"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Client
- Model: mistral:latest
- Game: public_goods
"""

from dataclasses import dataclass
from enum import Enum
import math
import numpy as np
from numpy.typing import NDArray
import random

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState




class Strategy_COLLECTIVE_1(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Adaptive Cooperation Strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_count = 0
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        self.last_opponent_action = opponent_actions[-1]
        if opponent_actions.sum() == 0:
            return Action.C if state.round_number == self.game_description.n_rounds - 1 else Action.D
        if self.last_opponent_action and opponent_actions.sum() >= self.game_description.n_players // 2:
            self.cooperation_count = max(0, self.cooperation_count - 3)
        self.cooperation_count += 1 if opponent_actions[-1] else -1
        return Action.C if self.cooperation_count > 0 else Action.D

class Strategy_COLLECTIVE_2(BaseStrategy):
    """
    The Tit-for-Tat Adaptive Cooperation (TFT-A) strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.threshold = 0.7

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.history.append({'actions': [action for action in history.opponent_actions[-1]] if state.round_number > 0 else [], 'payoffs': history.my_payoffs[-1] if state.round_number > 0 else None})
        total_cooperators = sum(history.opponent_actions[-1])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if total_cooperators == self.game_description.n_players:
            return Action.C
        elif total_cooperators > 0:
            return Action.C if state.round_number < self.game_description.n_rounds - 1 else Action.D
        else:
            opponents_actions = self.history[-1]['actions']
            if all((opponent == Action.C for opponent in opponents_actions)) or all((opponent == Action.D for opponent in opponents_actions)):
                return Action.C if opponents_actions[0] == Action.C else Action.D
            else:
                if sum((1 for opponent in opponents_actions if opponent == Action.C)) > len(opponents_actions) * self.threshold:
                    return Action.C
                return Action.D

class Strategy_COLLECTIVE_3(BaseStrategy):
    """Adaptive Tit-for-Tat strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            cooperators = np.sum(history.opponent_actions[-1])
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_4(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game.
    Balances cooperation and defection while being adaptable to various opponent behaviors and game parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = game_description.n_rounds - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
        last_action = opponent_actions[-1] if len(opponent_actions) > 0 else Action.D
        return Action.C if last_action == Action.C else Action.D if state.round_number < self.last_round else Action.C

class Strategy_COLLECTIVE_6(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Generosity (TfTA) Strategy
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        my_action = Action.D
        if state.round_number > 1:
            prev_action = history.my_actions[-1]
            total_contributions = np.sum(history.opponent_actions[-1])
            if prev_action == Action.C:
                if total_contributions > self.game_description.n_players // 2:
                    my_action = Action.C
                else:
                    p = self.k - total_contributions / self.game_description.n_players
                    if p > 0 and random.random() < p:
                        my_action = Action.C
            elif prev_action == Action.D:
                p = self.k * (self.game_description.n_players - total_contributions) / self.game_description.n_players
                if p > 0 and random.random() < p:
                    my_action = Action.C
        return my_action

class Strategy_COLLECTIVE_7(BaseStrategy):
    """
    An adaptive strategy based on Tit for Tat for N-Player Public Goods Game, encouraging cooperation among players and reciprocity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None and self.last_opponent_action is not None:
            last_opponent_action = self.last_opponent_action
        else:
            last_opponent_action = history.opponent_actions[-1][0] if history else None
        self.last_opponent_action = last_opponent_action
        return Action(int(last_opponent_action == Action.C))

class Strategy_COLLECTIVE_8(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(game_description.n_players * 0.75)
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.threshold:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_9(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive contribution for N-Player Public Goods Game.
    This strategy cooperates initially and then mimics the most cooperative player from the previous round.
    If no players have cooperated, it defects as a punishment. In the last round, it cooperates as a gesture of goodwill.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.most_cooperative_player = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif self.most_cooperative_player is not None and history.opponent_actions[state.round_number - 1, self.most_cooperative_player] == Action.C:
            return Action.C
        else:
            if history.opponent_actions[-1, :].sum() > 0:
                self.most_cooperative_player = random.choice(np.flatnonzero(history.opponent_actions[-1, :]))
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_10(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Time Discounting and Multiplayer Enhancements (ADMT) strategy.
    Encourages cooperation while being adaptable to various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperation_rate = None
        self.round_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return np.random.choice([Action.C, Action.D])
        if not self.round_history:
            self.average_cooperation_rate = history.my_actions[0]
            self.round_history.append(self.average_cooperation_rate)
        cooperators = np.sum(history.opponent_actions[-1])
        cooperation_rate = (len(self.round_history) * self.average_cooperation_rate + cooperators) / (len(self.round_history) + 1)
        self.round_history.append(cooperation_rate)
        if cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_11(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_round_cooperation = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_round_cooperation = None
            return Action.C
        self.previous_round_cooperation = np.mean(history.my_actions[-1])
        return Action(self.previous_round_cooperation == 1)

class Strategy_COLLECTIVE_12(BaseStrategy):
    """
    Tit-for-Tat with Cooperative Adjustment (TTCA) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.s = math.ceil(math.log2(game_description.n_players))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        actions = np.zeros(state.round_number, dtype=bool)
        actions[state.round_number - 1] = Action(history.my_actions[-1])
        consecutive_defections = 0
        for i in range(state.round_number - 1, max(state.round_number - self.s - 1, 0), -1):
            if actions[i] == Action.D:
                consecutive_defections += 1
            elif actions[i] == Action.C:
                consecutive_defections = 0
        return Action.C if history.opponent_actions[state.round_number - 1, :].mean() > (self.game_description.n_players - 1) / self.game_description.n_players or consecutive_defections >= self.s else Action.D

class Strategy_COLLECTIVE_13(BaseStrategy):
    """
    Strategy name: Tit-for-Tat Adaptive Cooperation (TFT-AC)
    Strategy summary: A strategy that prioritizes long-term gains over immediate ones by promoting cooperation when possible but punishing defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions = 0
        self.private_payoffs = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self._update_totals(history)
        cooperator_count = sum(history.opponent_actions[-1, :])
        if cooperator_count >= self.game_description.n_players // 2:
            return Action.C
        elif cooperator_count == 1:
            return Action.D
        return Action.C

    def _update_totals(self, history: PlayerHistory):
        self.total_contributions += np.sum(history.opponent_actions[:, -1])
        self.private_payoffs += np.sum(history.my_payoffs)

class Strategy_COLLECTIVE_14(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    Initialises with a cooperation threshold and adjusts it based on the number of cooperators in previous rounds.
    Cooperates more frequently when observing high levels of cooperation, but also punishes defection by retaliating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        super().__init__(game_description)
        self._cooperation_threshold = int(math.ceil(game_description.n_players * 0.5))
        self._ct_increment = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1] if history else np.zeros(self.game_description.n_rounds - 1))
        if cooperators >= self._cooperation_threshold:
            self._cooperation_threshold += self._ct_increment
        return Action.C if cooperators >= self._cooperation_threshold else Action.D

class Strategy_COLLECTIVE_15(BaseStrategy):
    """
    A Tit-for-Tat strategy with gradient adjustment that cooperates in the initial round, retaliates when an opponent defects, and gradually eases back into cooperation after conflicts.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_number = 0
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.round_number = state.round_number
        if history is not None:
            self.consecutive_defections = sum(history.opponent_actions[:, -1]) if history else 0
        if history is not None and self.round_number == len(history.opponent_actions) - 1:
            cooperators = sum(history.opponent_actions[-1, :])
            if self.consecutive_defections > 0 and cooperators < self.game_description.n_players // 2:
                return Action.D
            else:
                return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if history is None or self.consecutive_defections == 0:
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        elif self.consecutive_defections > 0 and cooperators >= self.game_description.n_players // (self.consecutive_defections + 1):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_16(BaseStrategy):
    """
    A Tit-for-Tat strategy with a twist for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-self.game_description.n_rounds:].sum(axis=0) > self.n_players // 2)
        if cooperators > self.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_19(BaseStrategy):
    """
    Tit-for-Tat-K (TfT-K) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.is_final_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.last_opponent_action = None
            self.is_final_round = False
            return Action.C
        if self.is_final_round or history.opponent_actions[-1, :].all():
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[:, -1]) == 1
        cooperators = np.count_nonzero(history.opponent_actions[:, -1])
        if self.last_opponent_action:
            return Action.C if cooperators >= (self.game_description.n_players + 1) // 2 else Action.D
        else:
            return Action.D if cooperators > 0 else Action.C
        self.is_final_round = state.round_number == self.game_description.n_rounds - 1

class Strategy_COLLECTIVE_20(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    Summary: This strategy cooperates in the first round and mimics the actions of the previous round by each player. If everyone cooperated in the last round, continue to cooperate. If at least one player defected, also defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == 0 or not self.history:
            return Action.C
        if all(self.history[state.round_number - 1]):
            return Action.C
        elif any(not self.history[state.round_number - 1]):
            return Action.D
        else:
            return Action.C

    def update_history(self, state: GameState, my_action: Action) -> None:
        """
        Update the strategy's history with the current player's action.
        """
        if state.round_number not in self.history:
            self.history[state.round_number] = [None] * self.game_description.n_players
        self.history[state.round_number][self.__class__.__name__.lower()] = my_action

class Strategy_COLLECTIVE_21(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperative threshold that considers average contributions and variance from previous rounds to determine cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_length = game_description.n_rounds - 1
        self.average_contributions = np.zeros(self.history_length)
        self.variance = np.zeros(self.history_length)
        self.cooperation_threshold = np.zeros(self.history_length)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.D
        cooperators = np.sum(history.opponent_actions[-1, :])
        total_contributions = np.sum(history.opponent_actions[:, -1])
        self.average_contributions = np.roll(self.average_contributions, 1)
        self.variance = np.roll(self.variance, 1)
        self.average_contributions[-1] = total_contributions / self.history_length
        variance = np.sqrt(self.variance[-1] * (self.history_length - 1) / self.history_length + (total_contributions - np.sum(self.average_contributions)) ** 2 / (self.history_length * (self.history_length - 1)))
        cooperation_threshold = self.game_description.k * (self.average_contributions[-1] + variance)
        if cooperators >= cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_22(BaseStrategy):
    """
    A Tit-for-Tat (TFT) Strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        elif not history and state.round_number > 1:
            self.last_round = state.round_number - 1
            action = Action.C if history.opponent_actions[-self.last_round, :].sum() == self.game_description.n_players else Action.D
        elif not history and state.round_number == self.last_round:
            action = Action.C if history.opponent_actions[-1, :].sum() >= self.game_description.n_players // 2 else Action.D
        elif not history:
            action = self.last_round_decision(state.round_number - 1, history.opponent_actions[-self.last_round, :])
        else:
            action = self.last_round_decision(state.round_number, history.opponent_actions[-1, :])
        return action

    def last_round_decision(self, round_number: int, previous_opponents_actions: NDArray[np.bool_]) -> Action:
        """
        Decides the action for a given round based on the opponent's actions in the previous round.
        """
        cooperators = previous_opponents_actions.sum()
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_23(BaseStrategy):
    """
    Implementation of the Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.own_action_history = np.zeros(game_description.n_rounds)
        self.previous_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.own_action_history = np.append(self.own_action_history, history.my_actions[-1])
            self.previous_round_cooperators = int(np.sum(history.opponent_actions[-1]))
        if self.own_action_history[0] == Action.C and self.previous_round_cooperators > 0:
            return Action.C
        elif self.own_action_history[-1] != Action.C or (self.own_action_history[-1] == Action.C and self.previous_round_cooperators == 0):
            return Action.D

class Strategy_COLLECTIVE_24(BaseStrategy):
    """
    A strategy that follows the principles of Tit-for-Tat Adaptive Cooperation (TFT-AC) in N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2)), np.zeros(1), np.zeros((self.game_description.n_players, 1)), np.zeros(1))
        self.forgiveness_waiting_period = math.ceil(self.game_description.n_players / 2)
        self.consistent_cooperator_threshold = math.floor(self.game_description.n_players * 0.75)
        self.consistent_defector_threshold = math.floor(self.game_description.n_players * 0.25)
        self.round_number = 0
        self.T = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state is None or history is None:
            return Action.C
        if self.round_number == 0:
            return Action.C
        self.history = history
        self.round_number = state.round_number
        opponent_behavior = self.get_opponent_behavior()
        current_round_opponent_behavior = self.get_current_round_opponent_behavior()
        if current_round_opponent_behavior == Action.C:
            return Action.C
        if current_round_opponent_behavior == Action.D and self.forgiveness_met():
            return Action.C
        if self.consistent_cooperator(opponent_behavior):
            if self.round_number == self.game_description.n_rounds or (self.remaining_rounds() > self.T and (not self.last_round_punishment())):
                return Action.C
            else:
                return Action.D
        if self.consistent_defector(opponent_behavior):
            if self.last_round_punishment():
                return Action.D
        return Action.D

    def get_opponent_behavior(self) -> NDArray[np.bool_]:
        return np.mean(self.history.opponent_actions[:, self.__class__], axis=0)

    def get_current_round_opponent_behavior(self) -> bool:
        return self.history.opponent_actions[-1, 0]

    def forgiveness_met(self) -> bool:
        return self.round_number - self.history.my_payoffs.size - self.forgiveness_waiting_period >= 0

    def consistent_cooperator(self, opponent_behavior: NDArray[np.bool_]) -> bool:
        return np.sum(opponent_behavior) <= self.consistent_defector_threshold

    def consistent_defector(self, opponent_behavior: NDArray[np.bool_]) -> bool:
        return np.sum(1 - opponent_behavior) <= self.consistent_cooperator_threshold

    def last_round_punishment(self) -> bool:
        return self.round_number == self.game_description.n_rounds or (self.remaining_rounds() <= self.T and self.consistent_defector(self.get_opponent_behavior()))

    def remaining_rounds(self) -> int:
        return self.game_description.n_rounds - self.round_number

class Strategy_COLLECTIVE_26(BaseStrategy):
    """
    An adaptive Tit-for-Tat strategy for the N-player public goods game.
    The strategy cooperates in the first round and adapts its behavior based on the previous round's total contributions, promoting cooperation when the majority contributes and punishing defection when it undermines the common good.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_contributions_prev = sum(history.opponent_actions[-1])
        if total_contributions_prev == self.game_description.n_players:
            return Action.C
        elif total_contributions_prev == 0:
            return Action.D
        else:
            return Action.C if total_contributions_prev >= self.game_description.n_players // 2 else Action.D

class Strategy_COLLECTIVE_27(BaseStrategy):
    """
    Implementation of the Tit-for-Tat (TFT) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < state.round_number + 1:
            return Action.C
        my_action = history.my_actions[state.round_number - 1]
        previous_opponent_action = history.opponent_actions[state.round_number - 1, 0]
        self.consecutive_defections = 0 if state.round_number == 1 else self.consecutive_defections + int(previous_opponent_action != my_action)
        if previous_opponent_action == Action.C:
            return Action.C
        elif previous_opponent_action == Action.D:
            return Action.D
        elif self.consecutive_defections >= self.game_description.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_28(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game strategy
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = history.my_actions[-1]
        cooperators = np.sum(history.opponent_actions[-1])
        if np.all(last_round):
            return Action.C
        elif last_round and (not np.any(~history.opponent_actions[-1])):
            return Action.D
        elif ~last_round and np.all(history.opponent_actions[-1]):
            return Action.C
        else:
            return Action.C

    def update_state(self, state: GameState, payoff: float) -> None:
        self.history.my_payoffs[state.round_number] = payoff
        self.history.my_actions[state.round_number] = self.__class__ == self.history.opponent_strategy

    def update_opponents(self, opponents: list[BaseStrategy], state: GameState):
        for opponent in opponents:
            if opponent != self and opponent.game_description == self.game_description:
                opponent_history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, len(opponents))), np.zeros((self.game_description.n_rounds, len(opponents))))
                opponent.update_state(state, opponent_history)
                self.history.opponent_actions[state.round_number] = opponent.history.my_actions[state.round_number].flatten()
                self.history.opponent_payoffs[state.round_number] = opponent.history.my_payoffs[state.round_number]

class Strategy_COLLECTIVE_29(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive contribution for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k_history = np.zeros(game_description.n_rounds)
        self.punishment_threshold = math.ceil(game_description.n_players / 2)
        self.forgiveness_threshold = math.floor((game_description.k - 1) * (game_description.n_players - 1))
        self.contribution_level = np.zeros(game_description.n_rounds)
        self.history = PlayerHistory(my_actions=np.array([[Action.C]], dtype=np.bool), my_payoffs=np.array([0.0], dtype=np.float64), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.float64))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.history = history
            return Action.C
        self.k_history[state.round_number] = np.mean(history.opponent_actions[-1]) * (self.game_description.n_players - 1) + 1
        self.contribution_level[state.round_number] = self.k_history[state.round_number] * (self.k_history[state.round_number] - 1) / ((self.game_description.n_players - 1) * (self.game_description.k - 1))
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.punishment_threshold:
            return Action.C
        elif self.forgiveness_threshold > state.round_number and history.my_payoffs[-1] < self.contribution_level[state.round_number] * self.game_description.k:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_30(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)
    Strategy Description: Mimic opponent's actions from the previous round. If they cooperated, cooperate; if they defected, also defect.
                           Include a forgiveness mechanism that resets cooperation after a certain number of consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = math.ceil(game_description.n_players / 3)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_round = state.round_number - 1 if history is not None else 0
        last_opponent_action = history.opponent_actions[current_round, 0] if history is not None else None
        forgiveness_reset = current_round + 1 >= state.round_number or (last_opponent_action is None and current_round >= self.forgiveness_counter)
        action = Action.C if forgiveness_reset or last_opponent_action == Action.C else Action.D
        return action

class Strategy_COLLECTIVE_31(BaseStrategy):
    """
    A strategy for N-Player Public Goods Game using Tit-for-Tat Adaptive (TFTA).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round = state.round_number
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if cooperators > self.game_description.n_players // 2:
            return Action.C
        elif self.round != self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_33(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_phase = int(self.game_description.n_rounds * 0.1)
        self.punishment_length = 5
        self.cooperate_threshold = math.ceil(self.game_description.n_players / 2)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number <= self.initial_phase:
            return Action.C
        elif history:
            current_cooperators = np.sum(history.opponent_actions[-1])
            if current_cooperators >= self.cooperate_threshold:
                return Action.C
            opponent_defection_streak = sum((1 for action in history.opponent_actions[:, 0][-self.punishment_length:] if action))
            if opponent_defection_streak >= self.punishment_length:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_35(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Community Factor (ATFC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.current_action = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return self.current_action
        previous_round = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=np.bool_)
        total_contributors_prev = sum(previous_round)
        ratio_contributors = float(total_contributors_prev) / self.game_description.n_players
        if self.current_action == Action.C and total_contributors_prev <= ratio_contributors:
            self.current_action = Action.D
            return self.current_action
        else:
            self.current_action = Action.C
            return self.current_action

class Strategy_COLLECTIVE_36(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = [1] * game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1]) if history is not None else self.game_description.n_players
        action = Action.C if total_contributions == self.game_description.n_players else Action.D
        return action if state.round_number < self.game_description.n_rounds - 1 else Action.C

class Strategy_COLLECTIVE_37(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for N-Player Public Goods Game.
    This strategy encourages cooperation, mirrors opponents' behavior and offers initial goodwill.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.num_consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.num_consecutive_defections = 0
            opponent_cooperators_in_last_round = sum(history.opponent_actions[state.round_number - 1, :])
            if opponent_cooperators_in_last_round >= self.game_description.n_players // 2:
                return Action.C
            if opponent_cooperators_in_last_round == 0 and self.num_consecutive_defections > self.game_description.n_players // 2:
                self.num_consecutive_defections += 1
                return Action.D
            self.num_consecutive_defections += 1 if history.opponent_actions[state.round_number - 1, :].all() else 0
        return Action.C if self.num_consecutive_defections > 0 else Action.D

class Strategy_COLLECTIVE_38(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game. The strategy encourages cooperation and maintains a responsive approach towards other players' actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            previous_round = history.opponent_actions[-1]
            cooperators = np.sum(previous_round)
            if cooperators > 0:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_39(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defect_count = 0
        self.last_round_action = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return self.last_round_action
        cooperators = np.sum(history.opponent_actions[-1]) if history is not None else 0
        total_players = self.game_description.n_players
        if cooperators == 0:
            if self.defect_count > 0:
                self.last_round_action = Action.D
                if state.round_number - self.defect_count >= self.game_description.n_rounds:
                    self.defect_count = 0
            else:
                self.defect_count += 1
                self.last_round_action = Action.D
        elif cooperators == total_players:
            self.defect_count = 0
            self.last_round_action = Action.C
        else:
            self.last_round_action = Action.C if self.defect_count > 0 and state.round_number - self.defect_count >= self.game_description.n_rounds else Action.D
        return self.last_round_action

class Strategy_COLLECTIVE_40(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy in the N-Player Public Goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance_factor = game_description.n_players // 2
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if state.round_number == 1:
            return Action.C
        cooperators = np.sum(history.opponent_actions[:, -1])
        actions = len(self.history) + cooperators
        if actions >= self.tolerance_factor and history.my_actions[-1] == Action.D:
            return Action.C
        elif actions < self.tolerance_factor and history.my_actions[-1] == Action.C:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_41(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    The strategy aims to foster an environment where players recognize the benefits of cooperation and are incentivized to reciprocate positive interactions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        total_players = self.game_description.n_players
        if state.round_number == 1:
            defectors = cooperators
        else:
            defectors = total_players - cooperators
        p = min(self.p * (defectors / total_players), 1)
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        if cooperators > total_players // 2:
            return Action.C
        elif random.random() <= p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_42(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game.
    This strategy cooperates with others when the majority of players contribute to the public good, and defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.players_history = [[0] * game_description.n_rounds for _ in range(game_description.n_players)]

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperation_count = sum(history.opponent_actions[-1]) if history else 0
        if cooperation_count >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_43(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

    Strategy Description: A cooperative strategy that cooperates in the first round and adapts its cooperation based on the average number of cooperators in previous rounds. The strategy punishes defection to encourage others to follow the cooperative spirit, while also maintaining a balanced and sustainable level of collective cooperation over time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.moving_average_window = math.ceil(self.game_description.n_rounds * 0.2)
        self.moving_average = np.zeros(int(self.moving_average_window))
        self.cooperated_last = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_cooperators = sum(history.opponent_actions[-1]) if history is not None else 0
        self.moving_average = np.roll(self.moving_average, -1)
        self.moving_average[int(self.moving_average_window) - 1] = current_cooperators
        average_cooperation = np.mean(self.moving_average)
        if history is not None and self.cooperated_last and (current_cooperators >= int(average_cooperation)):
            return Action.C
        self.cooperated_last = False
        return Action.D

class Strategy_COLLECTIVE_44(BaseStrategy):
    """
    A simple implementation of the Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        action = Action.C if cooperators > 0 else Action.D
        if random.random() < self.p and action == Action.D:
            action = Action.C
        return action

class Strategy_COLLECTIVE_45(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.decision = [Action.C]

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return self.decision[0]
        my_cooperation = self.decision[-1] if history is not None else False
        opponent_cooperation = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if my_cooperation and opponent_cooperation >= (self.game_description.n_players - 1) // 2:
            self.decision.append(Action.C)
        else:
            self.decision.append(Action.D)
        return self.decision[-1]

class Strategy_COLLECTIVE_46(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros((game_description.n_rounds,), dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state is not None:
            self.current_round = state.round_number
            if self.history.opponent_actions[-1].size == 0 or self.history.my_actions[-1].size == 0:
                self.history.update(self, history)
        action = Action.D
        if self.current_round > 0 and self.current_round < self.game_description.n_rounds:
            cooperators = np.sum(self.history.opponent_actions[-min(3, self.current_round):-1])
            if cooperators > self.game_description.n_players // 2:
                action = Action.C
                self.history.my_actions[self.current_round] = True
            elif self.current_round == 1 or np.sum(self.history.opponent_actions[-3:, -1]) > self.game_description.n_players // 2:
                action = Action.C
                self.history.my_actions[self.current_round] = True
        return action

class Strategy_COLLECTIVE_47(BaseStrategy):
    """
    A Tit-for-Tat-with-Variation (TFT-V) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.d_penalty_rounds = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_state = history.opponent_actions[last_round, :] if last_round >= 0 else np.zeros(self.game_description.n_players)
        if np.sum(last_state) == 0:
            punishment_round = min(last_round + 1, state.round_number - self.d_penalty_rounds)
            if punishment_round < state.round_number:
                return Action.D
        else:
            forgiveness_round = min(last_round + self.d_penalty_rounds, state.round_number - 1)
            if forgiveness_round >= last_round:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_48(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFTAC) strategy in a N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = -1
        self.opponent_cooperated_last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number > self.last_round and history is not None):
            self.last_round = state.round_number
            self.opponent_cooperated_last_round = False
            return Action.C
        if state.round_number == self.last_round + 1:
            self.opponent_cooperated_last_round = history.opponent_actions[self.last_round, :].all()
            return Action(int(self.opponent_cooperated_last_round))
        self.last_round = state.round_number
        return Action(int(self.opponent_cooperated_last_round))

class Strategy_COLLECTIVE_49(BaseStrategy):
    """
    The Tit-for-Tat with Adaptation (TfTA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.half_n = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        personal_history = history.my_actions if history else np.zeros(1, dtype=bool)
        current_cooperation = np.sum(personal_history)
        half_opponents_cooperated = current_cooperation >= self.half_n and np.mean(history.opponent_actions[-1]) >= self.half_n
        if half_opponents_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_50(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        cooperators = np.sum(opponent_actions)
        current_action = self.last_opponent_action if self.last_opponent_action is not None else Action.C
        if cooperators >= self.game_description.n_players // 2:
            current_action = Action.C
        elif current_action == Action.D and opponent_actions[-1] != opponent_actions[-2]:
            current_action = Action.D
        self.last_opponent_action = current_action
        return current_action

class Strategy_COLLECTIVE_51(BaseStrategy):
    """A Tit-for-Tat Evolution strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_payoff = 0.0
        self.avg_payoff = 0.0
        self.prev_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None:
            self.prev_opponent_action = Action.C
        else:
            self.prev_opponent_action = history.opponent_actions[-1, -1]
        action = Action.C if self.prev_opponent_action else Action.D
        payoff = 0.0
        total_contributions = 0
        for round_ in range(state.round_number):
            contributions = sum(history.opponent_actions[round_, :])
            if round_ < state.round_number - 1:
                payoff += 1 - action.value + self.game_description.k / self.game_description.n_players * contributions
            else:
                payoff += 1 - action.value + self.game_description.k / self.game_description.n_players * contributions if not np.isclose(payoff, self.avg_payoff) else action.value
                total_contributions += contributions
        self.total_payoff = payoff
        self.avg_payoff = self.total_payoff / state.round_number
        if state.round_number == self.game_description.n_rounds:
            if np.all(history.opponent_actions[-1, :] == history.opponent_actions[-2, :]) or total_contributions == 0:
                action = Action.C
        return action

class Strategy_COLLECTIVE_53(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFTA)

    This strategy cooperates initially and then responds to the opponent's previous action in each round.
    If the most recent round was favorable for cooperation, it continues cooperating; otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_previous_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.my_previous_action = Action.C
            return self.my_previous_action
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2 and self.my_previous_action == Action.C:
            self.my_previous_action = Action.C
        elif self.my_previous_action == Action.C:
            self.my_previous_action = Action.D
        else:
            self.my_previous_action = Action.C
        return self.my_previous_action

class Strategy_COLLECTIVE_54(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(math.floor(game_description.n_players / 2))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None and state.round_number < self.game_description.n_rounds:
            total_contributions = sum(history.opponent_actions[-self.game_description.n_rounds:, -1])
            if total_contributions / self.game_description.n_players < self.threshold:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_55(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptation strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_window = int(math.floor((game_description.n_rounds + 1) / 2))
        self.opponent_cooperators = np.zeros(self.history_window, dtype=np.int32)
        self.opponent_defectors = np.zeros(self.history_window, dtype=np.int32)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_opponent_action = history.opponent_actions[state.round_number - 1, state.round_number % len(history.opponent_payoffs)]
        self.opponent_cooperators[(state.round_number + self.history_window - 1) % self.history_window] = 1 if current_opponent_action else 0
        self.opponent_defectors[(state.round_number + self.history_window - 1) % self.history_window] = 1 - current_opponent_action
        cooperation_count = np.sum(self.opponent_cooperators)
        defection_count = np.sum(self.opponent_defectors)
        return Action.C if cooperation_count > defection_count else Action.D

class Strategy_COLLECTIVE_56(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_opponent_action is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1, -1]
        return Action(history.opponent_actions[-1, -1]) if history.opponent_actions[-1, -1] == self.last_opponent_action else Action.D

class Strategy_COLLECTIVE_57(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    This strategy cooperates initially, then adapts to the opponent's cooperation history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_phase = int(self.game_description.n_rounds * 0.1)
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.punishment_phase:
            return Action.D
        cooperation = np.mean(history.opponent_actions[-self.game_description.n_rounds:-1, -1])
        if cooperation >= 0.5:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_59(BaseStrategy):
    """
    Strategy name: Tit-for-Tat Adaptive Cooperation (TFT-AC)
    Summary: A cooperative strategy that reciprocates cooperation and punishes defection, with adaptability to changing opponent behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.history.my_actions[state.round_number - 1] = True
        opponent_cooperators = sum(self.history.opponent_actions[-1, :])
        if opponent_cooperators >= self.game_description.n_players // 2 + 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_60(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TfT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.most_frequent_cooperators = np.zeros(game_description.n_players, dtype=int)
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 or len(self.opponent_history) < self.game_description.n_rounds:
            return Action.C
        self.update_opponent_history(history)
        most_frequent_cooperators = self.count_cooperations_in_history()
        if len(most_frequent_cooperators) > 1:
            return Action.C
        else:
            return most_frequent_cooperators[0]

    def update_opponent_history(self, history: PlayerHistory):
        if len(self.opponent_history) < self.game_description.n_rounds:
            self.opponent_history.append([{i: action for i, action in enumerate(history.opponent_actions[state.round_number - 1])}])
        else:
            self.opponent_history[-1] = {i: history.opponent_actions[state.round_number - 1][i] for i in range(self.game_description.n_players)}

    def count_cooperations_in_history(self) -> np.ndarray:
        cooperators = self.opponent_history[-1].values()
        return np.bincount(cooperators, minlength=2)

class Strategy_COLLECTIVE_61(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) with Public Goods Game Variation (ATFT-PGV) strategy.
    This strategy follows a reciprocal approach, rewarding cooperation and punishing defection in a public goods game setting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.C if self.first_round else Action.D
        self.first_round = False if state.round_number > 0 else True
        if state.round_number > 0 and history is not None:
            cooperators = sum(history.opponent_actions[-1, :])
            return Action.C if cooperators >= self.game_description.n_players // 2 or history.my_actions[-1] == Action.C else Action.D
        return action

class Strategy_COLLECTIVE_62(BaseStrategy):
    """
    A strategy that emulates Tit-for-Tat with adaptive cooperation. In the first round, cooperate to foster a cooperative environment. For subsequent rounds, observe and mimic the behavior of other players from the previous round. If an opponent cooperated in the previous round, cooperate; otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(self.opponent_history) == 0):
            return Action.C
        opponent_actions = np.array([history.opponent_actions[i] for i in range(state.round_number - 1)] if history is not None else self.opponent_history)
        last_round_cooperators = np.sum(opponent_actions[:, -1])
        adaptive_decision = Action.C if last_round_cooperators >= self.game_description.n_players // 2 else Action.D
        if history is not None:
            self.opponent_history.append(history.opponent_actions[-1])
        return adaptive_decision

class Strategy_COLLECTIVE_63(BaseStrategy):
    """
    A strategy that employs the Tit-for-Tat Adaptive Cooperation (TFT-AC) approach in N-player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.deviations = 0
        self.forgiveness_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None:
            self.deviations = sum(history.my_actions[:-1])
            self.forgiveness_count = 0
        if any(history.opponent_actions[-1]):
            self.forgiveness_count += 1
            return Action.D if self.forgiveness_count < self.deviations else Action.C
        return Action.C

class Strategy_COLLECTIVE_64(BaseStrategy):
    """
    Tit-for-Tat-Plus (TFT+) strategy for N-Player Public Goods Game, promoting cooperation while protecting against defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_frequencies = [0] * self.game_description.n_players
        self.last_round_cooperators = 0
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if not self.first_round:
            self.update_cooperation_frequencies(history)
            frequent_cooperator_index = self.find_frequent_cooperator()
            if frequent_cooperator_index != -1:
                action = history.opponent_actions[-1][frequent_cooperator_index]
        if not action and sum(history.opponent_actions[-1, :]) > self.game_description.n_players // 2:
            action = Action.C
        if not history:
            self.first_round = False
        else:
            self.last_round_cooperators = sum(history.opponent_actions[-1, :])
        return action

    def update_cooperation_frequencies(self, history: PlayerHistory):
        cooperators = history.my_actions[-1]
        if cooperators:
            self.cooperation_frequencies[int(cooperators)] += 1 / self.game_description.n_rounds
        else:
            for player in range(self.game_description.n_players):
                self.cooperation_frequencies[player] *= 1 - 1 / self.game_description.n_rounds

    def find_frequent_cooperator(self) -> int:
        max_frequency = max(self.cooperation_frequencies)
        max_players = []
        for player in range(self.game_description.n_players):
            if self.cooperation_frequencies[player] == max_frequency:
                max_players.append(player)
        return random.choice(max_players) if max_players else -1

class Strategy_COLLECTIVE_65(BaseStrategy):
    """
    Strategy name: Tit-for-Tat Plus (TFT+)
    A strategy that mimics the opponent's actions from the preceding round, encouraging cooperation while maintaining adaptability.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        else:
            cooperators = sum(history.opponent_actions[state.round_number - 1, :])
            if cooperators >= self.game_description.n_players // 2:
                action = Action.C
        self.history.my_actions[state.round_number] = action == Action.C
        return action

class Strategy_COLLECTIVE_66(BaseStrategy):
    """
    Tit-for-Tat (with Adaptive Generosity) strategy for the N-Player Public Goods Game.
    Cooperates in the first round to show goodwill, and adjusts cooperation based on opponent's previous actions and adaptive generosity threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2
        self.forgiveness_adjustment = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        consecutive_defections = sum((1 for round in range(state.round_number - self.forgiveness_adjustment, state.round_number) if all(history.opponent_actions[round, :] == [False] * len(history.opponent_actions[0]))))
        if consecutive_defections > self.threshold:
            forgiveness_adjustment = min(consecutive_defections - self.threshold, state.round_number)
            self.forgiveness_adjustment += forgiveness_adjustment
        else:
            self.forgiveness_adjustment = 0
        opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        if opponent_cooperators > self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_67(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.empty((self.game_description.n_rounds,), dtype=bool), my_payoffs=np.empty(self.game_description.n_rounds, dtype=float), opponent_actions=np.empty((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.empty((self.game_description.n_rounds, self.game_description.n_players), dtype=float))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number] = Action.C == self(GameState(0), None)
        cooperators = np.sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_68(BaseStrategy):
    """
    A strategy that mirrors the actions of the most frequent collaborator in the previous r-1 rounds, with an initial friendly gesture.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.most_frequent_cooperator = None
        self.player_strategy = {'cooperators': 0, 'defectors': 0}

    def update_strategy(self, actions: NDArray[np.bool_]):
        """
        Updates the strategy based on the current round's actions.
        """
        self.player_strategy['cooperators'] += np.sum(actions)
        self.player_strategy['defectors'] += (self.game_description.n_players - np.sum(actions)).astype(int)

    def get_most_frequent_cooperator(self, players: NDArray[np.int_]):
        """
        Returns the id of the most frequent collaborator among the given players.
        """
        max_cooperators = max(self.player_strategy['cooperators'], self.player_strategy['defectors'])
        candidates = players[self.player_strategy['cooperators'] >= max_cooperators - self.game_description.n_players + 1]
        if len(candidates) == 1:
            return candidates[0]
        elif len(candidates) > 1:
            return candidates[0]
        else:
            return None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.update_strategy(history.opponent_actions[-1])
        if not self.most_frequent_cooperator:
            return Action.D
        elif state.round_number < self.game_description.n_rounds - 1:
            if self.most_frequent_cooperator == history.my_id:
                return Action.C
            elif history.my_actions[-1] > history.my_nonaction[-1]:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_69(BaseStrategy):
    """Adaptive Tit-for-Tat with Modified Contribution (ATFC) strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.trust_threshold = int(self.game_description.n_players * 0.7)
        self.punishment_threshold = int(self.game_description.n_players * 0.3)
        self.punishment_phase = math.ceil(self.punishment_threshold / 2)
        self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((self.game_description.n_players, 1), dtype=bool), np.zeros((1,)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            self.history = PlayerHistory(np.array([[True]]), np.array([[0]]), np.zeros((self.game_description.n_players, 1)), np.zeros((1,)))
            return Action.C if state.round_number == 0 else Action.D
        self.history = history
        round_number = len(self.history.my_actions) - 1
        if round_number == 0:
            return Action.C
        total_contributions_prev = sum(self.history.opponent_actions[round_number, :])
        contribution_history = self.history.my_actions[:round_number + 1]
        if total_contributions_prev == self.game_description.n_players:
            return Action.C
        elif np.count_nonzero(contribution_history[-self.trust_threshold:]) == self.trust_threshold:
            contribution = 0.8 * (1 if contribution_history[-1] else 0)
        elif np.count_nonzero(contribution_history[-self.punishment_threshold - self.punishment_phase + 1:-self.punishment_phase + 1]) >= self.punishment_threshold:
            contribution = 0 if round_number < self.punishment_phase else 1
        else:
            contribution = not total_contributions_prev
        self.history.my_actions = np.append(self.history.my_actions, [contribution])
        return Action(int(contribution))

class Strategy_COLLECTIVE_70(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 10
        self.T = int(self.game_description.n_players * 0.6)
        self.average_cooperators = 0
        self.cooperation_decisions = [False] * self.p

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-self.p:])
        self.cooperation_decisions.append(bool(np.mean(self.cooperation_decisions)))
        if len(self.cooperation_decisions) > self.p:
            self.cooperation_decisions = self.cooperation_decisions[-self.p:]
        cooperating_average = np.mean(self.cooperation_decisions)
        return Action.C if cooperating_average >= self.T else Action.D

class Strategy_COLLECTIVE_71(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperative trend for the N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_cooperative_percentage = 100
        self.current_round = 1
        self.adaptive_cooperative_trend = 5 / 100
        self.cooperate_probability = self.initial_cooperative_percentage

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players)
        total_cooperators = sum(opponents_actions)
        if total_cooperators == self.game_description.n_players:
            self.cooperate_probability = min(self.cooperate_probability + self.adaptive_cooperative_trend, 95)
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.C
        else:
            self.cooperate_probability = max(self.cooperate_probability - self.adaptive_cooperative_trend, 5)
        if random.random() < self.cooperate_probability / 100:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_72(BaseStrategy):
    """
    A simple Tit-for-Tat Cooperative game strategy that encourages cooperation among players while punishing defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_cooperators = 0
        self.total_defectors = 0
        self.player_index = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.total_cooperators += np.sum(history.my_actions)
            self.total_defectors += np.count_nonzero(~history.my_actions)
        my_action = Action.C if history is not None and np.sum(history.opponent_actions[-1, :]) == self.game_description.n_players else Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            players_cooperated = sum(history.opponent_actions[state.round_number - 1, :])
            if my_action == Action.C and players_cooperated == self.game_description.n_players or (my_action == Action.D and players_cooperated > self.game_description.n_players // 2):
                return my_action
            elif players_cooperated == self.game_description.n_players:
                return Action.C
        elif self.total_cooperators <= self.total_defectors:
            return Action.D
        self.player_index = (state.round_number - 1) % self.game_description.n_players
        return my_action

class Strategy_COLLECTIVE_73(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)
    Strategy Summary: A cooperative strategy that punishes non-cooperative players while adapting to the game's dynamics.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_threshold = int(self.game_description.n_players * 0.5)
        self.history_length = 5

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-self.history_length:-1].flatten())
        total_players = self.game_description.n_players
        if cooperators >= self.contribution_threshold and cooperators == total_players:
            punishment_duration = self.game_description.n_rounds - state.round_number
        elif cooperators < self.contribution_threshold * 0.8 and cooperators > total_players * 0.2:
            punishment_duration = state.round_number + 1
        elif cooperators >= self.contribution_threshold:
            recent_cooperators = sum(history.opponent_actions[-self.history_length:-1].flatten() > 0)
            if recent_cooperators >= math.ceil(self.history_length * 0.5):
                punishment_duration = state.round_number + 1
            else:
                punishment_duration = state.round_number - 1
        elif cooperators <= total_players * 0.2:
            punishment_duration = min(state.round_number + 2, self.game_description.n_rounds)
        else:
            punishment_duration = state.round_number + 1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action(punishment_duration % 2)

class Strategy_COLLECTIVE_74(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_init = 0.5
        self.total_payoff = 0.0
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < self.p_init else Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            self.last_round = True
        else:
            self.last_round = False
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if self.last_round and cooperators >= self.game_description.n_players // 2:
            return Action.C
        my_action = Action.C if history is not None and history.my_actions[-1] == cooperators else Action.D
        if state.round_number > 1:
            if my_action == history.opponent_actions[state.round_number - 1, :].all():
                return my_action
        return my_action

class Strategy_COLLECTIVE_75(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Cooperative Adjustment (TFTC)
    Summary: This strategy cooperates in the first round and adjusts its actions based on the number of cooperators in previous rounds. It encourages reciprocity and cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.trust_level = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1]) if history else 0
        cooperative_probability = total_contributions / self.game_description.n_players
        if random.random() < cooperative_probability * self.trust_level:
            return Action.C
        return Action.D

    def update_trust_level(self, state: GameState):
        total_contributions = sum(state.opponent_actions[-1]) if state.opponent_actions else 0
        if total_contributions == self.game_description.n_players:
            self.trust_level = min(self.trust_level * 1.2, 1)
        elif any((a == Action.D for a in state.opponent_actions[-1] if state.opponent_actions)):
            self.trust_level = max(self.trust_level * 0.8, 0.2)

class Strategy_COLLECTIVE_77(BaseStrategy):
    """
    A strategy called Tit-for-Tat with Fading Memory (TFTF). It adopts a cooperative approach,
    mimicking the previous action of its opponent for the next r - 1 rounds, but gradually forgives past defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_length = self.game_description.n_players * self.game_description.n_rounds + 1
        self.fading_memory_threshold = int(self.history_length / 3)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.my_actions) < self.history_length:
            return Action.C
        last_action = history.my_actions[-1]
        last_three_actions = history.my_actions[-self.fading_memory_threshold:]
        if all(last_three_actions):
            return Action.C
        elif not any(last_three_actions) and len(history.my_actions) > self.fading_memory_threshold:
            return Action.C if not last_action else Action.D
        else:
            return last_action

class Strategy_COLLECTIVE_79(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(math.ceil(game_description.n_players * 0.6))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        total_cooperators = sum(history.opponent_actions[-1])
        if total_cooperators >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_80(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_history = []
        self.forgiveness_counter = 0
        self.last_action = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.round_history) == 0:
            self.last_action = Action.C
            self.round_history.append(len(history.opponent_actions[-1]) if history else 0)
        else:
            cooperators = sum(history.opponent_actions[-1, :]) if history else self.round_history[-1]
            if cooperators >= self.game_description.n_players // 2 and self.last_action == Action.D:
                self.forgiveness_counter = max(self.forgiveness_counter - 1, 0)
            elif self.last_action == Action.C and cooperators < self.game_description.n_players // 2:
                self.forgiveness_counter += 1
            if self.forgiveness_counter >= self.game_description.n_rounds:
                self.forgiveness_counter = 0
                self.last_action = Action.C
            self.round_history.append(cooperators)
            self.last_action = Action.D if cooperators < self.game_description.n_players // 2 else Action.C
        return self.last_action

class Strategy_COLLECTIVE_81(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if len(self.opponent_history) < state.round_number or state.round_number == self.game_description.n_rounds:
            return Action.C
        opponent_action = self.opponent_history[state.round_number - 1]
        self.opponent_history.append(opponent_action)
        if opponent_action:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_82(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Probability Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions = 0
        self.cooperation_score = 0
        self.defection_score = 0
        self.p = 1.0
        self.threshold = self.total_contributions * (1 - 1 / self.game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.opponent_actions is not None:
            total_cooperation = sum(history.opponent_actions[:, -1])
            total_defection = len(history.opponent_actions) - total_cooperation
            cooperation_score_threshold = self.total_contributions * (self.game_description.k / self.game_description.n_players)
            if total_cooperation > total_defection or (self.total_contributions < cooperation_score_threshold and random.random() < self.p):
                return Action.C
            self.p *= 0.95
        else:
            self.p = 1.0
        self.total_contributions += np.sum(history.my_actions) if history is not None else 0
        cooperation = history.my_actions[-1] if history is not None else False
        self.cooperation_score += cooperation * (self.game_description.k / self.game_description.n_players) if history is not None else 0
        self.defection_score += 1 - cooperation if history is not None else 0
        return Action(int(cooperation))

class Strategy_COLLECTIVE_83(BaseStrategy):
    """
    A Tit-for-Tat (TfT) strategy with Cooperative Adaptation for N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = [Action.D] * self.game_description.n_players
        self.M = int(self.game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is None or state.round_number < self.M:
            return self.history[-1]
        else:
            total_contributions = np.sum(history.opponent_actions[state.round_number - self.M:state.round_number, :])
            if total_contributions > 0:
                last_action = history.opponent_actions[-1, :].mean()
                return Action(last_action > 0.5)
            else:
                return Action.C

class Strategy_COLLECTIVE_84(BaseStrategy):
    """
    The Tit-for-Tat Adaptive Cooperation (TFTAC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.forgiveness_counter = 0
        self.last_opponent_action = Action.D

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 2 and self.game_description.n_rounds % 2 != 0:
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if self.last_opponent_action == Action.C and cooperators == len(history.opponent_actions[self.game_description.n_rounds - 1, :]):
                return Action.C
            elif self.last_opponent_action == Action.D:
                self.forgiveness_counter += 1
                if self.forgiveness_counter >= math.ceil(self.game_description.n_players / 2):
                    self.forgiveness_counter = 0
            else:
                self.forgiveness_counter = 0
            return Action.D

class Strategy_COLLECTIVE_85(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-A) strategy in the N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_history) == 0:
            return Action.C
        latest_opponent_action = self.opponent_history[-1] if len(self.opponent_history) > 0 else np.zeros(self.game_description.n_players, dtype=int)
        cooperators = sum(latest_opponent_action)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

    def update_history(self, opponent_actions: NDArray[np.bool_]) -> None:
        """Update the opponent history"""
        self.opponent_history.append(opponent_actions)

class Strategy_COLLECTIVE_86(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    Aims to foster a cooperative environment by starting cooperatively and adapting to opponents' behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.player_id = None
        self.opponent_history = np.zeros((self.game_description.n_rounds,), dtype=np.bool_)
        self.total_payoff = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.player_id = len(history) if history is not None else None
            return Action.C
        if history is None:
            self.opponent_history[state.round_number] = False
        self.opponent_history[state.round_number] = np.mean(self.opponent_history[:state.round_number])
        if state.round_number == self.game_description.n_rounds - 1:
            my_cooperators = np.sum(history.my_actions) if history is not None else 0
            opponent_cooperators = np.sum(self.opponent_history)
            payoff_if_cooperate = 1 - my_cooperators + self.game_description.k / self.game_description.n_players * opponent_cooperators
            payoff_if_defect = 1
            if payoff_if_cooperate > payoff_if_defect:
                return Action.C
        if history is not None and self.player_id is not None:
            if history.my_actions[-1] == self.opponent_history[-1]:
                return history.my_actions[-1]
        return Action.D

class Strategy_COLLECTIVE_88(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Generosity (TFT-AG) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_number = 0
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        self.generosity_counter = 0
        self.base_probability = 0.5
        self.generosity_modifier = 0.2
        self.last_round_modifier = 0.1
        self.reciprocation_reset = self.game_description.n_players
        self.threshold = math.ceil(self.generosity_counter * (1 + self.generosity_modifier))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return Action.C
        self.round_number = state.round_number
        self.history = history or self.history
        if self.round_number % self.reciprocation_reset == 0 or self.generosity_counter >= self.threshold:
            self.generosity_counter = 0
        else:
            self.generosity_counter += 1
        generosity_factor = self.generosity_modifier * (1 - self.base_probability) if self.generosity_counter >= self.threshold else 0
        base_probability = self.base_probability + generosity_factor
        if state.round_number == self.game_description.n_rounds - 1:
            base_probability *= self.last_round_modifier
        opponent_action = self.history.opponent_actions[-1, (self.game_description.n_players + self.__class__.__name__.lower().find('tft') - 1) % self.game_description.n_players]
        if opponent_action:
            return Action.C
        else:
            return Action(int(random.random() <= base_probability))

class Strategy_COLLECTIVE_89(BaseStrategy):
    """
    The Adaptive Tit-for-Tat (ATfT) strategy encourages cooperation by following a reciprocal approach that rewards those who cooperate and punishes those who defect. This strategy seeks to create a stable equilibrium where most players cooperate, as it is in everyone's long-term interest to do so.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = np.zeros((game_description.n_rounds,), dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.history = np.roll(self.history, -1)
        cooperators = sum(self.history)
        if len(self.history) == self.game_description.n_players:
            cooperators -= self.history[0]
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_91(BaseStrategy):
    """
    Strategy that mirrors the initial cooperative behavior of opponents and adapts to defection when necessary,
    promoting a collaborative environment in N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance_threshold = int(math.ceil(game_description.n_players / 2))
        self.min_cooperators_threshold = math.floor(game_description.n_players * 0.5)
        self.current_defection_streak = 0
        self.previous_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C if random.random() > 0.5 else Action.D
        if history is not None:
            current_opponent_action = history.opponent_actions[-1, -1] if len(history.opponent_actions) > 0 else self.previous_opponent_action
            if current_opponent_action is None:
                self.previous_opponent_action = history.opponent_actions[0, -1] if len(history.opponent_actions) > 0 else None
                return Action.C if self.previous_opponent_action == Action.C else Action.D
            self.previous_opponent_action = current_opponent_action
            cooperators = sum(history.opponent_actions[-1, :])
            number_of_opponents = len(history.opponent_actions) if len(history.opponent_actions) > 0 else 0
            if current_opponent_action == Action.C and cooperators < self.min_cooperators_threshold:
                self.current_defection_streak = max(self.tolerance_threshold, self.current_defection_streak + 1)
            elif current_opponent_action == Action.D:
                self.current_defection_streak = 0
            if cooperators >= number_of_opponents or self.current_defection_streak > self.tolerance_threshold:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_92(BaseStrategy):
    """
    A simple Tit-for-Tat strategy for N-player Public Goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round_decision = random.choice([Action.C, Action.D])
        self.defection_penalty = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return self.first_round_decision
        cooperators = sum(history.opponent_actions[-1, :])
        action = Action.C if cooperators >= self.game_description.n_players // 2 else Action.D
        if history and np.any(history.my_actions != action):
            action = Action.D if action == self.defection_penalty else action
            self.defection_penalty += 1
            if self.defection_penalty > self.game_description.n_players:
                self.defection_penalty = 1
        return action

class Strategy_COLLECTIVE_93(BaseStrategy):
    """
    Tit-for-Tat (TFt) with Cooperative Adaptation (TFT-CA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            if self.opponent_history is None or len(self.opponent_history) < state.round_number:
                self.opponent_history = np.zeros((state.round_number,), dtype=bool)
            self.opponent_history[state.round_number - 1] = history.opponent_actions[-1, 0]
            if self.opponent_history[-1]:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_94(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    Strategy summary: A strategy that cooperates initially and follows the Tit-for-Tat pattern, while adapting contribution levels based on cooperation outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_level = 1.0
        self.last_opponent_cooperation = False
        self.min_contribution = 0.0
        self.max_contribution = self.game_description.k * self.game_description.n_players - 1
        self.last_round = False
        self.defector_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        elif state.round_number == 0:
            self.last_opponent_cooperation = False
            self.defector_streak = 0
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if state.round_number == len(history.my_payoffs) and (not self.last_round):
                self.last_round = True
                return Action.C
            elif self.last_opponent_cooperation:
                contribution = min(self.max_contribution, max(self.min_contribution, self.contribution_level + 0.1))
                self.contribution_level = contribution
                return Action.C
            elif cooperators > self.game_description.n_players // 2:
                self.last_opponent_cooperation = True
                self.defector_streak = 0
                self.contribution_level = min(self.max_contribution, max(self.min_contribution, self.contribution_level + 0.1))
                return Action.C
            elif cooperators == 0:
                self.last_opponent_cooperation = False
                self.defector_streak += 1
                if self.defector_streak >= self.game_description.n_players:
                    contribution = max(self.min_contribution, self.contribution_level - 0.1)
                    self.contribution_level = contribution
            else:
                self.last_opponent_cooperation = False
                self.defector_streak = 0
                self.contribution_level = min(self.max_contribution, max(self.min_contribution, self.contribution_level - 0.1))
            return Action.D

class Strategy_COLLECTIVE_96(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_actions = np.zeros(game_description.n_players, dtype=bool)
        self.last_round_payoffs = np.zeros(game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_round_actions = history.opponent_actions[-1]
            self.last_round_payoffs = history.opponent_payoffs[-1]
        current_cooperators = sum(history.opponent_actions[-1])
        if np.all(self.last_round_actions == history.opponent_actions[-1]) or (state.round_number > 1 and current_cooperators >= self.game_description.n_players // 2):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_97(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))
        self.avg_cooperation = 0
        self.num_rounds = game_description.n_rounds - 2 if game_description.n_rounds > 2 else game_description.n_rounds - 1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        self.history = history or self.history
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        elif len(self.history.opponent_actions) < self.num_rounds:
            pass
        else:
            avg_cooperation = np.mean(self.history.opponent_actions[max(0, state.round_number - self.num_rounds):state.round_number, :].sum(axis=0) / len(self.history.opponent_actions))
            if avg_cooperation >= self.game_description.n_players // 2:
                action = Action.C
        if action is Action.C:
            self.history.my_actions[-1] = True
        else:
            self.history.my_actions[-1] = False
        payoff = 1 - self.history.my_actions[-1] + self.game_description.k / self.game_description.n_players * self.history.opponent_actions[-1].sum()
        self.history.my_payoffs = np.append(self.history.my_payoffs, payoff)
        return action

class Strategy_COLLECTIVE_98(BaseStrategy):
    """Tit-for-Tat with Adaptive Cooperation (TFT-AC)"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.round = 0
            return Action.C
        self.round += 1
        if self.round == self.game_description.n_rounds:
            return Action.C
        previous_opponent_action = np.mean(history.opponent_actions[-1])
        return Action.C if previous_opponent_action else Action.D

class Strategy_COLLECTIVE_99(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if history:
            total_contributions = sum(history.my_actions) + self.total_contributions[state.round_number - 1]
            if total_contributions > self.game_description.k * (self.game_description.n_players // 2):
                action = Action.C
            elif total_contributions < self.game_description.k * (self.game_description.n_players // 3):
                action = Action.D
            else:
                average_contribution = np.mean(history.my_actions[:state.round_number])
                my_average = history.my_actions[state.round_number - 1] if state.round_number > 0 else None
                action = Action.C if my_average == average_contribution or action == Action.D else Action.D
        self.total_contributions[state.round_number - 1] = total_contributions
        return action

class Strategy_COLLECTIVE_100(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation (TFT-A) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.desired_cooperators = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators > self.desired_cooperators:
            return Action.C
        elif cooperators <= self.desired_cooperators:
            return Action.D
        if cooperators == self.desired_cooperators:
            return Action.D
        if self.game_description.n_players % 2 == 1 and cooperators == self.desired_cooperators - 1 or (self.game_description.n_players % 2 == 0 and cooperators == self.desired_cooperators):
            return Action(random.choice([0, 1]))

class Strategy_COLLECTIVE_101(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TfT-AC) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.alpha = 0.1
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        contributions = sum(history.my_actions[-self.game_description.n_rounds:]) if history else 0
        total_players = self.game_description.n_rounds
        if contributions == 0:
            percentage_contributors = 0
        else:
            percentage_contributors = contributions / total_players
        threshold = self.k / self.n_players - self.alpha
        if percentage_contributors > threshold:
            contribution = Action.C
        elif percentage_contributors < threshold / 2:
            contribution = Action.D
        elif not self.history or history.my_actions[-1] == Action.D:
            contribution = Action.D
        else:
            contribution = Action.C
        if contribution == Action.C:
            self.history.append(True)
        else:
            self.history.append(False)
        return contribution

class Strategy_COLLECTIVE_102(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.random = random.Random()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            action = self.random.choice([Action.C, Action.D])
        else:
            total_contributions = sum(history.opponent_actions[-1, :]) if history else 0
            if total_contributions == 0:
                action = Action.D
            elif total_contributions >= self.game_description.n_players // 2:
                action = Action.C
            else:
                majority = np.argmax(history.opponent_actions[-1, :]) if history else None
                action = Action.C if majority == self.game_description.n_players - 1 else Action.D
        if state.round_number == self.game_description.n_rounds:
            total_contributions = sum(history.opponent_actions[-2, :]) if history else 0
            if total_contributions >= (self.game_description.n_rounds - 1) * (self.game_description.n_players // 2):
                action = Action.C
        return action

class Strategy_COLLECTIVE_103(BaseStrategy):
    """
    A strategy that mimics opponents' actions in a simultaneous-move, repeated N-player public goods game.
    The strategy cooperates in the initial round and subsequent rounds it copies other players' actions from the previous round.
    If a player encounters an opponent who has not played the game before, it cooperates in the first round to initiate interaction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and self.last_opponent_action is not None:
            previous_round = len(history.opponent_actions) - 1
            last_opponent_action = history.opponent_actions[previous_round, state.round_number % self.game_description.n_players]
        else:
            last_opponent_action = None
        if state.round_number == 0 or last_opponent_action is None:
            return Action.C
        return Action(last_opponent_action)

    def update_history(self, state: GameState, history: PlayerHistory) -> None:
        """
        Updates the strategy's internal last opponent action variable.
        """
        if state.round_number < self.game_description.n_rounds - 1:
            history_copy = np.copy(history)
            history_copy.opponent_actions[-1, state.round_number % self.game_description.n_players] = self.last_opponent_action
            self.last_opponent_action = history_copy.opponent_actions[-1, state.round_number % self.game_description.n_players]

class Strategy_COLLECTIVE_104(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Generosity (TfT-AG)

    This strategy cooperates in the first round and responds to opponents' actions in subsequent rounds.
    It fosters trust and encourages cooperation by adapting its own generosity over time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.adaptability_factor = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        opponent_cooperators = sum(opponent_actions)
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        p_gen = min(1, 1 - self.adaptability_factor * (state.round_number / self.game_description.n_rounds))
        if opponent_actions[-1]:
            return Action.D if random.random() < p_gen else Action.C
        return Action.D

class Strategy_COLLECTIVE_105(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_opponent_action = None
            self.first_round = True
            return Action.C
        if history is None:
            self.last_opponent_action = None
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        action = Action.D
        if not self.first_round:
            if cooperators >= self.game_description.n_players // 2 and self.last_opponent_action is Action.C:
                action = Action.C
            elif cooperators < self.game_description.n_players // 2 and self.last_opponent_action is not Action.D:
                action = Action.D
            if self.last_opponent_action is not None and self.last_opponent_action is Action.D and (cooperators < self.game_description.n_players // 2):
                action = Action.D
                if state.round_number >= 3:
                    self.last_opponent_action = Action.D
        elif state.round_number == self.game_description.n_rounds:
            action = Action.C
        self.last_opponent_action = cooperators > self.game_description.n_players // 2 and Action.C or self.last_opponent_action
        self.first_round = False
        return action

class Strategy_COLLECTIVE_106(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    Cooperates initially and responds to opponents' actions in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = [['C'] * game_description.n_players for _ in range(game_description.n_rounds + 1)]

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.history[state.round_number] = history.opponent_actions[state.round_number - 1] if history else [Action.C] * self.game_description.n_players
        opponent_cooperators = np.sum(self.history[state.round_number])
        return Action.C if opponent_cooperators == self.game_description.n_players else Action.D

    def get_last_action(self) -> Action:
        """
        Return the last action played by this strategy.
        """
        return self.history[-1][self.__class__.__name__.lower().replace(' ', '_')]

class Strategy_COLLECTIVE_108(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy in an N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_action_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return Action.C
        opponent_actions = np.array([history.opponent_actions[state.round_number - 1, :]]).flatten() if history else np.zeros(self.game_description.n_players)
        self.opponent_action_history.append(opponent_actions)
        if opponent_actions[-1] == Action.D:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 and self.opponent_action_history[-1][-1] == Action.D:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_109(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    This strategy promotes cooperation within the group by adopting a reciprocal approach where actions are based on previous rounds' experiences with other players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_actions = np.zeros(game_description.n_rounds, dtype=bool)
        self.my_payoffs = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.my_actions) < self.game_description.n_rounds:
            history.my_actions = np.zeros(self.game_description.n_rounds, dtype=bool)
            history.my_payoffs = np.zeros(self.game_description.n_rounds)
        action = Action.C if self.my_actions[-1] == Action.C else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.C
        history.my_actions[state.round_number] = action
        self.my_actions[state.round_number] = action
        return action

class Strategy_COLLECTIVE_110(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros((1,)), np.zeros((self.game_description.n_players, 1), dtype=bool), np.zeros((1,)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_opponent_action = history.opponent_actions[-1][-1]
            if last_opponent_action:
                self.history.my_payoffs[-1] += self.game_description.k / self.game_description.n_players * sum(history.opponent_actions[-1]) - 1
                return Action.C
            else:
                self.history.my_payoffs[-1] += 1
                return Action.D
        self.history.my_payoffs = np.append(self.history.my_payoffs, [0])
        self.history.opponent_actions = np.vstack((self.history.opponent_actions, history.opponent_actions)) if history else np.zeros((self.game_description.n_rounds + 1, self.game_description.n_players, 1), dtype=bool)
        self.history.my_actions = np.vstack((self.history.my_actions, [Action.C] * state.round_number + [Action.D])) if history else np.zeros((self.game_description.n_rounds + 1,), dtype=bool)

class Strategy_COLLECTIVE_111(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) == 0):
            return Action.C
        self.history = history or self.history
        last_round = self.history.opponent_actions[-1]
        cooperation_count = sum(last_round)
        if cooperation_count >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_112(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.k / 2 * (self.game_description.n_players - 1) + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_c = np.mean(history.my_actions[:state.round_number])
        action = Action.C if avg_c >= self.threshold else Action.D
        return action

class Strategy_COLLECTIVE_114(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the N-player public goods game.
    Encourages cooperation while being robust against various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.favor_cooperation_probability = 0.7

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.opponent_actions) < self.game_description.n_rounds:
            return Action.D
        round_number = state.round_number - 1
        my_action = history.my_actions[round_number]
        opponent_cooperators = sum(history.opponent_actions[round_number, :])
        if opponent_cooperators == self.game_description.n_players:
            return Action.C
        if opponent_cooperators >= self.game_description.n_players // 2 and my_action:
            return Action.D
        if opponent_cooperators < self.game_description.n_players // 2 and (not my_action):
            return Action.C
        if round_number == self.game_description.n_rounds - 1:
            return Action.C
        cooperators = min(opponent_cooperators, self.game_description.n_players - opponent_cooperators)
        if cooperators == self.game_description.n_players // 2:
            return Action.C if random.random() > 1 - self.favor_cooperation_probability else Action.D
        return Action.C if cooperators < self.game_description.n_players // 2 and random.random() > self.favor_cooperation_probability else Action.D

class Strategy_COLLECTIVE_115(BaseStrategy):
    """A Tit-for-Tat with Foresight (TFTF) strategy for N-Player Public Goods Game."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.opponent_history.append(history.opponent_actions[-1])
        opponent_cooperated = np.sum(self.opponent_history[-1]) > 0
        current_action = Action.D if not opponent_cooperated else Action.C
        self.opponent_history = self.opponent_history[1:]
        return current_action

class Strategy_COLLECTIVE_116(BaseStrategy):
    """
    Implementation of the Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = math.floor(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        cooperators_last_round = sum(history.opponent_actions[-1])
        total_cooperators = sum(history.my_actions[:-1]) if state.round_number > 0 else 0
        forgiveness_needed = history.my_actions[0] == Action.C and cooperators_last_round == 0
        if state.round_number < self.game_description.n_rounds:
            return Action.C if forgiveness_needed or cooperators_last_round > self.tolerance else Action.D
        return Action.C

class Strategy_COLLECTIVE_117(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Contribution (TFTAC) for N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.l = min(game_description.n_rounds, game_description.n_rounds // 2)
        self.k_factor = 1.0
        self.forgetfulness_factor = 0.5
        self.average_contributions = np.zeros(self.l)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.my_payoffs[-1] > 0:
            self.k_factor = min(self.k_factor * self.forgetfulness_factor + max(history.opponent_actions[-self.l:, :].sum(axis=0)) / self.game_description.n_players, self.game_description.k)
        else:
            self.k_factor = max(self.k_factor * self.forgetfulness_factor + min(history.opponent_actions[-self.l:, :].sum(axis=0)) / self.game_description.n_players, 1.0)
        total_contributions = history.opponent_actions[-1, :].sum()
        if total_contributions == self.game_description.n_players:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_119(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.sliding_window = np.zeros((self.game_description.n_rounds, 2))
        self.cooperation_rate = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            cooperation_rate = self._calculate_cooperation_rate(history)
            return Action.C if cooperation_rate >= self.game_description.n_players // 2 else Action.D
        else:
            return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        self.sliding_window = np.roll(self.sliding_window, -1, axis=0)
        self.sliding_window[-1, 1] = np.mean(history.my_actions)
        return self.sliding_window[:, 1].mean()

class Strategy_COLLECTIVE_120(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperative (TFT-AC) strategy for N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = self.game_description.n_rounds
        self.a = math.floor(self.r / 10)
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        self.history = history
        opponent_cooperators = np.sum(history.opponent_actions[:, -1])
        my_action = Action.C if opponent_cooperators >= self.game_description.n_players // 2 or (self.history is not None and history.my_payoffs[-1] == 0) or len(history.opponent_actions) - self.a <= np.count_nonzero(history.opponent_actions[:, -1]) < len(history.opponent_actions) else Action.D
        return my_action

class Strategy_COLLECTIVE_122(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    Summary: Encourages cooperation and reciprocity among players, fostering a sense of community and shared responsibility for the common good.
             Adjusts the cooperative threshold over time based on previous encounters with defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = set()
        self.last_round_history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.last_round_history:
            self.last_round_history = history
        last_round_cooperation = sum(self.last_round_history.opponent_actions[-1, :]) >= self.game_description.n_players
        cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        if last_round_cooperation:
            return Action.C
        player_index = self.__class__.__name__.lower()
        if player_index in self.cooperative_threshold and cooperators == 0:
            return Action.C
        if all((history.opponent_actions[state.round_number - 1, i] == Action.D for i in range(self.game_description.n_players) if i != player_index)):
            return Action.C
        self.cooperative_threshold.add(player_index)
        return Action.D

class Strategy_COLLECTIVE_123(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif history is not None and self.first_round:
            cooperators = np.sum(history.opponent_actions[0, :])
            if cooperators == self.game_description.n_players:
                return Action.C
            else:
                self.first_round = False
                return Action.D
        elif history is not None and (not self.first_round):
            total_contributions = np.sum(history.opponent_actions[-1, :])
            if total_contributions == self.game_description.n_players:
                return Action.D
            elif total_contributions < self.game_description.n_players and history.my_actions[-1] == Action.D:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_124(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Foresight (TFTF)

    This strategy cooperates initially, then reciprocates the actions of other players while being cautious of freeriders.
    An element of unpredictability is introduced to deter opponents from exploiting TFTF strategies consistently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        my_action = history.my_actions[-1]
        total_contributions = sum(history.opponent_actions[-1])
        if my_action and total_contributions >= (self.game_description.n_players - 1) // 2:
            return Action.C
        if not my_action or total_contributions < (self.game_description.n_players - 1) // 2:
            return Action.D
        roll = random.random()
        return Action(int(roll < self.epsilon)) ^ my_action

class Strategy_COLLECTIVE_127(BaseStrategy):
    """
    A strategy that implements the Tit-for-Tat with Adaptive Cooperation (TFT-AC) in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.C if state.round_number == 0 else None
        if history is not None and len(self.history) > 0:
            last_opponent_action = self.history[-1]
            if last_opponent_action is None:
                self.history = [None] * state.round_number
            if last_opponent_action == Action.D and len(self.history) > 1:
                action = Action.D
            elif last_opponent_action is not None and last_opponent_action == Action.C:
                action = Action.C
            elif history.opponent_actions[-1, :].sum() == self.game_description.n_players - 1:
                action = Action.C
        if len(self.history) < state.round_number + 1:
            self.history.append(action)
        return action

class Strategy_COLLECTIVE_128(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.CT_initial = 0.3
        self.CT_max = 0.9
        self.cooperative_threshold = None
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            cooperate_probability = random.uniform(0, 1)
            self.cooperative_threshold = self.CT_initial if cooperate_probability < 0.5 else self.CT_max
            return Action.C if self.first_round else Action.D
        if history is None:
            return Action.D
        if self.first_round:
            self.first_round = False
        elif state.round_number == self.game_description.n_rounds:
            self.cooperative_threshold = min(self.CT_max, self.cooperative_threshold + (1 - (self.game_description.n_rounds - state.round_number) / self.game_description.n_rounds) * (self.CT_max - self.CT_initial))
        else:
            self.cooperative_threshold = min(self.CT_max, self.cooperative_threshold + (1 - (state.round_number + 1) / self.game_description.n_rounds) * (self.CT_max - self.CT_initial))
        total_cooperators = np.sum(history.opponent_actions[state.round_number - 1, :])
        return Action.C if total_cooperators >= self.cooperative_threshold else Action.D

class Strategy_COLLECTIVE_131(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Strategy for N-Player Public Goods Game.
    This strategy cooperates in the first round to signal trust, then adapts its behavior based on opponents' previous actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperative_rate = np.zeros(self.game_description.n_rounds)
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
            self.first_round = False
        opponent_cooperators = sum(history.opponent_actions[-1])
        cooperative_rate = opponent_cooperators / self.game_description.n_players
        self.opponent_cooperative_rate[state.round_number - 1] = cooperative_rate
        if self.first_round or cooperative_rate >= (self.game_description.n_players + 1) / 2:
            return Action.C
        if np.mean(self.opponent_cooperative_rate[:-1]) > 0.5:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_133(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return random.choice([Action.C, Action.D])
        cooperation_threshold = math.ceil(self.game_description.n_players / 2)
        coop_count = np.sum(history.opponent_actions[-1, :])
        if coop_count >= cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_134(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.floor((game_description.n_players + 1) / 2)
        self.recent_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds * 0.9:
            self.recent_cooperators = 0
        if history is not None:
            cooperators = sum(history.opponent_actions[-1, :])
            self.recent_cooperators += cooperators
        if self.recent_cooperators > self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_136(BaseStrategy):
    """
    A strategy that follows Tit-for-Tat with Adaptive Cooperation in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperators = 0.0
        self.rounds_played = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.rounds_played += 1
        cooperators = np.sum(history.opponent_actions[-self.game_description.n_players:])
        cooperators_average = self.average_cooperators if self.rounds_played > 0 else self.game_description.n_players // 2
        self.average_cooperators = (self.average_cooperators * (self.rounds_played - 1) + cooperators) / self.rounds_played
        threshold = math.ceil(cooperators_average)
        return Action.C if cooperators >= threshold else Action.D

class Strategy_COLLECTIVE_138(BaseStrategy):
    """
    A Tit-for-Tat variant strategy that promotes cooperation and adaptability in the N-Player Public Goods Game.
    The strategy cooperates initially, mimics opponents' actions, and adjusts cooperation based on overall player collaboration.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.strategy = [0] * game_description.n_rounds

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.strategy[state.round_number] = 1
            return Action.C
        collaborating = np.mean(history.opponent_actions[-1]) >= self.game_description.n_players / 2
        last_action = self.strategy[-1] if len(self.strategy) > 1 else None
        current_cooperation = last_action == 1 if last_action is not None else False
        if current_cooperation != collaborating:
            self.strategy[state.round_number] = 1 - self.strategy[-1]
        return Action(self.strategy[state.round_number])

class Strategy_COLLECTIVE_139(BaseStrategy):
    """
    An adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    This strategy cooperates in the first round to establish a cooperative relationship,
    and imitates the actions of other players from the previous round.
    If a player cooperated (C), then the ATFT player will also cooperate;
    if a player defected (D), the ATFT player will defect as well.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0 and history is None:
            action = Action.C
            self.first_round = True
        elif not self.first_round:
            last_round = history.opponent_actions[-1]
            if last_round[0] == Action.C:
                action = Action.C
            elif last_round[0] == Action.D:
                action = Action.D
        self.first_round = False
        return action

class Strategy_COLLECTIVE_141(BaseStrategy):
    """Fair-Share Strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_contributors = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        cooperators = np.sum(history.opponent_actions[-1, :]) if history is not None else 0
        if cooperators < self.average_contributors:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_142(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.last_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.update_history(state, history)
        if self.last_round != state.round_number - 1:
            self.last_opponent_action = None
            self.last_round += 1
        if self.last_opponent_action is None or self.last_round == state.round_number - 1:
            cooperators = sum(history.opponent_actions[self.last_round, :])
            return Action(cooperators >= self.game_description.n_players // 2)
        else:
            return Action(self.last_opponent_action == Action.C)

    def update_history(self, state: GameState, history: None | PlayerHistory):
        if history is not None and state.round_number > 0:
            self.last_opponent_action = history.opponent_actions[state.round_number - 1, 0]
            self.last_round = state.round_number - 1

class Strategy_COLLECTIVE_143(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TFT-A) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.past_cooperators = 0
        self.punishment_counter = 0
        self.forgiveness_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1])
        self.past_cooperators += total_contributions
        if state.round_number == self.game_description.n_rounds - 1:
            if self.past_cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        if total_contributions == self.game_description.n_players:
            self.forgiveness_counter = 0
            self.punishment_counter = 0
            return Action.C
        if total_contributions < self.game_description.n_players:
            self.punishment_counter += 1
        if self.punishment_counter >= self.game_description.n_players // 2 and self.forgiveness_counter <= self.game_description.n_rounds // 4:
            self.punishment_counter = 0
            self.forgiveness_counter += 1
            return Action.D
        self.forgiveness_counter = 0
        self.punishment_counter = 0
        return Action.C

class Strategy_COLLECTIVE_144(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = 1
        self.average_contributions = np.zeros(self.game_description.n_rounds)
        self.most_frequent_cooperator = None
        self.own_past_behavior = [0] * self.game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            contributions = np.sum(history.opponent_actions[:, :] * (2 - history.opponent_payoffs[:, :]), axis=1)
            self.average_contributions[-1] = np.mean(contributions)
            self.update_most_frequent_cooperator()
            self.update_k()
        if state.round_number == self.game_description.n_rounds - 1:
            return self.decide_last_round(history)
        return self.decide_regular_round(history)

    def update_most_frequent_cooperator(self):
        if not self.most_frequent_cooperator or self.game_description.n_players == len(set(self.average_contributions)):
            self.most_frequent_cooperator = None
        else:
            self.most_frequent_cooperator = np.argmax(self.average_contributions)

    def update_k(self):
        if np.mean(self.average_contributions) < (self.game_description.n_players - 1) / self.game_description.n_players:
            self.k = max(1, self.k * 0.95)
        elif np.mean(self.average_contributions) > (self.game_description.n_players + 1) / self.game_description.n_players:
            self.k = min(self.game_description.n_players, self.k * 1.05)

    def decide_regular_round(self, history):
        if self.most_frequent_cooperator is None:
            return Action.C
        if history.my_actions[-1]:
            self.own_past_behavior[-1] = 1
        else:
            self.own_past_behavior[-1] = 0
        player = self.most_frequent_cooperator if np.mean(self.own_past_behavior) == 0.5 else self.most_frequent_cooperator % self.game_description.n_players
        return history.opponent_actions[len(history.my_actions) - 1, player]

    def decide_last_round(self, history):
        cooperators = np.sum(history.opponent_actions[:, :])
        if cooperators < (self.game_description.n_players - 1) * 2:
            self.k = max(1, self.k * 0.95)
        return self.decide_regular_round(history)

class Strategy_COLLECTIVE_145(BaseStrategy):
    """
    A strategy that follows the Tit-for-Tat-Adaptive (TFT-A) approach in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = self.game_description.n_rounds
        self.current_round = 0
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.current_round = state.round_number
        if history is not None:
            total_cooperation_prev = sum(history.opponent_actions[-1])
            if total_cooperation_prev == self.game_description.n_players:
                return Action.C
            elif total_cooperation_prev > 0:
                if self.consecutive_defects >= self.r:
                    self.consecutive_defects = 0
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_146(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.first_round = False
        if state.round_number == len(history.opponent_actions) and self.first_round:
            return Action.C
        actions = history.opponent_actions[:, -1]
        cooperators = sum(actions)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_147(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    Summary: A strategy that initiates cooperation and responds cooperatively when opponents do so.
             It gradually adjusts retaliation based on the average cooperation rate to encourage long-term cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.k = self.game_description.k
        self.r = self.game_description.n_rounds
        self.moving_average_window = 5
        self.decay = 0.8
        self.max_punishment = self.n_players - 1
        self.retaliation_rate = np.ones(self.r)
        self.opponent_history = np.zeros((self.r, self.n_players), dtype=bool)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = state.round_number
        total_cooperation = np.sum(self.opponent_history[-self.moving_average_window:-1, :].flatten())
        average_cooperation_rate = total_cooperation / self.moving_average_window
        self.retaliation_rate[round_number] = min(self.decay * self.max_punishment, 1)
        if round_number == self.r - 1:
            opponent_action = history.opponent_actions[-1, :].sum() > self.n_players // 2
            return Action(int(not opponent_action))
        opponent_action = history.opponent_actions[round_number - 1, :].sum() > self.n_players // 2
        if opponent_action:
            return Action.C
        return Action(int(self.retaliation_rate[round_number] > average_cooperation_rate))

class Strategy_COLLECTIVE_148(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_rate = 0.5
        self.average_contribution_history = []
        self.num_rounds = 0
        self.threshold = self._calculate_threshold()

    def _calculate_threshold(self):
        if len(self.average_contribution_history) < 5:
            return np.mean(self.average_contribution_history)
        return np.median(self.average_contribution_history)

    def _update_average_contribution(self, cooperators):
        self.num_rounds += 1
        self.average_contribution_history.append(cooperators / self.game_description.n_players)
        if len(self.average_contribution_history) > 5:
            self.average_contribution_history.pop(0)
        return np.mean(self.average_contribution_history)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        adjusted_contribution_rate = self._update_average_contribution(cooperators)
        my_action = Action.D if cooperators == 0 else Action.C
        payoff = 1 - my_action.value + self.game_description.k / self.game_description.n_players * cooperators
        if adjusted_contribution_rate > self.threshold:
            contribution_multiplier = 1.1
        elif adjusted_contribution_rate < self.threshold:
            contribution_multiplier = 0.9
        else:
            contribution_multiplier = 1.0
        self.contribution_rate *= contribution_multiplier
        return Action(int(self.contribution_rate))

class Strategy_COLLECTIVE_149(BaseStrategy):
    """
    A Tit-for-Tat with Adaptation strategy for N-Player Public Goods Game.
    Cooperates in the first round and subsequent rounds if opponent cooperated in the previous round,
    otherwise defects based on an adaptation mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions if history is not None else np.zeros((1, self.game_description.n_players), dtype=np.bool_)
        cooperators = np.sum(opponent_actions[-1])
        defected_in_last_round = cooperators < self.game_description.n_players - 1 and opponent_actions.shape[0] > 1
        if (defection := (defected_in_last_round or self.opponent_defections)):
            self.opponent_defections += int(defection)
            return Action.D if self.opponent_defections > 0 else Action.C
        self.opponent_defections = 0
        return Action.C

class Strategy_COLLECTIVE_150(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    Encourages cooperation while punishing defection, fostering a collaborative mindset among players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = False
        self.first_encounter_with_defection = False
        self.previous_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_round = state.round_number == self.game_description.n_rounds
        self.first_encounter_with_defection = state.round_number == 2 and history.opponent_actions[1, 0] != Action.C
        if history is not None:
            self.previous_opponent_action = history.opponent_actions[-1, 0]
        if self.last_round or (not self.first_encounter_with_defection and history.my_actions[state.round_number - 2] == self.previous_opponent_action):
            return Action.C
        elif not self.last_round:
            return Action.D if history.my_actions[state.round_number - 1] != self.previous_opponent_action else Action.C

class Strategy_COLLECTIVE_151(BaseStrategy):
    """
    Strategy that implements the Tit-for-Tat with Fading Memory strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_action_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = self.opponent_action_history[-1] if len(self.opponent_action_history) > 0 else None
        if not opponent_action:
            return Action.C
        decay_factor = min((state.round_number - 1) / (self.game_description.n_rounds - 1), 1)
        if opponent_action == Action.C:
            return Action.C * (1 - decay_factor) + Action.D * decay_factor
        else:
            return Action.C * decay_factor + Action.D * (1 - decay_factor)

class Strategy_COLLECTIVE_152(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat with Cooperative Evolution (ATFTE)
    Strategy summary: Promotes cooperation among players and punishes defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_payoff = 0.0
        self.average_payoff = np.nan
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if self.first_round:
            cooperators = sum(history.opponent_actions[0])
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            self.first_round = False
        cooperators = sum(history.opponent_actions[-1])
        if cooperators == self.game_description.n_players:
            return Action.C
        elif any((x != 1 for x in history.opponent_actions[:-1].flatten())) or cooperators == 0:
            return Action.D
        if not np.isnan(self.average_payoff):
            self.total_payoff += state.round_number * (history.my_payoffs[-1] + self.average_payoff)
            if state.round_number < self.game_description.n_rounds:
                self.average_payoff = self.total_payoff / state.round_number
            elif self.total_payoff > self.average_payoff:
                return Action.C
            elif self.total_payoff < self.average_payoff:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_153(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_cooperators = sum(history.opponent_actions[-1])
        cooperators = self.last_cooperators
        if state.round_number > 1 and cooperators == 0:
            return Action.D
        return Action.C if cooperators > 0 else Action.D

class Strategy_COLLECTIVE_154(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)
    Strategy Description: An adaptive strategy that alternates between cooperating and defecting based on the opponent's actions in the previous round. If the opponent cooperates, TFT-AC cooperates as well; if the opponent defects, TFT-AC defects in the next round but will gradually revert to cooperating with a decay factor (0 <  < 1).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = 0.8
        self.adaptation_threshold = 0.5

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_decay = self.alpha ** (state.round_number - 2)
        if cooperation_decay >= random.uniform(0, 1):
            return Action.C
        else:
            return Action.D

    def edge_case_handling(self, current_round: int, r: int, current_score: int, max_score: int) -> None | Action:
        if current_round == 1:
            return Action.C
        elif current_round == self.game_description.n_rounds:
            if current_score >= math.ceil(max_score * self.adaptation_threshold):
                return Action.D
            else:
                return None
        else:
            return None

class Strategy_COLLECTIVE_156(BaseStrategy):
    """
    Tit-for-Tat Cooperative Strategy for N-Player Public Goods Game.
    A strategy that promotes mutual cooperation while being adaptive to various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_of_defection_count = 0
        self.last_cooperated_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number > 0 and self.history_of_defection_count == 0):
            return Action.C
        self.history_of_defection_count = sum(history.opponent_actions[:state.round_number, :].flatten() != Action.C) if history else 0
        cooperate_condition = self.game_description.n_players > self.history_of_defection_count and state.round_number > self.last_cooperated_round + self.game_description.k - 1
        if cooperate_condition:
            self.last_cooperated_round = state.round_number
            self.history_of_defection_count = 0
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_157(BaseStrategy):
    """
    A strategy that follows the Tit-for-Tat Adaptive Cooperation (TFTAC) in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_history = np.zeros(game_description.n_rounds, dtype=bool)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.cooperation_history[state.round_number] = True
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        current_round = len(self.cooperation_history) - 1
        if current_round == self.game_description.n_rounds - 1:
            self.cooperation_history[current_round] = True
            return Action.C
        elif cooperators >= self.game_description.n_players // 2 and history.opponent_actions[-1, current_round] == Action.D:
            self.cooperation_history[current_round] = False
            return Action.D
        elif cooperators <= self.game_description.n_players // 2 and history.opponent_actions[-1, current_round] == Action.C:
            self.cooperation_history[current_round] = True
            return Action.C
        else:
            self.cooperation_history[current_round] = history.opponent_actions[-1, current_round]
            return self.cooperation_history[current_round]

class Strategy_COLLECTIVE_158(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == 0 or history.my_actions[-1] == self.game_description.n_players:
            return Action.C
        elif np.any(history.opponent_actions[-1, :]):
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_159(BaseStrategy):
    """
    The ATFT strategy promotes cooperation while being robust against various opponent behaviors.
    It cooperates initially to foster a cooperative environment and mimics opponent's actions to encourage reciprocity and build trust over time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            history = self.history
        last_round = len(history.opponent_actions) - 1
        opponent_cooperators = sum(history.opponent_actions[last_round, :])
        my_action = Action.C if opponent_cooperators >= (self.game_description.n_players + 1) // 2 else Action.D
        self.history.my_actions[last_round] = my_action.value
        return my_action

class Strategy_COLLECTIVE_160(BaseStrategy):
    """
    A Tit-for-Tat strategy for N-player Public Goods Game. This strategy cooperates in the first round and responds to opponent's cooperation or defection in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_limit = math.floor(game_description.n_players / 2)
        self.history = PlayerHistory(my_actions=np.array([False]), my_payoffs=np.array([]), opponent_actions=np.zeros((1, game_description.n_players)), opponent_payoffs=np.zeros(game_description.n_players))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) < self.game_description.n_rounds):
            return Action.C
        opponent_cooperation = np.sum(history.opponent_actions[-1, :])
        my_last_action = bool(self.history.my_actions[-1])
        if opponent_cooperation == self.game_description.n_players:
            return Action.C
        elif opponent_cooperation > 0 and my_last_action:
            return Action.C
        else:
            return Action.D

    def update_history(self, state: GameState, my_action: bool, opponent_actions: NDArray[np.bool_]):
        self.history.my_actions = np.concatenate((self.history.my_actions, np.array([my_action])))
        self.history.opponent_actions = np.vstack((self.history.opponent_actions, opponent_actions))

class Strategy_COLLECTIVE_161(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contributions_sum = 0.0
        self.round_number = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_number = state.round_number
        cooperators = sum(history.opponent_actions[-1] if history else [False] * self.game_description.n_players)
        contributions_fraction = cooperators / self.game_description.n_players
        if contributions_fraction < self.game_description.n_players // 2 or self.round_number == 1:
            return Action.C
        return history and history.opponent_actions[-1][-1] if self.round_number > 1 else Action.D

class Strategy_COLLECTIVE_162(BaseStrategy):
    """
    Implementation of the Tit-for-Tat-Cooperative (TFTC) game theory strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.num_players = game_description.n_players
        self.rounds = game_description.n_rounds
        self.k = game_description.k
        self.majority = math.ceil((self.num_players + 1) / 2)

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1])
        if opponent_cooperators >= self.majority:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_163(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy (ATFT) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = None
        self.average_cooperation = 0
        self.total_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.threshold:
            self.calculate_threshold()
        if self.total_rounds < self.game_description.n_rounds - 1:
            self.average_cooperation = np.mean(history.my_actions[:self.total_rounds + 1])
        else:
            self.average_cooperation = np.sum(history.my_actions[self.total_rounds - self.game_description.n_rounds + 2:self.total_rounds + 1]) / self.game_description.n_rounds
        if self.average_cooperation >= self.threshold:
            return Action.C
        return Action.D

    def calculate_threshold(self):
        min_threshold = 1 - self.game_description.k / self.game_description.n_players + 1 / self.game_description.n_rounds
        self.threshold = min_threshold / 2
        self.total_rounds += 1

class Strategy_COLLECTIVE_164(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = math.ceil(game_description.n_players / 2)
        self.history_length = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_count = np.sum(history.my_actions[-self.history_length:])
        current_cooperators = np.sum(history.opponent_actions[-self.history_length:, :], axis=1) > cooperation_count
        if np.sum(current_cooperators) > cooperation_count:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_165(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.history.my_actions[0] = True
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators < (self.game_description.n_players - 1) // 2:
            return Action.D
        if sum(history.opponent_actions[-1, :]) == self.game_description.n_players - 1:
            return Action.D
        if cooperators > (self.game_description.n_players + 1) // 2:
            self.history.my_actions[state.round_number] = True
        else:
            self.history.my_actions[state.round_number] = False
        return Action(int(self.history.my_actions[state.round_number]))

class Strategy_COLLECTIVE_166(BaseStrategy):
    """
    Strategy that follows Tit-for-Tat with Adaptive Cooperation (TFT-AC) in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        elif history is not None:
            self.last_cooperators = sum(history.opponent_actions[-1])
            if self.last_cooperators > 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_167(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat Adaptive Cooperative (TFT-AC)
    A strategy that cooperates in the first round, then adapts its behavior based on opponents' past actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.trust = True
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.opponent_history.append(history.opponent_actions[-1, 0])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        action = Action.D if self.opponent_history[-1] == Action.D else Action.C
        return action

class Strategy_COLLECTIVE_169(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        if not history:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2 and history.my_actions[-1]:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_171(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == 1 and history is not None:
            self.last_round_cooperators = np.count_nonzero(history.opponent_actions[0])
        cooperators = np.count_nonzero(history.opponent_actions[-1])
        if cooperators >= self.game_description.n_players:
            return Action.C
        elif self.last_round_cooperators == self.game_description.n_players:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_172(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.initiate_cooperation = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return self.initiate_cooperation and Action.C or Action.D
        elif state.round_number > 0 and history is not None:
            cooperators = np.sum(history.opponent_actions[-1, :])
            if self.n_players - math.floor(self.n_players / 2) <= cooperators < self.n_players:
                self.initiate_cooperation = True
            else:
                self.initiate_cooperation = False
            return self.initiate_cooperation and Action.C or Action.D
        return Action.C

class Strategy_COLLECTIVE_173(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TFTA) strategy for N-Player Public Goods Game.
    This strategy cooperates in the first round and then adjusts its actions based on opponent's previous moves.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_history += [history.opponent_actions[state.round_number - 1, :]] if history else []
        cooperators = sum(self.opponent_history[-1])
        if state.round_number == self.game_description.n_rounds:
            return Action(cooperators >= len(self.opponent_history) // 2)
        return Action(self.opponent_history[-1][-1] == Action.C)

class Strategy_COLLECTIVE_174(BaseStrategy):
    """
    The Tit For Tat Strategy for the N-Player Public Goods Game.
    This strategy rewards cooperation and punishes defection while encouraging a collaborative environment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_number = 0
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if self.round_number == 0 or self.history is None:
            cooperation = True
        else:
            cooperation = np.sum(history.opponent_actions[-1]) > (self.game_description.n_players - 1) // 2
        self.round_number = state.round_number + 1
        self.history = history if state.round_number < self.game_description.n_rounds else PlayerHistory(**{key: val[self.game_description.n_rounds] for key, val in history.__dict__.items()})
        return Action.C if cooperation else Action.D

class Strategy_COLLECTIVE_175(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.last_cooperators = 0
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        self.last_cooperators = cooperators
        if cooperators > self.game_description.n_players // 2:
            return Action.C
        elif self.game_description.n_players % 2 == 1 and cooperators < self.game_description.n_players // 2:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_176(BaseStrategy):
    """
    A strategy that emulates Tit-for-Tat with Adaptive Cooperation in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 1.0
        self.T = 2 / 3
        self.Delta = 0.1
        self.c = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None:
            self.c += np.mean(history.opponent_actions[-1]) - self.c
        avg_cooperators = self.c / state.round_number
        if avg_cooperators > self.T:
            self.p += self.Delta
        elif avg_cooperators < 1 - self.T:
            self.p -= self.Delta
        opponent_action = history.opponent_actions[-state.round_number, 0] if state.round_number > 1 else Action.C
        return Action(int((random.random() < self.p) == opponent_action))

class Strategy_COLLECTIVE_177(BaseStrategy):
    """
    Implements the Tit-for-Tat (TFT) Strategy for the N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.history = history
        action = history.opponent_actions[-1][-1] if self.history else None
        return Action(1 if action == Action.C else 0)

class Strategy_COLLECTIVE_178(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance_threshold = math.floor(game_description.n_players / 2)
        self.last_opponent_action = None
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if self.first_round:
            self.first_round = False
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 or (self.last_opponent_action is not None and history is not None and (sum(history.opponent_actions[-1, :]) != len(history.opponent_actions[0]))):
            return Action.C if self.last_opponent_action == Action.D else Action.D
        if history is not None and self.last_opponent_action is not None and (sum(history.opponent_actions[-2, :]) >= self.tolerance_threshold):
            return Action.C
        else:
            return Action.D

    def update_last_opponent_action(self, opponent_action):
        self.last_opponent_action = opponent_action

class Strategy_COLLECTIVE_179(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    Strategy name: ATFT
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2
        self.player_strategy = {0: True}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[state.round_number - 1]) if history else 0
        c_ratio = cooperators / self.game_description.n_players
        if self.player_strategy[0] and c_ratio >= self.threshold:
            return Action.C
        elif not self.player_strategy[0] and c_ratio < self.threshold:
            return Action.D
        self.player_strategy[state.round_number] = not self.player_strategy[0]
        if c_ratio >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_180(BaseStrategy):
    """
    Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game.
    Aimed at fostering long-term cooperation by mimicking others' cooperative actions and punishing defection with defection,
    while adapting to various opponent behaviors through an initial compliance parameter 's'.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_compliance = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < self.initial_compliance else Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        majority_cooperated = cooperators >= math.ceil(self.game_description.n_players / 2)
        my_previous_action = history.my_actions[-1] if history else None
        if majority_cooperated and my_previous_action == Action.C or (not majority_cooperated and my_previous_action is None):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_183(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif np.all(history.opponent_actions[-1]):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_187(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

    This strategy follows Tit-for-Tat response rules, adapting to opponents' behaviors by including an escalation factor.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.escalation_factor = game_description.n_players // 2
        self.max_escalation_factor = math.ceil(game_description.n_players * game_description.n_rounds)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) == 0:
            return Action.D
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators >= self.escalation_factor:
            return Action.C
        elif opponent_cooperators == 0 and state.round_number < self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 1:
            if opponent_cooperators >= self.escalation_factor:
                return Action.C
            else:
                return Action.D
        if state.round_number < self.game_description.n_rounds - 1 and opponent_cooperators == 0:
            self.escalation_factor = min(self.max_escalation_factor, self.escalation_factor + 1)

class Strategy_COLLECTIVE_188(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy in N-Player Public Goods Game.
    This strategy cooperates when others do, but also punishes frequent defectors to maintain fairness and trust.
    It fosters a balance between selfishness and cooperation that aligns with a collective mindset.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            total_contributions_previous_round = sum(history.opponent_actions[-1])
            contributions_in_last_rounds = sum(sum(history.opponent_actions[state.round_number - 1:])) - total_contributions_previous_round
            if contributions_in_last_rounds >= self.T:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_189(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    This strategy cooperates initially and mimics opponents' actions, punishing defection with defect in the subsequent round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(game_description.n_players * 0.5)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_cooperators = sum(history.opponent_actions[-1, :]) if history else self.threshold
        if total_cooperators >= self.threshold:
            return Action.C
        my_action = Action.D if total_cooperators < self.game_description.n_players - 1 else Action.C
        for i in range(len(history.opponent_actions)):
            if history.opponent_actions[i, -1] == Action.C:
                if state.round_number > 1 and history.opponent_actions[i, i - 1] == Action.D:
                    return Action.D
        return my_action

class Strategy_COLLECTIVE_190(BaseStrategy):
    """
    The Tit-for-Tat Adaptive (TFTA) strategy promotes a collective mindset by demonstrating a willingness to cooperate and punishing uncooperative behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None
        self.most_frequent_cooperators = set()
        self.last_cooperator = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if not self.history:
            return Action.C
        self.most_frequent_cooperators.clear()
        self.last_cooperator = None
        if self.history:
            cooperators, cooperation_streaks = self._count_cooperators_and_streaks()
        else:
            cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        self._update_most_frequent_cooperators(cooperators)
        self._update_last_cooperator(cooperation_streaks)
        decision = self._make_decision()
        self.history = history
        return decision

    def _count_cooperators_and_streaks(self) -> tuple[int, dict]:
        """
        Count cooperators and calculate cooperation streaks for each cooperator in the history.
        :return: A tuple of total cooperators count and a dictionary mapping cooperators to their cooperation streaks.
        """
        if not self.most_frequent_cooperators:
            cooperators = {player: 0 for player in range(self.game_description.n_players)}
            streaks = {player: 0 for player in range(self.game_description.n_players)}
        else:
            cooperators, streaks = ({}, {})
            for cooperator in self.most_frequent_cooperators:
                streaks[cooperator] = 0
                for round_number in range(1, len(self.history.opponent_actions)):
                    if self.history.opponent_actions[round_number, cooperator.index] == Action.C and self.history.opponent_actions[round_number - 1, cooperator.index] == Action.D:
                        streaks[cooperator] += 1
        total_cooperators = sum(self.history.opponent_actions[:, :].sum(axis=0))
        for round_number in range(len(self.history.opponent_actions)):
            cooperators[self.history.opponent_actions[round_number, :].argmax()] += 1
        return (total_cooperators, streaks)

    def _update_most_frequent_cooperators(self, total_cooperators: int):
        """
        Update the most frequent cooperators based on the current round's cooperators count.
        :param total_cooperators: The total number of cooperators in the current round.
        """
        cooperators = self._get_current_round_cooperators()
        if total_cooperators == 0:
            return
        frequencies = {player: cooperators[player] / total_cooperators for player in cooperators}
        self.most_frequent_cooperators = set(sorted(frequencies, key=frequencies.get, reverse=True)[:self.game_description.n_players])

    def _update_last_cooperator(self, cooperation_streaks: dict):
        """
        Update the last cooperator based on cooperation streaks from the current round and history (if available).
        :param cooperation_streaks: A dictionary mapping cooperators to their cooperation streaks.
        """
        if not self.history or len(self.most_frequent_cooperators) == 1:
            self.last_cooperator = next(iter(self.most_frequent_cooperators))
        else:
            last_streaks = cooperation_streaks if self.history else {}
            last_cooperator = max(((cooperator, streak) for cooperator, streak in cooperation_streaks.items() if streak in last_streaks and cooperation_streaks[cooperator] >= last_streaks[cooperator]))
            self.last_cooperator = list(self.most_frequent_cooperators)[last_cooperator[0].index]

    def _make_decision(self) -> Action:
        """
        Make a decision based on the most frequent cooperators and cooperation streaks from the current round and history (if available).
        :return: The action to play in the current round.
        """
        if not self.last_cooperator or len(self.most_frequent_cooperators) == 0:
            return Action.D
        cooperation_streak = self._get_current_round_cooperation_streak(self.last_cooperator)
        last_action = self.history.opponent_actions[-1, self.last_cooperator.index] if self.history else None
        return Action.C if last_action == Action.D and cooperation_streak > 0 or cooperation_streak > len(self.history.opponent_actions) // 2 else Action.D

    def _get_current_round_cooperators(self) -> dict:
        """
        Return a dictionary mapping players to whether they cooperated in the current round.
        :return: A dictionary with keys being player indices and values being True if the player cooperated, False otherwise.
        """
        return {player: action == Action.C for player, action in enumerate(self.history.opponent_actions[state.round_number - 1, :])}

    def _get_current_round_cooperation_streak(self, cooperator: tuple) -> int:
        """
        Return the cooperation streak of a given cooperator in the current round.
        :param cooperator: A tuple representing the index of the cooperator (player).
        :return: The cooperation streak of the cooperator in the current round.
        """
        return self.history.opponent_actions[state.round_number - 1, cooperator[0]] if self.history else 0

class Strategy_COLLECTIVE_191(BaseStrategy):
    """
    Tit-for-Tat with Variable Contribution (TFTVC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            total_cooperators_prev = sum(history.opponent_actions[-1])
            if total_cooperators_prev >= self.n_players // 2:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_192(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TfTA-C) strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        self.last_state = GameState(-1)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            self.history.my_actions[0] = True
            self.last_state = state
            return Action.C
        self.last_state = state
        total_cooperators = np.sum(self.history.opponent_actions[-1, :])
        if self.last_state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if total_cooperators == 0:
            return Action.D
        if np.all(self.history.opponent_actions[-2, :] == (Action.C - 1).astype(bool)):
            return Action.D
        return self.history.my_actions[-1]

class Strategy_COLLECTIVE_193(BaseStrategy):
    """
    The Tit-for-Tat Adaptive Strategy (TfTAS) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contributions = []
        self.x = int(math.floor(0.7 * game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        total_contributions = sum(history.opponent_actions[-1])
        m = self.adjust_threshold(total_contributions, self.contributions)
        if total_contributions >= m:
            return Action.C
        else:
            return Action.D

    def adjust_threshold(self, total_contributions, contributions):
        if len(contributions) < self.x:
            m = int(math.floor(self.game_description.n_players / 2))
        else:
            m = int(np.mean(contributions[-self.x:]))
        return m

class Strategy_COLLECTIVE_194(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    Strategy promotes cooperation and collaboration among players by encouraging reciprocity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros((1,)), np.zeros((self.game_description.n_players, 1), dtype=bool), np.zeros((1,)))

    def __call__(self, state: GameState, history: PlayerHistory | None):
        if not history:
            self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros((1,)), np.zeros((self.game_description.n_players, 1), dtype=bool), np.zeros((1,)))
        else:
            self.history = history
        if state.round_number == 0:
            return Action.C
        last_action = self.history.my_actions[-1]
        opponent_cooperators = sum(self.history.opponent_actions[-1, :])
        if last_action and opponent_cooperators:
            return Action.C
        elif last_action and (not opponent_cooperators):
            return Action.D
        elif not last_action and opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_195(BaseStrategy):
    """
    Strategy name: Adaptive Cooperation Strategy (ACS)
    Summary: A strategy based on the average cooperation rate over previous rounds, deciding to cooperate or defect based on a predefined decision rule.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.predefined_initial_value = 0.5
        self.average_cooperation_rate = self.predefined_initial_value
        self.total_contributions = 0
        self.player_actions = [{'round': range(self.n_rounds), 'action': ['D'] * self.n_rounds} for _ in range(self.n_players)]

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            for t in range(state.round_number):
                self._update_average_cooperation_rate(history, t)
        if self._decide_to_cooperate(state):
            return Action.C
        return Action.D

    def _update_average_cooperation_rate(self, history: PlayerHistory, round_number: int) -> None:
        for t in range(round_number + 1):
            total_contributions = sum(history.opponent_actions[t])
            if total_contributions > self.k * self.n_players / (self.k - 1):
                self.average_cooperation_rate = (self.average_cooperation_rate + 1) / (t + 1)
            else:
                self.average_cooperation_rate = self.average_cooperation_rate / (t + 1)

    def _decide_to_cooperate(self, state: GameState) -> bool:
        return self.average_cooperation_rate > self.k / (self.k - 1)

class Strategy_COLLECTIVE_196(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    Encourages cooperation and rewards others who cooperate, while being punitive towards those who do not cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.min_coop_level = math.ceil(game_description.n_players / 2)
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players)), np.zeros(1))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.history = history
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.min_coop_level:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_197(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) with Cooperation Threshold (CT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = np.median([x for x in range(1, game_description.n_players)])
        self.history = PlayerHistory(np.zeros((game_description.n_rounds,), dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1, :])
        cooperation_rate = cooperators / self.game_description.n_players
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if cooperation_rate >= self.cooperation_threshold else Action.D
        return Action.C if cooperation_rate >= self.cooperation_threshold else Action.D

    def update_history(self, state: GameState, action: Action, payoff: float):
        self.history.my_actions[state.round_number] = int(action == Action.C)
        self.history.my_payoffs[state.round_number] = payoff
        self.history.opponent_actions[state.round_number, :] = np.array([int(opp_action == Action.C) for opp_action in history.opponent_actions[-1, :]])
        self.history.opponent_payoffs[state.round_number] = np.array([opp_payoff for opp_payoff in history.opponent_payoffs[-1]])

class Strategy_COLLECTIVE_198(BaseStrategy):
    """
    Tit-for-Tat Evolution (TfTE) Strategy for N-Player Public Goods Game.
    This strategy encourages cooperation when most players contribute, but also punishes free-riders.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1] if history else np.zeros(1, dtype=bool))
        self.total_contributions[state.round_number - 1] = float(cooperators)
        if self.total_contributions[-1] >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_199(BaseStrategy):
    """
    A strategy that cooperates in the first round, then adopts a Tit-for-Tat approach by cooperating if an opponent cooperated in the previous round, and defecting otherwise.
    Introduces time discounting to prioritize current payoffs over future rewards, where the discount rate decreases as the game progresses.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.discount_rate = np.array([math.exp(-math.log(game_description.n_players) * (round / game_description.n_rounds)) for round in range(1, game_description.n_rounds + 1)]).flatten()
        self.discount_rate = np.maximum(self.discount_rate, np.array([0.5] * len(self.discount_rate)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.my_actions[-1] != Action.C:
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        reward = self.game_description.k / self.game_description.n_players * (cooperators - len(history.opponent_actions) + 1)
        if reward >= self.discount_rate[state.round_number] * (1 - reward):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_200(BaseStrategy):
    """
    Tit-for-Tat with Gradual Cooperation strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.trust_level = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if np.sum(history.opponent_actions[-1]) > self.game_description.n_players // 2:
            self.trust_level += 0.05
        else:
            self.trust_level -= 0.05
        action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if np.sum(history.my_actions) > np.sum(history.opponent_actions.flatten()):
                action = Action.C
        elif self.trust_level < 0.5:
            action = Action.D if np.random.uniform(0, 1) > random.choice([0.2, 0.4]) else Action.C
        elif self.trust_level >= 0.5:
            action = Action.D if np.random.uniform(0, 1) > random.choice([0.8, 1]) else Action.C
        return action

class Strategy_COLLECTIVE_201(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game.
    Mimics opponent's behavior from the previous round, with a slight modification to encourage cooperation in the public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_defectors = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation = False if history is None else sum(history.opponent_actions[-1]) > self.game_description.n_players - 2
        if state.round_number == self.game_description.n_rounds:
            cooperation = True if sum(history.opponent_actions[:-1, :].sum(axis=0)) >= self.game_description.n_players - len(self.round_defectors) * (self.game_description.n_players / (2 * self.game_description.k)) else not self.round_defectors[state.round_number - 1]
        else:
            cooperation = history.opponent_actions[state.round_number - 1].sum() > self.game_description.n_players - 2
        self.round_defectors[state.round_number] = len(history.opponent_actions[:state.round_number]) if state.round_number != 0 else 0
        return Action.C if cooperation else Action.D

class Strategy_COLLECTIVE_202(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_observed_cooperation_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.my_actions[-1] == Action.D and self.last_observed_cooperation_round == -1:
            self.last_observed_cooperation_round = -1
            return Action.D
        elif history.my_actions[-1] == Action.C:
            self.last_observed_cooperation_round = state.round_number
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators < self.game_description.n_players // 2 and self.last_observed_cooperation_round != -state.round_number:
            return Action.D
        elif self.last_observed_cooperation_round == -1:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_204(BaseStrategy):
    """
    A strategy that mimics Tit-for-Tat in the N-Player Public Goods Game.
    Players cooperate initially, then follow the actions of their opponents in subsequent rounds.
    If an opponent switches strategies or shows irrational behavior, the strategy adapts by switching to unconditional defection for that opponent.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_behavior = {}
        self.last_round_history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number > 0 and history is not None:
            self.last_round_history = history
            if history != self.last_round_history:
                self.opponent_behavior = {}
            action = Action.C
            if len(self.opponent_behavior) > 0 and state.round_number > 1:
                last_action = history.opponent_actions[-1][-1]
                last_round = self.last_round_history if self.last_round_history is not None else history
                last_opponent_action = last_round.opponent_actions[-2][-1]
                if last_action == Action.C and last_opponent_action == Action.D or (last_action == Action.D and last_opponent_action == Action.C):
                    action = Action.D
                elif self.opponent_behavior and history.opponent_actions[0] != self.opponent_behavior[0]:
                    self.opponent_behavior[0] = last_action
            return action

class Strategy_COLLECTIVE_205(BaseStrategy):
    """
    A simple and adaptive cooperation strategy called Tit-for-Tat Adaptive Cooperation (TFTAC).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_round_history is None:
            return Action.C
        self.last_round_history = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        cooperators = sum(self.last_round_history)
        return Action.C if cooperators >= self.game_description.n_players // 2 else Action.D

class Strategy_COLLECTIVE_206(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_rounds = 0
        self.total_rounds = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.total_rounds += 1
        if history and state.round_number < self.game_description.n_rounds:
            cooperators = sum(history.opponent_actions[-1, :])
            punishment_needed = False
            if cooperators > self.game_description.n_players // 2:
                self.cooperative_rounds += 1
                if self.cooperative_rounds == 1 and state.round_number != 1:
                    punishment_needed = True
            else:
                self.cooperative_rounds = max(0, self.cooperative_rounds - 1)
            if history.my_actions[-1] == Action.C and (not punishment_needed):
                return Action.C
            elif history.my_actions[-1] != Action.C:
                return Action.D
        if state.round_number == self.game_description.n_rounds:
            cooperators = sum(history.opponent_payoffs[-1]) / self.total_rounds
            if cooperators > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_208(BaseStrategy):
    """
    Adaptive Cooperative Tit-for-Tat (ACTFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.C
        if history is not None and state.round_number > 1:
            last_round_action = history.my_actions[-1]
            total_contributions = np.sum(history.my_actions[:-1])
            if last_round_action == Action.D and total_contributions / state.round_number > self.threshold:
                action = Action.D
            elif last_round_action != history.my_actions[0]:
                action = last_round_action
        return action

class Strategy_COLLECTIVE_210(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game.
    This strategy cooperates in the first round and mimics the last player's action for subsequent rounds,
    except in the last round, it always cooperates regardless of the opponent's last action to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > state.round_number - 1:
            self.last_opponent_action = history.opponent_actions[state.round_number - 1, 0]
            return Action(self.last_opponent_action) if state.round_number != self.game_description.n_rounds else Action.C

class Strategy_COLLECTIVE_211(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game that promotes cooperation and punishes defection, while also being forgiving to encourage reformation after mistakes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number == 0 or (self.history.my_actions[-1] != Action.C and opponent_cooperators == 0):
            return Action.D
        else:
            return Action.C

    def update(self, state: GameState, my_action: Action, payoff: float) -> None:
        """
        Update the strategy's internal state with new information from the game environment.
        This method is called after each round to provide the strategy with feedback about its actions and their consequences.
        """
        self.history.my_actions[-1] = my_action
        self.history.my_payoffs[-1] = payoff
        self.history.opponent_actions[-1, self.__class__.__name__.lower()] = not self.history.my_actions[-1]

class Strategy_COLLECTIVE_212(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_number = 0
        self.history = None
        self.cooperate_count = 0
        self.defect_count = 0
        self.payoff_sum = 0
        self.punishment_period = 0
        self.noise = 0.1

    def __call__(self, state: GameState, history: PlayerHistory):
        self.round_number = state.round_number
        self.history = history if self.round_number > 0 else None
        action = Action.C if self.round_number == 0 else self._determine_action(history)
        return action

    def _determine_action(self, history: PlayerHistory):
        if not history:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1])
        avg_payoff = np.mean(history.my_payoffs[-self.game_description.n_rounds:])
        payoff_from_cooperating = history.my_payoffs[-1] - 1
        if payoff_from_cooperating < avg_payoff:
            self._start_punishment()
            return Action.D
        elif payoff_from_cooperating > avg_payoff:
            self._adjust_cooperation(total_contributions)
        cooperators = total_contributions // self.game_description.n_players * self.game_description.n_players
        return Action.C if history.my_actions[-1] == cooperators else Action.D

    def _start_punishment(self):
        self.punishment_period = self.game_description.n_rounds // 2
        self.defect_count += 1

    def _adjust_cooperation(self, total_contributions: int):
        self.punishment_period -= 1
        cooperators = total_contributions // self.game_description.n_players * (1 + self.noise) * self.game_description.n_players
        self.cooperate_count += cooperators - total_contributions

class Strategy_COLLECTIVE_213(BaseStrategy):
    """
    A strategy that imitates opponents' behavior, builds cooperative relationships and shows forgiveness.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_length = math.ceil(game_description.n_players / 3)
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 or not history:
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1][-1]
        opponent_defects = (history.opponent_actions[-self.history_length:-1].sum(axis=0) >= self.history_length // 2).astype(int)
        if np.all(opponent_defects):
            return Action.D
        if self.last_opponent_action == Action.C:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_214(BaseStrategy):
    """
    Strategy that implements Tit-for-Tat with Adaptive Cooperation (TFT-AC) in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / 2)
        self.half_game_duration = math.ceil(game_description.n_rounds / 2)
        self.cooperation_level = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if cooperators >= self.threshold and state.round_number > self.half_game_duration:
            if self.cooperation_level < 2:
                self.cooperation_level += 1
        if cooperators == 0 or (self.cooperation_level == 2 and cooperators < self.threshold):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_215(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.phase = 1
        self.rounds_per_phase = int(self.game_description.n_rounds / 2)
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or self.current_round < self.rounds_per_phase:
            self.current_round += 1
            return Action.C if self.current_round <= self.rounds_per_phase else Action.D
        cooperators = sum(history.opponent_actions[-self.rounds_per_phase:, -1])
        if self.current_round > self.rounds_per_phase * 2 and self.phase == 1 and (cooperators < self.game_description.n_players // 2):
            self.phase = 3
        elif self.phase == 1 and history.my_actions[-1] == Action.D and (cooperators >= self.game_description.n_players // 2):
            self.phase = 2
        return self.get_action(cooperators)

    def get_action(self, cooperators):
        if self.phase == 1:
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        elif self.phase == 2:
            return Action.C if history.my_actions[-1] == Action.C else Action.D
        elif self.phase == 3:
            return Action.D

class Strategy_COLLECTIVE_216(BaseStrategy):
    """
    The Adaptive Tit-for-Tat (ATfT) strategy for N-Player Public Goods Games with Public Goods Game Optimization (APGO).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.count_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.my_actions[-1] == Action.D:
            self.count_defects += 1
            if self.count_defects >= 2:
                return Action.C
            return Action.D
        else:
            self.count_defects = 0
        return Action.C

class Strategy_COLLECTIVE_217(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFTAC) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.window_size = int(math.ceil((game_description.n_rounds - 1) / game_description.n_players))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        my_actions = history.my_actions[0] if state.round_number == 0 else history.my_actions[-self.window_size:].sum() > self.game_description.n_players // 2
        opponent_actions = history.opponent_actions[:, -1] if state.round_number <= self.window_size else history.opponent_actions[-self.window_size:, -1].mean() > 0.5
        return Action.C if my_actions and opponent_actions else Action.D

class Strategy_COLLECTIVE_218(BaseStrategy):
    """
    Adaptive Cooperative Tit-for-Tat strategy for the N-Player Public Goods Game.
    Promotes cooperation while demonstrating resilience against various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        self.history.append(history.my_actions[-1])
        self.last_opponent_action = history.opponent_actions[-1, -1] if len(self.history) >= self.game_description.n_players else self.last_opponent_action
        if self.history[-1]:
            if self.last_opponent_action:
                return Action.C
            elif not self.last_opponent_action and history.my_actions[0]:
                return Action.C
            else:
                return Action.D
        elif not self.last_opponent_action:
            return Action.C
        elif self.last_opponent_action and (not history.my_actions[0]):
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_220(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_contributors = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds - 1:
            cooperators = sum(history.opponent_actions[-1, :])
            average_contributors = np.mean(self.average_contributors[:state.round_number]) if state.round_number > 0 else 0
            return Action.C if cooperators > average_contributors else Action.D
        else:
            average_contributors = np.mean(self.average_contributors)
            total_contributions = sum(history.opponent_actions[-1, :])
            return Action.C if total_contributions > self.game_description.n_players * average_contributors // 2 else Action.D
        for action, count in zip(history.my_actions, range(len(history.my_actions))):
            self.average_contributors[count] = np.mean(self.average_contributors[:count + 1]) if count > 0 else action
        return Action.C

class Strategy_COLLECTIVE_222(BaseStrategy):
    """
    A strategy that mimics opponents' actions and promotes mutual trust, cooperation, and forgiveness in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperative_round = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_cooperative_round is None:
            return Action.C
        action = history.opponent_actions[state.round_number - 1, 0] if history is not None else None
        if action == Action.C and self.last_cooperative_round is None:
            self.last_cooperative_round = state.round_number
        elif action == Action.C and self.last_cooperative_round > 0 and (self.last_cooperative_round != state.round_number - 1):
            self.last_cooperative_round = None
        return action if self.last_cooperative_round is not None else Action.C

class Strategy_COLLECTIVE_223(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    Promotes cooperation among players while being responsive to their actions,
    aiming to maximize overall group benefits and minimize individual losses due to freeriding.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_round = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        num_cooperators_last_round = sum(previous_round)
        if num_cooperators_last_round > self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_225(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    This strategy cooperates when average cooperation exceeds a certain threshold, or if an opponent cooperated in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = game_description.n_players // 2
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players - 1), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players - 1)))

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            self.history.my_actions[0] = True
            return Action.C
        last_round = len(self.history.opponent_actions) - 1
        my_last_cooperation = self.history.my_actions[-1]
        opponent_last_cooperation = sum(self.history.opponent_actions[last_round, :]) / (self.game_description.n_players - 1)
        if opponent_last_cooperation > self.T:
            return Action.C
        if my_last_cooperation:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_228(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game (TFT-PG)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.strategy = Action.C
        self.past_actions = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return self.strategy
        payoffs = np.zeros(self.game_description.n_rounds, dtype=np.float64)
        for round_idx in range(state.round_number):
            if self.strategy == Action.C:
                total_contributions = sum(history.opponent_actions[round_idx, :])
                if total_contributions == self.game_description.n_players:
                    payoffs[round_idx] = 1 + self.game_description.k / self.game_description.n_players * (total_contributions + 1)
                    self.strategy = Action.C
                else:
                    payoffs[round_idx] = 1 - self.game_description.k / self.game_description.n_players * total_contributions
                    self.strategy = history.my_actions[-1 + round_idx] if round_idx > 0 else Action.D
                    self.past_actions.append(self.strategy)
            else:
                payoffs[round_idx] = 1 + self.game_description.k / self.game_description.n_players * (history.opponent_actions[-1, :].sum() + 1)
                if history.opponent_actions[-1, :].sum() == self.game_description.n_players:
                    self.strategy = Action.C
                    self.past_actions.append(self.strategy)
        self.strategy = Action.C
        return self.strategy

class Strategy_COLLECTIVE_229(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.start_coop = True
        self.endgame = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            self.start_coop = True
        elif state.round_number == self.game_description.n_rounds - 1:
            self.endgame = True
        if self.start_coop or history is None:
            action = Action.C
        else:
            cooperation = sum(history.opponent_actions[-1])
            if cooperation == len(self.game_description.n_players) - 1:
                action = Action.C
            elif self.endgame and cooperation != 0:
                action = Action.D
        return action

class Strategy_COLLECTIVE_231(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.opponent_history = history.opponent_actions
        last_round = len(self.opponent_history) - 1
        total_contributions = np.sum(self.opponent_history[-1])
        if total_contributions == self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_232(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    The strategy cooperates initially and responds to other players' actions in a reciprocal manner, promoting long-term cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions = [0] * self.game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.total_contributions[state.round_number - 1] = sum(history.opponent_actions[-1, :])
        if sum(self.total_contributions) == self.game_description.n_players:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_233(BaseStrategy):
    """
    An implementation of the Adaptive Cooperation (AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.avg_cooperators = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        total_contributions = np.sum(history.my_actions if history else [False])
        self.avg_cooperators[state.round_number - 1] = (np.cumsum(self.avg_cooperators) + total_contributions)[-1] / state.round_number
        avg_cooperators_t = self.avg_cooperators[-1]
        if avg_cooperators_t > self.game_description.n_players / (2 * self.game_description.k):
            return Action.C
        elif avg_cooperators_t < self.game_description.n_players / (3 * self.game_description.k):
            return Action.D
        else:
            return random.choice([Action.C, Action.D])

class Strategy_COLLECTIVE_234(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Time-Varying Contribution (ATFT-TVC) strategy for N-Player Public Goods Game.
    This strategy aims to promote mutual cooperation and collective success, while being adaptive and robust to a wide range of opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.r = self.game_description.n_rounds
        self.k = self.game_description.k
        self.contribution_factor = 0.1
        self.max_contribution = 0.9
        self.recent_cooperation_average = np.zeros(self.r)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        contribution_factor = min(self.k * (state.round_number / self.r) * self.contribution_factor, self.max_contribution)
        if history is not None:
            total_cooperation = sum(history.my_actions)
            recent_cooperators = sum(history.opponent_actions[:, -10:])
            cooperation_average = (total_cooperation + recent_cooperators.sum()) / (self.r + 10)
            if cooperation_average > self.n // 2 and state.round_number != self.r:
                return Action.C
            elif cooperation_average < 0.5:
                return Action.D
        return Action(int(contribution_factor))

    def update_history(self, history: PlayerHistory):
        self.recent_cooperation_average = np.roll(self.recent_cooperation_average, -1)
        self.recent_cooperation_average[-1] = sum(history.my_actions) / 10

class Strategy_COLLECTIVE_235(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_def = int(self.game_description.n_players / 2)
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        self.history.append(history)
        last_round = self.history[-1]
        last_round_cooperators = sum(last_round.opponent_actions[-1, :])
        if last_round_cooperators == self.game_description.n_players:
            return Action.C
        elif last_round_cooperators > 0 and any(last_round.opponent_actions[-1]):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_239(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_move = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C if self.first_move else Action.D
        last_round = len(history.opponent_actions) - 1
        last_opponent_cooperated = sum(history.opponent_actions[last_round]) >= self.game_description.n_players // 2
        self.first_move = False if state.round_number == self.game_description.n_rounds - 1 else self.first_move
        return Action.C if last_opponent_cooperated and self.first_move else Action.D

class Strategy_COLLECTIVE_240(BaseStrategy):
    """
    A Tit-for-Tat-Based Adaptive Cooperation Strategy (TFTAC) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.is_first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number > 0 and (not self.is_first_round):
            total_cooperators = sum(history.opponent_actions[-1])
            if total_cooperators == self.game_description.n_players:
                action = Action.C
            else:
                action = Action.D
        elif state.round_number > 0:
            self.is_first_round = False
        return action

class Strategy_COLLECTIVE_241(BaseStrategy):
    """
    Tit-for-Tat with Adaptation strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = np.full((game_description.n_rounds,), True)
        self.last_cooperator_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        current_round = min(state.round_number, len(self.opponent_history) - 1)
        last_round = current_round if state.round_number == self.game_description.n_rounds else None
        if last_round is not None:
            pass
        elif current_round > self.last_cooperator_round + 3:
            self.opponent_history[current_round] = False
            self.last_cooperator_round = -1
        elif self.opponent_history[current_round - 1]:
            pass
        else:
            self.opponent_history[current_round] = False
            self.last_cooperator_round = -1
        return Action(int(self.opponent_history[current_round]))

class Strategy_COLLECTIVE_244(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        self.last_round_cooperators = cooperators
        if all((action == Action.C for action in history.opponent_actions[-1, :] if history is not None)) or cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_245(BaseStrategy):
    """
    A strategy that promotes cooperation in the N-Player Public Goods Game using a Tit-for-Tat Adaptive Cooperative approach.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.past_cooperators = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == 0 and history is not None:
            cooperators = np.count_nonzero(history.opponent_actions[0])
            if cooperators < self.game_description.n_players - 1:
                return Action.D
            return Action.C
        else:
            cooperators = np.count_nonzero(history.opponent_actions[-1])
            if cooperators > self.game_description.n_players // 2:
                self.past_cooperators[state.round_number] += 1
                return Action.C
            self.past_cooperators[state.round_number] = 0
            return Action.D

class Strategy_COLLECTIVE_246(BaseStrategy):
    """
    Strategy that uses Tit-for-Tat with Adaptation in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperators = 0
        self.last_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_round = state.round_number - 1
        cooperators = sum(history.opponent_actions[self.last_round, :])
        if cooperators > 0 and self.last_cooperators == 0:
            self.punishment_counter = min(3, self.game_description.n_players)
        if state.round_number == self.game_description.n_rounds:
            total_payoff = np.sum(history.my_payoffs)
            if total_payoff > self.game_description.n_players * self.game_description.k - 1:
                return Action.C
        action = Action.D
        if cooperators > 0 and self.punishment_counter > 0:
            self.punishment_counter -= 1
        elif cooperators == self.last_cooperators:
            action = Action.C
        self.last_cooperators = cooperators
        return action

class Strategy_COLLECTIVE_247(BaseStrategy):
    """
    Implements the Tit-for-Tat Adaptive strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0 and history is None:
            self.first_round = True
            action = Action.C
        elif state.round_number > 0 and history is not None:
            if self.first_round:
                self.first_round = False
            opponent_cooperation_last_round = sum(history.opponent_actions[-1, :])
            action = Action.C if opponent_cooperation_last_round > 0 else Action.D
        return action

class Strategy_COLLECTIVE_248(BaseStrategy):
    """
    A strategy that cooperates in the first round and mirrors opponents' actions while adapting contribution probability based on previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = 0.1
        self.past_cooperators = 0
        self.past_defectors = 0
        self.rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.past_cooperators = 0
            self.past_defectors = 0
            self.rounds = 1
        action = Action.D
        if self.rounds > 1:
            cooperators = sum(history.opponent_actions[self.rounds - 1, :])
            opponent_payoffs = history.opponent_payoffs[self.rounds - 1]
            self.past_cooperators += 1 if cooperators > self.past_cooperators else 0
            self.past_defectors += 1 if sum(opponent_payoffs) == len(opponent_payoffs) else 0
            p_cooperate = (1 + self.alpha * (self.past_defectors - self.past_cooperators)) / self.game_description.n_players
            action = Action.C if random.random() < p_cooperate else Action.D
        self.rounds += 1
        if state.round_number == self.game_description.n_rounds:
            if self.past_cooperators > self.past_defectors:
                action = Action.C
        return action

class Strategy_COLLECTIVE_249(BaseStrategy):
    """
    Tit-for-Tat strategy for N-Player Public Goods Game.
    Encourages and rewards cooperative behavior while adapting to opponents' actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players)), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number - 1] = True
        cooperators = np.sum(history.opponent_actions[-1, :])
        majority = cooperators > self.game_description.n_players // 2 if np.count_nonzero(history.opponent_actions[-1, :]) >= 2 else False
        self.history.my_payoffs[state.round_number - 1] = 0
        if majority:
            self.history.opponent_actions[-1, :] = np.where(self.history.opponent_actions[-1, :], True, False)
            payoffs = self.game_description.k / self.game_description.n_players * np.sum(self.history.my_actions[:state.round_number])
            self.history.opponent_payoffs[-1] = self.history.opponent_payoffs[-1] + payoffs - 1
        else:
            self.history.opponent_actions[-1, :] = np.where(self.history.opponent_actions[-1, :], False, True)
            self.history.my_payoffs[state.round_number - 1] += 1
        return Action.C if majority else Action.D

class Strategy_COLLECTIVE_251(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    A strategy that promotes mutual cooperation and establishes a stable equilibrium where all players benefit from each other's contributions to the public good.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.8
        self.own_cooperation_rate = None
        self.last_opponent_action = None
        self.opponent_cooperation_rate = None
        self.rounds_observed = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if self.rounds_observed < self.game_description.n_rounds - 1 and self.own_cooperation_rate is None:
            self.own_cooperation_rate = self.calculate_cooperation_rate(history)
        if history is not None:
            self.last_opponent_action = int(np.array(history.opponent_actions[-1, :]).sum()) > 0
            self.rounds_observed += 1
            if self.last_opponent_action:
                cooperation = self.own_cooperation_rate >= self.cooperation_threshold
            else:
                cooperation = not self.own_cooperation_rate >= self.cooperation_threshold
            if self.opponent_cooperation_rate is None:
                cooperation = self.last_opponent_action
            return Action(int(cooperation))

    def calculate_cooperation_rate(self, history) -> float:
        total_contributions = sum(history.my_actions[:])
        total_rounds = len(history.my_actions)
        cooperation_rate = total_contributions / total_rounds
        return cooperation_rate

class Strategy_COLLECTIVE_252(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFT-AC) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_level = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            previous_round = len(history.opponent_actions) - 1
            my_cooperated = bool(history.my_actions[previous_round])
            opponents_cooperated = sum(history.opponent_actions[previous_round]) >= self.game_description.n_players // 2
            if not history and previous_round == 0:
                return Action.C
            if opponents_cooperated:
                return Action.C
            elif my_cooperated and (not opponents_cooperated):
                self.contribution_level = min(self.contribution_level + 0.1, 1)
                return Action.C
            elif not my_cooperated and opponents_cooperated:
                self.contribution_level = max(self.contribution_level - 0.1, 0)
                return Action.D
            else:
                self.contribution_level = max(self.contribution_level - 0.1, 0)
                return Action.D

class Strategy_COLLECTIVE_253(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = history.opponent_actions[-1] if history is not None else None
        total_cooperation = sum(previous_round) if previous_round is not None else self.game_description.n_players
        return Action.C if total_cooperation == self.game_description.n_players else Action.D

class Strategy_COLLECTIVE_254(BaseStrategy):
    """
    A Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game.
    This strategy cooperates initially and imitates the majority of players' collective action in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        else:
            self.history = history
            total_contributions = np.sum(history.opponent_actions[-1])
            cooperators = total_contributions >= self.game_description.n_players // 2
            action = Action.C if cooperators else Action.D
            if state.round_number == 0:
                self.history.my_actions = np.full(self.game_description.n_rounds, action.value)
            elif state.round_number > 1:
                self.history.my_actions[state.round_number - 1] = action.value
        return action

class Strategy_COLLECTIVE_255(BaseStrategy):
    """
    Implementation of Adaptive Tit-for-Tat (ATfT) game theory strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.rounds_to_consider = math.ceil(self.game_description.n_rounds / 2)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.history) < self.rounds_to_consider:
            return Action.C
        most_frequent_cooperator = self.find_most_frequent_cooperator(self.history)
        tendency_to_cooperate = self.calculate_tendency_to_cooperate(history, most_frequent_cooperator)
        if tendency_to_cooperate > 0.5:
            return Action.C
        return Action.D

    def find_most_frequent_cooperator(self, history):
        cooperators = []
        for i in range(len(history.opponent_actions)):
            if self.count_cooperation([row[i] for row in history.opponent_actions], i) > len(history) / 2:
                cooperators.append(i + 1)
        if len(cooperators) == 1:
            return cooperators[0]
        else:
            most_frequent_cooperator = max(cooperators)
            return most_frequent_cooperator

    def count_cooperation(self, actions, player):
        cooperation_count = sum([1 if action[player - 1] == Action.C else 0 for action in actions])
        return cooperation_count

    def calculate_tendency_to_cooperate(self, history, most_frequent_cooperator):
        cooperation_count = self.count_cooperation([history.opponent_actions[i] for i in range(-1 * self.rounds_to_consider + 1, 0)], most_frequent_cooperator)
        total_rounds = len(history.opponent_actions[-self.rounds_to_consider + 1:])
        return cooperation_count / total_rounds

class Strategy_COLLECTIVE_256(BaseStrategy):
    """
    The Tit-for-Tat (TFT) Adaptive Cooperation Strategy based on trust and reciprocity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or self.opponent_last_action is None:
            return Action.C
        if history is not None:
            self.opponent_last_action = history.opponent_actions[-1, -1]
            if self.opponent_last_action:
                return Action.C
            elif history.my_actions[-2]:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_257(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Cooperation Threshold strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            cooperators = sum(history.opponent_actions[-1])
            if cooperators > self.cooperation_threshold:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_258(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-A) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.6

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_last_action = history.opponent_actions[-1][0] if len(history.opponent_actions) > 0 else None
        cooperate = state.round_number % 2 == 0 and opponent_last_action == Action.C.value or not opponent_last_action
        total_contributions = np.count_nonzero(history.opponent_actions[-1])
        if state.round_number < self.game_description.n_rounds or (state.round_number >= self.game_description.n_rounds / 2 and total_contributions > math.ceil(self.game_description.n_players * self.threshold)):
            cooperate = True
        payoff = np.zeros(1, dtype=np.float64)
        if cooperate:
            payoffs = 1 - Action.D.value + self.game_description.k / self.game_description.n_players * total_contributions
            payoff[0] = np.sum(payoffs)
        else:
            payoff[0] = 1
        history.my_actions[state.round_number - 1] = cooperate
        history.my_payoffs[state.round_number - 1] = payoff[0]
        return Action(cooperate)

class Strategy_COLLECTIVE_259(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.count_nonzero(history.opponent_actions[-1, :]) if history else 0
        return Action.C if cooperators >= self.game_description.n_players // 2 else Action.D

class Strategy_COLLECTIVE_260(BaseStrategy):
    """
    A strategy that implements Tit-for-Tat with Adaptive Cooperation (TFT-AC) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_round = -1
            return Action.C
        self.last_round = state.round_number
        opponent_cooperators = np.sum(history.opponent_actions[-1]) if history else 0
        cooperate = self.last_round != self.game_description.n_players and opponent_cooperators >= self.game_description.n_players // 2
        return Action(cooperate)

class Strategy_COLLECTIVE_261(BaseStrategy):
    """
    Freerider with Tit-for-Tat Adaptation Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.rounds = 0
        self.average_cooperation_rate = 0.5
        self.cooperation_threshold = self.game_description.n_players // 3
        self.previous_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        self.rounds += 1
        if state.round_number == 0:
            return Action.C
        if self.rounds > self.game_description.n_players + 2:
            cooperators = np.mean(history.opponent_actions[self.rounds - self.game_description.n_players - 1:-1, :])
        else:
            cooperators = np.mean(history.opponent_actions[:self.rounds - 1, :]) if history is not None else 0.5
        if cooperators > self.cooperation_threshold:
            return Action.C
        if self.previous_opponent_action is not None and self.rounds - self.previous_opponent_action >= 2:
            return Action(self.previous_opponent_action == Action.C).reverse()
        return Action.D

class Strategy_COLLECTIVE_262(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C if state.round_number == 0 else Action.D
        self.history = history
        if state.round_number == 1:
            self.last_cooperators = sum(self.history.opponent_actions[0])
        current_round = state.round_number - 1
        if all(self.history.opponent_actions[current_round]):
            return Action.C
        elif any(~self.history.opponent_actions[current_round]):
            return Action.D
        total_contributions = sum(self.history.my_actions[current_round]) + self.last_cooperators
        if state.round_number == self.game_description.n_rounds - 1 or total_contributions / (self.game_description.k * self.game_description.n_players) > 1 - total_contributions:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_263(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Contribution (TfTAC) strategy for N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = self.game_description.k
        self.n = self.game_description.n_players
        self.x = int(self.game_description.n_rounds * 0.8)
        self.average_contribution = np.zeros((1, self.x))
        self.current_round_contributions = np.zeros(self.n)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.current_round_contributions = sum(history.opponent_actions[-1, :])
        if history is not None:
            self.average_contribution = np.roll(self.average_contribution, -1)
            self.average_contribution[0][-self.x] = self.current_round_contributions / self.n
        if self.current_round_contributions > self.k:
            self.k += 0.05
        elif self.current_round_contributions < self.k:
            self.k -= 0.05
        cooperators = sum(history.opponent_actions[-1, :]) >= self.n // 2
        return Action.C if cooperators else Action.D

class Strategy_COLLECTIVE_264(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_round = False
            return Action.C
        player_action = Action.D
        if not self.last_round:
            cooperators = sum(history.opponent_actions[-1, :]) if history else 0
            if cooperators >= self.game_description.n_players // 2:
                player_action = Action.C
        self.last_round = state.round_number == self.game_description.n_rounds
        return player_action

class Strategy_COLLECTIVE_265(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    Strategy description: A cooperative strategy that adapts to opponent's behavior.
    Initially cooperates in the first round, then adapts strategy based on opponent's action in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((1, self.game_description.n_players), dtype=bool), my_payoffs=np.zeros(self.game_description.n_rounds, dtype=float), opponent_actions=np.zeros((self.game_description.n_rounds + 1, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds + 1, self.game_description.n_players), dtype=float))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if history is not None:
            self.history = history
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        elif self.history.opponent_actions[-1, :].sum() > 0 and len(self.history.opponent_actions[-1, :]) < self.game_description.n_players - 1:
            cooperators = sum(self.history.opponent_actions[-1, :])
            if cooperators >= math.ceil(self.game_description.n_players / 2):
                action = Action.C
        return action

class Strategy_COLLECTIVE_266(BaseStrategy):
    """
    The Tit-for-Tat Adaptive Cooperative Strategy mimics opponents' actions from the previous round. If an opponent cooperated, this strategy will cooperate in return. If an opponent defected, it will also defect in response. This encourages stability and punishes defection. A forgiveness mechanism is implemented to avoid being exploited by opponents who constantly defect, with a punishment threshold that can be determined based on the game parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_threshold = math.ceil(game_description.n_players * 0.6)
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 or len(self.history) == 0:
            return Action.C
        last_action = self.history[-1] if len(self.history) > 0 else None
        if last_action is not None and state.round_number - last_action['round_number'] >= self.punishment_threshold:
            return Action.C
        my_cooperators = sum([1 for round, action in history.opponent_actions if round == state.round_number - 1 and action])
        return Action(my_cooperators > len(self.history) // 2)

class Strategy_COLLECTIVE_268(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None:
            self.last_round_cooperators = sum(history.opponent_actions[-1, :])
            if all((elem == 1 for elem in history.opponent_actions[-1])):
                return Action.C
            else:
                if state.round_number == self.game_description.n_rounds - 1 and self.last_round_cooperators == self.game_description.n_players:
                    return Action.C
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_269(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Contribution (TFTAC) strategy player in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.contribution_rate = game_description.k
        self.n_wait = 2
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif history is not None and self.current_round < self.n_wait:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if len(self.history) < self.current_round + 1 or (self.current_round == 0 and len(history.opponent_actions[0]) < self.game_description.n_players // 2):
            cooperation = True
        else:
            cooperation = np.count_nonzero(history.opponent_actions[-1]) >= np.count_nonzero(np.not_(history.opponent_actions[-1])) and self.history[-1] == cooperation
        if cooperation:
            self.contribution_rate += self.current_round / self.game_description.n_rounds
        total_contributions = np.count_nonzero(history.opponent_actions[-1])
        payoff = 1 - cooperation + self.contribution_rate * total_contributions
        self.history.append(cooperation)
        self.current_round += 1
        return cooperation and Action.C or Action.D

class Strategy_COLLECTIVE_270(BaseStrategy):
    """
    Adaptive Fitness-based Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.fitness_scores = np.zeros(game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            total_players = self.game_description.n_players
            cooperators = sum(history.opponent_actions[-1, :])
            all_cooperated = cooperators == total_players
            any_defected = np.any(~history.opponent_actions[-1, :])
            if all_cooperated:
                return Action.C
            elif any_defected:
                return Action.D
            self.update_fitness_scores(history)
            self.adaptive_decision(total_players, cooperators)
        return self._choose_action()

    def update_fitness_scores(self, history: PlayerHistory):
        for round in range(1, len(history.my_payoffs)):
            if history.my_payoffs[round] > 0:
                player = np.argmax(history.opponent_actions[round, :])
                self.fitness_scores[player] += 1 / history.my_payoffs[round]

    def adaptive_decision(self, total_players: int, cooperators: int):
        fitness_threshold = (total_players + 1) // 2
        if np.max(self.fitness_scores) > fitness_threshold:
            return
        else:
            self.fitness_scores *= 0.95

    def _choose_action(self):
        action = Action.D
        if np.max(self.fitness_scores) >= self.game_description.n_players // 2:
            action = Action.C
        return action

class Strategy_COLLECTIVE_272(BaseStrategy):
    """
    Freerider-Punisher (FP) strategy for N-Player Public Goods Game.
    Aims to balance between cooperation and defection while being adaptive and robust to various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.C_init = 0.5
        self.T_coop = math.ceil(self.n * 0.6)
        self.history = {'total': 0}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            cooperators_avg = self.history['total'] / self.n if self.history['total'] else self.C_init
            p = min(1, cooperators_avg + self.C_init)
            return Action.C if random.random() < p else Action.D
        elif state.round_number == self.game_description.n_rounds:
            return Action.D
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            return Action.C if cooperators > self.T_coop else Action.D

class Strategy_COLLECTIVE_273(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        if self.threshold is None:
            self.threshold = int((1 + np.mean(history.opponent_actions[0]) / self.game_description.n_players) * self.game_description.n_players)
        opponent_cooperated_last_round = history.opponent_actions[-1].sum() >= self.threshold
        if opponent_cooperated_last_round:
            return Action.C
        else:
            return Action.D

    def update(self, state: GameState, payoff: float) -> None:
        pass

class Strategy_COLLECTIVE_274(BaseStrategy):
    """
    A Tit-for-Tat Adaptive (TfTA) Strategy for N-Player Public Goods Game.
    This strategy encourages cooperation among players as a means of fostering a more collaborative environment within the game.
    It does so by rewarding cooperative behavior and punishing defection, promoting trust and fairness among players.
    Players that follow this strategy will adapt to the collective behavior of others over time, ensuring long-term success in repeated interactions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.current_strategy = Action.C
        self.history = PlayerHistory(my_actions=np.array([[Action.C]], dtype=bool), my_payoffs=np.array([0], dtype=float), opponent_actions=np.zeros((1, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros(1, dtype=float))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.update_history(state, history)
        current_round = len(self.history.my_actions) - 1
        last_cooperators = sum(self.history.opponent_actions[current_round, :])
        if self.current_strategy == Action.C and last_cooperators > 0:
            return Action.C
        elif self.current_strategy == Action.C and last_cooperators == 0:
            self.current_strategy = Action.D
            return Action.D
        elif self.current_strategy == Action.D and last_cooperators > 0:
            self.current_strategy = Action.C
            return Action.C
        else:
            self.current_strategy = Action.D
            return Action.D

    def update_history(self, state: GameState, history: PlayerHistory):
        if history is not None:
            self.history = history
        else:
            self.history.my_actions = np.vstack([self.history.my_actions, [self.current_strategy]]).reshape(-1)
            self.history.my_payoffs = np.append(self.history.my_payoffs, 0)
            self.history.opponent_actions = np.vstack([self.history.opponent_actions, np.zeros((state.round_number + 1, self.game_description.n_players), dtype=bool)])
            self.history.opponent_payoffs = np.append(self.history.opponent_payoffs, np.zeros(state.round_number + 1))
        if state.round_number > self.game_description.n_rounds:
            self.current_strategy = Action.D

class Strategy_COLLECTIVE_276(BaseStrategy):
    """Tit-for-Tat Strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players * (game_description.k - 1) / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        if cooperators <= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_277(BaseStrategy):
    """
    A Tit-for-Tat with a twist strategy that encourages cooperation while being adaptive and robust to various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_period = math.ceil(game_description.n_players / 2)
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.C if self.first_round or state.round_number == self.game_description.n_rounds - 1 else None
        if history and (not self.first_round):
            opponent_action = history.opponent_actions[state.round_number - 1, 0]
            self.first_round = False if opponent_action == Action.C or self.punishment_period > state.round_number else True
            action = opponent_action if self.first_round else Action.D
        return action

class Strategy_COLLECTIVE_278(BaseStrategy):
    """
    Tit-for-Tat with Variable Cooperation (TfTVC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.initial_cooperation_period = 10
        self.probability_to_cooperate = 0.5
        self.round_number = 0
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.round_number = state.round_number
        if self.round_number < self.initial_cooperation_period:
            return Action.C
        cooperation_history = history.opponent_actions[-self.initial_cooperation_period:, -1]
        cooperators = np.sum(cooperation_history)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif cooperators >= self.n_players // 2:
            return Action.C
        elif random.random() < self.probability_to_cooperate:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_279(BaseStrategy):
    """
    Strategy: Adaptive Tit-for-Tat (ATFT) for the N-Player Public Goods Game.
    Encourages cooperation while being robust against varying opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))
        self.forgiven = False
        self.retaliating = False

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if history is not None:
            self.history = history
        if state.round_number == 0 or (not self.forgiven and self.retaliating):
            return Action.C
        previous_round = self.history.opponent_actions[-1]
        total_cooperators = np.sum(previous_round)
        if total_cooperators == 0:
            self.retaliating = True
            return Action.D
        elif total_cooperators >= self.game_description.n_players - 1:
            self.forgiven = True
            self.retaliating = False
            return Action.C
        elif np.all(previous_round == self.history.my_actions[-1]):
            self.forgiven = True
            self.retaliating = False
            return self._mimic_opponent(previous_round)
        elif not self.retaliating:
            self.retaliating = True
            return Action.D
        else:
            self.forgiven = False
            return Action.C

    def _mimic_opponent(self, previous_round):
        if np.all(previous_round == Action.C):
            return Action.C
        elif np.all(previous_round == Action.D):
            return Action.D
        else:
            return self.history.my_actions[-1]

class Strategy_COLLECTIVE_280(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_cooperated = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_opponent_cooperated = False
            return Action.C
        if history is not None:
            self.last_opponent_cooperated = history.opponent_actions[-1, -1]
            cooperators = sum(history.opponent_actions[-1])
            return Action(int(cooperators >= self.game_description.n_players // 2))
        else:
            return Action.D

class Strategy_COLLECTIVE_281(BaseStrategy):
    """
    A simple strategy that follows the Tit-for-Tat protocol, with modifications for the Public Goods Game.
    This strategy cooperates in the first round and subsequently imitates the majority of players from the previous round.
    If there's a tie, it sides with cooperation as a means to promote cooperation and foster a collective mindset.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            opponents_cooperated = np.count_nonzero(history.opponent_actions[-1])
            majority = self.game_description.n_players // 2 + 1
            if opponents_cooperated >= majority:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_283(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        opponent_action = history.opponent_actions[-1][-1] if len(history.opponent_actions) > 0 else None
        self.opponent_actions_history.append(opponent_action)
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        if opponent_action is None or len(self.opponent_actions_history) < 2:
            return Action.C
        return Action(1 - self.opponent_actions_history[-1])

class Strategy_COLLECTIVE_285(BaseStrategy):
    """
    An adaptive tit-for-tat strategy for N-Player Public Goods Games.
    This strategy cooperates in the initial round, and thereafter, it cooperates if a majority of players have previously cooperated.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(math.floor(game_description.k / 2 * game_description.n_players))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None and history.my_actions[-1] is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_286(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Strategy (TFTA) for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        self.my_action = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history.my_actions[0] = True
            return self.my_action
        if state.round_number == 0:
            return self.my_action
        opponent_cooperators = history.opponent_actions[state.round_number - 1].sum()
        cooperate = True if opponent_cooperators >= self.game_description.n_players // 2 else False
        self.my_action = Action(int(cooperate))
        self.history.my_actions[state.round_number] = cooperate
        return self.my_action

class Strategy_COLLECTIVE_287(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TFT-A) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            if history is not None and len(history.opponent_actions) == self.game_description.n_rounds:
                self.last_opponent_action = history.opponent_actions[-1, 0]
        opponent_cooperated = bool(np.sum(history.opponent_actions[-1, :])) if history is not None else False
        action = Action.C if self.last_opponent_action == opponent_cooperated else Action.D
        self.last_opponent_action = opponent_cooperated
        return action

class Strategy_COLLECTIVE_289(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-Adaptive (TfT-A)
    A strategy that cooperates initially and then adapts its actions based on the opponents' previous moves.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.opponent_cooperators = sum(history.opponent_actions[-1])
        action = Action.D
        if self.opponent_cooperators > 0:
            action = Action.C
        return action

class Strategy_COLLECTIVE_290(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_few_rounds = 5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None and state.round_number < self.first_few_rounds:
            return Action.C
        total_contributions = np.sum(history.opponent_actions[-1])
        if total_contributions == self.game_description.n_players:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_291(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    This strategy cooperates in the first round and then adaptively chooses to cooperate or defect based on other players' actions in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if not history:
            self.first_round = True
        elif state.round_number == 0:
            action = Action.C
            self.first_round = False
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators == self.game_description.n_players or self.first_round:
                action = Action.C
                self.first_round = False
        return action

class Strategy_COLLECTIVE_292(BaseStrategy):
    """
    The ATFT-PCT strategy cooperates in the first round and adapts its behavior based on the total contributions in previous rounds.
    It defines a probabilistic cooperative threshold (pct) as the moving average of total contributions divided by n, and decides to cooperate if the total contributions in the previous round are greater than or equal to pct * n.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.pct = None
        self.total_contributions = [0] * game_description.n_rounds

    def moving_average(self, values, window=10):
        return np.mean(values[-window:]) if len(values) > window else values[0]

    def decide_action(self, total_contributions_t):
        self.pct = self.moving_average(self.total_contributions, self.game_description.n_rounds)
        return Action.C if total_contributions_t >= self.pct * self.game_description.n_players else Action.D

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.my_actions) < state.round_number:
            self.total_contributions[state.round_number - 1] = sum(history.my_payoffs[:state.round_number]) if state.round_number in history.my_payoffs else 0
        total_contributions_t = sum(history.my_actions[-state.round_number:])
        return self.decide_action(total_contributions_t)

class Strategy_COLLECTIVE_293(BaseStrategy):
    """
    A Tit-for-Tat-Evolution (T4E) strategy that balances cooperation and adaptability.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []

    def most_common_cooperators(self, history):
        cooperators_count = {Action.D: 0, Action.C: 0}
        for action in history:
            if action is not None:
                cooperators_count[action] += 1
        max_cooperators = max(cooperators_count.values())
        max_cooperators_actions = [Action.D if act == max_cooperators else Action.C for act in cooperators_count.values()]
        return max_cooperators_actions

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(self.history) == 0):
            return Action.C
        most_recent_cooperators = self.most_common_cooperators(self.history[-state.round_number:])
        action = None if len(most_recent_cooperators) == 0 else most_recent_cooperators[0]
        self.history.append(action)
        return action

class Strategy_COLLECTIVE_294(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None and state.round_number != self.game_description.n_rounds:
            self.last_opponent_action = np.mean(history.opponent_actions[:, -1])
            return Action(int(self.last_opponent_action))
        elif state.round_number == self.game_description.n_rounds:
            return Action.C

class Strategy_COLLECTIVE_295(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.half_n = int(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1, :])
        if cooperators < self.half_n:
            return Action.D
        elif cooperators > self.half_n:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_296(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_contributions = 0
        self.punishment_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            last_round = history.opponent_actions[-1]
            total_contributions = np.sum(last_round)
            self.punishment_counter = 0 if total_contributions >= self.game_description.n_players // 2 else self.punishment_counter + 1
            if np.all(last_round == Action.C):
                return Action.C
            elif last_round[-1] == Action.C and self.punishment_counter < 2:
                return Action.C
            elif total_contributions <= self.last_round_contributions * 0.5:
                self.punishment_counter = 0
                return Action.C
            elif self.punishment_counter < 2:
                return Action.D
        self.last_round_contributions = total_contributions if history is not None else 0
        return Action.C

class Strategy_COLLECTIVE_297(BaseStrategy):
    """
    A Tit-for-Tat strategy for N-Player Public Goods Game.
    Cooperates in the first round and decides to cooperate or defect based on the previous round's contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        collaborators = np.count_nonzero(history.opponent_actions[-1])
        if collaborators >= self.game_description.n_players - 1:
            return Action.C
        return Action.D

    def last_round(self, state):
        return state.round_number == self.game_description.n_rounds

    def handle_ties(self, collaborators):
        ties = sum([1 for contribution in collaborators if contribution == len(collaborators) - 1])
        return [1] * ties + [0] * (len(collaborators) - ties)

class Strategy_COLLECTIVE_298(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players - 1), dtype=bool), np.zeros(game_description.n_rounds))
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.opponent_history = history if history else self.opponent_history
        if self.opponent_history.opponent_actions[-1].sum() == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        cooperation = self.opponent_history.opponent_actions[-1][-1]
        self.last_cooperators += int(cooperation)
        if state.round_number < 3 or cooperation:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_300(BaseStrategy):
    """
    TFT-Adaptive Cooperation Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        self.round = state.round_number
        if not history or self.round == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_my_action = history.my_actions[last_round] if last_round >= 0 else False
        last_opp_cooperators = sum(history.opponent_actions[last_round])
        cooperate = self.round > 0 and last_my_action == (last_opp_cooperators > 0)
        return Action.C if cooperate else Action.D

class Strategy_COLLECTIVE_302(BaseStrategy):
    """
    A strategy inspired by the Tit-for-Tat approach where cooperation is rewarded and defection is punished.
    The strategy starts by cooperating (C) in each round, then cooperates if an opponent also cooperated in the previous round, but defects if an opponent defected.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self.last_opponent_action = None
        self.last_opponent_action = history.opponent_actions[-1, :].mean()
        return Action(int(self.last_opponent_action == 1))

class Strategy_COLLECTIVE_303(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n, self.r, self.k = (self.game_description.n_players, self.game_description.n_rounds, self.game_description.k)
        self.alpha = 0.5
        self.CR_current, self.CR_prev, self.CR_threshold = (0.5, 0.5, 0.5)
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.history.append(history.opponent_actions[-1])
        if state.round_number == 0 or len(self.history) < self.r // 2:
            return Action.C
        cooperators = np.sum(self.history[-1])
        CR_current = cooperators / self.n
        if CR_current > self.CR_threshold:
            return Action.C
        elif state.round_number == self.r:
            return Action.C if CR_current > self.CR_threshold else Action.D
        else:
            self.CR_prev, self.CR_threshold = (self.CR_current, self.alpha * self.CR_prev + (1 - self.alpha) * CR_current)
            return Action.D

class Strategy_COLLECTIVE_306(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-A) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        action = Action.C if opponent_cooperators >= self.game_description.n_players // 2 else Action.D
        self.history.my_actions[state.round_number] = action == Action.C
        return action

class Strategy_COLLECTIVE_307(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_actions = history.opponent_actions if history else np.zeros((state.round_number + 1, self.game_description.n_players), dtype=np.bool_)
        self.last_opponent_action = opponent_actions[-1, 0]
        if state.round_number == state.round_number - 1 or state.round_number == state.round_number - 2:
            return self.__call__(state, history)
        return Action(int(self.last_opponent_action)) if self.last_opponent_action is not None else Action.C

class Strategy_COLLECTIVE_309(BaseStrategy):
    """
    Strategy that implements the Tit-for-Tat with Modified Grim Trigger in N-Player Public Goods Game.
    The strategy cooperates initially and reciprocates cooperation if the opponent did so in the previous round.
    If the opponent defected, it will consider the history of cooperation to decide whether to cooperate or defect.
    If a certain threshold of consecutive defections is exceeded, it will trigger a "Grim Trigger" response and permanently switch to defecting against that opponent.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / 2)
        self.consecutive_defections = np.zeros(game_description.n_players, dtype=int)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if history is not None:
            if state.round_number == 1:
                action = Action.C
            elif history.opponent_actions[-1, -1] == Action.C:
                action = Action.C
            else:
                consecutive_defections = (history.opponent_actions[:, -1] == Action.D).sum()
                if consecutive_defections > self.threshold:
                    self.consecutive_defections[history.my_actions[-1]] += 1
                    action = Action.D
                else:
                    self.consecutive_defections[history.my_actions[-1]] = 0
                    if np.mean(history.opponent_actions[:, -1]) > 0.5:
                        action = Action.C
        return action

class Strategy_COLLECTIVE_310(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation Strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_counter = 0
        self.round_number = 1
        self.forgiveness_interval = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number % self.forgiveness_interval == 1:
            self.cooperation_counter = 1
        elif history and state.round_number > 0:
            self.cooperation_counter = history.opponent_actions[-1, -1]
        if self.cooperation_counter:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_311(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Tendency (TACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperators = np.zeros(game_description.n_rounds)
        self.h = int(math.ceil(game_description.n_rounds / 2))
        self.p = 0.5

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            total_cooperators = sum(history.opponent_actions[-1])
            average_cooperators = np.mean(self.average_cooperators)
            if total_cooperators > average_cooperators:
                return Action.C
        actions_in_h_rounds = history.opponent_actions[max(0, state.round_number - self.h):state.round_number]
        number_of_cooperators_in_h_rounds = sum(np.sum(actions_in_h_rounds, axis=1))
        if number_of_cooperators_in_h_rounds == self.h:
            return Action.C
        random_decision = random.random()
        if random_decision < self.p:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_312(BaseStrategy):
    """
    A strategy that implements the Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_actions = history.opponent_actions if history else np.zeros((state.round_number, self.game_description.n_players), dtype=np.bool_)
        self.last_opponent_action = opponent_actions[-1, 0] if state.round_number > 0 else None
        action = Action.C if state.round_number == self.game_description.n_rounds or (state.round_number > 0 and self.last_opponent_action > 0) else Action.D
        return action

class Strategy_COLLECTIVE_313(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that follows an adaptive Tit-for-Tat (ATFT) approach, encouraging cooperation when there's evidence of collaborative behavior among players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.h_initial = math.ceil(2)
        self.h_final = self.game_description.n_players - 1
        self.adjustment = (self.h_final - self.h_initial) / self.game_description.n_rounds
        self.history = [0] * (self.game_description.n_rounds + 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        t = state.round_number
        if t == self.game_description.n_rounds:
            self.h_final = min(self.h_final, self.game_description.n_players - 1)
        self.h = t / self.game_description.n_rounds * (self.h_final - self.h_initial) + self.h_initial
        if history is None:
            total_contributions = 0
        else:
            total_contributions = np.sum(history.opponent_actions[:t, :].sum(axis=1))
        if total_contributions >= self.h:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_315(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TFT-A) strategy for N-Player Public Goods Game.
    Cooperates in the first round to establish a cooperative environment and retaliates against defection in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if history is not None and state.round_number > 0:
            total_contributions = self.total_contributions[state.round_number - 1] + history.my_actions[-1]
            if total_contributions >= self.game_description.n_players - 1:
                action = Action.C
        self.total_contributions[state.round_number - 1] = np.sum(history.my_actions[-self.game_description.n_rounds:])
        return action

class Strategy_COLLECTIVE_316(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Generosity (TFT-AG) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.number_of_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.C
        self.number_of_defects = 0
        if history is not None:
            last_opponent_action = history.opponent_actions[-1, -1]
            if last_opponent_action == Action.D:
                self.number_of_defects += 1
                adaptive_generosity_factor = min(1 + 0.01 * self.number_of_defects, 1.5)
                if random.random() > adaptive_generosity_factor:
                    action = Action.D
            else:
                self.number_of_defects = 0
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.C
        return action

class Strategy_COLLECTIVE_317(BaseStrategy):
    """
    Implements the Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.last_round_action = np.mean(history.my_actions[-1]) > 0
        if state.round_number < self.game_description.n_rounds - 1:
            return Action(int(self.last_round_action))
        return Action.D

class Strategy_COLLECTIVE_319(BaseStrategy):
    """
    A simple Tit-for-Tat Adaptive strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperation = 0.0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            self.average_cooperation = np.mean(history.opponent_actions[-1])
        if state.round_number == self.game_description.n_rounds:
            if self.average_cooperation >= 0.5:
                return Action.C
            else:
                return Action.D
        cooperators = sum(history.opponent_actions[-1])
        if cooperators > self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_320(BaseStrategy):
    """
    A Tit-for-Tat with Gradient Adaptation (TfTGA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.threshold = game_description.n_players // 2
        self.gradient_step = (self.k - 1) / game_description.n_players * 0.05

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators >= self.threshold:
            return Action.C
        else:
            self.k += self.gradient_step * (opponent_cooperators - self.threshold)
        return Action.D

class Strategy_COLLECTIVE_322(BaseStrategy):
    """Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if not self.history or state.round_number == 0:
            self.history = history
            return Action.C
        total_cooperators = np.sum(self.history.opponent_actions[-1, :])
        if total_cooperators > self.n_players // 2:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.C

class Strategy_COLLECTIVE_324(BaseStrategy):
    """
    Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number - 1] = True
        total_coop_prev = sum(history.opponent_actions[-1]) if history else self.game_description.n_players
        my_contribution = len(history.my_actions) - sum(self.history.my_actions[:state.round_number]) if history else 0
        return Action.C if total_coop_prev >= self.game_description.n_players * my_contribution else Action.D

class Strategy_COLLECTIVE_325(BaseStrategy):
    """
    A Tit-for-Tat with Adaptation (TfTA) strategy for N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperation = self._calculate_opponent_cooperation(history)
        if opponent_cooperation >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

    def _calculate_opponent_cooperation(self, history: PlayerHistory) -> int:
        cooperators = np.sum(history.opponent_actions[-1])
        return math.ceil(cooperators / self.game_description.n_players * 100)

class Strategy_COLLECTIVE_327(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_cooperated = False
        self.uncooperative_opponents = set()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if history is not None:
            if state.round_number == self.game_description.n_rounds - 1:
                action = Action.C
            elif state.round_number > 1 and history.my_actions[-1] == Action.C:
                action = Action.C
            elif len(self.uncooperative_opponents) > 0 and self.game_description.n_players - 1 in self.uncooperative_opponents:
                action = Action.D
            elif state.round_number > 1 and history.my_actions[-1] == Action.D and (not self.last_opponent_cooperated):
                self.uncooperative_opponents.add(history.opponent_actions[-1, -1])
            elif state.round_number > 1 and history.my_actions[-1] == Action.C and (history.opponent_actions[-1][-1] == Action.C):
                self.last_opponent_cooperated = True
            elif state.round_number > 1 and history.my_actions[-1] == Action.C and (len(self.uncooperative_opponents) == 0):
                self.last_opponent_cooperated = False
        return action

class Strategy_COLLECTIVE_328(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.history is None:
            self.history = np.zeros((state.round_number + 1,), dtype=bool)
            self.history[0] = True
        total_cooperators_prev = np.sum(self.history[-state.round_number:])
        if total_cooperators_prev == self.game_description.n_players:
            return Action.C
        return Action.D

    def update(self, state: GameState, my_action: Action, payoff: float) -> None:
        if state.round_number == 0 or self.history is None:
            self.history = np.zeros((state.round_number + 1,), dtype=bool)
            self.history[0] = my_action == Action.C
        self.history[-state.round_number] = my_action == Action.C

class Strategy_COLLECTIVE_331(BaseStrategy):
    """
    Implementation of a Tit-for-Tat strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_contributions = np.sum(history.opponent_actions[:, -1])
        contributions_ratio = total_contributions / self.game_description.n_players
        if state.round_number < self.game_description.n_rounds:
            action = Action.C if contributions_ratio >= self.threshold else Action.D
        else:
            average_contributions = np.mean(history.opponent_actions[:, -self.game_description.n_rounds:])
            action = Action.C if average_contributions >= self.threshold else Action.D
        max_contributions = np.max(history.opponent_actions[:, -1])
        if max_contributions == contributions_ratio and (not state.round_number == 0):
            action = Action.C
        return action

class Strategy_COLLECTIVE_333(BaseStrategy):
    """
    A simple Tit-for-Tat strategy with Fitness Adaptation for an N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = -1
        self.current_state = Action.D

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number <= self.game_description.n_rounds - 2 or state.round_number == self.last_round + 1:
            if history is not None and self.current_state != history.opponent_actions[-1, 0]:
                self.current_state = Action.D if self.current_state == Action.C else Action.C
        elif state.round_number == self.last_round + 1:
            self.current_state = Action.C
        self.last_round = state.round_number
        return self.current_state

class Strategy_COLLECTIVE_334(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = 0.1
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if self.history is None:
            return Action.C
        t = state.round_number
        cooperators = np.sum(history.opponent_actions[t - 1])
        total_players = self.game_description.n_players
        if t == 1:
            return Action.C
        cooperation_rate = cooperators / total_players
        threshold = self.game_description.k / total_players * (1 + self.alpha)
        if cooperation_rate > threshold:
            return Action.C
        else:
            return Action.D
        if t == self.game_description.n_rounds:
            my_payoff = calculate_payoff(Action.C, cooperation_rate, self.game_description.k)
            if calculate_payoff(Action.D, cooperation_rate, self.game_description.k) > my_payoff:
                return Action.D
        if history.my_actions[-1] == 0:
            self.alpha = min(self.alpha + 0.1, 2)

    def reset(self):
        self.history = None
        self.alpha = 0.1

class Strategy_COLLECTIVE_335(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Adaptive Contribution (TfTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k_i = game_description.k
        self.threshold = int(game_description.n_players * 0.6)
        self.avg_contribution = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.my_payoffs.size > 0:
            self.avg_contribution = np.mean(history.my_actions.flatten())
            if history.opponent_actions[-1, :].sum() >= self.threshold:
                if self.k_i < self.game_description.k:
                    self.k_i += (self.game_description.n_players - history.opponent_actions[-1, :].sum()) * 0.1
                    self.k_i = min(self.k_i, self.game_description.k)
            elif history.opponent_actions[-1, :].sum() <= self.threshold:
                if self.k_i > 1:
                    self.k_i -= self.avg_contribution * 0.1
                    self.k_i = max(self.k_i, 1)
        if state.round_number == self.game_description.n_rounds - 1:
            if self.avg_contribution > self.threshold:
                return Action.C
        return Action(int(self.k_i > random.random()))

class Strategy_COLLECTIVE_336(BaseStrategy):
    """
    A strategy that encourages cooperation in a Public Goods game, mimicking human-like behavior by reciprocating cooperation and punishing defection with temporary ostracism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.n_players * self.game_description.n_rounds / (2 * (self.game_description.n_rounds + 1)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_history = np.where(history.opponent_actions.sum(axis=0) == 1, 1, 0) if history is not None else np.zeros(self.game_description.n_rounds).astype(int)
        recent_defections = len(opponent_history[opponent_history == 1])
        if recent_defections > self.threshold:
            return Action.C
        cooperator_count = history.opponent_actions[-1].sum() if history is not None else 0
        if cooperator_count == self.game_description.n_players:
            return Action.C
        elif cooperator_count > 0 and recent_defections < self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_337(BaseStrategy):
    """
    A Tit-for-Tat with Gradual Cooperation (TFTG) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = np.zeros((1 + self.game_description.n_rounds,), dtype=bool)
        self.total_contributions = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.history = self.history[-self.game_description.n_rounds:]
            self.total_contributions = np.sum(history.my_actions)
        action = Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            if np.sum(history.opponent_actions[-1]) > 0:
                action = Action.C
            elif np.sum(history.opponent_actions[-1]) == len(history.opponent_actions[0]) and state.round_number >= self.game_description.n_rounds // 2:
                action = Action.C
        return action

class Strategy_COLLECTIVE_339(BaseStrategy):
    """
    A cooperative Tit-for-Tat strategy with adjustable cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.adjustment_factor = 0.1
        self.cooperative_threshold = (game_description.n_players - 1) // 2
        self.past_rounds = 0
        self.average_cooperation = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.past_rounds += 1
        total_contributions = sum(history.opponent_actions[-self.past_rounds:])
        cooperators = total_contributions.sum()
        current_threshold = self.game_description.n_players - self.adjustment_factor if self.average_cooperation > self.cooperative_threshold else self.game_description.n_players + self.adjustment_factor
        if cooperators >= current_threshold:
            return Action.C
        return Action.D

    def update(self, history: PlayerHistory):
        self.average_cooperation = (self.past_rounds * self.average_cooperation + history.my_actions[-1]) / self.past_rounds

class Strategy_COLLECTIVE_341(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_threshold = int(game_description.n_players * 0.5)
        self.payoff_benchmark = np.mean([random.random() for _ in range(int(game_description.n_players * 1.2))])
        self.cooperation_frequency = game_description.n_players // game_description.n_rounds
        self.forgiveness_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_payoff = history.my_payoffs[-1] if history is not None else np.nan
        average_payoff = np.mean(history.my_payoffs) if history is not None else np.nan
        if state.round_number > 1 and history:
            if current_payoff < self.payoff_benchmark:
                self.cooperation_frequency *= 2
            elif current_payoff > self.payoff_benchmark * 1.5:
                self.cooperation_frequency /= 2
                self.forgiveness_counter = 0
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
        cooperators = sum(opponent_actions)
        cooperative_action = Action.C if (cooperators >= self.round_threshold or state.round_number == 1) and self.forgiveness_counter < self.game_description.n_rounds // 4 else Action.D
        if cooperative_action == Action.C:
            if opponent_actions[-1] == Action.D and self.forgiveness_counter < self.game_description.n_rounds // 8:
                self.forgiveness_counter += 1
            else:
                self.forgiveness_counter = 0
        if state.round_number == self.game_description.n_rounds:
            if average_payoff > self.payoff_benchmark:
                return Action.C
        return cooperative_action

class Strategy_COLLECTIVE_342(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0
        self.initial_round_cooperation = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.initial_round_cooperation = True
            return Action.C
        if history is not None:
            self.last_round_cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number == 1 or (state.round_number > 1 and self.initial_round_cooperation):
            self.initial_round_cooperation = False
            return Action.C
        if self.last_round_cooperators == self.game_description.n_players:
            return Action.C
        elif history.my_actions[-2] == Action.C and any(history.opponent_actions[-1, :] == [Action.D]) or (history.my_actions[-1] == Action.D and history.my_actions[-2] == Action.C):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_343(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT)
    Strategy Description: Cooperate in the first round, then follow the Tit-for-Tat rule for subsequent rounds. If the number of opponents who cooperated in the previous round is greater than or equal to half of the total players, cooperate; otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_opponent_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and history.opponent_actions[-1, :].sum() == 0):
            return Action.C
        self.last_round_opponent_cooperators = history.opponent_actions[-1, :].sum() if history else 0
        cooperate = self.last_round_opponent_cooperators >= self.game_description.n_players // 2
        return Action(int(cooperate))

class Strategy_COLLECTIVE_344(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperative (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_last_action = None
        self.opponent_last_actions = np.zeros((self.game_description.n_players, 1), dtype=np.bool_)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.my_last_action is None:
            return Action.C
        cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        if cooperators >= self.game_description.n_players // 2 and self.my_last_action == Action.D:
            return Action.C
        elif self.my_last_action is not None and self.opponent_last_actions[history.opponent_actions[state.round_number - 1, self.my_id]][0] == Action.D:
            return self.my_last_action
        else:
            self.my_last_action = not history.my_actions[state.round_number - 1, 0]
            self.opponent_last_actions = history.opponent_actions[state.round_number - 1, :]
            return Action.D if self.my_last_action else Action.C

class Strategy_COLLECTIVE_345(BaseStrategy):
    """Adaptive Tit-for-Tat with Probability of Cooperation (ATFTP)"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_high = 0.8
        self.p_low = 0.5
        self.round_number = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.round_number += 1
            return Action.C
        else:
            self.round_number = state.round_number
            if history.opponent_actions[-1].all():
                p = self.p_high
            else:
                p = self.p_low
            random_choice = random.random()
            if random_choice < p:
                action = Action.C
            else:
                action = Action.D
        if self.round_number == self.game_description.n_rounds:
            action = Action.C
        return action

class Strategy_COLLECTIVE_346(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_counter = 0
        self.history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros((game_description.n_rounds,), dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if history is not None:
            self.history = history
            self.round_counter += 1
        if state.round_number == 0:
            return Action.C
        elif self.round_counter < self.game_description.n_rounds - 1:
            opponent_cooperation = sum(self.history.opponent_actions[-1])
            return Action(int(opponent_cooperation > len(self.history.my_actions) // 2))
        else:
            return Action.C

class Strategy_COLLECTIVE_347(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_threshold = game_description.n_rounds // 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        last_move = history.opponent_actions[-1, 0] if history else Action.D
        if last_move == Action.C:
            return Action.C
        elif state.round_number > self.forgiveness_threshold and np.all(history.opponent_actions[state.round_number - self.forgiveness_threshold:, 0] == [False] * self.forgiveness_threshold):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_348(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the N-Player Public Goods Game.
    Designed to promote cooperation and maintain trust within the group, even when faced with defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_cooperation = 0
        self.p_forgive = game_description.k / game_description.n_players - 1

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1])
        action = Action.D
        if total_contributions == self.game_description.n_players:
            action = Action.C
        self.consecutive_cooperation += 0 if action == Action.D else 1
        self.p_forgive = self.game_description.k / self.game_description.n_players - self.consecutive_cooperation / state.round_number if action == Action.D else self.p_forgive + (1 - self.p_forgive) * (self.consecutive_cooperation / state.round_number)
        if history is not None and state.round_number < self.game_description.n_rounds:
            return action
        if self.consecutive_cooperation > 0:
            return Action.C if random.random() <= self.p_forgive else Action.D
        return Action.D

class Strategy_COLLECTIVE_349(BaseStrategy):
    """
    Implementation of the Tit-for-Tat Adaptive strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tunable_parameter = math.ceil(game_description.n_rounds * 0.5)
        self.recent_history = np.zeros((self.tunable_parameter,), dtype=np.bool_)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        if state.round_number == 0:
            self.recent_history[:] = True
        if len(self.recent_history) < self.tunable_parameter:
            action = history.opponent_actions[-1, state.player_index]
        else:
            cooperators = sum(self.recent_history)
            if cooperators > self.game_description.n_players * self.tunable_parameter // 4:
                action = Action.C
            else:
                action = Action.D
        self.recent_history[:-1] = self.recent_history[1:]
        self.recent_history[-1] = action == Action.C
        return action

class Strategy_COLLECTIVE_350(BaseStrategy):
    """
    A strategy that uses the Tit-for-Tat Adaptive Cooperation (TFTAC) approach in N-Player Public Goods Games.
    This strategy cooperates initially and punishes defection, but also considers overall payoff when deciding to cooperate or defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_round = True
        self.opponent_history = np.zeros((game_description.n_rounds, 1), dtype=bool)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number - 1
        opponent_action = history.opponent_actions[current_round, 0] if history else self.opponent_history[current_round, 0]
        decision_round = current_round + 1 if state.round_number < self.game_description.n_rounds else state.round_number
        action = Action.C if opponent_action else Action.D
        if not self.initial_round and (state.round_number == self.game_description.n_rounds or decision_round >= self.game_description.n_rounds - 1):
            total_payoff = history.my_payoffs[-1] if history else np.mean(self.calculate_payoffs())
            average_payoff = np.mean(self.calculate_payoffs())
            action = Action.C if total_payoff >= average_payoff else Action.D
        self.opponent_history[current_round, 0] = opponent_action
        return action

    def calculate_payoffs(self) -> NDArray[np.float64]:
        """
        Calculate the payoffs for all rounds based on this strategy's actions and opponents' actions.
        """
        cooperators = self.opponent_history.sum(axis=0)
        contributions = np.where(self.opponent_history, 1, 0).sum(axis=0)
        payoffs = np.ones((self.game_description.n_rounds,)) - self.opponent_history + self.game_description.k / self.game_description.n_players * contributions / cooperators
        return payoffs

class Strategy_COLLECTIVE_354(BaseStrategy):
    """
    Tit-for-Tat Cooperation Strategy (TFTC) for N-Player Public Goods Game.
    Promotes cooperation by rewarding it and punishing defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1]) if history else 0
        self.last_round_cooperators = cooperators
        return Action.C if all([cooperator for cooperator in history.opponent_actions[-1] if cooperator == 1]) else Action.D

class Strategy_COLLECTIVE_356(BaseStrategy):
    """
    A strategy that cooperates if a majority of players contributed in the previous round, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C if random.random() < 0.5 else Action.D
        cooperators = sum(history.opponent_actions[-1])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_357(BaseStrategy):
    """
    A strategy that cooperates initially and reciprocates cooperation or defects based on opponents' actions in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.empty((game_description.n_rounds,), dtype=bool), my_payoffs=np.empty((game_description.n_rounds,), dtype=float), opponent_actions=np.empty((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.empty((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        self.history.my_actions[state.round_number - 1] = (Action.C if history is not None else Action.D) == Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if state.round_number < self.game_description.n_rounds:
            return (Action.C if opponent_cooperators > 0 else Action.D) if history is not None else Action.D
        last_round = self.game_description.n_rounds - 1
        penultimate_round = last_round - 1
        if state.round_number == last_round:
            return (Action.C if history.opponent_actions[penultimate_round, :].sum() > 0 else Action.D) if history is not None else Action.C
        elif state.round_number == penultimate_round:
            return (Action.C if history.opponent_actions[-1, :].sum() > 0 else Action.D) if history is not None else Action.C

class Strategy_COLLECTIVE_358(BaseStrategy):
    """
    Strategy: Adaptive Tit-for-Tat with Grace Period and Gradual Escalation (ATFT_GPGE).
              This strategy cooperates at first, retaliates minimally when others defect,
              and gradually eases back into cooperative behavior if opponents return to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.grace_period = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self.grace_period = False
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=np.bool_)
        if self.grace_period or all(opponent_actions):
            return Action.C
        elif any(opponent_actions):
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_359(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t_wait = int(math.ceil(game_description.n_players / 2 * (1 + math.sqrt(game_description.n_players))))
        self.total_contributions = 0
        self.contributions_history = np.zeros(game_description.n_rounds, dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.contributions_history[state.round_number - 1] = True if history is not None and np.sum(history.opponent_actions[-1, :]) > self.game_description.n_players // 2 else False
        self.total_contributions += int(self.contributions_history[-1])
        action = Action.C if self.total_contributions > self.game_description.n_players // 2 else Action.D
        payoff = 1 - int(action == Action.D) + self.game_description.k / self.game_description.n_players * np.sum(self.contributions_history)
        if state.round_number >= self.t_wait and action == Action.D:
            action = Action.C
        return action

class Strategy_COLLECTIVE_360(BaseStrategy):
    """
    A strategy inspired by Tit-for-Tat Cooperation for N-Player Public Goods Game.
    Cooperate on the first round, and in subsequent rounds, cooperate if all opponents cooperated in the previous round; defect otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.opponent_history.append(np.mean(history.opponent_actions, axis=0))
        cooperation_last_round = np.all(self.opponent_history[-1] == 1)
        if state.round_number < self.game_description.n_rounds - 1:
            return Action(cooperation_last_round)
        return Action.C

class Strategy_COLLECTIVE_363(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Contribution (TFTAC) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.rounds_memory = np.zeros(game_description.n_rounds, dtype=np.float64)
        self.average_cooperation = 0.0
        self.m = int(math.ceil(self.game_description.n_rounds * 0.2))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.my_actions) > self.m:
            total_contributions = np.sum(history.my_actions[-self.m:])
            self.average_cooperation = total_contributions / self.m
            contribution_level = 1.0 if self.average_cooperation >= 0.6 else self.average_cooperation * (self.game_description.k / self.game_description.n_players)
            return Action(int(contribution_level > 0))
        return Action.D

class Strategy_COLLECTIVE_364(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Generosity (TFT-AG).
    Cooperates initially and responds to opponents' cooperation history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.history.append(int(np.all(history.opponent_actions[-1])))
        if state.round_number == len(self.history):
            cooperators = sum(self.history)
            if cooperators > len(self.history) // 2 or cooperators >= self.game_description.n_players - (len(self.history) - cooperators):
                return Action.C
        return Action(self.history[-1])

class Strategy_COLLECTIVE_365(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_cooperation = True
        self.player_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        player_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players)
        total_cooperation = np.sum(player_actions)
        if total_cooperation > self.game_description.n_players // 2:
            action = Action.C
        else:
            action = Action.D
        self.initial_cooperation = False if state.round_number > 0 else True
        return action

class Strategy_COLLECTIVE_366(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperated_last = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or history.my_actions is None:
            self.opponent_cooperated_last = None
            return Action.C
        if self.opponent_cooperated_last is None:
            self.opponent_cooperated_last = len(history.my_actions) > 0 and history.my_actions[-1] == Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if self.opponent_cooperated_last is not None:
                return Action(int(self.opponent_cooperated_last))
            else:
                return Action.D
        if history.my_actions[-1] == Action.C:
            self.opponent_cooperated_last = True
            return Action.C
        elif len(history.my_actions) > 0 and self.opponent_cooperated_last is False:
            self.opponent_cooperated_last = False
            return Action.D
        else:
            self.opponent_cooperated_last = True
            return Action.C

class Strategy_COLLECTIVE_367(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players * game_description.k // game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_368(BaseStrategy):
    """
    A Tit-for-Tat Plus (TfT+) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_length = game_description.n_rounds - 1

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.opponent_actions) < self.history_length:
            return Action.D
        most_recent_round = state.round_number - 1
        if most_recent_round >= self.history_length:
            for round_idx in range(self.history_length - 1, -1, -1):
                if sum(history.opponent_actions[round_idx, :]) == len(history.opponent_actions[0]):
                    return Action.C
            return Action.D
        else:
            if sum(history.opponent_actions[most_recent_round, :]) == len(history.opponent_actions[0]):
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_369(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy with forgiveness for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.player_action = Action.C
        self.forgiveness_counter = 1
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.first_round = True
            return Action.C
        if history is not None:
            self.first_round = False
        action = self.player_action
        total_cooperators = np.sum(history.opponent_actions[-1])
        if total_cooperators == 0:
            self.forgiveness_counter = min(self.game_description.n_players, self.forgiveness_counter + 1)
            if self.forgiveness_counter >= self.game_description.n_players // 2 and np.random.rand() < 0.05:
                action = Action.C
        elif total_cooperators == self.game_description.n_players:
            self.forgiveness_counter = 1
        else:
            self.forgiveness_counter += 1
        if state.round_number == state.round_number - self.forgiveness_counter:
            action = Action.C
        return action

class Strategy_COLLECTIVE_370(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    This strategy cooperates initially and mirrors opponents' previous actions while taking into account historical cooperation trends.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.sliding_window = int(math.ceil(game_description.n_rounds * 0.2))
        self.threshold = 0.75
        self.state = {'cooperator_count': np.zeros(self.sliding_window), 'round': 0, 'last_opponent_cooperation': False}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or self.state['round'] == 0:
            return Action.C
        self.state['round'] += 1
        if self.state['round'] <= self.sliding_window:
            self.state['cooperator_count'] = np.roll(self.state['cooperator_count'], -1)
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        self.state['cooperator_count'][self.state['round'] % self.sliding_window] = int(cooperators >= self.game_description.n_players * self.threshold)
        average_cooperators = np.mean(self.state['cooperator_count'])
        if history is not None and cooperators > 0:
            self.state['last_opponent_cooperation'] = history.opponent_actions[-1, state.player_index]
        return Action.C if average_cooperators >= self.threshold or (self.state['round'] == 1 and self.state['last_opponent_cooperation']) else Action.D

class Strategy_COLLECTIVE_372(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)
    Strategy Description: Implementation of the TFT-AC strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_mcr = None
        self.threshold = 0.6 * self.game_description.n_players

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        mcr = np.mean(history.my_actions[-self.game_description.n_rounds:])
        own_last_action = history.my_actions[-1]
        if mcr == 1:
            return Action.C
        elif mcr == self.game_description.n - 1:
            return Action.D
        elif mcr == self.game_description.n / 2:
            return own_last_action
        elif abs(mcr - self.average_mcr) > self.threshold:
            self.average_mcr = mcr
        elif own_last_action == Action.C:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_373(BaseStrategy):
    """
    This strategy implements Tit-for-Tat with Adaptive Cooperation (TFT-AC).
    It mimics the most frequent opponent strategy in previous rounds, adjusting for deviations and forgiveness.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.most_common_strategy = Action.D
        self.longest_streak = 0
        self.current_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.history += [history.opponent_actions[-1]] if state.round_number < self.game_description.n_rounds else history.opponent_actions[-self.game_description.n_rounds:]
        if len(self.history) == self.game_description.n_rounds:
            self.most_common_strategy, self.longest_streak, self.current_streak = self.find_most_common_strategy()
        if state.round_number == self.game_description.n_rounds:
            return self.__decide_last_round(history)
        return self.__decide_subsequent_round(self.most_common_strategy, history)

    def find_most_common_strategy(self):
        strategies = np.bincount(self.history[-self.game_description.n_rounds:].flatten())
        most_common, longest_streak = max(enumerate(strategies), key=lambda x: (x[1], sum(strategies >= x[1])))
        return (Action(most_common), longest_streak, self.current_streak)

    def __decide_last_round(self, history):
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators >= len(history.opponent_actions) // 2:
            return Action.C
        return self.most_common_strategy

    def __decide_subsequent_round(self, strategy, history):
        current_streak = np.count_nonzero(np.array([strategy == action for action in history.opponent_actions[-1]]))
        if self.most_common_strategy != strategy and current_streak >= self.longest_streak:
            self.most_common_strategy, self.longest_streak, self.current_streak = (strategy, current_streak, 1)
        return self.most_common_strategy

class Strategy_COLLECTIVE_375(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

    This strategy follows the Tit-for-Tat game theory strategy, encouraging reciprocal behavior while retaliating against defection. The TFTA variant has an adaptive cooperation aspect where it cooperates more frequently if opponents also tend to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_opponent_action = np.all(history is None)
            return Action.C if self.last_opponent_action else Action.D
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players)
        cooperators = sum(opponent_actions)
        self.last_opponent_action = cooperators >= self.game_description.n_players - 1
        return Action.C if self.last_opponent_action and state.round_number != self.game_description.n_rounds else Action.D

class Strategy_COLLECTIVE_376(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_action = history.my_actions[-1] if history else None
        opponent_cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        response = Action.D if my_action is None or not my_action or opponent_cooperators == 0 else Action.C
        return response

class Strategy_COLLECTIVE_378(BaseStrategy):
    """
    A Tit-for-Tat with Variable Cooperation (TFTV) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.previous_action = history.my_actions[-1] if len(history.my_actions) > 0 else None
        cooperation_threshold = math.ceil(self.game_description.n_players / 2)
        cooperators_in_last_round = sum(history.opponent_actions[-1, :])
        if state.round_number == 1 or self.previous_action is None:
            return Action.C
        if cooperators_in_last_round >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_379(BaseStrategy):
    """
    An Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    This strategy cooperates initially, then mimics the opponent's actions from the previous round.
    It also considers edge cases in the last and potential final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_contributions = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=np.bool_)
        last_cooperators = sum(opponent_actions)
        if state.round_number == self.game_description.n_rounds:
            return Action.C if last_cooperators >= self.average_contributions else Action.D
        return Action.C if last_cooperators > 0 else Action.D

class Strategy_COLLECTIVE_380(BaseStrategy):
    """
    Fractional Contribution Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.contribution_rates = np.zeros((self.game_description.n_rounds + 1,))
        self.average_contribution_rates = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        contributions = np.sum(history.my_actions) if history else self.contribution_rates[1:]
        average_contributions = contributions / (self.game_description.n_players * (state.round_number - 1))
        contribution_rate = max(0, min(1, self.cooperation_threshold * average_contributions))
        if state.round_number < self.game_description.n_rounds:
            self.contribution_rates[state.round_number] = contribution_rate
        return Action(int(contribution_rate > 0))

class Strategy_COLLECTIVE_381(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.opponent_history:
            self.opponent_history.append(history.opponent_actions[state.round_number - 1])
        action = Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            action = Action.C
        self.opponent_history.append(history.opponent_actions[state.round_number - 1])
        return action

class Strategy_COLLECTIVE_383(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    This strategy starts with cooperating in the first round, and subsequently copies the action of the previous round's majority.
    In case of a tie or last round, it chooses to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self._history.my_actions[state.round_number - 1] = Action.C if history is None else history.my_actions[-1]
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else np.sum(self._history.opponent_actions[-1, :])
        if cooperators > self.game_description.n_players // 2:
            return Action.C
        if len(self._history.my_actions) <= 1 or (len(self._history.my_actions) % 2 == 1 and cooperators <= self.game_description.n_players // 2):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_385(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TfTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 80
        self.num_rounds_passed = 0
        self.previous_cooperation_percentage = 100

    def calculate_cooperation_percentage(self, opponent_actions: NDArray[np.bool_]):
        return np.sum(opponent_actions) / self.game_description.n_players * 100

    def decide_action(self, opponent_actions: NDArray[np.bool_]) -> Action:
        cooperation_percentage = self.calculate_cooperation_percentage(opponent_actions)
        if self.num_rounds_passed == 0:
            action = Action.C
        elif cooperation_percentage >= self.threshold:
            action = Action.C
        else:
            action = Action.D
        self.num_rounds_passed += 1
        if self.num_rounds_passed < self.game_description.n_rounds:
            new_threshold = max(40, min(80, math.ceil(self.threshold - self.num_rounds_passed // 20 * 5)))
            self.threshold = max(new_threshold - self.num_rounds_passed // 20 * 5, 40)
        else:
            new_threshold = max(40, min(80, math.ceil(self.threshold - self.game_description.n_rounds // 10 * 5)))
            self.threshold = max(new_threshold - self.game_description.n_rounds // 10 * 5, 40)
        if cooperation_percentage < self.previous_cooperation_percentage:
            new_threshold = min(80, math.ceil(self.threshold + self.num_rounds_passed // 20 * 5))
            self.threshold = min(new_threshold + self.num_rounds_passed // 20 * 5, 80)
        self.previous_cooperation_percentage = cooperation_percentage
        return action

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return self.decide_action(np.full((self.game_description.n_players,), True))
        else:
            return self.decide_action(history.opponent_actions[-1])

class Strategy_COLLECTIVE_387(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 0.25

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            previous_round = [Action.D for _ in range(self.game_description.n_players)]
        else:
            previous_round = history.opponent_actions[-1]
        average_cooperation = np.mean(previous_round)
        if average_cooperation >= self.game_description.n_players * (1 - self.epsilon):
            action = Action.C
        elif average_cooperation <= self.game_description.n_players * self.epsilon:
            action = Action.D
        else:
            action = previous_round[state.player_index]
        return action

class Strategy_COLLECTIVE_388(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperative Strategy for N-Player Public Goods Game.
    Cooperates in the initial round and mimics opponents' actions from subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif self.last_round_action is None and history is not None:
            self.last_round_action = np.mean(history.opponent_actions[-1])
        return Action(int(self.last_round_action * (Action.C.value - Action.D.value) + Action.D.value))

    def finalize_round(self, state: GameState, history: PlayerHistory) -> None:
        self.last_round_action = np.mean(history.opponent_actions[-1])

class Strategy_COLLECTIVE_389(BaseStrategy):
    """
    Tit-for-Tat-Adaptive (TfTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory):
        action = Action.D
        if state.round_number == 0 or len(history.opponent_actions) < 2:
            action = Action.C
        elif np.all(history.opponent_actions[-2]):
            action = Action.C
        else:
            action = history.my_actions[-1] if np.all(history.opponent_actions[-2]) else Action.D
        self.history.my_actions[state.round_number] = bool(action)
        if state.round_number > 0:
            cooperators = sum(history.opponent_actions[-1])
            self.history.my_payoffs[state.round_number] = 1 - bool(action) + self.game_description.k / self.game_description.n_players * cooperators
        return action

class Strategy_COLLECTIVE_390(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players)), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_391(BaseStrategy):
    """
    A Tit-for-Tat strategy for N-player Public Goods Games, which cooperates if the majority of players in the previous round also cooperated.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.majority = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        if cooperators >= self.majority:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_392(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._opponent_last_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self._opponent_last_action = np.mean(history.opponent_actions[-1])
        if history.my_actions[-1] and self._opponent_last_action:
            return Action.C
        elif not history.my_actions[-1] and self._opponent_last_action and np.all(history.my_actions[:-1][::-1] == self._opponent_last_action):
            return Action.C
        elif not history.my_actions[-1]:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_393(BaseStrategy):
    """
    A simple Tit-for-Tat Plus (TFT+) strategy for the N-Player Public Goods Game.
    This strategy encourages cooperation by demonstrating a willingness to work together and only retaliating when necessary.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_last_action = Action.D

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if self.opponent_last_action == Action.D:
            opponent_cooperated = sum(history.opponent_actions[-1, :]) < self.game_description.n_players - 1
        else:
            opponent_cooperated = True
        if state.round_number == self.game_description.n_rounds or not opponent_cooperated:
            self.opponent_last_action = Action.D
            return Action.C
        self.opponent_last_action = history.opponent_actions[-1][-1]
        return Action.C if self.opponent_last_action == Action.C else Action.D

class Strategy_COLLECTIVE_395(BaseStrategy):
    """
    Tit-for-Tat Cooperation Strategy (TFTC) for N-Player Public Goods Game.
    This strategy cooperates in the first round and subsequently cooperates if the majority of players cooperated in the previous round.
    If not, it will defect to encourage other players to cooperate in the future.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.majority_count = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperator_count = sum(history.opponent_actions[-1, :])
        if cooperator_count >= self.majority_count:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_396(BaseStrategy):
    """
    Tit-for-Tat Cooperative Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.r * 0.8)
        self.total_contributions = np.zeros(self.r + 1)
        self.average_total_contributions = self.total_contributions[self.m] / self.m

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 or state.round_number == self.r:
            return Action.C
        contributions = sum(history.opponent_actions[-1])
        if contributions >= self.average_total_contributions:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_397(BaseStrategy):
    """
    A cooperative strategy that adapts to player behavior and encourages cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 1 - 1 / math.sqrt(self.game_description.n_players)
        self.grace_period = min(int(math.log2(self.game_description.n_players)), self.game_description.n_rounds // 4)
        self.current_round = 0
        self.player_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.current_round += 1
        if self.current_round <= self.grace_period:
            return Action.C
        if self.current_round == 1 + self.game_description.n_rounds:
            return self._choose_last_round_action(state, history)
        cooperators = sum(history.opponent_actions[-self.grace_period:, :].flatten())
        cooperation_rate = cooperators / self.grace_period if self.grace_period > 0 else 0
        return Action.C if cooperation_rate >= self.cooperation_threshold else Action.D

    def _choose_last_round_action(self, state: GameState, history: PlayerHistory) -> Action:
        payoffs = history.my_payoffs[-1]
        if payoffs[Action.C] > payoffs[Action.D]:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_398(BaseStrategy):
    """
    A Tit-for-Tat strategy for N-Player Public Goods Game.
    Cooperates if all others cooperated in the last round, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_round_cooperators = sum(history.opponent_actions[-1])
        if state.round_number < self.game_description.n_rounds and self.last_round_cooperators == self.game_description.n_players:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_399(BaseStrategy):
    """
    A strategy that mimics the Tit-for-Tat Adaptive (TFT-A) behavior in N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.dealt_punishment = False
        self.defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if history:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators > 0:
                action = Action.C
                self.dealt_punishment = False
            else:
                self.defections += 1
                if self.defections >= math.ceil(self.game_description.n_players / 2) or state.round_number == self.game_description.n_rounds:
                    action = Action.D
                    self.dealt_punishment = True
                    self.defections -= 1
        return action

class Strategy_COLLECTIVE_400(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.acceptance_threshold = int(game_description.n_players * 0.5)
        self.min_cooperation_threshold = int(game_description.n_players * 0.2)
        self.max_cooperation_threshold = int(game_description.n_players * 0.8)
        self.average_cooperation = 0
        self.rounds_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0 and history is None:
            return action
        self.rounds_count += 1
        if self.rounds_count < self.game_description.n_rounds // 20:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.acceptance_threshold:
                action = Action.C
        else:
            cooperators_ratio = sum(history.opponent_actions[:, -self.game_description.n_rounds // 20:].sum(axis=1) > self.acceptance_threshold) / (self.game_description.n_rounds // 20)
            if cooperators_ratio < self.min_cooperation_threshold:
                self.acceptance_threshold = max(self.acceptance_threshold - int(self.acceptance_threshold * 0.1), 1)
            elif cooperators_ratio > self.max_cooperation_threshold:
                self.acceptance_threshold = min(self.acceptance_threshold + int(self.acceptance_threshold * 0.1), self.game_description.n_players - 1)
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.acceptance_threshold:
                action = Action.C
        return action

class Strategy_COLLECTIVE_402(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat (ATFT)
    Summary: Cooperates in the first round and cooperates if the majority of players cooperated in the previous round, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.majority = math.floor((self.game_description.n_players + 1) / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.opponent_actions is not None and len(history.opponent_actions) > 0:
            cooperators = np.sum(history.opponent_actions[-1])
            if cooperators >= self.majority:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_403(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_opponent_action is None:
            self.last_opponent_action = history.opponent_actions[state.round_number - 1, 0]
        action = Action.C if self.last_opponent_action else Action.D
        self.last_opponent_action = history.opponent_actions[state.round_number - 1, 0]
        return action

class Strategy_COLLECTIVE_404(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT)
    Summary: A cooperative strategy that encourages mutual cooperation while protecting from long-term exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperated_last = False

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.opponent_cooperated_last = any(history.opponent_actions[-1])
        if state.round_number < self.game_description.n_rounds - 1 and self.opponent_cooperated_last:
            return Action.C
        elif state.round_number < self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_405(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number] = True
        self.history.opponent_actions[state.round_number, :] = np.mean(self.history.opponent_actions[:state.round_number + 1, :], axis=0) > self.game_description.n_players // 2
        if self.history.opponent_actions[-1, :].sum() < self.game_description.n_players - 1:
            return Action.D
        return np.mean(self.history.opponent_actions[-1:])

class Strategy_COLLECTIVE_406(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    This strategy promotes cooperation and reciprocity while considering the consequences of defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.player_history = [False for _ in range(game_description.n_players + 1)]
        self.last_cooperation_index = -1
        self.punishment_counter = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        elif state.round_number >= self.player_history.index(False):
            self.last_cooperation_index = self.player_history.index(False)
            cooperators = np.sum(history.opponent_actions[-1])
            if cooperators == 0:
                if self.punishment_counter < self.game_description.n_players - 1:
                    self.punishment_counter += 1
                else:
                    self.punishment_counter = 0
            else:
                self.punishment_counter = 0
                if self.last_cooperation_index > 0 and history.round_number - self.last_cooperation_index >= self.game_description.n_players - 1:
                    action = Action.C
        else:
            cooperators = np.sum(history.opponent_actions[state.round_number - 1])
            if history.my_actions[state.round_number - 1] and cooperators > 0:
                action = Action.C
        return action

class Strategy_COLLECTIVE_407(BaseStrategy):
    """
    A cooperative Tit-for-Tat variant strategy for the N-Player Public Goods Game with memory and adaptation capabilities.
    """
    MEMORY_FACTOR = 1.2
    LAST_ROUND_THRESHOLD = 0.75

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_contributions = np.zeros(self.game_description.n_rounds)
        self.num_cooperators_history = [0] * self.game_description.n_rounds

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_action = history.my_actions[state.round_number - 1]
        total_contributions = sum(history.opponent_actions[state.round_number - 1])
        if total_contributions >= self.average_contributions[-1] * self.MEMORY_FACTOR:
            return Action.C
        elif my_action:
            num_cooperators = sum(history.my_actions[:state.round_number])
            if num_cooperators / state.round_number >= self.average_contributions[-1] * self.MEMORY_FACTOR:
                return Action.C
        average_contributions = np.roll(self.average_contributions, -1)
        average_contributions[state.round_number - 1] = total_contributions / state.round_number
        self.average_contributions = average_contributions
        if state.round_number == self.game_description.n_rounds:
            if total_contributions >= self.average_contributions[-1] * self.LAST_ROUND_THRESHOLD:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_408(BaseStrategy):
    """
    This strategy is based on Tit-for-Tat Adaptive Cooperation (TFT-A). It initiates cooperation in the first round, and then cooperates if the opponent cooperated in the previous round. If the opponent defected, it defects as well. In the last round, it always cooperates regardless of the opponent's previous action.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperated_last_round = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.cooperated_last_round = True
            return Action.C
        elif history is not None and state.round_number < self.game_description.n_rounds:
            if self.cooperated_last_round:
                action = Action.C
            else:
                action = Action.D
            self.cooperated_last_round = not action
        elif state.round_number == self.game_description.n_rounds:
            action = Action.C
            self.cooperated_last_round = True
        return action

class Strategy_COLLECTIVE_409(BaseStrategy):
    """
    Implements the Adaptive Tit-for-Tat (ATFT) strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or len(history.opponent_actions) < 2:
            return Action.C
        prev_cooperators = sum(history.opponent_actions[-1])
        last_action = Action(int(state.round_number > 0 and history.my_actions[-1] == 1))
        current_cooperators = last_action if state.round_number == 1 else sum(history.opponent_actions[state.round_number - 1])
        cooperate = prev_cooperators > self.game_description.n_players // 2 and last_action == Action.C or (current_cooperators < (self.game_description.n_players + 1) // 2 and last_action == Action.D)
        return Action(int(cooperate))

class Strategy_COLLECTIVE_410(BaseStrategy):
    """
    Strategy name: Tit-for-Tat Adaptive (TFT-A) for N-Player Public Goods Game
    Summary: Cooperates initially and responds to opponents' actions from the previous round. If an opponent cooperated in the previous round, cooperate; otherwise, defect. Adapts to cooperation based on initial rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_few_rounds = self.game_description.n_players // 5
        self.last_round_cooperation = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if state.round_number > self.first_few_rounds:
            last_round = history.opponent_actions[-1]
            cooperation_ratio = np.mean(last_round)
            action = Action.C if cooperation_ratio >= 0.5 else Action.D
        elif state.round_number > 0 and history is not None:
            last_round = history.opponent_actions[-1]
            self.last_round_cooperation = np.mean(last_round) >= 0.5
        return action

class Strategy_COLLECTIVE_411(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.past_interactions = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.update_past_interactions(history)
        action = Action.D
        for opponent, past in self.past_interactions.items():
            last_action = past[-1]
            if last_action == Action.C:
                action = Action.C
            elif last_action == Action.D and state.round_number > 1:
                action = Action.D
        return action

    def update_past_interactions(self, history):
        for round_num in range(history.opponent_actions.shape[0]):
            opponent_action = history.opponent_actions[round_num, :]
            if self.__class__ not in self.past_interactions:
                self.past_interactions[self.__class__] = []
            for i, is_cooperator in enumerate(opponent_action):
                if isinstance(is_cooperator, np.bool_):
                    self.past_interactions[self.__class__].append(is_cooperator)

class Strategy_COLLECTIVE_412(BaseStrategy):
    """
    Tit-for-Tat with Fitness-Based Adaptation (TFT-FA) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_history = [False]

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        strategy = self.cooperation_history[-1] if len(self.cooperation_history) > state.round_number else False
        if opponent_cooperators >= self.game_description.n_players // 2 and strategy:
            self.cooperation_history.append(True)
            return Action.C
        self.cooperation_history.append(False)
        return Action.D

class Strategy_COLLECTIVE_413(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for the N-Player Public Goods Game.
    This simple yet robust strategy encourages cooperation and punishes defection, promoting long-term stable equilibrium.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.probability_defect_first_round = 0.05

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C if random.random() > self.probability_defect_first_round else Action.D
        previous_opponent_action = np.mean(history.opponent_actions[-1])
        return Action.C if previous_opponent_action == 1 else Action.D

class Strategy_COLLECTIVE_414(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)
    - A strategy that encourages cooperation and punishment, combined with an adaptive forgiveness phase.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_length = int(math.floor(game_description.n_players / 2))
        self.last_round_cooperation_threshold = math.ceil(game_description.n_players * 0.5)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = len(history.opponent_actions) - 1 if history else state.round_number
        opponent_last_action = history.opponent_actions[current_round, 0] if history else None
        if opponent_last_action is None or current_round == state.round_number - 1:
            return Action.C
        cooperation_phase = self.forgiveness_length
        while cooperation_phase > 0:
            if current_round < state.round_number - cooperation_phase and opponent_last_action == Action.D:
                cooperation_phase -= 1
                break
            cooperation_phase -= 1
            if opponent_last_action == Action.C:
                return Action.C
        return opponent_last_action

    def last_round_decision(self, state: GameState, history: PlayerHistory) -> Action:
        cooperators = np.count_nonzero(history.opponent_actions[-1])
        payoffs_difference = self.game_description.n_players * (1 - self.game_description.k / self.game_description.n_players) * state.round_number
        if cooperators >= self.last_round_cooperation_threshold:
            return Action.C
        if history.my_payoffs[-1] > payoffs_difference:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_415(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t_punish = math.ceil(game_description.n_rounds * 0.2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            cooperators = sum(history.opponent_actions[-1])
            if cooperators == self.game_description.n_players or (cooperators == self.game_description.n_players - 1 and state.round_number > self.t_punish):
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_416(BaseStrategy):
    """
    Implementation of Tit-for-Tat-Adaptive (TfT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.partner_cooperates = False
        self.cooperation_count = 0
        self.total_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self.partner_cooperates = history.opponent_actions[state.round_number - 1][0]
            self.total_rounds += 1
            self.cooperation_count += int(self.partner_cooperates)
        if state.round_number == 0:
            return Action.C
        elif state.round_number < self.game_description.n_rounds and self.partner_cooperates:
            return Action.C
        elif state.round_number < self.game_description.n_rounds and (not self.partner_cooperates):
            return Action.D
        elif state.round_number == self.game_description.n_rounds:
            cooperation_ratio = self.cooperation_count / self.total_rounds
            if cooperation_ratio > self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        return latest_action(history)

class Strategy_COLLECTIVE_417(BaseStrategy):
    """
    A Tit-for-Tat with Fault Tolerance strategy for the N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(math.floor(game_description.n_players / 2))
        self.past_cooperation = False
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 or history is None:
            self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))
            return Action.C
        self.history = history
        previousRound = len(self.history.opponent_actions) - 1
        total_cooperators = np.sum(self.history.opponent_actions[previousRound])
        if total_cooperators == self.game_description.n_players:
            return Action.C
        if total_cooperators > 0 and (not self.past_cooperation):
            p_cooperate = min(1, max(0.5, (self.game_description.n_players - total_cooperators) / self.game_description.n_players))
            if random.random() <= p_cooperate:
                self.past_cooperation = True
                return Action.C
        if self.past_cooperation and np.all(self.history.opponent_actions[previousRound]) == [True]:
            self.past_cooperation = True
            return Action.C
        if not self.past_cooperation or np.any(self.history.opponent_actions[previousRound]) == [False]:
            p_cooperate = max(0.5, random.random())
            if random.random() <= p_cooperate:
                self.past_cooperation = False
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_418(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

    This strategy cooperates initially and adapts to the opponent's behavior
    by considering the number of cooperators in the most recent round.
    If more than half of the opponents cooperate, it continues cooperation.
    Otherwise, it defects unless the opponent has behaved cooperatively for a certain number of rounds (tolerance threshold).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance_threshold = int(math.ceil(game_description.n_players / 2))
        self.cooperation_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.round_number > 1 and history is not None:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            if opponent_cooperators >= self.tolerance_threshold:
                return Action.C
            if opponent_cooperators > 0:
                self.cooperation_counter += 1
                if self.cooperation_counter >= self.tolerance_threshold:
                    return Action.C
            else:
                self.cooperation_counter = 0
        return Action.D

class Strategy_COLLECTIVE_419(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    Strategy Description: Reciprocates cooperation when others cooperate, punishes defection by withholding cooperation.
                           Adapts the number of initial cooperative rounds based on opponent behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.f = math.floor(self.game_description.n_rounds / 2)
        self.history = PlayerHistory(np.zeros((1, 3), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        self.history = history if history else self.history
        if state.round_number == 0:
            return Action.C
        opponent_strategy = np.mean(self.history.opponent_actions[:, -self.f:]) > (self.game_description.n_players - 1) / 2
        if not opponent_strategy and self.history.my_actions[-1]:
            self.f = max(int(self.f * 0.5), 1)
        last_round = len(self.history.opponent_actions) - 1
        if state.round_number == last_round or (not opponent_strategy and self.history.my_actions[last_round]):
            return Action.D
        prev_round = last_round - 1 if last_round > 0 else 0
        total_cooperators = np.sum(self.history.opponent_actions[prev_round, :])
        all_players_cooperated = total_cooperators == self.game_description.n_players
        opponent_cooperated_last = self.history.opponent_actions[last_round, self.history.my_actions[-1] - 1]
        if all_players_cooperated or opponent_cooperated_last:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_421(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))
        self.coop_count = 0
        self.defect_count = 0
        self.total_rounds = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.history.my_actions[self.total_rounds] = Action.C == self.__call__(GameState(0), None)
        self.history.my_payoffs[self.total_rounds] = 0
        if history is not None:
            self.coop_count += sum(history.opponent_actions[-1, :])
            self.defect_count += len(history.opponent_actions) - self.coop_count
            self.total_rounds += 1
        if state.round_number == self.game_description.n_rounds:
            if np.all(history.opponent_actions[-1, :]) or not np.any(history.opponent_actions[-1, :]):
                return Action.C
            return Action.D
        contribution_factor = self.coop_count / (self.defect_count + self.coop_count + 1) if self.defect_count + self.coop_count > 0 else 1
        cooperator_count = sum(history.opponent_actions[-1, :])
        if cooperator_count >= self.game_description.n_players // 2:
            return Action.C
        elif contribution_factor < (self.game_description.k - 1) / (self.game_description.n_players - 1):
            return Action.D
        else:
            return Action.C if random.random() > contribution_factor else Action.D

class Strategy_COLLECTIVE_422(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players)), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if history is not None:
            self.history = history
        if state.round_number == 0:
            return Action.C
        total_cooperators = sum(self.history.opponent_actions[-1, :])
        if total_cooperators >= self.game_description.n_players // 2 or random.random() < 0.5:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_423(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_round_cooperation = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperation = sum(history.opponent_actions[-1])
        return Action.C if cooperation == self.game_description.n_players - 1 or self.previous_round_cooperation == cooperation else Action.D
        self.previous_round_cooperation = cooperation

class Strategy_COLLECTIVE_424(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_cooperators = sum(history.opponent_actions[-1, :])
        if self.last_cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

    def is_last_round(self, current_round, total_rounds):
        return current_round == total_rounds

    def last_round_cooperate(self, previous_actions):
        return all((previous_action for previous_action in previous_actions))

class Strategy_COLLECTIVE_425(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            if state.round_number == 0:
                self.last_action = Action.C
                return self.last_action
        elif state.round_number == 1 or self.last_action == Action.C:
            self.last_action = Action.C
        else:
            self.last_action = (history.opponent_actions[-1, history.my_id] == Action.C) * Action.C + Action.D
        return self.last_action

class Strategy_COLLECTIVE_427(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_cooperators = 0
        self.sudden_change_threshold = math.ceil(game_description.n_players * 0.5)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        current_contribution = Action.C if cooperators > self.previous_cooperators else Action.D
        previous_contribution = Action.C if self.previous_cooperators > cooperators else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return current_contribution
        sudden_change = abs(self.previous_cooperators - cooperators) >= self.sudden_change_threshold
        return current_contribution if not sudden_change else previous_contribution

    def update_history(self, state: GameState, history: PlayerHistory) -> None:
        self.previous_cooperators = sum(history.opponent_actions[-1, :])

class Strategy_COLLECTIVE_428(BaseStrategy):
    """
    A Tit-for-Tat strategy in the N-player public goods game where players cooperate initially, and then respond similarly to their opponent's actions in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((1,), dtype=bool), my_payoffs=np.zeros(1), opponent_actions=np.zeros((self.game_description.n_players, 1)), opponent_payoffs=np.zeros((self.game_description.n_players, 1)))
        self.last_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self.history = history
            self.last_round += 1
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.last_round + 1:
            cooperators = sum(self.history.opponent_actions[self.last_round, :])
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        elif state.round_number > self.last_round + 1 and self.last_round != -1:
            cooperators = sum(self.history.opponent_actions[self.last_round, :])
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        elif state.round_number > self.last_round + 1 and self.last_round == -1:
            if history is None:
                return Action.C

class Strategy_COLLECTIVE_429(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat with Fading Memory (ATFM)
    A cooperative strategy that adapts to the opponent's behavior, lessening the severity of punishment over time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_level = 0.5
        self.consecutive_defections = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if opponent_cooperators >= self.game_description.n_players // 2:
            self.consecutive_defections = 1
            return Action.C
        self.consecutive_defections = max(self.consecutive_defections - 1, 1)
        punishment_probability = max(0.5 - (self.consecutive_defections - 4) / 2, 0)
        if self.consecutive_defections > 5:
            return Action.C
        elif self.consecutive_defections <= 3:
            return Action.D
        else:
            return Action.C if random.random() < punishment_probability else Action.D

class Strategy_COLLECTIVE_430(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_count = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1]) if history is not None else 0
        cooperation_ratio = cooperators / self.game_description.n_players if self.game_description.n_players > 0 else 0
        if state.round_number == 1 or cooperation_ratio >= 0.5:
            return Action.C
        forgiveness = min(self.forgiveness_count, state.round_number - 2)
        for _ in range(forgiveness):
            if history.opponent_actions[-(forgiveness + 1), :][-1] == Action.C:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_431(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy in the N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round = 0
        self.opponent_cooperation_count = 0
        self.last_opponent_action = Action.D
        self.strategy_switch_counter = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round += 1
        if history is None or len(history.opponent_actions) == 0:
            return Action.D
        cooperators = sum(history.opponent_actions[-1])
        if self.round == self.game_description.n_rounds:
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1, -1]
        if self.last_opponent_action == Action.C:
            self.opponent_cooperation_count += 1
            if cooperators == self.game_description.n_players:
                return Action.C
            elif self.strategy_switch_counter >= 2:
                return Action.C
        elif self.opponent_cooperation_count > 0:
            self.opponent_cooperation_count -= 1
            self.strategy_switch_counter = 0
        self.strategy_switch_counter += 1 if cooperators > 0 else 0
        return Action.D

class Strategy_COLLECTIVE_432(BaseStrategy):
    """
    A Tit-for-Tat (TFT) strategy that adapts to opponent's behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_score = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            self.update_average_score(history)
            current_score = self.calculate_score(history)
            if current_score > self.average_score:
                return Action.C
        else:
            last_action = history.opponent_actions[-1][-1] if history is not None else Action.D
            return Action(int(last_action == Action.C))

    def update_average_score(self, history: PlayerHistory):
        self.average_score = np.mean(history.my_payoffs[1:])

    def calculate_score(self, history: PlayerHistory) -> float:
        return np.sum(history.my_payoffs[1:])

class Strategy_COLLECTIVE_433(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)
    A recursive cooperative strategy that mirrors the behavior of other players, punishing defection and promoting cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_action = None
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        self.previous_action = cooperators > 0
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif self.previous_action:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_434(BaseStrategy):
    """
    A Tit-for-Tat (TFT) strategy for the N-Player Public Goods Game.
    This strategy cooperates initially, and thereafter, depends on the opponent's last action.
    It encourages mutual cooperation by reciprocating cooperation with cooperation, but retaliating defection with defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.array([]), my_payoffs=np.array([]), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players)), opponent_payoffs=np.array([]))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        self.history = history or PlayerHistory(my_actions=self.history.my_actions, my_payoffs=self.history.my_payoffs, opponent_actions=self.history.opponent_actions, opponent_payoffs=self.history.opponent_payoffs)
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(self.history.opponent_actions[-1, :])
        my_action = Action.C if cooperators >= self.game_description.n_players // 2 else Action.D
        self.history.my_actions = np.append(self.history.my_actions, my_action)
        return my_action

class Strategy_COLLECTIVE_435(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFTA)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.partner_history = []
        self.threshold = game_description.n_players // 2
        self.evaluation_interval = game_description.n_rounds // 10

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            action = self.partner_history[-1] if history is not None and len(self.partner_history) > 0 else None
            cooperators = sum(history.opponent_actions[state.round_number - 1, :]) if history is not None else None
            if action is None or cooperators is None:
                return Action.D
            self.partner_history.append(action)
            if state.round_number % self.evaluation_interval == 0 and cooperators <= self.threshold:
                if action == Action.C:
                    if sum(self.partner_history[-self.threshold:]) > self.threshold:
                        return Action.C
                return Action.D
            return action

class Strategy_COLLECTIVE_437(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-Adaptive (TfTA)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and len(self.opponent_history) > 0:
            self.opponent_history.append(history.opponent_actions[-1, 0])
        if state.round_number == 0 or len(self.opponent_history) == 0:
            return Action.C
        opponent_last_move = self.opponent_history[-1]
        if opponent_last_move:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.C

class Strategy_COLLECTIVE_438(BaseStrategy):
    """
    The Tit-for-Tat Strategy for the N-Player Public Goods Game encourages reciprocity between players, incentivizing mutual benefits and reducing the risk of free riders exploiting others.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
        cooperators = sum(opponent_actions)
        if cooperators == self.game_description.n_players - 1:
            return Action.D
        elif cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_439(BaseStrategy):
    """
    An adaptive tit-for-tat strategy for the n-player public goods game.
    The strategy cooperates initially and reciprocates cooperation from others while retaliating against defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.round_history) == 0:
            return Action.C
        opponent_cooperators = sum(self.round_history[-1])
        if opponent_cooperators > 0 and history is not None and (history.opponent_actions[state.round_number - 1, 0] == Action.D):
            return Action.C
        return history.opponent_actions[state.round_number - 1, 0] if history is not None else Action.C

    def update_history(self, opponent_action: bool):
        """
        Update the opponent's actions history for this round.
        """
        self.round_history.append(np.array([opponent_action]))

class Strategy_COLLECTIVE_440(BaseStrategy):
    """
    A Tit-for-Tat strategy that encourages cooperation among players and retaliates defection with defection in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if np.all(history.opponent_actions[:, -1]):
            return Action.C
        elif cooperators > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_442(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game.
    Cooperates on initial round and responds to opponent's previous action in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        last_action = self.history[-1] if len(self.history) > 0 else None
        if cooperators >= self.game_description.n_players // 2 and last_action == Action.C:
            return Action.C
        elif last_action == Action.C:
            return Action.C
        else:
            return Action.D
        self.history = history.opponent_actions[-1, :].tolist() + self.history

class Strategy_COLLECTIVE_443(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation (TFT-A) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        elif self.last_round_history is not None:
            history = self.last_round_history
        if state.round_number < self.game_description.n_rounds - 1:
            self.last_round_history = PlayerHistory(my_actions=np.array([[True if a == Action.C else False for a in history.my_actions]]), my_payoffs=np.array([history.my_payoffs[-1]]), opponent_actions=history.opponent_actions, opponent_payoffs=history.opponent_payoffs)
        cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number == 1 or (cooperators >= self.game_description.n_players // 2 and self.last_round_history.my_actions[-1]):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_444(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Modified Grace Period (TTMGP) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_action = Action.C
            return self.previous_action
        self.previous_action = history.my_actions[-1]
        cooperators = sum(history.opponent_actions[-1, :])
        if self.previous_action == Action.C:
            return Action.C
        elif self.game_description.n_players > cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_446(BaseStrategy):
    """
    Tit-for-Tat strategy for the N-Player Public Goods Game with adaptation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.majority = math.ceil(self.n_players // 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number != 0:
            cooperators = sum(history.opponent_actions[-1, :])
            return Action.C if cooperators > self.majority else Action.D
        if state.round_number == 0 and history is None:
            return Action.C

class Strategy_COLLECTIVE_448(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_round_cooperators = sum(history.opponent_actions[-1, :])
        cooperators_ratio = self.last_round_cooperators / self.game_description.n_players if history else 0
        return Action.C if cooperators_ratio > 0.5 else Action.D

class Strategy_COLLECTIVE_449(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFTA)
    Initial cooperation to promote trust, mimic opponent actions, forgiveness mechanism, and flexibility.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_since_last_cooperation = 0
        self.forgiveness_threshold = math.ceil(game_description.n_players / 2)
        self.minimum_community_participation = game_description.k / (2 * game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        elif state is not None:
            if state.round_number == 1:
                self.round_since_last_cooperation += 1
            else:
                self.round_since_last_cooperation += 1 if history.my_actions[-2] == Action.D else 0
            if self.round_since_last_cooperation > self.forgiveness_threshold:
                action = Action.C
            if state.round_number <= self.forgiveness_threshold:
                action = Action.C
            elif self.round_since_last_cooperation < self.forgiveness_threshold and np.mean(history.opponent_actions[-1]) > self.minimum_community_participation:
                action = Action.C
        return action

class Strategy_COLLECTIVE_450(BaseStrategy):
    """
    Implementation of the Adaptive Cooperative Tit-for-Tat (AC-TFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(game_description.n_players * 0.6)
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        previous_cooperation_count = self.history.my_actions[-1] if state.round_number > 0 else 0
        action = Action.D
        if opponent_cooperators > 0:
            if opponent_cooperators >= self.threshold:
                action = Action.C
            else:
                action = Action.D
        else:
            action = Action.C
        self.history = history or PlayerHistory(np.append(self.history.my_actions, [action]), np.append(self.history.my_payoffs, np.nan), history.opponent_actions if history else self.history.opponent_actions, np.append(self.history.opponent_payoffs, np.nan))
        return action

class Strategy_COLLECTIVE_452(BaseStrategy):
    """
    Strategy that promotes cooperation while being robust against various opponent behaviors
    by imitating the previous action of the opponent from the previous round, and gradually adjusting strategy when necessary.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = 3
        self.deference_decay = 0.95
        self.current_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number >= self.game_description.n_rounds - 1:
            return Action.C
        if history is not None and history.opponent_actions is not None:
            last_action = history.opponent_actions[-1, 0]
            self.current_defections = max(0, min(self.tolerance, self.current_defections + (1 - last_action)))
            cooperate_probability = 1 if last_action else 1 - self.deference_decay ** self.current_defections
            return Action(math.floor(cooperate_probability))
        return Action.D if state.round_number == 0 else Action.C

class Strategy_COLLECTIVE_453(BaseStrategy):
    """
    A strategy that mimics the Tit-for-Tat with Adaptive Cooperation (TFT-AC) in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.grace_period = 3
        self.persistent_defection_threshold = math.ceil(self.game_description.n_players * 0.75)
        self.last_round_opponent_cooperated = False
        self.last_round_opponent_defected = False
        self.persistent_defection_count = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.last_round_opponent_cooperated = any(history.opponent_actions[-1, :])
        self.last_round_opponent_defected = all((not x for x in history.opponent_actions[-1, :]))
        cooperation = Action.C if self.last_round_opponent_cooperated else Action.D
        if state.round_number < self.grace_period and (not self.last_round_opponent_cooperated):
            return cooperation
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif not self.last_round_opponent_cooperated and self.persistent_defection_count < self.persistent_defection_threshold:
            return cooperation
        elif self.last_round_opponent_cooperated:
            self.persistent_defection_count = 0
            return cooperation
        else:
            self.persistent_defection_count += 1
            if self.persistent_defection_count >= self.persistent_defection_threshold:
                return Action.D
            else:
                return cooperation

class Strategy_COLLECTIVE_454(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy with a Cooperative Threshold (CT). This strategy cooperates when more than half of the players cooperated in the previous round, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(game_description.n_players // 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and history.my_payoffs[-1] <= 0):
            return Action.C
        cooperators = sum(history.opponent_actions[-1]) if history is not None else 0
        if cooperators >= self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_455(BaseStrategy):
    """
    A strategy that cooperates in the initial round and subsequently responds to opponents' actions from the previous round.
    It encourages long-term collaboration by reciprocating cooperative actions and punishing non-cooperative ones.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.N = int(self.r * 0.8)
        self.cooperation_threshold = 0.5
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.history = [Action.C]
            return Action.C
        action = None
        if len(self.history) < self.N:
            cooperation_rate = sum([1 for action in history.my_actions[-self.N:] if action]) / self.N
            if all([action == Action.C for action in history.my_actions[-self.N:]]):
                action = Action.C
            else:
                action = Action.D
        else:
            previous_cooperation_rate = np.mean(history.my_actions[-self.N:])
            cooperation_rate = sum([1 for action in history.my_actions[-self.N:] if action]) / self.N
            if cooperation_rate - previous_cooperation_rate > 0.1 or cooperation_rate < 1 - 0.1:
                self.cooperation_threshold = cooperation_rate
            if all([action == Action.C for action in history.my_actions[-self.N:]]):
                if cooperation_rate >= self.cooperation_threshold:
                    action = Action.C
                else:
                    action = Action.D
            else:
                action = Action.D
        if action == Action.C:
            self.history.append(action)
        else:
            self.history.append(None)
        return action

class Strategy_COLLECTIVE_456(BaseStrategy):
    """Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_history = np.zeros(self.game_description.n_rounds)
        self.contributions_count = 0
        self.avg_cooperation_rate = 0
        self.threshold = 0
        self.esf = 0.5

    def FractionContribute(self):
        return (self.game_description.k - 1) / ((self.game_description.n_players - 1) * self.game_description.k)

    def AdaptiveContribute(self, round_contributions: NDArray[np.bool_]):
        self.contribution_history[-1] = round_contributions.sum()
        self.contributions_count += np.count_nonzero(round_contributions)
        if self.contributions_count > 0:
            self.avg_cooperation_rate = self.contributions_count / (self.contribution_history[-1].size + 1e-08)
        self.threshold = 1 - self.avg_cooperation_rate ** self.esf
        return round_contributions.sum() >= self.threshold * self.avg_cooperation_rate * (self.game_description.n_players - 1)

    def Threshold(self):
        if self.contribution_history[-1].size > 0:
            return self.avg_cooperation_rate ** self.esf
        return 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            contribution = self.FractionContribute()
            self.contributions_count += math.floor(contribution * (state.round_number + 1))
            return Action.C if random.random() < contribution else Action.D
        if history is None:
            self.contributions_count = 0
            self.avg_cooperation_rate = 0
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            self.contributions_count += np.count_nonzero(history.my_actions[-1]) + cooperators
            if state.round_number < self.game_description.n_rounds - 1:
                self.avg_cooperation_rate = (self.contributions_count / (state.round_number + 1) + self.threshold * (self.game_description.n_players - 2)) / 2
            elif self.contributions_count > 0:
                self.avg_cooperation_rate = self.contributions_count / state.round_number
        return Action.C if self.AdaptiveContribute(history.my_actions[-1]) else Action.D

class Strategy_COLLECTIVE_457(BaseStrategy):
    """
    A Tit-for-Tat strategy that mimics opponents' actions in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        cooperators = sum(history.opponent_actions[last_round, :]) if history else 0
        majority_cooperated = cooperators >= self.game_description.n_players // 2
        my_action = history.my_actions[last_round] if history else None
        if last_round > 0 and (my_action == Action.C and majority_cooperated or not my_action):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_458(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive contribution for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_opponent_action is None and history:
            self.last_opponent_action = np.mean(history.opponent_actions[-1])
        total_contributions = sum(history.opponent_actions[-1])
        cooperate = (total_contributions > self.game_description.n_players // 2) == self.last_opponent_action
        self.last_opponent_action = cooperate
        payoff = 1 - cooperate + self.game_description.k / self.game_description.n_players * total_contributions
        return Action(cooperate) if cooperate else Action.D

class Strategy_COLLECTIVE_459(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFTAC) strategy for N-Player Public Goods Game.
    This strategy aims to maintain a stable cooperation group by reciprocating others' actions and encouraging fairness in contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None and self.first_round:
            self.first_round = False
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        if cooperators == self.game_description.n_players or (cooperators > 0 and history.my_actions[-1]):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_460(BaseStrategy):
    """
    A conditional cooperation strategy that maintains a memory of opponents' actions from previous rounds and adjusts its own cooperation based on the opponents historical behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(math.floor(game_description.n_players / 2 * 0.8))
        self.opponent_history = [None] * game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_index = (state.round_number - 1) % self.game_description.n_players
        opponent_history = self.opponent_history[opponent_index]
        if opponent_history is None:
            return random.choice([Action.C, Action.D])
        if history is not None and opponent_history[-1] == history.my_actions[-1]:
            return Action.C
        current_round = state.round_number - 1 - (self.cooperation_threshold - 1) * sum(opponent_history[:-1])
        if current_round < 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_461(BaseStrategy):
    """
    A strategy that demonstrates goodwill by cooperating initially and reciprocates cooperation while punishing defection with gradual forgiveness.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.N, self.M = (math.ceil(game_description.n_players / 2), math.floor(game_description.n_players / 4))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[-1]) if history else None
        cooperators = sum(history.opponent_actions[-1] if history else [0]) if history else 0
        if state.round_number < self.game_description.n_rounds - 1 and opponent_action is not None:
            if opponent_action == Action.C:
                return Action.C
            elif opponent_action == Action.D:
                return Action.D
            else:
                round_number_since_defection = state.round_number - math.ceil((state.round_number - 1) / self.M) * self.M
                if round_number_since_defection > self.N and opponent_action == Action.D:
                    return Action.C
                else:
                    return Action.D
        return Action.C

class Strategy_COLLECTIVE_462(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    Summary: Signals cooperation, retaliates against defection, and promotes mutual benefit & trust.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.N = 5
        self.last_opponent_action = None
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        current_opponent_action = history.opponent_actions[-1][-1]
        self.consecutive_defections = self.consecutive_defections + 1 if current_opponent_action == Action.D else 0
        action = Action.C if self.consecutive_defections > self.N or current_opponent_action == Action.C else Action.D
        self.last_opponent_action = current_opponent_action
        return action

class Strategy_COLLECTIVE_463(BaseStrategy):
    """
    A simple strategy that encourages reciprocity and collective mindset in the N-Player Public Goods Game.
    The strategy cooperates initially, then adapts to opponents' actions by punishing defection and forgiving cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        opp_action = np.mean(history.opponent_actions[-1])
        if opp_action > 0.5:
            return Action.C
            self.forgiveness_counter = math.ceil(self.game_description.n_players / 2)
        else:
            self.forgiveness_counter -= 1
            if self.forgiveness_counter <= 0:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_464(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_total_contributions = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_round_total_contributions = sum(history.opponent_actions[-1])
        if self.last_round_total_contributions == self.game_description.n_players:
            return Action.C
        return Action.D

    def last_round_action(self) -> Action:
        """
        Returns the action this strategy would take in the last round
        (when game ends or state.round_number == self.game_description.n_rounds)
        """
        return Action.C

class Strategy_COLLECTIVE_466(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) with Foresight strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.history_length = self.r if self.r else float('inf')

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.r and state.round_number == self.r - 1:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-min(self.history_length, len(history.opponent_actions)):, :].flatten())
        cooperation_percentage = cooperators / self.n * 100
        if cooperation_percentage >= 50 + 50 // self.n:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_467(BaseStrategy):
    """
    A strategy that mimics the Tit-for-Tat approach in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.last_opponent_action is None else self.last_opponent_action
        last_opponent_action = history.opponent_actions[-1][-1] if history else self.last_opponent_action
        self.last_opponent_action = last_opponent_action
        if last_opponent_action == Action.C and len(history) > 1:
            return Action.C
        return Action.D if last_opponent_action == Action.C else Action.C

class Strategy_COLLECTIVE_468(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Fitness-Based Contribution (ATFC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_total_contributions = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_total_contributions is None:
            return Action.C
        total_contributions = np.sum(history.opponent_actions[-1])
        if total_contributions == (self.game_description.n_players - 1) // 2:
            total_contributions += 1
        self.last_total_contributions = total_contributions
        return Action(total_contributions > (self.game_description.n_players - 1) // 2)

class Strategy_COLLECTIVE_469(BaseStrategy):
    """
    Strategy that implements the Tit-for-Tat with Adaptive Contribution (TFTAC) in an N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = [None] * self.game_description.n_rounds
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        cooperators = sum(history.opponent_actions[state.round_number - 1])
        if cooperators >= self.game_description.n_players // 2:
            action = Action.C
            self.last_cooperators = state.round_number
        elif self.history and self.history[-1] == Action.D or state.round_number < self.last_cooperators + 1:
            pass
        else:
            action = Action.C
            self.last_cooperators = state.round_number
        self.history[state.round_number] = action
        return action

class Strategy_COLLECTIVE_470(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_player_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_player_action = np.zeros(self.game_description.n_players)
            return Action.C
        self.previous_player_action = history.opponent_actions[state.round_number - 1]
        cooperators = sum(history.opponent_actions[-1])
        if self.previous_player_action[0] and cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_471(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)
    Strategy Description: Cooperate initially; in subsequent rounds, cooperate if the previous opponent cooperated. Introduce Adaptive Generosity by increasing contributions if the opponent's cooperation rate exceeds a threshold and reducing contributions if it falls below a minimum threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold_cooperation = 0.7
        self.threshold_defection = 0.3
        self.contribution_multiplier = game_description.k / game_description.n_players
        self.contributions_history = np.array([self.contribution_multiplier], dtype=np.float64)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = (history is not None) * np.array(history.opponent_actions, dtype=np.bool_) if history is not None else np.zeros((1, self.game_description.n_players), dtype=np.bool_)
        cooperators = sum(opponent_actions[-1, :])
        cooperation_rate = cooperators / state.round_number if state.round_number > 0 else 0
        if cooperation_rate > self.threshold_cooperation:
            self.contributions_history[-1] += self.contribution_multiplier * 0.1
        elif cooperation_rate < self.threshold_defection:
            self.contributions_history[-1] -= self.contribution_multiplier * 0.1
        opponent_cooperated = opponent_actions[-1, -1] if state.round_number > 0 else False
        action = Action.C if opponent_cooperated or cooperation_rate <= self.threshold_defection else Action.D
        self.contributions_history = np.append(self.contributions_history, [self.contribution_multiplier * self.contributions_history[-1]], axis=0)
        return action

class Strategy_COLLECTIVE_472(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat with Time Discounting (ATFT-TD)
    Strategy summary: A strategy that balances cooperation and defection, while remaining adaptable and robust in various situations.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.x = int(math.ceil(game_description.n_rounds / 2))
        self.y = int(math.floor(game_description.n_rounds * 0.8))
        self.p = game_description.n_players // 3
        self.delta = random.random()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.round_number <= self.x else Action.D
        cooperators = sum(history.opponent_actions[-self.y:, :].flatten())
        if cooperators >= self.p * self.game_description.n_players:
            return Action.C
        payoffs = history.my_payoffs[-self.y:] if history else np.zeros(self.y)
        payoff_mean = np.mean(payoffs)
        self.delta *= max((1 - payoff_mean) / payoff_mean, 0.95)
        return Action.D if random.random() < self.delta * sum(history.opponent_actions[-1, :]) else Action.C

class Strategy_COLLECTIVE_473(BaseStrategy):
    """
    Implementation of the Tit-for-Tat Adaptive Cooperation (TFT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(self.game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(self.game_description.n_rounds, dtype=np.float64), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.float64))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        else:
            opponent_actions = history.opponent_actions[state.round_number - 1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
            cooperators = sum(opponent_actions)
            return Action(cooperators >= self.game_description.n_players // 2).C if cooperators > 0 else Action.D

class Strategy_COLLECTIVE_474(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)
    Aims to foster a collective mindset by initially cooperating, rewarding cooperation, and punishing defection in a fair and predictable manner.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        coop_prev = np.all(history.opponent_actions[-1] == 1)
        punish_defect = self._punishment_logic(state, history)
        cooperate = coop_prev or punish_defect
        if not cooperate:
            adaptive_cooperation = self._adaptive_cooperation_logic(state, history)
            cooperate = cooperate or adaptive_cooperation
        if cooperate:
            self.history.my_actions[-1] = 1
        else:
            self.history.my_actions[-1] = 0
        self.history.my_payoffs[-1] = self._calculate_payoff(self.history.opponent_actions, state.round_number)
        return Action(int(self.history.my_actions[-1]))

    def _punishment_logic(self, state: GameState, history: PlayerHistory) -> bool:
        coop_prev2 = np.any(history.opponent_actions[state.round_number - 2:-1] == 0) and np.any(history.opponent_actions[-1] == 1)
        return coop_prev2 or len([h for h in history.opponent_actions[-self.game_description.n_players:] if h[0] == 0]) > self.game_description.n_players // 2

    def _adaptive_cooperation_logic(self, state: GameState, history: PlayerHistory) -> bool:
        return state.round_number - (len(history.opponent_actions) - self.game_description.n_players) > self.game_description.n_players and np.any(history.opponent_actions[state.round_number - self.game_description.n_players:state.round_number - self.game_description.n_players // 2] == 1)

    def _calculate_payoff(self, opponent_actions: NDArray[np.bool_], round_number: int) -> float:
        total_cooperators = sum(opponent_actions[-1])
        k = self.game_description.k
        return 1 - self.history.my_actions[-1] + k / self.game_description.n_players * total_cooperators

class Strategy_COLLECTIVE_475(BaseStrategy):
    """
    Tit-for-Tat with Graciousness (TfTG) strategy for N-Player Public Goods Game.
    This strategy cooperates initially and reciprocates cooperation from opponents,
    while forgiving occasional defection with a gracious one-time response of cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_period = math.ceil(game_description.n_players / 2)
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators > 0:
            if self.last_opponent_action is None or self.last_opponent_action == Action.C:
                return Action.C
            elif state.round_number < self.game_description.n_rounds - 1:
                self.last_opponent_action = Action.D
                return Action.C
        if self.last_opponent_action is not None and state.round_number >= self.forgiveness_period:
            self.last_opponent_action = history.opponent_actions[-1, -1]
            return Action.D
        self.last_opponent_action = history.opponent_actions[-1, -1]
        return Action.C

class Strategy_COLLECTIVE_476(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat Adaptive Cooperative (TFT-A)
    Summary: TFT-A cooperates initially and mirrors the opponent's previous action while forgiving initial defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_factor = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_history = np.array([action for round_history in history.opponent_actions for action in round_history])
        if len(opponent_history) < self.forgiveness_factor:
            return Action.C
        current_action = opponent_history[-1]
        if current_action == Action.C and len(opponent_history) > self.forgiveness_factor:
            history_length = len(opponent_history) - self.forgiveness_factor
            if history_length % (2 * self.forgiveness_factor) == 0:
                return Action.C
        elif current_action == Action.C:
            return Action.C
        elif current_action == Action.D and len(opponent_history) > self.forgiveness_factor:
            history_length = len(opponent_history) - self.forgiveness_factor
            if history_length % (2 * self.forgiveness_factor) + 1 == self.forgiveness_factor:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_477(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None and self.last_opponent_action is not None:
            if self.consecutive_defections >= 3:
                self.consecutive_defections = 0
                return Action.C
            elif self.last_opponent_action == Action.C:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        if history is not None:
            self.last_opponent_action = history.opponent_actions[-1][0] if state.round_number > 0 else None

class Strategy_COLLECTIVE_478(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    Aims for a balanced distribution of contributions among players to ensure the sustainability and effectiveness of the public good project.
    By following decision rules, attempts to maintain cooperation when it is beneficial for the group, while also penalizing excessive defection that could harm the common interest.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_contributions = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.average_contributions:
            self.average_contributions = (self.game_description.n_players + sum(history.opponent_actions[-1, :])) // 2 if history else self.game_description.n_players // 2
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        return Action.C if cooperators >= self.average_contributions else Action.D

class Strategy_COLLECTIVE_479(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game.
    """
    THRESHOLD = 0.5

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round = 0
        self.total_payoff = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.round += 1
            return Action.C
        self.round += 1
        if self.round == self.game_description.n_rounds:
            payoff = np.mean(history.my_payoffs)
            if payoff < self.THRESHOLD:
                return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        total_players = len(history.opponent_actions[0])
        if all((action == Action.C for action in history.opponent_actions[-1])):
            return Action.C
        if cooperators > total_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_480(BaseStrategy):
    """Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k_base = game_description.k
        self.s = int(game_description.n_players // 10)
        self.last_opponent_action = None
        self.cooperation_counter = 0
        self.round_counter = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.last_opponent_action = np.all(history.opponent_actions[-1] == 0)
            return Action.C if self.last_opponent_action else Action.D
        self.round_counter += 1
        opponent_cooperators = sum(history.opponent_actions[self.round_counter - 1])
        self.cooperation_counter = self.cooperation_counter + opponent_cooperators if self.round_counter > self.s else opponent_cooperators
        avg_cooperation = self.cooperation_counter / self.s if self.round_counter > self.s else 0
        self.k_base *= (avg_cooperation + 1) / 2
        return Action.C if self.last_opponent_action == history.my_actions[-1] else Action.D
        self.last_opponent_action = history.my_actions[-1]

class Strategy_COLLECTIVE_482(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_period = math.floor(game_description.n_players / 2)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_actions = history.my_actions[-1]
        last_opponent = history.opponent_actions[-1, -1]
        if last_opponent == my_actions:
            return Action.C
        elif state.round_number < self.game_description.n_rounds and state.round_number <= state.round_number + self.punishment_period:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_483(BaseStrategy):
    """
    The Adaptive Tit for Tat (ATFT) strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.opponent_last_action = np.mean(history.opponent_actions[-1])
        if state.round_number == 0:
            return Action.C
        elif self.opponent_last_action is None:
            return Action.C
        else:
            return Action(self.opponent_last_action == 1)

class Strategy_COLLECTIVE_484(BaseStrategy):
    """
    Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[-1])
        cooperators = np.count_nonzero(history.opponent_actions[-1])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_485(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2 + self.game_description.n_players - 1
        self.consecutive_defections = self.threshold

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if self.consecutive_defections > 0 and cooperators < self.threshold:
            return Action.D
        if cooperators >= self.threshold:
            self.consecutive_defections = self.game_description.n_players - 1
        else:
            self.consecutive_defections -= 1
        return Action.C if cooperators > 0 else Action.D

class Strategy_COLLECTIVE_487(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy in a N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_opponent_action = None
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if self.last_opponent_action == Action.C and cooperators >= self.game_description.n_players - 1:
            pass
        elif self.last_opponent_action is None or self.last_opponent_action == Action.D:
            return Action.C
        else:
            return Action.D
        self.last_opponent_action = history.opponent_actions[-1, :] if history else None

class Strategy_COLLECTIVE_488(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TFT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_window = game_description.n_players - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if history is not None and state.round_number >= self.history_window:
            opponent_cooperators = np.sum(history.opponent_actions[:, -self.history_window:], axis=1)
            if all(opponent_cooperators == self.game_description.n_players - 1):
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_490(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFTAC) strategy for N-Player Public Goods Game.
    Balances self-interest with cooperation, encouraging a culture of reciprocity among players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_opponent_action is None:
            return Action.C
        opponent_action = history.opponent_actions[-1][-1] if len(history.opponent_actions) > 0 else None
        self.last_opponent_action = opponent_action
        return Action(int(opponent_action == Action.C))

class Strategy_COLLECTIVE_491(BaseStrategy):
    """
    Tit-for-Tat strategy for N-Player Public Goods Game with modifications for cooperation promotion and edge cases handling.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperate_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None and history.my_payoffs[-1] > 0:
            self.cooperate_count += 1
            return Action.C
        else:
            self.cooperate_count = 0
        if state.round_number == self.game_description.n_rounds - 1 or self.cooperate_count > (self.game_description.n_players - 2) // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_493(BaseStrategy):
    """
    A strategy that initially cooperates and then adapts the opponent's actions in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_actions_history) == 0:
            return Action.C
        opponent_action = self.opponent_actions_history[-1] if history is not None else None
        if opponent_action == Action.C:
            return Action.C
        return Action.D

    def update_history(self, state: GameState, my_action: Action, opponents_actions: NDArray[np.bool_]) -> None:
        self.opponent_actions_history.append(opponents_actions)

class Strategy_COLLECTIVE_494(BaseStrategy):
    """
    An adaptive tit-for-tat strategy for the N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.MCD = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < self.MCD:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-self.MCD:][-1])
        return Action(state.round_number > 0 and opponent_cooperators == len(history.opponent_actions) or state.round_number == 1)

class Strategy_COLLECTIVE_495(BaseStrategy):
    """
    The Tit-for-Tat with Adaptation (TfT-Adapt) strategy. A player that starts by cooperating and adapts its strategy based on the opponent's cooperation rate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_rate = None
        self.own_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.own_history) == 0:
            return Action.C
        self.own_history.append([action == Action.C for action in history.my_actions])
        if self.opponent_cooperation_rate is None or len(self.opponent_cooperation_rate) < state.round_number:
            self.opponent_cooperation_rate = np.zeros(state.round_number, dtype=np.float64)
        cooperators = sum(history.opponent_actions[-1, :])
        self.opponent_cooperation_rate[state.round_number] = cooperators / self.game_description.n_players
        own_cooperation_rate = np.mean(self.own_history)
        if self.opponent_cooperation_rate[-1] < 0.5 and own_cooperation_rate > 0.7:
            return Action.D
        elif own_cooperation_rate < 0.5 or self.opponent_cooperation_rate[-1] > 0.8:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_498(BaseStrategy):
    """
    A Tit-for-Tat inspired strategy for N-Player Public Goods Game, called Cooperative Tit-for-Cooperation (CTFC).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.group_behavior = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.group_behavior = None
            return Action.C
        if self.group_behavior is None:
            cooperators = sum(history.opponent_actions[0, :])
            self.group_behavior = 'cooperation' if cooperators >= self.game_description.n_players // 2 else 'defection'
        group_behavior_this_round = sum(history.opponent_actions[-1, :])
        if group_behavior_this_round == self.game_description.n_players:
            return Action.C
        elif group_behavior_this_round == 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_500(BaseStrategy):
    """
    Strategy that follows the Adaptive Tit-for-Tat (ATFT) approach in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1, :])
        if total_contributions >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_501(BaseStrategy):
    """
    The Freerider with Tit-for-Tat Adaptation strategy in the N-Player Public Goods Game.
    This strategy balances cooperation and self-interest to maintain a long-term payoff while being adaptive to various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperate_threshold = math.ceil(game_description.k * game_description.n_rounds / game_description.n_players) + 1
        self.history = None

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history
        cooperators_t = np.sum(history.opponent_actions[state.round_number - 1])
        if state.round_number == 1:
            action_t = Action.C
        elif self.history.my_actions[-1] == Action.C:
            if cooperators_t >= self.game_description.k * self.game_description.n_players / self.game_description.n_rounds + 1:
                action_t = Action.C
            else:
                action_t = Action.D
        else:
            action_t = Action.D
        return action_t

class Strategy_COLLECTIVE_502(BaseStrategy):
    """
    A strategy that reciprocates cooperation and punishes defection in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.current_strategy = Action.C

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return self.current_strategy
        if history is None:
            return self.current_strategy
        for player, actions in enumerate(history.opponent_actions[-1]):
            if actions and self.current_strategy == Action.D or (not actions and self.current_strategy == Action.C):
                self.current_strategy = Action.D
            elif not (actions and self.current_strategy == Action.C) and (not (not actions and self.current_strategy == Action.D)):
                self.current_strategy = Action.C
        return self.current_strategy

class Strategy_COLLECTIVE_503(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR)
    A simple, adaptive cooperation strategy that encourages reciprocity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(math.floor(game_description.n_rounds * 0.8))
        self.T = game_description.k / (2 * game_description.n_players)
        self.epsilon = 0.1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < self.m + 1:
            return Action.D
        average_cooperation = np.mean(history.opponent_actions[-self.m:, :].flatten())
        random_factor = random.gauss(0, self.epsilon) if self.epsilon > 0 else 0
        return Action.C if average_cooperation >= self.T + random_factor else Action.D

class Strategy_COLLECTIVE_505(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game (TFT-PG)
    This strategy follows a reciprocal approach, encouraging cooperation through trust-building.
    It cooperates in the initial round and subsequent rounds if all players cooperated in the previous round; otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.all_cooperated = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        if self.all_cooperated is not None and np.all(history.opponent_actions[-1] == self.all_cooperated):
            return Action.C
        self.all_cooperated = np.all(history.opponent_actions[-1]) if history is not None else None
        return Action.D

class Strategy_COLLECTIVE_507(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            history = self.history
            self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if state.round_number == 0:
            history.my_actions[0] = True
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.game_description.n_players - 1:
                history.my_actions[-1] = True
            else:
                history.my_actions[-1] = False
        return Action(int(history.my_actions[-1]))

class Strategy_COLLECTIVE_509(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.num_initial_cooperative_moves = int(np.ceil(game_description.n_players / 2))
        self.history = PlayerHistory(None, None, np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history
        if state.round_number < self.num_initial_cooperative_moves or (state.round_number >= self.num_initial_cooperative_moves and history.opponent_actions[-1][-1] == Action.C):
            return Action.C
        elif state.round_number > self.num_initial_cooperative_moves and history.opponent_actions[-1][-1] == Action.D:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_510(BaseStrategy):
    """
    A Tit-for-Tat Plus (TFT+) strategy implementation for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.opponent_history = np.zeros((state.round_number,), dtype=bool)
            self.opponent_history[0] = False
            return Action.C
        if len(self.opponent_history) < state.round_number:
            current_round = state.round_number - 1
            last_cooperation = self.opponent_history[-1] if current_round > 0 else False
            self.opponent_history.append(last_cooperation)
        current_round = len(self.opponent_history) - 1
        last_cooperation = self.opponent_history[current_round]
        if self.opponent_history[-1]:
            return Action.C
        elif not self.opponent_history[current_round - 1]:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_512(BaseStrategy):
    """
    A collective and adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = {}
        self.initial_cooperation = True

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        total_contributions = sum(history.opponent_actions[state.round_number - 1])
        my_action = Action.C if self.initial_cooperation or total_contributions > 0 else Action.D
        self.update_history(state, history, my_action)
        return my_action

    def update_history(self, state: GameState, history: PlayerHistory, action: Action) -> None:
        if state.round_number == 1:
            self.initial_cooperation = False
        self.history[state.round_number] = np.array([action], dtype=np.bool_)
        history.opponent_actions[state.round_number - 1, :] = self.history[state.round_number]

class Strategy_EXPLOITATIVE_1(BaseStrategy):
    """
    Strategy name: Freeloader
    Strategy type: Exploitative
    Description: Minimize contributions while still benefiting from others' cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_players = set()
        self.defective_players = set()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return Action.D
        current_round = state.round_number - 1 if history else 0
        if current_round == 0:
            self.cooperative_players.clear()
            self.defective_players.clear()
            for player in history.opponent_actions[current_round, :]:
                if np.all(history.opponent_actions[current_round, :] == player):
                    if player:
                        self.cooperative_players.add(player)
                    else:
                        self.defective_players.add(player)
        actions = [Action.D]
        if len(self.cooperative_players) > len(self.defective_players):
            for player in history.opponent_actions[current_round, :]:
                if player in self.cooperative_players:
                    actions[0] = Action.C
                    break
        elif len(self.defective_players) > len(self.cooperative_players):
            for player in history.opponent_actions[current_round, :]:
                if player in self.defective_players:
                    actions[0] = Action.D
                    break
        return actions[0]

class Strategy_EXPLOITATIVE_2(BaseStrategy):
    """
    A Tit-for-Tat Plus (TfT+) strategy for N-Player Public Goods Games.
    This strategy mimics opponents' previous actions, adjusting its cooperation level
    based on the average proportion of cooperation among all players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.reduction_factor = 0
        self.average_proportion_cooperation = None
        self.m = math.ceil(game_description.n_rounds * 0.8)

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[:, :-1].flatten())
        self.average_proportion_cooperation = cooperators / self.m if self.m > 0 else None
        if self.average_proportion_cooperation is not None:
            my_cooperation = np.sum(history.my_actions) / self.game_description.n_players
            if my_cooperation < self.average_proportion_cooperation:
                self.reduction_factor = max(self.reduction_factor - 1, 0)
            elif my_cooperation > self.average_proportion_cooperation:
                self.reduction_factor = min(self.reduction_factor + 1, self.game_description.n_players)
        likelihood = (1 + self.reduction_factor) / self.game_description.n_players if history.opponent_actions[-1, -1] == Action.C else 0
        return Action.C if random.random() < likelihood else Action.D

class Strategy_EXPLOITATIVE_3(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat (ATFT) strategy with Progressive Cooperation Threshold (PCT).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.min_thresh = int(math.ceil(game_description.n_players / 2))
        self.max_thresh = self.min_thresh * 3
        self.t = self.min_thresh
        self.opponent_cooperated_last = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperated = np.any(history.opponent_actions[state.round_number - 1]) if history else False
        self.opponent_cooperated_last = opponent_cooperated
        if not opponent_cooperated:
            if self.t <= self.max_thresh:
                return Action.D
        elif self.opponent_cooperated_last:
            return Action.C
        return Action.D

    def reset(self):
        """
        Resets the strategy state for a new game.
        """
        self.t = self.min_thresh
        self.opponent_cooperated_last = False

class Strategy_EXPLOITATIVE_4(BaseStrategy):
    """
    A simple Tit-for-Tat with Adaptive Cooperation strategy for the N-Player Public Goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool))
        return Action(int(cooperators >= self.game_description.n_players // 2))

class Strategy_EXPLOITATIVE_6(BaseStrategy):
    """
    The Tit-for-Tat with Adaptation (TfTA) strategy for the N-Player Public Goods Game.
    This strategy cooperates in the first round, and in subsequent rounds, mimics reciprocity by cooperating when opponents cooperate and defecting when opponents defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.history = history
        cooperation_count = np.sum(self.history.opponent_actions[-1, :])
        opponent_cooperated = cooperation_count > 0
        return Action.C if opponent_cooperated else Action.D

class Strategy_EXPLOITATIVE_7(BaseStrategy):
    """
    Cooperative Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = None
        self.cooperate_first = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.opponent_history = history.opponent_actions if history else np.zeros((1, self.game_description.n_players), dtype=bool)
        opponent_cooperators = sum(self.opponent_history[-1])
        if state.round_number == 1 or all(self.opponent_history[-1]):
            self.cooperate_first = False
        return Action.C if self.cooperate_first or opponent_cooperators >= self.game_description.n_players else Action.D

class Strategy_EXPLOITATIVE_8(BaseStrategy):
    """
    The Tit-for-Tat with Variance (TFTV) strategy for the N-Player Public Goods Game.
    This strategy cooperates in the first round and adjusts its actions based on the previous round's outcome, introducing a small probability of deviation to encourage unpredictability.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 0.1
        self.history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=np.zeros((1, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros(1))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
            if opponent_cooperators > (self.game_description.n_players - 1) * (1 - self.epsilon):
                return Action.C
            elif random.random() < self.epsilon:
                return Action(not history.opponent_actions[state.round_number - 1][-1])
            else:
                return Action(history.opponent_actions[state.round_number - 1][-1])

class Strategy_EXPLOITATIVE_9(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_last_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.opponent_last_action = None
            return Action.C
        if self.opponent_last_action is None or state.round_number == self.game_description.n_rounds - 1:
            self.opponent_last_action = history.opponent_actions[-1, :].any()
        if history.opponent_actions[-1, :].sum() >= self.game_description.n_players // 2 and self.opponent_last_action:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_10(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptation (TfTA)
    A strategy that cooperates in the initial round and reciprocates cooperation or defection from opponents in subsequent rounds, adapting to opponent behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.last_opponent_action:
            self.last_opponent_action = history.opponent_actions[state.round_number - 1, 0] if history else None
        opponent_cooperated = self.last_opponent_action == Action.C if self.last_opponent_action else history.opponent_actions[state.round_number - 1, 0]
        self.last_opponent_action = opponent_cooperated
        if state.round_number < self.game_description.n_rounds:
            return Action(int(opponent_cooperated))
        else:
            return Action.C

class Strategy_EXPLOITATIVE_11(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT)
    Strategy Description: Initially cooperates, but changes behavior based on opponent's previous actions. Cooperates if the opponent has cooperated in the last n-1 rounds; otherwise, defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_opponent_actions = np.zeros(game_description.n_players - 1, dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-self.game_description.n_players + 1:, -1])
        self.previous_opponent_actions = np.roll(self.previous_opponent_actions, -1)
        self.previous_opponent_actions[-1] = bool(opponent_cooperators)
        if opponent_cooperators >= self.game_description.n_players - len(self.previous_opponent_actions) and np.all(self.previous_opponent_actions):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_13(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_contributions = np.zeros(game_description.n_rounds - 1)
        self.average_contribution = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            contributions = history.opponent_actions[-1].sum()
            self.opponent_contributions = np.roll(self.opponent_contributions, -1)
            self.opponent_contributions[len(self.opponent_contributions) - 1] = contributions
            self.average_contribution = np.mean(self.opponent_contributions)
        if self.average_contribution > (self.game_description.n_players - 1) / 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_14(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation Strategy that encourages reciprocity and discourages unilateral defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_action = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return self.previous_action
        current_cooperators = sum(history.opponent_actions[-1, :])
        current_round = state.round_number - 1 if history is not None else 0
        my_action = self.previous_action if current_cooperators >= self.game_description.n_players // 2 else Action.D
        self.previous_action = my_action
        return my_action

class Strategy_EXPLOITATIVE_16(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = 2
        self.rounds_played = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.rounds_played += 1
        if history is not None and state.round_number > self.game_description.n_rounds // self.game_description.n_players:
            self.tolerance = min(self.tolerance * 2, self.game_description.n_rounds)
        if history is not None and state.round_number == self.game_description.n_rounds:
            cooperators_last_round = sum(history.opponent_actions[-1, :])
            return Action.C if cooperators_last_round >= len(self.game_description.n_players) // 2 else Action.D
        defect_count = np.count_nonzero(history.my_actions[:-self.tolerance] == Action.D)
        if self.rounds_played <= self.tolerance:
            return Action.C
        elif defect_count < self.tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_17(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive generosity, designed for the N-Player Public Goods Game.
    The strategy balances cooperation and exploitation based on observed player behavior over time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.f = 0.1
        self.g = 3
        self.avg_contributions = np.zeros(self.game_description.n_players)
        self.current_round = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        elif history is None:
            pass
        else:
            self.current_round += 1
            total_contributions = sum(history.my_actions[-self.game_description.n_rounds:])
            avg_contributions = np.mean(total_contributions / self.game_description.n_rounds)
            if self.current_round >= self.game_description.n_rounds:
                self.avg_contributions[:] = avg_contributions
            else:
                self.avg_contributions = np.roll(self.avg_contributions, -1)
                self.avg_contributions[-1] = avg_contributions
            p_cooperate = min(1, total_contributions / avg_contributions ** self.f) * max((avg_contributions / total_contributions) ** self.g, 0.5)
            if random.random() < p_cooperate:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_18(BaseStrategy):
    """
    A simple adaptive strategy, Tit-for-Tat with Adaptation (TfTA), that cooperates if the opponent did in the previous round and defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if self.opponent_history is None or len(self.opponent_history) <= state.round_number - 1:
            self.opponent_history = np.zeros((state.round_number,), dtype=bool)
        self.opponent_history[state.round_number - 1] = history.opponent_actions[-1, 0]
        return Action(self.opponent_history[-1])

class Strategy_EXPLOITATIVE_19(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players * 0.7
        self.cooperator_counter = np.zeros(game_description.n_rounds)
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        if len(history.opponent_actions) < self.game_description.n_rounds:
            cooperators = sum(history.my_actions[:state.round_number])
            self.cooperator_counter[state.round_number] = cooperators
            return Action.C if cooperators > 0 else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            cooperators = sum(history.opponent_actions[-self.game_description.n_rounds:, :])
            if np.mean(self.cooperator_counter[-self.game_description.n_rounds:]) > self.threshold:
                return Action.C
            cooperators_last_r = sum(history.opponent_actions[-self.game_description.n_rounds:, :])
            if cooperators_last_r > self.threshold:
                self.cooperator_counter[state.round_number] = cooperators_last_r
                return Action.C
        else:
            opponent_action = history.opponent_actions[-1, (state.round_number - 1) % self.game_description.n_players]
            cooperators_last_r = sum(history.opponent_actions[-self.game_description.n_rounds:, :])
            self.cooperator_counter[state.round_number] = cooperators_last_r if state.round_number < len(self.cooperator_counter) - 1 else 0
        return Action.C if opponent_action else Action.D

class Strategy_EXPLOITATIVE_20(BaseStrategy):
    """
    Strategy name: Cooperate-Then-Defect (CTD)
    Summary: Initially cooperates for a pioneering phase to attract others, then defects to exploit them.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.pioneering_rounds = int(self.game_description.n_rounds * 0.2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        pioneering_ended = current_round > self.pioneering_rounds + 1
        return Action(int(pioneering_ended))

class Strategy_EXPLOITATIVE_21(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.recent_rounds = np.zeros((self.game_description.n_rounds, 2), dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[:, -1])
        self.recent_rounds = np.roll(self.recent_rounds, -1)
        self.recent_rounds[-1, 0] = cooperators > math.ceil(self.game_description.n_players * np.mean(self.recent_rounds[:, 1]))
        self.recent_rounds[-1, 1] = cooperators >= int(np.mean(self.recent_rounds[:, 1]) * self.game_description.n_players)
        return Action.C if np.sum(self.recent_rounds[-1, :]) > 0 else Action.D

class Strategy_EXPLOITATIVE_22(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or state.round_number >= self.game_description.n_rounds - 1:
            self.last_round = state.round_number >= self.game_description.n_rounds - 1
        cooperators = sum(history.opponent_actions[-1] if history else [False for _ in range(self.game_description.n_players)])
        my_action = Action.C if not self.last_round and cooperators > 0 else Action.D
        return my_action

class Strategy_EXPLOITATIVE_23(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive contribution.
    Cooperates on the first round and adapts to opponents' behavior in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((1,), dtype=bool), my_payoffs=np.zeros((1,)), opponent_actions=np.zeros((1, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((1, game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 or len(history.opponent_actions) < self.game_description.n_rounds:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        my_last_action = self.history.my_actions[last_round]
        total_cooperators = np.sum(history.opponent_actions[last_round])
        if total_cooperators > (self.game_description.n_players - 1) // 2:
            return Action.C
        payoff, _ = self.calculate_payoff(state, history)
        self.history = PlayerHistory(my_actions=np.concatenate((self.history.my_actions, np.array([[my_last_action]], dtype=bool)), axis=0), my_payoffs=np.concatenate((self.history.my_payoffs, np.array([[payoff]], dtype=float)), axis=0), opponent_actions=np.concatenate((history.opponent_actions, history.opponent_actions[-1].reshape(self.game_description.n_rounds, self.game_description.n_players).T), axis=0), opponent_payoffs=np.concatenate((history.opponent_payoffs, np.array([[payoff]] * self.game_description.n_players)), axis=0))
        return Action.D

    def calculate_payoff(self, state: GameState, history: PlayerHistory):
        total_contributions = np.sum(history.opponent_actions[:, -state.round_number])
        my_action = 1 if self.__call__(GameState(state.round_number), history) == Action.C else 0
        payoff = 1 - my_action + self.game_description.k / self.game_description.n_players * total_contributions
        return (payoff, my_action)

class Strategy_EXPLOITATIVE_25(BaseStrategy):
    """
    Tit-for-Tat with Time-Averaged Cooperation (TFT-TAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperation_threshold = 0.5
        self.window_size = int(math.ceil(self.game_description.n_rounds * 0.8))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions, axis=0)
        cooperation_rate = self._calculate_cooperation_rate(cooperators)
        if state.round_number == self.game_description.n_rounds - 1 and cooperation_rate < self.average_cooperation_threshold:
            return Action.D
        if cooperation_rate >= self.average_cooperation_threshold:
            return Action.C
        return Action.D

    def _calculate_cooperation_rate(self, cooperators: NDArray[np.bool_]) -> float:
        if np.sum(cooperators) == 0:
            return 0.0
        return np.mean(cooperators[-self.window_size:])

class Strategy_EXPLOITATIVE_26(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Generosity (TfT-AG) strategy for N-Player Public Goods Game.
    This strategy cooperates initially, then adapts its actions based on opponents' behavior in the previous round.
    It maintains a degree of generosity by occasionally cooperating even after being exploited in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_length = int(math.ceil(game_description.n_rounds * 0.8))
        self.average_cooperation = np.zeros(self.history_length)
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        elif history is not None and state.round_number != self.game_description.n_rounds:
            self._update_average_cooperation(history)
            cooperators = sum(history.opponent_actions[self.current_round, :])
            if cooperators >= np.ceil(self.game_description.n_players * (1 - self.average_cooperation[-1])):
                return Action.C
        self.current_round += 1
        return Action.D

    def _update_average_cooperation(self, history):
        self.average_cooperation = np.roll(self.average_cooperation, -1)
        self.average_cooperation[-1] = sum(history.opponent_actions[self.current_round - 1, :]) / self.game_description.n_players

class Strategy_EXPLOITATIVE_28(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            self.last_opponent_cooperators = sum(history.opponent_actions[-1, :])
            return Action(self.last_opponent_cooperators > (self.game_description.n_players - 1) // 2)
        return Action.D

class Strategy_EXPLOITATIVE_29(BaseStrategy):
    """
    A strategy that starts by cooperating and adapts its actions based on the previous round's total contributions.
    The strategy is designed to encourage cooperation while punishing non-cooperative behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(math.ceil(game_description.n_players * 0.5))
        self.state = {}

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.state['cooperators'] = sum(history.opponent_actions[-1, :])
        self.state['total_contributions_prev'] = self.state['cooperators']
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        current_action = Action.D
        if self.state['total_contributions_prev'] > 0:
            if self.state['total_contributions_prev'] >= self.threshold:
                current_action = Action.C
            elif self.state['total_contributions_prev'] < self.threshold and self.state['cooperators'] > 0:
                current_action = Action.D
        elif self.state['total_contributions_prev'] <= 0:
            current_action = Action.D
        return current_action

class Strategy_EXPLOITATIVE_30(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.ct = 1.0
        self.alpha = 0.5
        self.beta = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_contributions_prev = np.sum(history.opponent_actions[-1]) if history else 0
        if total_contributions_prev > self.game_description.n_players // 2 and total_contributions_prev >= math.floor(self.ct):
            return Action.C
        return Action.D

    def update_cooperation_threshold(self, total_contributions: int):
        self.ct = self.ct * self.alpha + (self.game_description.n_players - total_contributions) * self.beta

class Strategy_EXPLOITATIVE_31(BaseStrategy):
    """
    Strategy name: Tit-for-Tat-Evolution (TfT-E)
    Summary: This strategy cooperates initially and mimics opponents' actions in subsequent rounds, favoring cooperation when faced with cooperative opponents while punishing defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_opponent_actions = np.zeros(game_description.n_players)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_round_opponent_actions = np.mean(history.opponent_actions[-1], axis=0) > 0.5
        if np.all(self.last_round_opponent_actions == 1):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_32(BaseStrategy):
    """
    Tit-for-Tat Cooperation with Adaptive Escalation (TTTAE) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        actions = history.opponent_actions[state.round_number - 1]
        total_contributions = np.sum(actions)
        self.total_contributions[state.round_number - 1] = total_contributions
        if state.round_number < self.game_description.n_rounds:
            if total_contributions >= self.game_description.n_players // 2:
                return Action.C
            return Action.D
        if state.round_number == self.game_description.n_rounds and total_contributions >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_33(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy that cooperates when opponents also cooperate, and defects in response to defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.first_move = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.history.my_actions[0] = True
            self.first_move = False
            return Action.C
        elif self.first_move:
            self.first_move = False
            self.history.my_actions[0] = True
            return Action.C
        else:
            if history is None:
                self.history = PlayerHistory(self.history.my_actions, np.zeros(state.round_number), self.history.opponent_actions, self.history.my_payoffs)
            self.history.my_payoffs[-1] += self.game_description.k / self.game_description.n_players * sum(self.history.opponent_actions[-1]) - 1 + self.history.my_actions[-1] if self.history.my_actions[-1] else 1
            cooperators = sum(self.history.opponent_actions[-1])
            return Action.C if self.history.my_payoffs[-1] >= 0 or cooperators >= self.game_description.n_players // 2 else Action.D

class Strategy_EXPLOITATIVE_35(BaseStrategy):
    """
    A Tit-for-Tat with Punishment (TFTP) strategy that cooperates initially and mimics opponent's actions, introducing a punishment mechanism for uncooperative opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_threshold = math.ceil(game_description.n_players / 2)
        self.defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        current_action = Action.C if opponent_cooperators >= self.punishment_threshold else Action.D
        if state.round_number > 1 and history:
            self.defections += np.count_nonzero(history.opponent_actions[-2, :])
            if self.defections >= self.punishment_threshold:
                current_action = Action.D
        return current_action

class Strategy_EXPLOITATIVE_36(BaseStrategy):
    """
    A cooperative Tit-for-Tat with Adaptive Generosity (TfT-AG) strategy for N-Player Public Goods Games.
    This strategy adapts its cooperation level based on the number of opponents who cooperated in the previous round.
    If more than half of opponents cooperate, TfT-AG will also cooperate; otherwise, it will defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_players = self.game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        if cooperators >= self.total_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_38(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat with Threshold (A3T)
    A cooperative strategy that gradually adapts its behavior based on opponents' cooperation over time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(min([game_description.n_players, game_description.n_rounds]) / 2)
        self.total_defections_history = []

    def __call__(self, state: GameState, history: PlayerHistory | None):
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_cooperators = np.sum(history.opponent_actions[-1])
        if state.round_number > self.game_description.n_rounds - 1 or len(self.total_defections_history) >= self.threshold:
            if np.all(history.opponent_actions[-1] == Action.C.value):
                return Action.C
            else:
                return Action.D
        cooperate = opponent_cooperators > self.game_description.n_players // 2
        return Action(cooperate) if state.round_number > 0 else Action.C

    def updateTotalDefectionsHistory(self, state: GameState, history: PlayerHistory):
        self.total_defections_history.append(np.sum(history.opponent_actions[-1] == Action.D.value))

class Strategy_EXPLOITATIVE_40(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if self.last_opponent_action is None:
            self.last_opponent_action = np.mean(history.opponent_actions[-1])
        last_cooperators = sum(history.opponent_actions[-1] == 1)
        if last_cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            self.last_opponent_action = np.mean(history.opponent_actions[-1])
            return Action.D

class Strategy_EXPLOITATIVE_41(BaseStrategy):
    """
    A simple Tit-for-Tat with Escalation strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.escalation_length = 10
        self.streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif history is not None:
            if history.opponent_actions is None or len(history.opponent_actions) == 0:
                return Action.C
            current_action = history.opponent_actions[-1, -1]
            if current_action:
                action = Action.C
            else:
                self.streak += 1
                if self.streak > self.escalation_length:
                    self.streak = 0
                    self.escalation_length *= 2
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_42(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.t = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.history = history.opponent_actions.flatten().tolist()
        if state.round_number < self.t:
            return Action.C
        opponent_cooperators = sum(self.history[-self.t:])
        self.t += 1 if opponent_cooperators >= len(self.history[-self.t:]) else self.game_description.n_players
        return Action.C if self.t <= state.round_number + 1 else Action.D

class Strategy_EXPLOITATIVE_43(BaseStrategy):
    """
    A Tit-for-Tat with Gradual Cooperation (TFTGC) strategy for N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_duration = 0
        self.gradual_cooperation = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        opponent_defected = cooperators < self.game_description.n_players // 2
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if not opponent_defected else Action.D
        if opponent_defected:
            self.punishment_duration += 1
            if self.punishment_duration >= 3:
                self.gradual_cooperation = True
                self.punishment_duration -= 3
        else:
            self.punishment_duration = 0
        return Action.C if not opponent_defected or self.gradual_cooperation else Action.D

class Strategy_EXPLOITATIVE_44(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_length = math.floor(game_description.n_players / 2)
        self.increase_length = self.punishment_length // 2 + 1
        self.current_round = 0
        self.cooperation_history = [True] * game_description.n_rounds
        self.punishment_counter = 0
        self.last_opponent_cooperated = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if not self.last_opponent_cooperated and self.punishment_counter > 0:
                return Action.D
            else:
                return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        self.last_opponent_cooperated = cooperators >= self.game_description.n_players // 2
        if self.current_round == 0 or all(self.cooperation_history[:self.current_round + 1]):
            return Action.C
        else:
            self.punishment_counter += 1
            if self.punishment_counter >= self.punishment_length:
                self.punishment_counter = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_45(BaseStrategy):
    """
    A strategy that cooperates initially and responds to opponent's actions in subsequent rounds.
    The propensity for initial cooperation decreases over time, making the strategy more resilient to defection while still maintaining a cooperative starting point.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        opponent_cooperated_last_round = False if history.opponent_actions[-1].all() else True
        if not opponent_cooperated_last_round and (not history.opponent_actions[:-1].all()):
            return Action.D
        self.p = max(0, self.p - 1 / state.round_number)
        if opponent_cooperated_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_46(BaseStrategy):
    """
    Tit-for-Tat with Time Delay (TFTD) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.time_delay = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number - 1 < self.time_delay:
            return Action.C
        for i in range(state.round_number - self.time_delay, -1, -1):
            if history.opponent_actions[i, 0] == Action.C:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_48(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.player_history = []
        self.avg_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.player_history = []
        if len(self.player_history) < self.game_description.n_rounds:
            self.player_history.append(np.zeros((1, self.game_description.n_players), dtype=bool))
        if len(self.player_history) >= self.game_description.n_rounds:
            self.avg_cooperators = np.mean(np.sum(self.player_history[-self.game_description.n_rounds:], axis=0))
        if len(self.player_history) == self.game_description.n_rounds:
            self.player_history = self.player_history[-self.game_description.n_rounds:]
        most_common = np.argmax(np.sum(self.player_history[-self.game_description.n_rounds:], axis=0))

        def adjust_k():
            return min(max(1 + (self.avg_cooperators - self.game_description.n_players // 2) / self.game_description.n_players, 1), self.game_description.n_players)
        if most_common == self.game_description.n_players:
            k = adjust_k()
            return Action.C if k >= self.game_description.n_players - 1 else Action.D
        elif most_common > self.game_description.n_players // 2:
            k = adjust_k()
            return Action.C if k >= self.game_description.n_players - 1 else Action.D
        elif history is not None and history.opponent_actions[-1, most_common] == False:
            punishment_rounds = min(self.game_description.n_rounds - state.round_number, 3)
            return Action.D if punishment_rounds > 0 else most_common
        else:
            k = adjust_k()
            return Action.C if k < self.game_description.n_players - 1 else Action.D

class Strategy_EXPLOITATIVE_49(BaseStrategy):
    """
    Strategy that implements the Tit-for-Tat with Gradient Adjustment (TfTGA) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.gradients = np.zeros(game_description.n_rounds)
        self.contribution_averages = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() > 0.5 else Action.D
        self.gradients[state.round_number - 1] = self.calculate_gradient(state, history)
        self.contribution_averages[state.round_number] = np.mean(history.my_actions[-self.game_description.n_rounds:])
        return Action.C if self.gradients[state.round_number - 1] > 0 else Action.D

    def calculate_gradient(self, state: GameState, history: PlayerHistory) -> float:
        cooperated_last_round = np.any(history.my_actions[state.round_number - 1])
        if cooperated_last_round and (not all(history.opponent_actions[state.round_number - 1])):
            return self.game_description.k * (1 - self.contribution_averages[-1]) - 1
        elif not cooperated_last_round and np.all(history.my_actions[state.round_number - 1]):
            return 1 - self.contribution_averages[-1]
        else:
            return 0

class Strategy_EXPLOITATIVE_50(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR) strategy for N-Player Public Goods Game.
    This strategy cooperates initially to encourage trust, maintains cooperation if all opponents also cooperated in the previous round, and gradually decreases the rate of immediate retaliation over time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.rate_of_adaptation = game_description.k
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or self.last_round:
            return Action.C
        cooperation_rate = min((state.round_number - 2) / (self.game_description.n_rounds - 2) * (1 / self.rate_of_adaptation), 1)
        if history.my_actions[-1] == Action.C:
            return Action.D if cooperation_rate < random.random() else Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        self.last_round = state.round_number == self.game_description.n_rounds
        return Action.D

class Strategy_EXPLOITATIVE_51(BaseStrategy):
    """
    A strategy that cooperates in the first round and follows a "Tit-for-Tat" approach with an adaptive contribution mechanism.
    This strategy imitates other players' behavior from the previous round. If most players cooperated in the previous round, it will also cooperate in the current round. Otherwise, it will defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_cooperation = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.total_cooperation[state.round_number] = 0
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            total_cooperation = np.sum(history.opponent_actions[-1])
            return Action.D if self.game_description.n_rounds == state.round_number else Action.C
        total_cooperation = self.total_cooperation[state.round_number]
        current_cooperation = np.sum(history.opponent_actions[-1])
        if history is not None:
            self.total_cooperation[state.round_number] = current_cooperation + total_cooperation
        if current_cooperation > self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_52(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Variable Cooperation (A-TFTV) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players * (game_description.k - 1) / game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            cooperators = sum(history.opponent_actions[-2, :]) if history is not None else 0
            return Action.C if cooperators >= self.threshold else Action.D
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            return Action.C if cooperators >= self.threshold else Action.D

class Strategy_EXPLOITATIVE_53(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(game_description.n_rounds * 0.8)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if cooperators >= self.game_description.n_players // 2 and state.round_number < self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_54(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    The strategy cooperates initially, returns favors when cooperated upon, and defects to punish opponents who do not reciprocate cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.prev_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.prev_opponent_action = np.mean(history.opponent_actions[-1])
        if history is None or state.round_number == self.game_description.n_rounds - 1:
            if self.prev_opponent_action == Action.C:
                return Action.C
            else:
                return Action.D
        elif self.prev_opponent_action == Action.C:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_55(BaseStrategy):
    """
    A public goods game strategy that implements the Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.games_played = 0
        self.average_cr = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if self.games_played == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            cr = np.mean(history.my_actions) if history else 0
            if cr >= self.average_cr:
                return Action.C
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        cr = cooperators / self.game_description.n_players if history else 0
        self.games_played += 1
        if history:
            self.update_average_cr(cr)
        return Action.C if cr >= self.average_cr else Action.D

    def update_average_cr(self, cr):
        self.average_cr = (self.average_cr * self.games_played + cr) / (self.games_played + 1)

class Strategy_EXPLOITATIVE_56(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Contribution (TFTAC) strategy participates in the Public Goods Game.
    This strategy cooperates initially and adapts its behavior based on opponents' actions to maintain a balance between cooperation and defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None and state.round_number < self.game_description.n_rounds:
            last_opponent_action = history.opponent_actions[-1, -1] if self.last_opponent_action is None else self.last_opponent_action
            self.last_opponent_action = last_opponent_action
            return Action(int(last_opponent_action == Action.C))
        else:
            return Action.D

class Strategy_EXPLOITATIVE_57(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Time-Delayed Cooperation (ATTC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.delay = self.game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.D if np.sum(np.array([1 for _ in range(self.game_description.n_players)])) > self.game_description.n_players // 2 else Action.C
        if state.round_number == self.game_description.n_rounds:
            cooperators = np.sum(history.opponent_actions[-1, :])
            return Action.C if cooperators > self.game_description.n_players // 2 else Action.D
        self.delay -= 1
        cooperation_count = np.sum(history.opponent_actions[state.round_number - 1, :])
        return Action.D if cooperation_count < self.game_description.n_players // 2 else Action.C

class Strategy_EXPLOITATIVE_58(BaseStrategy):
    """
    The Tit-for-Tat Strategy (TFT) in N-Player Public Goods Game.

    This strategy encourages cooperation on the first round, and copies opponents' actions from the previous round in subsequent rounds.
    If an opponent cooperates, the TFT player continues to cooperate; if an opponent defects, the TFT player defects in response.
    To encourage long-term cooperation, the TFT strategy switches back to cooperative behavior in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if not history:
            return Action.C
        last_round = state.round_number == self.game_description.n_rounds
        self.last_round = last_round
        if last_round:
            return Action.C
        opponent_cooperated_last_round = sum(history.opponent_actions[-1, :]) > 0
        return opponent_cooperated_last_round and (not self.last_round) and Action.C or Action.D

class Strategy_EXPLOITATIVE_59(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = None
        if state.round_number == 0:
            self.first_round = True
            action = random.choice([Action.C, Action.D])
        else:
            cooperators = sum(history.opponent_actions[state.round_number - 1, :])
            if self.first_round:
                self.first_round = False
                action = random.choice([Action.C, Action.D])
            elif cooperators >= self.threshold:
                self.threshold += 0.1
                action = Action.C
            else:
                self.threshold -= 0.1
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_60(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TfTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            history = self.history
        if state.round_number == 0:
            return Action.C
        if state.round_number + 1 >= self.game_description.n_rounds:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1, :])
        current_player_cooperated = history.my_actions[-1] == Action.C if history is not None else False
        if total_contributions < self.game_description.n_players:
            return Action.D
        if not current_player_cooperated and np.all(history.my_actions[:-1] == Action.D):
            return Action.D
        elif total_contributions == self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_61(BaseStrategy):
    """
    Tit-for-Tat with Variations (TFT-V) strategy for N-Player Public Goods Game.
    This strategy mimics the "Tit for Tat" strategy, but adds a twist:
    - If the total number of opponents who have ever cooperated exceeds the total number who have ever defected, temporarily switch to cooperating, even if the opponent defected last round.
    - After switching to cooperation, continue cooperating as long as all opponents are also cooperating (i.e., they have not defected for a certain number of rounds, say 'm'). If an opponent defects after this period, return to the previous strategy (defect if opponent defected last round).
    - The value of 'm' can be adjusted based on the number of players and multiplication factor. A higher 'm' encourages patience and less frequent switching between cooperation and defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.floor(self.n / 2)
        self.cooperators_count = 0
        self.defectors_count = 0
        self.first_round = True
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            self.first_round = True
            return Action.C
        opponent_actions = history.opponent_actions[current_round - 1, :]
        total_cooperators = np.sum(opponent_actions)
        if self.first_round:
            self.first_round = False
            return Action.C
        if opponent_actions[-1] == Action.C and total_cooperators > self.defectors_count:
            self.cooperators_count += 1
            return Action.C
        if total_cooperators > self.defectors_count:
            self.switch_to_cooperation()
            return self.current_action
        if opponent_actions[-1] != self.last_opponent_action and current_round >= self.m + 1:
            self.switch_to_cooperation()
            return self.current_action
        return Action.D

    def switch_to_cooperation(self):
        self.current_action = Action.C
        self.last_opponent_action = None
        self.cooperators_count += 1
        self.defectors_count = 0

class Strategy_EXPLOITATIVE_62(BaseStrategy):
    """
    Tit-for-Tat with Cooperative Adjustment (TFT-CA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() > 0.5 else Action.D
        cooperators = sum(history.opponent_actions[-1] if history else [0])
        if state.round_number == self.r:
            threshold = np.ceil(cooperators * (self.game_description.n_players / 2))
        else:
            threshold = int((self.r - state.round_number + 1) * (cooperators / (self.r * self.game_description.n_players)))
        return Action.C if cooperators >= threshold else Action.D

class Strategy_EXPLOITATIVE_63(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        threshold = self.game_description.n_players // 2
        return Action(cooperators >= threshold)

class Strategy_EXPLOITATIVE_64(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Threshold (TfT-AT) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players, self.n_rounds, self.k = (game_description.n_players, game_description.n_rounds, game_description.k)
        self.T0 = self.k / (self.n_players + 1)
        self.alpha = 0.95
        self.average_cooperation_rate = np.zeros(self.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.average_cooperation_rate = np.roll(self.average_cooperation_rate, -1)
            self.average_cooperation_rate[-1] += history.my_actions[0].mean() - self.average_cooperation_rate[-1]
            threshold = self.alpha * self.T0 + (1 - self.alpha) * (self.k / (self.n_players + 1) * self.average_cooperation_rate[-1])
        cooperators = sum(history.opponent_actions[state.round_number - 1, :]) if state.round_number != 0 else 0
        if cooperators >= threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_65(BaseStrategy):
    """
    A Tit-for-Tat strategy adapted for the N-Player Public Goods Game.
    This strategy starts cooperatively, but will punish uncooperative opponents by defecting in response.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self. = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = np.sum(history.opponent_actions[-1, :]) if history is not None else 0
        my_action = Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            if opponent_cooperators > 0:
                my_action = Action.C if opponent_cooperators == self.game_description.n_players else Action.D
        elif state.round_number == self.game_description.n_rounds - 1 and random.random() < self.:
            my_action = Action.C
        return my_action

class Strategy_EXPLOITATIVE_66(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game.
    Cooperates when opponents do, defects as punishment otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperated_last_round = np.zeros(game_description.n_players, dtype=np.bool_)
        self.first_time_cooperating = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.opponent_cooperated_last_round.fill(False)
            self.first_time_cooperating = True
            return Action.C
        opponent_cooperators_this_round = np.sum(history.opponent_actions[-1])
        self.opponent_cooperated_last_round = history.opponent_actions[-2] if len(history.opponent_actions) > 1 else self.opponent_cooperated_last_round
        if opponent_cooperators_this_round == 0:
            return Action.D
        if not np.any(self.opponent_cooperated_last_round):
            return Action.D if np.all(history.opponent_actions[-1]) == Action.D else Action.C
        if opponent_cooperators_this_round < self.game_description.n_players // 2:
            return Action.D
        if np.all(self.opponent_cooperated_last_round == opponent_cooperators_this_round):
            return Action.C
        if np.all(self.opponent_cooperated_last_round):
            self.first_time_cooperating = False
            return Action.C
        self.first_time_cooperating = False
        return Action.D

class Strategy_EXPLOITATIVE_67(BaseStrategy):
    """
    A strategy that mimics the Tit-for-Tat approach with an adaptive cooperation threshold (TFT-ACT).
    This strategy adjusts its cooperation based on the history of cooperative actions in the game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.history_length = self.game_description.n_rounds
        self.average_cooperators = np.zeros(self.game_description.n_rounds)
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            cooperation_percentage = random.random()
            return Action(int(cooperation_percentage >= self.cooperation_threshold))
        if history is not None:
            self.current_round += 1
            cooperators = np.sum(history.my_actions)
            total_contributions = len(history.my_actions)
            cooperation_percentage = cooperators / total_contributions * 100
            self.average_cooperators[min(self.current_round, self.game_description.n_rounds)] = cooperation_percentage
        if self.current_round == 1:
            return Action(int(random.random() >= self.cooperation_threshold))
        average_cooperators = np.mean(self.average_cooperators)
        cooperation_threshold = (average_cooperators + 50) / 100 * self.game_description.n_players
        return Action(int(sum(history.opponent_actions[-1, :]) >= cooperation_threshold))

class Strategy_EXPLOITATIVE_68(BaseStrategy):
    """
    Tit-for-Tat Strategy with Modified Defection Threshold (TFTM) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_players = game_description.n_players
        self.threshold = int(math.floor(self.total_players * 0.5))
        self.defection_threshold = int(math.ceil(self.total_players / (2 * self.game_description.k) * 0.5))
        self.memory_length = 10

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.opponent_actions) < self.memory_length:
            return Action.D
        total_cooperators = np.sum(history.opponent_actions[-self.memory_length:, :])
        cooperators_ratio = total_cooperators / (self.memory_length * self.total_players)
        if cooperators_ratio > self.threshold:
            return Action.C
        elif cooperators_ratio < self.defection_threshold:
            return Action.D
        most_frequent_opponent_behavior = np.argmax(np.bincount(history.my_actions[-self.memory_length:], minlength=2))
        if most_frequent_opponent_behavior == 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_69(BaseStrategy):
    """
    A Tit-for-Tat with Adjustable Contribution (TfTA-C) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contributions = [0] * game_description.n_rounds
        self.average_cooperators = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None:
            self._update_contributions(history)
            self._calculate_averages()
        avg_c = self.average_cooperators[-1]
        if avg_c < (self.game_description.n_players - 1) / 2 or avg_c > (self.game_description.n_players + 1) / 2:
            return Action.D
        recent_history = history.opponent_actions[-self.game_description.n_rounds // 2:]
        frequent_action = np.argmax(np.sum(recent_history, axis=0))
        if frequent_action == 1:
            return Action.C
        else:
            return Action.D

    def _update_contributions(self, history: PlayerHistory):
        self.contributions[-1] = history.my_actions[-1]

    def _calculate_averages(self):
        total_contributions = np.sum(self.contributions)
        if len(self.average_cooperators) > 0:
            self.average_cooperators = np.roll(self.average_cooperators, -1)
        self.average_cooperators[-1] = total_contributions / len(self.contributions)

class Strategy_EXPLOITATIVE_70(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive contribution for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.n = game_description.n_players
        self.avg_cooperators = self.n / 2
        self.rounds_played = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            self.rounds_played += 1
            last_round = len(history.opponent_actions) - 1
            cooperators = sum(history.opponent_actions[last_round])
            total_contributions = np.sum(history.my_actions[last_round])
            if self.rounds_played == self.game_description.n_rounds - 1 or (self.rounds_played > self.game_description.n_rounds - 5 and total_contributions < self.n / 2):
                return Action.D
            if cooperators == self.n:
                self.k = 1
            elif cooperators == 0:
                self.k = self.n
            else:
                self.k *= (self.n - cooperators + 1) / cooperators
                self.avg_cooperators = cooperators
            if total_contributions >= math.ceil(self.avg_cooperators):
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_71(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptation (TfTA)
    A cooperative strategy that punishes defection to encourage cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_opponent_action is None:
            return Action.C
        opponent_action = history.opponent_actions[-1, (state.player_index + 1) % self.game_description.n_players]
        self.last_opponent_action = opponent_action
        if opponent_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_72(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TfTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperators = 0
        self.most_cooperative = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.update_cooperator_count(history)
            self.update_most_cooperative(history)
        if history and self.most_cooperative is not None:
            return self.most_cooperative.last_action
        return Action.D

    def update_cooperator_count(self, history: PlayerHistory):
        cooperators = sum(history.opponent_actions[-1, :])
        self.cooperators += cooperators - (self.cooperators if self.cooperators else 0)

    def update_most_cooperative(self, history: PlayerHistory):
        max_cooperators = []
        max_coops = self.cooperators
        for i in range(history.opponent_actions.shape[1]):
            coops = sum(history.opponent_actions[:, i])
            if coops > max_coops:
                max_cooperators = [(i, history)]
                max_coops = coops
            elif coops == max_coops:
                max_cooperators.append((i, history))

class Strategy_EXPLOITATIVE_73(BaseStrategy):
    """
    A strategy that cooperates initially, then adapts to the opponents' cooperation levels, demonstrating generosity when reciprocated and punishing defection.
    """
    THRESHOLD_ADJUSTMENT_INTERVAL = 10
    MINIMUM_THRESHOLD = 50
    MAXIMUM_THRESHOLD = 95
    THRESHOLD_INCREASE = 5

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.MINIMUM_THRESHOLD if self.game_description.n_players % 2 == 0 else math.floor(self.MINIMUM_THRESHOLD)
        self.round_counter = 0

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        self.threshold += self.THRESHOLD_INCREASE if self.round_counter % self.THRESHOLD_ADJUSTMENT_INTERVAL == 0 else 0
        self.threshold = min(self.MAXIMUM_THRESHOLD, self.threshold)
        return Action.C if cooperators >= self.threshold else Action.D

class Strategy_EXPLOITATIVE_74(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Time Discounting (TFT-TD)
    Strategy that cooperates in the first round and adapts its strategy based on opponent's previous contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.discount_factor = 1 - self.game_description.n_players / self.game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        opponent_action = history.opponent_actions[-1, 0] if history else None
        if opponent_action is not None and state.round_number < self.game_description.n_rounds // 2:
            return Action.D if opponent_action else Action.C
        if opponent_action == Action.C and state.round_number >= self.game_description.n_rounds // 2:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_75(BaseStrategy):
    """
    A strategy that initially fosters cooperation but retaliates if met with defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.opponent_last_action = None
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            cooperators = sum(history.opponent_actions[-1, :])
            if self.opponent_last_action is not None and cooperators < self.opponent_last_action:
                return Action.D
            else:
                return Action.C
        self.opponent_last_action = history.opponent_actions[-1, :].mean()
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= (self.game_description.n_players - 1) / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_76(BaseStrategy):
    """
    Tit-for-Tat-Adaptive Strategy (TfT-A) for N-Player Public Goods Game
    This strategy maintains a memory of each opponent's behavior from the previous round. If an opponent cooperates, the player will also cooperate in the subsequent round. If an opponent defects, the player will defect in the subsequent round. However, to foster initial cooperation and avoid being exploited early on, TfT-A employs a forgiveness mechanism: it cooperates during the first few rounds before beginning its tit-for-tat strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_frequency = math.ceil(game_description.n_players / 2)
        self.history = PlayerHistory(np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        self.history = history
        round_number = len(self.history.opponent_actions)
        my_action = Action.D
        if round_number < self.forgiveness_frequency:
            my_action = Action.C
        elif round_number >= self.forgiveness_frequency and history.my_actions[round_number - 1] == Action.C:
            my_action = Action.C
        else:
            my_opponent_cooperators = sum(history.opponent_actions[-1, :])
            if my_opponent_cooperators < self.game_description.n_players // 2:
                my_action = Action.D
        return my_action

class Strategy_EXPLOITATIVE_79(BaseStrategy):
    """
    A simple Tit-for-Tat strategy with evolutionary adaptability. This strategy cooperates initially and reciprocates the opponent's actions thereafter.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round = 0
        self.opponent_cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round += 1
        if history is not None and len(self.opponent_cooperation_history) > 0:
            last_action = self.opponent_cooperation_history[-1]
        else:
            last_action = Action.D
        if last_action == Action.C:
            self.opponent_cooperation_history.append(True)
            return Action.C
        else:
            self.opponent_cooperation_history.append(False)
            return Action.D

class Strategy_EXPLOITATIVE_80(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TfTA) strategy for an N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_history = np.zeros(self.game_description.n_rounds)
        self.last_opponent_action = Action.D

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        cooperators = sum(history.opponent_actions[-self.game_description.n_rounds // 3:, :].mean(axis=0))
        if cooperators > self.game_description.n_players // 2:
            return Action.C
        elif cooperators < self.game_description.n_players // 2:
            return Action.D
        else:
            return self.last_opponent_action
        self.cooperation_history[-1] = cooperators
        self.last_opponent_action = history.opponent_actions[state.round_number - 1, :].mean()

class Strategy_EXPLOITATIVE_81(BaseStrategy):
    """
    A strategy that cooperates in the initial round and subsequently cooperates if all opponents cooperated in the previous round, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.history is None or len(self.history.opponent_actions) < self.game_description.n_rounds:
            self.history = history
            return Action.C
        previous_round = self.history.opponent_actions[-1]
        total_cooperators = sum(previous_round)
        if total_cooperators == len(previous_round):
            return Action.C
        else:
            return Action.D

    def last_round(self, state: GameState, history: PlayerHistory) -> bool:
        """
        Checks if the current round is the last one in the game.
        """
        return state.round_number == self.game_description.n_rounds - 1

class Strategy_EXPLOITATIVE_82(BaseStrategy):
    """
    A strategy that cooperates in the initial round and adapts to opponents' moves in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_action = Action.C
            return Action.C
        self.previous_action = history.my_actions[-1]
        cooperators = sum(history.opponent_actions[-1, :])
        if self.previous_action == Action.C and cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_83(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adjustable Contributions (TFTAC)
    Strategy Description: A cooperative strategy that adjusts contributions based on opponent's behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_level = 0.5
        self.last_cooperation = False
        self.punishment_duration = 3
        self.reward_duration = 5
        self.current_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.current_round += 1
        opponent_cooperators = sum(history.opponent_actions[self.current_round - 1, :]) if history else 0
        if opponent_cooperators > 0 and (not self.last_cooperation):
            self.contribution_level += (self.reward_duration - self.current_round) * 0.1
            return Action.C
        elif self.last_cooperation and opponent_cooperators == 0:
            if self.contribution_level > 0.5:
                self.contribution_level -= (self.punishment_duration - self.current_round) * 0.1
            return Action.D
        elif opponent_cooperators == 0 and (not self.last_cooperation):
            self.contribution_level = 0.5
        self.last_cooperation = bool(opponent_cooperators)
        return Action(int(self.contribution_level))

class Strategy_EXPLOITATIVE_84(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.mean_cooperation = 0
        self.adaptation_factor = 1
        self.initial_cooperation_probability = 0.5
        self.first_round = True
        self.f = int(self.game_description.n_rounds * 0.2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = None
        if state.round_number == 0:
            action = Action.C if random.random() < self.initial_cooperation_probability else Action.D
        elif state.round_number < self.game_description.n_rounds:
            cooperators = sum(history.opponent_actions[-1, :])
            self.mean_cooperation += cooperators / self.f if self.first_round else self.mean_cooperation * (self.f - 1) / self.f
            self.first_round = False
            cooperation_threshold = self.mean_cooperation * self.adaptation_factor
            action = Action.C if cooperators >= int(self.game_description.n_players * cooperation_threshold) else Action.D
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_85(BaseStrategy):
    """
    A strategy that cooperates in the first round and then adopts a Tit-for-Tat approach, cooperating if the opponent cooperated in the previous round and defecting otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.last_opponent_action = None
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1, :].mean()
        if self.last_opponent_action == 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_86(BaseStrategy):
    """
    Implementation of a Tit-for-Tat strategy with a twist for an N-Player Public Goods Game.
    This strategy cooperates in the first round and thereafter copies the average cooperation level of opponents in subsequent rounds.
    A slight modification allows it to be more adaptive and exploitative.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploitation_level = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            cooperation_probability = self.exploitation_level if self.exploitation_level > 0.5 else 0.75
            return Action(random.choice([0, 1]) if history is None else history.my_actions[-1] == 1) if random.random() < cooperation_probability else Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action(history.my_actions[-1] == 1) if history.my_payoffs[-1] > np.mean(history.opponent_payoffs[-1]) else Action.D
        cooperators = sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        return Action(history.my_actions[-1] == 1) if history.my_actions[-1] >= cooperators else Action.D

class Strategy_EXPLOITATIVE_87(BaseStrategy):
    """
    A Tit-for-Tat-Evolved (TfTE) strategy for N-Player Public Goods Game.
    The strategy starts by cooperating in the first round, then adopts a tit-for-tat approach for the rest of the game.
    If a player has cooperated in the previous round, they will continue cooperating.
    If a player defected in the previous round, they will also defect in the current round as retaliation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_round_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.previous_round_action is None:
            self.previous_round_action = history.my_actions[0]
        last_action = self.previous_round_action
        self.previous_round_action = history.my_actions[-1]
        if last_action == Action.C:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_88(BaseStrategy):
    """
    A Tit-for-Tat Cooperation Adaptive (TFTCA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_history) == 0:
            return Action.C
        last_opponent_action = self.opponent_history[-1]
        cooperators = np.count_nonzero(history.opponent_actions[-1])
        if last_opponent_action == Action.C and cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif last_opponent_action != Action.C:
            return Action.D
        opponent_history = PlayerHistory(my_actions=np.array([], dtype=bool), my_payoffs=np.array([]), opponent_actions=history.opponent_actions, opponent_payoffs=history.opponent_payoffs)
        self.opponent_history.append(opponent_history)
        return Action.D

class Strategy_EXPLOITATIVE_89(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    Strategy Description: Cooperate initially and reciprocate cooperation or defection in subsequent rounds. Punish defection by defecting, encourage cooperation by cooperating when others do as well.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploitative_mindset = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        opponent_last_action = history.opponent_actions[-1, :] if history else np.full((self.game_description.n_players, 1), False)
        if self.exploitative_mindset:
            cooperators = sum(opponent_last_action)
            return Action(cooperators >= self.game_description.n_players // 2 and Action.C == opponent_last_action[-1])
        else:
            return not opponent_last_action[-1]

class Strategy_EXPLOITATIVE_90(BaseStrategy):
    """Adaptive Tit-for-Tat with Cooperative Bias (ATFT-CB) for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = self.game_description.k
        self.n = self.game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        previous_round = history.opponent_actions[-1] if state.round_number > 0 else np.zeros(self.n, dtype=bool)
        num_cooperators = np.sum(previous_round)
        if np.all(previous_round):
            return Action.C
        cooperate_probability = 1 - (num_cooperators / self.n) ** 2
        if random.random() < cooperate_probability:
            return Action.C
        else:
            return Action.D

    def p(self, num_cooperators):
        return 1 - (num_cooperators / self.n) ** 2

    def q(self, num_cooperators):
        return (num_cooperators / self.n) ** 2

class Strategy_EXPLOITATIVE_92(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[-1])
        cooperators = sum(history.opponent_actions[-1, :])
        if self.last_opponent_action == 1 and cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_93(BaseStrategy):
    """
    Tit-for-Tat Exploitative Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.own_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.C if history and history.opponent_actions[-1].sum() > 0 else Action.D
        if history and len(self.own_history) > 0:
            last_round = self.own_history[-1]
            if last_round != action:
                action = action if history.opponent_actions[-1][-1] == action else Action.D
        self.own_history.append(action)
        return action

class Strategy_EXPLOITATIVE_94(BaseStrategy):
    """
    Tit-for-Tat Cooperator Strategy in the N-Player Public Goods Game.
    Initiates cooperation, retaliates against defection, and encourages cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_round_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_round_action = Action.C
        else:
            self.previous_round_action = history.my_actions[-1]
        return self._determine_action(self.previous_round_action)

    def _determine_action(self, previous_round_action):
        return Action.C if previous_round_action == Action.C else Action.D

class Strategy_EXPLOITATIVE_95(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_rounds_threshold = game_description.n_players // 2
        self.total_payoff = 0
        self.last_opponent_action = None
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
            self.first_round = False
        if not history:
            self.last_opponent_action = np.zeros(self.game_description.n_players, dtype=bool)
        action = Action.D
        if not self.first_round:
            last_opponent_cooperators = sum(self.last_opponent_action)
            current_opponent_cooperators = sum(history.opponent_actions[-1, :])
            if current_opponent_cooperators > last_opponent_cooperators:
                action = Action.C
            elif current_opponent_cooperators < last_opponent_cooperators:
                action = Action.D
            else:
                pass
            self.last_opponent_action = history.opponent_actions[-1, :]
        if state.round_number == self.game_description.n_rounds - 1:
            total_cooperative_payoffs = np.sum(history.my_payoffs[history.my_actions == True])
            total_defective_payoffs = np.sum(history.my_payoffs[history.my_actions == False])
            if total_cooperative_payoffs > total_defective_payoffs:
                action = Action.C
            else:
                action = Action.D
        self.total_payoff += np.sum(history.my_payoffs)
        return action

class Strategy_EXPLOITATIVE_97(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.window_size = math.floor(game_description.n_players / 2)
        self.threshold = game_description.n_players // 2
        self.opponent_history = np.zeros((self.window_size,))
        self.cooperation_avg = self.calculate_moving_average(self.opponent_history)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_history = np.roll(self.opponent_history, -1)
            self.opponent_history[-1] = int(history.opponent_actions[state.round_number - 1, 0])
            self.cooperation_avg = self.calculate_moving_average(self.opponent_history)
        if self.cooperation_avg < self.threshold:
            return Action.D if history is None or history.opponent_actions[state.round_number - 1, 0] == 0 else Action.C
        return Action.C

    def calculate_moving_average(self, data: np.ndarray) -> float:
        if len(data) < self.window_size:
            return np.mean(data)
        return np.mean(np.concatenate(([np.mean(data[:self.window_size])], data[1:-self.window_size + 1], [np.mean(data[-self.window_size:])])))

class Strategy_EXPLOITATIVE_98(BaseStrategy):
    """
    Tit-for-Tat with Variable Defection Probability (TFTVP) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t = self.game_description.n_players // 2
        self.vdp = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            vdp = self.vdp if cooperators < self.t else (self.vdp + 0.1) * min(1, self.t / cooperators)
            return np.random.choice([Action.C, Action.D], p=[1 - vdp, vdp])

class Strategy_EXPLOITATIVE_99(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.adaptation_rounds = 1000
        self.threshold = math.ceil(game_description.n_players / 2)
        self.cooperation_count = 0
        self.current_round = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        self.current_round = state.round_number
        if self.current_round == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators >= self.threshold and self.current_round != self.game_description.n_rounds - 1:
            self.cooperation_count += 1
        elif cooperators < self.threshold and self.cooperation_count > 0:
            self.cooperation_count -= 1
        else:
            self.cooperation_count = 0
        if self.current_round == self.game_description.n_rounds - 1 and self.cooperation_count >= self.game_description.n_players // 3:
            return Action.C
        return Action.D if self.cooperation_count < self.game_description.n_players // 2 else Action.C

class Strategy_EXPLOITATIVE_100(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TfT-A) strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / 2)
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.my_actions is not None and self.consecutive_defects > 0:
            if np.any(history.my_actions[-1]):
                self.consecutive_defects = 0
        cooperators = sum(history.opponent_actions[-1, :])
        opponents_cooperated = cooperators >= self.game_description.n_players // 2
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif opponents_cooperated and (not self.consecutive_defects):
            return Action.C
        elif self.consecutive_defects < self.m:
            return Action.D
        else:
            self.consecutive_defects = 0
            return Action.C

class Strategy_EXPLOITATIVE_101(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defeats = 0
        self.average_cooperation = 0.0
        self.round_threshold = int(game_description.n_players / 2)
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == len(history.opponent_actions) - 1 and (not self.last_round):
            self.last_round = True
            return self._calculate_action(history)
        self.consecutive_defeats = sum(history.opponent_actions[-self.round_threshold:, :].flatten())
        if self.consecutive_defeats >= self.round_threshold:
            self.average_cooperation = np.mean(history.opponent_actions[:, -self.round_threshold:].flatten())
            return Action.D
        self.average_cooperation = np.mean(history.opponent_actions[:, -self.round_threshold:].flatten())
        return self._calculate_action(history)

    def _calculate_action(self, history):
        last_action = Action.D if history.opponent_payoffs[-1, :].max() < history.opponent_payoffs[-1, np.where(history.opponent_actions[-1, :] == Action.C)].mean() else Action.C
        return last_action

class Strategy_EXPLOITATIVE_102(BaseStrategy):
    """
    A strategy that follows Tit-for-Tat with Adaptive Contribution (TFTAC) in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_contributions = np.zeros(game_description.n_rounds - 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if history is not None and len(history.opponent_actions) > 1:
            avg_contributions = np.mean(history.opponent_actions[-1], axis=0)
            self.average_contributions[-1] = avg_contributions
        if len(self.average_contributions) == state.round_number - 1:
            my_contribution = Action.D if self.average_contributions[-1].sum() < self.game_description.n_players // 2 else Action.C
            return my_contribution
        return Action.D

class Strategy_EXPLOITATIVE_103(BaseStrategy):
    """
    Implementation of Tit-for-Tat strategy for the N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_threshold = int(game_description.n_players * 0.5)
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self.last_round = True
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators < self.punishment_threshold and (not self.last_round):
            return Action.D
        elif cooperators >= self.punishment_threshold or self.last_round:
            return Action.C

    def get_payoff(self, state: GameState, history: PlayerHistory) -> float:
        """
        Calculate the payoff for this strategy instance based on its actions and opponents' actions.
        """
        payoff = np.zeros(state.round_number + 1)
        actions = history.my_actions[-1]
        total_contributions = sum(history.opponent_actions[-1, :])
        for i in range(len(actions)):
            payoff[i] = 1 - actions[i] + self.game_description.k / self.game_description.n_players * total_contributions
        return np.sum(payoff)

class Strategy_EXPLOITATIVE_106(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Frequency (TFT-ACF) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_history = np.array([], dtype=bool)
        self.cooperation_threshold = 0.5
        self.last_round = False

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.coop_history = np.append(self.coop_history, np.array([state.round_number >= len(self.coop_history)], dtype=bool))
        avg_coop = np.mean(self.coop_history[-self.game_description.n_rounds:-1])
        if self.last_round and avg_coop > self.cooperation_threshold:
            return Action.C
        elif self.last_round and avg_coop <= self.cooperation_threshold:
            return Action.D
        elif state.round_number >= len(self.coop_history):
            if avg_coop > self.cooperation_threshold:
                self.cooperation_threshold += (avg_coop - self.cooperation_threshold) / self.game_description.n_rounds
            else:
                self.cooperation_threshold -= (self.cooperation_threshold - avg_coop) / self.game_description.n_rounds
        return Action(int(self.coop_history[-1]))

class Strategy_EXPLOITATIVE_107(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_threshold = self.game_description.n_players // 2
        self.adaptation_window = int(self.game_description.n_rounds * 0.75)
        self.coop_rate_threshold = 0.75
        self.last_cooperation_rate = 0.0
        self.punishment_probability = 1.0
        self.exploitation_probability = 0.0
        self.adaptation_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        current_cooperators = sum(history.opponent_actions[-1, :])
        cooperation_rate = current_cooperators / self.game_description.n_players
        if state.round_number < self.adaptation_window:
            punishment_probability = 0.5 + 0.5 * math.sin(math.pi * (state.round_number / self.adaptation_window))
        else:
            punishment_probability = self.punishment_probability
            exploitation_probability = self.exploitation_probability
        if cooperation_rate < self.coop_threshold and self.adaptation_count < self.game_description.n_rounds:
            self.punishment_probability += 0.1
            self.adaptation_count += 1
        if cooperation_rate > self.coop_rate_threshold and state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if random.random() < punishment_probability * current_cooperators / self.game_description.n_players + (1 - punishment_probability) * (1 - current_cooperators):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_108(BaseStrategy):
    """
    Tit-for-Tat-with-Modification (TfT-M) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = game_description.n_rounds - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < state.round_number:
            action = Action.D
        else:
            action = self._determine_action(state, history)
        return action

    def _determine_action(self, state: GameState, history: PlayerHistory) -> Action:
        cooperators = sum(history.opponent_actions[state.round_number - 1])
        if cooperators == self.game_description.n_players:
            return Action.C
        elif state.round_number < self.last_round and history.my_actions[state.round_number - 1] == Action.C:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_109(BaseStrategy):
    """
    Tit-for-Tat-Evolution (TfTe) Exploitative Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0
        self.last_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is None:
            return Action.D
        else:
            current_round = state.round_number - 1
            self.last_round += 1
            self.last_round_cooperators = sum(history.opponent_actions[self.last_round, :])
            if self.last_round == 0 or (self.last_round_cooperators > 0 and history.my_actions[current_round - 1] == Action.D):
                return Action.D
            elif self.last_round_cooperators == self.game_description.n_players:
                return Action.C
            else:
                payoff_if_cooperate = history.opponent_payoffs[current_round - 1, np.where(history.opponent_actions[current_round - 1] == Action.C)].mean() + self.game_description.k / self.game_description.n_players
                payoff_if_defect = history.my_payoffs[current_round - 1] + (1 - history.opponent_payoffs[current_round - 1, np.where(history.opponent_actions[current_round - 1] == Action.C)].mean())
                return Action.C if payoff_if_cooperate > payoff_if_defect else Action.D

class Strategy_EXPLOITATIVE_110(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = 0.2
        self.cooperation_rate = 0
        self.round_half = math.ceil(game_description.n_rounds / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.round_half:
            action = history.opponent_actions[state.round_number - 1, 0] if history else Action.C
            self.cooperation_rate += (action == Action.C) / self.game_description.n_players
        else:
            self.cooperation_rate = max(0, min(1, self.cooperation_rate))
            self.cooperative_threshold = self.get_cooperative_threshold()
            action = history.opponent_actions[state.round_number - self.round_half, 0] if history else Action.C
        return Action(int(action == Action.C) > self.cooperative_threshold)

    def get_cooperative_threshold(self):
        cooperation_rate = self.cooperation_rate if self.round_half % 2 == 1 else self.cooperation_rate * 2
        return max(0.2, min(0.8, cooperation_rate))

class Strategy_EXPLOITATIVE_113(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    The strategy follows the rules of Tit-for-Tat but adjusts its contribution level based on the number of cooperators in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_history.append(np.mean(history.opponent_actions[-1]))
        cooperators = np.sum(history.opponent_actions[-1])
        if state.round_number == self.game_description.n_rounds:
            return Action.C if np.mean(self.opponent_history) >= 0.5 else Action.D
        if history.my_actions[-1] == Action.C:
            return Action.C
        elif history.my_payoffs[-1] > (1 - self.game_description.k) * cooperators + self.game_description.k * np.mean(self.opponent_history):
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_114(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive cooperation for N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.penalty_rounds = self.game_description.n_players // 2
        self.min_cooperation_threshold = 0.5
        self.history_length = min(self.game_description.n_rounds, 10)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        my_actions = history.my_actions[-self.history_length:]
        total_cooperators = np.sum(my_actions)
        cooperation_percentage = total_cooperators / self.history_length
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif cooperation_percentage > self.min_cooperation_threshold:
            return Action.C
        else:
            opponent_actions = history.opponent_actions[-1, :]
            if np.all(opponent_actions == my_actions[-1]) and state.round_number >= self.penalty_rounds:
                return Action.C
            elif np.all(opponent_actions != my_actions[-1]):
                self.penalty_rounds = min(self.game_description.n_players, self.penalty_rounds * 2)
            else:
                self.penalty_rounds = max(1, self.penalty_rounds // 2)
            return Action.D

class Strategy_EXPLOITATIVE_117(BaseStrategy):
    """
    A simple adaptive strategy based on Tit For Tat where a player cooperates if their opponent cooperated in the previous round, and defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_history) == 0:
            return Action.C
        latest_opponent_action = self.opponent_history[-1]
        if latest_opponent_action == Action.C:
            return Action.C
        return Action.D

    def record_opponent_action(self, opponent_action: Action):
        self.opponent_history.append(opponent_action)
        if len(self.opponent_history) > self.game_description.n_rounds:
            self.opponent_history = self.opponent_history[-self.game_description.n_rounds:]

class Strategy_EXPLOITATIVE_118(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Contribution (TTAC) strategy for the N-Player Public Goods Game.
    This strategy cooperates initially and reciprocates cooperation while punishing defection when necessary, maintaining a balance between cooperation and defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.memory = {}

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        action = Action.D
        if state.round_number in self.memory:
            cooperating_now = True
            for opponent_action in history.opponent_actions[:, self.__class__.__name__]:
                if not np.all(opponent_action):
                    cooperating_now = False
                    break
            if cooperating_now:
                action = Action.C
        else:
            total_players = self.game_description.n_players
            cooperation_count = np.sum(history.opponent_actions[-1, :])
            if state.round_number == 1:
                action = Action.C
            elif cooperation_count >= (total_players - 1) // 2 and (not history.my_actions[-1]):
                action = Action.C
            elif not history.my_actions[-1] or cooperation_count < (total_players - 1) // 2:
                action = Action.D
        if state.round_number > 0 and action == Action.C and (state.round_number not in self.memory):
            self.memory[state.round_number] = state.round_number
        return action

class Strategy_EXPLOITATIVE_119(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TfTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0
        self.last_defection_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.forgiveness_counter = max(self.forgiveness_counter - 1, 0)
        if history is not None:
            self.last_defection_round = np.argmax(history.opponent_actions[:, 0])
        cooperation = np.any(history.opponent_actions[-1, :]) if history is not None else False
        forgiven_defection = self.last_defection_round < state.round_number - self.forgiveness_counter - 1
        action = Action.C if cooperation or forgiven_defection else Action.D
        return action

class Strategy_EXPLOITATIVE_120(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    This strategy begins by cooperating in the first round, mimicking initial goodwill or uncertainty about opponent behavior.
    In subsequent rounds: if an opponent cooperates, ATfT also cooperates; if an opponent defects, ATfT also defects.
    However, to account for the multiplayer setting, when an opponent cooperates, ATfT will only contribute proportionally less than the average number of cooperators in the previous round (excluding itself).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_contribution = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not self.previous_contribution:
            return Action.C
        cooperators = sum(history.opponent_actions[-1]) + (1 if history else 0)
        avg_cooperators = cooperators / self.game_description.n_players
        self.previous_contribution = max(0, min(self.game_description.k / avg_cooperators * self.previous_contribution, 1))
        return Action.C if history and np.all(history.opponent_actions[-1]) == [self.previous_contribution > 0] else Action.D

    def handle_edge_cases(self, round: int, is_last_round: bool) -> bool:
        return round == 1 or not is_last_round

class Strategy_EXPLOITATIVE_121(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperation = None
        self.threshold = None
        self.cooperative_history = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.average_cooperation or self.game_description.n_rounds < self.game_description.n_players + 1:
            self.threshold = np.mean(history.my_actions[:self.game_description.n_players - 1].sum(axis=0))
        else:
            self.cooperative_history[-1] += int(history.my_actions[-1].sum())
            self.threshold = np.mean(self.cooperative_history) if self.cooperative_history.sum() > 0 else self.game_description.n_players / 2
        cooperators = history.opponent_actions[state.round_number - 1].sum()
        if cooperators >= self.threshold:
            return Action.C
        return Action.D

    def update(self, state: GameState, payoff: float):
        if state.round_number == self.game_description.n_rounds - 1 and self.cooperative_history[-1] < self.average_cooperation:
            return Action.D
        self.cooperative_history[state.round_number] = int(history.my_actions[state.round_number].sum())

class Strategy_EXPLOITATIVE_123(BaseStrategy):
    """
    A simple strategy that cooperates with more than the majority of players, based on game parameters n and k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tftac_threshold = math.ceil(game_description.n_players * (1 - game_description.k / 2))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if cooperators >= self.tftac_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_124(BaseStrategy):
    """Tit-for-Tat with Adaptive Cooperation Frequency (TFT-ACF)"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cf_threshold = 0.5
        self.rounds_played = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        self.rounds_played += 1
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        avg_cooperation = cooperators / self.game_description.n_players
        self.cf_threshold = self.cf_threshold * (self.game_description.k / (self.game_description.k - 1)) if history.my_actions[-1] else self.cf_threshold * ((self.game_description.k - 1) / self.game_description.k)
        return Action.C if avg_cooperation >= self.cf_threshold else Action.D

class Strategy_EXPLOITATIVE_125(BaseStrategy):
    """
    Tit-for-Tat with Variance (TfTV) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        cooperators = sum(opponent_actions)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        prob = 1 - self.epsilon
        action = Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            if opponent_actions[-1]:
                action = np.random.choice([Action.C, Action.D], p=[prob, self.epsilon])
            else:
                action = np.random.choice([Action.C, Action.D], p=[self.epsilon, prob])
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_127(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_contributions = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.average_contributions[0] = 0
            self.calculate_average_contributions(history)
            return Action.C
        if state.round_number == len(self.average_contributions):
            return Action.C
        self.calculate_average_contributions(history)
        total_contributions = sum(history.opponent_actions[-1])
        if total_contributions >= np.mean(self.average_contributions):
            return Action.C
        return Action.D

    def calculate_average_contributions(self, history: PlayerHistory) -> None:
        """
        Calculate and update the average contributions per round.
        """
        self.average_contributions = np.roll(self.average_contributions, -1)
        self.average_contributions[-1] = sum(history.opponent_actions[-1]) / self.game_description.n_players

class Strategy_EXPLOITATIVE_128(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Contribution (TfTAC) strategy for N-player Public Goods Game.
    This strategy adapts its cooperation based on the number of cooperators in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2)), np.zeros(1), np.zeros((1, game_description.n_players)), np.zeros(1))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.history = history
        if state.round_number == 0:
            return Action.C
        cooperators = sum(self.history.opponent_actions[-1, :])
        average_cooperators = np.mean(self.history.opponent_actions[:, -1].reshape(-1))
        if cooperators >= math.ceil(self.game_description.n_players / 2) or (cooperators == self.game_description.n_players and random.random() < 0.5):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_129(BaseStrategy):
    """
    A Tit-for-Tat with Variation (TfTV) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = 0.5
        self.last_round_defectors = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        if history.opponent_actions[-1].sum() == self.game_description.n_players:
            return Action.C
        if self.last_round_defectors / self.game_description.n_players > self.alpha or history.opponent_actions[-1].sum() < self.game_description.n_players - 1:
            self.last_round_defectors = history.opponent_actions[-1].sum()
            return Action.D
        else:
            self.last_round_defectors = 0
            return Action.C

class Strategy_EXPLOITATIVE_130(BaseStrategy):
    """
    Tit-for-Tat-K (TFT-K) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperated_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        total_players = len(history.opponent_actions[0])
        self.cooperated_rounds = 0 if state.round_number == 1 else self.cooperated_rounds + 1
        if cooperators == total_players:
            return Action.C
        elif cooperators > 0 and self.cooperated_rounds < total_players - 1:
            return Action.D
        elif self.cooperated_rounds >= total_players - 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_131(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Cooperative Bias Strategy for N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defections = 0
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            self.consecutive_defections = 0
            self.last_opponent_action = None
            return Action.C
        if history is not None:
            self.last_opponent_action = history.opponent_actions[-1, -1] if state.round_number > 1 else None
            if self.last_opponent_action == Action.C:
                return Action.C
            elif self.last_opponent_action == Action.D:
                self.consecutive_defections += 1
                cooperation_probability = 1 / (1 + self.consecutive_defections)
                if random.random() < cooperation_probability:
                    return Action.C
            else:
                self.consecutive_defections = 0
        return Action.D

class Strategy_EXPLOITATIVE_133(BaseStrategy):
    """
    Tit-for-Tat Plus (TfT+) strategy for the N-player Public Goods Game.
    Rewards cooperation and punishes defection based on majority rules.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1]) if history else self.n_players
        majority = math.ceil((self.n_players + 1) / 2)
        if cooperators >= majority:
            return Action.C
        elif cooperators < self.n_players - 1 and state.round_number != self.game_description.n_rounds:
            return Action.D
        elif self.game_description.n_rounds == state.round_number and cooperators >= majority:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_135(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TfT-A) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_opponent_action is None:
            return Action.C
        last_opponent_action = history.opponent_actions[-1][-1] if state.round_number < self.game_description.n_rounds - 1 else history.opponent_actions[-2, -1]
        self.last_opponent_action = last_opponent_action
        return Action(int(last_opponent_action))

class Strategy_EXPLOITATIVE_136(BaseStrategy):
    """
    The Tit-for-Tat Cooperative (Tftc) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = math.floor(game_description.n_rounds * 0.1)
        self.consecutive_noncooperation = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1, :])
        self.consecutive_noncooperation = 0 if history is None else history.my_actions[-1]
        if self.consecutive_noncooperation > self.tolerance:
            return Action.D
        elif cooperators < self.game_description.n_players and history is not None:
            self.consecutive_noncooperation += 1
        else:
            self.consecutive_noncooperation = 0
        return Action.C if cooperators >= self.game_description.n_players // 2 else Action.D

class Strategy_EXPLOITATIVE_137(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    A simultaneous move game strategy that cooperates or defects based on the opponent's average cooperation rate over a sliding window.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = self.game_description.n_players // 2
        self.sliding_window = 5
        self.threshold_decay = 0.1
        self.threshold_increase = 0.2
        self.cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.cooperation_history.append(1 if history.my_actions[-1] == Action.C else 0)
            total_cooperators = sum(self.cooperation_history[-self.sliding_window:])
            cooperation_rate = total_cooperators / self.sliding_window
            if state.round_number == self.game_description.n_rounds - 1:
                if cooperation_rate >= self.cooperation_threshold:
                    return Action.C
                else:
                    return Action.D
            elif cooperation_rate < self.cooperation_threshold - self.threshold_decay:
                self.cooperation_threshold += self.threshold_increase
            elif cooperation_rate > self.cooperation_threshold + self.threshold_decay:
                self.cooperation_threshold -= self.threshold_decay
            return Action.C if cooperation_rate >= self.cooperation_threshold else Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_138(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)

    Summary:
    This strategy adopts the Tit-for-Tat cooperation strategy, with an additional adaptive cooperation mechanism and a forgiveness mechanism to handle various opponent behaviors. The strategy is designed to be robust against exploitation while maintaining the potential for long-term payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(math.ceil(game_description.n_players * 0.7))
        self.T = self.threshold
        self.R = int(self.T // 2)
        self.forgiveness_count = 0
        self.linear_decay_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return self.__call__(state, PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_players, self.game_description.n_rounds), dtype=bool), np.zeros(self.game_description.n_rounds)))
        if state.round_number == self.game_description.n_rounds - 1 or history.my_payoffs[-1] < self.threshold:
            return Action.D
        opponent_action = history.opponent_actions[-1, state.__class__.name - 1] if len(history.opponent_actions) > 0 else False
        if self.forgiveness_count >= self.T and self.linear_decay_rounds < self.R:
            cooperate_probability = (self.T - self.linear_decay_rounds) / self.T
            return Action(random.choice([Action.C, Action.D]) if random.random() < cooperate_probability else Action.D)
        if opponent_action:
            return Action.C
        else:
            self.forgiveness_count += 1 if opponent_action else 0
            if self.forgiveness_count >= self.T:
                self.linear_decay_rounds = self.game_description.n_rounds if self.linear_decay_rounds >= self.R else self.linear_decay_rounds + 1
            return Action.D

class Strategy_EXPLOITATIVE_139(BaseStrategy):
    """
    A strategy that mimics cooperation while punishing defection with an adaptive contribution factor.
    This strategy cooperates initially and reciprocates the opponent's previous action in subsequent rounds,
    while gradually reducing its contributions over time if faced with repeated defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_factor = game_description.k
        self.defections_counter = 0
        self.consecutive_defections_limit = math.floor(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number < self.game_description.n_rounds - 1:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators > 0:
                return Action.C
            else:
                self.defections_counter += 1
                if self.defections_counter <= self.consecutive_defections_limit:
                    return Action.D
                else:
                    self.contribution_factor *= 1 - self.consecutive_defections_limit / state.round_number
        if history is not None and state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_140(BaseStrategy):
    """
    A strategy that mimics opponents' last-round actions, fostering cooperation while retaliating against defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_threshold = int(math.ceil(game_description.n_players / 2))
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        my_action = self.history.my_actions[-1] if history is not None else Action.C
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C if my_action == Action.C else Action.D
        elif self.history.my_actions[-1] == Action.C and len(self.get_defectors()) > self.forgiveness_threshold:
            return Action.C
        return Action.D

    def get_defectors(self) -> int:
        """
        Returns the number of times an opponent defected in history.
        """
        return sum([np.count_nonzero(history.opponent_actions[:, i]) for i in range(1, self.game_description.n_players + 1)])

class Strategy_EXPLOITATIVE_141(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptation (TfTA)
    Strategy description: Cooperate in the first round; follow the majority of actions from the previous round thereafter, adapting to cooperative or defecting environments.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.majority_threshold = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) == 0):
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.majority_threshold:
            return Action.C
        elif cooperators == len(history.opponent_actions) - self.majority_threshold:
            return Action.D
        else:
            return random.choice([Action.C, Action.D])

class Strategy_EXPLOITATIVE_143(BaseStrategy):
    """
    An adaptive tit-for-tat strategy for the N-Player Public Goods Game.
    This strategy cooperates with opponents who have recently cooperated, and defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_history = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        last_move = opponent_history[-1]
        return Action.C if last_move else Action.D

class Strategy_EXPLOITATIVE_146(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFT-AC) strategy for N-Player Public Goods Game.
    This strategy cooperates in the initial round and mirrors the average contribution of opponents over the previous 'm' rounds thereafter.
    If the average contribution is above a certain threshold, it cooperates; otherwise, it defects. The strategy responds effectively to both cooperative and exploitative opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(math.ceil(self.game_description.n_rounds * 0.5))
        self.t = self.game_description.k / 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            history = PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))
            history.opponent_actions[0] = np.ones(self.game_description.n_players)
            history.opponent_payoffs[0] = 1 - history.opponent_actions[0] + self.game_description.k / self.game_description.n_players * history.opponent_actions[0].sum()
        if state.round_number == len(history.my_payoffs):
            contributions_avg = np.mean(history.opponent_actions[-self.m:, :].sum(axis=1))
        else:
            contributions_avg = np.mean(history.opponent_actions[-self.m:, :].sum(axis=1))
        if contributions_avg >= self.t:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_147(BaseStrategy):
    """
    A simple Tit-for-Tat Adaptive (TfTA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_action_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == 0 and history is not None:
            self.opponent_action_history = np.zeros(1)
        else:
            self.opponent_action_history = np.append(self.opponent_action_history, np.array([history.opponent_actions[-1].sum() > len(history.opponent_actions) // 2]))
        if len(self.opponent_action_history) == 0:
            return Action.C
        else:
            last_opponent_action = self.opponent_action_history[-1]
            if last_opponent_action:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_148(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy for N-Player Public Goods Game.
    This strategy cooperates initially and adapts based on opponent's actions, reciprocating cooperation and punishing defection with a temporary decrease in contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_period = math.ceil(game_description.n_rounds / 2)
        self.recent_opponent_history = np.zeros(self.punishment_period, dtype=bool)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            cooperators = np.zeros(self.game_description.n_rounds, dtype=int)
            cooperators[0] = 1
            return Action(cooperators[0])
        self.recent_opponent_history = self.recent_opponent_history[-self.punishment_period:]
        self.recent_opponent_history[-1] = history.opponent_actions[-1, -1]
        if np.all(history.opponent_actions[-self.punishment_period:, -1]) == [True]:
            if state.round_number % (self.punishment_period - 1) == 0:
                self.punishment_period -= 1
        else:
            self.punishment_period = math.ceil(self.game_description.n_rounds / 2)
        if state.round_number == self.game_description.n_rounds or (state.round_number > self.punishment_period and np.all(self.recent_opponent_history[-self.punishment_period:]) == [True]):
            return Action.C if np.all(history.opponent_actions[-self.punishment_period:, -1]) == [True] else Action.D
        return Action.D

class Strategy_EXPLOITATIVE_150(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Ratio strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(math.ceil(game_description.n_rounds / 20))
        self.average_cooperation = np.zeros(self.m)
        self.total_cooperation = 0
        self.history_length = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None and self.history_length >= self.m:
            cooperate_prob = max(self.average_cooperation / np.maximum(np.abs(self.average_cooperation - np.mean(self.average_cooperation)), 1e-05) * (self.game_description.n_players - 1), random.random())
            total_cooperators = np.sum(history.opponent_actions[-self.m:, :].T.ravel())
            if total_cooperators >= self.game_description.n_players * (self.game_description.k - 1) * 0.5:
                cooperate_prob += 1.0
            return Action(int(random.uniform(0, 1) < cooperate_prob))
        elif history is not None and self.history_length > 0:
            return self._decide_action(state, history)
        else:
            average_cooperation = np.mean(history.my_actions[:self.history_length]) if history is not None else 0
            return Action(int(random.uniform(0, 1) < average_cooperation))

    def _decide_action(self, state: GameState, history: PlayerHistory) -> Action:
        """
        Make a decision based on the history of actions and payoffs up to the current round.
        """
        opponent_cooperated = np.any(history.opponent_actions[-1] == 1)
        average_cooperation, total_cooperation = self._update_averages_and_totals(history)
        cooperate_prob = max(average_cooperation / np.maximum(np.abs(average_cooperations - np.mean(average_cooperation)), 1e-05) * (self.game_description.n_players - 1), random.random())
        if opponent_cooperated:
            cooperate_prob *= average_cooperation
        elif total_cooperation >= self.game_description.n_players * (self.game_description.k - 1) * 0.5:
            cooperate_prob += 1.0
        return Action(int(random.uniform(0, 1) < cooperate_prob))

    def _update_averages_and_totals(self, history: PlayerHistory) -> tuple[NDArray[np.float64], NDArray[np.float64]]:
        """
        Update the average cooperation and total cooperation in the last 'm' rounds of the game's history.
        """
        total_cooperation = np.sum(history.opponent_actions[-self.m:, :].T.ravel())
        self.total_cooperation = total_cooperation
        if self.history_length < self.m:
            average_cooperation = history.my_actions[:self.history_length]
        else:
            average_cooperation = (np.roll(self.average_cooperation, -1) + history.my_actions[self.history_length - self.m:]) / self.m
        self.average_cooperation = np.copy(average_cooperation)
        self.history_length += 1
        return (average_cooperation, total_cooperation)

class Strategy_EXPLOITATIVE_152(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game

    This strategy initially cooperates in the first round, then responds cooperatively or defectively based on the long-term average of opponent cooperation.
    The cooperation threshold is adaptively adjusted to balance cooperation and defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_opponent_cooperation = np.zeros(self.game_description.n_rounds)
        self.total_contributions_history = [0] * (self.game_description.n_rounds + 1)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.total_contributions_history[state.round_number] = sum(history.opponent_actions[-1])
        if state.round_number == 1 or history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        avg_contributions = np.mean(self.total_contributions_history[1:state.round_number + 1])
        t_coop = (avg_contributions * (state.round_number - 1) + cooperators) / state.round_number
        return Action.C if avg_contributions >= t_coop else Action.D

class Strategy_EXPLOITATIVE_154(BaseStrategy):
    """
    A strategy that plays Tit-for-Tat with Adaptive Generosity in N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.g = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.g = 1.0
            return Action.C
        self.g = 0.5 if state.round_number == self.game_description.n_rounds else 0.5
        previous_opponent_action = history.opponent_actions[-1, 0]
        if previous_opponent_action:
            self.g = min(self.g, 1.0)
            return Action.C
        elif random.random() < self.g:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_155(BaseStrategy):
    """
    Tit-for-Tat-Adaptive (TfTA) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_number = 0
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_number = state.round_number
        opponent_actions = history.opponent_actions if history else np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool)
        self.last_opponent_action = opponent_actions[-1, 0] if state.round_number < self.game_description.n_rounds else self.last_opponent_action
        return Action.C if self.last_opponent_action == Action.C else Action.D

class Strategy_EXPLOITATIVE_156(BaseStrategy):
    """Tit-for-Tat Strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.history = PlayerHistory(np.array([[Action.C]], dtype=bool), np.zeros((1,)), np.zeros((1, self.game_description.n_players)), np.zeros((1,)))
        my_action = history.my_actions[-1]
        total_cooperators = np.sum(history.opponent_actions[-1])
        payoff = 1 - my_action + self.game_description.k / self.game_description.n_players * total_cooperators
        history.my_payoffs[-1] = payoff
        if state.round_number < self.game_description.n_rounds:
            opp_action = history.opponent_actions[-1, -1]
        else:
            opp_action = history.opponent_actions[-2, -1]
        if opp_action == Action.C:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_157(BaseStrategy):
    """
    Tit-for-Tat (with Adaptive Cooperation Threshold) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = [0] * game_description.n_players
        self.round_progress = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if self.round_progress < self.game_description.n_players:
            self.cooperation_threshold[self.round_progress] = min(math.ceil(self.round_progress / self.game_description.n_players * (self.game_description.n_players - 1)), self.game_description.n_players - 1)
            self.round_progress += 1
        if history is not None:
            cooperators = sum(history.opponent_actions[-1])
            return Action(cooperators >= self.cooperation_threshold[-1])
        else:
            return Action.D

class Strategy_EXPLOITATIVE_159(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Cooperation (TfTA-C) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_window = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or len(history.opponent_actions) < self.history_window:
            return Action.C
        recent_rounds = history.opponent_actions[-self.history_window:]
        majority = np.count_nonzero(np.ravel(recent_rounds) > 0) >= self.game_description.n_players // 2
        return Action.C if majority else Action.D

class Strategy_EXPLOITATIVE_160(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Cooperation for N-Player Public Goods Game.
    The strategy cooperates initially, then responds to the opponent's previous action in each subsequent round.
    In the final round, it decides whether to cooperate or defect based on the overall history of cooperation between both players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_rounds = sum(range(1, self.game_description.n_players + 1)) * self.game_description.n_rounds
        self.total_cooperation_threshold = self.total_rounds // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_history = history.opponent_actions[state.round_number - 1] if history is not None else np.zeros(self.game_description.n_players, dtype=np.bool_)
        cooperators = sum(opponent_history)
        if state.round_number == self.total_rounds:
            cooperation_percentage = cooperators / state.round_number * 100
            return Action.C if cooperation_percentage > self.total_cooperation_threshold else Action.D
        return Action.C if cooperators >= self.game_description.n_players // 2 else Action.D

class Strategy_EXPLOITATIVE_162(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)

    This strategy cooperates initially to foster a cooperative environment, then adapts its behavior based on the opponent's previous action. If the opponent has cooperated, the agent will cooperate in return; if the opponent has defected, the agent will defect as well.

    In the last round, the agent cooperates regardless of past actions since there are no further rounds to retaliate. If an opponent has never cooperated before, the strategy continues defecting as a long-term strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))
        self.last_opponent_cooperation = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.history.my_actions[-1] and state.round_number > 1:
            return self.history.my_actions[-1]
        self.last_opponent_cooperation = sum(history.opponent_actions[state.round_number - 1, :])
        if history.my_actions[-1]:
            return Action.C
        elif self.last_opponent_cooperation and state.round_number < self.game_description.n_rounds:
            return Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.C

class Strategy_EXPLOITATIVE_163(BaseStrategy):
    """
    A Tit-for-Tat-Gradient strategy for N-Player Public Goods Game.
    Cooperates initially, then adapts to opponents' actions in subsequent rounds.
    Rewards cooperation and punishes defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.last_opponent_action = np.mean(history.opponent_actions[-1])
        if state.round_number == len(history.opponent_payoffs) and self.last_opponent_action is not None:
            return Action.D
        opponent_cooperated = self.last_opponent_action > 0.5
        if opponent_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_164(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TfT-ACR)

    This strategy cooperates in the first round, then adaptively decides to cooperate or defect based on a dynamic cooperation rate. The cooperation rate is updated after each round, depending on the average number of cooperators in the previous half rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_rate = self.game_description.k / 2
        self.delta = 0.01
        self.T = int(self.game_description.n_players * 0.6)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        average_cooperators = np.mean(history.my_actions[-self.game_description.n_rounds // 2:])
        if average_cooperators >= self.T:
            self.cooperation_rate = min(self.cooperation_rate + self.delta, 1)
        else:
            self.cooperation_rate = max(self.cooperation_rate - self.delta, 0)
        return Action.C if random.random() <= self.cooperation_rate else Action.D

class Strategy_EXPLOITATIVE_165(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        previous_round = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=np.bool_)
        cooperators = sum(previous_round)
        if all(previous_round):
            return Action.C
        elif cooperators > self.game_description.n_players // 2:
            return Action.C
        elif np.count_nonzero(previous_round) == self.game_description.n_players - 1:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_167(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TTFC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None:
            previous_cooperators = sum(history.opponent_actions[-1])
            cooperators_ratio = previous_cooperators / self.game_description.n_players
            if cooperators_ratio > 0.5:
                action = Action.C
            elif cooperators_ratio <= 0.5:
                action = Action.D
            else:
                action = self.last_round_action
            self.last_round_action = action
        return action

class Strategy_EXPLOITATIVE_168(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    A cooperative strategy that reciprocates cooperation and punishes defection, with a tolerance mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = 0
        self.cooperation_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history is not None:
            opponent_action = history.opponent_actions[state.round_number - 1, 0]
            if opponent_action == Action.C and self.tolerance < self.game_description.n_players:
                action = Action.C
            elif self.cooperation_counter > 0 and self.tolerance < self.game_description.n_players:
                action = Action.D
            elif self.tolerance >= self.game_description.n_players:
                action = Action.C
            if opponent_action == Action.C:
                self.cooperation_counter += 1
                self.tolerance = 0
            elif opponent_action == Action.D:
                self.tolerance += 1
        return action

class Strategy_EXPLOITATIVE_169(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFTA) strategy in the N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.k * (game_description.n_players - 1) / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators < self.threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_170(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    A strategy that cooperates when all opponents have previously cooperated,
    and defects otherwise. Maintains a history of interactions to make decisions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.history_length = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if history is not None:
            self.history = history
            self.update_state()
        cooperators = sum(self.history.opponent_actions[-self.history_length:, -1])
        if cooperators == self.game_description.n_players:
            return Action.C
        elif any((action == Action.D for action in self.history.my_actions[:-self.history_length])):
            return Action.D
        else:
            self.history_length += 1
            return Action.C

    def update_state(self):
        """Updates state variables based on the current history"""
        self.history.my_actions[:self.history_length] = self.history.opponent_actions[-self.history_length:, -1]
        self.history.my_payoffs[:self.history_length] = np.full(self.history_length, 1)
        cooperators = sum(self.history.opponent_actions[-self.history_length:, -1])
        payoff_multiplier = self.game_description.k / self.game_description.n_players * cooperators
        self.history.my_payoffs[-self.history_length] = 1 + payoff_multiplier - sum(self.history.opponent_payoffs[-self.history_length])

class Strategy_EXPLOITATIVE_172(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.noise_parameter = 0.5
        self.cooperation_threshold = self.game_description.k / self.game_description.n_players * (1 + self.noise_parameter)
        self.contributions = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_cooperation = sum(history.opponent_actions[-1]) if history else self.contributions[-1]
        average_contribution = total_cooperation / self.game_description.n_players
        if average_contribution >= self.cooperation_threshold:
            self.contributions[state.round_number] = 1
            return Action.C
        else:
            self.contributions[state.round_number] = 0
            return Action.D

class Strategy_EXPLOITATIVE_173(BaseStrategy):
    """
    A Tit-for-Tat-with-a-Twist strategy for an N-Player Public Goods Game.
    The strategy cooperates on the first round and responds to other players' actions in subsequent rounds.
    It punishes defectors while appearing trustworthy to potential partners.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.first_round = True
            return Action.C
        action = Action.C if self.first_round else Action.D
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if cooperators >= self.game_description.n_players // 2 and self.first_round:
            action = Action.C
            self.first_round = False
        if state.round_number < self.game_description.n_rounds - 1 and (not self.first_round):
            if cooperators >= self.game_description.n_players // 2:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_174(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Cooperative Threshold (TFT-ACT) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.lookback_window = int(math.ceil(game_description.n_rounds * 0.1))
        self.factor = 0.5
        self.min_act = 0.1
        self.max_act = 0.9
        self.rounds_played = 0
        self.total_cooperation = 0.0
        self.average_cooperation_rate = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.rounds_played += 1
        act = Action.D
        if self.rounds_played >= self.lookback_window:
            if history is not None and self.rounds_played - self.lookback_window > 0:
                cooperators = sum(history.opponent_actions[self.rounds_played - self.lookback_window:, :].sum(axis=1))
                self.total_cooperation += cooperators
                self.average_cooperation_rate = self.total_cooperation / self.rounds_played
                act_threshold = self.average_cooperation_rate * self.factor
                act = Action.C if act_threshold >= self.min_act and act_threshold <= self.max_act else Action.D
        return act

class Strategy_EXPLOITATIVE_175(BaseStrategy):
    """
    Tit-for-Tat-Plus Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = game_description.n_rounds - 1
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            self.first_round = True
            action = Action.C
        elif state.round_number != self.last_round and history is not None:
            opponent_action = history.opponent_actions[-1, -1] if len(history.opponent_actions) > 0 else Action.D
            self.first_round = False if opponent_action is not None else True
            action = opponent_action if opponent_action == Action.C else Action.D
        elif state.round_number == self.last_round or history is None:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_176(BaseStrategy):
    """
    The Tit-for-Tat-Plus strategy for the N-Player Public Goods Game.
    A robust and adaptive exploitative strategy that punishes defection and encourages cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.25
        self.state_history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.state_history = history
        opponent_cooperated_last_round = np.any(history.opponent_actions[-1])
        if opponent_cooperated_last_round:
            action = Action.C
        else:
            random_number = random.random()
            if 0 < random_number < self.p:
                action = Action.C
            elif self.p <= random_number < 1:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_177(BaseStrategy):
    """
    Traitor Tit for Tat with Adaptation (TTfTA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cumulative_cooperation_rate = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        if not history:
            self.cumulative_cooperation_rate = random.choices([0, 1], [1 / self.game_description.n_players, (self.game_description.n_players - 1) / self.game_description.n_players])[0]
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            self.cumulative_cooperation_rate = float(cooperators) / self.game_description.n_players
        if self.cumulative_cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_178(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    Strategy Description: Cooperates in the first round and then mimics the actions of its opponent from the previous round for the remainder of the game, with a forgiving nature that returns to cooperation after an act of defection by the opponent.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._opponent_history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            self._opponent_history = history.opponent_actions if history is not None else np.zeros((state.round_number, self.game_description.n_players), dtype=np.bool_)
            action = self._opponent_history[-1][0]
            return action if np.isnan(action) else Action.C if action else Action.D

class Strategy_EXPLOITATIVE_179(BaseStrategy):
    """
    A strategy that mimics cooperating in the first round and subsequently adapts its actions based on the opponent's previous moves. It includes a forgiveness mechanism for opponents who have demonstrated some level of cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_history = np.zeros(4, dtype=int)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < 4:
            self.forgiveness_history = np.zeros(4, dtype=int)
        opponent_cooperators = sum(history.opponent_actions[-4:-1].flatten() if history.opponent_actions[-1][0] else [])
        self.forgiveness_history[3] = self.forgiveness_history[2]
        self.forgiveness_history[2] = self.forgiveness_history[1]
        self.forgiveness_history[1] = self.forgiveness_history[0] + int(history.opponent_actions[-1][0])
        self.forgiveness_history[0] = opponent_cooperators
        if sum(self.forgiveness_history > 0) >= 3:
            return Action.C
        elif history.opponent_actions[-1][0]:
            return Action.C
        else:
            return Action.D

    def last_round(self):
        """
        Returns true if the current round is the last round in the game.
        """
        return self.game_description.n_rounds <= self.state.round_number + 1

class Strategy_EXPLOITATIVE_180(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)
    This strategy promotes cooperation based on the average number of cooperators and adjusts the cooperation behavior dynamically.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.consecutive_successful_cooperations = 0
        self.consecutive_defections = 0
        self.average_contributions = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        contributions = np.sum(history.opponent_actions, axis=0).astype(int)
        self.average_contributions = (self.average_contributions * (state.round_number - 1) + contributions[-1]) / state.round_number
        if contributions[-1] >= int(self.threshold * self.game_description.n_players):
            self.consecutive_successful_cooperations += 1
            self.consecutive_defections = 0
        else:
            self.consecutive_defections += 1
            self.consecutive_successful_cooperations = 0
        if self.consecutive_successful_cooperations > self.game_description.n_players // 2:
            self.threshold += 0.05
        elif self.consecutive_defections > self.game_description.n_players // 4:
            self.threshold -= 0.05
        return Action.C if self.average_contributions >= self.threshold else Action.D

class Strategy_EXPLOITATIVE_181(BaseStrategy):
    """
    Strategy that follows a Tit-for-Tat pattern with adaptation to the opponent's behavior,
    cooperating when the opponent has been cooperative for a certain number of previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.c = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        opponent_actions = history.opponent_actions[-self.c:] if state.round_number >= self.c else np.zeros(self.c, dtype=bool)
        recent_cooperators = np.sum(opponent_actions)
        return Action.C if recent_cooperators == self.c else Action.D

class Strategy_EXPLOITATIVE_183(BaseStrategy):
    """
    Implementation of a Tit-for-Tat strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == 0 and history is not None:
            self.last_opponent_action = history.opponent_actions[0]
            return Action.C if history.opponent_payoffs[0] < 1 else Action.D
        opponent_cooperators = sum(history.opponent_actions[-1])
        my_action = Action.C if self.last_opponent_action == Action.C or opponent_cooperators >= self.game_description.n_players - 1 else Action.D
        self.last_opponent_action = my_action if my_action is Action.D else history.opponent_actions[-1][-1]
        return my_action

class Strategy_EXPLOITATIVE_184(BaseStrategy):
    """
    A strategy that cooperates initially and adapts its contribution level based on opponents' actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.decay_factor = 1 - 1 / game_description.n_rounds
        self.contribution_rate = game_description.k / game_description.n_players
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.update_history(history)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        last_opponent_action = self.last_opponent_action
        contribution = self.contribution_rate * self.decay_factor ** (state.round_number - 2)
        if contribution <= 0:
            return Action.D
        self.last_opponent_action = last_opponent_action
        return Action.C

    def update_history(self, history: PlayerHistory):
        self.last_opponent_action = history.opponent_actions[-1, 0]

class Strategy_EXPLOITATIVE_185(BaseStrategy):
    """Tit-for-Tat with Gradual Adaptation (TfT-GA) strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators_count = np.sum(history.opponent_actions[-1])
        majority = math.ceil(self.game_description.n_players / 2)
        if cooperators_count + int(history.my_actions[-1]) >= majority:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_186(BaseStrategy):
    """
    Freerider strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = None
        self.f = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.D
        total_contributions = np.sum(history.opponent_actions[:, -1])
        if self.threshold is None or len(history.opponent_actions) < self.game_description.n_players:
            self.threshold = self.get_threshold(self.game_description, history=history)
        if total_contributions >= math.ceil(self.threshold):
            return Action.C
        return Action.D

    def get_threshold(self, game_description: PublicGoodsDescription, history: PlayerHistory=None):
        n = game_description.n_players
        k = game_description.k
        t = 0
        r = game_description.n_rounds
        if history is not None:
            t += (n - 1) * (k / (2 * n)) + self.f * (n - 1)
        return max(0, min(t, 1))

class Strategy_EXPLOITATIVE_187(BaseStrategy):
    """
    A strategy that gradually defects based on the observed proportion of cooperators in each round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = self.game_description.n_rounds
        self.n = self.game_description.n_players
        self.k = self.game_description.k
        self.threshold = self.n * (self.n * self.k) ** (-1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C if random.random() < 1 / self.r else Action.D
        cooperators = np.sum(history.opponent_actions[:state.round_number - 1, :].flatten())
        avg_cooperators = cooperators / (state.round_number - 1)
        if state.round_number >= self.r - math.sqrt(self.r):
            return Action.D
        if avg_cooperators < self.threshold:
            return Action.D
        elif avg_cooperators > self.threshold:
            return Action.C
        else:
            return random.choice([Action.C, Action.D])

class Strategy_EXPLOITATIVE_188(BaseStrategy):
    """
    A strategy that implements Tit-for-Tat with Adaptive Generosity in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.probability_deviation = 0.25
        self.streak = 0
        self.total_cooperators = np.zeros(game_description.n_rounds)
        self.my_payoffs = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if not history or state.round_number >= len(history.opponent_actions):
            return action
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        my_payoff = 1 - history.my_actions[-1][0] + self.game_description.k / self.game_description.n_players * opponent_cooperators
        total_cooperators_this_round = np.sum(history.opponent_actions[-1, :])
        self.total_cooperators[state.round_number - 1] = total_cooperators_this_round
        if my_payoff > np.mean(self.my_payoffs) and opponent_cooperators > self.streak:
            self.probability_deviation *= 1.05
            action = Action.C if random.random() < self.probability_deviation else Action.D
        elif my_payoff < np.mean(self.my_payoffs) and opponent_cooperators < self.streak:
            self.probability_deviation /= 1.05
            action = Action.C if random.random() >= self.probability_deviation else Action.D
        elif opponent_cooperators == self.streak:
            action = Action.C if random.random() < 0.5 else Action.D
        else:
            action = Action.D if history.opponent_actions[-1][state.round_number % self.game_description.n_players] else Action.C
        self.streak += int(action != history.my_actions[-1][0])
        return action

class Strategy_EXPLOITATIVE_189(BaseStrategy):
    """
    Adaptive Tit-for-Tat (TFT-X) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_history = [0] * game_description.n_players
        self.threshold = math.ceil(game_description.n_players / 2) if game_description.n_players % 2 == 0 else math.ceil((game_description.n_players + 1) / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.D
        actions = np.zeros(self.game_description.n_players, dtype=int)
        cooperators = 0
        if history is not None:
            actions = history.opponent_actions[state.round_number - 1]
            cooperators = np.sum(actions)
        if state.round_number < self.game_description.n_rounds and (cooperators == self.game_description.n_players or any([self.cooperation_history[i] >= self.threshold for i in range(self.game_description.n_players)])):
            return Action.C
        return Action.D

    def update_history(self, payoffs: PlayerHistory):
        self.cooperation_history[:] = [0] * len(self.cooperation_history)
        for i in range(len(self.cooperation_history)):
            if payoffs.my_actions[-1][i]:
                self.cooperation_history[i] += 1
                if self.cooperation_history[i] > self.threshold:
                    self.cooperation_history[i] = self.threshold

class Strategy_EXPLOITATIVE_190(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TfTA) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_threshold = int(math.ceil(game_description.n_players / 2))
        self.cooperation_duration = min(int(math.floor(game_description.n_rounds / 4)), self.forgiveness_threshold)
        self.current_round = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None and state.round_number == 0:
            return random.choice([Action.C, Action.D])
        if state.round_number < self.current_round <= state.round_number + self.cooperation_duration:
            return Action.C
        cooperators = sum(history.opponent_actions[-self.forgiveness_threshold:-1, -1])
        if cooperators >= len(history.opponent_actions) // 2:
            return Action.C
        return Action.D

    def update_parameters(self, state: GameState, history: PlayerHistory):
        if state.round_number == self.game_description.n_rounds - 1:
            success = np.mean(history.my_payoffs[-self.cooperation_duration:-1]) > np.mean(history.opponent_payoffs[-self.cooperation_duration:-1])
            if success:
                self.forgiveness_threshold -= 1
                self.cooperation_duration = min(int(math.floor(self.game_description.n_rounds / 4)), self.forgiveness_threshold)
            else:
                self.forgiveness_threshold += 1
                self.cooperation_duration -= 1
        self.current_round = state.round_number + 1

class Strategy_EXPLOITATIVE_192(BaseStrategy):
    """
    Tit-for-Tat-Adaptive strategy for N-Player Public Goods Game
    Adapts its cooperation based on the average cooperator ratio in a sliding window of past rounds
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.memory_size = int(self.r * 0.1)
        self.cooperator_ratio_threshold = 0.7
        self.opponent_history = np.zeros((self.memory_size,), dtype=bool)
        self.strategy = Action.C

    def update_strategy(self):
        cooperator_count = np.sum(self.opponent_history)
        avg_cooperator_ratio = cooperator_count / self.memory_size
        if avg_cooperator_ratio < self.cooperator_ratio_threshold:
            self.strategy = Action.D
        elif avg_cooperator_ratio > 1 - self.cooperator_ratio_threshold:
            self.strategy = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return self.strategy
        else:
            self.opponent_history = np.roll(self.opponent_history, -1)
            self.opponent_history[-1] = sum(history.opponent_actions[-1]) > 0
            self.update_strategy()
            return Action.C if self.strategy == Action.C else Action.D

class Strategy_EXPLOITATIVE_193(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game.
    Encourages reciprocity among players by cooperating initially and responding with defection if anyone defected in the previous round, while maintaining cooperation if everyone cooperated last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_number = 0
        self.history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.history = history
            self.round_number += 1
        previous_round = self.history.opponent_actions[-1]
        if all((previous_round[i] == Action.C.value for i in range(len(previous_round)))):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_194(BaseStrategy):
    """
    Implementation of the Tit-for-Tat strategy in the N-Player Public Goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_round += 1
        self.last_round %= self.game_description.n_rounds
        if self.last_round == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[self.last_round, :])
        my_action = history.my_actions[self.last_round] if history else None
        if my_action is not None and cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_195(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        self.last_opponent_action = np.mean(opponent_actions)
        if np.isclose(self.last_opponent_action, 1):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_196(BaseStrategy):
    """
    A strategy that emulates Tit-for-Tat with an adaptive cooperative threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.player_previous_cooperative_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        elif history and state.round_number > self.game_description.n_rounds - 1:
            action = Action.D
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.game_description.n_players // 2:
                self.player_previous_cooperative_rounds = cooperators
                action = Action.C
            elif cooperators < self.player_previous_cooperative_rounds:
                action = Action.D
            else:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_197(BaseStrategy):
    """
    A Tit-for-Tat Plus (TFT+) strategy for N-Player Public Goods Game.
    This strategy cooperates initially to foster a cooperative environment,
    and subsequently responds to opponent's behavior in the previous round:
    - If opponent cooperated, cooperate back to encourage continuation of cooperation.
    - If opponent defected, defect as punishment for their selfish behavior, with a slight twist that promotes eventual cooperation.
       After three consecutive defections by the opponent, switch to cooperating again to give them an opportunity to change their strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history and self.defection_counter < 3:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators > 0:
                self.defection_counter = 0
            else:
                self.defection_counter += 1
        action = Action.D if history and self.defection_counter >= 3 else Action.C if history and sum(history.opponent_actions[-1, :]) > 0 else Action.D
        if state.round_number == self.game_description.n_rounds - 1 or (history and (self.defection_counter > 0 and action == Action.C)):
            self.defection_counter = 0
        return action

class Strategy_EXPLOITATIVE_198(BaseStrategy):
    """
    A strategy named "Tit-for-Tat with Adaptive Cooperation" (TFT-AC). This strategy cooperates initially and responds to opponent's actions in subsequent rounds, punishing defections and encouraging cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.my_actions[-1] == Action.C and history.opponent_actions[-1].sum() == len(history.opponent_actions[0]) - 1:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_199(BaseStrategy):
    """
    A Tit-for-Tat Adaptive strategy with Time Discounting for N-Player Public Goods Game.
    The strategy adjusts cooperation based on the opponent's behavior, implementing exponential decay to balance short-term benefits against long-term relationships.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.discount_factor = 0.95
        self.last_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_round != state.round_number - 1:
            self.last_round = state.round_number
            return Action.C
        cooperation = history.opponent_actions[self.last_round, 0]
        if cooperation:
            return Action.C
        decayed_cooperation = np.power(self.discount_factor, state.round_number - self.last_round) * cooperation
        return Action.C if decayed_cooperation >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_200(BaseStrategy):
    """
    A Cooperative-Adaptive Defector (CAD) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_action = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if all((action == Action.C for action in (history.opponent_actions[state.round_number - 1] if history else [Action.C]))):
            self.last_action = Action.D
            return Action.D
        if any((self.last_action == Action.D for action in (history.opponent_actions[state.round_number - 1] if history else [Action.C]))):
            self.last_action = Action.D
        else:
            self.last_action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return self.last_action

class Strategy_EXPLOITATIVE_201(BaseStrategy):
    """
    The Tit-for-Tat Adaptive (TfT-A) strategy for the N-Player Public Goods Game.
    This strategy initially cooperates in the first round, mimicking an optimistic attitude of trusting others.
    In subsequent rounds, it follows a simple rule: if an opponent cooperated in the previous round, the TfT-A strategy will also cooperate;
    if not, it defects. This approach allows for potential cooperation while being prepared to retaliate against uncooperative opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = history.opponent_actions[-1]
        last_round_cooperators = np.count_nonzero(last_round)
        if last_round_cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_203(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_contrib_level = 0.5
        self.avg_coop_rate = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.avg_coop_rate:
            self.avg_coop_rate = np.mean(history.my_actions[0]) if history else 0
        cooperators = sum(history.opponent_actions[-1, :])
        avg_coop_rate = np.mean(history.opponent_actions[:-1].sum(axis=0)) if history else self.avg_coop_rate
        contrib_level = self.initial_contrib_level * (avg_coop_rate + 1) / 2
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif avg_coop_rate > (self.game_description.n_players - 1) / (2 * self.game_description.n_players):
            return Action.D if contrib_level < 1 else Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_204(BaseStrategy):
    """
    Tit-for-Tat with Time-Delayed Reciprocity (TfTR) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = -1
        self.my_last_action_2 = Action.D

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_round = state.round_number - 1
        opponent_last_action = history.opponent_actions[self.last_round, 0] if history else None
        my_action_2 = self.my_last_action_2 if self.my_last_action_2 is not Action.D else None
        if opponent_last_action == Action.C:
            return Action.C
        elif my_action_2 is not None and my_action_2 == Action.D:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_205(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.ceil(game_description.n_players / 2)
        self.alpha = 1 / (2 * game_description.n_players)
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number - 1] = Action.C == self.__class__.__name__
        self.history.my_payoffs[state.round_number - 1] = self._calculate_payoff(history)
        self.cooperation_threshold = min(self.cooperation_threshold + self.alpha, self.game_description.n_players // 2)
        cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        return Action.C if cooperators >= self.cooperation_threshold else Action.D

    def _calculate_payoff(self, history: PlayerHistory):
        total_contributions = sum(history.opponent_actions[:, 0])
        own_contribution = int(Action.C == self.__class__.__name__)
        return 1 - own_contribution + self.game_description.k / self.game_description.n_players * total_contributions

class Strategy_EXPLOITATIVE_206(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_count = {i: 0 for i in range(1, self.game_description.n_players + 1)}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < 1 / self.game_description.n_players else Action.D
        if history is not None:
            total_rounds = self.game_description.n_rounds
            total_cooperators = np.sum(history.opponent_actions.sum(axis=0))
            average_coop = total_cooperators / total_rounds
            if state.round_number < total_rounds - 1:
                player_count = len(self.history_count)
                coop_threshold = int(average_coop * self.game_description.n_players)
                if (coop_count := (sum(self.history_count.values()) >= coop_threshold)):
                    return Action.C if random.random() < self.game_description.k else Action.D
                return Action.D
            if sum(self.history_count.values()) >= average_coop:
                return Action.C
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_207(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Contribution (TTAC) strategy for the N-Player Public Goods Game.
    The strategy cooperates initially, then adapts based on past contributions to make decisions about current actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2
        self.contribution_level = 1.0
        self.adaptation_interval = int(game_description.n_rounds // 10)
        self.cooperation_decay = 0.05
        self.defection_threshold = game_description.n_players * 0.75

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1]) if history else 0
        if total_contributions >= self.threshold:
            self.contribution_level = min(self.contribution_level + self.cooperation_decay, 1.0)
            return Action.C
        elif total_contributions < self.defection_threshold and state.round_number > self.adaptation_interval:
            self.contribution_level = max(self.contribution_level - self.cooperation_decay, 0.0)
            return Action.D
        else:
            return Action.C if random.random() < self.contribution_level else Action.D

class Strategy_EXPLOITATIVE_209(BaseStrategy):
    """
    A Tit-for-Tat with Variation (TFTV) strategy that encourages stable partnerships while punishing those who betray the partnership.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defect_counter = 0
        self.cooperation_count = 0
        self.defection_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            cooperative_percentage = self.cooperation_count / (self.cooperation_count + self.defection_count)
            if cooperative_percentage > 0.5:
                return Action.C
            return Action.D
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        if state.round_number == 1 or opponents_cooperated >= self.game_description.n_players // 2:
            self.defect_counter = 0
            self.cooperation_count += 1
            return Action.C
        self.defection_count += 1
        if opponents_cooperated == 0:
            self.defect_counter += 1
        else:
            self.defect_counter = 1
        if self.defect_counter >= 2:
            self.defect_counter = 0
            self.cooperation_count += 1
        return Action.D if self.defect_counter > 0 else Action.C

class Strategy_EXPLOITATIVE_211(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number > self.game_description.n_rounds - 3:
            opponent_actions = history.opponent_actions[:state.round_number + 1, :]
            for i in range(state.round_number - 2, state.round_number):
                if np.all(opponent_actions[i][:self.game_description.n_players] == [False]):
                    self.defection_count += 1
                    if self.defection_count >= self.game_description.n_players - 1:
                        return Action.D
        if history is not None and state.round_number > self.game_description.n_rounds - 1:
            opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
            if opponent_cooperators < self.game_description.n_players - self.defection_count:
                return Action.D
        if self.defection_count < self.game_description.n_players - 1:
            self.defection_count = 0
        return Action.C

class Strategy_EXPLOITATIVE_212(BaseStrategy):
    """
    A Tit-for-Tat strategy that encourages cooperation and punishes defection in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_opponents = np.zeros((self.game_description.n_players, 1), dtype=bool)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return self.first_round(state)
        if state.round_number == 0:
            return self.first_round(state)
        return self.subsequent_rounds(state, history)

    def first_round(self, state: GameState) -> Action:
        """
        Strategy for the initial (zeroth) round.
        """
        return Action.C

    def subsequent_rounds(self, state: GameState, history: PlayerHistory) -> Action:
        """
        Strategy for subsequent rounds.
        """
        self.last_round_opponents = history.opponent_actions[-1]
        if np.all(self.last_round_opponents):
            return Action.D
        elif np.any(self.last_round_opponents):
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_213(BaseStrategy):
    """
    Tit-for-Tat with Modified Cooperation Probability (TFTMP) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_initial = game_description.k / game_description.n_players
        self.x = int(math.ceil(game_description.n_rounds * 0.2))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.D
        total_rounds = min(state.round_number, self.game_description.n_rounds)
        observed_behavior = np.mean(history.opponent_actions[:total_rounds, :], axis=0)
        cooperation_count = np.count_nonzero(observed_behavior == 1)
        if cooperation_count == 0 or np.all(observed_behavior == 1):
            p = 1 - self.p_initial
        elif np.all(observed_behavior == 0):
            p = self.p_initial
        else:
            cooperation_proportion = cooperation_count / total_rounds
            p = self.p_initial * cooperation_proportion + (1 - self.p_initial) * (1 - cooperation_proportion)
        r = random.uniform(0, 1)
        if r <= p:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_214(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_opponent_action = None
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.first_round = False
        opponent_action = history.opponent_actions[0, :] if history is not None else None
        self.previous_opponent_action = opponent_action[-1] if opponent_action is not None else None
        if self.first_round or self.previous_opponent_action is None:
            return Action.C
        if opponent_action[-1] == Action.C:
            return Action.C
        elif self.previous_opponent_action is None or self.previous_opponent_action == Action.D:
            return Action.D
        else:
            self.previous_opponent_action = Action.C
            return Action.C

class Strategy_EXPLOITATIVE_215(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

    This strategy implements the Adaptive Tit-for-Tat strategy in an N-player public goods game. The strategy cooperates initially and adapts its cooperation based on the number of cooperators from the previous round. If more than half the players cooperated, it continues to cooperate; otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.floor((game_description.n_players - 1) / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_216(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptation (TfTA) strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_round = state.round_number == self.game_description.n_rounds
        if history is not None:
            cooperators = sum(history.opponent_actions[-1, :])
            last_action = history.opponent_actions[-1][0]
            return Action(last_action) if not self.last_round else Action.D if not cooperators else Action.C
        return Action.D

class Strategy_EXPLOITATIVE_218(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(game_description.n_players * 0.6)
        self.round_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_history.append(np.mean(history.opponent_actions[:, 1:]))
        avg_cooperation = np.mean(self.round_history[-self.game_description.n_rounds:])
        if avg_cooperation > self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_219(BaseStrategy):
    """
    A simple Tit-for-Tat strategy for the N-Player Public Goods Game.
    This strategy cooperates in the first round and retaliates defections,
    while encouraging cooperation from opponents through reciprocity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_opponent_action = None
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        last_opponent_cooperation = self.last_opponent_action == Action.C
        current_round_is_last = state.round_number >= self.game_description.n_rounds - 1
        if not last_opponent_cooperation and (not current_round_is_last):
            self.last_opponent_action = Action.D
            return Action.D
        elif last_opponent_cooperation or current_round_is_last:
            self.last_opponent_action = Action.C
            return Action.C
        self.last_opponent_action = None
        return Action.C

class Strategy_EXPLOITATIVE_220(BaseStrategy):
    """
    A strategy that adapts to the opponent's behavior in the N-Player Public Goods Game, implementing the Tit-for-Tat strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperation = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if not self.last_round_cooperation and cooperators == 0:
            self.last_round_cooperation = False
            return Action.D
        self.last_round_cooperation = cooperators >= self.game_description.n_players // 2 and self.last_round_cooperation
        if not self.last_round_cooperation:
            return Action.D
        last_round = state.round_number == self.game_description.n_rounds - 1
        penultimate_round = state.round_number == self.game_description.n_rounds - 2 and self.last_round_cooperation
        return Action.C if last_round or penultimate_round else Action.D

class Strategy_EXPLOITATIVE_221(BaseStrategy):
    """
    A strategy that emulates the Tit-for-Tat behavior with adaptive cooperation in the N-Player Public Goods Game.
    The strategy initially cooperates to encourage others, then adapts its action based on the opponent's previous rounds, and in the last round cooperates if more than half of opponents have cooperated throughout the game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._opponent_cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        my_actions = np.array(history.my_actions).flatten()
        opponent_actions = history.opponent_actions.flatten()
        last_round = len(my_actions) - 1
        self._opponent_cooperation_history.append(opponent_actions[last_round])
        cooperation_threshold = math.ceil(self.game_description.n_players / 2)
        if len(self._opponent_cooperation_history) == self.game_description.n_rounds - 1:
            self._opponent_cooperation_history.pop(0)
        num_cooperators = sum(self._opponent_cooperation_history)
        if num_cooperators >= cooperation_threshold:
            return Action.C
        elif opponent_actions[last_round] == 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_222(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_avg = 0
        self.f = 3
        self.last_round_profit = 0
        self.history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.history:
            self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if history is not None:
            self.history = history
            self.coop_avg = np.mean(self.history.my_actions[-self.f:])
        coop_threshold = self.coop_avg + random.gauss(0, 0.1)
        if state.round_number == self.game_description.n_rounds:
            self.last_round_profit = 1 - self.history.my_actions[-1] + self.game_description.k / self.game_description.n_players * np.sum(self.history.my_actions[:-1])
            if self.last_round_profit > 1 - self.history.my_actions[-1]:
                return Action.C
        return Action.C if self.history.my_actions[state.round_number - 1] >= coop_threshold else Action.D

class Strategy_EXPLOITATIVE_223(BaseStrategy):
    """
    Implementation of Tit-for-Tat-with-Adaptation (TfT-A) strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 2
        self.last_round_cooperation = True
        self.last_round_defection = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_cooperation = np.all(history.opponent_actions[-1]) if history else True
        previous_cooperation = self.last_round_cooperation
        previous_defection = self.last_round_defection
        if current_cooperation and (not previous_defection) or (not current_cooperation and previous_defection):
            return Action.C
        elif current_cooperation:
            self.p -= 1
            if self.p <= 0:
                self.p = self.game_description.n_players // 2
            return Action.D
        else:
            self.last_round_defection = current_cooperation
            self.last_round_cooperation = not current_cooperation
            return Action.C

class Strategy_EXPLOITATIVE_224(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for N-Player Public Goods Game.
    The TFTA strategy cooperates initially, adapts its actions based on opponents' collective behavior in each round,
    and aims to punish defection while rewarding cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.fraction = 1 / math.log(self.game_description.n_players + 1) if self.game_description.n_players > 2 else 0.5
        self.history = PlayerHistory(np.zeros((self.game_description.n_rounds,), dtype=bool), np.zeros((self.game_description.n_rounds,)), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        else:
            actions = self.history.opponent_actions[-1]
            cooperators = sum(actions)
            if cooperators > math.floor(self.game_description.n_players * self.fraction):
                return Action.C
            return Action.D

class Strategy_EXPLOITATIVE_225(BaseStrategy):
    """
    A Tit-for-Tat with Adaptation (TfTA) strategy player for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance_limit = self.game_description.n_rounds // 2
        self.detection_threshold = self.game_description.n_rounds // 4
        self.consecutive_cooperations = 0
        self.consecutive_defections = 0
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == 0:
            self.consecutive_cooperations = 0
            self.consecutive_defections = 0
            self.last_opponent_action = np.zeros(self.game_description.n_players, dtype=int)
        else:
            opponent_actions = history.opponent_actions[-1]
            self.consecutive_cooperations = max(self.consecutive_cooperations - 1 if opponent_actions.sum() > self.detection_threshold else self.consecutive_cooperations, 0)
            self.consecutive_defections = max(self.consecutive_defections + 1 if opponent_actions.sum() == 0 else 0, self.tolerance_limit)
            self.last_opponent_action = opponent_actions
        if history.my_actions[-1] and self.consecutive_cooperations < self.detection_threshold:
            self.consecutive_cooperations += 1
        elif not history.my_actions[-1] and self.consecutive_defections > self.tolerance_limit:
            self.consecutive_defections -= 1
        if np.all(self.last_opponent_action == history.opponent_actions[-1]):
            return Action.C if self.last_opponent_action[0] else Action.D
        elif not np.all(self.last_opponent_action == history.opponent_actions[-1]) and self.consecutive_cooperations < self.detection_threshold:
            return Action.D if self.last_opponent_action[0] else Action.C

class Strategy_EXPLOITATIVE_226(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    Strategy Description: Cooperates if majority of players cooperated in the previous round, defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.majority = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators > self.majority:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.C

class Strategy_EXPLOITATIVE_227(BaseStrategy):
    """
    A strategy called Tit-for-Tat with Cooperative Bias (TFTCB).
    This strategy cooperates in the first round, and mirrors opponents' actions while maintaining a slight bias towards cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            self.first_round = True
            action = Action.C
        elif self.first_round:
            self.first_round = False
        else:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            if opponent_cooperators > self.game_description.n_players // 2:
                action = Action.C
            elif state.round_number == self.game_description.n_rounds:
                action = Action.C
            elif history.my_actions[-1] == Action.D or opponent_cooperators <= self.game_description.n_players // 2:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_228(BaseStrategy):
    """
    An Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and self.last_opponent_action is not None:
            last_opponent_action = self.last_opponent_action
        elif history is not None:
            last_opponent_action = history.opponent_actions[-1][0]
        else:
            return Action.C
        if last_opponent_action == Action.C:
            return Action.C
        else:
            self.last_opponent_action = last_opponent_action
            return Action.D

class Strategy_EXPLOITATIVE_229(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) with Cooperative Bias (CB)
    This strategy balances cooperation and punishment while allowing for forgiveness after a single act of betrayal.
    It can adapt to a wide range of opponent behaviors, making it competitive in the specified tournament setting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_bias = 0.5

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperation = np.sum(history.opponent_actions[-1])
        opponent_defection = len(history.opponent_actions) - opponent_cooperation
        if opponent_defection > 0 and opponent_defection == len(history.opponent_actions) - 1:
            roll = random.random()
            action = Action.C if roll < self.cooperative_bias else Action.D
        elif opponent_defection > 0:
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_230(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_actions = np.zeros(game_description.n_rounds, dtype=bool)
        self.cooperators_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.my_actions[state.round_number - 1] = Action.C if history and len(history.opponent_actions) > 0 else Action.D
        cooperators = np.sum(history.opponent_actions[-1, :]) if history else 0
        self.cooperators_count += int(self.my_actions[state.round_number - 1])
        return Action.C if cooperators > (self.game_description.n_players - 1) // 2 else Action.D

class Strategy_EXPLOITATIVE_231(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Threshold Strategy
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = [(0, 0)] * game_description.n_rounds
        self.threshold = 0.25
        self.average_cooperators = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if history is not None:
            cooperation = 0
            if state.round_number > self.game_description.n_rounds // 10:
                t = self.game_description.n_rounds // 10
            else:
                t = min(self.game_description.n_rounds, state.round_number)
            self.average_cooperators[state.round_number] = np.mean(history.opponent_actions[:, :t].sum(axis=1))
            if self.average_cooperators[state.round_number] > self.threshold:
                cooperation = 1
        payoff = 1 - cooperation + self.game_description.k / self.game_description.n_players * history.opponent_actions[:, -10:].sum(axis=1).mean() if history is not None else 0
        self.history[state.round_number] = (cooperation, state.round_number)
        return Action(cooperation)

class Strategy_EXPLOITATIVE_232(BaseStrategy):
    """
    A strategy that cooperates initially and then adjusts its cooperation based on the number of previous cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = math.ceil(game_description.k / 2)
        self.history = PlayerHistory(my_actions=np.array([False]), my_payoffs=np.array([]), opponent_actions=np.array([]), opponent_payoffs=np.array([]))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            total_contributions_prev = sum(history.opponent_actions[-1])
            if total_contributions_prev > self.game_description.n_players * (self.game_description.k - 1) // 2:
                self.cooperative_threshold = math.ceil(self.game_description.k / 2)
            elif total_contributions_prev < self.game_description.n_players * (self.game_description.k - 1) // (2 * self.game_description.n_players):
                self.cooperative_threshold = math.floor((self.game_description.k - 1) / (2 * self.game_description.n_players))
            if state.round_number == self.game_description.n_rounds:
                return Action.C
            return Action.C if self.cooperative_threshold >= len(history.opponent_actions) else Action.D

class Strategy_EXPLOITATIVE_233(BaseStrategy):
    """
    A strategy that follows the Tit-for-Tat with Adaptive Cooperation (TFT-AC) game theory strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_actions = None
        self.i_previously_cooperated = False

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.my_actions = history.my_actions if hasattr(history, 'my_actions') else np.zeros(state.round_number + 1, dtype=bool)
        self.i_previously_cooperated = self.my_actions[-1]
        num_cooperators = sum(history.opponent_actions[-1])
        if self.i_previously_cooperated and num_cooperators > self.game_description.n_players // 2:
            return Action.C
        elif self.i_previously_cooperated and num_cooperators <= self.game_description.n_players // 2:
            return Action.D
        elif not self.i_previously_cooperated and num_cooperators > self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_234(BaseStrategy):
    """
    A strategy that cooperates initially and responds to other players' actions based on the history of interactions.
    It adapts cooperation based on the majority of contributions in the last round,
    and punishes defection by defecting in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.array([], dtype=bool), my_payoffs=np.array([]), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if history is not None:
            self.history = history
        action = Action.C
        if state.round_number > 1:
            total_contributions = self.history.opponent_actions[-1].sum()
            if total_contributions >= self.game_description.n_players // 2:
                action = Action.C
            else:
                actions = self.history.opponent_actions[:, -1]
                cooperators = np.count_nonzero(actions)
                if cooperators == self.game_description.n_players - 1:
                    action = Action.C
                else:
                    action = Action.D
        return action

class Strategy_EXPLOITATIVE_235(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t = math.floor(game_description.n_players / 2)
        self.strategy = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return self.strategy
        opponent_actions = history.opponent_actions[-self.t:, -1]
        cooperators = sum(opponent_actions)
        if self.strategy == Action.C and (not cooperators):
            self.strategy = Action.D
        elif self.strategy == Action.D and cooperators >= len(opponent_actions):
            self.strategy = Action.C
        return self.strategy

class Strategy_EXPLOITATIVE_236(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = math.ceil(game_description.n_players / 2)
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent_actions = history.opponent_actions[state.round_number - 1, :] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
        if np.all(opponent_actions == Action.D):
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.cooperative_threshold:
                self.consecutive_defections = self.game_description.n_players
                return Action.D
        else:
            self.consecutive_defections = 0
        if np.all(opponent_actions == Action.C):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_238(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT)
    Summary: Calculates the average number of cooperators from previous rounds and decides whether to cooperate or defect based on a threshold.
    Adjusts the threshold based on opponent's behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.6
        self.average_cooperators = np.zeros(game_description.n_rounds)
        self.cooperation_history = np.zeros(game_description.n_rounds, dtype=bool)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.cooperation_history = history.my_actions
            for i in range(state.round_number):
                self.average_cooperators[i] = np.mean(self.cooperation_history[:i + 1])
        if state.round_number < self.game_description.n_rounds - 1:
            cooperators = sum(self.cooperation_history[-self.game_description.n_rounds:])
            average = np.mean(self.average_cooperators[-self.game_description.n_rounds:])
            cooperate = average > self.threshold if state.round_number != 1 else True
        else:
            cooperators = sum(self.cooperation_history[-self.game_description.n_rounds:])
            average = np.mean(self.average_cooperators[-self.game_description.n_rounds:])
            payoff_threshold = np.sum(history.my_payoffs[:-1]) * self.threshold
            if average > self.threshold and np.sum(history.my_payoffs) >= payoff_threshold:
                cooperate = True
            else:
                cooperate = not self.cooperation_history[-1]
        return Action.C if cooperate else Action.D

class Strategy_EXPLOITATIVE_239(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF)
    This strategy cooperates initially and adapts to the opponent's behavior based on a moving average of past rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.window_size = int(math.ceil(game_description.n_rounds * 0.2))
        self.moving_average_cooperation = np.zeros(self.window_size)
        self.current_round_index = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.moving_average_cooperation = np.array([1] * self.current_round_index)
            self.current_round_index += 1
        self.current_round_index = min(self.current_round_index + 1, self.window_size)
        self.moving_average_cooperation[self.current_round_index - 1] = history.opponent_actions[-1].sum() if history else 0
        moving_average_cooperation = np.mean(self.moving_average_cooperation)
        threshold = 0.75
        return Action.C if state.round_number > self.game_description.n_rounds // 10 or moving_average_cooperation > threshold else Action.D

class Strategy_EXPLOITATIVE_240(BaseStrategy):
    """
    Adaptive and exploitative strategy for a single player in N-Player Public Goods Game.
    The goal is to maximize total payoff by cooperating selectively based on past actions of opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contributions_history = []
        self.payoff_history = []
        self.threshold = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            contributions = sum([history.opponent_actions[state.round_number - 1, :].sum()])
            if contributions >= self.threshold + math.ceil(self.game_description.n_players / 2):
                self.threshold += 1
            elif contributions <= self.threshold - math.ceil(self.game_description.n_players / 2):
                self.threshold -= 1
        if state.round_number == 0:
            return Action.C
        if sum(history.opponent_actions[-1, :]) >= self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_241(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game.
    A strategy that balances cooperation and defection, adapting to opponents' behavior while maintaining an exploitative edge.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.history.append(history)
        if len(self.history) == 1 or state.round_number == self.game_description.n_rounds:
            return Action.C
        self.last_round_cooperators = sum(history.opponent_actions[-1])
        if all([h.opponent_actions[-1][0] == Action.C for h in self.history[-2:]]):
            return Action.C
        elif any([h.opponent_actions[-1][0] == Action.D for h in self.history[-2:]]):
            return Action.D
        return self.__class__.get_action(self.last_round_cooperators, self.game_description)

    @staticmethod
    def get_action(last_round_cooperators: int, game_description: PublicGoodsDescription) -> Action:
        cooperators_threshold = math.ceil(game_description.n_players / 2)
        if last_round_cooperators >= cooperators_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_242(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = None
        self.m = int(self.game_description.n_rounds * 0.8)
        self.past_cooperation_counts = [0] * self.m

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if self.cooperation_threshold is None:
            self.cooperation_threshold = math.ceil(sum(self.past_cooperation_counts) / len(self.past_cooperation_counts))
        total_contributions = sum(history.opponent_actions[-1])
        if total_contributions >= self.cooperation_threshold:
            return Action.C
        return Action.D

    def update_history(self, history: PlayerHistory):
        self.past_cooperation_counts.pop()
        self.past_cooperation_counts.append(sum(history.my_actions))
        self.cooperation_threshold = math.ceil((sum(self.past_cooperation_counts) + self.cooperation_threshold) / (len(self.past_cooperation_counts) + 1))

class Strategy_EXPLOITATIVE_243(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 1 if random.random() < 0.5 else 2
        self.max_cooperation_threshold = game_description.n_players - 1
        self.min_cooperation_threshold = int(self.game_description.n_players / 2) - 1
        self.p = 0.25

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_cooperators = sum(history.opponent_actions[-1]) if history else 0
        current_threshold = self.cooperation_threshold
        if total_cooperators <= current_threshold:
            self.cooperation_threshold -= math.floor(self.cooperation_threshold * (1 - self.p))
            self.cooperation_threshold = max(self.min_cooperation_threshold, self.cooperation_threshold)
        elif total_cooperators >= current_threshold + 1:
            self.cooperation_threshold += 1
            self.cooperation_threshold = min(self.max_cooperation_threshold, self.cooperation_threshold)
        if total_cooperators >= current_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_244(BaseStrategy):
    """
    The Tit-for-Tat (TfTS) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_last_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.opponent_last_action:
            self.opponent_last_action = history.opponent_actions[state.round_number - 1, :].any()
        action = Action.C if self.opponent_last_action else Action.D
        self.opponent_last_action = history.opponent_actions[state.round_number - 1, :].any()
        return action

class Strategy_EXPLOITATIVE_245(BaseStrategy):
    """
    A TFTAC strategy for the N-Player Public Goods Game.
    Cooperates initially, then reciprocates opponents' contributions while allowing for a 'punishment tolerance' period.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_tolerance = math.ceil(game_description.n_rounds * 0.2)
        self.last_opponent_action = Action.D

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=np.bool_)
        self.last_opponent_action = opponent_actions[-1]
        cooperators = sum(opponent_actions)
        if cooperators >= self.game_description.n_players // 2 and self.last_opponent_action == Action.C:
            return Action.C
        elif self.last_opponent_action == Action.C:
            punishment_round = state.round_number % self.punishment_tolerance
            if punishment_round > 0:
                return Action.D
        else:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_246(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat with Progressive Adjustment (ATfT-PA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_round_cooperators = 0
        self.threshold = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            cooperate = True
        else:
            cooperate = self.previous_round_cooperators >= self.threshold
            new_threshold = max(0, math.floor((self.game_description.k - 1) * state.round_number / self.game_description.n_players))
            self.threshold = new_threshold
            self.previous_round_cooperators = history.my_actions[-1] if cooperate else 0
        action = Action.C if cooperate else Action.D
        return action

class Strategy_EXPLOITATIVE_247(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defected_before = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else self.game_description.n_players
        last_round_action = Action.D if self.defected_before and cooperators > 0 else Action.C if cooperators == self.game_description.n_players else Action.D
        self.defected_before = last_round_action == Action.D
        return last_round_action

class Strategy_EXPLOITATIVE_248(BaseStrategy):
    """
    A Tit-for-Tat with Adaptation strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.counter = 0
        self.last_3_opponents = np.zeros(game_description.n_players, dtype=int)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            action = Action.C
        elif len(history.opponent_actions) < self.game_description.n_rounds:
            action = Action.D
        else:
            last_3_cooperators = np.sum(history.opponent_actions[-3:], axis=0)
            if np.all(last_3_cooperators == 0):
                self.counter += 1
                if self.counter > self.game_description.n_players // 2:
                    action = Action.C
            else:
                self.counter = np.where(last_3_cooperators > 0, 0, self.counter)
                self.counter += np.where(last_3_cooperators[1:] - last_3_cooperators[:-1] < 0, 1, 0)
            self.last_3_opponents = history.opponent_actions[-4:-1]
        return action

class Strategy_EXPLOITATIVE_249(BaseStrategy):
    """
    A strategy based on Tit-for-Tat with Adaptive Cooperation (TFT-AC) for the N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            last_round = state.round_number == self.game_description.n_rounds - 1
            self.last_round = last_round
            cooperators = np.sum(history.opponent_actions[-1, :])
            if cooperators >= self.threshold:
                return Action.C
            return Action.D
        cooperators = random.choices([0, self.game_description.n_players - 1], weights=[0.5, 0.5])[0]
        if cooperators >= self.threshold:
            return Action.C
        return Action.D

    def adapt_to_last_round(self) -> None:
        """
        Adapt the strategy for the last round if necessary
        """
        if self.last_round and random.random() > 0.5:
            cooperators = np.sum(self.history.opponent_actions[-1, :])
            if cooperators < self.threshold:
                return Action.D

class Strategy_EXPLOITATIVE_250(BaseStrategy):
    """
    A simple Tit-for-Tat-Plus (TfTP) strategy for the N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.is_last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds or self.is_last_round:
            return Action.D
        else:
            last_action = history.opponent_actions[-1, 0] if history is not None else False
            self.is_last_round = state.round_number == self.game_description.n_rounds
            return Action.C if last_action else Action.D

class Strategy_EXPLOITATIVE_252(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(game_description.k * game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            total_contributions = 0
        else:
            total_contributions = sum(history.opponent_actions[state.round_number - 1])
        action = Action.D if total_contributions < self.cooperation_threshold else Action.C
        if state.round_number < self.game_description.n_rounds:
            new_threshold = self.cooperation_threshold + (Action.C == action) - (total_contributions == 0)
            self.cooperation_threshold = max(new_threshold, 0) if total_contributions > self.cooperation_threshold else min(self.cooperation_threshold + 1, self.game_description.k * self.game_description.n_players)
        return action

class Strategy_EXPLOITATIVE_253(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = 3
        self.threshold = game_description.n_players // 4
        self.first_encounter = True
        self.opponent_response = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.first_encounter and history is not None:
            self.opponent_response = history.opponent_actions[state.round_number - 1, 0]
            if self.opponent_response is None:
                return Action.C
            elif self.opponent_response == Action.C:
                self.first_encounter = False
            else:
                self.threshold = self.threshold // 2
        cooperators = np.sum(history.opponent_actions[-self.m:, :].flatten()) / self.m
        if state.round_number == self.game_description.n_rounds or (state.round_number < self.game_description.n_rounds - 1 and self.first_encounter):
            return Action.D
        return Action.C if cooperators >= self.threshold else Action.D

class Strategy_EXPLOITATIVE_254(BaseStrategy):
    """
    A Gradual Cooperation strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.3
        self.increment_factor = 0.01
        self.increment_rounds = math.ceil(game_description.n_rounds / 5)
        self.last_round = False

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.D
        cooperators = sum(history.opponent_actions[-1])
        cooperation_rate = cooperators / state.round_number if state.round_number > 0 else 0
        if cooperation_rate < self.threshold or (self.last_round and cooperation_rate == 0):
            return Action.D
        elif cooperation_rate >= self.threshold:
            self.threshold += self.increment_factor if state.round_number % self.increment_rounds == 0 else 0
            return Action.C
        self.last_round = state.round_number == self.game_description.n_rounds
        return Action.D if self.last_round and cooperation_rate == 0 else Action.C

class Strategy_EXPLOITATIVE_255(BaseStrategy):
    """
    Grindstone Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = 10
        self.t = game_description.n_players * 0.5 + 0.1
        self.epsilon = 0.05

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.t -= self.epsilon
            return Action.C if random.random() < self.t else Action.D
        if history is not None:
            avg_coop_rate = np.mean(history.my_actions[-self.m:])
            if avg_coop_rate > self.t:
                return Action.C
            return Action.D

    def update_parameters(self, current_round_payoff: float):
        """
        Adjusts m and t based on the current round payoff to optimize strategy performance.
        """
        if self.game_description.n_rounds - current_round_payoff >= 5:
            self.m = int(math.sqrt((self.game_description.n_rounds - current_round_payoff) / 2)) + 10
            if self.m > self.game_description.n_players:
                self.m = self.game_description.n_players
            cooperators = sum(history.opponent_actions[-self.m:])
            avg_coop_rate = cooperators / self.m
            self.t = avg_coop_rate * 1.3 + self.epsilon

class Strategy_EXPLOITATIVE_256(BaseStrategy):
    """Tit-for-Tat with Variable Contribution (TFT-VC)"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contributions_threshold = math.ceil(game_description.n_players / 2)
        self.last_cooperation = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        cooperation_in_last_round = self.last_cooperation
        self.last_cooperation = cooperators >= self.contributions_threshold
        contribution = Action.C if cooperation_in_last_round and state.round_number != self.game_description.n_rounds else Action.D
        return contribution

class Strategy_EXPLOITATIVE_257(BaseStrategy):
    """
    Strategy: Tit-for-Tat with Adaptive Generosity (TfT-AG)
    A cooperative strategy that encourages cooperation among opponents but punishes non-cooperative behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.h = math.ceil(self.game_description.n_rounds / 2)
        self.p = math.ceil(self.game_description.n_rounds / 4)

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 or len(self.history) == 0:
            return Action.C
        self.history += [history]
        self.history = self.history[-self.h:] if len(self.history) > self.h else self.history
        avg_coop = np.mean([x[-1]['my_actions'] for x in self.history])
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        elif avg_coop < (self.game_description.n_players - 1) / 2:
            return Action.D
        elif avg_coop > (self.game_description.n_players + 1) / 2:
            return Action.C
        else:
            return self.history[-1]['opponent_actions'][-1]
        if len(self.history) > self.p:
            non_cooperative = np.sum([x['my_actions'] for x in self.history[-self.p:] if np.all(x['my_actions'] == [False])])
            if non_cooperative >= self.p:
                return TFT_AG(self.game_description)
        return self.history[-1]['opponent_actions'][-1]

class Strategy_EXPLOITATIVE_258(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.s = int(math.ceil(game_description.n_players * 0.1))
        self.T = game_description.k / (self.s + 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.T > 1 / self.game_description.n_players else Action.D
        if history is not None and history.my_actions is not None:
            cooperators = sum(history.my_actions[-self.s:])
            avg_coop_rate = cooperators / self.s
            return Action.C if avg_coop_rate > self.T else Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_259(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperation threshold for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = 5
        self.ct = None
        self.contributions_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number + self.m - 1) % self.game_description.n_players == 0:
            return Action.C
        if self.ct is None or len(self.contributions_history) < self.m:
            self.calculate_cooperation_threshold(history)
        cooperators = history.opponent_actions[state.round_number - 1, :].sum()
        if cooperators >= self.ct:
            return Action.C
        return Action.D

    def calculate_cooperation_threshold(self, history):
        total_contributions = np.sum(history.my_actions[-self.m:])
        self.ct = total_contributions / self.m * self.game_description.n_players if total_contributions != 0 else self.ct or 0
        self.contributions_history.append(total_contributions)

class Strategy_EXPLOITATIVE_260(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Generosity (TfT-AG) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.threshold = math.ceil(self.n_players / 2)
        self.last_round = game_description.n_rounds - 1

    def __call__(self, state: GameState, history: PlayerHistory):
        action = Action.D
        if state.round_number == 0 or (state.round_number > 0 and (not history)):
            action = Action.C
        elif state.round_number < self.last_round:
            cooperators = sum(history.opponent_actions[state.round_number - 1, :])
            if cooperators == self.n_players:
                action = Action.C
            elif cooperators < self.threshold:
                action = Action.D
            else:
                action = Action.C
        elif state.round_number == self.last_round:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_261(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.a = int(math.ceil(game_description.n_rounds * 0.5))
        self.b = int(math.ceil(game_description.n_rounds * 0.1))
        self.k_base = self.k
        self.history = PlayerHistory(np.zeros((self.a,), dtype=bool), np.zeros(self.a), np.zeros((self.game_description.n_rounds, self.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        self.current_round = -1

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if self.current_round == -1:
            return Action.C
        self.current_round += 1
        self.history.my_actions[min(self.current_round, self.a - 1)] = self.history.my_payoffs[-1] > 0
        if self.current_round >= self.b:
            self.k = self.k_base
        total_cooperators = np.sum(history.opponent_actions[min(self.current_round - self.a + 1, self.game_description.n_rounds - 1), :])
        if total_cooperators >= self.n_players // 2:
            self.k *= 1.1
        else:
            self.k = self.k_base
        if history.opponent_actions[self.current_round - 1, 0] == (history.my_payoffs[-2] > 0):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_262(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)
    A player uses a Tit-for-Tat strategy in a Public Goods Game while also adapting the contribution factor (k) based on the number of contributors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.adaptive_threshold = int(game_description.n_players * 3 * game_description.n_rounds // 4)
        self.k_base = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            cooperators = 0
        else:
            cooperators = sum(history.opponent_actions[-1])
        if cooperators == self.game_description.n_players:
            return Action.C
        contribution = int(self.k_base)
        if cooperators < self.game_description.n_players and state.round_number > self.adaptive_threshold:
            self.k_base += 1
            if self.k_base > self.game_description.n_players:
                self.k_base = self.game_definition.n_players
        return Action(int(contribution) == 1)

class Strategy_EXPLOITATIVE_263(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Generosity (TfTA-G) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.aggressiveness = int(self.game_description.n_players / 3)
        self.last_round_cooperators = 0
        self.randomize_first_move = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            self.randomize_first_move = True
            action = Action.C if random.random() < 0.5 else Action.D
        elif history is None or len(history.opponent_actions) < state.round_number:
            self.last_round_cooperators = 0
            self.randomize_first_move = False
            action = Action.C
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators > self.aggressiveness and (not self.randomize_first_move):
                action = Action.C
            elif cooperators < self.aggressiveness:
                action = Action.D
            self.last_round_cooperators = cooperators
        return action

class Strategy_EXPLOITATIVE_264(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_counter = 0
        self.last_opponent_action = '?'

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            self.cooperation_counter = max(1, self.cooperation_counter + (1 if history.opponent_actions[-1][-1] == Action.D else 0))
            self.last_opponent_action = history.opponent_actions[-1][-1] if len(history.opponent_actions) > 0 else '?'
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if self.last_opponent_action == Action.D:
            action = Action.D if self.cooperation_counter < state.round_number else Action.C
        elif self.last_opponent_action == Action.C:
            action = Action.C
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_265(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        coop_count = np.sum(history.opponent_actions[-1])
        if coop_count >= self.n_players // 2:
            return Action.C
        return Action.D

    def last_round(self, history: PlayerHistory) -> Action:
        coop_count = np.sum(history.opponent_actions[-1])
        if coop_count >= self.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_266(BaseStrategy):
    """
    The Tit-for-Tat Adaptive Cooperation (TFTAC) strategy is designed to encourage cooperation while punishing defection and rewarding collaboration.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_strategy = Action.C
        self.longest_defection_streaks = {}
        self.opponent_history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.my_strategy = Action.C
            return self.my_strategy
        if history is not None:
            self.opponent_history = history
        if state.round_number == self.game_description.n_rounds - 1:
            self.my_strategy = Action.C
        if self.opponent_history is not None and self.longest_defection_streaks:
            current_round = self.game_description.n_rounds - 1 if state.round_number == self.game_description.n_rounds - 1 else state.round_number
            current_opponent_history = self.opponent_history[current_round]
            most_frequent_collaborator = np.argmax(current_opponent_history.my_actions)
            collaborations_by_player = np.sum(current_opponent_history.my_actions, axis=0)
            if collaborations_by_player[most_frequent_collaborator] > (self.game_description.n_rounds - 1) // 2:
                self.my_strategy = Action.C
            elif most_frequent_collaborator in self.longest_defection_streaks:
                defection_length = self.longest_defection_streaks[most_frequent_collaborator]
                for _ in range(defection_length):
                    if current_round - defection_length < 0:
                        break
                    previous_opponent_history = self.opponent_history[current_round - defection_length]
                    if previous_opponent_history.my_actions[-1, most_frequent_collaborator]:
                        self.my_strategy = Action.D
            else:
                opponents = np.where(~current_opponent_history.my_actions)[0]
                for opponent in opponents:
                    opponent_history = self.opponent_history[state.round_number, opponent]
                    if not opponent_history and opponent != self.__class__.name:
                        streak = self._calculate_defection_streak(opponent_history)
                        if streak > 0:
                            self.longest_defection_streaks[opponent] = streak
                if len(self.longest_defection_streaks) > 0:
                    self.my_strategy = Action.D
                else:
                    self.my_strategy = Action.C
        return self.my_strategy

    def _calculate_defection_streak(self, opponent_history) -> int:
        defection_streak = 0
        for i in range(len(opponent_history.my_actions)):
            if not opponent_history.my_actions[i]:
                defection_streak += 1
            else:
                defection_streak = 0
        return defection_streak

class Strategy_EXPLOITATIVE_267(BaseStrategy):
    """
    Adaptive Free Rider strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n, self.r, self.k = (self.game_description.n_players, self.game_description.n_rounds, self.game_description.k)
        self.threshold, self.decay_factor = (self.n * (self.r - 1) / self.n, 0.95)
        self.total_cooperators_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return np.random.choice([Action.C, Action.D], p=[0.5, 0.5])
        if state.round_number == self.r:
            return Action.D
        current_cooperators = sum(history.opponent_actions[-1, :])
        if current_cooperators < self.threshold:
            self.threshold *= self.decay_factor
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_268(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TfTAC) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.num_players = game_description.n_players
        self.last_round = game_description.n_rounds - 1
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        self.current_round = state.round_number
        actions = history.opponent_actions[self.current_round - 1]
        total_contributors = np.sum(actions)
        if self.current_round == self.last_round:
            return Action.C
        if np.all(actions):
            return Action.C
        elif total_contributors > self.num_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_269(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Time-Decay (TTFTD) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperation = np.zeros(self.game_description.n_rounds)
        self.total_contributions = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_action = np.where(history.my_actions == Action.C, 1, 0)
        self.total_contributions[state.round_number - 1] += np.sum(my_action)
        if np.count_nonzero(my_action) > 0:
            self.average_cooperation = self._update_average_cooperation(state, my_action)
            if np.mean(self.average_cooperation) > 0.5:
                return Action.C if np.where(my_action == 1)[0].size > 0 else Action.D
            else:
                return Action.C if np.where(my_action == 0)[0].size > 0 else Action.D
        else:
            average_cooperation = self._update_average_cooperation(state, my_action)
            return Action.C if np.mean(average_cooperation) >= 0.5 else Action.D

    def _update_average_cooperation(self, state: GameState, my_actions: NDArray[np.bool_]) -> NDArray[np.float64]:
        contributions = np.sum(my_actions)
        self.total_contributions[state.round_number] += contributions
        if state.round_number < self.game_description.n_rounds:
            self.average_cooperation[state.round_number] = (self.total_contributions[state.round_number] + contributions) / (state.round_number + 1)
        return self.average_cooperation

class Strategy_EXPLOITATIVE_270(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold Strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.ct_initial = 1
        self.ct_increment = 0.1
        self.ct_decrement = 2
        self.cooperation_threshold = self.ct_initial
        self.opponent_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        cooperators = sum(opponent_actions)
        if cooperators > self.cooperation_threshold:
            return Action.C
        elif np.sum(opponent_actions) > self.cooperation_threshold:
            self.opponent_defections += 1
            self.cooperation_threshold -= self.ct_decrement if self.opponent_defections >= self.game_description.n_players // 2 else self.ct_increment
        else:
            self.opponent_defections = 0
            if state.round_number != self.game_description.n_rounds - 1 or np.sum(opponent_actions) > 0:
                self.cooperation_threshold += self.ct_increment
        return Action.D if self.cooperation_threshold <= 0 else Action.C

class Strategy_EXPLOITATIVE_271(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.endowment = game_description.n_players // 2
        self.contribution_level = None
        self.total_contributions = 0
        self.average_contributions = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.contribution_level = self.endowment // 2
            self.total_contributions += self.contribution_level
            return Action.C
        self.average_contributions = self.total_contributions / state.round_number if state.round_number > 0 else 0
        self.total_contributions += self.contribution_level
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators >= self.average_contributions:
            self.contribution_level = self.contribution_level
        else:
            self.contribution_level += self.endowment / self.game_description.n_rounds
        payoff = 1 - self.contribution_level + self.game_description.k / self.game_description.n_players * self.total_contributions
        return Action.C if self.contribution_level == int(self.endowment / 2) else Action.D

class Strategy_EXPLOITATIVE_272(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT)
    Strategy Description: This strategy cooperates in the first round and thereafter, it cooperates if its opponent cooperated in the previous round. Otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if history:
            self.first_round = False
            last_opponent_action = history.opponent_actions[-1, -1]
            if last_opponent_action == Action.C:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_274(BaseStrategy):
    """
    Strategy that follows Tit-for-Tat with Adaptation (TfTA) in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_history = np.zeros(game_description.n_rounds, dtype=int)
        self.t = 0
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.round_number > 0 and history is not None:
            self.current_round = state.round_number - 1
            opp_cooperation = np.mean(history.opponent_actions[:, self.my_history[-1]][-self.t:])
            if opp_cooperation > 0.5 and self.my_history[-1] == 1:
                self.my_history[self.current_round] = 0
                self.t += 1
            elif opp_cooperation <= 0.5 and self.my_history[-1] == 0:
                self.my_history[self.current_round] = 1
                self.t = 0
            else:
                self.my_history[self.current_round] = int(self.my_history[-1])
        return Action(self.my_history[state.round_number])

class Strategy_EXPLOITATIVE_275(BaseStrategy):
    """
    A strategy that cooperates initially and adapts its cooperation threshold based on the average number of cooperators in recent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = self.game_description.k // 2
        self.average_cooperators = [0] * self.game_description.n_rounds
        self.cooperator_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if len(history.opponent_actions) < self.game_description.n_rounds:
            return Action.D
        current_round = len(history.opponent_actions) - 1
        num_players = self.game_description.n_players
        if num_players % 2 == 1 and current_round >= self.game_description.n_rounds // 2:
            self.cooperator_count += np.sum(history.opponent_actions[current_round, 1:])
        else:
            self.cooperator_count += np.sum(history.opponent_actions[current_round])
        self.average_cooperators[current_round] = self.cooperator_count / num_players
        self.cooperator_count = 0
        if current_round < self.game_description.n_rounds - 1:
            return Action(self.average_cooperators[current_round] > self.cooperation_threshold)
        average_cooperators = np.mean(self.average_cooperators)
        return Action(average_cooperators > self.cooperation_threshold)

class Strategy_EXPLOITATIVE_276(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.even_n = game_description.n_players % 2 == 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        total_cooperators = np.sum(history.opponent_actions[-self.game_description.n_rounds:, :].flatten())
        if total_cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D
        if state.round_number > 1 and total_cooperators == self.game_description.n_players // 2:
            return Action.not_[self.__class__]

class Strategy_EXPLOITATIVE_277(BaseStrategy):
    """
    Tit-for-Tat Plus (TftT+) strategy for N-Player Public Goods Game.
    Cooperates in first round and subsequent rounds based on observed cooperation from opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        current_contributions = np.array([int(action) for action in history.opponent_actions[-1, :].tolist()])
        num_cooperators = max(0, self.n_players - 1 if np.sum(current_contributions) == self.n_players else np.sum(current_contributions))
        return Action.C if num_cooperators >= self.n_players - 1 else Action.D

class Strategy_EXPLOITATIVE_279(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat with Gradual Cooperation (ATTC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.g = self.game_description.n_players - 1
        self.T = 0.6

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.D
        cooperators = np.sum(history.opponent_actions[-1])
        CR = cooperators / (self.game_description.n_players - 1) if self.g > 0 else 0
        g = max(0, self.g - 1) if CR < self.T else min(self.game_description.n_players - 1, self.g)
        player_i_cooperates = CR > self.T or state.round_number < g + 1
        return Action.C if player_i_cooperates else Action.D

class Strategy_EXPLOITATIVE_280(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(math.floor(game_description.n_players * 0.6))
        self.previous_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number < self.game_description.n_rounds - 1:
            current_cooperators = sum(history.opponent_actions[-1, :])
            if current_cooperators >= self.cooperation_threshold:
                return Action.C
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if self.cooperation_threshold > self.game_description.n_players:
                return Action.D
            return Action.C
        if current_cooperators > self.previous_cooperators:
            self.cooperation_threshold += math.floor(math.sqrt(self.game_description.n_players))
        else:
            self.cooperation_threshold -= math.floor(math.sqrt(self.game_description.n_players))
        self.previous_cooperators = current_cooperators
        return Action.C if current_cooperators >= self.cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_281(BaseStrategy):
    """
    A strategy that mimics the Tit-for-Tat with Adaptation (TfTA) in N-Player Public Goods Game.
    Initially cooperates to foster a potential cooperative environment, but defects immediately upon encountering defection from opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        self.last_cooperators = cooperators
        return Action(self.last_cooperators >= self.game_description.n_players - 1)

class Strategy_EXPLOITATIVE_282(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT) Strategy
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_counter = 0
        self.threshold = math.floor(game_description.n_players / 2) + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if cooperators >= self.threshold and state.round_number != self.game_description.n_rounds - 1:
            self.cooperation_counter += 1
            return Action.C
        elif self.cooperation_counter > self.threshold:
            return Action.C
        self.cooperation_counter = 0 if history is not None and cooperators < self.threshold else self.cooperation_counter
        return Action.D

class Strategy_EXPLOITATIVE_284(BaseStrategy):
    """
    A simple Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for the N-player Public Goods Game.
    This strategy initially cooperates in the first round and then decides to cooperate or defect based on the opponent's actions from the previous round.
    If the opponent cooperated in the last round, the TFTA strategy also cooperates. If the opponent defected in the last round, the TFTA strategy defects as well.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == 0:
            self._history = np.zeros((self.game_description.n_players,), dtype=np.bool_)
        if self._history is None:
            self._history = history.opponent_actions.copy()
        lastAction = self._history[-1]
        return Action.C if np.all(lastAction) else Action.D

class Strategy_EXPLOITATIVE_285(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperation Rate (TFTAC) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.alpha = 0.1
        self.cr_threshold = 0.5
        self.total_contributions = np.zeros(self.r, dtype=np.int64)
        self.total_payoff = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history is not None:
            total_contributions = sum(history.my_actions)
            if state.round_number < self.r - 1:
                cooperation_rate = 1 - self.k / (self.n * self.r) + self.alpha * (total_contributions / self.n)
                action = Action.C if cooperation_rate > self.cr_threshold else Action.D
            else:
                total_payoff_this_round = history.my_payoffs[-1]
                self.total_payoff += total_payoff_this_round
                cooperation_rate = 1 - self.k / (self.n * self.r) + self.alpha * (self.total_payoff / self.r)
                action = Action.C if cooperation_rate > self.cr_threshold else Action.D
        return action

class Strategy_EXPLOITATIVE_286(BaseStrategy):
    """
    Tit-for-Tat with Adaptation strategy for N-Player Public Goods Game.
    This strategy cooperates initially to demonstrate goodwill, and adapts its actions based on opponents' previous moves.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number - 1] = [Action.C] if self.history.opponent_actions[state.round_number - 2].sum() > 0 else [Action.D]
        cooperators = sum(self.history.opponent_actions[state.round_number - 1])
        if cooperators >= self.game_description.n_players // 2 and self.history.my_actions[state.round_number - 1][0]:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_287(BaseStrategy):
    """
    Tit-for-Tat (TFT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_history.append(np.array([action for action in history.opponent_actions[-1]]))
        if len(self.opponent_history) > 1:
            last_round = self.opponent_history[-2]
            cooperators = np.count_nonzero(last_round)
            if cooperators >= len(last_round) // 2:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_289(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_opponent_action = None
        self.punishment_duration = int(math.ceil(self.game_description.n_players / 2))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or self.last_round_opponent_action is None:
            return Action.C
        opponent_cooperated = np.any(history.opponent_actions[-1])
        last_opponent_action = history.opponent_actions[-2][0] if self.last_round_opponent_action is None else self.last_round_opponent_action
        if opponent_cooperated:
            action = Action.C
        elif last_opponent_action == Action.D:
            self.last_round_opponent_action = Action.D
            if state.round_number < self.punishment_duration:
                action = Action.D
            else:
                self.last_round_opponent_action = None
                action = Action.C
        else:
            action = Action.C
            self.last_round_opponent_action = last_opponent_action
        return action

class Strategy_EXPLOITATIVE_290(BaseStrategy):
    """
    A Tit-for-Tat-Adaptive strategy player in an N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.escalation_period = math.ceil(game_description.n_players / 2)
        self.strategy = Action.C
        self.history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not self.history:
            return self.strategy
        opponent_actions = history.opponent_actions[-1]
        opponent_cooperators = sum(opponent_actions)
        if opponent_cooperators == len(opponent_actions):
            self.strategy = Action.C
        else:
            self.strategy = Action.D if self.history and all([action == Action.D for action in opponent_actions]) else Action.C
            if self.history and self.escalation_period < math.ceil((state.round_number - self.history[-1]['round']) / 2):
                self.escalation_period = min(self.game_description.n_players, self.escalation_period * 2)
        self.history.append({'round': state.round_number, 'strategy': self.strategy})
        return self.strategy

class Strategy_EXPLOITATIVE_291(BaseStrategy):
    """
    A strategy that follows Tit-for-Tat with a cooperative bias in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round = 0
        self.opponent_history = None
        self.last_opponent_action = Action.D

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and self.round > 0:
            self.opponent_history = history.opponent_actions
            self.last_opponent_action = self.opponent_history[-1][-1]
        if state.round_number == 0 or self.opponent_history is None:
            return Action.C
        if self.last_opponent_action == Action.C:
            return Action.C
        probability = 1 / (self.round + 1)
        if random.random() < probability:
            return Action.C
        else:
            return Action.D
        self.round += 1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_293(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive contribution for the N-Player Public Goods Game.
    Cooperates initially to signal good intentions, and adopts a Tit-for-Tat approach with an
    adaptive contribution level based on previous rounds' actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_contrib = np.zeros(game_description.n_rounds)
        self.opponents_cooperated_sum = 0
        self.opponent_actions = {}

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        contribution = 1
        opponents_cooperated = sum(history.opponent_actions[state.round_number - 1])
        self.opponents_cooperated_sum += opponents_cooperated
        if state.round_number < self.game_description.n_rounds:
            self.average_contrib[state.round_number] = self.opponents_cooperated_sum / (state.round_number + 1)
            if history.my_actions[state.round_number - 1] == Action.C:
                contribution = 1
            else:
                punishment = self.game_description.k * self.average_contrib[state.round_number - 1]
                contribution += punishment
            self.opponent_actions[self.__class__, state.round_number] = history.opponent_actions[state.round_number - 1]
        elif history.my_actions[state.round_number - 1] == Action.C:
            contribution = 1
        else:
            contribution = self.game_description.k * np.mean(history.opponent_payoffs[state.round_number - 1][self.opponent_actions[self.__class__, state.round_number - 1]])
        return Action.C if history.my_actions[state.round_number - 1] == Action.C and contribution <= 1 else Action.D

class Strategy_EXPLOITATIVE_294(BaseStrategy):
    """
    Tit-for-Tat with Cooperative Adjustment (TFT-CA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.n_players * 0.6)
        self.average_cooperation_rate = np.zeros(self.game_description.n_rounds + 1)
        self.cooperation_frequency = random.random()

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        action = Action.D
        cooperators = sum(history.opponent_actions[-1] if history is not None else [0])
        if cooperators > 0 and history is not None:
            average_cooperation_rate = np.mean(history.my_actions[-self.game_description.n_rounds:])
            self.average_cooperation_rate[state.round_number] = average_cooperation_rate
            if average_cooperation_rate >= self.threshold:
                self.cooperation_frequency *= 0.95
            elif average_cooperation_rate < self.threshold:
                self.cooperation_frequency *= 1.05
            action = Action(int(self.cooperation_frequency > random.random()))
        return action

class Strategy_EXPLOITATIVE_296(BaseStrategy):
    """
    Tit-for-Tat strategy for the N-player Public Goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_length = game_description.n_rounds
        self.average_cooperators = np.zeros(self.history_length)
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.last_round_cooperators = sum(history.opponent_actions[-1, :])
        self.average_cooperators[self.history_length - 1] = self.last_round_cooperators / self.game_description.n_players
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        average_cooperators = np.mean(self.average_cooperators)
        return Action.C if average_cooperators > 0.5 else Action.D

class Strategy_EXPLOITATIVE_297(BaseStrategy):
    """
    A strategy that follows the Tit-for-Tat with Adaptive Cooperation Threshold approach.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_n_threshold = int(game_description.n_players / 2)
        self.final_n_threshold = self.initial_n_threshold + (game_description.n_rounds - 1) * int(self.initial_n_threshold / game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            cooperators = np.sum(history.opponent_actions[-1])
            n_threshold = self.update_n_threshold(state.round_number, self.initial_n_threshold, self.final_n_threshold)
            return Action.C if cooperators >= n_threshold else Action.D
        else:
            return Action.D

    def update_n_threshold(self, r: int, initial_n_threshold: int, final_n_threshold: int) -> int:
        if r == 1:
            return initial_n_threshold
        elif r == self.game_description.n_rounds - 1:
            return final_n_threshold
        else:
            n_percent = (self.game_description.n_rounds - r) / (self.game_description.n_rounds - 1)
            return initial_n_threshold + (final_n_threshold - initial_n_threshold) * n_percent

class Strategy_EXPLOITATIVE_298(BaseStrategy):
    """
    Implementation of the Tit-for-Tat Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defect_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            total_contributions = sum(history.opponent_actions[state.round_number - 1])
            self.defect_count += total_contributions < self.game_description.n_players
            return Action.C if total_contributions == self.game_description.n_players else Action.D
        return NotImplementedError('History should not be None in __call__')

class Strategy_EXPLOITATIVE_299(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_ct = game_description.n_players // 2
        self.decay_rate = 0.95
        self.cooperation_threshold = self.initial_ct * self.decay_rate ** (self.game_description.n_rounds - 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.cooperation_threshold = self.initial_ct
        else:
            self.cooperation_threshold *= self.decay_rate
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if cooperators >= int(self.cooperation_threshold):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_300(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0
        self.num_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.num_cooperators += np.sum(history.my_actions[-1])
            current_round = state.round_number
            self.cooperation_threshold = math.floor(self.game_description.n_players * 0.5) + (self.game_description.n_rounds - current_round) * (history.my_payoffs[-1] / self.num_cooperators)
        return Action.C if self.num_cooperators >= self.cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_301(BaseStrategy):
    """
    A simple Tit-for-Tat (TFT) strategy that cooperates with others when they cooperate, and defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) < self.game_description.n_rounds):
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if all(history.opponent_actions[len(history.opponent_actions) - 2, :] == [b for b in history.opponent_actions[-1, :]]) or cooperators >= self.game_description.n_players - 1:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_302(BaseStrategy):
    """
    A Tit-for-Tat with Variable Contribution (TFTVC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.f = self.game_description.k / self.game_description.n_players
        self.g = self.f * 0.75
        self.h = 1 - self.game_description.n_rounds ** (-1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            opponent_cooperated = np.any(history.opponent_actions[state.round_number - 1])
            if opponent_cooperated and state.round_number < self.game_description.n_rounds * self.h:
                return Action.C
            elif not opponent_cooperated and state.round_number >= self.game_description.n_rounds * self.h:
                return Action.D
            else:
                return Action.C if random.random() > 0.25 else Action.D

class Strategy_EXPLOITATIVE_303(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_history = history.opponent_actions
        opponent_cooperators = np.count_nonzero(self.opponent_history[-1])
        opponent_defected = len(self.opponent_history) > 1 and self.opponent_history[-2][-1] == Action.D
        if state.round_number == self.game_description.n_rounds or opponent_defected:
            return Action.D
        if opponent_cooperators >= int(self.game_description.n_players / 2):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_304(BaseStrategy):
    """
    TFT-ACF Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_window = int(math.ceil(game_description.n_rounds * 0.3))
        self.threshold = 0.5
        self.average_cooperation = np.zeros(self.cooperation_window)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.my_actions) < self.cooperation_window:
            return Action.D
        my_action = history.my_actions[-1]
        total_cooperators = sum(history.opponent_actions[-1, :])
        average_cooperation = np.mean(history.my_actions[-self.cooperation_window:])
        if state.round_number == self.game_description.n_rounds - 1:
            if total_cooperators >= math.ceil(self.game_description.n_players * (1 - self.threshold)):
                return Action.C
            else:
                return Action.D
        if total_cooperators > average_cooperation:
            return Action.C
        elif my_action and math.ceil(total_cooperators / len(history.opponent_actions)) >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_305(BaseStrategy):
    """
    A Tit-for-Tat Strategy in N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_action = np.mean(history.opponent_actions[:, -1])
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        if state.round_number == history.opponent_actions.shape[0]:
            return Action.D
        for i in range(history.opponent_actions.shape[0]):
            if self.last_action[i] == 1 and history.opponent_actions[-1, i] == 0:
                if state.round_number >= history.opponent_actions.shape[0] - 2:
                    self.last_action[i] = 0
        return Action(self.last_action.astype(int))

class Strategy_EXPLOITATIVE_306(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    Strategy description: Cooperates initially. After that, the strategy will mimic the opponent's previous action. If the opponent cooperated in the last round, also cooperate; else defect. For the exploitative version, switch to defecting if the opponent has ever defected before.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.has_ever_defected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history is not None and len(history.opponent_actions) > 0:
            last_opponent_action = history.opponent_actions[-1, 0]
            if self.has_ever_defected or last_opponent_action == Action.D:
                action = Action.D
            else:
                action = Action.C
        if last_opponent_action == Action.D:
            self.has_ever_defected = True
        return action

class Strategy_EXPLOITATIVE_307(BaseStrategy):
    """
    Exploitative Public Goods Game strategy that leans towards exploitation by maximizing individual payoffs while considering game dynamics and opponents' behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(math.ceil(game_description.n_rounds * 0.75))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.D, Action.C])
        if history is not None:
            total_contributions = sum(history.my_actions[-self.m:])
            average_cooperators = total_contributions / self.m
            action = Action.D
            if total_contributions <= average_cooperators:
                pass
            else:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_308(BaseStrategy):
    """
    A simple yet effective exploitative strategy that aims for reciprocity while being cautious against exploitation in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round = 0
        self.history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history
        self.round += 1
        if self.round < self.game_description.n_rounds:
            opponent_actions = history.opponent_actions[-self.round:, :]
            last_opponent_action = opponent_actions[-1, :].mean()
            return Action(int(last_opponent_action))
        opponent_history = history.opponent_actions[0:-self.round + 1, :]
        if all((action == Action.C for action in opponent_history[:, -1])) or (len(opponent_history) > 1 and opponent_history[-2, -1] == Action.D):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_309(BaseStrategy):
    """
    A strategy that cooperates initially and adjusts contributions based on opponents' behavior, with a tit-for-tat approach and adaptive contribution levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.7
        self.adjustment_period = int(self.game_description.n_players * 2)
        self.opponent_history = []

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.opponent_history.append(history.opponent_actions[-1]) if history else None
        if len(self.opponent_history) < state.round_number + 1:
            return Action.C
        average_contribution = np.mean(self.opponent_history[-self.adjustment_period:-1])
        if average_contribution > self.threshold or average_contribution < 1 - self.threshold:
            contribution_adjustment_period = min(state.round_number, self.adjustment_period)
            return Action((1 - average_contribution) * self.opponent_history[state.round_number - contribution_adjustment_period][-1])
        return self.opponent_history[-1][-1]

class Strategy_EXPLOITATIVE_310(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_opponent_action = None
            return Action.C
        if history is None or history.opponent_actions.shape[0] == 0:
            self.last_opponent_action = None
        else:
            self.last_opponent_action = np.mean(history.opponent_actions[-1])
        return Action(int(self.last_opponent_action)) if self.last_opponent_action is not None else Action.D

class Strategy_EXPLOITATIVE_312(BaseStrategy):
    """
    A Tit-for-Tat-Plus strategy for N-Player Public Goods Game. This strategy initiates cooperation, then adjusts actions based on the number of cooperators in previous rounds and a short-term memory of an opponent's behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.strategy = []
        self.threshold = int(game_description.n_players * 0.6)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None and len(history.opponent_actions) > self.game_description.n_players // 2:
            cooperation_rate = np.mean(history.opponent_actions[-self.game_description.n_players // 2:, -1])
            memory = history.opponent_actions[-self.game_description.n_players // 2:, -1]
            if cooperation_rate > self.threshold or len([i for i in memory if i == True]) > len(memory) // 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_314(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = 0.6
        self.opponent_last_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.opponent_last_action = np.mean(history.opponent_actions[-1])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action(int(self.opponent_last_action)) if self.opponent_last_action is not None else Action.C
        probability_to_cooperate = 1 - self.alpha ** state.round_number if self.opponent_last_action == 1 else self.alpha ** state.round_number
        return Action(int(probability_to_cooperate > random.random())) if history is not None else Action.C

class Strategy_EXPLOITATIVE_315(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.learning_patience_rounds = int(self.game_description.n_players * 2)
        self.average_cooperation = 0
        self.max_contributions = self.game_description.n_players
        self.minimum_cooperators = math.ceil(self.learning_patience_rounds * self.game_description.n_players / 2)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        self.average_cooperation = np.mean(history.my_payoffs[:state.round_number])
        if state.round_number >= self.learning_patience_rounds:
            if opponent_cooperators < self.minimum_cooperators:
                return Action.D
        total_contributions = sum(history.my_actions[:state.round_number])
        cooperate_probability = min(1, (total_contributions - self.average_cooperation) / (self.max_contributions - self.minimum_cooperators))
        if opponent_cooperators:
            return Action.C if random.random() < cooperate_probability else Action.D
        return Action.D

class Strategy_EXPLOITATIVE_316(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_round_cooperators = sum(history.opponent_actions[-1])
        proportion_cooperators = self.last_round_cooperators / self.game_description.n_players if self.last_round_cooperators > 0 else 0.5
        return Action.C if proportion_cooperators >= 0.5 and (not any(history.opponent_actions[-1])) else Action.D

class Strategy_EXPLOITATIVE_317(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    Strategy Summary: ATFT cooperates by default but will retaliate when necessary to deter opponents from exploitation. The strategy aims to punish defection and foster stable cooperation for mutual benefits.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if self.last_opponent_action is None:
            self.last_opponent_action = history.opponent_actions[state.round_number - 1, state.round_number % len(history.opponent_actions)]
        else:
            last_cooperators = sum(history.opponent_actions[-1])
            if self.last_opponent_action == Action.C and last_cooperators >= self.game_description.n_players // 2:
                return Action.C
        self.last_opponent_action = history.opponent_actions[state.round_number - 1, state.round_number % len(history.opponent_actions)]
        return Action(self.last_opponent_action == Action.C)

class Strategy_EXPLOITATIVE_318(BaseStrategy):
    """
    A strategy that mimics the cooperative spirit in the first round, then cooperates or defects based on opponent's behavior in previous rounds.
    In the last round, it evaluates its payoff over the game and chooses an action that maximizes its total reward.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_reward_cooperation = 0.0
        self.total_reward_defection = 0.0
        self.last_round_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history is not None and history.opponent_actions[-1, 0] is not None:
            self.last_round_opponent_action = history.opponent_actions[-1, 0]
            if self.last_round_opponent_action == Action.C:
                action = Action.C
            elif self.last_round_opponent_action == Action.D:
                action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if self.calculate_total_reward_cooperation(self.total_reward_cooperation) > self.calculate_total_reward_defection(self.total_reward_defection):
                action = Action.C
            else:
                action = Action.D
        if history is not None:
            if state.round_number > 0 and self.last_round_opponent_action is not None:
                payoff = self.calculate_payoff(self.game_description, self.last_round_opponent_action)
                if action == Action.C:
                    self.total_reward_cooperation += payoff
                else:
                    self.total_reward_defection += payoff
        return action

    def calculate_payoff(self, game_description: PublicGoodsDescription, last_round_opponent_action: bool) -> float:
        k = game_description.k
        n = game_description.n_players
        if last_round_opponent_action:
            return 1 + k / n * len([i for i in range(n) if i != 0 and last_round_opponent_action])
        else:
            return 1

    def calculate_total_reward_cooperation(self, total_reward: float) -> float:
        return total_reward

    def calculate_total_reward_defection(self, total_reward: float) -> float:
        return total_reward

class Strategy_EXPLOITATIVE_319(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.forgiveness_period = math.ceil(game_description.n_players / 2)
        self.history = np.zeros((game_description.n_rounds,), dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        self.history = np.roll(self.history, -1)
        cooperators = np.sum(self.history[-1])
        current_cooperators = history.opponent_actions[state.round_number - 1].sum()
        if cooperators == 0 and current_cooperators > 0:
            return Action.D
        elif current_cooperators >= self.n_players // 2 and self.history[-1][-1] == Action.C:
            return Action.C
        elif current_cooperators > 0 and state.round_number - np.count_nonzero(self.history == Action.C) >= self.forgiveness_period:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_321(BaseStrategy):
    """
    Tit-for-Tat-Adaptive Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []
        self.consecutive_cooperation_count = 0
        self.consecutive_defection_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_history) == 0:
            return Action.C
        current_action = history.opponent_actions[-1, -1]
        self.opponent_history.append(current_action)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if current_action:
            if len(self.opponent_history) >= 2 and self.consecutive_cooperation_count >= 2:
                self.consecutive_defection_count = 0
                return Action.C
            else:
                self.consecutive_cooperation_count += 1
        elif len(self.opponent_history) >= 2 and self.consecutive_defection_count >= 2:
            self.consecutive_cooperation_count = 0
            return Action.D
        else:
            self.consecutive_defection_count += 1
        return current_action

class Strategy_EXPLOITATIVE_322(BaseStrategy):
    """
    A strategy that implements the Tit-for-Tat-Plus (TfT+) approach in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = 0.95
        self.theta = math.ceil(game_description.n_players / 2)
        self.delta = math.ceil(game_description.n_players / 4)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        total_rounds = history.opponent_actions.shape[0]
        if total_rounds == 0:
            return Action.D
        last_cooperation = (history.opponent_actions[:, -1] * self.alpha ** (total_rounds - 1)).sum()
        if cooperators >= self.game_description.n_players and last_cooperation < self.theta:
            return Action.C
        elif total_rounds - state.round_number >= self.delta:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_323(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.past_rounds = int(self.game_description.n_rounds * 0.8)
        self.threshold = self.game_description.n_players // 2
        self.min_contribution = 1 / self.game_description.k
        self.max_contribution = 1

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.my_actions is None:
            return Action.D
        average_cooperators = np.mean(history.my_actions[-self.past_rounds:])
        if average_cooperators >= self.threshold:
            contribution = 1
        elif average_cooperators < self.threshold and (not any((a == Action.C for a in history.my_actions))):
            round_number = state.round_number + 1
            punishment = self.max_contribution if round_number <= math.ceil(self.game_description.n_rounds / 2) else self.min_contribution
            contribution = 1 - punishment
        else:
            contribution = 1
        return Action(int(contribution))

class Strategy_EXPLOITATIVE_324(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Cooperative Favor (TFT-CF)
    A strategy that mimics cooperative behavior while showing a willingness to reciprocate and forgive.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_counter = 0
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.cooperative_counter = max(0, self.cooperative_counter - 1)
        self.last_opponent_action = np.mean(history.opponent_actions[-1])
        if history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        opponent_defected = (cooperators < self.game_description.n_players) & (self.last_opponent_action == 0)
        if opponent_defected:
            return Action.D
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            if self.last_opponent_action == 1 and self.cooperative_counter < self.game_description.n_players:
                self.cooperative_counter += 1
            return Action.D

class Strategy_EXPLOITATIVE_325(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Cooperation Threshold for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = self.game_description.k

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.opponent_actions) == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if self.k / 2 <= cooperators < (self.k + 1) / 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_326(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) strategy.
    Cooperates initially as a friendly gesture to encourage cooperation, then adapts its cooperative threshold based on other players' actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = int(game_description.n_players * 0.5)
        self.round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None and self.round < self.game_description.n_rounds - 1:
            total_cooperators = sum(history.opponent_actions[-1, :])
            if total_cooperators >= self.cooperative_threshold:
                return Action.C
            else:
                return Action.D
        elif history is not None and self.round == self.game_description.n_rounds - 1:
            return Action.D
        self.round += 1
        if total_cooperators < self.cooperative_threshold:
            self.cooperative_threshold -= 1
        elif total_cooperators > self.cooperative_threshold:
            self.cooperative_threshold += 1
        return Action.C if self.cooperative_threshold >= self.game_description.n_players // 2 else Action.D

class Strategy_EXPLOITATIVE_327(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TTFT-C)
    A strategy that cooperates in the first round and subsequently adapts its decision to cooperate or defect based on the percentage of previous cooperators in the game's history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = 0.5
        self.total_contributions = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            total_rounds = self.game_description.n_rounds
            cooperators = np.sum(history.opponent_actions[-total_rounds:, :].flatten())
            cooperative_rate = cooperators / total_rounds if total_rounds > 0 else 0
            return Action(int(cooperative_rate > self.cooperative_threshold))
        return None

    def set_cooperative_threshold(self, cooperative_threshold: float):
        """
        Set the cooperative threshold for this strategy instance.
        """
        if 1 < cooperative_threshold < self.game_description.n_players:
            self.cooperative_threshold = cooperative_threshold

class Strategy_EXPLOITATIVE_328(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for the N-Player Public Goods Game.
    The TFTAC strategy cooperates initially, then mimics opponents' actions while punishing free riders and exploiting cooperative opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None:
            self.opponent_history = []
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        cooperators = sum(opponent_actions)
        if cooperators == self.game_description.n_players:
            return Action.C
        self.opponent_history.append(opponent_actions)
        if 0 < cooperators:
            return Action.C
        return Action.D

    def adjust_strategy(self):
        """
        Adjusts the strategy based on the collected opponent history.
        This method is called periodically during the game.
        """
        free_riders = len([opponent_actions for opponent_actions in self.opponent_history if sum(opponent_actions) == 0])
        if free_riders > self.game_description.n_players // 2:
            self.opponent_history = [opponent_actions for opponent_actions, cooperators in enumerate(reversed(self.opponent_history)) if sum(opponent_actions) > 0]
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_EXPLOITATIVE_329(BaseStrategy):
    """
    Tit-for-Tat-Adaptive (TfT-A) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperators = 0.0
        self.round_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None:
            self.round_count = min(state.round_number + 1, self.game_description.n_rounds)
            cooperators = np.sum(history.opponent_actions[:, :self.round_count - 1].flatten())
            self.average_cooperators = cooperators / (self.round_count - 1) if self.round_count > 1 else 0.0
            if np.sum(history.opponent_actions[:, -1]) > self.average_cooperators:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_330(BaseStrategy):
    """
    The TFT-CA strategy follows a reciprocal relationship with cooperative opponents while punishing defection. It initially cooperates to promote trust and cooperation among players, then defects if all opponents did not cooperate in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        cooperative = cooperators >= self.game_description.n_players // 2
        if state.round_number == self.game_description.n_rounds - 1 and (not self.last_round):
            self.last_round = True
            return Action.D
        elif cooperative:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_331(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    The strategy alternates between cooperation and defection based on opponent behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.last_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and self.last_round != state.round_number - 1):
            self.last_opponent_action = np.mean(history.opponent_actions[-1]) if history is not None else None
            return Action.C
        elif self.last_round < state.round_number - 1:
            self.last_round += 1
        if self.last_opponent_action is None:
            return Action.C
        opponent_cooperated = np.mean(history.opponent_actions[-1]) == self.last_opponent_action
        last_round_cooperators = sum(history.opponent_actions[-2]) if history is not None and self.last_round > 0 else 0
        if opponent_cooperated:
            return Action.C
        elif last_round_cooperators < self.game_description.n_players - 1:
            return Action.D
        else:
            self.last_opponent_action = not self.last_opponent_action
            return Action.C

class Strategy_EXPLOITATIVE_332(BaseStrategy):
    """
    A Tit-for-Tat with Variable Cooperative Ratio (TFTVR) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k_prime = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self._update_k_prime(history)
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators >= math.ceil(self.game_description.n_players * (self.k_prime / 2)):
            return Action.C
        return Action.D

    def _update_k_prime(self, history: PlayerHistory):
        if self.k_prime is None:
            self.k_prime = self.game_description.k / self.game_description.n_players

class Strategy_EXPLOITATIVE_333(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy player in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[-1])
        if self.last_opponent_action == 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_334(BaseStrategy):
    """
    Tit-for-Tat with Gradient Adjustment (TfT-GA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) == 0):
            return Action.C
        self.history.my_actions[state.round_number - 1] = True
        if history is None:
            cooperators = 0
            for i in range(self.game_description.n_players):
                if self.history.opponent_actions[:, i][-1]:
                    cooperators += 1
            total_contributions = len(self.history.opponent_actions) * (self.game_description.k / self.game_description.n_players)
            payoff = 1 - self.history.my_payoffs[-1] + total_contributions * cooperators
        else:
            last_player_action = history.opponent_actions[:, -1][-1]
            cooperators = sum(history.opponent_actions[-1, :])
            total_contributions = len(self.history.opponent_actions) * (self.game_description.k / self.game_description.n_players)
            payoff = 1 - history.my_payoffs[-1] + total_contributions * cooperators if last_player_action else 0
        if state.round_number < self.game_description.n_rounds:
            action = Action.C if payoff > 0 else Action.D
        elif last_player_action and payoff == 0:
            action = Action.D
        else:
            action = Action.C
        self.history.my_payoffs[state.round_number - 1] = payoff
        return action

class Strategy_EXPLOITATIVE_335(BaseStrategy):
    """
    A strategy that reciprocates opponent actions while adapting to changing conditions in the N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = min(int(game_description.n_players / 2), game_description.n_rounds // 10)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-self.m:]) / self.m if history is not None else 0
        my_action = Action.C if cooperators > np.mean(cooperators) else Action.D
        return my_action

class Strategy_EXPLOITATIVE_336(BaseStrategy):
    """
    Tit-for-Tat Cooperation Strategy (TFTC) for N-Player Public Goods Game.
    This strategy cooperates initially for the first 'a' number of rounds, then follows a strict tit-for-tat approach thereafter.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_cooperation_rounds = int(game_description.n_rounds * 0.1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number <= self.initial_cooperation_rounds:
            return Action.C
        last_round = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=np.bool_)
        my_action = Action.C if np.all(last_round) else Action.D
        return my_action

class Strategy_EXPLOITATIVE_337(BaseStrategy):
    """
    A strategy that encourages cooperation unless provoked by non-cooperation from other players, following the Tit-for-Tat adaptive approach.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.endowment = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1] if history else [False] * self.game_description.n_players)
        majority_cooperated = cooperators >= self.game_description.n_players // 2
        return Action.C if majority_cooperated else Action.D

class Strategy_EXPLOITATIVE_338(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    This strategy cooperates in the first round and follows a tit-for-tat approach, adjusting its cooperation based on opponents' average cooperation rate over a window of h rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.h = int(math.ceil(game_description.n_players / 10))
        self.average_cooperation = np.zeros(self.h)
        self.cooperation_threshold = 0.6
        self.last_action = Action.C
        self.streak_length = 0
        self.punishment_duration = self.h

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None and self.streak_length > 0 and (state.round_number < self.game_description.n_rounds - 1):
            self.streak_length -= 1
            self.last_action = Action.D
        if history is not None:
            self.update_average_cooperation(history)
            cooperation_rate = np.mean(self.average_cooperation)
            if cooperation_rate > self.cooperation_threshold:
                return Action.C
        return self.last_action

    def update_average_cooperation(self, history: PlayerHistory):
        self.streak_length = max(0, self.streak_length + 1) if history.my_actions[-1] == self.last_action else 0
        index = (self.streak_length - 1) % self.h
        self.average_cooperation[index] = history.my_actions[-1]

class Strategy_EXPLOITATIVE_339(BaseStrategy):
    """
    The Adaptive Tit-for-Tat (ATFT) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not self.opponent_actions_history:
            return Action.C
        last_round_action = self.opponent_actions_history[-1] if self.opponent_actions_history else None
        cooperate = last_round_action['cooperate'] if last_round_action is not None else False
        self.opponent_actions_history.append(history.opponent_actions[-1])
        return {'cooperate': cooperate}

class Strategy_EXPLOITATIVE_340(BaseStrategy):
    """
    A simple strategy that reciprocates cooperation and adapts its behavior based on the opponent's actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = np.zeros((1, self.game_description.n_rounds), dtype=bool)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_history = np.roll(self.opponent_history, -1, axis=0)
        if np.all(self.opponent_history[-1]):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_341(BaseStrategy):
    """
    A strategy that cooperates initially and reciprocates cooperation or defection in subsequent rounds,
    with an adaptive contribution level based on a decay factor d.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.k = self.game_description.k
        self.d = 1 - 1 / self.n
        self.contribution_level = 1.0 / self.n

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.contribution_level = 1.0
        elif not history or state.round_number >= len(history.opponent_actions):
            self.contribution_level = self.contribution_level / max(self.contribution_level, self.d)
        else:
            cooperators = sum(history.opponent_actions[-1])
            if cooperators == self.n or (cooperators > 0 and self.contribution_level < 1):
                self.contribution_level = 1.0
            elif cooperators == 0:
                self.contribution_level *= self.d
                self.contribution_level = max(self.contribution_level, self.n ** (-1))
        return Action.C if self.contribution_level == 1.0 else Action.D

class Strategy_EXPLOITATIVE_342(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Contribution (TFT-AC) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_move = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return self.first_move
        cooperators = np.count_nonzero(history.opponent_actions[-1])
        total_players = len(history.opponent_actions[0])
        if np.all(history.opponent_actions) == Action.C:
            return Action.C
        elif np.all(history.opponent_actions) == Action.D:
            return Action.D
        elif cooperators < total_players // 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_344(BaseStrategy):
    """
    Tit-for-Tat-Plus (TfT+) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = 0.5
        self.last_round_cooperators = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_round_cooperators is None:
            self.last_round_cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        current_round_cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        n_players = self.game_description.n_players
        if all([action == Action.C for action in history.opponent_actions[-1, :]] if history is not None else True):
            return Action.C
        elif current_round_cooperators >= n_players - self.alpha * n_players and self.last_round_cooperators == current_round_cooperators:
            return Action.C
        elif current_round_cooperators < n_players - self.alpha * n_players:
            return Action.D
        else:
            return Action.D

    def update(self, state: GameState, payoffs: PlayerHistory) -> None:
        """
        Update strategy's internal variables with the given payoffs data.
        """
        self.last_round_cooperators = sum(payoffs.opponent_actions[-1, :])

class Strategy_EXPLOITATIVE_345(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Contribution strategy for the N-Player Public Goods Game.
    This strategy cooperates or defects based on previous actions of other players, while adjusting its contribution level based on the average number of contributors in recent rounds (r_avg).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.r_avg = np.mean([1 for _ in range(min(game_description.n_rounds, 100))])

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_previous_action = history.my_actions[-1] if len(history.my_actions) > 0 else None
        opponent_cooperators_in_last_round = sum(history.opponent_actions[-1, :])
        r_avg = np.mean([1 for _ in range(min(state.round_number, self.game_description.n_rounds))])
        if r_avg < self.game_description.n_players * 0.5:
            self.k *= 0.95
        elif r_avg > self.game_description.n_players * 0.8:
            self.k *= 1.05
        if my_previous_action is None or (my_previous_action and opponent_cooperators_in_last_round >= len(history.opponent_actions[0]) // 2):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_346(BaseStrategy):
    """
    The Tit For Tat strategy for N-player Public Goods Game.
    A Tit-for-Tat player cooperates on the first round and thereafter copies the action of a majority (> 50%) of players in the previous round.
    If no majority is found, it defects in subsequent rounds. In the last round, the strategy always cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) == 0):
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number < self.game_description.n_rounds:
            if cooperators >= (self.game_description.n_players + 1) // 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_347(BaseStrategy):
    """
    Strategy that mimics the Tit-for-Tat with Variance (TFTV) in N-Player Public Goods Game.
    This strategy cooperates when the majority of players are contributing but defects when there is a lack of contribution,
    while introducing some variance to avoid always matching opponent's behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.1

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.opponent_actions) == 0:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1])
        if total_contributions == self.game_description.n_players or total_contributions == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            deviate = random.random() < self.p
            return Action.C if not deviate else Action.D
        return Action.D

class Strategy_EXPLOITATIVE_348(BaseStrategy):
    """
    Tit-for-Tat with Cooperation Threshold (TFTC) Strategy
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = (game_description.k - 1) / game_description.n_players + 0.5
        self.average_contribution = None
        self.round_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.update_average_contribution(history)
        if state.round_number == len(self.round_history):
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.threshold and self.average_contribution is not None:
                return Action.C
            return Action.D
        self.record_history(history)
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators < self.threshold and self.average_contribution is not None:
            return Action.D
        return Action.C

    def update_average_contribution(self, history: PlayerHistory):
        total_cooperators = sum([sum(history.opponent_actions[round_, :]) for round_ in range(len(self.round_history), len(self.round_history) - 2, -1)])
        self.average_contribution = total_cooperators / (len(self.round_history) - 3)

    def record_history(self, history: PlayerHistory):
        if len(self.round_history) < self.game_description.n_rounds:
            self.round_history.append((history.my_actions[-1], history.opponent_actions[-1, :]))

class Strategy_EXPLOITATIVE_349(BaseStrategy):
    """A tit-for-tat exploitative strategy for the N-Player Public Goods Game."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_round_cooperators = 0
        self.total_previous_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.total_previous_round_cooperators += self.previous_round_cooperators
        self.previous_round_cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        avg_coop = self.total_previous_round_cooperators / (state.round_number - 1) if state.round_number > 1 else 0
        bias = 0.5 if avg_coop == self.game_description.n_players // self.game_description.k else 0
        return Action.C if avg_coop > self.game_description.n_players // self.game_description.k or random.random() > bias else Action.D

class Strategy_EXPLOITATIVE_350(BaseStrategy):
    """
    Free Rider with Adaptive Tit-for-Tat (FRTFT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t_init = int(math.ceil(game_description.n_rounds * 0.2))
        self.cooperation_threshold = game_description.n_players // 3
        self.cooperation_switch = int(math.ceil(game_description.n_rounds * 0.5))
        self.past_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            action = Action.D
        elif state.round_number < self.t_init:
            pass
        else:
            total_cooperators = sum(history.my_actions[-self.t_init:]) if history is not None else 0
            cooperation_rate = total_cooperators / self.t_init if self.t_init > 0 else 0
            if cooperation_rate > self.cooperation_threshold:
                action = Action.C
            elif history is not None and self.past_cooperators > self.cooperation_switch:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_351(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptation (TFTA)
    A cooperative strategy that adapts its behavior based on the opponent's previous actions.
    Initially, TFTA starts by cooperating in the first round to foster a cooperative environment.
    In subsequent rounds, it adapts its behavior as follows:
        - If the opponent has cooperated in the previous round, TFTA will also cooperate in the current round, promoting cooperation.
        - If the opponent has defected in the previous round, TFTA will also defect in the current round, punishing defection.
    In the last round, TFTA will analyze its total payoff up until that point and make a decision whether to cooperate or defect based on whether it has benefited more from cooperation or defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_payoff = np.zeros(game_description.n_rounds)
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[:, -1])
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and self.total_payoff[-1] > self.total_payoff.mean():
            return Action.C if np.mean(history.my_payoffs[-1]) > 1 - self.last_opponent_action + self.game_description.k / self.game_description.n_players * np.sum(history.opponent_actions[-1, :]) else Action.D
        return Action.C if self.last_opponent_action == 1 else Action.D

class Strategy_EXPLOITATIVE_352(BaseStrategy):
    """
    Tit-for-Tat with Variable Tit-for-Tat (TFTV) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.last_round_coop_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == 0:
            self.history = []
        if len(self.history) > 0:
            self.last_round_coop_count = sum(history.opponent_actions[-1, :])
        if state.round_number == 1 or (state.round_number > 1 and len(self.history) >= 2):
            if self.last_round_coop_count > self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_353(BaseStrategy):
    """
    A strategy that cooperates in the first round and adapts to opponents' strategies by mimicking their most common action in subsequent rounds.
    It aims for a balance between cooperation and exploitation, promoting reciprocity while responding dynamically to observed opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent = state.round_number % self.game_description.n_players
        opponent_history = self.opponent_history.get(opponent, None)
        if not opponent_history or len(opponent_history) == 0:
            return Action.C
        most_common_action = np.argmax(np.bincount(opponent_history))
        return Action(most_common_action) if most_common_action > len(opponent_history) // 2 else Action.D

class Strategy_EXPLOITATIVE_354(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfTA-C)

    This strategy cooperates if more than half of players cooperator in the previous round.
    If less than or equal to half of players cooperated, it defects. In the first round, it randomly chooses between cooperating and defecting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.random_choice = random.choice

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return self.random_choice([Action.C, Action.D])
        cooperators = sum(history.opponent_actions[-1] if history else [0])
        if cooperators > self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_356(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-Evolution (TfT-E)
    A cooperative strategy that fosters cooperation by punishing defection while incentivizing opponents to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1]) if history else 0
        self.last_cooperators = cooperators
        return Action(self.last_cooperators >= (self.game_description.n_players + 1) // 2)

class Strategy_EXPLOITATIVE_357(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_threshold = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else self.punishment_threshold
        if cooperators > self.punishment_threshold:
            return Action.C
        elif all([action == Action.D for action in history.opponent_actions[-1, :]]):
            punishment_round = state.round_number + 1
            return Action.D if punishment_round < len(history.opponent_payoffs) else Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_358(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_length = game_description.n_players * game_description.n_rounds
        self.forgiveness_factor = 0.5
        self.average_contributions = np.zeros(self.history_length)

    def __call__(self, state: GameState, history: PlayerHistory):
        if history is None and state.round_number == 0:
            return Action.C
        self._update_history(history)
        average = self._calculate_average_contributions()
        if state.round_number == 1 or average < self.forgiveness_factor:
            return Action.D
        return Action.C

    def _update_history(self, history):
        if len(self.average_contributions) < self.history_length:
            self.average_contributions[-1] = np.mean(history.opponent_actions[:, -1])

    def _calculate_average_contributions(self):
        return np.mean(self.average_contributions[self.history_length - self.game_description.n_rounds:])

class Strategy_EXPLOITATIVE_359(BaseStrategy):
    """
    A strategy inspired by Tit-for-Tat with an adaptive cooperation threshold.
    It encourages cooperation initially and maintains it if the average percentage of cooperation exceeds a certain threshold.
    Else, it punishes non-cooperators to deter defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((game_description.n_rounds, 1), dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.cooperation_threshold = self.game_description.n_players // 3

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_percentage = np.mean(history.my_actions[:state.round_number])
        cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        if state.round_number == self.game_description.n_rounds - 1:
            average_cooperation = np.mean(history.my_actions)
            if cooperation_percentage > average_cooperation and cooperators >= self.cooperation_threshold:
                return Action.C
        elif cooperation_percentage > self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_360(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) with Cooperative Probability Adjustment (CPA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cmin, self.cmax = (0.2, 1.0)
        self.coop_prob = self.cmin
        self.n_rounds_with_cooperation = 0
        self.n_rounds_of_defection = 0
        self.delta_c = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = np.array([history.opponent_actions[i] for i in range(state.round_number - 1, -1, -1)])
        last_opponent_action = opponent_actions[-1]
        if np.all(last_opponent_action == Action.C):
            self.n_rounds_with_cooperation += 1
            self.coop_prob = min(self.coop_prob + self.delta_c, self.cmax)
        elif np.all(last_opponent_action == Action.D):
            self.n_rounds_of_defection += 1
            self.coop_prob = max(self.coop_prob - self.delta_c, self.cmin)
        cooperate_threshold = math.floor((self.game_description.n_players + 1) / 2)
        if np.sum(opponent_actions[-1]) < cooperate_threshold:
            return Action.C if random.random() > self.coop_prob else Action.D
        return Action.C

class Strategy_EXPLOITATIVE_361(BaseStrategy):
    """
    A Tit-for-Tat Exploitative (TFT-E) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_history = [action for action in history.opponent_actions[-1]]
        cooperation_status = self.opponent_history[-1] and self.opponent_history or (not self.opponent_history[-1] and (not self.opponent_history[:-1]))
        if cooperation_status:
            return Action.C
        else:
            return Action.D

    def update_history(self, history: PlayerHistory):
        self.opponent_history = [action for action in history.opponent_actions[-1]]

class Strategy_EXPLOITATIVE_364(BaseStrategy):
    """
    Tit-for-Tat with Gradual Cooperation Strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.escalation_factor = 1.05

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_action = history.my_actions[last_round]
        last_contributions = sum(history.opponent_actions[last_round])
        k = self.escalation_factor ** math.ceil((state.round_number - 1) / (self.game_description.n_rounds / 2))
        if last_action and last_contributions >= self.game_description.n_players // 2:
            return Action.C
        elif not last_action and last_contributions >= self.game_description.n_players // 3:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_365(BaseStrategy):
    """
    Tit-for-Tat-Adaptive Strategy (TfT-A) for N-Player Public Goods Game

    Follows a tit-for-tat approach, with an added element of adaptability to encourage cooperation when opponents show signs of reciprocity and exploit them when they behave selfishly.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.x = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if opponent_cooperators > 0:
            return Action.C if state.round_number != self.game_description.n_rounds - 1 else Action.C if opponent_cooperators == self.game_description.n_players - 1 else Action.D
        if state.round_number >= self.x and history is not None:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_366(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = math.ceil(game_description.n_players / 2)
        self.current_ct = self.cooperative_threshold

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        num_cooperators = sum(opponent_actions)
        if num_cooperators >= self.current_ct:
            self.current_ct += 1
        elif opponent_actions[-1] == Action.D and self.current_ct > 1:
            self.current_ct -= 1
        return Action.C if self.current_ct <= num_cooperators else Action.D

class Strategy_EXPLOITATIVE_368(BaseStrategy):
    """
    Implementation of the Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players * (1 - 1 / game_description.k))
        self.round_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        if state.round_number == len(self.round_history):
            self.threshold = max(int((self.game_description.n_players - 1) * (self.game_description.k / self.game_description.n_players)), 0)
        cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        if history and cooperators >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_370(BaseStrategy):
    """
    A strategy that cooperates initially and follows a simple logic based on previous actions of opponents,
    promoting cooperation when beneficial but also retaliating against defection to deter others from taking advantage.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_period = math.ceil(game_description.n_players / 2)
        self.cooperation_rate = game_description.k - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None:
            history = PlayerHistory(my_actions=np.array([[Action.C]], dtype=bool), my_payoffs=np.array([], dtype=float), opponent_actions=np.zeros((1, self.game_description.n_players), dtype=bool), opponent_payoffs=np.array([]))
        cooperation_counter = sum(history.opponent_actions[-1])
        defection_counter = len(history.opponent_actions) - cooperation_counter
        if defection_counter >= self.forgiveness_period:
            self.cooperation_rate *= 0.95
        random_chance = state.round_number / self.game_description.n_rounds * self.cooperation_rate
        if random.random() > random_chance:
            return Action.D
        if cooperation_counter > defection_counter:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_371(BaseStrategy):
    """
    Tit-for-Tat-K (TfT-K) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions_prev = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.total_contributions_prev[state.round_number - 1] = np.sum(history.my_actions[-1])
        current_contributions = np.sum(history.my_actions[-1])
        if self.total_contributions_prev[-1] == self.game_description.n_players and current_contributions == self.game_description.n_players:
            return Action.C
        elif current_contributions < self.game_description.n_players:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_372(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-Evolution (TfTE)
    A simple strategy that cooperates in the first round and imitates opponents' previous actions in subsequent rounds.
    Includes a forgiveness mechanism and trust level to encourage cooperation while retaliating against defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_period = math.ceil(game_description.n_players / 2)
        self.trust_level = 1.0
        self.increase_factor = 0.1
        self.decrease_factor = 0.1
        self.threshold = 0.5
        self.action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            self.trust_level = 1.0
            self.action = Action.C
        else:
            if history.opponent_actions[-1][0] != self.action:
                self.trust_level += self.increase_factor if self.action == Action.C else self.decrease_factor
                self.trust_level = max(min(self.trust_level, 1), 0)
            elif state.round_number >= self.game_description.n_rounds - self.forgiveness_period:
                self.trust_level = 1.0
            self.action = Action.C if self.trust_level > self.threshold else Action.D
        return self.action

class Strategy_EXPLOITATIVE_373(BaseStrategy):
    """
    Implementation of Tit-for-Tat Adaptive strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        if self.last_round_action is None:
            self.last_round_action = history.opponent_actions[-1][-1]
        cooperators = sum(history.opponent_actions[-1, :])
        if self.last_round_action and cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif self.last_round_action and (not cooperators):
            return Action.D
        else:
            self.last_round_action = history.opponent_actions[-1][-1]
        return Action.D

class Strategy_EXPLOITATIVE_374(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    Cooperates in the first round, then cooperates if opponent cooperated last round; otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_last_round_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_last_round_action = np.mean(history.opponent_actions[-1]) if history else None
        opponent_cooperated = self.opponent_last_round_action == 1 if self.opponent_last_round_action else False
        return Action(opponent_cooperated)

class Strategy_EXPLOITATIVE_375(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperation threshold (TFT-ACT).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.average_coop = 0
        self.cooperate_count = 0
        self.defect_count = 0
        self.t = min(self.game_description.n_players - 1, self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            if state.round_number > self.t:
                cooperators = np.mean(history.opponent_actions[:, -self.t:])
                self.average_coop = (self.average_coop * (state.round_number - self.t - 1) + cooperators) / state.round_number
            else:
                self.average_coop = np.mean(history.opponent_actions[:, :state.round_number])
            if self.average_coop >= self.cooperation_threshold:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_376(BaseStrategy):
    """Tit-for-Tat with Adaptive Contribution (TFTAC) for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = 1 / game_description.n_players
        self.contribution = 0
        self.last_payoff = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            cooperators = sum(history.opponent_actions[-1])
            total_players = len(history.opponent_actions[0])
            if cooperators == total_players:
                self.contribution = 1
            elif cooperators < total_players // 2:
                self.contribution *= 1 - self.alpha
            elif cooperators > total_players // 2:
                self.contribution *= 1 + self.alpha
            payoff = 1 - self.contribution + self.game_description.k / self.game_description.n_players * cooperators
            if payoff > self.last_payoff:
                self.contribution += 0.01
            self.last_payoff = payoff
        return Action.C if self.contribution >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_378(BaseStrategy):
    """
    Tit-for-Tat with Variation strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = np.zeros((1, self.game_description.n_players), dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1, -1]
        my_action = self.opponent_history[-1, -1]
        last_two_actions = [my_action, opponent_action] if len(self.opponent_history) > 1 else [Action.C, opponent_action]
        if np.all(last_two_actions == Action.C):
            return Action.C
        elif my_action and (not opponent_action) or (not my_action and opponent_action):
            return Action.D
        else:
            return Action.C

    def update_opponent_history(self, opponent_action: bool):
        self.opponent_history = np.vstack((self.opponent_history, np.array([[opponent_action]])))

class Strategy_EXPLOITATIVE_379(BaseStrategy):
    """
    Implementation of the Tit-for-Tat-Plus strategy for N-Player Public Goods Game.
    This exploitative strategy cooperates if the total number of cooperators in the previous round is greater than or equal to a predefined threshold, and defects otherwise.
    The p-threshold dynamically adjusts based on the average number of cooperators over recent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = math.ceil(game_description.n_players / 2)
        self.r_avg = None
        self.rounds_for_average = min(game_description.n_rounds, 5)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() > 0.5 else Action.D
        elif self.r_avg is None:
            cooperators = sum(history.opponent_actions[:self.rounds_for_average, :].flatten())
            self.r_avg = cooperators / self.rounds_for_average
        else:
            recent_cooperators = sum(history.opponent_actions[-self.rounds_for_average:, :].flatten())
            self.p = math.ceil((recent_cooperators / self.rounds_for_average + self.r_avg) * 2)
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.p:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_380(BaseStrategy):
    """
    Tit-for-Tat-with-Adaptation (TfTA) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_last_action = np.sum(history.opponent_actions[-1]) > 0
        self.consecutive_defections = 0 if opponent_last_action else self.consecutive_defections + 1
        cooperate = opponent_last_action
        if self.consecutive_defections >= self.game_description.n_players:
            cooperate = False
        return Action(int(cooperate))

class Strategy_EXPLOITATIVE_381(BaseStrategy):
    """
    A strategy that employs the Tit-for-Tat with Adaptation (TfT-A) approach in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.window_size = math.ceil(self.n_rounds * 0.8)
        self.threshold = self.n_players // 2
        self.cooperation_rate = np.zeros(self.game_description.n_rounds)
        self.history_index = min(self.window_size, self.game_description.n_rounds - 1)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number <= self.history_index:
            return Action.C
        self.cooperation_rate = self.cooperation_rate[self.history_index - 1:]
        self.history_index += 1
        cooperation_count = np.sum(history.opponent_actions[-self.window_size:, :].flatten())
        cooperation_rate = cooperation_count / self.window_size
        if cooperation_rate >= self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_382(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

    A strategy that cooperates initially to foster cooperation and goodwill among opponents, then adapts its decisions based on the opponent's previous actions. If the opponent cooperated in the previous round, TFT-AG will continue cooperating. If the opponent defected, TFT-AG will retaliate with defection but has a probability of showing adaptive generosity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_cooperation = 0
        self.consecutive_defection = 0
        self.max_generosity = 2
        self.base_generosity = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        action = Action.D
        if history is not None and state.round_number > 1:
            self.update_history(history)
            if history.opponent_actions[-1, -1] == Action.C.value:
                action = Action.C
            elif history.opponent_actions[-1, -1] == Action.D.value:
                p = min(self.max_generosity * (self.consecutive_cooperation - self.consecutive_defection), self.base_generosity)
                if random.random() <= p:
                    action = Action.C
        return action

    def update_history(self, history: PlayerHistory):
        self.consecutive_defection = max(0, self.consecutive_cooperation - 1) if history.opponent_actions[-1, -1] == Action.C.value else self.consecutive_defection + 1
        self.consecutive_cooperation = max(0, self.consecutive_defection - 1) if history.opponent_actions[-1, -1] == Action.D.value else self.consecutive_cooperation + 1

class Strategy_EXPLOITATIVE_383(BaseStrategy):
    """
    Tit-for-Tat with Adaptation strategy for the N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5 * self.game_description.n_players
        self.last_round_cooperators = None
        self.total_payoff = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.last_round_cooperators = sum(history.opponent_actions[-1])
        if state.round_number == 1:
            return Action.C if self.last_round_cooperators >= self.threshold else Action.D
        action = Action.D if self.last_round_cooperators is None else Action.C if self.last_round_cooperators > 0 else Action.D
        if history is not None and state.round_number >= 2:
            self.total_payoff += history.my_payoffs[-1]
            if self.total_payoff / (state.round_number - 1) > self.threshold:
                action = Action.C
            elif state.round_number == self.game_description.n_rounds and self.total_payoff < self.threshold:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_384(BaseStrategy):
    """
    A robust and adaptive exploitative strategy called "Tit for Tat with Adaptation" (TfTA) for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_random = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if cooperators >= self.game_description.n_players // 2 and random.random() > self.p_random:
            return Action.C
        elif cooperators == 0:
            return Action.D
        elif random.random() < self.p_random:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_385(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperators = np.zeros(self.game_description.n_rounds)
        self.p = int(self.game_description.n_rounds * 0.1)
        self.threshold = math.floor(self.game_description.n_players / 2)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        self.average_cooperators[state.round_number - 1] = cooperators / self.game_description.n_players
        average_cooperators = np.mean(self.average_cooperators[-self.p:])
        if state.round_number == self.game_description.n_rounds - 1 or history.my_actions[-1] is not history.opponent_actions[-1][0]:
            return Action.D
        elif average_cooperators > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_386(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.n_players * 0.5)
        self.first_round = True
        self.opponents_history = np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.bool_)
        self.own_history = np.zeros(self.game_description.n_rounds, dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.first_round = True
            return Action.C
        elif state.round_number == 0:
            self.first_round = False
            self.opponents_history[0] = np.zeros(self.game_description.n_players, dtype=np.bool_) if history is None else history.opponent_actions[0]
        elif self.first_round:
            opponents_cooperators = np.sum(self.opponents_history[-1])
            if opponents_cooperators == 0:
                return Action.D
            self.first_round = False
            self.own_history[state.round_number - 1] = Action.C
        else:
            opponents_cooperators = np.sum(self.opponents_history[-1])
            if opponents_cooperators >= self.threshold and np.sum(self.own_history) < self.threshold:
                return Action.C
            elif opponents_cooperators > 0 and np.all(self.opponents_history[-1] == self.own_history[-1]):
                return Action.C
            else:
                return Action.D
        self.opponents_history[state.round_number] = history.opponent_actions[state.round_number] if history is not None else np.zeros(self.game_description.n_players, dtype=np.bool_)
        self.own_history[state.round_number] = Action.C if self.__call__(GameState(state.round_number - 1), history) == Action.C else Action.D

class Strategy_EXPLOITATIVE_387(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r_threshold = int(math.ceil(game_description.n_rounds * 0.75))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) < self.r_threshold):
            return Action.C
        cooperators = np.sum(history.opponent_actions[-self.r_threshold:, :].mean(axis=0)) if history else 0
        defectors = np.count_nonzero(history.opponent_actions[-self.r_threshold:, :]) if history else 0
        return Action.C if cooperators > defectors else Action.D

class Strategy_EXPLOITATIVE_388(BaseStrategy):
    """
    Free Rider with Time-Adaptive Cooperation (FR-TAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.window_size = math.floor(self.n_rounds / 2)
        self.threshold = math.ceil((self.n_players + 1) / 2)
        self.previous_cooperators = 0
        self.sliding_window = np.zeros(self.window_size, dtype=np.int64)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.n_rounds - 1:
            return Action.D
        elif history is None:
            return Action.D
        cooperators = np.sum(history.opponent_actions[-self.window_size:, :])
        self.sliding_window[0] = cooperators
        for i in range(1, len(self.sliding_window)):
            self.sliding_window[i] = self.sliding_window[i - 1]
        avg_cooperators = np.mean(self.sliding_window)
        adjusted_threshold = math.ceil((self.n_players + 1) / 2) + avg_cooperators
        self.previous_cooperators += np.sum(history.opponent_actions[state.round_number - 1, :])
        if self.previous_cooperators < adjusted_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_389(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution Strategy (TFTAC) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.rounds_left = 0
        self.total_contributions_TFTAC = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.round_number < self.game_description.n_rounds - self.rounds_left:
            self.rounds_left -= 1
            cooperators = np.mean(history.opponent_actions[:, -1]) if history else 0
            return Action.C if cooperators > self.threshold else Action.D
        if state.round_number <= self.game_description.n_rounds and self.total_contributions_TFTAC > self.game_description.k * (self.game_description.n_players - 1):
            return Action.D
        if history:
            self.total_contributions_TFTAC += np.sum(history.my_actions)
            return super().__call__(state, history)

class Strategy_EXPLOITATIVE_390(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    Summary: TFT-AC cooperates to encourage others in the first round and mimics opponents' behavior, retaliating if necessary.
             It maintains an exploitative advantage over other strategies, encouraging cooperation but punishing defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance_level = int(math.ceil(game_description.n_players * 0.5))
        self.retaliation_count = 0
        self.max_retaliation_limit = self.tolerance_level * 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_actions = history.my_actions[-1]
        total_contributions = sum(history.opponent_actions[-1])
        if total_contributions >= self.game_description.n_players:
            return Action.C
        opponent_cooperation = my_actions and np.mean(history.my_actions[:-1]) > 0.5
        if opponent_cooperation:
            self.retaliation_count = 0
            return Action.C
        if my_actions and self.retaliation_count < self.max_retaliation_limit:
            self.retaliation_count += 1
            return Action.D
        if not my_actions:
            return Action.C
        if self.retaliation_count >= self.max_retaliation_limit:
            return Action.D

class Strategy_EXPLOITATIVE_391(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_round_cooperators = 0
        self.newcomer = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.opponent_actions) < self.game_description.n_players:
            self.newcomer = True
        cooperators = sum(history.opponent_actions[-1, :])
        total_players = self.game_description.n_players
        if state.round_number == self.game_description.n_rounds - 1 or (cooperators < total_players // 2 and cooperators > 0):
            return Action.D
        elif cooperators >= total_players // 2:
            return Action.C
        elif self.newcomer and history.opponent_actions[-1, :].all():
            return Action.D
        else:
            self.previous_round_cooperators = cooperators
            return Action.C
        self.newcomer = False

class Strategy_EXPLOITATIVE_392(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game, which cooperates when others cooperate and defects when others defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.past_actions = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.past_actions = [Action.C] * state.round_number
        last_action = self.past_actions[-1] if self.past_actions else Action.C
        opponent_cooperators = np.sum(history.opponent_actions[-1])
        if last_action == Action.C and opponent_cooperators == self.game_description.n_players - 1:
            self.past_actions.append(Action.C)
            return Action.C
        elif last_action == Action.D or (last_action == Action.C and opponent_cooperators == 0):
            self.past_actions.append(Action.D)
            return Action.D
        else:
            self.past_actions.append(Action.C)
            return Action.C

class Strategy_EXPLOITATIVE_393(BaseStrategy):
    """
    A strategy that combines Tit-for-Tat with an adaptive contribution approach. It cooperates initially and responds to defection with defection, while encouraging cooperation by adapting its level of contribution based on the perceived commitment of other players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2
        self.p_increment = 1 / (self.game_description.n_players - self.threshold)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if cooperators < self.threshold:
            return Action.C
        elif cooperators >= self.game_description.n_players:
            return Action.C
        else:
            p = (cooperators - self.threshold) * self.p_increment
            contribution_decision = random.random() <= p
            return Action.C if contribution_decision else Action.D

class Strategy_EXPLOITATIVE_395(BaseStrategy):
    """
    A cooperative strategy called "Tit-for-Tat with Adaptation".
    It aims to maintain cooperation as long as opponents do so, but responds aggressively when faced with repeated defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance_threshold = math.ceil(game_description.n_players / 10)
        self.forgiveness_window = min(self.tolerance_threshold * 2, game_description.n_rounds - self.tolerance_threshold)
        self.response_threshold = min(self.tolerance_threshold + self.forgiveness_window, game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = np.sum(history.opponent_actions[-1]) if history else 0
        if opponent_cooperators > 0 or np.count_nonzero(history.opponent_actions[:self.tolerance_threshold] if history else np.zeros(self.tolerance_threshold)) == self.tolerance_threshold:
            return Action.C
        if np.count_nonzero(history.opponent_actions[self.tolerance_threshold:] if history else np.zeros(self.tolerance_threshold)) >= self.tolerance_threshold or np.count_nonzero(history.opponent_actions[-self.response_threshold:]) > self.tolerance_threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_397(BaseStrategy):
    """
    Tit for Tat - a Public Goods Game strategy that is exploitative yet adaptive to a wide range of opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = False
        self.opponent_cooperated_last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.last_round = state.round_number == self.game_description.n_rounds
            self.opponent_cooperated_last_round = np.all(history.opponent_actions[-1] == 1)
        if state.round_number == 1:
            return Action.C if self.opponent_cooperated_last_round else Action.D
        elif state.round_number < self.game_description.n_rounds - 1:
            opponent_action = history.opponent_actions[-1, np.argmax(history.my_actions)]
            return Action.C if opponent_action == 1 else Action.D
        elif not self.last_round and np.sum(history.opponent_actions[-1]) > len(history.opponent_actions) // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_399(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.game_description.n_rounds - 1
        self.threshold = math.ceil(total_rounds * (1 - state.round_number / total_rounds)) if state.round_number < total_rounds else 1
        opponent_actions = history.opponent_actions[-1]
        cooperators = sum(opponent_actions)
        if all(opponent_actions):
            return Action.C
        if np.any((np.array(history.my_actions)[:-1] == Action.D) & (opponent_actions[-1] == Action.C)):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_400(BaseStrategy):
    """
    A Tit-for-Tat Adaptive (TfTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_action = Action.C
        else:
            total_contributions = sum(history.opponent_actions[state.round_number - 1, :])
            if total_contributions == self.game_description.n_players:
                action = Action.C
            else:
                action = Action.D
            self.previous_action = action
        return self.previous_action

class Strategy_EXPLOITATIVE_401(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game that takes advantage of other players' cooperative tendencies while minimizing its own contributions when others defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_history = [0 for _ in range(self.game_description.n_rounds)]
        self.cooperation_threshold = 0.5

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.opponent_actions) < self.game_description.n_rounds:
            return Action.D
        if not history:
            total_contributions = 0
            for _ in range(state.round_number):
                total_contributions += sum((history.opponent_actions[i, :] for i in range(self.game_description.n_rounds)))
            ACR = total_contributions / state.round_number
        else:
            ACR = np.mean(history.my_actions)
        if ACR >= self.cooperation_threshold:
            return Action.C
        return Action.D

    def set_cooperation_threshold(self, threshold):
        self.cooperation_threshold = threshold

    def reset_ACR(self):
        self.round_history = [0 for _ in range(self.game_description.n_rounds)]

class Strategy_EXPLOITATIVE_403(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperation threshold for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.adaptation_threshold = math.floor(game_description.n_players * 0.8)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1, 0] if history is not None else None
        total_contributions = np.sum(history.my_actions[-1]) if history is not None else 0
        if opponent_action is None or state.round_number == self.game_description.n_rounds:
            return Action.C
        if opponent_action:
            return Action.C
        elif total_contributions > self.adaptation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_404(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.forgiveness_threshold = math.ceil(game_description.n_players / 2)
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or self.consecutive_defections >= self.forgiveness_threshold:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators > 0:
                return Action.C
        self.consecutive_defections += 1 if history is not None and all((action == Action.D for action in history.opponent_actions[-1, :])) else 0
        self.forgiveness_threshold = min(self.game_description.n_players, self.consecutive_defections * 2)
        return Action.D

class Strategy_EXPLOITATIVE_405(BaseStrategy):
    """
    Implements the Adaptive Tit-for-Tat strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number < self.game_description.n_rounds:
            last_opponent_action = history.opponent_actions[-1][-1] if len(history.opponent_actions) > 0 else None
            if self.last_opponent_action is None:
                self.last_opponent_action = last_opponent_action
            if last_opponent_action == Action.C:
                return Action.C
            elif last_opponent_action == Action.D:
                self.last_opponent_action = last_opponent_action
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_406(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            total_contributions = sum(history.opponent_actions[state.round_number - 1, :])
            if total_contributions == self.n_players // 2:
                return self.opponent_history[-1] if len(self.opponent_history) > 0 else Action.C
            if total_contributions < self.n_players // 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_407(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Modified Contribution (ATTC) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None
        self.total_payoff_cooperative = 0.0
        self.total_payoff_defective = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        elif state.round_number == 0:
            self.history = PlayerHistory(np.array([[False]], dtype=bool), np.zeros(1), np.zeros((1, self.game_description.n_players)), np.zeros(1))
            return Action.C
        else:
            self.update_history(state, history)
            contribution = self.determine_contribution()
            if contribution == 0:
                payoff = 1 - contribution
            else:
                cooperators = np.sum(self.history.opponent_actions[-1])
                payoff = 1 - contribution + self.game_description.k / self.game_description.n_players * cooperators
            if state.round_number == self.game_description.n_rounds:
                if self.total_payoff_cooperative > self.total_payoff_defective:
                    contribution = 1
                else:
                    contribution = 0
            self.update_payoffs(payoff)
            return Action(int(contribution))

    def update_history(self, state: GameState, history: PlayerHistory):
        if self.history is not None:
            self.history.my_actions = np.vstack([self.history.my_actions, np.array([[int(action == Action.C) for action in self.history.my_actions[-1]]])])
            self.history.my_payoffs = np.append(self.history.my_payoffs, [state.round_number])
            self.history.opponent_actions = np.vstack([self.history.opponent_actions, history.opponent_actions[:state.round_number + 1]])
            self.history.opponent_payoffs = np.append(self.history.opponent_payoffs, history.opponent_payoffs[:state.round_number + 1])
        else:
            self.history = PlayerHistory(np.array([[False]], dtype=bool), np.zeros(1), history.opponent_actions, history.opponent_payoffs)

    def update_payoffs(self, payoff):
        self.total_payoff_cooperative += payoff if self.history.my_actions[-1][0] == 1 else 0
        self.total_payoff_defective += payoff if self.history.my_actions[-1][0] == 0 else 0

    def determine_contribution(self):
        if len(self.history.my_actions) == 1:
            return 1
        previous_round = self.history.opponent_actions[-2]
        if previous_round[-1] == 1:
            return 1
        n_c = np.sum(previous_round)
        if n_c == 1:
            return self.game_description.k / self.game_description.n_players
        else:
            return self.game_description.k / self.game_description.n_players * (n_c / self.game_description.n_players)

class Strategy_EXPLOITATIVE_408(BaseStrategy):
    """
    A Tit-for-Tat with Adaptation (TfTA) strategy for N-Player Public Goods Game.
    This strategy cooperates initially, then adapts its decisions based on the opponent's previous move.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_half = math.ceil(self.game_description.n_rounds / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_round = len(history.opponent_actions) - 1
            last_move = history.opponent_actions[last_round, :]
            cooperators = np.sum(last_move)
            if last_round < self.round_half and (cooperators > 0 or np.sum(last_move) == len(history.opponent_actions)):
                return Action.C
            elif last_round >= self.round_half:
                return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_409(BaseStrategy):
    """
    Exploitative strategy for the N-Player Public Goods Game, maximizing total payoff while minimizing other players' payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players // 2 + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        cooperators = np.sum(history.opponent_actions[-1, :])
        if cooperators >= self.n:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_410(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold strategy for the N-Player Public Goods Game.
    The agent cooperates initially, and then adaptively decides to cooperate or defect based on a predefined threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_players, game_description.n_rounds), dtype=bool), np.zeros(game_description.n_rounds))
        self.sensitivity = 0.5

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None:
            self.history = history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds))
        avg_coop = np.mean(history.my_actions[:state.round_number])
        threshold = avg_coop * self.sensitivity
        if np.sum(history.my_actions[state.round_number - 1]) >= int(threshold):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_412(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if state.round_number == 0:
            return Action.C
        else:
            last_opponent_actions = history.opponent_actions[-1]
            cooperators = sum(last_opponent_actions)
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_413(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    The strategy follows a cooperative norm in the initial round, then punishes defection and rewards cooperation thereafter.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        self.last_opponent_action = history.opponent_actions[-1, 0]
        if self.last_opponent_action == Action.C:
            return Action.C
        else:
            return Action.D

    def adjust_for_last_round(self, history):
        """Adjusts history to account for the last round's actions when it might not be present."""
        if len(history) == self.game_description.n_rounds:
            return history
        else:
            history.opponent_actions = np.append(history.opponent_actions, np.full(self.game_description.n_rounds - len(history), Action.D))
            return history

class Strategy_EXPLOITATIVE_415(BaseStrategy):
    """
    Tit-for-Tat-K (TFT-K) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tft_k_threshold = math.ceil(self.game_description.k / 2 - 1)
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            self.history.my_actions[0] = True
            return Action.C
        if state.round_number == 0:
            self.history.my_actions[:] = [True] * state.round_number
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.tft_k_threshold or (self.history.my_actions[-1] and history.opponent_actions[-1, state.player_id - 1] == True):
            self.history.my_actions[state.round_number] = True
            return Action.C
        else:
            self.history.my_actions[state.round_number] = False
            return Action.D

class Strategy_EXPLOITATIVE_416(BaseStrategy):
    """
    A strategy that cooperates in the first round and adapts its cooperation level based on opponents' behavior.
    The strategy uses a 'cooperative score' to evaluate opponents' actions and decides whether to cooperate or defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 4
        self.last_round_penalty = 0.5
        self.cooperative_score = 1.0
        self.remaining_rounds_threshold = game_description.n_rounds // 4

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.opponent_actions is not None:
            self.cooperative_score = self.update_cs(history, state)
            return self.decide_action(state, self.cooperative_score)

    def decide_action(self, state: GameState, cs: float) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action(int(cs >= self.threshold))

    def update_cs(self, history: PlayerHistory, state: GameState) -> float:
        if state.round_number < self.remaining_rounds_threshold:
            opponent_cooperators = np.sum(history.opponent_actions[-1])
            self.cooperative_score += (1 - self.cooperative_score) * (Action.C == history.opponent_actions[-1, -1]) if state.round_number > 0 else 1
            self.cooperative_score *= 1 - self.last_round_penalty if history.my_actions[-1] != Action.C else self.cooperative_score
        return self.cooperative_score

class Strategy_EXPLOITATIVE_418(BaseStrategy):
    """
    A cooperative Tit-for-Tat strategy for the N-Player Public Goods Game, punishing defectors and rewarding cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = game_description.n_rounds - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        last_opponent_action = history.opponent_actions[-1, -1]
        if state.round_number <= self.last_round:
            return Action.C if last_opponent_action == Action.C else Action.D
        all_cooperated_previous_round = np.all(history.opponent_actions[-2, :])
        return Action.C if all_cooperated_previous_round else Action.D

class Strategy_EXPLOITATIVE_419(BaseStrategy):
    """
    Tit-for-Tat-Adaptive (TfT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_coop_threshold = int(math.ceil(game_description.n_players * 0.5))
        self.n_defection_percentage = 50
        self.n_cooperation_percentage = 75
        self.player_history = PlayerHistory(my_actions=np.array([], dtype=bool), my_payoffs=np.array([], dtype=float), opponent_actions=np.zeros((game_description.n_rounds, self.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, self.n_players), dtype=float))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.player_history = history
        current_round = state.round_number
        opponent_cooperation_percentage = np.mean(self.player_history.opponent_actions[:current_round, :].flatten()) * 100
        player_cooperation_percentage = np.mean(self.player_history.my_actions[:current_round]) * 100
        if current_round == self.game_description.n_rounds and opponent_cooperation_percentage > self.n_coop_threshold:
            return Action.D
        if opponent_cooperation_percentage > self.n_defection_percentage and player_cooperation_percentage > self.n_cooperation_percentage:
            action = Action.C
        elif opponent_cooperation_percentage < self.n_defection_percentage and player_cooperation_percentage > self.n_cooperation_percentage:
            action = Action.D
        elif opponent_cooperation_percentage > self.n_defection_percentage and player_cooperation_percentage < self.n_cooperation_percentage:
            action = Action.D
        else:
            action = Action.C
        self.player_history.my_actions[-1] = action == Action.C
        return action

class Strategy_EXPLOITATIVE_420(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.rounds = np.zeros(game_description.n_rounds, dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_cooperators = np.sum(history.opponent_actions[-1, :]) if history is not None else 0
        if total_cooperators >= self.game_description.n_players // 2:
            self.rounds[state.round_number] = True
        else:
            self.rounds[state.round_number] = False
        return Action(int(self.rounds[state.round_number]))

class Strategy_EXPLOITATIVE_421(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TfTAC) strategy for N-Player Public Goods Game.
    The strategy cooperates in the initial round and adapts to the average number of cooperators in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.avg_cooperators = 0.0
        self.total_rounds = self.game_description.n_rounds
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        self.current_round = state.round_number
        if self.current_round == 0:
            return Action.C
        if history is None:
            cooperators = np.zeros(self.game_description.n_players, dtype=np.int32)
        else:
            cooperators = np.sum(history.opponent_actions[-1], axis=0)
        self.avg_cooperators += (cooperators - self.avg_cooperators) / self.current_round
        threshold = self.avg_cooperators * (1 - self.current_round / self.total_rounds)
        if cooperators >= threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_423(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game, which encourages cooperation and punishes defection when needed.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number > 1 and (not self.last_round)):
            return Action.C
        if history:
            total_contributions = sum(history.opponent_actions[-1])
            if total_contributions > self.game_description.k * self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        return Action.D

    def update(self, state: GameState, payoff: float):
        if state.round_number > 1 and self.last_round is not None:
            self.last_round[0] = payoff
        else:
            self.last_round = [payoff]

class Strategy_EXPLOITATIVE_424(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Time Discounting (TfT-TD)
    Strategy summary: Cooperates at the beginning and punishes defection swiftly with a gradually reduced impact over time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_window_size = math.floor(game_description.n_rounds / 2)
        self.penalty_factor_coeff = 0.95
        self.past_opponent_actions = None
        self.last_round_cooperators = 0
        self.last_round_my_action = Action.D
        self.last_round_payoff = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - self.punishment_window_size // 3:
            return Action.C
        if history is not None:
            self.update_history(history)
            if state.round_number < self.punishment_window_size and self.last_round_my_action == Action.D:
                penalty_factor = 1 - self.penalty_factor_coeff ** ((state.round_number - 1) / self.game_description.n_rounds)
                if self.past_opponent_actions[-self.punishment_window_size:].mean() >= len(self.past_opponent_actions) // 2:
                    return Action.C if random.random() < penalty_factor else Action.D
        return Action.D

    def update_history(self, history):
        self.last_round_cooperators = sum(history.opponent_actions[-1, :])
        self.last_round_my_action = history.my_actions[-1]
        self.last_round_payoff = history.my_payoffs[-1]
        self.past_opponent_actions = np.concatenate([self.past_opponent_actions, history.opponent_actions]) if self.past_opponent_actions is not None else history.opponent_actions

class Strategy_EXPLOITATIVE_425(BaseStrategy):
    """
    A strategy that implements Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.t = math.ceil(self.n_rounds / 2)
        self.actions = np.array([Action.C] * self.n_rounds, dtype=np.bool_)

    def __call__(self, state: GameState, history: PlayerHistory | None):
        if history is None or state.round_number == 0:
            return Action.C
        majority = int(self.n_players * (self.t / self.n_players))
        if len(np.where(history.my_actions[:state.round_number] == Action.C)[0]) > majority:
            return Action.C
        return Action.D

    def update_cooperation_threshold(self, round_number: int):
        if round_number == self.n_rounds or len(np.where(self.actions[:round_number] == Action.C)[0]) > (self.t + 1) // self.n_players:
            self.t += 1 / (self.n_rounds * self.n_players)
        elif len(np.where(self.actions[:round_number] == Action.D)[0]) > (self.t - 1) // self.n_players:
            self.t -= 1 / (self.n_rounds * self.n_players)

class Strategy_EXPLOITATIVE_426(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for N-Player Public Goods Game.
    Cooperates if initial cooperation is observed or when others cooperate, punishes defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history and (not self.punished)):
            return Action.C
        if history and self.punished and (history.opponent_actions[-1, -1] == Action.C):
            self.punished = False
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_427(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TfT-A) strategy for N-Player Public Goods Game.
    Cooperates in the first round to foster a cooperative environment, adopts Tit-for-Tat strategy thereafter, and introduces an adaptation mechanism to prevent being taken advantage of by overly aggressive opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.score = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        actions = np.zeros(self.game_description.n_players, dtype=bool)
        actions[0] = True
        if history is not None:
            last_round = len(history.opponent_actions) - 1
            actions[1:] = history.opponent_actions[last_round]
            self.score += np.sum(actions) - self.score
        if np.sum(actions) > self.game_description.n_players * (self.score / self.game_description.n_players):
            self.score = min(self.score + 1, self.game_description.n_players)
            return Action.C
        self.score = max(0, self.score - 1)
        return Action.D

class Strategy_EXPLOITATIVE_428(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.r = game_description.n_rounds
        self.forgiveness_period_increment = math.ceil(self.r / 10)
        self.max_forgiveness_period = self.r * 2
        self.history = [None] * (self.r + 1)
        self.current_round = 0
        self.forgiveness_period = self.forgiveness_period_increment

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.current_round = state.round_number
        if self.history[self.current_round] is None:
            self.history[self.current_round] = np.zeros(self.n, dtype=np.bool_)
        cooperators = sum(self.history[self.current_round])
        if self.current_round == 1 or cooperators > self.forgiveness_period // 2:
            return Action.C
        return Action.D

    def update_history(self, state: GameState, actions: NDArray[np.bool_]) -> None:
        if self.current_round < len(self.history):
            self.history[self.current_round] = actions
        if self.current_round >= self.forgiveness_period:
            self.forgiveness_period += self.forgiveness_period_increment
            if self.forgiveness_period > self.max_forgiveness_period:
                self.forgiveness_period = self.max_forgiveness_period

class Strategy_EXPLOITATIVE_429(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = math.ceil(game_description.n_rounds * 0.1)
        self.last_t_rounds_defect = False
        self.last_t_rounds_before_defect_cooperated = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        if history is None:
            self.last_t_rounds_defect = False
            self.last_t_rounds_before_defect_cooperated = False
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators == self.game_description.n_players:
            return Action.C
        elif cooperators == 0:
            self.last_t_rounds_defect = True
            self.last_t_rounds_before_defect_cooperated = False
            return Action.D
        elif self.last_t_rounds_defect and sum(history.opponent_actions[-self.tolerance:-1, :].any(axis=0)) > 0:
            self.last_t_rounds_before_defect_cooperated = True
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_430(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_history = np.zeros(game_description.n_rounds - 1)
        self.average_contributions = np.zeros(game_description.n_rounds - 1)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        total_contributions = np.sum(history.my_actions[-1]) if history else self.round_history[-1]
        average_contributions = np.mean(self.round_history) if len(self.round_history) > 0 else None
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if total_contributions == average_contributions:
            return Action(random.choice([0, 1]))
        if total_contributions >= average_contributions:
            self.round_history[-1] = total_contributions
            return Action.C
        else:
            self.round_history[-1] = total_contributions
            return Action.D

class Strategy_EXPLOITATIVE_431(BaseStrategy):
    """
    TFTA Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2
        self.history = PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        if np.all(history.opponent_actions[:, -1] == self.game_description.n_players):
            return Action.C
        elif cooperators == 0:
            return Action.D
        else:
            return Action.C if cooperators >= self.threshold else Action.D

    def update_history(self, payoffs: NDArray[np.float64]):
        self.history = PlayerHistory(self.history.my_actions, np.concatenate((self.history.my_payoffs, payoffs)), self.history.opponent_actions, self.history.opponent_payoffs)

class Strategy_EXPLOITATIVE_432(BaseStrategy):
    """
    A strategy that cooperates initially and adapts its actions based on previous rounds' experiences,
    copying the opponent's action from the last round in the next round (cooperate if the opponent cooperated, defect if the opponent defected).
    If there is no history (first encounter), it will cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.aggressiveness = 0.5
        self.punishment_duration = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.punishment_duration = int(self.game_description.n_players * (1 - self.aggressiveness)) if self.punishment_duration is None else min(state.round_number, self.punishment_duration)
        if state.round_number <= self.punishment_duration:
            last_action = history.opponent_actions[-1][-1]
            return Action(int(last_action)) if history else Action.C
        elif np.count_nonzero(history.opponent_actions[-self.punishment_duration:, -1]) >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_436(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat Cooperation with Adaptive Contribution (TFTAC)
    The strategy cooperates initially and adjusts contributions based on the number of collaborators in the previous round.
    It punishes uncooperative behavior while encouraging cooperation by rewarding majority collaboration.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_level = 1.0
        self.initial_cooperation = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1, :])
        if self.initial_cooperation and cooperators < self.game_description.n_players // 2:
            self.contribution_level = 1.0
            self.initial_cooperation = False
        if cooperators >= (self.game_description.n_players + 1) // 2:
            contribution_factor = 0.5
        else:
            contribution_factor = 1.0
        self.contribution_level *= contribution_factor
        return Action.C if np.random.random() < self.contribution_level else Action.D

class Strategy_EXPLOITATIVE_437(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptation
    Description: A strategy that maximizes payoff by taking advantage of other players' actions while being robust to various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.historical_data = np.zeros((1, game_description.n_players), dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not any(history.opponent_actions[-1, :]):
            return Action.D
        total_cooperators = np.sum(history.opponent_actions[-1, :])
        if total_cooperators == history.opponent_actions.shape[1]:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_438(BaseStrategy):
    """
    A simple implementation of Tit-for-Tat Plus (TfT+) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_number = 0
        self.opponent_cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.opponent_actions) < self.round_number + 1:
            self.opponent_cooperation_history = [False] * (self.round_number + 1)
        last_opponent_action = history.opponent_actions[-1, -1]
        self.opponent_cooperation_history.append(last_opponent_action)
        if last_opponent_action:
            return Action.C
        else:
            if self.round_number > 1 and self.opponent_cooperation_history[-2]:
                return Action.D
            return Action.C

class Strategy_EXPLOITATIVE_439(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Contribution (TFTAC) in an N-Player Public Goods Game.
    This strategy cooperates initially and punishes opponents who defect, while also adapting its level of cooperation based on game parameters k and n.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = k = game_description.k
        self.n = n = game_description.n_players
        self.cooperate_threshold = math.floor((n + 1) / 2)
        self.contribution_level = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1] if history else np.zeros(self.game_description.n_rounds, dtype=bool))
        if cooperators >= self.cooperate_threshold:
            return Action.C
        contribution_probability = (1 - self.contribution_level) * (cooperators / self.cooperate_threshold)
        return Action(random.choice([0, 1]) if random.random() < contribution_probability else 1)

    def adjust_strategy(self, new_k: float, new_n: int):
        """
        Adjust the contribution level based on new game parameters k and n.
        This can be used to make the strategy more or less exploitative.
        """
        self.k = new_k
        self.n = new_n
        self.contribution_level = min(max(0.1, self.k * (new_n - 1) / new_n), 0.95)

class Strategy_EXPLOITATIVE_440(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(self.game_description.n_players * 0.5)
        self.average_cooperation_rate = None
        self.rounds_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.average_cooperation_rate is None or self.rounds_count < self.m:
            cooperators = np.sum(history.opponent_actions, axis=0) if history else np.zeros((1, self.game_description.n_players), dtype=bool)
            self.average_cooperation_rate = np.mean(cooperators)
        else:
            cooperators = history.opponent_actions[-self.m:, :].sum(axis=0)
            self.average_cooperation_rate = cooperators.mean()
        if self.average_cooperation_rate > 0.6:
            return Action.C
        elif self.average_cooperation_rate < 0.6:
            return Action.D
        else:
            return random.choice([Action.C, Action.D])

    def update(self, payoffs: PlayerHistory) -> None:
        self.rounds_count += 1
        if self.average_cooperation_rate is not None:
            payoffs.my_payoffs[-1] = payoffs.payoffs.sum()

class Strategy_EXPLOITATIVE_442(BaseStrategy):
    """
    A strategy that cooperates initially and then mimics opponent's actions from the previous round.
    It includes an adaptive element that adjusts the number of consecutive cooperation/defection rounds based on the opponent's history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_counter = 0
        self.defection_counter = 0
        self.adaptation_threshold = random.randint(1, self.game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            opponent_actions = history.opponent_actions[-1] if history.opponent_actions is not None else None
            if opponent_actions is not None and self.cooperation_counter > 0 and (self.defection_counter > 0):
                random_number = random.randint(1, self.game_description.n_rounds)
                if random_number <= min([self.cooperation_counter, self.adaptation_threshold]) or random_number <= min([self.defection_counter, self.adaptation_threshold]):
                    return Action(not opponent_actions[-1])
            action = opponent_actions[-1] if opponent_actions is not None else None
            if action is not None:
                if action:
                    self.cooperation_counter += 1
                    self.defection_counter = 0
                else:
                    self.cooperation_counter = 0
                    self.defection_counter += 1
            return Action(action is not None and action)
        return Action(False)

class Strategy_EXPLOITATIVE_445(BaseStrategy):
    """
    Tit-for-Tat Plus (TFT+) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_cooperators = sum(history.opponent_actions[-1, :])
        cooperators = self.last_cooperators
        if state.round_number < self.game_description.n_rounds - 1:
            if cooperators >= math.ceil(self.game_description.n_players / 2):
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_446(BaseStrategy):
    """
    A strategy called Tit-for-Tat with Adaptive Contribution (TFTAC). This strategy cooperates in the first round and adapts to opponents' actions for subsequent rounds. It contributes if the opponent contributed in the previous round, otherwise defects. In the final round, it always contributes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_contributions = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        elif history is not None and state.round_number == 1:
            self.opponent_contributions[0] = int(history.my_actions[0])
        elif history is not None:
            self.opponent_contributions[-1] = int(history.my_actions[-1])
        action = Action.C if self.opponent_contributions[-1] == 1 else Action.D
        if state.round_number == self.game_description.n_rounds:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_447(BaseStrategy):
    """
    A Tit-for-Tat-Adaptive (TfTA) strategy for N-Player Public Goods Game.
    This strategy maintains a history of past actions from each opponent and responds accordingly, with a slight modification to become more exploitative.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_streak = 0
        self.defection_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        actions = np.array([action for round_, action in zip(range(1, len(history.opponent_actions)), history.opponent_actions[0])], dtype=bool)
        cooperators = sum(actions)
        if cooperators >= self.game_description.n_players // 2:
            if self.defection_streak > 0:
                self.defection_streak -= 1
            self.cooperation_streak += 1
            return Action.C
        else:
            if self.cooperation_streak > 0:
                self.cooperation_streak -= 1
            self.defection_streak += 1
            return Action.D

class Strategy_EXPLOITATIVE_448(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contributions = [0] * game_description.n_rounds
        self.total_payoff = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self.contributions[-1] += history.my_actions[-1] - self.contributions[-1]
        if history is None or state.round_number == 0:
            return Action.C
        else:
            opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
            if history.my_payoffs[-1] > self.total_payoff / self.game_description.n_rounds and opponent_cooperators > 0:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_449(BaseStrategy):
    """
    A strategy that adapts to other players' strategies by cooperating when others cooperate and defecting when others defect. The contribution factor varies depending on the number of previous defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if np.any(history.opponent_actions[-1]):
            self.defection_counter += 1
        else:
            self.defection_counter = 0
        k_factor = 1 + math.ceil(self.defection_counter / self.game_description.n_players * (self.game_description.k - 1))
        cooperators = sum(history.opponent_actions[-1])
        if cooperators == self.game_description.n_players:
            return Action.C
        elif cooperators > 0 and self.defection_counter < self.game_description.n_players:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_450(BaseStrategy):
    """
    A strategy that cooperates in the first round and cooperates if the opponent cooperated in the previous round, otherwise defects.
    If the opponent switches from cooperation to defection (or vice versa), the player will retaliate accordingly.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history and history.opponent_actions[-1, 0] if history else None
        action = Action.C if opponent_action == Action.C else Action.D
        return action

class Strategy_EXPLOITATIVE_451(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_threshold = np.zeros(game_description.n_rounds)
        self.ct_step = 1 / game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_count = np.sum(history.opponent_actions[:state.round_number, :])
        adaptive_coop_threshold = min((state.round_number + 1) * self.ct_step, self.game_description.n_players // 2)
        if cooperation_count > adaptive_coop_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_452(BaseStrategy):
    """
    The Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round = 0
        self.opponent_history = []

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.opponent_history.append(np.mean(history.opponent_actions, axis=1))
        last_opponent_action = self.opponent_history[-1]
        self.round += 1
        if np.all(last_opponent_action):
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            if np.any(last_opponent_action) and np.all(self.opponent_history[-1])[0:self.game_description.n_players - 1]:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_453(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = self.game_description.n_players // 2 - 1
        self.current_opponent_cooperation_count = 0
        self.total_opponent_cooperation_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1, :]) if history else 0
        action = Action.D if total_contributions < self.cooperation_threshold else Action.C
        if action == Action.C:
            self.current_opponent_cooperation_count += 1
            self.total_opponent_cooperation_count += 1
        else:
            self.current_opponent_cooperation_count = 0
        self.cooperation_threshold = self.game_description.n_players // self.game_description.n_rounds * self.total_opponent_cooperation_count + self.cooperation_threshold
        if state.round_number == self.game_description.n_rounds:
            if self.current_opponent_cooperation_count >= self.game_description.n_players // 2 - 1:
                return Action.C
        return action

class Strategy_EXPLOITATIVE_454(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_history = []
        self.most_cooperative_opponent = None
        self.max_cooperation_count = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if len(self.my_history) > 0:
            cooperators = np.sum(history.opponent_actions[:, self.my_index])
            if cooperators >= len(history.opponent_actions[0]) // 2:
                return Action.C
        if len(self.my_history) > 1 and history.round_number == len(self.my_history) - 1:
            self._update_most_cooperative()
            if self.my_history[-1] == self.most_cooperative_opponent:
                return Action.C
        return Action.D

    def _update_most_cooperative(self):
        cooperators = np.sum(self.my_history[-1], axis=0)
        opponent_indices = [i for i, opp in enumerate(self.opponent_ids) if np.count_nonzero(cooperators[i]) > self.max_cooperation_count]
        if len(opponent_indices) > 0:
            self.most_cooperative_opponent = self.opponent_ids[opponent_indices[0]]
            self.max_cooperation_count = np.count_nonzero(cooperators[opponent_indices[0]])

class Strategy_EXPLOITATIVE_455(BaseStrategy):
    """
    A strategy that mimics the behavior of other cooperative strategies in the first few rounds, while being adaptive to changes in their cooperation levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.beta = min(math.sqrt(self.game_description.k - 1), 0.5)
        self.my_contribution = 0.0
        self.total_contributions = 0.0
        self.round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        self.round += 1
        if history is not None:
            self.my_contribution = np.sum(history.my_actions) / state.round_number
            self.total_contributions = np.sum(history.opponent_actions[-1])
        if self.total_contributions == 0:
            return Action.D
        if self.my_contribution == self.total_contributions:
            return Action.C
        elif self.my_contribution < self.total_contributions:
            contribution_factor = self.total_contributions / (self.game_description.k * (self.game_description.n_players - 1))
            return Action(int(math.floor(self.my_contribution + self.beta))) if contribution_factor > 0 else Action.D
        elif self.my_contribution > self.total_contributions:
            return Action(int(math.ceil(self.total_contributions / self.game_description.n_players))) if self.total_contributions > 0 else Action.C

class Strategy_EXPLOITATIVE_456(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game, which cooperates in the first round and maintains cooperation if the majority of players cooperated in the previous round, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.trust_horizon = math.ceil(game_description.n_rounds * 0.7)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.opponent_actions) < self.trust_horizon:
            return Action.C
        cooperators_last = np.sum(history.opponent_actions[-1])
        avg_cooperators_T = np.mean(history.opponent_actions[:, -self.trust_horizon:].flatten())
        if cooperators_last >= avg_cooperators_T:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_458(BaseStrategy):
    """
    Tit-for-Tat strategy with an average cooperative trend adjustment for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_rounds / 10) if game_description.n_rounds > 10 else game_description.n_rounds // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[:, -1])
        if state.round_number > 1 and cooperators >= np.mean(history.my_actions[:-1]).round():
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_459(BaseStrategy):
    """
    A strategy that cooperates in the first round and then adapts its contribution based on the average behavior of opponents. If the average contribution of opponents is greater than 50%, it cooperates; otherwise, it defects. If an opponent switches from cooperation to defection (defection event), it temporarily switches to defection for the next (n_rounds-1) rounds before reverting back to observing the average contribution rule. If an opponent switches from defection to cooperation (cooperation event), it continues cooperating for (n_rounds-1) rounds before reverting back to observing the average contribution rule. In case of a tie in the average_c calculation, it cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_contribution_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.average_contribution_history.append(np.mean(history.opponent_actions[-self.game_description.n_rounds + 1:-1].flatten()))
        if state.round_number < self.game_description.n_rounds:
            average_c = np.mean(self.average_contribution_history)
            return Action.C if average_c > 0.5 else Action.D
        average_c = self.average_contribution_history[-1]
        return Action.C if average_c > 0.5 else Action.D

    def cooperation_event(self, history: PlayerHistory):
        """
        Checks if an opponent switched from defection to cooperation in the most recent round
        """
        opponent_actions = history.opponent_actions[-1]
        for i in range(len(opponent_actions)):
            if opponent_actions[i] and (not self.average_contribution_history[-2][i]):
                return i + 1
        return None

    def defection_event(self, history: PlayerHistory):
        """
        Checks if an opponent switched from cooperation to defection in the most recent round
        """
        opponent_actions = history.opponent_actions[-1]
        for i in range(len(opponent_actions)):
            if not opponent_actions[i] and self.average_contribution_history[-2][i]:
                return i + 1
        return None

class Strategy_EXPLOITATIVE_460(BaseStrategy):
    """
    Strategy that starts by cooperating and then copies the most frequent cooperator from the previous round.
    If multiple players tied for the most frequent cooperation, chooses one arbitrarily or uses an average of their contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros((game_description.n_rounds,), dtype=np.float64), opponent_actions=np.full((game_description.n_rounds, game_description.n_players), False), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.count_nonzero(history.opponent_actions[-1, :])
        max_cooperators = np.argmax(history.opponent_actions[:, -1])
        if np.sum(history.opponent_actions[state.round_number - 1] == 1) == cooperators and cooperators == self.game_description.n_players:
            return Action.C
        if len({max_cooperators}) > 1:
            average_cooperators = np.mean(history.opponent_actions[:, max_cooperators])
            if average_cooperators == 1:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_461(BaseStrategy):
    """
    Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.trust_indices = [0.5] * game_description.n_players
        self.alpha = 0.7
        self.cooperation_threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_rate = np.mean(history.my_actions[-self.game_description.n_rounds:])
        self.trust_indices = [a * self.alpha + (1 - self.alpha) * c for a, c in zip(self.trust_indices, np.repeat(cooperation_rate, len(self.trust_indices)))]
        action = Action.C if np.mean(self.trust_indices) > self.cooperation_threshold else Action.D
        return action

class Strategy_EXPLOITATIVE_462(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy in N-Player Public Goods Game.
    This strategy mimics the first-mover advantage and adapts to opponents' past actions,
    cooperating when opponents cooperate and defecting when opponents defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.history.my_actions[state.round_number] = Action.C
        opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        self.history.my_payoffs[state.round_number - 1] = 1 - self.history.my_actions[state.round_number - 1] + self.game_description.k / self.game_description.n_players * opponent_cooperators
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_463(BaseStrategy):
    """
    Implementation of the Tit-for-Tat-Adaptive (TfTA) strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        self.last_opponent_action = opponent_actions[-1] if len(opponent_actions) > 0 else None
        if state.round_number == len(history.opponent_payoffs):
            return Action.C
        action = Action.C if self.last_opponent_action == Action.C else Action.D
        return action

class Strategy_EXPLOITATIVE_464(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Variation (TfTV)

    A simple strategy that cooperates in the first round and mimics opponents' previous actions in subsequent rounds, with a small probability of deviating each time. The deviation probability increases as the number of consecutive defections by an opponent increases. In the last round, the strategy cooperates to encourage cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.deviation_probability = 0
        self.opponent_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_defections = sum(history.opponent_actions[:state.round_number, :][-1] == Action.D)
            self.deviation_probability = min(self.opponent_defections / state.round_number, 0.5)
        if self.deviation_probability > random.random():
            return Action.D
        else:
            actions = history.opponent_actions[:state.round_number, -1]
            if np.sum(actions) >= self.game_description.n_players // 2:
                return Action.C
            elif np.all(actions == Action.D):
                return Action.D
        return Action.C

    def final_round_strategy(self, state: GameState) -> Action:
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        return self.__call__(state, None)

class Strategy_EXPLOITATIVE_465(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for an N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if not self.history or len(self.history) < state.round_number + 1:
            self.history = [history] if history else []
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators == self.n_players or cooperators == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        max_cooperators = np.max(opponent_actions)
        if max_cooperators > 0 and random.random() < max_cooperators / cooperators:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_466(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold strategy for the N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tau = 2 / game_description.n_players
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))
        self.threshold_counter = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        if state.round_number < 5:
            return Action.C
        self.history = history
        opponent_cooperators = sum(self.history.opponent_actions[-1])
        if state.round_number == self.history.my_actions.size and opponent_cooperators > 0:
            return Action.C
        if state.round_number == self.history.my_actions.size - 1:
            self.threshold_counter += 1
        if opponent_cooperators >= math.ceil(self.tau * self.history.my_actions.size * self.threshold_counter):
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_467(BaseStrategy):
    """
    A Tit-for-Tat with Adaptation strategy for the N-Player Public Goods Game.
    This strategy follows three key principles: reciprocity, forgiveness, and adaptation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.learning_rate = 0.1
        self.threshold = 0.5
        self.memories = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and self.memories:
            for opponent in range(1, self.game_description.n_players + 1):
                cooperators = sum(history.opponent_actions[:, opponent - 1])
                if cooperators == self.game_description.n_players:
                    self.memories[opponent] = max(self.learning_rate, self.memories[opponent])
                else:
                    self.memories[opponent] *= self.learning_rate
                    self.memories[opponent] = min(1, self.memories[opponent])
            actions = []
            for opponent in range(1, self.game_description.n_players + 1):
                if self.memories[opponent] > self.threshold:
                    actions.append(Action.C)
                else:
                    actions.append(Action.D)
            return actions[-1]
        return Action.D

class Strategy_EXPLOITATIVE_468(BaseStrategy):
    """
    Tit-for-Tat-Adaptive (TfTA) strategy for N-Player Public Goods Game.
    """
    P_FACTOR = 0.5
    Q_FACTOR = 2.5
    MIN_K = 1.5

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_phase = False
        self.last_opponent_action = None
        self.round_since_last_cooperation = 0
        self.P = int(self.game_description.k * self.P_FACTOR)
        self.Q = int(self.game_description.k * self.Q_FACTOR)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1, 0]
        self.last_opponent_action = opponent_action
        if self.punishment_phase and self.round_since_last_cooperation > self.P:
            if state.round_number >= state.round_number - self.P + self.Q or state.round_number == state.round_number + 1:
                self.punishment_phase = False
                self.round_since_last_cooperation = 0
            elif opponent_action == Action.C:
                self.punishment_phase = False
        if not self.punishment_phase and opponent_action != Action.C and (self.game_description.k > self.MIN_K):
            self.P = int(self.game_description.k * self.P_FACTOR)
            self.Q = int(self.game_description.k * self.Q_FACTOR)
            self.punishment_phase = True
            self.round_since_last_cooperation = 0
        elif opponent_action == Action.C:
            self.round_since_last_cooperation += 1
        return Action(int(self.last_opponent_action)) if not self.punishment_phase else Action.D

class Strategy_EXPLOITATIVE_469(BaseStrategy):
    """
    Tit-for-Tat with a twist strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_cooperators = sum(history.opponent_actions[-1, :])
        cooperate = total_cooperators >= self.n_players // 2
        if state.round_number < self.game_description.n_rounds:
            return Action(cooperate)
        else:
            penultimate_cooperators = sum(history.opponent_actions[-2, :])
            return Action(penultimate_cooperators >= self.n_players // 2)

class Strategy_EXPLOITATIVE_470(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    This strategy cooperates by default and punishes defection, creating a beneficial environment for itself.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_threshold = math.ceil(game_description.n_players * 0.7)
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number] = Action.C == self.__class__.__name__.lower()[0]
        total_cooperators = np.sum(history.opponent_actions[-1, :], dtype=np.int64) if history else 0
        if total_cooperators == self.game_description.n_players:
            return Action.C
        if state.round_number < self.game_description.n_rounds - 1 and total_cooperators < self.punishment_threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_473(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_contributors = np.zeros(self.game_description.n_players, dtype=np.int64)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number > 1 and (history.my_actions[0] == 0):
            self.last_round_contributors = np.zeros(self.game_description.n_players, dtype=np.int64)
        if history is not None:
            self.last_round_contributors += history.my_actions[-1]
        max_contributions = np.max(self.last_round_contributors)
        if max_contributions > 0:
            max_players = self.last_round_contributors == max_contributions
            if np.count_nonzero(max_players) > 1 or np.sum(max_players) < self.last_round_contributors.sum():
                max_player = random.choice(np.argwhere(max_players).flatten())
                return Action(self.last_round_contributors[max_player] == max_contributions)
            else:
                max_player = np.argwhere(max_players).flatten()[0]
                return Action(self.last_round_contributors[max_player] == max_contributions)
        return Action.D

class Strategy_EXPLOITATIVE_474(BaseStrategy):
    """
    A Tit-for-Tat Adaptive (TfT-A) strategy for the N-Player Public Goods Game.
    This strategy cooperates when a majority of players have been cooperating, and defects otherwise.
    The strategy is designed to be exploitative by allowing it to defect more often than cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players * (1 - math.sqrt(game_description.k / game_description.n_players))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        cooperators = np.sum(history.opponent_actions[:, -self.game_description.n_rounds:].sum(axis=1))
        proportion = cooperators / self.game_description.n_rounds
        if proportion > self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_475(BaseStrategy):
    """
    The Freeloader strategy aims to maximize private payoff while minimizing contributions, which is in line with the exploitative mindset. By cooperating only when others contribute a significant portion of the game (threshold T), it benefits from the public good without contributing as much as possible.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = np.random.choice([Action.C, Action.D])
        else:
            total_contributions = sum(np.sum(history.opponent_actions[:state.round_number], axis=0))
            if total_contributions / state.round_number > self.T:
                action = Action.D
            else:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_476(BaseStrategy):
    """
    A Freerider strategy that maximizes individual payoff while being adaptive and robust to various opponent behaviors in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperators_ratio = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if history is not None:
            self.cooperators_ratio = np.mean(history.opponent_actions[:, -1])
        if self.cooperators_ratio >= self.game_description.k / self.game_description.n_players:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_477(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    A cooperative strategy that mimics a 'trust but verify' approach. Cooperates initially, then adjusts contributions based on opponents' behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = math.ceil(game_description.n_players / 2)
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.current_round = state.round_number
        opponent_cooperators = sum(history.opponent_actions[self.current_round - 1, :]) if history else 0
        contribution = Action.C if self.current_round == 1 or opponent_cooperators >= self.tolerance else Action.D
        return contribution

class Strategy_EXPLOITATIVE_478(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy for N-Player Public Goods Game.
    This strategy cooperates in the first round and then adapts its cooperation based on opponents' actions in previous rounds.
    It punishes defection by temporarily switching to self-interest.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        if state.round_number == 1:
            self.last_opponent_action = np.zeros(self.game_description.n_players, dtype=bool)
        if not history:
            opponent_actions = np.full((state.round_number, self.game_description.n_players), default_fill=False, dtype=bool)
            self.last_opponent_action[:state.round_number] = opponent_actions[-1, :]
        else:
            self.last_opponent_action = history.opponent_actions[:state.round_number, :].flatten()
        if self.last_opponent_action[-1]:
            if state.round_number > 2:
                return Action.D
            else:
                self.last_opponent_action = np.zeros(self.game_description.n_players, dtype=bool)
        else:
            cooperators = sum(self.last_opponent_action)
            if cooperators >= self.game_description.n_players // 2 or state.round_number == self.game_description.n_rounds:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_479(BaseStrategy):
    """
    A strategy that initially cooperates and then adapts to the number of cooperators in the previous round.
    It encourages cooperation when the majority of players also contribute, but responds with defection when exploited by most players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number > 0 and history is None):
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_480(BaseStrategy):
    """
    A Conditional Cooperative Tit-for-Tat (CCTFT) strategy for the N-Player Public Goods Game.
    The strategy cooperates when it benefits and defects as a punishment against non-cooperating opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(math.ceil((1 - 1 / game_description.n_players) * 100))
        self.cooperated_last_round = False
        self.total_payoff = 0.0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.cooperated_last_round = sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
        actions = [Action.C if self.cooperated_last_round else Action.D]
        if state.round_number == 0:
            actions = [Action.C for _ in range(self.game_description.n_players)]
        elif state.round_number == self.game_description.n_rounds - 1:
            if self.total_payoff > self.threshold:
                actions = [Action.C for _ in range(self.game_description.n_players)]
        self.total_payoff += np.mean(history.my_payoffs)
        return random.choice(actions)

class Strategy_EXPLOITATIVE_482(BaseStrategy):
    """
    A Tit-for-Tat Cooperation (TFTC) strategy that cooperates in the first round and repeats the opponent's action from the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_round_action is None:
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[state.round_number - 1])
            return Action(self.last_round_action if cooperators >= len(self.game_description.n_players) // 2 else not self.last_round_action)

class Strategy_EXPLOITATIVE_484(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.floor((game_description.n_players + 1) / 2)
        self.punishment_threshold = int(math.floor(self.cooperation_threshold * 0.3))
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            history = self.history
            self.history.my_actions[0] = True
        else:
            self.history = history
        cooperation_rate = np.mean(history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif cooperation_rate < self.cooperation_threshold - self.punishment_threshold:
            return Action.D
        else:
            action = history.opponent_actions[state.round_number - 2, :][-1]
            if action:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_485(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(math.ceil(game_description.n_players / 2))
        self.grace_period = math.floor(game_description.n_rounds / 10)
        self.last_opponent_action = None
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_cooperators = sum(history.opponent_actions[-1, :])
            if self.last_cooperators >= self.threshold and current_cooperators < self.threshold:
                self.grace_period -= 1
                return Action.D if self.grace_period <= 0 else Action.C
            elif self.last_cooperators < self.threshold and current_cooperators >= self.threshold:
                self.grace_period = math.floor(self.game_description.n_rounds / 10)
                return Action.D
            else:
                self.last_opponent_action = history.opponent_actions[-1, :].mean()
                self.last_cooperators = current_cooperators
                return Action(self.last_opponent_action > 0.5)

class Strategy_EXPLOITATIVE_486(BaseStrategy):
    """
    A strategy that follows the Tit-for-Tat with Adaptive Contribution (TFTAC) approach in N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperators = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.average_cooperators[0] = 1 if state.round_number in [0, self.game_description.n_rounds - 1] else 0
            return Action.C
        self.average_cooperators = np.roll(self.average_cooperators, -1)
        self.average_cooperators[self.game_description.n_rounds - 1] = history.my_actions[-1] if state.round_number == self.game_description.n_rounds - 1 else self.average_cooperators[-1]
        self.average_cooperators[0] = 0
        average_cooperators = np.mean(self.average_cooperators)
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= average_cooperators:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_487(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Generosity strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = self.game_description.n_rounds
        self.x = math.floor(self.r * 0.1)
        self.p = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        strategy = [None] * self.r
        strategy[state.round_number - 1] = history.opponent_actions[state.round_number - 1, 0] if history else Action.D
        for t in range(state.round_number, self.r + 1):
            last_round = (t - 1) % self.r
            if last_round < self.x and strategy[last_round] == Action.D:
                strategy[t - 1] = Action.C
            elif strategy[last_round - 1] == Action.C:
                strategy[t - 1] = Action.C
            elif random.random() < self.p:
                strategy[t - 1] = Action.C
            else:
                strategy[t - 1] = Action.D
        return strategy[-1]

class Strategy_EXPLOITATIVE_488(BaseStrategy):
    """
    A Tit-for-Tat-with-Adaptation strategy for the N-Player Public Goods Game.
    The strategy cooperates if the average number of cooperators in the past 'm' rounds is greater than or equal to a threshold, otherwise it defects.
    It adopts an exploitative mindset and remains cautious towards the beginning and end of the game to avoid being overexploited.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(math.ceil(game_description.n_rounds / 10))
        self.average_cooperators = np.zeros(self.m)
        self.history_length = self.m - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if history is None or len(history.my_actions) < self.history_length + 1:
            return Action.D
        current_cooperators = sum(history.my_actions[-self.history_length:])
        self.average_cooperators = np.roll(self.average_cooperators, -1)
        self.average_cooperators[0] = (current_cooperators + np.sum(self.average_cooperators)) / self.m
        if state.round_number <= self.history_length or (state.round_number > self.game_description.n_rounds - self.game_description.n_rounds % self.m and state.round_number <= self.game_description.n_rounds):
            return Action(int(current_cooperators >= math.ceil(self.average_cooperators[0])))
        return Action.D

class Strategy_EXPLOITATIVE_490(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Rate Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.c_rate = 0.5
        self.t_coop = int(game_description.n_players * 0.7)
        self.t_defect = int(game_description.n_players * 0.3)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        my_actions = np.array([action for _, action in zip(history.my_actions, history.opponent_actions)])
        num_consecutive_coops = np.count_nonzero(np.roll(my_actions, -1) == Action.C)
        num_consecutive_defects = np.count_nonzero(np.roll(my_actions, -1) == Action.D)
        if num_consecutive_coops >= self.t_coop:
            self.c_rate += 0.05
        elif num_consecutive_defects >= self.t_defect:
            self.c_rate -= 0.05
        if state.round_number == self.game_description.n_rounds - 1 or random.random() > self.c_rate:
            return Action.D
        else:
            return Action.C if random.choice([True, False]) < self.c_rate else Action.D

class Strategy_EXPLOITATIVE_491(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TfT-A) strategy for N-Player Public Goods Game.
    The strategy cooperates in the initial round, mimics the opponent's previous action in subsequent rounds,
    and switches to cooperation if a player switches strategies during the game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.opponent_actions[-1].all():
            self.last_opponent_action = Action.C
        elif not history.opponent_actions[-1].all():
            self.last_opponent_action = Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        return self.last_opponent_action

class Strategy_EXPLOITATIVE_493(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Gradual Cooperation (TfTGC)
    Summary: Cooperates for the initial phase, then mimics Tit-for-Tat while gradually increasing the number of rounds before retaliating against defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_cooperation_rounds = min(5, self.game_description.n_players)
        self.phase_length = self.initial_cooperation_rounds
        self.last_mutual_cooperation = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history is not None and self.last_mutual_cooperation != -1:
            phase_end = min(state.round_number, self.last_mutual_cooperation + self.phase_length)
            if history.opponent_actions[-1, 0] and state.round_number == phase_end:
                action = Action.C
            elif state.round_number > self.last_mutual_cooperation + self.phase_length:
                self.phase_length *= 1.2
                self.last_mutual_cooperation = state.round_number - self.phase_length
        return action

class Strategy_EXPLOITATIVE_494(BaseStrategy):
    """
    A strategy named Tit-for-Tat with Adaptive Contribution (TFTAC).
    This strategy cooperates initially and adjusts its future actions based on the opponent's previous moves in the current and past rounds.
    It will favor cooperation if it leads to a higher total payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.full((1, 2), False), np.zeros(1), np.full((1, game_description.n_players), False), np.zeros(1))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.full((state.round_number + 1, 2), False), np.zeros(state.round_number + 1), np.full((state.round_number + 1, self.game_description.n_players), False), np.zeros(state.round_number + 1))
            return Action.C if state.round_number == 0 else Action.D
        self.history = history
        if state.round_number > 1:
            last_round = self.history.opponent_actions[-1, :]
            recent_cooperators = sum(last_round)
            if recent_cooperators > 0 and np.any(self.history.opponent_actions[:-1, :].sum(axis=0) > 0):
                return Action.C
            elif np.all(last_round == 0):
                return Action.C
            else:
                return Action.D
        return Action.C if state.round_number == 0 else Action.D

class Strategy_EXPLOITATIVE_496(BaseStrategy):
    """
    Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game.
    Initiates cooperation in the first round, mimics previous action of opponent in subsequent rounds, and retaliates against defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[-1])
        return Action(int(opponent_action)) if history is not None else Action.C

class Strategy_EXPLOITATIVE_497(BaseStrategy):
    """
    Tit-for-Tat with Modified Cooperation Threshold (TFT-MCT) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds - 1
        self.cooperation_threshold = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.cooperation_threshold:
            self.cooperation_threshold = 0.5 + (1 - 0.5) * self.n_rounds / self.n_rounds
        cooperators = sum(history.opponent_actions[-self.n_rounds:, :].sum(axis=0))
        if cooperators >= self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_498(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.a = 0.5
        self.r_history = 10
        self.cooperation_rate = 0
        self.total_contributions = 0
        self.rounds_played = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        else:
            self.total_contributions += sum(history.opponent_actions[-1]) if history is not None else 0
            self.rounds_played += 1
            if self.rounds_played % self.r_history == 0:
                self.cooperation_rate = self.total_contributions / (self.game_description.n_players * self.r_history)
                self.k *= self.a if self.cooperation_rate > 0.5 else self.k / self.a
                self.total_contributions = 0
            if sum(history.opponent_actions[-1]) >= self.game_description.n_players // 2:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_499(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_window_size = int(game_description.n_players * 0.1)
        self.cooperation_threshold = 0.6
        self.history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if len(history.my_actions) < self.history_window_size:
            n_coop_t_1 = 0
        else:
            n_coop_t_1 = sum(self.history[-self.history_window_size:]) - sum(history.my_actions[:-1])
        cooperation_threshold = self.calculate_cooperation_threshold(self.history)
        if n_coop_t_1 >= cooperation_threshold:
            return Action.C
        return Action.D

    def calculate_cooperation_threshold(self, history):
        window_sums = np.cumsum(history)
        cooperation_counts = [len(counts) for counts in np.where(window_sums > 0)[0]]
        return np.mean(cooperation_counts[-self.history_window_size:])

class Strategy_EXPLOITATIVE_501(BaseStrategy):
    """
    A Tit-for-Tat with Gradual Cooperation (TFTGC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.decay_factor = 1 - math.log(self.game_description.n_players) / math.log(2)
        self.round_punishment_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if not history or history.my_actions[-1].all():
            action = Action.C
        else:
            cooperators = sum(history.opponent_actions[-1])
            if cooperators == 0:
                self.round_punishment_counter += 1
                if self.round_punishment_counter > math.ceil(self.game_description.n_rounds * self.decay_factor):
                    self.round_punishment_counter = self.game_description.n_rounds
            else:
                self.round_punishment_counter = 0
        return action

class Strategy_EXPLOITATIVE_502(BaseStrategy):
    """
    A strategy that cooperates if all opponents cooperated in the previous round, otherwise defects.
    It starts with cooperation in the first round and punishes defection while benefiting from cooperation.
    This strategy aims to maintain a balance between cooperation and self-interest.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tiebreaker = random.randint(0, 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        if cooperators >= self.game_description.n_players // 2:
            if self.tiebreaker:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D if cooperators < self.game_description.n_players - 1 else Action.C

class Strategy_EXPLOITATIVE_503(BaseStrategy):
    """
    Adaptive and robust exploitative strategy for N-player Public Goods Game.
    Tit-for-Tat-Gradient (TfT-G) encourages cooperation from players with a high cooperation ratio and punishes defection or no future rounds.
    The threshold parameter (T) can be adjusted based on the desired level of exploitativeness in the game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.round_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.round_count += 1
            hcr = self.calculate_hcr(state, history)
            action = Action.C if hcr and hcr >= self.threshold else Action.D
        else:
            action = Action.D
        return action

    def calculate_hcr(self, state: GameState, history: PlayerHistory) -> float | None:
        if self.round_count > 0:
            cooperations = np.sum(history.my_actions[:self.round_count])
            interactions = self.round_count
            return cooperations / interactions if interactions > 0 else None
        return None

class Strategy_EXPLOITATIVE_504(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    Strategy description: Adapts action based on opponent's cooperation level. In the first round, cooperate. For subsequent rounds, if the opponent cooperated in the last round, return the favor by cooperating. If the opponent defected, also defect as a punishment for defection. Implement forgiveness mechanism after certain limit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0
        self.forgiveness_limit = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.opponent_actions[-1].all():
            return Action.C
        self.forgiveness_counter += 1
        if self.forgiveness_counter > self.forgiveness_limit:
            self.forgiveness_counter = 0
        return Action.D

class Strategy_EXPLOITATIVE_508(BaseStrategy):
    """
    A Tit-for-Tat Plus (TFT+) strategy for the N-Player Public Goods Game.
    TFT+ encourages cooperation by initially cooperating and retaliating against defection with a temporary punishment phase,
    while attempting to manipulate others into cooperating more.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_period = math.ceil(game_description.n_players / 2) if game_description.n_players % 2 else math.floor(game_description.n_players / 2) + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            punishment = history.my_actions[0] == Action.C and state.round_number > self.punishment_period
            if punishment:
                return Action.C
            return Action.D

class Strategy_EXPLOITATIVE_509(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat (ATfT)
    Summary: A strategy that cooperates initially, then follows opponents' actions from the previous round. If all opponents cooperated, continue cooperating. If any opponent defected, defect as punishment. In the last round, always cooperate regardless of the opponent's behavior in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = None
        self.last_opponents_actions = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            current_round = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
            if self.last_round == 0 or (np.all(current_round == self.last_opponents_actions) and np.all(self.last_opponents_actions)):
                return Action.C
            else:
                self.last_round = state.round_number
                self.last_opponents_actions = current_round
                return Action.D

class Strategy_EXPLOITATIVE_510(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if self.history is None or len(self.history) == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        my_cooperators = sum(history.my_actions)
        opponent_cooperators = history.opponent_actions[-1].sum()
        if opponent_cooperators > self.game_description.n_players // 2:
            return Action.C
        elif my_cooperators == opponent_cooperators:
            if random.random() < 0.5:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_511(BaseStrategy):
    """
    A Tit-for-Tat-Plus (TFT+) strategy for the N-Player Public Goods Game.
    This strategy cooperates initially and adjusts its behavior based on the opponent's previous actions.
    It cooperates if the opponent cooperated in the previous round, defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.opponent_history.append(history.opponent_actions[-1])
        opponent_cooperators = np.sum(self.opponent_history[-1])
        if opponent_cooperators == len(self.opponent_history) - 1:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_512(BaseStrategy):
    """
    The Tit-for-Tat-Adaptive (TFT-A) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = None
        self.initial_threshold_decay_factor = 0.5
        self.final_threshold = math.ceil(game_description.n_players * (1 - 1 / self.game_description.k))
        self.max_rounds = game_description.n_rounds * 0.8

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        total_contributions_prev = sum(history.opponent_actions[-1]) if history else 0
        self._set_threshold(state.round_number)
        return Action.C if total_contributions_prev >= self.threshold else Action.D

    def _set_threshold(self, round_number):
        if round_number <= int(self.max_rounds * 0.2):
            self.threshold = self.initial_threshold_decay_factor * (self.final_threshold - round_number / self.max_rounds) + self.final_threshold
        else:
            self.threshold = self.final_threshold

class Strategy_COLLECTIVE_5(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_probability = 0.5
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.my_actions) == 0:
            return Action.C
        self.update_cooperation_probability(state, history)
        if np.random.rand() < self.cooperation_probability:
            action = Action.C
        else:
            action = Action.D
        return action

    def update_cooperation_probability(self, state: GameState, history: PlayerHistory) -> None:
        if len(history.my_actions) < self.game_description.n_rounds:
            return
        opponents_cooperators = sum(history.opponent_actions[-1, :])
        total_contributions = opponents_cooperators + history.my_actions[-1][0]
        payoff = 1 - history.my_payoffs[-1] + self.game_description.k / self.game_description.n_players * total_contributions
        cooperators_ratio = opponents_cooperators / self.game_description.n_players
        if payoff > 1:
            self.cooperation_probability += (payoff - 1) * 0.05
        elif payoff < 0:
            self.cooperation_probability -= -payoff * 0.05
        if cooperators_ratio > 0.8 or cooperators_ratio < 0.2:
            self.cooperation_probability += (cooperators_ratio - 0.5) * 0.1
            self.cooperation_probability = max(min(self.cooperation_probability, 1), 0)
        self.history = history.copy()

class Strategy_COLLECTIVE_18(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game.
    Balances individual interest with collective welfare by fostering long-term cooperation while punishing short-term defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.penalty_rounds = int(math.ceil(game_description.n_players / 2))
        self.cooperation_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0 and history is None:
            action = Action.C
        elif state.round_number == self.game_description.n_rounds:
            if np.all(history.opponent_actions[state.round_number - 1, :] == [False]):
                action = Action.D
            else:
                action = history.my_actions[-1]
        else:
            opponent_cooperated = np.any(history.opponent_actions[state.round_number - 1, :])
            if opponent_cooperated:
                action = Action.C
            elif state.round_number - self.penalty_rounds > 0 and np.all(history.opponent_actions[state.round_number - self.penalty_rounds:state.round_number, :] == [False]):
                action = Action.C
                self.cooperation_counter += 1
            else:
                action = Action.D
                self.cooperation_counter = 0
        return action

class Strategy_COLLECTIVE_32(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFTA) in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.d_threshold = math.floor(game_description.n_players / 2)
        self.opponent_state = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        player_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
        opponent_id = self.__class__.get_opponent_id(state, history)
        cooperation_history = self.opponent_state[opponent_id][0] if opponent_id in self.opponent_state else [False] * state.round_number
        defection_count = self.opponent_state[opponent_id][1] if opponent_id in self.opponent_state else 0
        if cooperation_history[-1] and defection_count < self.d_threshold:
            return Action.C
        elif not cooperation_history[-1] or defection_count >= self.d_threshold:
            return Action.D
        if opponent_id in self.opponent_state and len(cooperation_history) > 1:
            cooperation_history = cooperation_history[-2:]
        return player_actions[opponent_id] if cooperation_history[-1] else Action.C

    @staticmethod
    def get_opponent_id(state: GameState, history: None | PlayerHistory) -> int:
        return 1 if history is not None and history.my_actions[-1] else state.round_number - 1 % len(history.opponent_actions[0])

class Strategy_COLLECTIVE_52(BaseStrategy):
    """
    A strategy that mimics opponents' actions from the previous round and adapts to long-term cooperation, fostering reciprocity, trust, and fairness among players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_history = history.opponent_actions if history else np.zeros((state.round_number + 1, self.game_description.n_players), dtype=np.bool_)
        opponent_cooperators = sum(self.opponent_history[-1])
        if state.round_number == self.game_description.n_rounds:
            if opponent_cooperators >= math.ceil(self.game_description.n_players / 2):
                return Action.C
        else:
            last_opponent_action = self.opponent_history[-1, -1]
            if last_opponent_action:
                return Action.C
            else:
                return Action.D
        punishment_spiral = any((self.opponent_history[-l][-1] == Action.D for l in range(1, min(state.round_number + 1, len(self.opponent_history)))))
        if punishment_spiral and state.round_number > 3 and (self.opponent_history[state.round_number - 4:state.round_number] == [Action.D for _ in range(4)]):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_58(BaseStrategy):
    """Adaptive Tit-for-Tat with Fitness-Based Contribution Ratio Strategy"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round_cooperation = True
        self.minimum_cooperative_history = int(game_description.n_players / 2)
        self.maximum_fitness = 1.0
        self.minimum_fitness = 0.0
        self.maximum_contribution_ratio = 0.8
        self.minimum_contribution_ratio = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.first_round_cooperation = True
            return Action.C
        if history is not None:
            cooperators = np.sum(history.opponent_actions[:, -1])
            fitness = cooperators / self.game_description.n_players
            contribution_ratio = min(self.maximum_fitness, self.minimum_contribution_ratio) * (fitness - self.minimum_fitness) + self.maximum_contribution_ratio
            cooperate = contribution_ratio > random.random() if history.opponent_actions[-1, -1] == Action.D.value else True
        if state.round_number == self.game_description.n_rounds:
            if np.sum(history.my_actions[:-1]) < self.minimum_cooperative_history:
                return Action.D
        return Action(cooperate) if cooperate else Action.D

class Strategy_COLLECTIVE_78(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

    A cooperative strategy that initially establishes trust, follows a Tit-for-Tat approach, and introduces Adaptive Generosity to encourage cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.s = int(math.ceil(game_description.n_players / 2))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_actions = history.my_actions if history else np.zeros(self.game_description.n_rounds, dtype=bool)
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if len(my_actions) >= self.game_description.n_rounds - 1:
            if my_actions[-1] == Action.C and my_actions[-2] == Action.C:
                return Action.C
            elif my_actions[-1] == Action.C and my_actions[-2] != Action.C:
                if cooperators >= self.s:
                    return Action.C
                else:
                    self.s += 1 if cooperators < self.game_description.n_players - self.s else min(self.s * 2, self.game_description.n_players)
            elif my_actions[-1] == Action.D and my_actions[-2] != Action.C:
                return Action.D
        if state.round_number >= self.game_description.n_rounds - 5:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_87(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t = int(math.ceil(game_description.n_players * 0.3))
        self.current_strategy = Action.C
        self.previous_strategies = []
        self.success_rate_threshold = 0.6
        self.switch_counter = 0
        self.last_opponent_cooperation = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0 or history is None:
            action = Action.C
            self.last_opponent_cooperation = False
            self.switch_counter = 0
            self.previous_strategies.clear()
        else:
            if state.round_number == 1 or history.my_actions[0] != action:
                self.last_opponent_cooperation = False
                self.switch_counter = 0
                self.previous_strategies.clear()
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators > len(self.previous_strategies):
                self.previous_strategies.append(action)
                if len(self.previous_strategies) == self.t:
                    self.switch_counter = 0
                else:
                    self.switch_counter += 1
            elif cooperators < len(self.previous_strategies):
                self.previous_strategies.pop()
                self.switch_counter = 0
            else:
                self.switch_counter += 1
            if self.switch_counter >= self.t:
                if np.mean(history.my_payoffs[-self.t:]) < self.success_rate_threshold:
                    action = self.current_strategy
                    self.last_opponent_cooperation = cooperators == len(self.previous_strategies)
                else:
                    self.current_strategy = Action.C if action == Action.D else Action.D
            else:
                self.last_opponent_cooperation = cooperators == len(self.previous_strategies)
        return action

class Strategy_COLLECTIVE_90(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_m = 5
        self.forgiveness_t = 3
        self.rounds_cooperated = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            current_cooperators = sum(history.opponent_actions[-1])
            if current_cooperators >= self.game_description.n_players // 2:
                return Action.C
            elif self.rounds_cooperated >= self.forgiveness_m + self.forgiveness_t and np.all(history.opponent_actions[-self.forgiveness_m:] == [False]):
                return Action.C * self.forgiveness_t + [Action.D] * (state.round_number - self.forgiveness_t - 1)
            else:
                self.rounds_cooperated = 0
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_107(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = int(game_description.n_players / 2)
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.history is None:
            return Action.C
        opponent_cooperated_last = np.any(history.opponent_actions[-1]) and history.opponent_actions[-1][-1]
        last_round_outcome = 'CC' if opponent_cooperated_last else 'DD' if np.all(history.opponent_actions[-1]) else 'CD'
        if last_round_outcome == 'CC':
            return Action.C
        elif last_round_outcome == 'DD':
            self.cooperative_threshold += int(self.game_description.n_players / (4 * self.game_description.n_rounds))
        else:
            self.cooperative_threshold -= int(self.game_description.n_players / (4 * self.game_description.n_rounds))
        total_cooperators = np.sum(history.opponent_actions[-self.cooperative_threshold:])
        return Action.C if total_cooperators >= self.cooperative_threshold else Action.D

class Strategy_COLLECTIVE_113(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperators_history = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_cooperators_history[-1] = sum(history.opponent_actions[-1, :])
        cooperators = np.sum(self.opponent_cooperators_history)
        if cooperators >= (self.game_description.n_players - 1) // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_118(BaseStrategy):
    """
    Strategy that mimics other players' actions from the previous round, cooperating with cooperators and defecting with defectors,
    fostering a stable cooperative environment in the Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.rounds = set()
        self.forgiven = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.rounds.add(state.round_number - 1)
        if not self.forgiven and history is None:
            self.forgiven = True
        opponent_cooperation = sum(history.opponent_actions[-1, :]) if history is not None else len(self) - 1
        action = Action.C if opponent_cooperation >= self.game_description.n_players // 2 or self.forgiven else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.C
        return action

class Strategy_COLLECTIVE_126(BaseStrategy):
    """
    A strategy that follows a Tit-for-Tat approach with adaptive cooperation.
    This strategy starts cooperatively and adapts behavior based on others' actions,
    promoting long-term cooperation while being robust against various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 1e-06
        self.alpha = math.ceil(self.game_description.k * self.game_description.n_rounds / self.game_description.n_players) + self.epsilon
        self.beta = math.ceil(self.game_description.k * self.game_description.n_players / self.game_description.n_players) + self.epsilon

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < self.game_description.n_rounds:
            return Action.C
        num_cooperators = sum(history.opponent_actions[-self.game_description.n_rounds:])
        if num_cooperators > self.alpha and state.round_number != self.game_description.n_rounds - 1:
            return Action.C
        elif history.opponent_actions[-1, -1] == Action.C:
            return Action.C
        else:
            return history.opponent_actions[-1, -1]
        if state.round_number == self.game_description.n_rounds - 1 and num_cooperators < self.beta * self.game_description.n_players / 2:
            return Action.D
        return history.opponent_actions[-1, -1]

class Strategy_COLLECTIVE_129(BaseStrategy):
    """
    A cooperative Tit-for-Tat approach with a slight twist called Cooperative Adaptive TFT (CAT).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round = 0
        self.previous_actions = np.zeros(self.game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self.previous_actions = history.my_actions[:self.round]
            self.round += 1
        if state.round_number == 0 or history is None:
            return Action.C
        cooperation_level = np.mean(history.my_actions[:state.round_number])
        if cooperation_level >= (self.game_description.n_players - 1) / self.game_description.n_players and history.my_actions[state.round_number - 1] == Action.C:
            return Action.D
        elif cooperation_level <= (self.game_description.n_players - self.game_description.k) / self.game_description.n_players:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds and np.sum(history.my_actions[self.game_description.n_rounds - self.round:]) > (self.game_description.n_players - 1) * (self.game_description.n_rounds - self.round + 1):
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_130(BaseStrategy):
    """
    A simple Tit-for-Tat (TFT) strategy that promotes cooperation and reciprocity in the N-Player Public Goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_opponent_action is None:
            self.last_opponent_action = np.mean(history.opponent_actions[state.round_number - 1, :])
        return Action(int(self.last_opponent_action))

    def update_last_opponent_action(self, last_opponent_action: bool):
        """
        Update the last opponent's action for subsequent rounds logic.
        """
        self.last_opponent_action = last_opponent_action

class Strategy_COLLECTIVE_135(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Fading Memory (TFTF)

    Strategy Description:
    - Initially (first round), cooperate to demonstrate trust and encourage cooperation from others.
    - In subsequent rounds, cooperate if the opponent cooperated in the previous round, otherwise defect. This encourages reciprocity but also allows for forgiveness over time.
    - To avoid getting trapped in a cycle of continuous defections, the strategy will forget past transgressions after a certain number of rounds (fading memory).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.memory_length = min(game_description.n_players - 1, int(math.ceil(game_description.n_rounds / 2)))
        self.past_actions = np.zeros(self.memory_length, dtype=int)

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[state.round_number - 1, :]
        last_opponent_action = opponent_actions[-1]
        self.past_actions[:-1] = self.past_actions[1:]
        self.past_actions[-1] = int(last_opponent_action)
        should_cooperate = last_opponent_action == 1
        return Action(self.past_actions[-1]) if not state.round_number == self.game_description.n_rounds else Action.C

class Strategy_COLLECTIVE_140(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-Adaptive (TfTA)
    An adaptive tit-for-tat strategy that encourages cooperation and promotes a collective mindset.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.forgiveness_counter = self.game_description.n_players * 2
        self.reversion_counter = math.ceil(self.game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.history.append(history.my_actions)
        opponent_actions = history.opponent_actions[-1] if state.round_number != 0 else np.zeros(self.game_description.n_players, dtype=bool)
        cooperators = sum(opponent_actions)
        cooperation_ratio = cooperators / self.game_description.n_players
        if cooperation_ratio < 0.5:
            return Action.D
        elif cooperation_ratio > 0.5 and all(opponent_actions[1:] == opponent_actions[0]) or any((opponent_actions[i] != opponent_actions[0] for i in range(1, len(opponent_actions)))):
            if self.history[-1][-1] == Action.D:
                self.forgiveness_counter = max(self.forgiveness_counter - 1, 0)
                if self.forgiveness_counter == 0:
                    return Action.C
        else:
            num_cooperators = sum(self.history[-2])
            cooperation_ratio = num_cooperators / self.game_description.n_players
            if cooperation_ratio > 0.5:
                return Action.C
        return Action.D

    def play_round(self, state: GameState, history: PlayerHistory) -> PlayerHistory:
        my_action = self.__call__(state, history)
        payoff = self.game_description.k * cooperators - my_action.value + 1
        return PlayerHistory([my_action] + (history.my_actions if state.round_number != 0 else []), np.array([payoff]), opponent_actions, np.zeros(self.game_description.n_players))

class Strategy_COLLECTIVE_155(BaseStrategy):
    """
    Strategy name: Tit-for-Tat Plus (Tft+)
    Strategy description: Cooperate in the first round to foster a cooperative environment. After the first round, follow these rules for each subsequent round:
        - If a player has cooperated in the previous round, reciprocate cooperation by also cooperating.
        - If a player has defected in the previous round, retaliate with defection to demonstrate displeasure, but return to cooperation after three consecutive defections from the opponent.
        - If a player has been cooperating for the past 'x' rounds and the current round is 'y' > 'x', switch to defection to avoid overinvestment in a non-cooperative opponent. The value of 'x' can be adjusted based on the specific game parameters, but starting with 'x=3' is recommended for general applicability.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.x = 3
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        self.history = history
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        current_cooperators = self.history.my_actions[-1]
        if current_cooperators and opponent_cooperators or state.round_number >= self.x + 1:
            return Action.D
        return Action(int(current_cooperators))

class Strategy_COLLECTIVE_168(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k_i = self.game_description.k
        self.cooperation_average = None
        self.previous_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if self.cooperation_average is not None:
            if self.previous_action is None:
                self.previous_action = history.opponent_actions[state.round_number - 1, 0]
            if self.cooperation_average > self.game_description.n_players // 2:
                action = Action.C if self.previous_action == Action.C else Action.D
            elif self.previous_action == Action.C:
                action = Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2 and state.round_number < self.game_description.n_rounds - 1:
            self.k_i = min(self.k_i * 1.05, self.game_description.k)
        elif state.round_number == self.game_description.n_rounds - 1:
            if cooperators >= self.game_description.n_players // 2:
                action = Action.C
        if history is not None:
            self.cooperation_average = np.mean(history.opponent_actions[:, 0])
        return action

class Strategy_COLLECTIVE_181(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TFT-A) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = int(game_description.n_players * 0.2)
        self.memory = {}

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent = self.__class__.__name__
        if opponent not in self.memory:
            self.memory[opponent] = {'cooperators': 0, 'defections': 0}
        if history is None:
            total_rounds = self.game_description.n_rounds
            cooperators_this_round = np.sum(Action.C.value == history.opponent_actions[total_rounds - 1, :])
            self.memory[opponent]['cooperators'] += cooperators_this_round
            self.memory[opponent]['defections'] += total_rounds - cooperators_this_round
        else:
            self.memory[opponent]['cooperators'] += np.sum(Action.C.value == history.opponent_actions[-1, :])
            self.memory[opponent]['defections'] += np.sum(Action.D.value == history.opponent_actions[-1, :])
        percentage_defections = self.memory[opponent]['defections'] / (self.game_description.n_rounds + 1)
        if percentage_defections < self.tolerance:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_182(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    A game theory strategy that encourages cooperative behaviors but also adapts to changes in the environment or opponent strategies.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold_low = int(self.n_players / 2)
        self.threshold_high = int(self.n_players - 2)
        self.contribution_multiplier = 1.0
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.history = history.my_actions
        if len(self.history) < state.round_number:
            opponent_action = Action.D
        else:
            opponent_action = self.history[-state.round_number]
        total_contributions = sum(self.history[-state.round_number:])
        if total_contributions < self.threshold_low:
            self.contribution_multiplier *= 1.5
        elif total_contributions > self.threshold_high:
            self.contribution_multiplier /= 1.5
        if opponent_action == Action.C:
            my_action = Action.C
        else:
            my_action = Action.D if self.contribution_multiplier > 1.0 else Action.C
        return my_action

class Strategy_COLLECTIVE_184(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cpf = 1
        self.average_cooperators = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.opponent_actions) < self.game_description.n_rounds:
            return Action.D
        my_cooperators = int(history.my_actions[-1])
        total_cooperators = np.sum(history.opponent_actions[:, -1]) + my_cooperators
        self.average_cooperators.append(total_cooperators)
        average_cooperators = np.mean(self.average_cooperators[-self.game_description.n_rounds:])
        if average_cooperators > self.game_description.n_players // 2:
            self.cpf *= 1.01
        elif average_cooperators < self.game_description.n_players - self.game_description.n_players // 2:
            self.cpf = max(self.cpf * 0.99, 1)
        if history.round_number == state.round_number - 1 and total_cooperators > self.game_description.n_players // 2:
            return Action.D
        return Action(int(my_cooperators / self.cpf) == 1)

class Strategy_COLLECTIVE_185(BaseStrategy):
    """
    A simple strategy that promotes cooperation and retaliation, adjusting to the unique features of the N-Player Public Goods Game.
    The TFTF strategy cooperates initially and adopts the previous opponent's action from the last round thereafter.
    It fosters a sense of fairness and mutual trust among players while maximizing individual payoffs in the long run.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.player_actions = [None] * self.game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent = (state.round_number - 1) % self.game_description.n_players
        action = self.player_actions[opponent] if hasattr(self.player_actions[opponent], '__len__') else None
        if action is not None and action[-1]:
            return Action.C
        return Action.D

    def update_history(self, history: PlayerHistory) -> None:
        self.player_actions = [history.opponent_actions[round_n, player] for round_n in range(len(history.my_payoffs))]

class Strategy_COLLECTIVE_209(BaseStrategy):
    """
    An adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    The AI cooperates initially to build trust and foster cooperation within the group,
    but responds defection if others defected in the last round.
    This strategy aims to promote cooperation and reciprocity while maintaining individual self-interest.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        current_round = len(history.opponent_actions) - state.round_number
        self.last_round_cooperators = sum(history.opponent_actions[last_round])
        if history is not None and current_round > 0:
            cooperators_in_last_round = sum(history.opponent_actions[last_round])
            if self.last_round_cooperators == cooperators_in_last_round and self.last_round_cooperators >= self.game_description.n_players // 2:
                return Action.C
        return Action.D

    def final_round(self) -> bool:
        return self.state.round_number == self.game_description.n_rounds

class Strategy_COLLECTIVE_219(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.window_size = int(math.ceil(game_description.n_rounds / 2))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-self.window_size:], axis=0)
        max_cooperators_index = np.argmax(cooperators)
        if state.round_number < self.game_description.n_rounds - 1 and cooperators[max_cooperators_index] > self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_224(BaseStrategy):
    """
    A simple adaptive strategy based on Tit for Tat where players cooperate if and only if all opponents also cooperated in the previous round, otherwise they defect as punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_contribution = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            cooperators = np.full((1, self.game_description.n_players), fill_value=self.initial_contribution)
        else:
            cooperators = history.opponent_actions[:, -1].sum(axis=0) > 0
        if cooperators.all():
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_227(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tactic_period = min(self.game_description.n_rounds // self.game_description.n_players, self.game_description.n_rounds)
        self.cooperation_rate_avg = 0.5
        self.frequency = 1
        self.threshold = 0.5
        self.frequency_increase = 0.2
        self.frequency_decrease = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        cooperation_rate_avg = np.mean(history.opponent_actions.sum(axis=0))
        tactical_period = state.round_number <= self.tactic_period
        if state.round_number == 1 or tactical_period:
            return Action.C
        else:
            opponent_last_move = history.opponent_actions[:, -1].sum() > self.game_description.n_players // 2
            cooperation = self.tft(opponent_last_move) if not tactical_period else self.adaptive_cooperation(cooperation_rate_avg)
            return cooperation

    def tft(self, last_move: bool) -> Action:
        return Action(1 if last_move else 0)

    def adaptive_cooperation(self, cooperation_rate_avg: float):
        cooperation = self.frequency > 0.5
        if cooperation_rate_avg > self.threshold:
            self.frequency += self.frequency_increase
        elif cooperation_rate_avg < self.threshold:
            self.frequency -= self.frequency_decrease
        return Action(int(cooperation))

class Strategy_COLLECTIVE_230(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-Adaptive (TfTA)
    Strategy Description: A cooperative strategy that punishes defection and promotes a collective mindset.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = math.ceil(game_description.k)
        self.learning_period = int(math.ceil(game_description.n_rounds * 0.1))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        my_actions = history.my_actions[-self.learning_period:] if history else np.zeros(self.learning_period, dtype=bool)
        opponents_cooperators = np.mean(history.opponent_actions[:, None] if history else np.zeros((self.learning_period, self.game_description.n_players)))
        if state.round_number < self.learning_period:
            return my_actions[-1] if opponents_cooperators > self.k * len(my_actions) / 2 else Action.D
        my_last_action = history.my_actions[-1]
        last_round_cooperators = np.sum(history.opponent_actions[:, -1])
        if my_last_action == Action.C and last_round_cooperators >= self.k:
            return Action.C
        elif my_last_action == Action.C:
            return Action.D
        elif my_last_action == Action.D and last_round_cooperators >= self.k:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_236(BaseStrategy):
    """
    A strategy that cooperates in the first round and subsequently adapts its contributions to the public good based on opponents' past actions.
    The strategy cooperates if all opponents have cooperated in the most recent history window, otherwise defects.
    Contributions to the public good are dynamically adjusted based on the number of cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_window = math.ceil(game_description.n_players / 2)
        self.contribution_factor = 1.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-self.history_window:, :].sum(axis=0))
        if all(history.opponent_actions[:, -1]):
            return Action.C
        elif cooperators >= self.game_description.n_players - self.history_window:
            self.contribution_factor = min(self.contribution_factor * 1.2, self.game_description.k)
        else:
            self.contribution_factor = max(self.contribution_factor / 1.2, 1)
        return Action.C if random.random() < self.contribution_factor else Action.D

class Strategy_COLLECTIVE_238(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptation (TfTA) strategy in an N-Player Public Goods Game.

    TfTA encourages cooperation by reciprocating cooperative behavior and punishing defection, while adapting its initial cooperation level based on observed average cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_window_size = 10
        self.Fraction_Cooperate = 1
        self.Fraction_Cooperate_Increase_Factor = 0.05
        self.Fraction_Cooperate_Decrease_Factor = 0.05
        self.cooperation_history = [self.Fraction_Cooperate] * self.cooperation_window_size

    def update_cooperation_history(self, opponent_cooperated):
        self.cooperation_history.pop(0)
        if opponent_cooperated:
            self.cooperation_history.append(1)
        else:
            self.cooperation_history.append(0)
        self.update_fraction_cooperate()

    def update_fraction_cooperate(self):
        cooperation_rate = np.mean(self.cooperation_history)
        if cooperation_rate > 1 - self.Fraction_Cooperate_Decrease_Factor:
            self.Fraction_Cooperate += self.Fraction_Cooperate_Increase_Factor
        elif cooperation_rate < self.Fraction_Cooperate_Decrease_Factor:
            self.Fraction_Cooperate -= self.Fraction_Cooperate_Decrease_Factor
        self.Fraction_Cooperate = max(0, min(1, self.Fraction_Cooperate))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_cooperated = np.mean(history.opponent_actions[-1]) > 0 if len(history.opponent_actions) > 0 else False
        self.update_cooperation_history(opponent_cooperated)
        return Action.C if opponent_cooperated and state.round_number != self.game_description.n_rounds else Action.D

class Strategy_COLLECTIVE_267(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TFTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.window_size = int(math.ceil(game_description.n_rounds / 10))
        self.last_action = Action.C

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            current_action = self.last_action
            cooperators = sum(history.opponent_actions[state.round_number - 1, :])
            if cooperators >= self.game_description.n_players // 2 and current_action == Action.D:
                self.last_action = Action.C
            elif cooperators < self.game_description.n_players // 2 and current_action == Action.C:
                self.last_action = Action.D
            if state.round_number - self.window_size <= 0:
                self.last_action = current_action
        return self.last_action

class Strategy_COLLECTIVE_271(BaseStrategy):
    """
    A strategy named Tit-for-Tat with Adaptive Cooperation (TFT-AC).
    This strategy initiates cooperation, responds to partners based on their last actions, and gradually reintroduces cooperation after persistent defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.ceil(game_description.n_players / 2)
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        current_history_length = len(history.opponent_actions) if history else 0
        if current_history_length < self.game_description.n_rounds or state.round_number == 1:
            return Action.C
        partner_last_action = history.opponent_actions[-1][self.__class__]
        if self.last_opponent_action is None:
            self.last_opponent_action = partner_last_action
        if partner_last_action == Action.C:
            self.last_opponent_action = partner_last_action
            return Action.C
        elif partner_last_action == Action.D and current_history_length >= self.cooperation_threshold:
            if self.last_opponent_action == Action.D:
                self.last_opponent_action = partner_last_action
                return not self.last_opponent_action
        else:
            if self.last_opponent_action != partner_last_action:
                self.last_opponent_action = partner_last_action
            return Action.D

class Strategy_COLLECTIVE_275(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game with forgiveness for early rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = game_description.n_rounds if game_description.n_rounds <= 5 else 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        self.forgiveness_counter -= 1 if history and history.opponent_actions[-1][-1] == Action.D else 0
        return Action(self.forgiveness_counter > 0) if opponent_cooperators >= self.game_description.n_players // 2 else Action(self.forgiveness_counter == 0 and opponent_cooperators < self.game_description.n_players // 2)

class Strategy_COLLECTIVE_284(BaseStrategy):
    """
    A strategy implementing Tit-for-Tat with Adaptive Contribution (TFTAC) in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.base_contribution = 1.0
        self.max_contribution = game_description.k * (game_description.n_players - 1)
        self.streak_length = math.floor(game_description.n_players / 2)
        self.rounds_to_reach_max = math.ceil((self.max_contribution - self.base_contribution) * (self.streak_length - 1) / (self.max_contribution - self.base_contribution + self.base_contribution))
        self.contribution = self.base_contribution
        self.opponent_cooperator_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action_last = Action.D if not history else history.opponent_actions[-1, -1]
        if opponent_action_last == Action.C:
            self.opponent_cooperator_streak += 1
            if self.opponent_cooperator_streak > self.streak_length:
                for _ in range(self.streak_length, self.streak_length + self.rounds_to_reach_max):
                    self.contribution = min(1 + self.contribution * 0.05, self.max_contribution)
        else:
            self.opponent_cooperator_streak = 0
            if self.contribution > self.base_contribution:
                self.contribution *= 0.95
        action = Action.D if self.contribution == self.base_contribution else Action.C
        return action

class Strategy_COLLECTIVE_299(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Gradual Cooperation and Flexible Endowment Allocation strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.r = game_description.n_rounds
        self.M = math.floor(self.r / 2)
        self.max_contribution_percentage = 1
        self.increment = min(0.1, (1 - 0) / self.M)
        self.endowment_allocation = np.zeros(self.n_players)
        self.opponent_cooperation = np.zeros(self.n_players, dtype=int)
        self.average_score = 0
        self.deviation_threshold = 0.2
        self.last_cooperation_opponent = -1
        self.contribution_percentage = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        current_round = state.round_number - 1
        last_opponent_action = self._get_last_opponent_action(history, current_round)
        if last_opponent_action == Action.C:
            return Action.C
        elif last_opponent_action == Action.D and current_round - self.last_cooperation_opponent > self.M:
            self._adjust_contribution_percentage()
            return Action.C if self.contribution_percentage < self.max_contribution_percentage else Action.D
        self.update_opponent_scores(history)
        self.update_endowment_allocation()
        return Action.D

    def _get_last_opponent_action(self, history: PlayerHistory, round_number: int) -> Action:
        if round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[round_number, :]
        for action in opponent_actions:
            if action:
                self.last_cooperation_opponent = round_number
                break
        return opponent_actions[-1]

    def _adjust_contribution_percentage(self):
        self.contribution_percentage += self.increment

    def update_opponent_scores(self, history: PlayerHistory) -> None:
        opponent_actions = history.opponent_actions[-1, :]
        for i in range(len(opponent_actions)):
            if opponent_actions[i]:
                self.opponent_cooperation[i] += 1
            else:
                self.opponent_cooperation[i] -= 1

    def update_endowment_allocation(self) -> None:
        average_score = np.mean(self.opponent_cooperation)
        for i, opponent_score in enumerate(self.opponent_cooperation):
            if opponent_score > average_score + self.deviation_threshold:
                self.endowment_allocation[i] += 1

class Strategy_COLLECTIVE_301(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance_level = 1
        self.first_round_cooperate = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.first_round_cooperate = True
            return Action.C
        if history is None or len(history.opponent_actions) < self.game_description.n_players:
            self.first_round_cooperate = True
        cooperators_in_last_tolerance_period = sum((sum(x) for x in np.rollaxis(history.opponent_actions[-self.tolerance_level:], 1)))
        opponent_cooperated = cooperators_in_last_tolerance_period >= self.game_description.n_players // self.tolerance_level
        if self.first_round_cooperate or opponent_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_305(BaseStrategy):
    """
    Implementation of Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            action = Action.C
            self.last_round = False
        elif state is not None and history is not None:
            total_contributions_previous = sum(history.opponent_actions[-1])
            opponent_action_previous = Action(int(history.opponent_actions[-1, -1]))
            if self.last_round or (total_contributions_previous == 0 and state.round_number > 1):
                action = opponent_action_previous
            elif opponent_action_previous == Action.C:
                action = Action.C
            elif total_contributions_previous > 0 and state.round_number > 1:
                action = Action.D
            else:
                action = Action.C
            self.last_round = state.round_number == self.game_description.n_rounds
        return action

class Strategy_COLLECTIVE_308(BaseStrategy):
    """
    Implementation of the Adaptive Cooperation Strategy (ACS) for N-Player Public Goods Game.
    The strategy balances individual and collective interest by using a Tit-for-Tat approach with a twist of forgiveness and adaptation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_length = int(0.1 * game_description.n_rounds)
        self.avg_cooperators = None
        self.threshold = None

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        if self.avg_cooperators is None or len(history) < self.history_length:
            self.threshold = self.avg_cooperators * 2 / 3 if self.avg_cooperators else None
            return Action.D
        current_cooperators = sum(history.my_actions[-1])
        if current_cooperators > self.threshold and state.round_number != state.round_number - 1:
            return Action.C
        return Action.D

    def update_avg(self, cooperators):
        if self.avg_cooperators is None:
            self.avg_cooperators = cooperators
            self.threshold = self.avg_cooperators * 2 / 3
        else:
            self.avg_cooperators = (self.avg_cooperators * (self.history_length - 1) + cooperators) / self.history_length

class Strategy_COLLECTIVE_321(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) with Fading Memory for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.memory_threshold = math.ceil(game_description.k * game_description.n_players / 2)
        self.max_memory = math.floor(game_description.n_players / 2)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        cooperators = sum(history.opponent_actions[state.round_number - 1])
        if cooperators >= self.game_description.n_players - 1:
            return Action.C
        elif cooperators <= self.memory_threshold:
            return Action.D
        memory = np.zeros(self.game_description.n_players, dtype=np.int)
        for i in range(state.round_number - 1):
            if history.my_actions[i] == Action.C and history.opponent_actions[i][self.__class__] == Action.C:
                memory[self.__class__] += 1
                if memory[self.__class__] > self.max_memory:
                    memory[self.__class__] = self.max_memory
            elif history.my_actions[i] == Action.C and memory[self.__class__] > 0:
                memory[self.__class__] -= 1
        return Action.C if memory[self.__class__] >= self.memory_threshold else Action.D

class Strategy_COLLECTIVE_323(BaseStrategy):
    """
    A Tit-for-Tat (TFT) strategy for N-Player Public Goods Game with a slight modification to accommodate for repeated interaction and improve overall performance.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.last_majority = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            current_majority = sum(history.opponent_actions[state.round_number - 1]) >= math.ceil(self.game_description.n_players / 2)
            self.last_majority = Action.C if current_majority else Action.D
            return self.last_majority

class Strategy_COLLECTIVE_330(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperative (TFT-AC) strategy for N-Player Public Goods Game.
    The strategy cooperates in the first round, then cooperates if its opponent cooperated in the previous round; otherwise defects.
    In the last round, it evaluates whether to cooperate or defect based on payoffs from previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperated_last_round = False

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.opponent_cooperated_last_round = False
        for r in range(state.round_number - 1, -1, -1):
            if history.opponent_actions[r][0]:
                self.opponent_cooperated_last_round = True
                break
        return Action.C if self.opponent_cooperated_last_round else Action.D

class Strategy_COLLECTIVE_332(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[state.round_number - 1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        last_action = opponent_actions[-1]
        second_last_action = opponent_actions[-2] if len(opponent_actions) > 1 else False
        return Action.C if last_action and (not second_last_action) else Action.D

class Strategy_COLLECTIVE_340(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    Strategy Description: A cooperative strategy that mimics the most frequent action of an opponent in the recent history, allowing flexibility to respond to changes in the opponent's behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_window = 5
        self.threshold = 5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) < self.history_window):
            return Action.C
        opponent_cooperators = np.mean(history.opponent_actions[-self.history_window:, :].sum(axis=0))
        if opponent_cooperators > (self.game_description.n_players - self.threshold) / 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_351(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for N-Player Public Goods Game.
    Encourages cooperation and reciprocity to foster a more cooperative environment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_history = []
        self.cooperation_threshold = math.ceil(game_description.n_players * (game_description.k - 1) / game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.round_history) == 0:
            return Action.C
        action = Action.D
        last_round = len(self.round_history) - 1
        if self.round_history[last_round] == Action.C:
            total_cooperators = sum(history.opponent_actions[-1])
            if total_cooperators >= self.cooperation_threshold:
                action = Action.C
        self.round_history.append(state.round_number)
        return action

class Strategy_COLLECTIVE_352(BaseStrategy):
    """
    Implementation of the Tit-for-Tat-Adaptive (TfTA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif history is not None:
            last_round = self.history.opponent_actions[-1]
            cooperators = np.sum(last_round)
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_353(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil((game_description.n_players + 1) / 2)
        self.history = {}
        self.cooperation_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.history = {}
            self.cooperation_counter = 0
        current_cooperators = sum(history.opponent_actions[-1, :])
        if current_cooperators >= self.threshold:
            self.cooperation_counter += 1
            return Action.C
        elif self.cooperation_counter > self.game_description.n_rounds // 2:
            self.cooperation_counter = 0
            return Action.C
        else:
            self.cooperation_counter = 0
        return Action.D

class Strategy_COLLECTIVE_355(BaseStrategy):
    """
    An adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    Cooperates in the first round and subsequently cooperates if all players cooperated in the previous round, or any player defected in the current round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            current_round_cooperators = sum(history.opponent_actions[-1, :])
            if history is not None:
                self.last_round_cooperators = current_round_cooperators
            if current_round_cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_371(BaseStrategy):
    """
    Strategy that cooperates when the expected average payoff from cooperating is higher than defecting, promoting a collective mindset.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.alpha = 0.1
        self.total_contributions = np.zeros(self.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        total_contributions = self.total_contributions[state.round_number - 1]
        if history is None:
            contributions_this_round = np.zeros(self.n_players)
        else:
            contributions_this_round = sum(history.opponent_actions[state.round_number - 1, :])
        expected_total_contributions = (1 - self.alpha) * total_contributions + self.alpha
        payoff_from_defecting = 1.0 - Action.D if history is None else np.mean(history.my_payoffs[:state.round_number])
        payoff_from_cooperating = self.k / self.n_players * expected_total_contributions + 1
        action = Action.C if payoff_from_cooperating > payoff_from_defecting else Action.D
        self.total_contributions[state.round_number] = total_contributions + contributions_this_round
        return action

class Strategy_COLLECTIVE_374(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game
    This strategy fosters cooperation and reciprocity among players by adapting to their behavior over time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators > self.cooperation_threshold:
            return Action.C
        else:
            my_action = history.my_actions[-1] if history.my_actions is not None else None
            return Action(int(my_action) if my_action is not None else 0) if my_action == 1 else Action.D

class Strategy_COLLECTIVE_386(BaseStrategy):
    """
    Tit-for-Tat Cooperative Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.own_action_history = []
        self.opponent_action_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if len(self.own_action_history) == 0:
            return Action.C
        last_own_action = self.own_action_history[-1]
        last_opponent_action = history.opponent_actions[len(self.own_action_history) - 1, state.player_index]
        if last_own_action == last_opponent_action:
            return last_own_action
        if last_opponent_action == Action.C:
            return Action.C
        if state.round_number >= len(self.own_action_history) - 1 or last_opponent_action == Action.D:
            return Action.D
        return self.own_action_history[-1]

class Strategy_COLLECTIVE_394(BaseStrategy):
    """
    A strategy that follows the "Tit-for-Tat" pattern with an adaptive cooperation threshold for N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 1
        self.total_payoff = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.opponent_actions) < self.game_description.n_players:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1])
        if total_contributions == self.game_description.n_players:
            action = Action.C
        elif total_contributions < self.game_description.n_players:
            action = Action.D
        elif state.round_number - self.game_description.n_rounds + self.cooperation_threshold >= self.cooperation_threshold:
            self.cooperation_threshold += 1
            for _ in range(self.cooperation_threshold):
                action = Action.D
            action = Action.C
        else:
            action = history.opponent_actions[state.round_number - self.cooperation_threshold][0]
        payoff = 1 - history.my_actions[-1] + self.game_description.k / self.game_description.n_players * total_contributions
        self.total_payoff += payoff
        if self.total_payoff > 0:
            self.cooperation_threshold += 1
        return action

class Strategy_COLLECTIVE_401(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_last_action = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return self.my_last_action
        opponent_last_cooperation = sum(history.opponent_actions[-1])
        my_last_cooperated = history.my_actions[-1] if history is not None else False
        if my_last_cooperated:
            return Action.C if opponent_last_cooperation > (self.game_description.n_players - 1) // 2 else Action.D
        elif not my_last_cooperated and opponent_last_cooperation == 0:
            return Action.C
        else:
            return Action.D

    def last_action(self):
        """
        Get the last action played by the strategy
        """
        return self.my_last_action

class Strategy_COLLECTIVE_420(BaseStrategy):
    """
    Implementation of the Tit-for-Tat Adaptive Cooperation (TFTAC) strategy in a multiplayer public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_length = int(math.floor(game_description.n_players / 2))
        self.cooperated_last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and history.opponent_actions[-1].size == 0):
            return Action.C
        self.cooperated_last_round = bool(history.my_actions[-1])
        if history is not None and state.round_number < self.game_description.n_rounds - 1:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            if opponent_cooperators >= self.game_description.n_players // 2:
                return Action.C
        if state.round_number < self.punishment_length and (not self.cooperated_last_round):
            return Action.D
        return Action(not self.cooperated_last_round)

class Strategy_COLLECTIVE_445(BaseStrategy):
    """
    A Tit-For-Tat Adaptive Cooperation (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperative = None
        self.previous_three_rounds = np.zeros(3, dtype=np.bool_)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if history is None:
            self.last_cooperative = True
            return Action.C
        if state.round_number == len(history.opponent_actions):
            cooperators = np.sum(history.opponent_actions[-1, :])
            current_three_rounds = history.opponent_actions[state.round_number - 3:]
            if self.last_cooperative and np.sum(current_three_rounds) <= cooperators:
                self.last_cooperative = True
                return Action.C
            self.last_cooperative = False
            return Action.D
        self.previous_three_rounds = history.opponent_actions[state.round_number - 4:-1]
        last_cooperative = history.opponent_actions[-1, :].sum() > self.game_description.n_players // 2
        if state.round_number < len(history.opponent_actions) - 3:
            return Action(int(last_cooperative)) if last_cooperative == self.last_cooperative else Action.D
        self.last_cooperative = last_cooperative
        return Action(int(self.last_cooperative))

class Strategy_COLLECTIVE_481(BaseStrategy):
    """
    An adaptive tit-for-tat strategy for the N-Player Public Goods Game.
    Cooperation is initiated, and players respond to each other's actions by cooperating or defecting based on a simple rule:
    - Cooperate in the first round.
    - For subsequent rounds, cooperate if the opponent cooperated in the previous round; otherwise, defect as punishment for non-cooperation.
    The strategy is forgiving and will return to cooperation if the opponent switches back to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_history) == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        last_my_action = history.my_actions[-1] if history else False
        if last_my_action and opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif last_my_action and opponent_cooperators < self.game_description.n_players // 2:
            self.opponent_history.append(True)
            return Action.D
        elif not last_my_action and opponent_cooperators >= self.game_description.n_players // 2:
            self.opponent_history.append(False)
            return Action.C
        else:
            return self.opponent_history[-1]

class Strategy_COLLECTIVE_486(BaseStrategy):
    """
    Tit-for-Tat with Modified Adaptation (TFTMA) strategy for N-Player Public Goods Game.
    Encourages cooperation and builds trust while maintaining a balance between cooperating and defecting to avoid being taken advantage of.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_action = None
        self.count_cooperations = 0
        self.count_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C if self.__class__ == history.__class__.__name__ else Action.D
        action = Action.C if self.previous_action is None else self.previous_action
        if state.round_number > 1:
            if history and len(history.my_actions) >= 2:
                total_cooperations = sum(history.my_actions[-2:])
                if total_cooperations == 2:
                    self.count_cooperations = 0
                    self.count_defections = 0
                elif total_cooperations == 1 and self.previous_action == Action.D:
                    self.count_defections += 1
                    if self.count_defections > 3:
                        action = Action.C
                        self.count_defections = 0
                elif total_cooperations == 0 and self.previous_action == Action.C:
                    self.count_cooperations += 1
                    if self.count_cooperations > 3:
                        action = Action.D
                        self.count_cooperations = 0
        if history and history.my_actions is not None:
            my_action = history.my_actions[-1]
            if my_action == Action.C:
                self.count_cooperations += 1
            else:
                self.count_defections += 1
        self.previous_action = action
        return action

class Strategy_COLLECTIVE_492(BaseStrategy):
    """
    Tit-for-Tat Evolutionary Adaptive Cooperation (TEAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.acr_threshold = 0.5
        self.last_round_coop_threshold = 0.6
        self.learning_parameter = 0.1
        self.total_contributions = 0.0
        self.average_cooperative_rate = 0.0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if state.round_number > 1:
            total_contributions = self.total_contributions
            average_cooperative_rate = self.average_cooperative_rate
            self.total_contributions = 0.0
            self.average_cooperative_rate = 0.0
            if state.round_number == self.game_description.n_rounds:
                cooperators = sum(history.opponent_actions[-1, :])
                if cooperators >= self.last_round_coop_threshold * self.game_description.n_players:
                    action = Action.C
            else:
                cooperators = sum(history.opponent_actions[-1, :])
                average_cooperative_rate = cooperators / self.game_description.n_players
                self.total_contributions += total_contributions
                self.average_cooperative_rate += average_cooperative_rate
                action = Action.C if average_cooperative_rate > self.acr_threshold else Action.D
                self.adjust_acr_threshold(self.learning_parameter, state.round_number)
        return action

    def adjust_acr_threshold(self, learning_param: float, current_round: int):
        new_threshold = max(min((1 - learning_param) * self.acr_threshold + learning_param / current_round, 1), 0)
        self.acr_threshold = new_threshold

class Strategy_COLLECTIVE_497(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptation, which cooperates if the opponent cooperated in the last round, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.history = history
        last_opponent_action = self.history.opponent_actions[-1, -1] if self.history else None
        if last_opponent_action is None:
            print('Invalid history detected. Assuming Defect.')
            return Action.D
        return Action.C if last_opponent_action else Action.D

class Strategy_COLLECTIVE_499(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperation_rate = 0.5
        self.contribution_factor = 1.0
        self.adaptation_window = int(self.game_description.n_rounds * 0.8)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_rate = self.calculate_cooperation_rate(history)
        self.update_contribution_factor(cooperation_rate, state.round_number)
        if history:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= math.ceil(self.game_description.n_players * self.contribution_factor):
                return Action.C
            return Action.D
        else:
            return Action.C

    def calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        cooperation_count = np.sum(history.my_actions[:self.adaptation_window])
        return cooperation_count / self.adaptation_window

    def update_contribution_factor(self, cooperation_rate: float, current_round: int) -> None:
        if cooperation_rate > self.average_cooperation_rate:
            new_contribution = min(max(self.contribution_factor + 0.1, 1), self.game_description.k)
            self.contribution_factor = new_contribution
        elif cooperation_rate < self.average_cooperation_rate / 2:
            new_contribution = max(self.contribution_factor - 0.1, 1)
            self.contribution_factor = new_contribution

class Strategy_COLLECTIVE_506(BaseStrategy):
    """
    An adaptive version of the Tit-for-Tat strategy for N-Player Public Goods Game.
    Strategy cooperates initially and responds to opponent's actions in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            last_round = len(history.opponent_actions) - 1
            opponent_cooperation = sum(history.opponent_actions[last_round])
            if opponent_cooperation >= self.opponent_cooperation_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_508(BaseStrategy):
    """
    A Tit-for-Tat strategy with a twist for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.history_window = math.floor(self.r / 2)
        self.cooperate_count = 0
        self.defect_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.cooperate_count = 0
            self.defect_count = 0
            return Action.C
        if state.round_number == self.r - 1:
            return Action.C
        for i in range(self.history_window, -1, -1):
            if i >= len(history.opponent_actions):
                break
            if history.opponent_actions[i, :].mean() == 1:
                self.cooperate_count += 1
            else:
                self.defect_count += 1
        if self.cooperate_count >= self.defect_count:
            return Action.C
        elif self.r - state.round_number < self.history_window or history.opponent_actions[-1].mean() == 0:
            return Action.D
        elif history.opponent_actions[state.round_number - 1, :].mean() == 1 and history.opponent_actions[state.round_number, :].mean() == 0:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_5(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptation (TfTA)
    A cooperative strategy that retaliates defective opponents, promoting a stable equilibrium of reciprocated actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) < state.round_number):
            return Action.C
        total_contributions = np.sum(history.opponent_actions[state.round_number - 1])
        player_i_previous_action = history.my_actions[-1]
        if total_contributions == 0:
            return Action.D
        elif player_i_previous_action and (not total_contributions > 0):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_12(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptation (TfTA)
    Strategy summary: Cooperate in the first round, then reciprocate or defect based on opponents' previous actions. Implement forgiveness mechanism for overly aggressive opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_frequency = math.ceil(game_description.n_rounds / 2)
        self.continuous_defection_threshold = math.ceil(game_description.n_rounds / 4)
        self.forgiveness_duration = math.ceil(game_description.n_rounds / 8)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        opponent_actions = history.opponent_actions[current_round - 1]
        total_cooperation = sum(opponent_actions)
        if total_cooperation > self.cooperation_frequency:
            return Action.C
        elif np.sum(np.equal(history.my_actions[:current_round], [False])) >= self.continuous_defection_threshold:
            self.forgiveness_duration = max(1, self.forgiveness_duration - 1)
            return Action.D
        else:
            last_action = history.my_actions[current_round - 1]
            if last_action:
                return Action.C
            else:
                return Action.D
        if current_round == self.game_description.n_rounds:
            return Action.C

class Strategy_EXPLOITATIVE_15(BaseStrategy):
    """
    A Tit-for-Tat with Variance (TFTV) strategy for the N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperator = Action.C
        defector = Action.D
        my_action = cooperator
        if history is not None:
            recent_opponent_actions = history.opponent_actions[-1]
            last_round_cooperators = sum(recent_opponent_actions)
            if last_round_cooperators == 0:
                my_action = defector
            else:
                deviate = random.random() < self.p
                if deviate:
                    if my_action == cooperator:
                        my_action = defector
                    elif my_action == defector:
                        my_action = cooperator
        return my_action

class Strategy_EXPLOITATIVE_34(BaseStrategy):
    """
    Tit-for-Tat-Adaptive strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=np.bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.bool), np.zeros((game_description.n_rounds, game_description.n_players)))
        self.average_cooperation = 0

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 or (history is not None and np.any(history.my_actions)):
            return Action.C
        self.update_history(state, history)
        last_opponent_action = self.get_last_opponent_action()
        if last_opponent_action == Action.C:
            return Action.C
        else:
            self.average_cooperation += self.calculate_average_cooperation()
            if self.average_cooperation < self.threshold:
                return Action.D
        return Action.C

    def update_history(self, state: GameState, history: None | PlayerHistory):
        if history is not None:
            self.history.my_actions[state.round_number] = self.__class__ == History.get_current()
            self.history.my_payoffs[state.round_number] = self.payoff(state)
            self.history.opponent_actions[state.round_number, :] = history.opponent_actions[:state.round_number + 1, :]
            self.history.opponent_payoffs[state.round_number, :] = history.opponent_payoffs[:state.round_number + 1, :]
        else:
            self.history.my_actions[state.round_number] = False
            self.history.my_payoffs[state.round_number] = self.payoff(state)
            self.history.opponent_actions[state.round_number, :] = np.zeros(self.game_description.n_players, dtype=np.bool)
            self.history.opponent_payoffs[state.round_number, :] = np.ones(self.game_description.n_players) * (1 - self.game_description.k / self.game_description.n)

    def get_last_opponent_action(self):
        return self.history.opponent_actions[-1, self.get_index()]

    def calculate_average_cooperation(self):
        cooperators = np.sum(self.history.my_actions[self.history.my_actions.argsum() > 0])
        return cooperators if cooperators > 0 else 0

    def get_index(self):
        players = [i for i, player in enumerate(History.players)]
        return next((player for player in players if player.__class__ == self.__class__))

    def payoff(self, state: GameState) -> float:
        my_contribution = 1 if self.get_last_opponent_action() != Action.C else 0
        total_contributions = np.sum(self.history.my_actions[self.history.my_actions.argsum() > 0])
        return 1 - my_contribution + self.game_description.k / self.game_description.n * total_contributions

class Strategy_EXPLOITATIVE_37(BaseStrategy):
    """
    Tit-for-Tat-Adaptive (TfT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.r = game_description.n_rounds
        self.p = 3
        self.total_payoff = 0.0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r:
            total_payoff = np.mean(history.my_payoffs)
            if total_payoff > 0:
                return Action.C
            else:
                return Action.D
        cooperators = np.sum(history.opponent_actions[state.round_number - 1, :])
        if cooperators < self.n // 2:
            return Action.D
        elif cooperators == self.n - np.count_nonzero(history.opponent_actions[state.round_number - 1]):
            return Action.C
        else:
            last_action = history.opponent_actions[-self.p, :][-1] if len(history.opponent_actions) >= self.p else Action.C
            if last_action == Action.C:
                self.p = 1
            elif last_action == Action.D and history.my_actions[state.round_number - 1] == Action.C:
                return np.where(history.opponent_actions[:, state.round_number - 1] == Action.D, Action.D, Action.C)
            else:
                self.p += 1
        self.total_payoff += history.my_payoffs[state.round_number - 1]
        return Action.D if history.my_actions[state.round_number - 1] == Action.C else Action.C

class Strategy_EXPLOITATIVE_47(BaseStrategy):
    """
    Strategy: Adaptive Tit-for-Tat with Punishment (ATTP)
    Strategy Description: https://projecteuler.net/game/public-goods

    This strategy follows a tit-for-tat approach in subsequent rounds: if an opponent has cooperated in the previous round,
    the ATTP strategy will also cooperate in the current round. If the opponent defected in the previous round, the ATTP strategy
    will punish them by defecting as well. In the first round, it always cooperates and for the last round (round == r), it defects
    regardless of the opponent's previous action because there are no future interactions and the strategy aims to maximize personal payoff in that round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_round = False
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        self.last_round = state.round_number == self.game_description.n_rounds
        if not history and self.last_round:
            return Action.D
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_77(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TFT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T_switch = math.ceil(game_description.n_rounds * 0.8)
        self.strategy = None
        self.last_opponent_action = False

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = len(history.opponent_actions) - 1
        if current_round >= self.T_switch and self.last_opponent_action == False:
            self.strategy = 'CD'
        if self.strategy == 'CD' and current_round != state.round_number - 1 and (self.last_opponent_action == False):
            return Action.D
        if self.strategy is None or self.strategy == 'CD':
            if history.opponent_actions[-1, -1] == True:
                return Action.C
            else:
                self.last_opponent_action = False
                return Action.D
        elif self.strategy == 'CD' and history.opponent_actions[-1, -1] == False:
            if current_round != state.round_number - 1:
                return Action.C
            else:
                self.last_opponent_action = True
                return Action.D

class Strategy_EXPLOITATIVE_91(BaseStrategy):
    """
    A strategy that cooperates in the first round and then bases its actions on the average cooperation of past 'm' rounds.
    It defects when the average falls below a threshold 't'. This helps foster cooperation while also being less vulnerable to exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(math.ceil(game_description.n_rounds * 0.7))
        self.t = 0.6

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = np.mean(history.opponent_actions[-self.m:, :].flatten())
        if cooperators >= self.t:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_105(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-A) strategy for N-Player Public Goods Game.
    Initializes cooperatively, retaliates against defection, and adapts to uncooperative environments.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.current_player = 0
        self.total_cooperators = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            self.history.my_actions[0] = True
            return Action.C
        self.update_history(state, history)
        current_round = len(self.history.my_payoffs) - 1
        if current_round == state.round_number - 1:
            total_cooperators = np.sum(self.history.opponent_actions[-1, :])
            if total_cooperators > self.total_cooperators:
                self.total_cooperators = total_cooperators
            elif total_cooperators < self.total_cooperators:
                self.total_cooperators = math.floor(self.game_description.n_players / 2)
        else:
            last_round = current_round - 1
            last_state = GameState(last_round)
            if self.history.my_actions[last_round] and self.history.opponent_actions[last_round, self.current_player]:
                return Action.C
            else:
                return Action.D
        next_player = (self.current_player + 1) % self.game_description.n_players
        self.current_player = next_player
        return self.determine_action(state, history)

    def update_history(self, state: GameState, history: PlayerHistory):
        if len(self.history.my_payoffs) < state.round_number + 1:
            self.history.my_actions[state.round_number] = None
            self.history.my_payoffs[state.round_number] = None
            for player in range(self.game_description.n_players):
                self.history.opponent_actions[state.round_number, player] = False
                self.history.opponent_payoffs[state.round_number, player] = None
        else:
            self.history.my_actions[state.round_number] = True if state.round_number == 0 else self.history.my_actions[state.round_number - 1]

    def determine_action(self, state: GameState, history: PlayerHistory):
        last_cooperators = np.sum(history.opponent_actions[-1, :])
        if last_cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_111(BaseStrategy):
    """
    A strategy that mimics the opponent's behavior, cooperating if they do and defecting if they don't. It also adapts its own contribution level based on the opponents' actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_history = None
        self.opponent_history = None
        self.current_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            self.my_history = np.zeros((self.game_description.n_rounds,), dtype=bool)
            self.opponent_history = np.zeros((self.game_description.n_rounds, self.game_description.n_players + 1), dtype=bool)
            self.current_round += 1
        if self.current_round == 0:
            return Action.C
        self.my_history[self.current_round] = Action.D != history.opponent_actions[-1, self.__class__.__name__ % 2]
        self.opponent_history[self.current_round, self.__class__.__name__ % 2] = history.opponent_actions[-1, self.__class__.__name__ % 2]
        cooperators = np.sum(history.opponent_actions[-1, :])
        if self.current_round < self.game_description.n_rounds - 1:
            self.current_round += 1
            return Action.D != history.opponent_actions[self.current_round - 1, self.__class__.__name__ % 2] if cooperators >= self.game_description.n_players // 2 else self.my_history[-1]
        else:
            return Action.C

class Strategy_EXPLOITATIVE_112(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperation factor.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.past_coop_count = 0
        self.past_coop_history = []
        self.cooperative_threshold = self.game_description.n_players // 2
        self.consecutive_defect_limit = math.ceil(self.game_description.n_rounds / 3)
        self.current_player_punishment = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        my_action = history.my_actions[-1]
        opponent_cooperators = sum(history.opponent_actions[:, -1])
        past_cooperation_rate = self.past_coop_count / len(self.past_coop_history) if len(self.past_coop_history) > 0 else 0
        if state.round_number == history.opponent_actions.shape[0] - 1:
            if past_cooperation_rate >= self.cooperative_threshold:
                return Action.C
            return Action.D
        if my_action:
            self.past_coop_history.append(True)
            self.past_coop_count += 1
            self.current_player_punishment = 0
        else:
            self.past_coop_history.append(False)
            if self.current_player_punishment < self.consecutive_defect_limit:
                self.current_player_punishment += 1
        punishment_factor = self.current_player_punishment / self.consecutive_defect_limit if self.current_player_punishment > 0 else 0
        opponent_deviation = opponent_cooperators - past_cooperation_rate
        return Action.C if opponent_deviation <= punishment_factor else Action.D

class Strategy_EXPLOITATIVE_115(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold Strategy
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_coop = np.zeros(self.game_description.n_players)
        self.history_coop = [[0] * self.game_description.n_rounds for _ in range(self.game_description.n_players)]
        self.threshold = [0] * self.game_description.n_players
        self.penalty = 0.5
        self.punish_count = 3
        self.forgive = False

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0 or not history:
            action = Action.C
        else:
            current_coop = sum(history.opponent_actions[state.round_number - 1, :])
            self.average_coop = self.game_description.n_players / (self.game_description.n_rounds - 1) * self.average_coop + current_coop
            self.history_coop[0][state.round_number] = int(action == Action.C)
            for opponent in range(1, self.game_description.n_players):
                self.threshold[opponent] = (self.average_coop[opponent] + self.penalty * (1 - self.average_coop[opponent])) / 2
            for opponent in range(1, self.game_description.n_players):
                if self.history_coop[opponent][state.round_number - 1] > self.threshold[opponent]:
                    action = Action.C
                    break
            if history.my_actions[state.round_number - 1] == Action.D:
                self.punish_count -= 1
                if self.punish_count <= 0:
                    action = Action.C
                    self.forgive = True
                    self.penalty = 0.5
            if self.history_coop[1][state.round_number - 1] > self.threshold[1] and (not self.forgive):
                action = Action.C
                self.penalty = 0.5
                self.punish_count = 3
                self.forgive = True
        return action

class Strategy_EXPLOITATIVE_126(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Ratio (TFT-ACR) strategy for N-Player Public Goods Game.
    This strategy cooperates in the first round, mimicking cooperative behavior. After that, it maintains a ratio of cooperations to defections based on the observed behavior of other players.
    If another player has been cooperative, the TFT-ACR strategy will also cooperate, with the cooperation ratio increasing over time to encourage more cooperation from the opponent. Conversely, if an opponent has been uncooperative, the TFT-ACR strategy will gradually decrease its cooperation ratio to match the opponent's behavior and potentially punish them for their previous actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_ratio = 1.0
        self.growth_factor = 0.1
        self.decay_factor = 0.1
        self.minimum_cooperation_threshold = 0.5
        self.last_n_rounds = int(self.game_description.n_rounds * 0.7)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        cooperators = self.get_recent_opponent_behavior(history)[0]
        self.cooperation_ratio += self.growth_factor * (1 - self.cooperation_ratio) if cooperators else self.decay_factor * self.cooperation_ratio
        return Action.C if self.calculate_cooperation_decision(cooperators, self.cooperation_ratio) else Action.D

    def calculate_cooperation_decision(self, cooperators: int, cooperation_ratio: float) -> bool:
        return cooperators >= math.ceil(cooperation_ratio * self.game_description.n_players)

    def get_recent_opponent_behavior(self, history: PlayerHistory) -> tuple[int, bool]:
        recent_rounds = history.opponent_actions[-self.last_n_rounds:]
        total_cooperations = np.sum(np.sum(recent_rounds, axis=0))
        cooperation_percentage = total_cooperations / self.last_n_rounds
        return (int(total_cooperations), cooperation_percentage >= self.minimum_cooperation_threshold)

class Strategy_EXPLOITATIVE_132(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.most_frequent_cooperator = None
        self.defected_opponents = set()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.my_actions is not None:
            self.update_history(history)
        if state.round_number < self.game_description.n_rounds - 1:
            most_frequent_cooperator = self.find_most_frequent_cooperator()
            if self.most_frequent_cooperator is not None and most_frequent_cooperator != history.my_actions[-1]:
                return Action.D
        return Action.C

    def update_history(self, history: PlayerHistory) -> None:
        if self.most_frequent_cooperator is not None and len(self.defected_opponents) > 0:
            if history.round_number == self.game_description.n_rounds - 1:
                self.most_frequent_cooperator = None
                self.defected_opponents.clear()
            else:
                self.most_frequent_cooperator += history.my_actions[-1] - self.most_frequent_cooperator
                if history.my_actions[-1] == Action.D:
                    self.defected_opponents.add(self.most_frequent_cooperator)
                    self.most_frequent_cooperator = None

    def find_most_frequent_cooperator(self) -> Action | None:
        if not self.most_frequent_cooperator:
            return None
        opponent_actions = np.array([action for round_, actions in enumerate(history.opponent_actions) for action in actions])
        num_cooperators = sum((opponent_actions == Action.C).flatten())
        if num_cooperators >= self.game_description.n_players // 2:
            return Action.C
        tied_cooperators = opponent_actions[opponent_actions == Action.C]
        if len(tied_cooperators) > 0:
            return tied_cooperators[-1]

class Strategy_EXPLOITATIVE_144(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TAFC)
    Summary: A strategy that cooperates in the first round and responds to opponent's last action,
             adapting the level of cooperation based on their history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_cooperation = 0
        self.threshold = int(game_description.n_players * 0.6)
        self.adaptation_factor = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[state.round_number - 1]
        self.consecutive_cooperation = sum(opponent_actions)
        if self.consecutive_cooperation > self.threshold and state.round_number > self.threshold:
            self.adaptation_factor = min(self.threshold, self.game_description.n_rounds - 1)
        action = Action.D
        if state.round_number < self.game_description.n_rounds and self.adaptation_factor > 0:
            action = Action(not opponent_actions[-self.adaptation_factor])
        if state.round_number == self.game_description.n_rounds - 1:
            if opponent_actions[-1]:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_149(BaseStrategy):
    """
    A strategy that follows the Tit-for-Tat-with-Adaptation (TfTA) rule in the N-Player Public Goods Game. The TfTA strategy cooperates initially and reciprocates cooperation, while retaliating against defectors with a predefined threshold and time frame for retaliation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_threshold = int(math.ceil(game_description.n_players * 0.5))
        self.M = math.floor(game_description.n_rounds * 0.5)
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        self.history = history if history else PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_players, self.game_description.n_rounds), dtype=bool), np.zeros(self.game_description.n_rounds))
        if state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number - 1] = True
        if history is None:
            total_coop = np.sum(self.history.opponent_actions[:state.round_number, :])
        else:
            total_coop = np.sum(history.opponent_actions[:state.round_number, :])
        if total_coop < self.n_threshold and state.round_number <= self.M + 1:
            return Action.D
        elif state.round_number > self.M + 1:
            cooperators = np.sum(self.history.opponent_actions[state.round_number - self.M - 1:state.round_number, :])
            if cooperators >= self.n_threshold:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_153(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TfT-A) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r_threshold = int(self.game_description.n_rounds * 0.8)
        self.history = PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1,)), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds,)))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        elif state.round_number >= self.r_threshold or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            if opponent_cooperators > 0 and (self.history.opponent_actions[state.round_number - 1, :] == self.history.opponent_actions[-1, :]).all():
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_158(BaseStrategy):
    """
    A cooperative strategy that mirrors opponents' actions while being adaptive to their behavior and showing forgiveness towards changes in behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contributed_this_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_actions = history.opponent_actions if history else np.zeros((1, self.game_description.n_players), dtype=bool)
        last_round = state.round_number - 1 if state.round_number > 0 else 0
        last_opponent_action = opponent_actions[last_round, -1]
        self.contributed_this_round = last_opponent_action == Action.C
        return last_opponent_action if state.round_number == self.game_description.n_rounds and self.contributed_this_round else Action.D

class Strategy_EXPLOITATIVE_161(BaseStrategy):
    """Adaptive Tit-for-Tat (ATfT) strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.scores = {opponent: 0 for opponent in range(1, self.game_description.n_players + 1)}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or history.my_actions is None or len(history.my_actions) < self.game_description.n_rounds:
            return Action.C
        previous_action = history.my_actions[-1]
        current_opponent = state.round_number % self.game_description.n_players + 1
        if previous_action[current_opponent - 1] == 1 and state.round_number != self.game_description.n_rounds:
            return Action.C
        elif previous_action[current_opponent - 1] == 0 and state.round_number != self.game_description.n_rounds:
            return Action.D
        else:
            total_scores = np.sum(np.array([self.scores[opponent] for opponent in range(1, self.game_description.n_players + 1)]))
            if total_scores[current_opponent] > total_scores - total_scores[current_opponent]:
                return Action.C
            else:
                return Action.D
        self.update_score(current_opponent, previous_action[current_opponent - 1])

    def update_score(self, opponent: int, action: bool) -> None:
        if action:
            self.scores[opponent] += 1

class Strategy_EXPLOITATIVE_166(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TfTAC) strategy for N-Player Public Goods Game.
    This strategy adapts to different opponent behaviors by implementing an exploratory phase and a stable phase.
    It encourages mutual cooperation but also retaliates against defection, aiming to maximize individual payoff while not completely relying on the opponent's cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploratory_phase = True
        self.round_number = 0
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        self.round_number = state.round_number
        if len(self.history) <= int(self.game_description.n_rounds * 0.1):
            return random.choice([Action.C, Action.D])
        if self.exploratory_phase:
            last_action = self.history[-1][-1] if self.history else None
            if last_action == Action.C and history:
                return Action.C
            elif last_action == Action.D and history:
                return Action.D
            else:
                self.exploratory_phase = False
        if not history or len(history) < self.round_number:
            return Action.C
        last_opponent_action = history.opponent_actions[-1, int(self.__class__.__name__.lower().replace(' ', '_'))]
        if self.round_number == self.game_description.n_rounds - 1:
            if last_opponent_action == Action.C:
                return Action.C
            elif last_opponent_action == Action.D:
                return Action.D
        return last_opponent_action

class Strategy_EXPLOITATIVE_171(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Ratio (TFT-ACR) strategy in an N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2
        self.opponent_history = np.zeros((1, self.game_description.n_players), dtype=np.bool_)
        self.personal_defections = 0
        self.total_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        elif history is not None:
            self._update_opponent_history(history)
            self._update_personal_defections(history)
            self._adjust_threshold()
            if state.round_number == self.game_description.n_rounds:
                return Action.C
            avg_cooperation = np.mean(history.my_actions[self.total_rounds - self.game_description.n_rounds + 1:])
            if avg_cooperation > self.threshold:
                return Action.C
            else:
                return Action.D

    def _update_opponent_history(self, history: PlayerHistory):
        self.opponent_history = np.roll(self.opponent_history, -1)
        self.opponent_history[-1] = history.my_actions[0]

    def _update_personal_defections(self, history: PlayerHistory):
        self.total_rounds += 1
        personal_defections = np.count_nonzero(history.my_actions) - self.total_rounds + 1
        self.personal_defections += personal_defections

    def _adjust_threshold(self):
        recent_cooperative_rounds = np.sum((self.opponent_history[-2:] == Action.C).flatten())
        if recent_cooperative_rounds > 2:
            self.threshold += 0.1
        elif np.mean(self.opponent_history[-self.game_description.n_players:-1]) < self.threshold:
            self.threshold -= 0.1
        if self.personal_defections / self.total_rounds > 0.8:
            self.threshold += 0.2

class Strategy_EXPLOITATIVE_182(BaseStrategy):
    """
    Tit-for-Tat Strategy with Adaptive Cooperation Probability for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.5
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=None, opponent_payoffs=None)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.update_cooperation_probability(history.opponent_actions[-1, :][-1])
        if random.random() < self.p:
            return Action.C
        else:
            return Action.D

    def update_cooperation_probability(self, opponent_action):
        if self.history.my_actions[-1] == Action.C and opponent_action == Action.D:
            self.p = min(self.p + 0.1, 1)
        elif self.history.my_actions[-1] == Action.D and opponent_action == Action.C:
            self.p = max(self.p - 0.1, 0)

    def update_history(self, my_action, opponent_actions, payoffs):
        self.history.my_actions[-1] = int(my_action)
        self.history.my_payoffs[-1] = np.max(payoffs)
        self.history.opponent_actions = np.vstack((self.history.opponent_actions, opponent_actions))
        self.history.opponent_payoffs = np.vstack((self.history.opponent_payoffs, payoffs))

class Strategy_EXPLOITATIVE_191(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_rate = 0.8
        self.alpha = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1] if history is not None else [0] * self.game_description.n_players)
        cooperation_rate = self.update_cooperation_rate(state.round_number, cooperators, self.cooperation_rate, self.alpha)
        return Action.C if cooperation_rate >= cooperators else Action.D

    def update_cooperation_rate(self, current_round, previous_cooperators, r_c, alpha):
        return (1 - alpha) * r_c + alpha * (previous_cooperators / self.game_description.n_players if previous_cooperators > 0 else 0.5)

class Strategy_EXPLOITATIVE_208(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat with Gradual Defection (nGF)
    This strategy initiates cooperation, and reciprocates cooperation in subsequent rounds while defecting when opponents consistently defect.
    It introduces a gradual defection mechanism after observing n consecutive defections from an opponent, where n is a fraction of total rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = int(self.game_description.n_players * (self.game_description.n_rounds / 10))
        self.memory_buffer = [False] * self.n

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.opponent_actions) < self.n:
            return Action.C
        last_opponent_action = history.opponent_actions[-1][0]
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if last_opponent_action:
            if any(self.memory_buffer):
                self.memory_buffer = [last_opponent_action] + self.memory_buffer[1:]
                return Action.C
            else:
                self.memory_buffer = [last_opponent_action]
                return Action.D
        elif all(self.memory_buffer):
            self.memory_buffer = [last_opponent_action] + self.memory_buffer[1:]
            return Action.D
        else:
            self.memory_buffer = [last_opponent_action]
            return Action.C

class Strategy_EXPLOITATIVE_217(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat with Evolving Cooperation Threshold (ATTET)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.T = int((self.n_players + 1) / 2) if self.n_players % 2 == 1 else int(self.n_players / 2)
        self.delta = 0.05
        self.sigma = 2.0
        self.T_0 = self.T

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        my_action = Action.C if cooperators >= self.T else Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            if my_action == Action.C and cooperators >= self.T:
                self.T = min(self.T + self.delta, self.n_players - 1)
            elif my_action == Action.D and cooperators > self.T:
                self.T = max(self.T - self.sigma, self.T_0)
        return my_action

class Strategy_EXPLOITATIVE_251(BaseStrategy):
    """
    Tit-for-Tat with Gradual Adaptation (TFT-GA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgetting_factor = 1 - math.log2(game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None and len(history.opponent_actions) >= self.game_description.n_rounds // 2:
            return Action.D
        history_length = len(history.opponent_actions)
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if history_length > 1 and opponent_cooperators >= self.game_description.n_players * (1 - self.forgetting_factor):
            return Action.C
        elif history_length > 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_278(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TTAC) strategy in N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self.history = self.history[-min(state.round_number, len(self.history)):]
        if state.round_number == 0 or len(self.history) == 0:
            return Action.C
        last_interaction = self.history[-1]
        contribute = last_interaction[1] if len(self.history) > 0 else True
        if contribute and last_interaction[1]:
            return Action.C
        elif contribute and (not last_interaction[1]):
            return Action.D
        elif not contribute and last_interaction[1]:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_288(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        current_round = state.round_number
        current_opponent_actions = history.opponent_actions[current_round - 1] if current_round > 0 else None
        if len(self.history) == 0 or (current_round == 0 and history is None):
            return Action.C
        decision_function = decide_action_edge_cases if current_round < self.game_description.n_rounds else decide_action_last_round
        return decision_function(current_round, current_opponent_actions, self.history, self.game_description)

    def decide_action(self, current_round: int, current_opponent_action: np.bool_) -> Action:
        if len(self.history) == 0:
            return Action.C
        if self.history[-1] == Action.C and current_opponent_action:
            return Action.C
        elif self.history[-1] != current_opponent_action:
            return Action.D
        else:
            return self.history[-1]

    def decide_action_last_round(self, current_round: int, current_opponent_action: np.bool_, history: list, total_rounds: int):
        if current_round == total_rounds:
            if len(history) > total_rounds // 2 and (len(history) % 2 == 0 or current_opponent_action):
                return Action.C
            else:
                return self.history[-1]
        else:
            return self.decide_action(current_round, current_opponent_action)

class Strategy_EXPLOITATIVE_295(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy for N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = int(self.game_description.k * 0.5)
        self.recent_coopers = 0
        self.no_cooperation_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            num_cooperators = int(self.game_description.n_players // 2 + 1)
            if num_cooperators <= self.game_description.n_players:
                return Action.C
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        coop_count = sum(history.opponent_actions[-1])
        if history is None or self.no_cooperation_count >= self.game_description.n_rounds // 10:
            self.recent_coopers = 0
            self.no_cooperation_count = 0
            self.cooperative_threshold = int(self.game_description.k * 0.5)
        if coop_count >= self.cooperative_threshold and coop_count >= self.game_description.n_players // 2:
            self.recent_coopers += 1
            self.no_cooperation_count = 0
        elif coop_count < self.cooperative_threshold:
            self.no_cooperation_count += 1
            if self.recent_coopers < self.game_description.n_players // 2:
                self.cooperative_threshold += 1
            else:
                self.cooperative_threshold -= 1
        if coop_count >= self.cooperative_threshold and self.recent_coopers >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_311(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy player for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = None
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.threshold = self.game_description.n_players - 1
        elif state.round_number > 0 and history is not None:
            self.last_round_cooperators = sum(history.opponent_actions[-1])
            self.threshold = self.update_threshold() if history else self.game_description.n_players - 1
        action = Action.D if self.last_round_cooperators <= self.threshold else Action.C
        return action

    def update_threshold(self) -> int:
        cooperators = self.last_round_cooperators
        if cooperators >= self.game_description.n_players - 1:
            threshold = math.floor(self.game_description.n_players * (1 - self.game_description.k / self.game_description.n_players)) + 1
            threshold = max(2, threshold)
        else:
            threshold = self.threshold
        return threshold

class Strategy_EXPLOITATIVE_355(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = None
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        self.history = history if history else PlayerHistory(np.zeros((state.round_number + 1, 2), dtype=bool), np.zeros(state.round_number + 1), np.zeros((state.round_number + 1, self.game_description.n_players), dtype=bool), np.zeros(state.round_number + 1))
        if state.round_number == 0:
            return Action.C
        cooperators = self.history.my_actions[-1]
        total_cooperators = sum(self.history.opponent_actions[-1, :])
        if total_cooperators >= math.ceil((self.game_description.n_players * (self.game_description.k / self.game_description.n_players) - 1) * (state.round_number // 2)) and self.cooperative_threshold is None:
            self.cooperative_threshold = math.ceil((self.game_description.n_players * (self.game_description.k / self.game_description.n_players) - 1) * (state.round_number // 2))
        if total_cooperators >= cooperators + self.cooperative_threshold:
            return Action.C
        elif cooperators == self.cooperative_threshold and self.history.my_actions[-2] == Action.C:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_363(BaseStrategy):
    """
    Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = np.zeros((self.game_description.n_rounds,), dtype=bool)
        self.history[-1] = True

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.D
        if state.round_number == 0:
            self.history[state.round_number] = True
            return Action.D
        else:
            last_memory = self.history[-1]
            current_cooperators = sum(history.opponent_actions[-1, :])
            if np.all(self.history[-self.game_description.n_rounds // 2:-1] == True) and last_memory is False:
                self.history[state.round_number] = True
            elif current_cooperators >= self.game_description.n_players // 2 and last_memory is False:
                self.history[state.round_number] = True
            elif current_cooperators == 0:
                self.history[state.round_number] = True
            else:
                self.history[state.round_number] = history.opponent_actions[-1, -1]
        return Action(int(self.history[state.round_number]))

class Strategy_EXPLOITATIVE_367(BaseStrategy):
    """
    A strategy that cooperates initially, then cooperates if opponents cooperate in the previous round, and defects otherwise.
    This strategy also adapts to the behavior of each opponent independently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponents_histories = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number > self.game_description.n_rounds - 1:
            return Action.C
        opponent = history.opponent_actions[state.round_number - 1, 0] if len(self.opponents_histories) else None
        if opponent is not None and opponent == Action.D:
            self.opponents_histories[history.my_payoffs[-1].argmax()] = history
            return Action.D
        if len(self.opponents_histories) > 0:
            last_opponent_history = self.opponents_histories[history.my_payoffs[-1].argmax()]
            last_opponent_cooperation = sum(last_opponent_history.opponent_actions[-1, :])
            if last_opponent_cooperation >= self.game_description.n_players // 2:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_369(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF)
    This strategy mimics the behavior of its opponent while fostering cooperation through an adaptive cooperation factor.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.fc = 0.1
        self.l = 3
        self.step = 0.1
        self.max_fc = 1.0
        self.t = 0.7

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        actions = np.zeros(self.game_description.n_players, dtype=np.bool_)
        actions[0] = True
        actions[-1] = history.opponent_actions[-1][-1] if history else False
        total_cooperators = np.sum(actions)
        my_payoff = 1 - actions[0] + self.game_description.k / self.game_description.n_players * total_cooperators
        if history and total_cooperators > 0 and (state.round_number >= self.l):
            self.fc = min(self.fc + self.step, self.max_fc)
        if state.round_number == self.game_description.n_rounds or (state.round_number < self.game_description.n_rounds and actions[-1]):
            return Action.C if self.fc > self.t else Action.D
        return Action(int(actions[0]))

class Strategy_EXPLOITATIVE_377(BaseStrategy):
    """
    Tit-for-Tat-Cooperative (Tftc) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_sequence = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history:
            last_round = len(history.opponent_actions) - 1
            opponent_action = history.opponent_actions[last_round, 0]
            self.defection_sequence += 1 if opponent_action == Action.D else 0
            return Action.C if last_round < self.game_description.n_rounds - 1 and self.defection_sequence < 3 else Action.D
        else:
            return Action.C

    def reset(self):
        """
        Reset state variables at the start of each game.
        """
        self.defection_sequence = 0

class Strategy_EXPLOITATIVE_394(BaseStrategy):
    """
    Tit-for-Tat with Adaptation Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / 2)
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else self.last_cooperators
        if state.round_number == self.game_description.n_rounds - 1:
            if cooperators >= self.threshold:
                return Action.C
            return Action.D
        if cooperators >= self.threshold:
            return Action.C
        return Action.D

    def update(self, new_history: PlayerHistory):
        cooperators = sum(new_history.opponent_actions[-1, :])
        self.last_cooperators = cooperators if cooperators < self.threshold + 1 and self.last_cooperators != 0 else 0

class Strategy_EXPLOITATIVE_398(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Frequency Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_counters = {i: 0 for i in range(1, self.game_description.n_players + 1)}
        self.total_rounds = self.game_description.n_rounds * self.game_description.n_players

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        total_contributions = np.sum(history.opponent_actions[-1])
        self.update_opponent_counters(total_contributions)
        if state.round_number >= self.total_rounds // self.game_description.n_players:
            best_opponent = self.choose_best_opponent()
            payoff_ratio = self.calculate_payoff_ratio(best_opponent)
            action = self.choose_action(payoff_ratio, history)
        elif np.any(self.opponent_counters.values()) >= self.game_description.k:
            payoff_ratio = self.calculate_payoff_ratio(np.argmin(list(self.opponent_counters.values())))
            action = self.choose_action(payoff_ratio, history)
        return action

    def update_opponent_counters(self, total_contributions):
        for opponent in self.opponent_counters:
            if total_contributions > 0:
                self.opponent_counters[opponent] += 1
            else:
                self.opponent_counters[opponent] = min(self.game_description.k, self.opponent_counters[opponent])

    def calculate_payoff_ratio(self, best_opponent):
        own_total_payoffs = np.sum(history.my_payoffs)
        best_opponent_total_payoffs = np.sum(history.opponent_payoffs[best_opponent])
        return own_total_payoffs / (own_total_payoffs + best_opponent_total_payoffs)

    def choose_action(self, payoff_ratio, history):
        random_number = random.random()
        if payoff_ratio >= 0.5:
            return Action.C if np.max(history.opponent_actions[:, best_opponent]) > 0 else Action.D
        return Action.D if np.min(self.opponent_counters.values()) < self.game_description.k - 1 else Action.C

    def choose_best_opponent(self):
        max_contributions = 0
        best_opponent = None
        for opponent in self.opponent_counters:
            contributions = np.sum(history.opponent_actions[:, opponent])
            if contributions > max_contributions:
                max_contributions = contributions
                best_opponent = opponent
        return best_opponent

class Strategy_EXPLOITATIVE_411(BaseStrategy):
    """
    A strategy that mimics the Tit-for-Tat with a twist of k cooperative players in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k_over_n = game_description.k / game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            cooperators = 0
        else:
            cooperators = np.sum(history.opponent_actions[:-1].mean(axis=0))
        if cooperators >= self.k_over_n:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_414(BaseStrategy):
    """
    A Tit-for-Tat with Time-Delayed Response (TFTD) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tau = math.ceil(game_description.n_rounds / 10)
        self.opponent_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        self.opponent_history.append(np.mean(history.opponent_actions, axis=1))
        opponent_cooperators = np.count_nonzero(self.opponent_history[-1])
        if opponent_cooperators >= len(self.opponent_history) // 2:
            return Action.C
        if state.round_number > self.tau and any(self.opponent_history[-self.tau - 1] == [True]):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_422(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        self.history.append(history.opponent_actions[-1]) if history else self.history.append([False] * self.game_description.n_players)
        total_contributions = sum(self.history[-1])
        action = Action.C if total_contributions == self.game_description.n_players else Action.D
        if state.round_number == len(self.history):
            action = Action.C if sum(self.history[-1]) == self.game_description.n_players else Action.D
        return action

class Strategy_EXPLOITATIVE_433(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.own_strategy_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.C if state.round_number == 0 else self._get_action(state, history)
        self.own_strategy_history.append(action)
        return action

    def _get_action(self, state: GameState, history: PlayerHistory) -> Action:
        opponent_last_cooperation = sum(history.opponent_actions[:, -1])
        if opponent_last_cooperation == self.game_description.n_players:
            return Action.C
        elif 0 < opponent_last_cooperation < self.game_description.n_players and state.round_number != self.game_description.n_rounds:
            cooperation_probability = opponent_last_cooperation / state.round_number
            return Action(int(random.uniform(0, 1) < cooperation_probability))
        return Action.D

class Strategy_EXPLOITATIVE_434(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Cooperative Threshold (ATFT-CT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_length = int(math.ceil(game_description.n_players / 2))
        self.average_cooperators = np.zeros(self.history_length)
        self.ct = 0.0
        self.pt = 0.5 * game_description.k * (game_description.n_players - 1)
        self.last_round_payoff = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        cooperators = sum(history.opponent_actions[-self.history_length:, :].flatten()) if history else self.average_cooperators.sum()
        self.average_cooperators = np.roll(self.average_cooperators, -1)
        self.average_cooperators[-1] = cooperators / self.history_length
        self.ct = self.average_cooperators.mean() if self.history_length <= len(self.average_cooperators) else self.ct
        if cooperators > self.ct:
            return Action.C
        elif state.round_number == self.game_description.n_rounds and self.last_round_payoff < self.pt:
            self.last_round_payoff = 0.0
            return Action.D
        self.last_round_payoff = np.sum(history.my_payoffs[-1]) if history else 0.0
        return Action.D

class Strategy_EXPLOITATIVE_435(BaseStrategy):
    """
    Strategy named Tit-for-Tat with Adaptive Cooperation (TFT-AC).
    Cooperates initially and punishes defection, while adapting to a wide range of opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_round = state.round_number
        opponent_actions = history.opponent_actions if history else np.zeros((current_round, self.game_description.n_players), dtype=bool)
        cooperation_count = sum(opponent_actions[-self.tolerance:, -1])
        cooperate = cooperation_count >= self.tolerance
        if current_round != self.game_description.n_rounds and (current_round == len(opponent_actions) or not cooperate):
            opponent_actions[-1, -1] = 1 - cooperate
        return Action(int(cooperate))

class Strategy_EXPLOITATIVE_444(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_threshold = None
        self.cooperators_count = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.coop_threshold is None:
            for i in range(state.round_number - self.game_description.n_rounds // 2):
                if history.my_actions[i] == Action.C:
                    self.cooperators_count += 1
            self.coop_threshold = self.cooperators_count / (self.game_description.n_rounds // 2) + 0.5
            self.cooperators_count = 0
        previous_rounds_cooperation = sum(history.my_actions[state.round_number - self.game_description.n_rounds // 2:state.round_number])
        coop_ratio = previous_rounds_cooperation / (self.game_description.n_rounds // 2)
        cooperate = False
        if coop_ratio >= self.coop_threshold:
            cooperate = True
        return Action(int(cooperate))

class Strategy_EXPLOITATIVE_457(BaseStrategy):
    """
    A Tit-for-Tat Plus (TFT+) strategy for N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_period = math.ceil(game_description.n_players / 2)
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players - 1), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_opponent_action = history.opponent_actions[-1, -1]
        if last_opponent_action:
            return Action.C
        else:
            punishment_rounds = min(self.punishment_period, state.round_number - np.count_nonzero(history.my_actions[-self.punishment_period:]))
            if punishment_rounds >= self.punishment_period:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_472(BaseStrategy):
    """
    A Tit-for-Tat strategy with a slight modification for exploitation in the N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.history) == 0:
            return Action.C
        last_round = len(self.history) - 1
        opponent_actions = self.history[-1] if history is None else history.opponent_actions[last_round, :]
        my_action = Action.C if all((opp_action == Action.D for opp_action in opponent_actions[:-1])) else opponent_actions[-1]
        self.history.append(opponent_actions)
        return my_action

class Strategy_EXPLOITATIVE_481(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptation (TFT-A)
    This strategy mimics a cooperative approach and adapts its behavior based on opponents' actions in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players, self.n_rounds, self.k = (game_description.n_players, game_description.n_rounds, game_description.k)
        self.N = 10
        self.current_round = 0
        self.opponent_history = None

    def __call__(self, state: GameState, history: PlayerHistory | None):
        if history is not None:
            self.opponent_history = history.opponent_actions
            self.current_round = state.round_number + 1
        if state.round_number == 0:
            return Action.C
        elif state.round_number < self.n_rounds:
            last_round = self.opponent_history[-1]
            cooperators = np.sum(last_round, axis=0)
            if cooperators >= self.game_description.n_players // 2 and self.current_round > self.N:
                return Action.C
            elif cooperators < self.game_description.n_players // 2:
                self.N = max(self.N - 1, 1)
        else:
            last_N_rounds = self.opponent_history[-self.N:]
            last_N_cooperators = np.sum(last_N_rounds, axis=0)
            if np.all(last_N_cooperators == 0):
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_483(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Gradient Adjustment strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = (game_description.n_players - 1) // 2
        self.delta_threshold = 0.05
        self.increment_cooperators = 0
        self.defectors = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.increment_cooperators = 0
            self.defectors = 0
        else:
            avg_cooperation = np.mean(history.my_actions)
            if avg_cooperation >= self.threshold:
                return Action.C
            elif state.round_number < self.game_description.n_rounds:
                if avg_cooperation > 0:
                    self.increment_cooperators += 1
                else:
                    self.defectors += 1
                self.threshold += self.delta_threshold * (self.increment_cooperators - self.defectors)
            return Action.D

class Strategy_EXPLOITATIVE_489(BaseStrategy):
    """
    Adaptive and exploitative Tit-for-Tat-Plus (TfTP) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.t = math.floor(self.n_players / 2)
        self.history = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            coop_percentage = np.mean([value[1] for key, value in self.history.values() if value[0] > self.t]) * self.n_players
            return Action.C if coop_percentage > self.n_players // 2 else Action.D
        if state.round_number == self.game_description.n_rounds:
            return self(GameState(self.game_description.n_rounds - 1), history)
        total_cooperators = sum(history.opponent_actions[-1, :])
        if total_cooperators > self.t:
            return Action.C
        return Action.D

    def update(self, state: GameState, actions: NDArray[np.bool_], payoffs: NDArray[np.float64]) -> None:
        if state.round_number == 0:
            return
        round_number = state.round_number - 1
        self.history.setdefault(round_number, (self.t, np.zeros(self.n_players)))[1][self] = payoffs[-1]
        if actions[-1, :].sum() < self.t:
            self.t -= 0.1
        elif actions[-1, :].sum() > self.t * 2:
            self.t += 0.1

class Strategy_EXPLOITATIVE_500(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    The strategy cooperates initially and mimics the opponent's action in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        self.history = history if history else self.history
        if state.round_number == 0:
            return Action.C
        current_action = Action(int(self.history.opponent_actions[-1, 0]))
        self.history = PlayerHistory(np.append(self.history.my_actions, [current_action]), np.append(self.history.my_payoffs, np.nan), self.history.opponent_actions, self.history.opponent_payoffs)
        return current_action

class Strategy_EXPLOITATIVE_505(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    A strategy that cooperates initially and punishes defection, while adapting the multiplication factor based on opponent's actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.opponent_cooperation_streak = 0
        self.my_defection_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_action = Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators > self.game_description.n_players // 2:
            my_action = Action.C
            self.opponent_cooperation_streak += 1
            if self.opponent_cooperation_streak >= 2:
                self.k += 0.1
        else:
            self.my_defection_streak += 1
            if self.my_defection_streak >= 2:
                self.k -= 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            my_action = Action.D
        return my_action

class Strategy_EXPLOITATIVE_506(BaseStrategy):
    """
    A strategy named Tit-for-Tat with Gradual Cooperation (TFT-GC).
    This strategy cooperates in the first round and adapts its cooperation based on the behavior of other players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.grace_period_triggered = False
        self.most_frequent_cooperator = None
        self.min_consecutive_cooperations = 4
        self.grace_period_length = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and self.most_frequent_cooperator is None):
            return Action.C
        if history is None:
            self.grace_period_triggered = False
            self.most_frequent_cooperator = np.zeros(self.game_description.n_players, dtype=int)
        else:
            self.update_history(history)
            cooperation_frequency = self.calculate_cooperation_frequency()
            if self.grace_period_triggered and self.check_consecutive_cooperations():
                return Action.C
            if cooperation_frequency >= self.game_description.n_players * 0.6 and (not self.grace_period_triggered):
                return Action.C
            else:
                return Action.D

    def update_history(self, history):
        if self.most_frequent_cooperator is None:
            self.most_frequent_cooperator = np.zeros(self.game_description.n_players, dtype=int)
        for i in range(len(history.opponent_actions)):
            if history.opponent_actions[i].sum() > self.most_frequent_cooperator.sum():
                self.most_frequent_cooperator[:] = history.opponent_actions[i]
                self.most_frequent_cooperator[-self.grace_period_length:] = 0
            elif (history.opponent_actions[i] == np.ones(len(history.opponent_actions[i]))).all():
                self.grace_period_triggered = True

    def calculate_cooperation_frequency(self):
        return np.mean(self.most_frequent_cooperator)

    def check_consecutive_cooperations(self):
        if self.most_frequent_cooperator[-self.min_consecutive_cooperations:].sum() >= self.min_consecutive_cooperations:
            return True
        return False

class Strategy_COLLECTIVE_242(BaseStrategy):
    """
    A strategy that cooperates initially and copies the most frequent cooperator's action in subsequent rounds, while adjusting contribution level based on the number of current cooperators relative to the total players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_level = 0.5
        self.history = None
        self.most_frequent_cooperator = None
        self.current_contributions = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not self.history):
            return Action.C
        if not self.history:
            self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_players, self.game_description.n_rounds), dtype=bool), np.zeros((self.game_description.n_players, self.game_description.n_rounds)))
        if state.round_number == self.history.my_actions.size - 1:
            return Action.C if not self.most_frequent_cooperator else Action(int(self.most_frequent_cooperator) != int(random.choice(range(self.game_description.n_players))))
        action = self.history.opponent_actions[-1, :].copy()
        self.most_frequent_cooperator = np.argmax(action) if action.sum() > 0 else None
        self.current_contributions = action.sum()
        if self.current_contributions == self.game_description.n_players:
            self.contribution_level += 0.1
        return Action(int(self.most_frequent_cooperator) != int(random.choice(range(self.game_description.n_players))) if self.most_frequent_cooperator else int(random.choice([0, 1])) == 1 if self.current_contributions >= self.game_description.n_players // 2 - math.floor((self.game_description.k - 1) / 2) else int(random.choice([0, 1])))

class Strategy_COLLECTIVE_282(BaseStrategy):
    """
    Tit-for-Tat Plus (TFT+) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_streak = 0
        self.opponent_defection_counter = 0
        self.x = math.ceil(game_description.n_players / 2)
        self.y = int(self.x * 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        opponent_action = np.mean(history.opponent_actions[-1]) if history else Action.D
        if opponent_action == Action.C and (self.cooperation_streak < self.x or self.opponent_defection_counter > self.y):
            action = opponent_action
            self.cooperation_streak += 1 if action == Action.C else 0
            self.opponent_defection_counter = 0
        elif self.opponent_defection_counter > self.y:
            action = Action.C
            self.cooperation_streak = 0
            self.opponent_defection_counter = 0
        self.opponent_defection_counter += 1 if opponent_action == Action.D else 0
        return action

class Strategy_COLLECTIVE_288(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_round_action = np.mean(history.opponent_actions[-1])
        action = Action.D if self.last_round_action < 0.5 else Action.C
        if state.round_number == self.game_description.n_rounds:
            if self.last_round_action >= 0.5:
                action = Action.C
        return action

class Strategy_COLLECTIVE_304(BaseStrategy):
    """
    Tit-for-Tat Strategy for the N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponents_cooperated = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history:
            last_round = state.round_number - 1
            cooperators = sum(history.opponent_actions[last_round, :])
            self.opponents_cooperated += int(cooperators > self.game_description.n_players // 2)
            if state.round_number == self.game_description.n_rounds:
                if self.opponents_cooperated >= self.game_description.n_players - 1:
                    action = Action.C
        return action

class Strategy_COLLECTIVE_318(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperate_init = True
        self.opponent_action = None
        self.wait_for_retaliation = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.opponent_action = history.opponent_actions[state.round_number - 1, 0]
        if self.cooperate_init:
            self.cooperate_init = False
            return Action.C
        if self.opponent_action == Action.C:
            return Action.C
        elif self.opponent_action == Action.D and self.wait_for_retaliation < 1:
            self.wait_for_retaliation += 1
        elif self.opponent_action == Action.C and self.wait_for_retaliation > 0:
            self.wait_for_retaliation -= 1
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_329(BaseStrategy):
    """
    A simple Tit-for-Tat with Adaptation (TFT-A) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 4
        self.opponents_history = {}

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_player_index = state.round_number - 1
        total_contributions = np.sum(history.opponent_actions[state.round_number - 1])
        payoff_from_cooperation = 1 - history.my_actions[state.round_number - 1] + self.game_description.k / self.game_description.n_players * total_contributions
        if len(self.opponents_history) == 0 or current_player_index not in self.opponents_history:
            return Action.C
        opponent_action = self.opponents_history[current_player_index]
        if opponent_action == history.my_actions[state.round_number - 1]:
            return opponent_action
        num_cooperators = sum(np.where(history.opponent_actions[state.round_number - 1] == Action.C, 1, 0))
        if num_cooperators / self.game_description.n_players >= self.threshold:
            return opponent_action
        return Action.D

    def update_opponent_history(self, player_index):
        """
        Update the history of an opponent's actions.
        """
        self.opponents_history[player_index] = self.opponents_history.get(player_index, []) + [self.opponents_history[-1][-1] if len(self.opponents_history) > 0 else Action.C]

class Strategy_COLLECTIVE_362(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    This strategy mimics the actions of the most common action taken by all players in the previous r-1 rounds, while also considering payoffs to choose between tied actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            self.history.my_actions[state.round_number] = True
            return Action.C
        most_common_action = np.argmax(self.history.opponent_actions[-self.game_description.n_rounds + state.round_number - 1:, :].sum(axis=0))
        if np.bincount(self.history.opponent_actions[-self.game_description.n_rounds + state.round_number - 1:, :].sum(axis=0))[most_common_action].size > 1:
            payoffs = self.calculate_payoffs_for_tied_actions(history)
            chosen_action = choose_action_with_highest_payoff(payoffs)
        else:
            chosen_action = most_common_action
        self.history.my_actions[state.round_number] = chosen_action
        return Action(chosen_action)

    def calculate_payoffs_for_tied_actions(self, history: PlayerHistory):
        payoffs = np.zeros(self.game_description.n_players)
        for action in [True, False]:
            subhistory = copy(history)
            subhistory.my_actions[subhistory.opponent_payoffs.argmax()] = action
            payoffs[np.where(subhistory.my_actions == action)[0]] = subhistory.opponent_payoffs[subhistory.opponent_payoffs.argmax()]
        return payoffs

class Strategy_COLLECTIVE_382(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperative Quotient (TFT-AQ) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = [(0, np.zeros(game_description.n_players))]
        self.window_size = 1
        self.threshold = self.window_size / game_description.n_rounds * game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.history[-1] = (self.window_size, history.my_actions[-1])
            self.window_size += 1
        cooperators = np.sum(self.history[-1][1]) / self.window_size
        action = Action.C if cooperators >= self.threshold else Action.D
        if state.round_number + 1 >= self.window_size + 1:
            self.threshold = self.window_size / self.game_description.n_rounds * self.game_description.n_players
            self.window_size += 1
        return action

class Strategy_COLLECTIVE_384(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) Strategy
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = int(game_description.n_players * 0.5)
        self.adaptive_threshold = self.cooperative_threshold

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number < self.game_description.n_rounds:
            opponents_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
            if opponents_cooperators >= self.adaptive_threshold:
                self.adaptive_threshold += int(self.game_description.n_players * 0.01)
                return Action.C
            elif opponents_cooperators < self.adaptive_threshold:
                self.adaptive_threshold -= int(self.game_description.n_players * 0.01)
                return Action.D
        else:
            recent_history = history.opponent_actions[state.round_number - 2:-1]
            opponents_cooperators = sum([np.sum(row) for row in recent_history])
            if np.sum(recent_history[-1, :]) >= self.adaptive_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_436(BaseStrategy):
    """
    Strategy based on the Adaptive Tit-for-Tat approach, which fosters cooperation while being robust against various opponent behaviors in N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.t = int(math.ceil(game_description.n_rounds * 0.2))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if history is not None:
            self.history = history.opponent_actions.flatten().tolist()
        if state.round_number < self.t:
            if len(self.history) >= self.t - 1 and self.history[-self.t + 1:-1] == [False] * (self.t - 1):
                return Action.C
            else:
                return Action.D
        elif self.history[-1] == Action.C:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_447(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.max_defections = self.game_description.n_players // 2
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_history = history.opponent_actions[:, -1] if history else np.zeros(self.game_description.n_rounds, dtype=bool)
        defections_counter = np.count_nonzero(np.cumsum(opponent_history == Action.D))
        if defections_counter > self.max_defections:
            defections_counter = 0
        return opponent_history[-1] if defections_counter >= self.max_defections else Action.D

class Strategy_COLLECTIVE_496(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Fading Memory (TFTF) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.memory = {0: Action.C, 1: Action.D}
        self.current_round = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.current_round = state.round_number
        total_cooperators = sum(history.my_actions[:self.current_round]) if self.current_round > 0 else 0
        my_action = self.memory[total_cooperators] if total_cooperators < self.game_description.n_players else self.memory[self.game_description.n_players - 1 - total_cooperators]
        if my_action == Action.C and all((history.my_actions[self.current_round - 1] == Action.D for _ in range(len(history.my_actions)))):
            self.memory[total_cooperators + (self.game_description.n_players - 1)] = my_action
        elif my_action == Action.D and all((history.my_actions[self.current_round - 1] == Action.C for _ in range(len(history.my_actions)))):
            self.memory[total_cooperators] = my_action
        else:
            self.memory[self.current_round] = my_action
        return my_action

class Strategy_COLLECTIVE_504(BaseStrategy):
    """
    Tit-for-Tat with Cooperative Adaptation (TFTCA) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.player_history = PlayerHistory(my_actions=np.zeros((1, self.game_description.n_players), dtype=bool), my_payoffs=np.zeros(self.game_description.n_players, dtype=np.float64), opponent_actions=np.zeros((self.game_description.n_rounds + 1, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds + 1, self.game_description.n_players), dtype=np.float64))
        self.current_round = 0
        self.opponent = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == 0:
            self.current_round += 1
            self.opponent = random.randint(0, self.game_description.n_players - 1)
            return Action.C
        self.current_round += 1
        opponent_last_action = history.opponent_actions[-1][self.opponent]
        if opponent_last_action:
            return Action.C
        else:
            return Action.D

    def update_history(self, payoffs):
        self.player_history.my_payoffs[self.current_round - 1] = payoffs[self.opponent]
        self.player_history.opponent_actions[-1][self.opponent] = self.get_action() == Action.C
        if self.current_round < self.game_description.n_rounds:
            self.opponent = (self.opponent + 1) % self.game_description.n_players

class Strategy_COLLECTIVE_511(BaseStrategy):
    """
    A simple implementation of the Tit-for-Tat-Adaptive (TfTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int((self.game_description.n_players + 1) / 2) if self.game_description.n_players % 2 == 0 else int(self.game_description.n_players / 2)
        self.history = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            total_contributions = sum(history.my_actions)
            prev_action = history.my_actions[-1]
            if prev_action == Action.C:
                if total_contributions > self.threshold:
                    action = Action.C
                elif total_contributions < self.threshold and prev_action == Action.D:
                    action = Action.D
                else:
                    action = Action.C
            elif total_contributions > self.threshold:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_96(BaseStrategy):
    """
    A game strategy that implements the Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.adaptation_weights = {}
        self.t = 0

    def calculate_payoff(self, my_action: bool, total_contributions: int) -> float:
        return 1 - my_action + self.game_description.k / self.game_description.n_players * total_contributions

    def calculate_weighted_payoffs(self, opponent_actions: NDArray[np.bool_]) -> dict:
        weights = {(1, 0): (self.game_description.k / self.game_description.n_players) ** self.t, (0, 1): 1 - (self.game_description.k / self.game_description.n_players) ** self.t}
        total_payoffs = {}
        for combination, weight in weights:
            payoff_sum = sum([self.calculate_payoff(ca, np.sum(opponent_actions == combination)) * weight for ca in combination])
            total_payoffs[combination] = payoff_sum
        return total_payoffs

    def play_round(self, my_action: Action) -> float:
        self.t += 1
        contributions = np.sum(self.opponent_actions[:, self.my_index])
        payoff_this_round = self.calculate_payoff(my_action == Action.C, contributions)
        return payoff_this_round

    def adaptive_contribution(self) -> bool:
        if len(self.opponent_actions) == 1:
            return self.opponent_actions[-1][0]
        opponents_actions = np.argmax([v for k, v in self.calculate_weighted_payoffs(self.opponent_actions).items()])
        if all(opponents_actions == 1):
            return True
        if any(opponents_actions == 0):
            return False
        weight_values = {(a, 1 - a): (self.game_description.k / self.game_description.n_players * (1 - a)) ** (self.t - 1) for a in range(0, 1, 0.01)}
        for combination, weight in weight_values.items():
            self.adaptation_weights[combination,] = weight
        max_payoff = np.max([self.calculate_weighted_payoffs((opponents_actions == a for a in [0, 1])).values()])
        max_action = list(np.argwhere(np.array([v == max_payoff for v in self.calculate_weighted_payoffs(self.opponent_actions).values()]))[0][0])
        if np.sum(max_action) > len(max_action) // 2:
            return True
        return False

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        self.opponent_actions = history.opponent_actions if history else np.zeros((state.round_number + 1, self.game_description.n_players), dtype=bool)
        self.my_index = self.__class__.__name__
        if state.round_number == 0 and history is None:
            return Action.C
        my_action = Action.C if state.round_number > 0 else self.__call__(GameState(state.round_number - 1), None)
        if np.all(self.opponent_actions[-1]) == 1:
            return Action.C
        if any(self.opponent_actions[-1]):
            return Action.D
        self.adaptation_weights = {}
        if np.count_nonzero(self.opponent_actions[-1]) > 1:
            my_action = self.adaptive_contribution()
        return my_action

class Strategy_EXPLOITATIVE_116(BaseStrategy):
    """
    Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game

    This strategy cooperates initially, and then mirrors the opponent's actions from the previous round. If an opponent stops cooperating after a streak of mutual cooperation, TfT-E forgives once by reverting to initial cooperation in the next round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number > 0:
            self.round_history.append(history.opponent_actions[-1])
            opponent_action = self.round_history[-1]
            if state.round_number == self.game_description.n_rounds and opponent_action != Action.C:
                action = opponent_action
            elif len(self.round_history) < 2:
                action = Action.C
            else:
                forgiveness_required = np.where(np.array(self.round_history[:-1]) != self.round_history[-1])[0].any()
                if forgiveness_required and self.round_history[-2] == Action.C:
                    action = Action.C
                else:
                    action = opponent_action
            self.round_history.pop(0)
            return action

class Strategy_EXPLOITATIVE_134(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_rounds = math.floor(game_description.n_rounds / 10)
        self.cooperative_threshold = np.mean(np.array([random.choices([True, False], weights=[1, 0])[:self.initial_rounds].count(True)]))
        self.tolerance_window = self.cooperative_threshold * 0.2
        self.tolerance_change_interval = 5
        self.tolerance_growth_factor = 1.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self.tolerance_window *= 2
        if not history:
            history = PlayerHistory(np.zeros((self.game_description.n_rounds,), dtype=np.bool), np.zeros((self.game_description.n_rounds,)), np.zeros((self.game_description.n_players, self.game_description.n_rounds), dtype=np.bool), np.zeros((self.game_description.n_players, self.game_description.n_rounds)))
        number_of_cooperators = history.my_actions[-1].sum()
        if number_of_cooperators > self.cooperative_threshold + self.tolerance_window:
            self.update_tolerance_window(state)
            self.cooperative_threshold += self.tolerance_window
        if number_of_cooperators < self.cooperative_threshold - self.tolerance_window:
            self.update_tolerance_window(state)
            self.cooperative_threshold -= self.tolerance_window
        return Action.C if number_of_cooperators >= self.cooperative_threshold else Action.D

    def update_tolerance_window(self, state):
        current_round = state.round_number
        tolerance_change = current_round - self.last_round > self.tolerance_change_interval and np.abs(self.cooperative_threshold - history.my_actions[current_round]) > 0
        if tolerance_change:
            self.tolerance_window *= self.tolerance_growth_factor if history.my_actions[current_round] == True else self.tolerance_window / self.tolerance_growth_factor
        self.last_round = current_round

class Strategy_EXPLOITATIVE_145(BaseStrategy):
    """
    The Tit-for-Tat Plus (TFT+) strategy.
    This strategy cooperates initially and responds with the same action as the previous round.
    It maintains an exploitative edge by not immediately forgiving defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and self.last_opponent_action is not None:
            opponent_cooperated = self.last_opponent_action
        else:
            opponent_cooperated = False
        self.last_opponent_action = history.opponent_actions[-1][0] if history is not None else None
        return Action(int(not opponent_cooperated ^ state.round_number > 1))

class Strategy_EXPLOITATIVE_237(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)
    A strategy that initially cooperates to encourage cooperation from others and punishes defection. It also adapts its behavior based on the total payoff gained throughout the game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.n_players * 0.6)
        self.payoff = 0

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            last_round = len(history.opponent_actions) - 1
            my_action = history.my_actions[last_round]
            if my_action:
                opponent_cooperators = sum(history.opponent_actions[last_round])
                if opponent_cooperators > self.game_description.n_players // 2:
                    return Action.C
            elif last_round == self.game_description.n_rounds - 1:
                payoff_ratio = self.payoff / (self.game_description.k * self.game_description.n_players ** 2)
                if payoff_ratio > self.threshold:
                    return Action.C
            return Action.D

class Strategy_EXPLOITATIVE_273(BaseStrategy):
    """
    A Tit-for-Tat Strategy with Adaptation (TFTA) for N-Player Public Goods Game.
    This strategy cooperates in the first round, copies the most frequent cooperator's action in subsequent rounds,
    and punishes defections with an adaptive punishment period.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_period = 0
        self.max_coop_history = []
        self.best_player_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if len(self.max_coop_history) > 0:
            max_coop_count = self.max_coop_history[-1]
            if max_coop_count >= self.game_description.n_players // 2:
                action = Action.C
        if len(self.best_player_history) > 0 and history.my_actions:
            best_player = np.argmax(history.my_actions)
            self.best_player_history.append(best_player)
            if best_player in history.my_actions[-self.punishment_period]:
                action = Action.C
            else:
                self.punishment_period = min(2 * self.punishment_period, self.game_description.n_players)
        return action

class Strategy_EXPLOITATIVE_313(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Cooperation (TFTA) strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.retaliation_threshold = int(game_description.n_rounds * 0.75)
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros((1,)), np.zeros((self.game_description.n_players, 1), dtype=bool), np.zeros((1,)))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        self.history = history or self.history
        if state.round_number == 0:
            return Action.C
        current_round = self.history.opponent_actions[-1, 0]
        if current_round and self.history.my_payoffs[-1] > self.game_description.k * np.mean(self.history.opponent_payoffs[-1]) + 1:
            return Action.C
        elif not current_round and state.round_number > 1:
            return Action.D
        elif self.history.my_actions[:-1].sum() >= self.retaliation_threshold:
            return Action.D
        if state.round_number < self.game_description.n_rounds:
            cooperate_score = np.sum(self.history.my_payoffs[:-1])
            defect_score = np.sum(self.history.opponent_payoffs[:-1])
            return Action(cooperate_score > defect_score)
        else:
            cooperate_score = np.sum(self.history.my_payoffs[:-1])
            defect_score = np.sum(self.history.opponent_payoffs[:-1])
            return Action(cooperate_score > defect_score)

class Strategy_EXPLOITATIVE_402(BaseStrategy):
    """
    Tit-for-Tat with Adaptation strategy for N-Player Public Goods Game.
    This strategy cooperates initially, retaliates against defectors, and forgives cooperation to encourage potential future cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_opponent_action = None
        self.current_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.current_round = state.round_number
            return Action.C
        self.current_round = state.round_number
        if self.last_round_opponent_action is None and history.my_actions[-1]:
            self.last_round_opponent_action = history.my_actions[-1]
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[self.current_round - 1])
        my_action = history.my_actions[-1] if self.current_round > 0 else Action.C
        if my_action == Action.C and self.last_round_opponent_action == Action.C:
            return Action.C
        elif my_action == Action.D and self.last_round_opponent_action == Action.C:
            return Action.D
        elif opponent_cooperators < self.game_description.n_players // 2 and my_action != Action.D:
            self.last_round_opponent_action = my_action
            return Action.D
        elif self.last_round_opponent_action is None or opponent_cooperators >= self.game_description.n_players // 2:
            self.last_round_opponent_action = my_action
            return Action.C

class Strategy_EXPLOITATIVE_443(BaseStrategy):
    """
    A strategy that cooperates initially and mimics opponents' actions from the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        return Action.C if opponent_cooperators >= self.game_description.n_players // 2 else Action.D

class Strategy_EXPLOITATIVE_471(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_rounds = 10
        self.CTmin = math.floor(game_description.n_players / 2)
        self.recent_rounds = min(self.game_description.n_rounds, 10)
        self.average_contributions = np.zeros(self.recent_rounds + 1)
        self.CT = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.average_contributions = np.zeros(self.recent_rounds + 1)
            for i in range(self.initial_rounds):
                self.average_contributions[i] = sum(history.opponent_actions[:, i]) / self.game_description.n_players
        if state.round_number <= self.initial_rounds:
            return Action.C
        total_contributions = sum(history.opponent_actions[:, -1])
        self.average_contributions[self.recent_rounds] = total_contributions / self.game_description.n_players
        self.CT = self.update_cooperative_threshold(state.round_number, self.game_description, total_contributions)
        return self.decide_action(state.round_number, self.game_description, self.game_description.k, history.my_actions[-1], total_contributions, self.CT)

    def update_cooperative_threshold(self, round_number: int, game_description: PublicGoodsDescription, total_contributions: float) -> float:
        if round_number <= self.initial_rounds:
            return np.mean(self.average_contributions[:])
        else:
            avg = np.mean(self.average_contributions[-self.recent_rounds:])
            if avg < self.CTmin:
                return self.CTmin
            return avg

    def decide_action(self, round_number: int, game_description: PublicGoodsDescription, k: float, own_contribution: bool, total_contributions: float, CT: float) -> Action:
        if total_contributions < CT:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_17(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.own_actions_history = []
        self.opponent_last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and self.opponent_last_action is not None:
            self.opponent_last_action = history.opponent_actions[-1, self.__class__.__name__]
        action = Action.C if self.opponent_last_action else Action.D
        self.own_actions_history.append(action)
        return action

class Strategy_COLLECTIVE_25(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-A) strategy for N-Player Public Goods Game.
    Prioritizes cooperation when there is evidence of consistent collaboration from other players,
    adapting to new situations as the game progresses and promoting fairness and reciprocity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consistent_players = set()
        self.longest_streak = math.ceil(game_description.n_rounds / 2)
        self.last_round_cooperators = [0] * game_description.n_players
        self.majority_cooperators = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < self.game_description.n_rounds:
            return Action.D
        current_cooperators = sum(history.opponent_actions[-1, :])
        average_cooperation = np.mean(history.opponent_actions[:, -1])
        if current_cooperators >= self.majority_cooperators:
            return Action.C
        elif average_cooperation > 0.5 and len(self.consistent_players) == 0:
            self.consistent_players.update([i for i, action in enumerate(history.opponent_actions[:, -1]) if action])
            self.longest_streak = max(self.longest_streak, len(self.consistent_players))
        elif len(self.consistent_players) > 0 and current_cooperators >= self.majority_cooperators - 1:
            player = random.choice(list(self.consistent_players))
            if history.opponent_actions[-self.longest_streak, player].all():
                return Action.C
        elif average_cooperation > 0.5:
            self.consistent_players.update([i for i, action in enumerate(history.opponent_actions[:, -1]) if action])
            self.last_round_cooperators = [current_cooperators] * len(self.consistent_players) + [0] * (game_description.n_players - len(self.consistent_players))
        elif len(self.consistent_players) > 0:
            self.last_round_cooperators = [sum(self.last_round_cooperators[i]) for i in self.consistent_players] + [0] * (game_description.n_players - len(self.consistent_players))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if sum(self.last_round_cooperators) >= self.majority_cooperators else Action.D
        return Action.D

class Strategy_COLLECTIVE_76(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_level = 0.0
        self.last_round_action = Action.D

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.cooperation_level = self.calculate_cooperation_level(history)
        action = self.decide_action(state, history)
        self.last_round_action = action
        return action

    def calculate_cooperation_level(self, history: PlayerHistory) -> float:
        cooperation_count = np.sum(history.opponent_actions[:, -1])
        total_players = history.opponent_actions.shape[1]
        if total_players == 0:
            return 0.0
        else:
            return float(cooperation_count) / total_players

    def decide_action(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        cooperation_level = self.cooperation_level
        if cooperation_level > 0.5 or history.opponent_actions[-1, -1] == Action.C:
            return Action.C
        elif self.last_round_action == Action.C:
            return Action.C
        else:
            return self.last_round_action

class Strategy_COLLECTIVE_132(BaseStrategy):
    """
    The Adaptive Tit-for-Tat with Public Goods Factor (ATFPG) strategy.
    Encourages cooperation by initiating cooperation in the first round,
    reciprocating cooperation from opponents, and adjusting punishment based on a public goods factor.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.last_cooperation = -1

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < state.round_number + 1:
            self.last_cooperation = -1
            return Action.C
        last_cooperation = max([i for i, action in enumerate(history.opponent_actions[:, self.__class__]) if action])
        defect_rounds = math.ceil((state.round_number - last_cooperation) / self.k)
        if defect_rounds > 0:
            return Action.D * defect_rounds + Action.C
        else:
            self.last_cooperation = state.round_number
            return Action.C

class Strategy_COLLECTIVE_207(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

    Summary: Implementation of the ATFT strategy that cooperates when it's beneficial for both individual payoffs and collective well-being by reciprocating good deeds and punishing defections. Over time, the adaptive nature of the strategy allows for gradual adjustments in trust scores based on past interactions, fostering a collective mindset that encourages cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.trust_scores = np.full(self.n_players, 0.5)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C if random.random() < 0.5 else Action.D
        if state.round_number == 1:
            for player in range(1, self.n_players + 1):
                self._update_trust_score(player, history)
            return Action.C if random.random() < 0.5 else Action.D
        current_round = len(history.opponent_actions) - 1
        last_action = history.opponent_actions[current_round, state.round_number % self.n_players - 1]
        my_last_action = history.my_actions[current_round]
        action = Action.C if last_action == my_last_action else Action.D
        self._update_trust_score(state.round_number % self.n_players - 1, history)
        return action

    def _update_trust_score(self, player: int, history: PlayerHistory):
        if history.my_actions[-1] == Action.C:
            self.trust_scores[player] += 0.1
        elif history.my_actions[-1] == Action.D and self.trust_scores[player] > 0:
            self.trust_scores[player] -= 0.1

class Strategy_COLLECTIVE_221(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for the N-Player Public Goods Game.
    This strategy cooperates in the first round, and subsequently mimics the opponent's action from the previous round.
    If it's the last round, TFTA decides to cooperate or defect based on which action provides a better payoff in the current situation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.rounds_played = 0
        self.opponent_history = []

    def get_opponent_action(self, history):
        return history.opponent_actions[self.rounds_played - 1] if self.rounds_played > 0 else None

    def update_opponent_history(self, my_action):
        self.opponent_history.append(my_action)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if not history:
            history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if state.round_number == 0:
            self.update_opponent_history(Action.C)
            return Action.C
        my_action = self.get_opponent_action(history)
        last_round = state.round_number == self.game_description.n_rounds - 1
        payoff_cooperate = (1 - Action.C.value if my_action else 1) + self.game_description.k / self.game_description.n_players * sum(history.my_actions[history.my_payoffs > 0])
        payoff_defect = history.my_payoffs[-1] if my_action else 1 + self.game_description.k / self.game_description.n_players * sum(history.my_actions[history.my_payoffs > 0])
        return Action.C if payoff_cooperate > payoff_defect and (not last_round) else Action.D

class Strategy_COLLECTIVE_243(BaseStrategy):
    """Adaptive Tit-for-Tat (ATfT) strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = [Action.C] * game_description.n_players
        self.m = math.ceil(game_description.n_rounds / game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history:
            if state.round_number == 0:
                return Action.C
            else:
                self.history = [h[i] for h in history.opponent_actions for i in range(len(self.history))]
        action = self.history[state.round_number % len(self.history)]
        if state.round_number == 1:
            return action
        opponent_action = history.opponent_actions[-1][state.round_number % len(history.opponent_actions)]
        self.history[state.round_number % len(self.history)] = opponent_action
        if opponent_action == Action.C:
            payoff = 1 - action + self.game_description.k / self.game_description.n_players * np.sum(history.opponent_actions[-1])
            return action
        else:
            return Action.D
        if state.round_number % self.m == 0 and len(self.history) != state.round_number % len(self.history):
            next_player = state.round_number % len(self.history) + 1
            self.history[next_player] = not self.history[state.round_number % len(self.history)]

class Strategy_COLLECTIVE_338(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.stable_coop_threshold = math.ceil(game_description.n_players / 2)
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        elif state.round_number == 0:
            self.history = history
            return self.decide_action(state, self.history)
        else:
            self.history = PlayerHistory(self.history.my_actions[:state.round_number + 1], self.history.my_payoffs[:state.round_number + 1], self.history.opponent_actions[:, :state.round_number + 1], self.history.opponent_payoffs[:state.round_number + 1])
            return self.decide_action(state, self.history)

    def decide_action(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        is_stable = np.all(np.diff(history.opponent_actions[:, -2:], axis=1).sum(axis=0) >= self.stable_coop_threshold * (self.game_description.n_players - 1))
        if not is_stable and np.count_nonzero(history.opponent_actions[-1]) > self.stable_coop_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_361(BaseStrategy):
    """
    A Tit-for-Tat with Adaptation strategy for the N-Player Public Goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.opponent_cooperators = {}
        self.opponent_defectors = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent = self.__class__
        action = Action.D
        if history is not None:
            for round_idx, (cooperators, defectors) in enumerate(zip(history.opponent_actions[-1], self.opponent_defectors.values())):
                if sum(cooperators) > len(cooperators) // 2:
                    action = Action.C
                elif sum(defectors) > len(defectors) // 2:
                    action = Action.D
                elif round_idx == 0 or self.opponent_cooperators[opponent] >= len(self.opponent_cooperators):
                    action = Action.C
            for round_idx, action_list in enumerate(history.opponent_actions):
                if any(action_list):
                    self.update_opponent_cooperators(opponent, action_list)
                    self.update_opponent_defectors(action_list)
        return action

    def update_opponent_cooperators(self, opponent: type, actions: NDArray[np.bool_]):
        cooperators = sum(actions)
        if opponent not in self.opponent_cooperators:
            self.opponent_cooperators[opponent] = cooperators
        else:
            self.opponent_cooperators[opponent] += cooperators

    def update_opponent_defectors(self, actions: NDArray[np.bool_]):
        defectors = sum([1 - action for action in actions])
        if np.any(actions):
            self.history.my_payoffs[-1] += self.game_description.k / self.game_description.n_players * defectors

class Strategy_COLLECTIVE_451(BaseStrategy):
    """
    A strategy that mimics the action of the most frequent cooperators among all players from the previous rounds.
    If multiple players have the same frequency, chooses one randomly. If no player has cooperated at all in the recent history, defects to avoid being taken advantage of.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.history = []
        self.forgiveness_period = int(math.ceil(game_description.n_players / 2))
        self.trust_threshold = int(math.floor(game_description.n_rounds * 0.75))
        self.most_frequent_cooperators = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        self.history.append(history)
        if len(self.history) <= state.round_number:
            return Action.D
        most_frequent_cooperators = self._get_most_frequent_cooperators()
        if not most_frequent_cooperators or len(most_frequent_cooperators) == 0:
            return Action.D
        opponent = random.choice(most_frequent_cooperators)
        if state.round_number <= self.forgiveness_period:
            return Action.C
        cooperator_history = self._get_cooperator_history(opponent)
        if len(cooperator_history) >= self.trust_threshold and cooperator_history[-1] == Action.C:
            return Action.C
        return self._mimic_opponent_actions(opponent, history)

    def _get_most_frequent_cooperators(self):
        if not self.history or len(self.history) <= self.forgiveness_period:
            return None
        frequencies = [[] for _ in range(self.n_players)]
        for round_history in reversed(self.history):
            for i, player in enumerate(round_history.opponent_actions[-1]):
                if player:
                    frequencies[i].append(frequencies[i][-1] + 1)
                else:
                    frequencies[i].append(frequencies[i][-1] - 1)
        cooperators = sorted([player for i, player in enumerate(frequencies) if max(i, 0) > sum(i)], reverse=True)[:self.forgiveness_period]
        return cooperators

    def _get_cooperator_history(self, opponent):
        if not self.most_frequent_cooperators or opponent not in self.most_frequent_cooperators:
            return None
        index = self.most_frequent_cooperators.index(opponent)
        cooperator_history = [round_history.opponent_actions[0, index] for round_history in self.history]
        return np.array(cooperator_history)

    def _mimic_opponent_actions(self, opponent, history):
        opponent_history = self._get_cooperator_history(opponent)
        if not opponent_history:
            return Action.D
        opponent_actions = [round_action[opponent] for round_action in history.opponent_actions]
        return np.select([np.equal(opponent_actions, opponent_history)], [Action.C, Action.D], default=Action.D)

class Strategy_COLLECTIVE_465(BaseStrategy):
    """
    Implements the Tit-for-Tat with Modified Grace Period strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.grace_period = int(math.ceil(game_description.n_players / 2))
        self.switching_adjustment_rounds = self.grace_period * 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_strategy = Action.D
        if history and (not history.my_actions[0]):
            opponent_strategy = Action.C
        current_state = np.where(history.my_actions[:state.round_number], opponent_strategy, Action.D)
        last_opponent_strategy = current_state[-1]
        opponent_switched = np.any(current_state != last_opponent_strategy)
        if not opponent_switched or len(history.my_actions) > self.switching_adjustment_rounds:
            return last_opponent_strategy
        return Action.C if last_opponent_strategy == Action.D else Action.D

class Strategy_EXPLOITATIVE_27(BaseStrategy):
    """
    A strategy that cooperates initially, but adjusts cooperation based on opponents' behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperation_threshold = game_description.n_players // 2
        self.window_size = int(math.ceil(game_description.n_rounds * 0.9))
        self.opponent_cooperation_history = np.zeros(self.window_size, dtype=int)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        opponent_cooperation = sum(history.opponent_actions[max(0, round_number - self.window_size):round_number, :])
        average_opp_cooperation = np.mean(self.opponent_cooperation_history)
        if average_opp_cooperation > self.average_cooperation_threshold or round_number == self.game_description.n_rounds:
            self.opponent_cooperation_history = np.roll(self.opponent_cooperation_history, -1)
            self.opponent_cooperation_history[round_number % self.window_size] = int(Action.C == history.my_actions[round_number])
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_104(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.d = math.ceil(game_description.n_players / 2)
        self.t = int(game_description.n_players * 0.75)
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        elif history is None:
            self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
            return Action.D
        else:
            self.history = history
            if state.round_number == self.game_description.n_rounds - 1 or self.game_description.n_rounds - self.game_description.n_players <= state.round_number:
                if np.any(self.history.opponent_actions[-1, :]):
                    return Action.C
                else:
                    return Action.D
            else:
                total_defectors = sum(self.history.opponent_actions[-self.d:, -1])
                if total_defectors > self.t:
                    return Action.C
                elif np.any(self.history.opponent_actions[-1, :]):
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_210(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    Cooperates initially, responds with defection to previous defection, and cooperates in response to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_actions = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not self.previous_actions:
            return Action.C
        if self.previous_actions and history and (len(history.my_actions) >= state.round_number):
            last_action = history.my_actions[-1]
            if last_action:
                return Action.C
            elif self.previous_actions[-1]:
                return Action.D
        if history and len(history.my_actions) >= state.round_number - 1:
            self.previous_actions = history.my_actions[:state.round_number]
        if state.round_number == self.game_description.n_rounds:
            return self.previous_actions[-1] if self.previous_actions else Action.C
        self.previous_actions = None
        return Action.C

class Strategy_EXPLOITATIVE_292(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Gradient Adjustment (TfTGA)
    Description: Implementing a cooperative strategy that adapts to the behavior of other players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.g = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            cooperators_previous_round = np.mean(np.array([random.choice([True, False]) for _ in range(self.game_description.n_players)]))
            return Action(int(cooperators_previous_round))
        if history is None:
            return Action.C
        cooperators_previous_round = np.mean(history.opponent_actions[-1])
        action = Action.D
        if cooperators_previous_round >= self.game_description.n_players * self.g:
            action = Action.C
        payoff = 1 - action.value + self.game_description.k / self.game_description.n_players * np.sum(history.opponent_actions[-1])
        if action == Action.C and cooperators_previous_round >= self.game_description.n_players * self.g:
            adjustment = 0.1
        elif action == Action.D and cooperators_previous_round < self.game_description.n_players * self.g:
            adjustment = -0.1
        else:
            adjustment = 0
        self.g += adjustment
        return action

class Strategy_EXPLOITATIVE_362(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy in the N-player Public Goods Game.
    This strategy cooperates initially and responds cooperatively unless provoked by defection,
    punishing defectors for four consecutive rounds before resuming cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_count = 0
        self.last_action = Action.C
        self.last_two_actions = [Action.C] * 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_two_actions[-1] = self.last_action
        self.last_two_actions[0] = self.last_two_actions[-2]
        self.last_action = Action.D if history else Action.C
        if state.round_number <= self.game_description.n_rounds - 4 and self.punishment_count < 4:
            return Action.D
        if history and (self.last_two_actions[-1] == Action.C and self.last_two_actions[-2] == Action.C and (self.last_action == Action.D)):
            self.punishment_count = 0
        elif history and self.last_action == Action.D:
            self.punishment_count += 1
        if state.round_number == self.game_description.n_rounds and history:
            avg_payoff = np.mean(history.my_payoffs[1:])
            if np.allclose(self.game_description.k * np.sum(history.my_actions) / self.game_description.n_players, avg_payoff) or history.my_payoffs[-1] >= avg_payoff:
                return Action.C
        if self.punishment_count == 0 and self.last_action == Action.C:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_492(BaseStrategy):
    """
    A strategy that cooperates when the majority contributes and punishes those who do not, with a small probability of randomness to avoid predictability.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1, :])
        my_past_action = history.my_actions[-1] if history else False
        if cooperators > self.game_description.n_players // 2:
            return Action.C
        elif my_past_action and cooperators <= self.game_description.n_players // 2:
            return Action.C
        elif not my_past_action and cooperators <= self.game_description.n_players // 2:
            return Action.D
        else:
            if random.random() < self.p:
                return Action.C if my_past_action else Action.D
            return my_past_action

class Strategy_EXPLOITATIVE_507(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Variable Defection (TFTV)

    A strategy that cooperates in the first round and reciprocates cooperation, defects once, and then returns to cooperation when an opponent does so. If an opponent has a certain threshold of continuous defections, TFTV defects multiple times before returning to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_defects = []
        self.threshold = int(game_description.n_players * 0.7)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            current_round = state.round_number - 1
            opponent_cooperators = sum(history.opponent_actions[current_round, :])
            if current_round >= 2 and history.my_actions[current_round - 1] == Action.C and (history.my_actions[current_round - 2] == Action.C):
                return Action.C
            self.opponent_defects = [] if len(self.opponent_defects) < self.threshold else self.opponent_defects[-self.threshold:]
            if opponent_cooperators > 0 and history.my_actions[current_round - 1] == Action.D:
                self.opponent_defects.append(current_round)
            if len(self.opponent_defects) >= self.threshold:
                num_defections = min(len(self.opponent_defects), self.threshold)
                for _ in range(num_defections):
                    action = Action.D
            else:
                action = Action.D if history.my_actions[current_round - 1] == Action.C else Action.C
        return action

class Strategy_COLLECTIVE_513(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_threshold = math.ceil(game_description.n_players * 0.8)
        self.last_opponent_action = [Action.C]

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is not None:
            self.last_opponent_action = history.opponent_actions[-1]
        if state.round_number == 0 or len(self.last_opponent_action) < self.game_description.n_players:
            return Action.C
        last_opponent = self.last_opponent_action[-1]
        if last_opponent == Action.C:
            return Action.C
        else:
            cooperators = np.sum(history.opponent_actions[-1])
            if cooperators < self.game_description.n_players - self.punishment_threshold:
                return Action.C
            self.last_opponent_action[-1] = last_opponent
        return Action.D

class Strategy_COLLECTIVE_514(BaseStrategy):
    """
    A Tit-for-Tat Adaptive (TFT-A) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.moving_average_window = math.ceil(self.game_description.n_rounds * 0.8)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            h = min(self.game_description.k / self.game_description.n_players, 1)
        else:
            cooperators = np.sum(history.opponent_actions[-self.moving_average_window:, -1])
            h = cooperators / self.moving_average_window if self.moving_average_window > 0 else min(self.game_description.k / self.game_description.n_players, 1)
        action = Action.D if h < self.game_description.k / self.game_description.n_players else Action.C
        self.history.my_actions[state.round_number] = action == Action.C
        return action

class Strategy_COLLECTIVE_516(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

    Strategy Description: In the first round, cooperate to establish a cooperative environment. For subsequent rounds, analyze past actions of opponents and adjust cooperation accordingly:
        - If an opponent has cooperated in the previous round, cooperate back.
        - If an opponent has defected in the previous round, defect in this round unless the opponent has shown a consistent pattern of cooperation or lack thereof for a certain number of rounds (threshold). In that case, respond with the same action as the opponent did during the threshold period.
    To encourage initial cooperation and deter repeated defections, gradually increase generosity over time by decreasing the threshold for cooperative responses.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponents = []
        self.threshold = math.ceil(game_description.n_rounds / 4)
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.C
        if history is not None and self.current_round > 0:
            opponent_action = history.opponent_actions[self.current_round - 1, 0]
            if opponent_action == Action.D:
                if self.current_round >= self.threshold:
                    action = history.opponent_actions[-self.threshold][-1]
        self.opponents.append(history.my_actions[self.current_round - 1])
        self.current_round += 1
        if state.round_number == self.game_description.n_rounds or (self.current_round > math.ceil(self.game_description.n_rounds / 2) and len(self.opponents) >= math.ceil(self.game_description.n_rounds / 4)):
            self.threshold = math.ceil((self.game_description.n_rounds - self.current_round) / 4)
        return action

class Strategy_COLLECTIVE_517(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game, promoting reciprocity and sustained cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_round_cooperators = sum(history.opponent_actions[-1]) if history else 0
        if history and len(history.opponent_actions) >= 2:
            self.last_round_cooperators = sum(history.opponent_actions[-1])
            if self.last_round_cooperators >= (self.game_description.n_players + 1) // 2:
                return Action.C
        return Action.D if self.last_round_cooperators == 0 else Action.C

class Strategy_COLLECTIVE_518(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TFT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.probability_p = 1
        self.total_cooperative_encounters = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        last_opponent_action = opponent_actions[-1]
        total_cooperators = sum(opponent_actions)
        if self.game_description.n_players // 2 <= total_cooperators:
            action = Action.C
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if last_opponent_action == Action.C:
                action = Action.C
            else:
                action = Action.D
        elif last_opponent_action == Action.C:
            action = Action.C
        elif random.random() < self.probability_p:
            action = Action.C
        else:
            action = Action.D
        if action == Action.C and last_opponent_action == Action.C:
            self.total_cooperative_encounters += 1
            self.probability_p *= self.total_cooperative_encounters / state.round_number
            self.probability_p = min(self.probability_p, 1)
        return action

class Strategy_COLLECTIVE_519(BaseStrategy):
    """
    A freeriding Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.first_round = True
            return Action.C if random.random() >= 0.5 else Action.D
        if not history:
            cooperators = 0
        else:
            cooperators = sum(history.opponent_actions[-1, :])
        if self.first_round and cooperators < self.game_description.n_players - 1:
            self.first_round = False
            return Action.D
        elif self.first_round or cooperators >= self.game_description.n_players - 1:
            return Action.C
        else:
            return Action.C if cooperators < self.game_description.n_players - 1 and history.my_actions[-2] == Action.C else Action.D

class Strategy_COLLECTIVE_520(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.opponent_actions) == 0:
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1][-1]
        if self.last_opponent_action is None:
            return Action.C
        return Action(self.last_opponent_action)

class Strategy_COLLECTIVE_521(BaseStrategy):
    """
    The Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number > 0 and self.last_round_history is None):
            return Action.C
        cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        if cooperators >= self.game_description.n_players // 2:
            action = Action.C
        else:
            action = Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            self.last_round_history = history.opponent_actions[state.round_number]
        return action

class Strategy_COLLECTIVE_522(BaseStrategy):
    """
    A strategy that implements the Adaptive Tit-for-Tat (ATFT) in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.first_round = True
            return Action.C
        if self.first_round:
            self.last_round_cooperators = np.sum(history.opponent_actions[0])
            self.first_round = False
        action = Action.C if history is None else self._determine_action(history)
        return action

    def _determine_action(self, history: PlayerHistory) -> Action:
        current_cooperators = np.sum(history.opponent_actions[-1])
        if self.last_round_cooperators == 0 and current_cooperators > 0:
            return Action.C
        elif self.last_round_cooperators > 0 and current_cooperators == 0:
            return Action.D
        self.last_round_cooperators = current_cooperators
        return Action.C if current_cooperators >= (self.game_description.n_players + 1) // 2 else Action.D

class Strategy_COLLECTIVE_523(BaseStrategy):
    """
    Implementation of the Tit-for-Tat (TFT) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        if state.round_number == self.game_description.n_rounds:
            self.last_opponent_action = None
            return Action.D
        if not history:
            self.last_opponent_action = Action.C
            return Action.C
        cooperator_count = sum(history.opponent_actions[last_round])
        if self.last_opponent_action is None:
            self.last_opponent_action = Action.C
            return Action.C
        elif cooperator_count >= (self.game_description.n_players - 1) // 2:
            self.last_opponent_action = Action.C
            return Action.C
        else:
            self.last_opponent_action = Action.D
            return Action.D

class Strategy_COLLECTIVE_524(BaseStrategy):
    """
    Tit-for-Tat with Gradual Cooperation (TFTG) strategy for N-Player Public Goods Game.
    Cooperates when more than half of the players cooperated in the previous round, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = 0
        self.increment = 0.1
        self.max_T = game_description.n_players // 2 + 1
        self.recent_rounds = int(math.ceil(game_description.n_rounds * 0.8))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_cooperators = sum(history.opponent_actions[state.round_number - 1]) if history else 0
        if n_cooperators > self.T:
            return Action.C
        return Action.D

    def update_T(self, cooperation_rate):
        if cooperation_rate > self.max_T:
            self.T = self.max_T
        elif cooperation_rate > self.T + self.increment:
            self.T += self.increment

class Strategy_COLLECTIVE_525(BaseStrategy):
    """
    A game theory strategy implementing Tit-for-Tat with Adaptation (TFT-A).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.F = 5
        self.P = 10
        self.forgiveness = 0
        self.punishment_threshold = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1][0] if history else Action.D
        if opponent_action == Action.C:
            self.forgiveness += 1
            self.punishment_threshold = 0
            return Action.C
        elif self.forgiveness < self.F and self.punishment_threshold < self.P:
            self.punishment_threshold += 1
            return Action.D
        else:
            self.forgiveness = 0
            return Action.C

class Strategy_COLLECTIVE_526(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.k * (1 - 1 / game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_cooperation = np.sum(history.opponent_actions[:, -1]) if history else 0
        if total_cooperation >= self.game_description.n_players - total_cooperation:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1 and total_cooperation > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_527(BaseStrategy):
    """
    A simple strategy that follows the Adaptive Tit-for-Tat approach in the N-Player Public Goods Game. The strategy cooperates with other players if they mostly cooperate and defects otherwise. It starts by cooperating in the first round to encourage cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        self.total_cooperators = cooperators
        decision = Action.C if cooperators >= self.game_description.n_players // 2 else Action.D
        return decision

class Strategy_COLLECTIVE_528(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    Cooperates in the first round, then reciprocates the opponent's previous action.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_cooperation = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        last_opponent_action = history.opponent_actions[-1, -1] if history else self.initial_cooperation
        action = Action.C if last_opponent_action else Action.D
        self.initial_cooperation = not last_opponent_action
        return action

class Strategy_COLLECTIVE_529(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            self.first_round = True
            return Action.C
        elif not history:
            self.first_round = False
            return Action.C
        elif self.first_round:
            action = Action.C
            self.first_round = False
        else:
            opponent_action = history.opponent_actions[-1][0]
            if opponent_action == Action.C:
                action = Action.C
            elif opponent_action == Action.D:
                action = Action.D
        return action

class Strategy_COLLECTIVE_530(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None and self.last_opponent_action is not None:
            last_player = (state.round_number - 1) % self.game_description.n_players
            current_opponent = history.opponent_actions[-1][last_player]
            self.last_opponent_action = current_opponent
            return Action(int(current_opponent))
        else:
            self.last_opponent_action = None
            return Action.C

class Strategy_COLLECTIVE_532(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.sqrt(self.game_description.n_players)
        self.punishment_period = math.ceil(self.threshold)
        self.round_cooperators = [0] * (self.game_description.n_rounds + 1)
        self.current_round_cooperators = 0
        self.current_punishment_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.round_cooperators[state.round_number] = sum(history.opponent_actions[-1, :])
        if state.round_number < self.punishment_period and self.current_round_cooperators < self.threshold:
            self.current_punishment_count += 1
        elif state.round_number >= self.punishment_period and self.current_punishment_count > 0:
            self.current_punishment_count -= 1
        self.current_round_cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        return Action.C if self.current_round_cooperators >= self.threshold else Action.D

class Strategy_COLLECTIVE_534(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators > (self.n_players - 1) // 2 and state.round_number > 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_535(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy in N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperated_last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is None:
            return Action.C
        self.opponent_cooperated_last_round = sum(history.opponent_actions[-1, :]) > 0
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        return Action(1 - self.opponent_cooperated_last_round)

class Strategy_COLLECTIVE_536(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation strategy that reciprocates cooperative or defective behavior among players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_action = Action.C
        self.total_payoff = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return self.previous_action
        if history is not None:
            current_round = len(history.my_actions)
            if current_round == self.game_description.n_players:
                self.total_payoff += history.my_payoffs[-1]
                if self.total_payoff > history.my_payoffs[-1]:
                    self.previous_action = Action.D
                else:
                    self.previous_action = Action.C
            else:
                cooperation = self.previous_action
                cooperators = sum(history.opponent_actions[current_round - 1])
                if cooperators == current_round - 1:
                    self.previous_action = cooperation
                elif cooperators > current_round - 2:
                    self.previous_action = Action.C
                else:
                    self.previous_action = Action.D
        return self.previous_action

class Strategy_COLLECTIVE_538(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.majority_threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators > self.majority_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_540(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None
        self.average_contributions = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if not self.history:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            total_contributions = np.sum(history.opponent_actions[:, -1]) * (self.game_description.k / self.game_description.n_players)
            if total_contributions < self.average_contributions * (self.game_description.n_players - 1):
                return Action.D
            else:
                return Action.C
        self.update_history(history)
        my_opponent_action = self.history[-1] if self.history else None
        return Action(my_opponent_action == Action.C).value if my_opponent_action is not None else Action.C

    def update_history(self, history: PlayerHistory) -> None:
        if self.history is None and history is not None:
            self.history = [history.my_actions[0]]
        elif self.history is not None and history is not None:
            self.history.append(history.my_actions[-1])

class Strategy_COLLECTIVE_541(BaseStrategy):
    """
    Implementation of the Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Games.
    The strategy encourages reciprocity, fosters a learning environment, and promotes stability among players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.player_id = None
        self.initial_phase_length = math.ceil(game_description.n_rounds * 0.2)
        self.main_phase_punishment_length = game_description.n_rounds // 10
        self.forgiveness_threshold = game_description.n_rounds // 10

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.player_id = self.__class__.__name__.lower().replace('strategy', '')
            return Action.C
        action = Action.C
        if history is None:
            self.player_id = self.__class__.__name__.lower().replace('strategy', '')
            for i, player in enumerate(history.opponent_actions[0]):
                if player:
                    self.player_id = str(i + 1)
                    break
        opponent_cooperators = np.count_nonzero(history.opponent_actions[-1])
        if state.round_number >= self.initial_phase_length and state.round_number < self.initial_phase_length + self.main_phase_punishment_length:
            most_frequent, _ = np.unique(history.opponent_actions[-1], return_counts=True)
            if len(most_frequent) > 1 and np.max(most_frequent) >= opponent_cooperators:
                action = Action.C if opponent_cooperators > len(most_frequent) // 2 else Action.D
            elif opponent_cooperators >= self.game_description.n_players // 2:
                action = Action.C
        elif state.round_number >= self.initial_phase_length + self.main_phase_punishment_length and state.round_number < self.initial_phase_length + self.main_phase_punishment_length + self.forgiveness_threshold:
            if history.my_actions[-1] != Action.D:
                action = Action.C
        elif state.round_number >= self.initial_phase_length + self.main_phase_punishment_length + self.forgiveness_threshold and history.my_actions[-1] == Action.C:
            action = Action.C
        return action

class Strategy_COLLECTIVE_542(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.aggression_threshold = int(math.ceil(self.game_description.n_players / 2))
        self.last_round = math.floor(self.game_description.n_rounds * 0.1)
        self.aggression_probability = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if cooperators < self.aggression_threshold:
            self.aggression_probability = max(self.aggression_probability - 0.05, 0)
        else:
            self.aggression_probability = min(self.aggression_probability + 0.1, 1)
        return np.random.choice([Action.C, Action.D], p=[self.aggression_probability, 1 - self.aggression_probability])

class Strategy_COLLECTIVE_543(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game.
    A simple and adaptable rule set that encourages mutual trust and reciprocity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_payoff = 0
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if state.round_number == len(history.opponent_actions):
            if self.total_payoff >= 0:
                return Action.C
            else:
                return Action.D
        action = history.opponent_actions[-state.round_number] if state.round_number > 0 else None
        self.last_opponent_action = action
        if action is not None:
            return action
        else:
            return Action.C

class Strategy_COLLECTIVE_544(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / 2)
        self.history = PlayerHistory(np.zeros((1, game_description.n_rounds), dtype=bool), np.zeros((1, game_description.n_rounds)), np.zeros((game_description.n_players, game_description.n_rounds), dtype=bool), np.zeros((game_description.n_players, game_description.n_rounds)))

    def __call__(self, state: GameState, history: PlayerHistory):
        self.history.my_actions[-1] = [state.round_number == 0] if history is None else history.my_actions[-1]
        self.history.my_payoffs[-1] = np.zeros(self.game_description.n_rounds)
        if state.round_number == 0:
            return Action.C
        total_contributions = sum(history.opponent_actions[-1, :])
        my_previous_action = self.history.my_actions[-1][-1]
        if my_previous_action == Action.C and total_contributions >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_546(BaseStrategy):
    """
    A strategy that reciprocates cooperative actions of other players and adapts personal contribution based on the current state of cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []
        self.cooperators_threshold = int(self.game_description.n_players * 0.5)
        self.contributors_threshold_low = int((self.game_description.n_players - self.cooperators_threshold) / 2)
        self.contributors_threshold_high = int(self.game_description.n_players * 0.8)
        self.min_contribution = self.game_description.k / self.game_description.n_players
        self.max_contribution = 1 + self.game_description.k * 2 / self.game_description.n_players
        self.interpolation_factor = (self.max_contribution - self.min_contribution) / (self.contributors_threshold_high - self.contributors_threshold_low + 1)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        personal_contribution = self.min_contribution
        if state.round_number < self.game_description.n_rounds - 1:
            if cooperators >= self.cooperators_threshold:
                personal_contribution += self.interpolation_factor * (state.round_number - self.contributors_threshold_low) * (self.max_contribution - self.min_contribution)
            elif state.round_number > self.contributors_threshold_low:
                personal_contribution -= self.interpolation_factor * (state.round_number - self.contributors_threshold_high) * (self.max_contribution - self.min_contribution)
        if cooperators >= len(history.opponent_actions[-1]) // 2 and state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D if personal_contribution < sum(history.opponent_actions[-1]) else Action.C

class Strategy_COLLECTIVE_547(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    The strategy encourages cooperation as a means of fostering trust among players, while also punishing defection to discourage selfish behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        opponent_action = history.opponent_actions[-1][-1] if len(history.opponent_actions) > 0 else None
        self.opponent_history.append(opponent_action)
        if not self.opponent_history:
            return Action.C
        if opponent_action == Action.C and state.round_number != self.game_description.n_rounds - 1:
            return Action.C
        elif opponent_action == Action.D and state.round_number != self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_548(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TFT-A) strategy for N-Player Public Goods Game.
    This strategy cooperates in the first round and subsequently responds to opponents' actions in a predictable manner.
    It encourages mutual cooperation and fosters a collective mindset of fair play.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if history is not None:
            self.history = history
        if state.round_number < len(self.history.opponent_actions):
            return self.history.opponent_actions[-state.round_number, 0]
        cooperators = sum(self.history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_550(BaseStrategy):
    """
    A Tit-for-Tat Adaptive (TfTA) strategy for N-Player Public Goods Game.
    This strategy mimics the cooperative behavior of opponents in previous rounds,
    and includes forgiveness after three consecutive defeats by opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defeats = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.consecutive_defeats >= 3:
            self.consecutive_defeats = 0
        opponent_cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        if opponent_cooperators > 0:
            return Action.C
        self.consecutive_defeats += 1 if history.opponent_actions[state.round_number - 1, -1] == Action.D else 0
        return Action.D

class Strategy_COLLECTIVE_551(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat (TFT) with Fitness-Based Evolution (TFT-FE)
    This strategy follows a simple yet adaptive rule for cooperation in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_action_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_action_history) == 0:
            return Action.C
        opponent_cooperation = sum(history.opponent_actions[-1, :])
        self.opponent_action_history.append(opponent_cooperation >= self.game_description.n_players // 2)
        if self.opponent_action_history[-1]:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_552(BaseStrategy):
    """Tit-for-Tat with Adaptive Cooperation Strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.6
        self.grace_period = int(game_description.n_rounds * 0.1)
        self.rounds_played = 0
        self.cooperation_rate = 0.0
        self.cooperative_actions_count = 0
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if self.rounds_played < self.grace_period:
            return Action.C
        if history is None:
            opponent_actions = np.zeros(self.game_description.n_players, dtype=np.bool_)
        else:
            opponent_actions = history.opponent_actions[-1]
        if self.rounds_played < len(self.opponent_history):
            cooperation_decision = self.opponent_history[-1] == Action.C
        else:
            cooperative_actions_count = np.sum(self.opponent_history[-len(self.opponent_history):] == Action.C)
            self.cooperation_rate = cooperative_actions_count / (self.rounds_played - self.grace_period + 1)
            cooperation_decision = self.cooperation_rate > self.threshold
        action = Action.D if not cooperation_decision else Action.C
        self.opponent_history.append(action)
        self.rounds_played += 1
        return action

class Strategy_COLLECTIVE_553(BaseStrategy):
    """
    Tit-for-Tat with Gradual Cooperation (TFTGC) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.max_cooperators = math.ceil(game_description.n_players * game_description.n_rounds / 2)
        self.current_round = 0
        self.opponents = [(0, 0) for _ in range(game_description.n_players)]

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            self.current_round += 1
            return Action.C
        self.current_round += 1
        cooperators = sum(history.opponent_actions[-1, :])
        best_opponent = max(self.opponents, key=lambda x: x[0])
        best_cooperators = best_opponent[0]
        punishment_counter = (self.current_round - 1) * (best_cooperators / self.max_cooperators)
        if self.current_round == 1 or punishment_counter >= best_cooperators:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_554(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game.
    This strategy cooperates in the first round to demonstrate a cooperative intent,
    and adapts its actions based on the previous round's actions of all players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.previous_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None and np.sum(history.opponent_actions[-1]) == len(history.opponent_actions[0]) - 1:
            self.previous_round_cooperators = 1
        else:
            self.previous_round_cooperators += np.sum(history.opponent_actions[-1])
        if self.previous_round_cooperators == len(history.opponent_actions[0]):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_555(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.current_round = 0
        self.history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.current_round = state.round_number
        if self.history is None or self.history.round_number < self.current_round - 1:
            return Action.C
        opponent_cooperators = sum(self.history.opponent_actions[self.current_round - 1, :])
        if self.current_round == self.game_description.n_rounds:
            return Action.C
        else:
            return self.history.opponent_actions[self.current_round - 1, (self.current_round - 1) % self.game_description.n_players]

class Strategy_COLLECTIVE_556(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperate_counter = 0
        self.defect_counter = 0
        self.total_rounds = game_description.n_players * game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_action = Action.D if self.defect_counter >= self.total_rounds // 2 else Action.C
        if not history:
            self.cooperate_counter = 1
            self.defect_counter = 0
            return my_action
        cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number > 1 and cooperators >= self.game_description.n_players // 2:
            if my_action == Action.C:
                self.cooperate_counter += 1
            else:
                self.defect_counter += 1
        elif state.round_number > 1 and cooperators < self.game_description.n_players // 2:
            self.defect_counter += 1
        elif my_action == Action.C:
            self.defect_counter = max(0, self.defect_counter - 1)
        elif my_action == Action.D:
            self.cooperate_counter = max(0, self.cooperate_counter + 1)
        return my_action

class Strategy_COLLECTIVE_557(BaseStrategy):
    """
    Implementation of Tit-for-Tat (TFT) strategy in N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.prev_state = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.prev_state is None:
            return Action.D
        total_contributions_prev = np.sum(history.opponent_actions[self.prev_state.round_number])
        cooperate = False if total_contributions_prev <= self.game_description.n_players // 2 else True
        return Action.C if state.my_actions[-1] and cooperate else Action.D

    def update_prev_state(self, state: GameState) -> None:
        """
        Store the current game state for future decision making.
        """
        self.prev_state = state

class Strategy_COLLECTIVE_558(BaseStrategy):
    """
    A strategy that fosters cooperation while being adaptable and robust against a wide range of opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_history = history.opponent_actions[-1]
        all_cooperators = np.all(last_history)
        if all_cooperators:
            self.last_round_cooperators += 1
            return Action.C
        else:
            if self.last_round_cooperators == 0:
                return Action.D
            self.last_round_cooperators = 0
            return Action.C

class Strategy_COLLECTIVE_559(BaseStrategy):
    """
    Tit-for-Tat Adaptive Strategy (TFT-A) for N-Player Public Goods Game.
    Encourages cooperation and responds reciprocally to opponent actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperator = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            frequency = np.bincount(history.opponent_actions[-1, :].flatten())
            last_cooperator = np.argmax(frequency)
            cooperators = sum(history.opponent_actions[-1, :])
            if max(frequency) > self.game_description.n_players // 2:
                if history.opponent_actions[-1, last_cooperator] == Action.C:
                    return Action.C
                else:
                    return Action.D
            if last_cooperator is not None and history.opponent_actions[-1, last_cooperator] == Action.C:
                self.last_cooperator = last_cooperator
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_560(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t = game_description.k + 1
        self.max_t = math.ceil(2 * game_description.n_players - 1)
        self.min_t = math.floor((game_description.k + 1) / 2)
        self.history = PlayerHistory(my_actions=np.array([[Action.C]], dtype=np.bool_), my_payoffs=np.array([], dtype=np.float64), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.bool_), opponent_payoffs=np.zeros(game_description.n_rounds * game_description.n_players, dtype=np.float64))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            self.history.my_actions[0] = [Action.C]
            return Action.C
        opponent_cooperators_in_last_round = sum(self.history.opponent_actions[-1, :])
        average_cc = np.mean(self.history.my_actions[:, -self.game_description.n_players:])
        if self.game_description.n_rounds == state.round_number or average_cc >= self.max_t:
            self.t = self.min_t
        action = Action.C if average_cc > self.t else Action.D
        self.history.my_actions[-1] = [action.value]
        return action

class Strategy_COLLECTIVE_561(BaseStrategy):
    """
    Implementation of Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = Action.D

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions if history else np.zeros((1, self.game_description.n_players), dtype=np.bool_)
        last_round = state.round_number - 1 if history else 0
        last_opponent_action = opponent_actions[last_round]
        self.last_opponent_action = last_opponent_action
        return Action(int(last_opponent_action[-1]) ^ 1)

    def finalize_round(self, state: GameState, history: PlayerHistory):
        self.last_opponent_action = history.opponent_actions[-1]

class Strategy_COLLECTIVE_562(BaseStrategy):
    """
    A simple Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    The strategy initially cooperates in the first round, and then cooperates if all opponents cooperated in the previous round; otherwise, defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.init_coop = math.ceil(self.game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        modified_atft = self.modified_ATFT(state.round_number, history, self.game_description.n_players, self.game_description.k, self.init_coop)
        if modified_atft:
            return Action.C
        else:
            return Action.D

    def modified_ATFT(self, round_number: int, history: PlayerHistory, n: int, k: float, init_coop: int) -> bool:
        if round_number <= init_coop:
            return True
        previous_round = len(history.my_actions) - 1 if history else 0
        cooperators = np.sum(history.opponent_actions[previous_round]) if history else 0
        return cooperators == n

class Strategy_COLLECTIVE_563(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    Strategy Description: Cooperates if at least h% of players contributed in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_threshold = int(game_description.n_players * game_description.k / 100)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return random.choice([Action.C, Action.D])
        elif history is not None:
            if len(history.opponent_actions[-1]) < self.contribution_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_564(BaseStrategy):
    """
    Tit-for-Tat Evolution (T4TE) Strategy for N-player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_payoff = 0
        self.average_payoff = np.mean([0] * game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        action = Action.C if state.round_number == 0 else self._get_action(history)
        if state.round_number == self.game_description.n_rounds:
            if self.total_payoff < self.average_payoff:
                action = Action.D
        return action

    def _get_action(self, history: PlayerHistory):
        last_opponent_actions = history.opponent_actions[-1]
        if np.sum(last_opponent_actions) == self.game_description.n_players - 1:
            return Action.D
        else:
            return Action.C if np.all(history.my_actions[:-1]) == Action.C and last_opponent_actions[-1] == Action.C else Action.D

class Strategy_COLLECTIVE_565(BaseStrategy):
    """
    A Tit-for-Tat with Forgiveness strategy for the N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0
        self.last_opponent_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self.forgiveness_counter = max(self.forgiveness_counter - 1, 0)
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) < self.game_description.n_players):
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        self.last_opponent_cooperators = cooperators
        if cooperators >= self.game_description.n_players // 2:
            self.forgiveness_counter = self.game_description.n_rounds // 3 if self.forgiveness_counter == 0 else self.forgiveness_counter
        return Action.C if cooperators > self.last_opponent_cooperators or history.opponent_actions[-2, -1] == Action.C else Action.D

class Strategy_COLLECTIVE_566(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.adaptive_window_size = min(game_description.n_players - 1, math.ceil(game_description.n_rounds / 2))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[:, state.round_number - self.adaptive_window_size:state.round_number], axis=1) >= self.game_description.n_players * (self.adaptive_window_size / self.game_description.n_players)
        return Action.C if np.all(cooperators) else Action.D

class Strategy_COLLECTIVE_567(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = math.floor(self.game_description.n_players * self.game_description.n_rounds / 2)
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        self.history.my_actions[0] = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            history = self.history
            self.history.opponent_payoffs[0] = 1 + self.game_description.k / self.game_description.n_players * sum(history.my_actions)
        if state.round_number == 0:
            return Action.C
        elif history.opponent_payoffs[-1].sum() >= self.cooperative_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_568(BaseStrategy):
    """
    Tit-for-Tat Evolutionary Adaptive Public Goods Game strategy.
    Encourages cooperation when more than half of the players are cooperating in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_init = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < self.p_init else Action.D
        cooperators = np.count_nonzero(history.opponent_actions[-1, :])
        last_action = history.my_actions[-1] if history is not None else Action.D
        if cooperators > self.game_description.n_players // 2 and last_action == Action.D or (cooperators == self.game_description.n_players // 2 or history is None):
            return Action.C
        elif cooperators < self.game_description.n_players // 2 and last_action == Action.C:
            return Action.D
        return Action.C if random.random() < cooperators / self.game_description.n_players else Action.D

class Strategy_COLLECTIVE_569(BaseStrategy):
    """
    A Tit-for-tat strategy with adaptive cooperation that encourages collaboration and responds to opponents' actions
    in a flexible manner by gradually increasing the likelihood of cooperating when facing repeated defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_factor = 0.2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or self.consecutive_defections == 0:
            self.consecutive_defections = 0
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2 and state.round_number > 1:
            return Action.C
        self.consecutive_defections += 1 if history.opponent_actions[-1][0] else -1
        cooperation_probability = max(0, 1 - self.forgiveness_factor * self.consecutive_defections)
        return Action(int(random.random() < cooperation_probability))

class Strategy_COLLECTIVE_570(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy with forgiveness in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            self.punishment_count = 0
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators == 0 and history is not None:
            self.punishment_count += 1
            if self.punishment_count < self.game_description.n_rounds:
                return Action.D
            else:
                self.punishment_count = 0
        else:
            self.punishment_count = 0
        return Action.C

class Strategy_COLLECTIVE_571(BaseStrategy):
    """
    Tit-for-Tat-Adaptive (TfTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.5
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and self.last_opponent_action is not None:
            last_round = len(history.opponent_actions) - 1
            if last_round == state.round_number - 1:
                opponent_action = history.opponent_actions[last_round, state.round_number % self.game_description.n_players]
                if opponent_action == self.last_opponent_action:
                    self.last_opponent_action = opponent_action
                    return Action.C if opponent_action else Action.D
                elif last_round == state.round_number - 2 and self.last_opponent_action != opponent_action:
                    self.last_opponent_action = opponent_action
                    return Action.D
        if state.round_number == self.game_description.n_rounds or random.random() < self.p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_572(BaseStrategy):
    """
    A strategy that adopts the Adaptive Tit-for-Tat approach in N-Player Public Goods Games.
    This strategy encourages cooperation while punishing defection and strikes a balance between collective success and self-interest.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds), np.zeros(game_description.n_rounds), np.full((game_description.n_rounds, game_description.n_players), False).T, np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        elif np.all(history.opponent_actions[-1]):
            return Action.C
        else:
            return Action.D

    def update_history(self, state: GameState, action: Action):
        if self.history.my_actions[0] is None:
            self.history = PlayerHistory(np.full(self.game_description.n_rounds, action), np.zeros(self.game_description.n_rounds))
        self.history.my_actions[state.round_number] = action == Action.C
        if state.round_number < self.game_description.n_rounds:
            self.history.opponent_actions[state.round_number, :] = self.history.opponent_actions[state.round_number - 1, :]
        self.history.my_payoffs[state.round_number] = self._calculate_payoff(self.game_description, self.history)

class Strategy_COLLECTIVE_573(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.recent_opponent_actions = np.zeros(self.n_players, dtype=int)
        self.num_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        self.num_rounds += 1
        if history is not None:
            for i in range(self.n_players - 1):
                self.recent_opponent_actions[i] = (self.recent_opponent_actions[i] + int(history.opponent_actions[-1][i])) % 2
        opponent_cooperators = np.count_nonzero(self.recent_opponent_actions)
        if opponent_cooperators >= (self.n_players - 1) * 2 // 3:
            return Action.C
        elif opponent_cooperators <= (self.n_players - 1) * 1 // 3:
            return Action.D
        probability = 0.5 + 0.5 * math.cos(math.pi * (opponent_cooperators - np.count_nonzero(self.recent_opponent_actions == 0)))
        return Action.C if random.random() < probability else Action.D

class Strategy_COLLECTIVE_575(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.last_opponent_action = None
            return Action.C
        if state.round_number == len(history.opponent_actions) - 1:
            self.last_opponent_action = np.mean(history.opponent_actions[:, -1])
        action = Action.D
        if history.my_actions[-1] != action and self.last_opponent_action is not None:
            action = self.last_opponent_action
        elif history.my_actions[-1] == action:
            action = Action.C
        return action

class Strategy_COLLECTIVE_577(BaseStrategy):
    """
    A strategy implementing the Tit-for-Tat (with adaptation) in N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.k = self.game_description.k
        self.r = self.game_description.n_rounds
        self.history_size = int(self.r * 0.1)
        self.decay = 0.95
        self.sensitivity = 0.1
        self.long_term_coop = [0.0]
        self.average_coop = [0.0]
        self.threshold = [0.0]
        self.players = set()
        self.cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number < self.history_size:
            return Action.C
        current_player = len(self.players)
        self.players.add(current_player)
        if len(self.cooperation_history) < self.history_size:
            cooperation_rate = 0.0
        else:
            cooperation_rate = np.mean(self.cooperation_history[-self.history_size:])
            self.average_coop[-1] = cooperation_rate
        threshold = self.decay * self.long_term_coop[-1] + self.sensitivity * (cooperation_rate - self.long_term_coop[-1])
        self.threshold[-1] = threshold
        play_C = cooperation_rate >= threshold
        self.cooperation_history.append(play_C)
        if state.round_number == self.r - 1 and threshold > 0.5:
            play_C = True
        payoff = self._calculate_payoff(play_C, self.cooperation_history[-1], current_player)
        if len(self.long_term_coop) > self.history_size:
            self.long_term_coop.pop(0)
        return Action(int(play_C))

    def _calculate_payoff(self, play_C, cooperation_rate, current_player):
        total_contributions = sum(self.cooperation_history[-self.history_size:])
        payoff = 1 - play_C + self.k / self.n_players * total_contributions
        return payoff

class Strategy_COLLECTIVE_578(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat with Probability of Defection (A-TTDP)
    Strategy Description: Responds to opponent's actions by cooperating or defecting based on their past behavior, with a probability of defection that increases over time if the opponent continues to defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_init = 0.2
        self.p_growth = 1.5
        self.consecutive_defections = 0
        self.first_opponent_move = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            opponent_action = history.opponent_actions[state.round_number - 1, 0] if self.first_opponent_move else history.opponent_actions[-1, 0]
            self.first_opponent_move = False
            if opponent_action:
                return Action.C
            elif state.round_number > 1:
                self.consecutive_defections += 1 if opponent_action == Action.D else 0
                p = min(self.p_init + (1 - self.p_init) * (self.p_growth ** self.consecutive_defections / (1 + self.p_growth ** self.consecutive_defections)), 1.0)
                return Action.C if random.random() > p else Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_579(BaseStrategy):
    """
    An adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.strategy_state = {'round': 0}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.strategy_state['random_choice'] = random.choice([True, False])
            return Action(int(self.strategy_state['random_choice']))
        self.strategy_state['round'] = state.round_number
        total_contributions = sum(history.opponent_actions[self.strategy_state['round'] - 1] if history else [self.strategy_state['random_choice']])
        if np.all(history.opponent_actions[self.strategy_state['round'] - 1] == False):
            return Action.D
        elif np.any(history.opponent_actions[self.strategy_state['round'] - 1]):
            self.strategy_state['random_choice'] = not self.strategy_state['random_choice']
        return Action(int(self.strategy_state['random_choice']))

    def update_history(self, history: PlayerHistory):
        """
        Update the strategy state with the given game history.
        """
        self.strategy_state['round'] += 1
        self.strategy_state['random_choice'] = random.choice([True, False])

class Strategy_COLLECTIVE_580(BaseStrategy):
    """
    A Tit-for-Tat strategy for the N-Player Public Goods Game.
    This strategy encourages cooperation and reciprocity, adjusting actions based on previous rounds to foster long-term cooperation when possible.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self._init_phase = int(self.r // self.n) + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if history is None else self._decide_action(state, history)
        round_number = state.round_number - 1
        if round_number < self._init_phase:
            return Action.C
        cooperators = sum(history.opponent_actions[round_number, :])
        if cooperators > (self.n - 1) // 2:
            return Action.C
        return Action.D

    def _decide_action(self, state: GameState, history: PlayerHistory):
        if state.round_number >= self._init_phase:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators > (self.n - 1) // 2:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_581(BaseStrategy):
    """
    Implementation of the Tit-for-Tat strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperated_last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        self.cooperated_last_round = history.opponent_actions[-1, :].mean() > 0
        return self.cooperated_last_round and Action.C or Action.D

class Strategy_COLLECTIVE_582(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

    The strategy promotes a cooperative environment and incentivizes reciprocity.
    It encourages cooperation in the initial round, followed by adaptive actions based on opponents' previous moves.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_threshold = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.C
            if state.round_number % self.game_description.n_rounds == 1:
                cooperators = history.opponent_actions[-1, :].sum()
                if cooperators >= self.forgiveness_threshold:
                    return Action.C
            else:
                cooperators_prev = history.opponent_actions[-2, :].sum()
                cooperators_curr = history.opponent_actions[-1, :].sum()
                if cooperators_prev > 0 and cooperators_curr >= self.forgiveness_threshold:
                    return Action.C
        return Action.D

class Strategy_COLLECTIVE_583(BaseStrategy):
    """
    Tit-for-Tat-Adaptive (TfTA) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._cooperative_players = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            self._cooperative_players = sum(history.opponent_actions[-1, :])
            if self._cooperative_players == self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_584(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Strategy for N-Player Public Goods Game, demonstrating cooperative intent and encouraging others to follow suit while punishing defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        action = Action.C
        if history is not None and len(history.opponent_actions) > state.round_number - 1:
            self.opponent_cooperation_count += int(history.opponent_actions[state.round_number - 1, :].mean())
            if state.round_number != self.game_description.n_rounds and self.opponent_cooperation_count >= self.game_description.n_players // 2:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_COLLECTIVE_585(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_last = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds * (1 - self.p_last):
            return Action.C
        if history:
            last_round = len(history.opponent_actions) - 1
            last_cooperators = sum(history.opponent_actions[last_round])
            if last_cooperators == self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_586(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    This strategy fosters cooperation by adapting to other players' behavior while maintaining a fair balance between individual interests and collective welfare.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance_rate = game_description.n_players // 100
        self.round_history = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.update_round_history(state, history)
        if state.round_number == self.game_description.n_rounds:
            return self.tit_for_tat(self.round_history[-1])
        current_action = self.round_history[-1][0] if self.round_history else None
        consecutive_defectors = self.consecutive_defectors(self.round_history, current_action)
        consecutive_cooperators = self.consecutive_cooperators(self.round_history)
        if current_action == Action.C and consecutive_defectors < (1 - self.tolerance_rate) * self.game_description.n_rounds:
            return Action.C
        if current_action == Action.D and consecutive_cooperators > self.tolerance_rate * self.game_description.n_rounds:
            return Action.D
        return self.tit_for_tat(current_action)

    def update_round_history(self, state: GameState, history: PlayerHistory):
        if not self.round_history:
            self.round_history = [(Action.C,)] * self.game_description.n_rounds
        self.round_history[-state.round_number] = (history.my_actions[state.round_number - 1],)

    def consecutive_defectors(self, history: list, last_action: Action):
        count = sum((1 for action in history if action == Action.D and action != last_action))
        return count if last_action == Action.C else 0

    def consecutive_cooperators(self, history: list):
        count = sum((1 for action in reversed(history) if action == Action.C))
        return count if history[0] == Action.D else 0

    def tit_for_tat(self, last_action: Action):
        return Action.C if last_action == Action.C else Action.D

class Strategy_COLLECTIVE_587(BaseStrategy):
    """
    A Tit-for-Tat strategy for N-Player Public Goods Game, encouraging reciprocity and promoting a sense of community.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_round_action is None:
            return Action.C
        self.last_round_action = history.my_actions[-1] if history else False
        return self.last_round_action

class Strategy_COLLECTIVE_588(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if self.game_description.n_players not in self.history:
            self.history[self.game_description.n_players] = {}
        if state.round_number - 1 not in self.history[self.game_description.n_players]:
            self.history[self.game_description.n_players][state.round_number - 1] = []
        if len(self.history[self.game_description.n_players][state.round_number - 1]) < state.round_number:
            opponents = [i for i in range(1, self.game_description.n_players + 1)]
            self.history[self.game_description.n_players][state.round_number - 1].extend(opponents)
        opponent_action = self.history[self.game_description.n_players][state.round_number - 1][state.round_number % self.game_description.n_players]
        if opponent_action == Action.C:
            return Action.C
        elif opponent_action == Action.D:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_589(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

    Summary: This strategy cooperates in the first round and then mimics other players' actions from the previous round.
             If all players cooperated, it continues to cooperate. If any player defected, it defects in the current round.
             If a player switches from cooperation to defection, ATFT will mimic their behavior for one round before returning to its original strategy (cooperating if everyone cooperated last round, defecting otherwise).
             In the last round and in situations where all players have previously defected, ATFT may switch to a more aggressive strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.aggressive = False
        self.punishment_rounds = 3

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or (history is None and state.round_number > 0):
            return Action.C
        if self.aggressive:
            self.aggressive = False
            return Action.D
        if history is not None and all(history.opponent_actions[-self.game_description.n_rounds:, -1] == [0]):
            self.aggressive = True
            return Action.D
        if all(history.opponent_actions[-self.game_description.n_rounds:, -1] == [1]):
            return Action.C
        else:
            opponent_defected = history.opponent_actions[-1, -1]
            if opponent_defected:
                self.aggressive = False
                return Action.D
            return Action.C

class Strategy_COLLECTIVE_591(BaseStrategy):
    """
    A strategy that mimics opponent's previous action with a fading memory effect,
    encouraging cooperation in an effort to maintain positive relationships over time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.lambda_ = 0.95
        self.memory_length = min(int(math.ceil(game_description.n_players / 2)), 10)
        self.fading_history = np.zeros((self.memory_length,), dtype=np.float64)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = np.sum(history.opponent_actions[-1]) if history is not None else 0
        self.update_fading_memory(opponent_cooperators)
        previous_action = self.get_fading_memory(state.round_number - 1)
        current_opponent_action = Action(int(history.opponent_actions[state.round_number - 1][0])) if history is not None else None
        return Action.C if previous_action >= 0.5 and (current_opponent_action is None or current_opponent_action == Action.C) else Action.D

    def update_fading_memory(self, opponent_cooperators: int):
        self.fading_history = np.roll(self.fading_history, -1)
        self.fading_history[-1] = (1 - self.lambda_) * opponent_cooperators + self.lambda_ * self.fading_history[-2]

    def get_fading_memory(self, round: int):
        if round > len(self.fading_history) - 1:
            return 0.5
        return self.fading_history[round]

class Strategy_COLLECTIVE_592(BaseStrategy):
    """
    A strategy that encourages cooperation by mimicking the previous action of the opponent, promoting fairness and long-term cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[-1]) if history is not None else None
        return Action(int(self.last_opponent_action))

class Strategy_COLLECTIVE_593(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-A) strategy for N-Player Public Goods Game.
    Cooperates in the first round, mirrors other players' actions in subsequent rounds and punishes defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        self.history = history or PlayerHistory(np.zeros((state.round_number + 1,), dtype=bool), np.zeros((state.round_number + 1,)), np.zeros((state.round_number + 1, self.game_description.n_players), dtype=bool), np.zeros((state.round_number + 1, self.game_description.n_players)))
        if state.round_number == 0:
            self.history.my_actions[0] = True
        else:
            last_action = self.history.my_actions[-1]
            last_n_actions = self.history.my_actions[-self.game_description.n_players:-1]
            if np.all(last_n_actions) and len(last_n_actions) > 1:
                self.history.my_actions[-1] = True
            elif last_action:
                self.history.my_actions[-1] = True
            else:
                last_opponent_cooperators = sum(self.history.opponent_actions[-1, :])
                if len(last_n_actions) > 1 and np.all(last_n_actions == False):
                    self.history.my_actions[-1] = False
        return Action(int(self.history.my_actions[-1]))

class Strategy_COLLECTIVE_594(BaseStrategy):
    """
    The Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_actions_history) == 0:
            return Action.C
        last_round = self.opponent_actions_history[-1]
        last_round_cooperators = sum(last_round)
        if state.round_number < self.game_description.n_rounds - 1 and (state.round_number + 1) % 2 == 0:
            return Action.C
        return Action.C if last_round_cooperators >= len(self.opponent_actions_history) // 2 else Action.D

    def update_history(self, history: PlayerHistory):
        self.opponent_actions_history.append(history.opponent_actions[-1])

class Strategy_COLLECTIVE_596(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.avg_cooperators = 0
        self.num_rounds = 0
        self.contribution_change = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        current_cooperators = sum(history.opponent_actions[-1]) if history else 0
        if state.round_number == 1 or current_cooperators > self.avg_cooperators:
            action = Action.C
            self.k += self.contribution_change
        elif current_cooperators < self.avg_cooperators:
            action = Action.D
            self.k -= self.contribution_change
        self.avg_cooperators = (self.avg_cooperators * self.num_rounds + current_cooperators) / (state.round_number + 1)
        self.num_rounds += 1
        return action

class Strategy_COLLECTIVE_598(BaseStrategy):
    """
    Tit-for-Tat Plus (TFT+) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = game_description.n_players // 10

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators >= self.game_description.n_players - self.alpha:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_599(BaseStrategy):
    """
    Tit-for-Tat Cooperation Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.n_players - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players - 1, dtype=bool))
        return Action.C if cooperators >= self.cooperation_threshold else Action.D

class Strategy_COLLECTIVE_600(BaseStrategy):
    """
    A strategy that reciprocates cooperation with cooperation and defection with defection, while being forgiving when others switch back to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.q = game_description.n_players // 2
        self.r_punish = int(math.ceil(self.game_description.n_players * 0.1))
        self.r_reward = int(math.floor(self.game_description.n_players * 0.2))
        self.punish_timer = 0
        self.reward_timer = 0
        self.last_action = Action.C

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        if cooperators >= self.q:
            if self.last_action == Action.D:
                self.reward_timer += 1
                if self.reward_timer >= self.r_reward:
                    self.last_action = Action.C
                    self.reward_timer = 0
            else:
                self.punish_timer += 1
                if self.punish_timer >= self.r_punish:
                    self.last_action = Action.D
                    self.punish_timer = 0
        else:
            self.last_action = Action.D
            self.punish_timer = max(self.punish_timer - self.r_punish, 0)
            self.reward_timer = 0
        return self.last_action

class Strategy_EXPLOITATIVE_513(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.learning_rate = 0.1
        self.threshold = game_description.n_players // 2
        self.average_coop = 0.0
        self.rounds_played = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.rounds_played += 1
        if not history:
            cooperators = [Action.C for _ in range(self.game_description.n_rounds)]
        else:
            cooperators = history.opponent_actions[:, -1].sum()
        if cooperators >= self.threshold:
            return Action.C
        return Action.D
        self.average_coop = (self.rounds_played * self.average_coop + cooperators) / (self.rounds_played + 1)
        self.threshold = (1 - self.learning_rate) * self.threshold + self.learning_rate * self.average_coop

class Strategy_EXPLOITATIVE_514(BaseStrategy):
    """
    The Conditional Cooperative Tit-for-Tat (CCTFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number != self.game_description.n_rounds:
            cooperators = np.sum(history.opponent_actions[-1])
            cooperation_average = cooperators / self.game_description.n_players
            return Action.C if cooperation_average > self.threshold else Action.D
        return Action.D

class Strategy_EXPLOITATIVE_515(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.moving_average = np.zeros(game_description.n_rounds)
        self.threshold = game_description.n_players // 2
        self.punishment_duration = 3
        self.free_rider_reduction_factor = 0.95

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        self.moving_average = np.roll(self.moving_average, -1) if len(self.moving_average) > 1 else self.moving_average
        self.moving_average[-1] = cooperators / (state.round_number + 1)
        if state.round_number < self.punishment_duration:
            return Action(history.opponent_actions[state.round_number - 1, 0])
        if self.moving_average[-1] > self.threshold:
            return Action.C
        elif self.moving_average[-1] < self.threshold * 0.5:
            return Action.D
        else:
            return Action.C if np.mean(self.moving_average) > self.threshold else Action.D

class Strategy_EXPLOITATIVE_516(BaseStrategy):
    """
    The Tit-for-Tat-Cooperative (TFT-C) strategy.
    This strategy encourages cooperation by cooperating initially, then adapting to opponents' actions in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_number = 0
        self.even_number_of_players = game_description.n_players % 2 == 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        self.round_number = state.round_number
        if history is None or len(history.opponent_actions) < self.round_number:
            return Action.C
        total_cooperators = sum(history.opponent_actions[-1])
        if total_cooperators == self.game_description.n_players or (total_cooperators > 0 and total_cooperators < self.game_description.n_players and (self.round_number % 2 != 1)) or (self.even_number_of_players and self.round_number % 2 == 1 and (total_cooperators == self.game_description.n_players - 1)):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_517(BaseStrategy):
    """Tit-for-Tat with Adaptive Cooperation Rate (TFTAC) strategy for the N-Player Public Goods Game."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_count = 0
        self.total_rounds = self.game_description.n_rounds
        self.p = int(math.ceil(self.total_rounds / 10))
        self.inc = 0.01
        self.Thresh = self.game_description.n_players // 2
        self.cp = 0.5
        self.avg_coop = float('inf') if self.p > self.total_rounds else None
        self.TotalCoop = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.avg_coop or (state.round_number % self.p == 0 and state.round_number != self.total_rounds):
            self.avg_coop = self.TotalCoop / self.p
            self.TotalCoop = self.coop_count + self.avg_coop * (self.p - 1)
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        self.coop_count += 1 if history and history.my_actions[-1] == Action.C else 0
        if cooperators >= self.Thresh:
            self.cp += self.inc
        elif cooperators < self.Thresh - self.inc:
            self.cp -= self.inc
        return Action(int(math.floor(self.cp)))

class Strategy_EXPLOITATIVE_518(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = np.mean(np.arange(1, game_description.n_players + 1))
        self.CT_min, self.CT_max = (math.floor(self.cooperation_threshold), math.ceil(self.cooperation_threshold))
        self.ct_adjustment = 0.1
        self.e = np.exp(1)
        self.random_chance = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action(int(random.random() < self.random_chance))
        cooperators = sum(history.opponent_actions[-1, :])
        adjusted_cooperators = (cooperators - self.cooperation_threshold) / self.cooperation_threshold
        if np.isclose(adjusted_cooperators, 0) or np.isclose(adjusted_cooperators, self.e):
            factor = self.e ** (-1 * adjusted_cooperators)
            self.cooperation_threshold = min(max(self.cooperation_threshold + factor * self.ct_adjustment, self.CT_min), self.CT_max)
        action = Action.C if cooperators >= int(self.cooperation_threshold) else Action.D
        return action

    def update_cooperation_threshold(self, current_round, num_cooperators):
        factor = self.e ** ((num_cooperators - self.cooperation_threshold) / (self.cooperation_threshold * self.game_description.n_rounds))
        self.cooperation_threshold = min(max(self.cooperation_threshold + factor * self.ct_adjustment, self.CT_min), self.CT_max)

class Strategy_EXPLOITATIVE_520(BaseStrategy):
    """
    A Tit-for-Tat Plus (TfT+) strategy that cooperates initially and responds reciprocally to other players' actions in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_length = int(math.ceil(game_description.n_players / 2))
        self.past_opponent_actions = np.zeros((self.punishment_length + 1,), dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            last_round = len(history.opponent_actions) - 1
            self.past_opponent_actions = np.roll(self.past_opponent_actions, -1)
            self.past_opponent_actions[-1] = history.opponent_actions[last_round, 0]
            cooperators = np.sum(history.opponent_actions[last_round])
            if np.count_nonzero(self.past_opponent_actions) >= self.game_description.n_players // 2:
                return Action.C
        if np.all(self.past_opponent_actions):
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_522(BaseStrategy):
    """
    A simple Tit-for-Tat Adaptive (TFT-A) strategy for the N-Player Public Goods Game.
    This strategy cooperates initially and then mimics a "trust but verify" approach,
    punishing defection by defecting in response, while resuming cooperation when opponents cooperate again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.lookback_window = int(self.game_description.n_players * 0.2)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_history = history.opponent_actions[:, -1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        recent_cooperators = np.sum(opponent_history)
        if recent_cooperators >= self.lookback_window:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_523(BaseStrategy):
    """
    An exploitative strategy called "Trickster Tit-for-Tat". The strategy encourages cooperation and punishes defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players)), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators > 0:
            self.history.my_payoffs[-1] += self.game_description.k / self.game_description.n_players * opponent_cooperators
            return Action.C
        else:
            self.history.my_payoffs[-1] = math.ceil(1 - sum(history.opponent_payoffs[-1]))
            return Action.D

class Strategy_EXPLOITATIVE_524(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.historical_proportion_cooperators = np.zeros(self.game_description.n_rounds)
        self.adaptation_interval = int(math.ceil(self.game_description.n_rounds / 10))
        self.current_deviation = 0
        self.cooperation_threshold = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return np.random.choice([Action.C, Action.D], p=[0.5, 0.5])
        if self.cooperation_threshold is None:
            self.cooperation_threshold = 0.5
        cooperation_proportion = sum(history.opponent_actions[-1]) / self.game_description.n_players
        self.historical_proportion_cooperators[state.round_number - 1] = cooperation_proportion
        if state.round_number % self.adaptation_interval == 0:
            self.current_deviation = np.abs(self.cooperation_threshold - cooperation_proportion)
            self.cooperation_threshold = np.clip(self.historical_proportion_cooperators.mean() + self.current_deviation * 0.1, 0, 1)
        if cooperation_proportion > self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_525(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TFT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tau = game_description.n_rounds // 4
        self.cooperative_count = np.zeros(self.game_description.n_rounds, dtype=np.int32)
        self.last_action = Action.D

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            cooperative_rate = self.cooperative_count[-1] / self.game_description.n_rounds
            if cooperative_rate > (self.game_description.n_players - self.tau) / self.game_description.n_players:
                return Action.C
            else:
                self.last_action = Action.D
                return Action.D
        else:
            current_round = state.round_number - 1
            recent_history = history.opponent_actions[current_round, :]
            self.cooperative_count[current_round] += np.sum(recent_history)
            if recent_history[-1]:
                self.last_action = Action.C
            else:
                self.last_action = Action.D
            if np.sum(recent_history[:self.tau]) < self.tau:
                self.last_action = Action.D
        return self.last_action

class Strategy_EXPLOITATIVE_527(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = np.zeros((self.game_description.n_rounds, 1), dtype=np.bool_)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = np.sum(history.opponent_actions[-1]) > 0
        self.opponent_history[-1] = opponent_action
        return Action(int(opponent_action)) if state.round_number != self.game_description.n_rounds else self.opponent_history[-1]

class Strategy_EXPLOITATIVE_530(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_len = game_description.n_rounds - 1
        self.m = int(self.history_len * 0.2)
        self.threshold = game_description.n_players // 2
        self.recent_averages = np.zeros((self.m + 1,))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[state.round_number - 1, :]) if history else 0
        average_cooperation = self._smooth_average(self.recent_averages, cooperators)
        if average_cooperation > self.threshold:
            self.threshold += (average_cooperation - self.threshold) / 10
        elif average_cooperation < self.threshold:
            self.threshold -= (self.threshold - average_cooperation) / 10
        return Action.C if average_cooperation >= self.threshold else Action.D

    def _smooth_average(self, averages: np.ndarray, current: int) -> float:
        averages[0] = current
        for i in range(1, len(averages)):
            if i <= self.m:
                averages[i] = (current + averages[i - 1]) / 2
            else:
                averages[i] = (4 * averages[i - 1] + current) / 5
        return averages[-1]

class Strategy_EXPLOITATIVE_531(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.memory_length = int(math.floor(game_description.n_rounds * 0.8))
        self.cooperation_threshold = int(math.ceil(game_description.n_players / 2))
        self.cooperator_count = np.zeros(self.memory_length, dtype=int)
        self.average_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        self.cooperator_count[state.round_number % self.memory_length] = sum(history.opponent_actions[-self.memory_length:, :].flatten()) if history else 0
        self.average_cooperators = np.mean(self.cooperator_count)
        return Action.C if self.average_cooperators > self.cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_533(BaseStrategy):
    """
    Tit-for-Tat-Cooperative (TFTC) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_round_action = history.my_actions[-1]
        if self.last_round_action == Action.C:
            return Action.C
        else:
            return Action.D

    def last_round_action(self) -> Action:
        """
        Return the action taken in the last round.
        """
        return self.last_round_action

class Strategy_EXPLOITATIVE_534(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k_half = math.floor(self.game_description.k / 2)
        self.k_minus_one_over_two = (self.game_description.k - 1) / 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        interpolation = (cooperators - self.k_minus_one_over_two) / (self.k_half - self.k_minus_one_over_two) if cooperators > self.k_minus_one_over_two else 0
        return Action.C if interpolation >= 0.5 else Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.C if cooperators >= self.k_half else Action.D

class Strategy_EXPLOITATIVE_535(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) with Frequency-Dependent Defection (FDD) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.rolling_window_size = math.ceil(self.game_description.n_rounds * 0.1)
        self.threshold = 0.5
        self.learning_rate = 0.05
        self.defection_probability = 0.2
        self.defection_count = 0
        self.rolling_window = np.zeros(self.rolling_window_size, dtype=np.float64)

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 or (history is not None and history.my_actions is None):
            return Action.C
        self.rolling_window = np.roll(self.rolling_window, -1)
        self.rolling_window[-1] = 0 if history is None else self.defection_count / (state.round_number + 1)
        self.defection_count = 0
        defections = np.sum(history.opponent_actions[:, -1])
        if defections > self.threshold * self.n_players:
            self.defection_probability += self.learning_rate
        elif self.defection_probability > 0.2:
            self.defection_probability -= self.learning_rate
        if state.round_number == self.game_description.n_rounds - 1 or (history is not None and np.sum(history.my_payoffs) >= np.sum(history.opponent_payoffs)):
            return Action.C if random.random() < self.defection_probability else Action.D
        return Action.C if history is None or history.my_actions[-1] == 1 else Action.D if random.random() < self.defection_probability else Action.C

class Strategy_EXPLOITATIVE_536(BaseStrategy):
    """
    A strategy that adapts its cooperation threshold based on the behavior of other players in a repeated N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil((game_description.n_players + 1) / 2)
        self.adaptation_rate = 0.01
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        elif history is not None:
            self.history.my_actions[state.round_number - 1] = Action.C if state.round_number > 1 else Action.D
            cooperators = sum(history.opponent_actions[-1, :])
            change_in_cooperation = abs(cooperators - self.history.my_payoffs[-1] * (self.game_description.n_players / state.round_number))
            self.threshold += self.adaptation_rate * change_in_cooperation
        payoff = np.zeros(self.game_description.n_players)
        if history is not None:
            for i, opponent_actions in enumerate(history.opponent_actions):
                total_cooperation = sum(opponent_actions)
                if total_cooperation >= self.threshold:
                    payoff[i] = 1 - (Action.D.value if opponent_actions[-1] else Action.C.value) + self.game_description.k / self.game_description.n_players * cooperators
        self.history.my_payoffs[state.round_number - 1] = payoff[0] if state.round_number > 1 else 1
        return Action.C if sum(history.opponent_actions[-1, :]) >= self.threshold else Action.D

class Strategy_EXPLOITATIVE_537(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploitation_rate = 0.5
        self.lookback = math.ceil(game_description.n_rounds * 0.7)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperation_threshold = self.calculate_cooperation_threshold(history)
        current_cooperators = sum(history.opponent_actions[-1])
        if current_cooperators >= cooperation_threshold:
            return Action.C
        return Action.D

    def calculate_cooperation_threshold(self, history):
        total_contributions = sum([sum(row) for row in history.opponent_actions[-self.lookback:]])
        average_contributions = total_contributions / self.lookback
        cooperation_threshold = (1 - self.exploitation_rate) * average_contributions
        return cooperation_threshold

class Strategy_EXPLOITATIVE_538(BaseStrategy):
    """
    A strategy that implements Tit-for-Tat with an adaptive cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.average_cooperation = np.zeros(game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_payoffs) < self.game_description.n_rounds):
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1, :]) if history is not None else 0
        average_cooperation = (self.average_cooperation[-1] * (self.game_description.n_rounds - 1) + cooperators) / self.game_description.n_rounds
        self.average_cooperation[-1] = average_cooperation
        self.cooperation_threshold = max(min(1, self.cooperation_threshold * (average_cooperation / (average_cooperation + 1 - cooperators))), 0)
        if cooperators > math.floor(self.game_description.n_players * self.cooperation_threshold):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_539(BaseStrategy):
    """
    A strategy that cooperates initially and reciprocates cooperation from opponents while defecting if opponents are uncooperative.
    The strategy encourages cooperation in the short term but punishes those who consistently defect to deter further defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._last_round_cooperation = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number < self.game_description.n_rounds and (not history):
            return Action.C
        else:
            cooperation = history.opponent_actions[-1].any() if state.round_number > 0 else self._last_round_cooperation
            return Action(int(cooperation) == 1) if state.round_number < self.game_description.n_rounds else Action.C

    def update_history(self, history: PlayerHistory):
        history.my_actions[state.round_number - 1] = self.__class__.__name__.upper() == history.my_actions[-1].names[0].upper()
        self._last_round_cooperation = history.my_actions[-1]

class Strategy_EXPLOITATIVE_540(BaseStrategy):
    """
    A Tit-for-Tat with Adaptation (TfTA) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.deviation_probability = 0.05

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number < self.game_description.n_rounds:
            last_action = history.my_actions[-1]
            deviation_probability = 0.1 if np.sum(history.opponent_actions[:, 0]) < self.game_description.n_players // 2 else self.deviation_probability
        else:
            deviation_probability = 0.1
        random_deviation = random.random() <= deviation_probability
        return Action(int(last_action if not random_deviation else 1 - last_action))

class Strategy_EXPLOITATIVE_541(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)
    A cooperative strategy that punishes defection and rewards cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.opponent_history or len(self.opponent_history) < state.round_number:
            self.opponent_history += [None] * (state.round_number - len(self.opponent_history))
        opponent_action = self.opponent_history[state.round_number - 1] if self.opponent_history else None
        if not opponent_action and history:
            opponent_action = history.opponent_actions[state.round_number - 1, 0]
        if opponent_action is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if opponent_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_542(BaseStrategy):
    """
    A simple strategy implementing Tit-for-Tat with Adaptation (TfT-A) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        if state.round_number == self.game_description.n_rounds and len(self.history) > 1 and (sum(self.history[-2]) < self.game_description.n_players):
            return Action.D
        if all([sum(self.history[-i - 1]) < self.game_description.n_players for i in range(1, len(self.history))]):
            return Action.D
        total_contributions = sum([1 if x > 0 else 0 for x in self.history[-1]])
        if total_contributions == self.game_description.n_players:
            return Action.C
        return Action.D

    def update_history(self, contributions: NDArray[np.bool_]):
        """
        Update history with the latest round's total contributions
        """
        self.history.append(contributions)

class Strategy_EXPLOITATIVE_544(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperators = 0
        self.total_cooperators = 0
        self.round_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None and self.round_count > 0:
            self.total_cooperators += np.sum(history.opponent_actions[-1, :])
            self.round_count += 1
            self.average_cooperators = self.total_cooperators / self.round_count * self.game_description.n_players
        if self.average_cooperators > self.game_description.n_players // 2:
            return Action.C
        elif self.average_cooperators < self.game_description.n_players * 0.3:
            return Action.D
        else:
            return random.choice([Action.C, Action.D])

class Strategy_EXPLOITATIVE_545(BaseStrategy):
    """
    Tit-for-Tat Cooperative strategy for the N-Player Public Goods Game.
    This strategy balances cooperation and exploitation by adapting to opponents' behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = state.round_number - 1
        self.last_opponent_action = history.opponent_actions[last_round, :].mean()
        return Action(self.last_opponent_action == 1)

class Strategy_EXPLOITATIVE_546(BaseStrategy):
    """
    A Tit-for-Tat Plus (TfT+) strategy for the N-Player Public Goods Game.
    This strategy encourages cooperation among opponents while also punishing defection.
    It incorporates forgiveness for initial mistakes and flexibility in adapting to changes in opponent strategies.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))
        self.round_number = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) < self.game_description.n_rounds):
            return Action.C
        self.history = history
        self.round_number = state.round_number
        if len(self.history.my_actions) == self.game_description.n_rounds:
            return Action.C
        opponent_cooperators = sum(self.history.opponent_actions[self.round_number - 1, :])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_547(BaseStrategy):
    """
    Tit-for-Tat with Cooperation Threshold (TFT-CT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.punishment_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        opponent_actions = history.opponent_actions[-1]
        if self.punishment_counter > self.cooperation_threshold * self.game_description.n_rounds:
            self.punishment_counter = 0
            return Action.C
        if opponent_actions[-1] == 1 or self.punishment_counter == 0:
            self.punishment_counter = 0
            return Action.C
        self.punishment_counter += 1
        return Action.D

class Strategy_EXPLOITATIVE_548(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive contributions for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_opponents_cooperated = None
        self.current_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.current_round = 0
            return Action.C
        self.current_round += 1
        if self.current_round == 1:
            self.last_round_opponents_cooperated = False
            return Action.C
        elif self.current_round < self.game_description.n_rounds:
            opponents_cooperated = bool(sum(history.opponent_actions[self.current_round - 1]))
            if opponents_cooperated == self.last_round_opponents_cooperated:
                action = Action.C if self.last_round_opponents_cooperated else Action.D
            elif self.last_round_opponents_cooperated is None:
                action = Action.C
            else:
                action = Action.D
            self.last_round_opponents_cooperated = opponents_cooperated
            return action
        else:
            self.last_round_opponents_cooperated = True
            return Action.C

class Strategy_EXPLOITATIVE_549(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = math.floor(game_description.n_players * 0.6)
        self.previous_opponent_action = None
        self.total_cooperation_count = 0
        self.current_round = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if not history:
            return Action.C
        self.current_round = state.round_number
        if self.previous_opponent_action is None:
            self.previous_opponent_action = history.opponent_actions[-1][0]
        cooperate = False
        if self.current_round == 1 or self.previous_opponent_action:
            cooperate = True
        if not cooperate and self.total_cooperation_count < self.cooperative_threshold:
            cooperate = True
        self.total_cooperation_count += sum(history.opponent_actions[-self.game_description.n_rounds:][-1])
        if self.current_round == self.game_description.n_rounds - 10:
            cooperate = False
        return cooperate and Action.C or Action.D

class Strategy_EXPLOITATIVE_551(BaseStrategy):
    """
    Tit-for-Tat-Greedy (TFT-G) Strategy for N-Player Public Goods Game.
    When exactly do you cooperate vs defect?
        - Cooperate if you have cooperated in all previous rounds.
        - Defect if you have defected in any previous round.
        - If opponent's average contribution is less than the average minimum cooperation threshold (AMCT), defect.
        - If opponent's average contribution is greater than or equal to the average maximum cooperation threshold (AMXT), cooperate.
        - Otherwise, mimic the opponent's action from the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.amct = game_description.n_players // 4
        self.amxt = game_description.n_players * 3 // 4

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        my_actions = np.zeros(state.round_number + 1, dtype=np.bool_)
        my_payoffs = np.zeros(state.round_number + 1, dtype=np.float64)
        opponent_actions = history.opponent_actions if history else np.zeros((state.round_number + 1, self.game_description.n_players), dtype=np.bool_)
        my_history = PlayerHistory(my_actions, my_payoffs, opponent_actions, history.opponent_payoffs if history else np.zeros((state.round_number + 1, self.game_description.n_players), dtype=np.float64))
        action = self._decide(my_history)
        return action

    def _decide(self, my_history: PlayerHistory) -> Action:
        if np.all(my_history.my_actions[:-1] == 1):
            opponent_contributions = self._get_opponent_average_contribution(my_history)
            if opponent_contributions >= self.amxt:
                return Action.C
            elif opponent_contributions <= self.amct:
                return Action.D
        elif np.any(my_history.my_actions[:-1]):
            opponent_contributions = self._get_opponent_average_contribution(my_history)
            if opponent_contributions >= self.amxt:
                return Action.C
        elif np.any(my_history.my_actions == 0):
            opponent_contributions = self._get_opponent_average_contribution(my_history)
            if opponent_contributions <= self.amct:
                return Action.D
        else:
            return Action.D

    def _get_opponent_average_contribution(self, my_history: PlayerHistory) -> float:
        total_contributions = np.sum(my_history.opponent_actions[:, -1])
        return total_contributions / len(my_history.opponent_actions) if len(my_history.opponent_actions) > 0 else 0

class Strategy_EXPLOITATIVE_552(BaseStrategy):
    """
    Tit-for-Tat-Gradient (TfTG) Strategy for the N-Player Public Goods Game.
    Follows a tit-for-tat approach with a gradient that makes it more responsive to the average cooperation rate in the game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperation = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.average_cooperation = self.game_description.k / self.game_description.n_players
            return Action.C
        total_contributions_previous = sum(history.opponent_actions[-1])
        if total_contributions_previous >= self.average_cooperation:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_553(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self._last_opponent_action is None:
            return Action.C
        last_opponent_action = history.opponent_actions[-1][-1]
        self._last_opponent_action = last_opponent_action
        if last_opponent_action:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_554(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Contribution (TFTAC) for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.num_opponents = game_description.n_players - 1
        self.k = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        if len(history.opponent_actions) == self.game_description.n_rounds:
            self.history = history
            opponents = np.where(self.history.opponent_actions[:, -1] == Action.D)[0]
            cooperators = len(np.where(self.history.opponent_actions[-1, :] == Action.C)[0])
            if len(opponents) > len(np.where(self.history.opponent_actions[:, -1] == Action.C)[0]):
                return Action.D
            elif self.num_opponents in opponents:
                if len(np.where(self.history.opponent_actions[:, -1] == Action.C)[0]) < len(opponents):
                    return Action.C
            else:
                return Action.C
        else:
            self.history = history
            return Action.C

class Strategy_EXPLOITATIVE_555(BaseStrategy):
    """
    Tit-for-Tat with Adaptation (TFT-A) strategy in an N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.average_cooperation = np.zeros(game_description.n_players)
        self.opponent_cooperators_threshold = 0.5
        self.opponent_defectors_threshold = 0.8
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.current_round = state.round_number
        if history is not None:
            cooperators_this_round = sum(history.opponent_actions[self.current_round - 1, :])
            self.average_cooperation += cooperators_this_round / self.game_description.n_players
        if np.all(self.average_cooperation >= self.opponent_cooperators_threshold):
            return Action.C
        if np.all(self.average_cooperation <= self.opponent_defectors_threshold):
            return Action.D
        opponent = self._find_best_opponent()
        if opponent is not None:
            return Action.C
        return Action.D

    def _find_best_opponent(self) -> int | None:
        max_cooperators = np.min(self.average_cooperation)
        best_opponent_index = np.argmax([sum(history.opponent_actions[round_, i]) for round_ in range(self.current_round) for i in range(1, self.game_description.n_players + 1) if sum(history.opponent_actions[round_, :]) >= max_cooperators])
        return best_opponent_index if best_opponent_index is not None and best_opponent_index != self.player_id else None

class Strategy_EXPLOITATIVE_556(BaseStrategy):
    """
    Tit-for-Tat (with Adaptation) strategy in a N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        elif not history:
            self.first_round = False
            return Action.C
        else:
            self.first_round = False
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators == len(history.opponent_actions[-1]):
                return Action.C
            elif cooperators > 0 and cooperators >= len(history.opponent_actions[-1]) // 2 or len(history.opponent_actions[-1]) - cooperators < len(history.opponent_actions[-1]) // 2:
                return Action.C
            elif cooperators == 0 or cooperators > len(history.opponent_actions[-1]) // 2:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_560(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Cooperation Factor for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.n = game_description.n_players
        self.CF = 1.0
        self.k_rounds = int(self.game_description.n_players * 0.8)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number > self.k_rounds:
            average_cooperation = np.mean(history.my_actions[-self.k_rounds:])
            CF_update = (average_cooperation - self.CF / 2) / self.k
            self.CF *= CF_update + (1 - self.CF) * (1 - average_cooperation)
        cooperate = Action.C if history is not None and history.my_actions[-1] != Action.D and (self.CF > 0.5) else Action.D
        return cooperate

class Strategy_EXPLOITATIVE_561(BaseStrategy):
    """
    Tit-for-Tat Strategy with Adaptive Contribution (TFTAC) for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions_history = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        k_adjustment = 1
        if opponent_cooperators > self.game_description.n_players // 2:
            k_adjustment = 0.85
        elif opponent_cooperators < self.game_description.n_players // 4:
            k_adjustment = 1.15
        self.total_contributions_history[state.round_number - 1] = k_adjustment * np.sum(history.opponent_actions[-1, :]) if history is not None else 0
        c = k_adjustment / self.game_description.n_players * opponent_cooperators if history is not None else 0
        payoff = 1 - c + self.game_description.k / self.game_description.n_players * np.sum(history.opponent_actions[-1, :]) if history is not None else 0
        return Action.C if payoff > 1 else Action.D

class Strategy_EXPLOITATIVE_562(BaseStrategy):
    """
    A cooperative strategy that adapts to the opponent's behavior, prioritizing personal gain while maintaining an initial peaceful front to encourage cooperation from opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, game_description.n_players - 1), dtype=bool), np.zeros(self.game_description.n_rounds))
        self.current_state = 'TfT'
        self.punishment_timer = 0
        self.cooperation_threshold = math.ceil(self.game_description.n_players / 2)
        self.min_consecutive_cooperations = self.game_description.n_rounds // 10

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        self.history.my_actions[state.round_number] = Action.C == self(state, None)
        cooperators = sum(self.history.opponent_actions[-1, :])
        if self.current_state == 'TfT' and cooperators >= self.cooperation_threshold:
            self.punishment_timer = 0
        elif self.current_state == 'DuCw':
            if cooperators >= self.cooperation_threshold * 2:
                self.current_state = 'TfT'
                self.punishment_timer = 0
            else:
                self.punishment_timer += 1
                if self.punishment_timer > self.min_consecutive_cooperations:
                    self.current_state = 'TfT'
                    self.punishment_timer = 0
        payoff = 1 - self.history.my_actions[state.round_number] + self.game_description.k / self.game_description.n_players * cooperators
        self.history.my_payoffs[state.round_number] = payoff
        if state.round_number < self.game_description.n_rounds - 1:
            self.history.opponent_actions[state.round_number + 1, :] = (Action.C == self(state, None)) * np.arange(self.game_description.n_players - 1)
        return Action.C if self.current_state == 'TfT' else Action.D

class Strategy_EXPLOITATIVE_563(BaseStrategy):
    """
    A strategy called Tit-for-Tat with Adaptive Cooperation (TFT-AC). This strategy cooperates in the first round and reciprocates the actions of opponents based on their previous moves. In the last round, it considers the number of cooperators and defectors to decide whether to cooperate or defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_count = 0
        self.opponent_cooperated_last_round = False
        self.opponent_history = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        self.opponent_history = history if history is not None else PlayerHistory(np.zeros((current_round, self.game_description.n_players), dtype=bool), np.zeros(current_round))
        if current_round == 1:
            return Action.C
        elif self.opponent_history is None or self.opponent_history.my_actions[-1].size == 0:
            return Action.C
        else:
            opponent_cooperators = sum(self.opponent_history.opponent_actions[-1])
            self.opponent_cooperated_last_round = opponent_cooperators > 0 and self.opponent_history.opponent_actions[current_round - 2][-1] == Action.C.value
            if self.opponent_cooperated_last_round:
                return Action.C
            elif opponent_cooperators > current_round // 2:
                return Action.C
            else:
                return Action.D
        if current_round == self.game_description.n_rounds:
            opponent_cooperators = sum(self.opponent_history.opponent_actions[:-1].sum(axis=0))
            opponent_defectors = sum(self.opponent_history.opponent_actions[:-1].sum(axis=0) - self.opponent_history.opponent_actions[-1])
            if opponent_cooperators > opponent_defectors:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_564(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.threshold is None:
            self.threshold = math.floor((self.game_description.n_players * self.game_description.k + 1) / 2) - state.round_number // 2
        cooperators = np.sum(history.opponent_actions[-1, :])
        if cooperators >= self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_565(BaseStrategy):
    """
    A Tit-for-Tat strategy with a Modified Cooperation Threshold for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.n_players // 2
        self.learning_rate = 0.1
        self.average_cooperators = np.zeros(self.game_description.n_rounds)
        self.m = int(self.game_description.n_rounds * 0.8)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else self.cooperation_threshold
        self.average_cooperators = np.roll(self.average_cooperators, -1)
        self.average_cooperators[-1] = cooperators
        adjusted_threshold = self.cooperation_threshold + self.learning_rate * (cooperators - np.mean(self.average_cooperators[:self.m]))
        if adjusted_threshold < self.game_description.n_players:
            self.cooperation_threshold = min(adjusted_threshold, self.game_description.n_players - 1)
        return Action.C if cooperators >= self.cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_566(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.n = game_description.n_players
        self.k = game_description.k
        self.average_cooperators = self.n * (self.k / self.r)
        self.opponents_who_cooperated = 0
        self.opponents_who_defected = 0
        self.current_contribution = self.k
        if self.r < self.n * self.k:
            self.current_contribution = self.r / self.n

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number == 0:
            cooperators = sum(history.opponent_actions[0])
            if cooperators > self.n * (self.k / 2):
                self.current_contribution = self.n * (self.k / 2)
        action = Action.D
        if history is not None:
            last_round = len(history.opponent_actions) - 1
            if all([x == 0 for x in history.opponent_actions[last_round]]):
                if self.opponents_who_defected > self.average_cooperators:
                    self.current_contribution *= 1.5
                action = Action.D
            elif all([x == 1 for x in history.opponent_actions[last_round]]):
                if self.opponents_who_cooperated > self.average_cooperators:
                    self.current_contribution /= 1.5
                action = Action.C
            self.opponents_who_cooperated += sum(history.opponent_actions[last_round])
            self.opponents_who_defected += len(history.opponent_actions[last_round]) - self.opponents_who_cooperated
        return action

class Strategy_EXPLOITATIVE_567(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        total_players = len(history.opponent_actions[0])
        if cooperators > self.cooperation_threshold * total_players:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_569(BaseStrategy):
    """
    Tit-for-Tat (TFT) Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if history is None:
            self.history.my_actions[0] = True
            return Action.C
        last_round = state.round_number - 1
        total_contributions = np.sum(self.history.opponent_actions[last_round])
        if self.history.my_actions[last_round] == True and total_contributions >= self.game_description.n_players - 1:
            self.history.my_payoffs[-1] = 1 - self.history.my_actions[last_round] + self.game_description.k / self.game_description.n_players * total_contributions
        else:
            self.history.my_payoffs[-1] = 1 - self.history.my_actions[last_round] + self.game_description.k / self.game_description.n_players * 0
        self.history.my_actions[state.round_number] = self.history.opponent_actions[last_round].mean()
        return Action(int(self.history.my_actions[state.round_number]))

class Strategy_EXPLOITATIVE_570(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.own_action_history = None
        self.others_action_history = np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.bool_)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.own_action_history is None:
            return Action.C
        if self.others_action_history.shape[0] == 1 and history is not None:
            self.others_action_history = history.opponent_actions.copy()
        previous_round = state.round_number - 1
        own_cooperated_last_round = self.own_action_history[-1] == Action.C
        all_others_cooperated_last_round = np.all(self.others_action_history[previous_round])
        own_history = history.my_actions if history is not None else self.own_action_history
        if all_others_cooperated_last_round and own_history == [Action.C]:
            return Action.C
        encountered_defectors = np.any(self.others_action_history[previous_round], axis=0) & (own_history != [Action.C])
        return Action.D if encountered_defectors.any() else self.own_action_history[-1]

class Strategy_EXPLOITATIVE_571(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that uses a Tit-for-Tat+ approach, designed to be exploitative while adapting to a wide range of opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.round_history = np.zeros(self.game_description.n_rounds, dtype=int)
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        self.round_history[state.round_number] = int(history.my_actions[-1])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        self.last_round_cooperators = sum(history.opponent_actions[-1, :])
        if self.last_round_cooperators == self.game_description.n_players:
            return Action.C
        elif sum(history.opponent_actions[-1, :]) > 0:
            return Action.D
        else:
            for i in range(state.round_number - 1, -1, -1):
                if self.round_history[i] == int(history.opponent_actions[i][-1]) != self.last_round_cooperators:
                    return Action(self.round_history[i])
        return Action.C

class Strategy_EXPLOITATIVE_573(BaseStrategy):
    """
    Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0
        self.last_round_defection = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_round_defection:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        opponents_cooperated = cooperators >= self.game_description.n_players // 2
        if not opponents_cooperated:
            self.forgiveness_counter += 1
        else:
            self.forgiveness_counter = 0
        if self.forgiveness_counter < self.game_description.n_players:
            return Action.C
        return Action.D

    def end_round(self, payoffs: NDArray[np.float64]):
        """
        Update state variables after the end of a round.
        """
        self.last_round_defection = False
        for player in range(self.game_description.n_players):
            if payoffs[player, -1] == 1 and history.my_actions[-1, player] == Action.D:
                self.last_round_defection = True

class Strategy_EXPLOITATIVE_574(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions = np.zeros(self.game_description.n_rounds)
        self.my_contribution = np.zeros(self.game_description.n_rounds, dtype=bool)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.D
        elif state.round_number == 0:
            self.my_contribution[state.round_number] = False
            return Action.D
        else:
            total_contributions = sum(history.opponent_actions[-1, :])
            if total_contributions == self.game_description.n_players or (self.my_contribution[state.round_number - 1] and self.total_contributions[state.round_number - 2] == self.game_description.n_players):
                self.my_contribution[state.round_number] = True
                self.total_contributions[state.round_number] = total_contributions
                return Action.C
            else:
                self.my_contribution[state.round_number] = False
                return Action.D

class Strategy_EXPLOITATIVE_575(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-Adaptive (TfTA)
    Strategy Description: This strategy cooperates initially, then adapts to opponents' behavior while maintaining a balance between cooperation and self-interest.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = int(math.ceil(game_description.n_players / 2))
        self.last_round = False if game_description.n_rounds > 1 else True
        self.my_actions = np.zeros((game_description.n_rounds,), dtype=bool)
        self.history = PlayerHistory(self.my_actions, np.zeros((game_description.n_rounds,)), np.zeros((game_description.n_rounds + 1, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds + 1, game_description.n_players)))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            self.history = PlayerHistory(self.my_actions, np.zeros((self.game_description.n_rounds,)), np.zeros((self.game_description.n_rounds + 1, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds + 1, self.game_description.n_players)))
            return Action.C if state.round_number == 0 else Action.D
        self.history = history
        current_round = state.round_number
        if current_round == 1:
            return Action.C
        last_cooperation = np.where(self.my_actions[-2:] == 1)[0].size > 0
        recent_defections = sum(self.history.opponent_actions[current_round - 1, :]) - np.where(self.my_actions[-2:] == 1)[0].size
        self.tolerance = int(math.ceil((self.game_description.n_players + recent_defections) / 2)) if self.last_round else self.tolerance
        cooperate = np.where(self.my_actions[-1] == 1, 1, 0) >= self.tolerance
        return Action.C if last_cooperation and cooperate else Action.D

class Strategy_EXPLOITATIVE_576(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.n_players * 0.8)
        self.contribution_level = 1.0
        self.initial_contribution_level = 1.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponents_actions = history.opponent_actions[-1]
        cooperators = sum(opponents_actions)
        if all(opponents_actions):
            if self.contribution_level < self.game_description.k / self.game_description.n_players:
                self.contribution_level += 0.1
        elif any(~opponents_actions):
            if self.contribution_level > self.initial_contribution_level:
                self.contribution_level -= 0.1
        if state.round_number >= self.threshold and any(~opponents_actions) and all(opponents_actions[-self.threshold:]):
            self.contribution_level = self.initial_contribution_level
        return Action.C if cooperators > len(opponents_actions) // 2 else Action.D

class Strategy_EXPLOITATIVE_577(BaseStrategy):
    """
    Implementation of Tit-for-Tat Exploitative (TFT-E) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1][-1]
        if self.last_opponent_action == Action.C:
            return Action.C
        else:
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            return Action.D

class Strategy_EXPLOITATIVE_579(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history_length = game_description.n_rounds - 1
        self.cooperation_threshold = math.ceil((game_description.k + 1) / (2 * game_description.n_players))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.opponent_actions.size < self.history_length:
            return Action.C
        average_cooperation = np.mean(history.opponent_actions[:, -self.history_length:])
        cooperation_count = int(average_cooperation * (self.game_description.n_players - 1) + 0.5)
        return Action.C if cooperation_count >= self.cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_580(BaseStrategy):
    """
    Tit-for-Tat Strategy for N-Player Public Goods Game
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperated_last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.cooperated_last_round = True
            return Action.C
        self.cooperated_last_round = history.opponent_actions[-1][-1] if len(history.opponent_actions) > 0 else False
        return Action(int(self.cooperated_last_round))

class Strategy_EXPLOITATIVE_581(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) == 0):
            return Action.C
        last_state = self.game_description.n_rounds - 1 if state.round_number == self.game_description.n_rounds else state.round_number - 1
        last_history = PlayerHistory(self.history.my_actions[:last_state + 1], self.history.my_payoffs[:last_state + 1], self.history.opponent_actions[:last_state + 1, :], self.history.opponent_payoffs[:last_state + 1]) if history is not None else PlayerHistory(np.zeros(last_state + 1, dtype=bool), np.zeros(last_state + 1), np.zeros((last_state + 1, self.game_description.n_players), dtype=bool), np.zeros(last_state + 1))
        last_opponent_cooperators = sum(last_history.opponent_actions[-1, :])
        if last_history.my_actions[-1] == Action.C and last_opponent_cooperators > 0:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_582(BaseStrategy):
    """
    Tit-for-Tat with Adaptation strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_cooperation_history.append(sum(history.opponent_actions[-1]))
        if state.round_number == len(self.opponent_cooperation_history):
            return Action.D
        last_round = self.opponent_cooperation_history[-1]
        if last_round >= self.game_description.n_players // 2:
            return Action.C
        elif last_round > 0:
            return Action.D
        else:
            self.opponent_cooperation_history = [0] * len(self.opponent_cooperation_history)
            return Action.D

class Strategy_EXPLOITATIVE_583(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Contribution (TFTAC) strategy for N-Player Public Goods Game.
    The strategy cooperates in the first round, reciprocating cooperation or defection in subsequent rounds,
    and maintains adaptability by considering the possibility of defection in each round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.opponent_defected_last_round = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.opponent_defected_last_round and history is not None and (history.opponent_actions[-1, 0] == 1):
            return Action.C
        elif self.opponent_defected_last_round and history is not None and (history.opponent_actions[-1, 0] == 0):
            return Action.D
        else:
            self.opponent_defected_last_round = history is not None and history.opponent_actions[-1, 0] == 0
            return Action.D

class Strategy_EXPLOITATIVE_584(BaseStrategy):
    """
    Tit-for-Tat with Gradient Adjustment (TFTGA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.x = min(5, self.game_description.n_players // 2)
        self.y = self.x
        self.alpha = 1.1
        self.beta = 0.9

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        opponent_streak = np.sign(cooperators - self.game_description.n_players // 2)
        streak_length = (np.abs(opponent_streak) > 0).sum()
        if streak_length >= self.x and streak_length <= self.game_description.n_players:
            cooperation_prob = min(max(1, cooperators / self.game_description.n_players), self.alpha) ** streak_length
        elif streak_length >= self.y and streak_length <= self.game_description.n_players:
            cooperation_prob = max(0, self.beta ** streak_length)
        else:
            cooperation_prob = random.random()
        cooperation_prob += random.uniform(-0.1, 0.1)
        return Action(cooperation_prob > random.random()) if cooperation_prob >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_586(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive contribution level. This strategy cooperates if the average contribution of all players in the last `t-1` rounds is greater than or equal to a dynamic threshold value ''. The threshold adapts based on opponents' behavior throughout the game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.avg_contribution_history = np.zeros(game_description.n_rounds)
        self.threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_contribution = self.avg_contribution_history[-1]
        if avg_contribution >= self.threshold:
            return Action.C
        return Action.D

    def update_average(self, history: PlayerHistory):
        total_contributions = np.sum(history.my_actions)
        if state.round_number > 1:
            self.avg_contribution_history[state.round_number - 2] = (self.avg_contribution_history[state.round_number - 2] * (self.game_description.n_rounds - 2) + total_contributions) / self.game_description.n_rounds
        else:
            self.avg_contribution_history[0] = total_contributions

    def update_threshold(self, opponent_average_contribution: float):
        """
        Adjust the threshold based on opponent's performance in the game so far.
        """
        if opponent_average_contribution > self.threshold:
            self.threshold += 10
        elif opponent_average_contribution < self.threshold:
            self.threshold -= 10

class Strategy_EXPLOITATIVE_587(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.P = int(game_description.n_rounds * 0.5 + 1)
        self.cooperation_status = True
        self.opponent_history = np.zeros((self.P,))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None:
            history_len = len(history.opponent_actions)
            self.opponent_history = np.roll(self.opponent_history, -1)
            self.opponent_history[-1] = history.opponent_actions[history_len - 1].any()
        action = Action.C
        if not self.cooperation_status and sum(self.opponent_history) >= self.P:
            action = Action.D
            self.cooperation_status = False
        return action

class Strategy_EXPLOITATIVE_588(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TfTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.n_players / 2)
        self.history = PlayerHistory(my_actions=np.zeros(self.game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(self.game_description.n_rounds, dtype=float), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=float))

    def __call__(self, state: GameState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        if cooperators >= self.threshold and random.random() < 0.25:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_589(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            self.last_round_cooperators = sum(history.opponent_actions[-1, :])
        if self.last_round_cooperators > (self.game_description.n_players - 1) // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_590(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for the N-Player Public Goods Game.
    This strategy encourages cooperation and punishes defection, adapting its behavior based on the collective actions of other players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperative = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        if cooperators >= self.game_description.n_players // 2 and (not self.last_cooperative):
            self.last_cooperative = True
            return Action.C
        elif cooperators < self.game_description.n_players // 2 and self.last_cooperative:
            return Action.C
        elif cooperators >= self.game_description.n_players // 2:
            self.last_cooperative = True if state.round_number != self.game_description.n_rounds else False
            return Action.D
        else:
            self.last_cooperative = False
            return Action.D

class Strategy_EXPLOITATIVE_591(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Variable Contribution Strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2
        self.decay_rate = 0.1
        self.round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1, :])
        t = self.game_description.n_players * (1 - self.round / self.game_description.n_rounds) ** self.decay_rate
        if cooperators >= t:
            return Action.C
        return Action.D

    def update(self, state: GameState):
        self.round += 1

class Strategy_EXPLOITATIVE_592(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperative_threshold = 1.0
        self.history_length = game_description.n_rounds // 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[max(0, state.round_number - self.history_length):state.round_number, :].sum(axis=1))
        cooperative_rate = cooperators / self.history_length if self.history_length > 0 else None
        if cooperative_rate is not None:
            if cooperative_rate > 0.5:
                self.cooperative_threshold *= 0.6
            else:
                self.cooperative_threshold *= 0.4
        if sum(history.opponent_actions[state.round_number - 1, :]) >= math.ceil(self.game_description.n_players * self.cooperative_threshold):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_593(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_rate = random.uniform(0, 1)
        self.a = 0.05
        self.b = 0.02

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() <= self.cooperation_rate else Action.D
        cooperators = np.sum(history.opponent_actions[-1])
        self.cooperation_rate += (self.a - self.b) * (2 * cooperators / self.game_description.n_players - 1)
        self.cooperation_rate = max(min(self.cooperation_rate, 1), 0)
        return Action.C if random.random() <= self.cooperation_rate else Action.D

class Strategy_EXPLOITATIVE_595(BaseStrategy):
    """
    A strategy that cooperates when the majority of opponents contribute, with an adaptive contribution threshold based on the average proportion of contributors over a few rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = None
        self.average_cooperation = np.zeros(int(self.game_description.n_rounds * 0.2))
        self.rounds_window = int(self.game_description.n_rounds * 0.2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < 0.5 else Action.D
        if not history:
            self.threshold = np.mean(self.average_cooperation) * self.game_description.n_players // 2
            return Action.C if random.random() < self.threshold else Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        self.adjust_threshold(cooperators)
        return Action.C if cooperators >= self.threshold else Action.D

    def calculate_average_cooperation(self):
        window_start = (self.rounds_window - 1) // 2
        self.average_cooperation[window_start:] = np.mean(self.average_cooperation[window_start + 1:], axis=0)

    def adjust_threshold(self, cooperators: int):
        if cooperators > len(self.average_cooperation):
            self.calculate_average_cooperation()
        self.average_cooperation[-1] = cooperators / self.game_description.n_players
        self.threshold = np.mean(self.average_cooperation) * self.game_description.n_players // 2

class Strategy_EXPLOITATIVE_596(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game.
    This strategy cooperates initially and then imitates other players' actions from the previous round:
    if a majority ( (n/2) players) cooperated in the last round, then cooperate; otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros((1,)), np.zeros((self.game_description.n_players, 1), dtype=bool), np.zeros((1,)))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            return Action.D

    def update_history(self, payoffs: PlayerHistory):
        self.history = payoffs

class Strategy_EXPLOITATIVE_597(BaseStrategy):
    """
    A strategy that mimics cooperation and punishes defection with an adaptive threshold mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.window_size = 10
        self.cooperation_threshold = 0.6
        self.cumulative_cooperation = 0
        self.cooperated_in_window = [0] * self.window_size

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        t = (state.round_number - 1) % self.window_size
        self.cooperated_in_window[t] += 1 if history.my_actions[-1] == Action.C else 0
        average_cooperation = self.cumulative_cooperation / (self.window_size if t >= self.window_size - 1 else t + 1)
        self.cooperation_threshold = self.cooperation_threshold * average_cooperation
        cooperated_in_last_round = history.my_actions[-1] == Action.C
        cooperate = self.cooperated_in_window[t] > int(self.cooperation_threshold * (self.game_description.n_players - 1)) if cooperated_in_last_round else not cooperated_in_last_round
        self.cumulative_cooperation += int(cooperate)
        return Action.C if cooperate else Action.D

class Strategy_EXPLOITATIVE_598(BaseStrategy):
    """
    A Tit-for-Tat-Adaptive (TfT-A) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defect_threshold = int(math.floor(game_description.n_players * 0.5))
        self.cooperators = 1
        self.defectors = 0
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None and state.round_number < self.game_description.n_rounds:
            self._update_cooperators_defectors(history)
            if self.current_round == 1 and self.defectors > self.defect_threshold:
                return Action.D
            elif history.opponent_actions[-1, -1] == Action.C:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _update_cooperators_defectors(self, history):
        self.current_round += 1
        self.cooperators += history.opponent_actions[-1][-1] == Action.C
        self.defectors += history.opponent_actions[-1][-1] == Action.D

class Strategy_EXPLOITATIVE_599(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.ct = self.n // 2
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.C
        if self.history:
            for h in reversed(self.history):
                if state.round_number != h[0] and h[1] == Action.C:
                    self.ct -= (1 - self.ct) / self.r
                else:
                    self.ct += (self.ct - 1) / (self.r * (state.round_number + 1))
        total_contributions = np.sum(history.opponent_actions[-1, :]) if history else self.n
        if total_contributions >= self.ct:
            action = Action.C
        else:
            action = Action.D
        self.history.append((state.round_number, action))
        return action

class Strategy_EXPLOITATIVE_600(BaseStrategy):
    """Tit-for-Tat with Adaptation (TfT-A) strategy for N-Player Public Goods Game"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = int(self.game_description.n_rounds // 10)
        self.punishment_phase = True
        self.recent_history = np.zeros((self.p, 2), dtype=bool)
        self.cooperator_count = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            recent_defections = np.count_nonzero(self.recent_history[:, 0])
            if recent_defections <= self.p // 2:
                self.punishment_phase = False
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators > self.game_description.n_players // 2 and self.punishment_phase:
            self.recent_history[-1, 0] = False
            self.cooperator_count -= 1
        elif cooperators == 0 and (not self.punishment_phase):
            self.recent_history[-1, 0] = True
            self.cooperator_count += 1
        if len(self.recent_history) < self.p:
            self.recent_history = np.roll(self.recent_history, -1)
            self.recent_history[-1] = [history.opponent_actions[-1, :][0], cooperators > 0]
        if self.cooperator_count > self.p // 2:
            self.punishment_phase = True
        else:
            self.punishment_phase = False
        return Action(int(self.punishment_phase)) if len(self.recent_history) == self.p else Action.C

class Strategy_COLLECTIVE_125(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_payoff = [0] * game_description.n_rounds
        self.prev_cooperation = [False] * game_description.n_players
        self.average_payoff = 0.0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        action = Action.D
        self.average_payoff = np.mean(history.my_payoffs[:state.round_number])
        if self.total_payoff[state.round_number - 1] > self.average_payoff:
            action = Action.C
        elif self.total_payoff[state.round_number - 1] < self.average_payoff / self.game_description.n_players:
            action = Action.D
        self.prev_cooperation[(state.round_number - 1) % self.game_description.n_players] = history.my_actions[-1] if action == Action.C else not history.my_actions[-1]
        return action

class Strategy_EXPLOITATIVE_78(BaseStrategy):
    """
    The Tit-for-Tat with Adaptation (TfTA) strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.previous_to_last_opponent_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.previous_to_last_opponent_action = self.last_opponent_action
        self.last_opponent_action = history.opponent_actions[state.round_number - 1, :].mean()
        if self.last_opponent_action == Action.D and self.previous_to_last_opponent_action == Action.C:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_417(BaseStrategy):
    """
    Tit-for-Tat with Gradual Cooperation (TFTG) strategy.
    Initially cooperates for a specified number of rounds, then responds to opponents' actions from the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_cooperation_rounds = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[-1])
        if state.round_number <= self.initial_cooperation_rounds:
            return Action.C
        return Action(int(opponent_action))

class Strategy_EXPLOITATIVE_441(BaseStrategy):
    """
    A Tit-for-Tat with Gradual Adaptation (TFTGA) strategy for N-Player Public Goods Game.
    This strategy cooperates initially, and adapts its cooperation level based on the opponent's past actions.
    The adaptation is gradual to account for various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t = int(math.ceil(self.game_description.n_rounds * 0.8))
        self.h = 0.1
        self.g = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.D
        cooperators = sum(history.opponent_actions[-1])
        total_players = len(history.opponent_actions[0])
        cooperation_probability = self._adaptation_factor(state, history)
        if random.random() < cooperation_probability:
            return Action.C
        return Action.D

    def _adaptation_factor(self, state: GameState, history: PlayerHistory) -> float:
        current_round = state.round_number
        opponent_cooperators_sequence = np.sum(history.opponent_actions[:, :current_round], axis=1)
        opponent_defectors_sequence = len(history.opponent_actions) - opponent_cooperators_sequence
        if current_round < self.t:
            adaptation_factor = 1.0
        else:
            cooperation_streak = np.count_nonzero(np.greater(opponent_cooperators_sequence, self.t - current_round))
            defect_streak = np.count_nonzero(np.greater(opponent_defectors_sequence, self.t - current_round))
            cooperation_factor = 1 - (self.h * min(cooperation_streak, self.t) if cooperation_streak > 0 else 0)
            defect_factor = 1 - (self.g * min(defect_streak, self.t) if defect_streak > 0 else 0)
            adaptation_factor = max(cooperation_factor, defect_factor)
        return adaptation_factor

class Strategy_COLLECTIVE_531(BaseStrategy):
    """
    This implementation of the Tit-for-Tat strategy aims to promote cooperation and reciprocity among players in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = game_description.n_players
        self.previous_opponent = None
        self.cooperation = True

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.previous_opponent = np.zeros(shape=self.game_description.n_players)
        else:
            self.previous_opponent = history.opponent_actions[-1]
        if self.cooperation and np.sum(history.opponent_actions[-1]) == np.count_nonzero(self.previous_opponent):
            self.tolerance -= 1
            if self.tolerance <= 0:
                self.cooperation = False
        elif not self.cooperation and np.sum(history.opponent_actions[-1]) == np.count_nonzero(np.logical_not(self.previous_opponent)):
            self.tolerance = self.game_description.n_players
            self.cooperation = True
        return Action.C if self.cooperation else Action.D

class Strategy_COLLECTIVE_533(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_actions_last_round = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_actions = history.opponent_actions if history else np.zeros((history.opponent_actions.shape[0], self.game_description.n_players), dtype=bool)
        if self.opponent_actions_last_round is None:
            self.opponent_actions_last_round = opponent_actions[-1, :]
        else:
            self.opponent_actions_last_round = opponent_actions[-2, :]
        cooperators = sum(self.opponent_actions_last_round)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_539(BaseStrategy):
    """
    A strategy that follows the Tit-for-Tat Adaptive Cooperation (TFTAC) in the N-Player Public Goods Game.
    This strategy cooperates initially and retaliates when another player defects, encouraging reciprocity among players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and self.last_opponent_action is not None:
            last_opponent_cooperation = len(history.opponent_actions[:, self.__class__].T[self.last_opponent_action]) > 0
            current_opponent_cooperation = len(history.opponent_actions[:, state.round_number - 1]) > 0
            if last_opponent_cooperation and current_opponent_cooperation:
                return Action.C
            elif not last_opponent_cooperation and current_opponent_cooperation:
                self.last_opponent_action = state.round_number - 1
                return Action.D
        self.last_opponent_action = None
        return Action.C

class Strategy_COLLECTIVE_545(BaseStrategy):
    """
    A strategy that encourages reciprocal cooperation in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.n = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number > 0 and history is not None:
            if state.round_number == len(history.opponent_actions):
                return Action.C
            count_c = np.sum(history.my_actions)
            count_d = self.n - count_c
            if count_c > count_d:
                return Action.C
            else:
                return Action.D
        cooperators = np.sum(history.opponent_actions[-1, :])
        if cooperators >= self.n // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_590(BaseStrategy):
    """
    Strategy that encourages cooperation while being robust against various opponent behaviors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.cooperation_threshold = (self.n + 1) / 2
        self.history = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif not self.history or len(self.history) < self.n - 1:
            return Action.C
        last_n_actions = self.get_last_n_actions(history.opponent_actions[-self.n + 1:])
        more_than_half_cooperated = np.sum(last_n_actions) > (self.n - 1) // 2
        if more_than_half_cooperated:
            return Action.C
        return Action.D

    def get_last_n_actions(self, history: NDArray[np.bool_]) -> NDArray[np.bool_]:
        """Return the last n-1 opponent actions."""
        return history[-self.n + 1:]

class Strategy_COLLECTIVE_597(BaseStrategy):
    """
    Tit-for-Tat strategy for N-Player Public Goods Game with a collective twist.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        self.total_contributions = np.sum(history.opponent_actions[:state.round_number].sum(axis=0)) if history else 0
        cooperation_probability = min(self.total_contributions / self.game_description.n_players, 1)
        cooperation = True if random.random() < cooperation_probability else False
        last_action = Action.D if cooperation else Action.C
        return last_action

class Strategy_EXPLOITATIVE_519(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT)
    In each round, the TFTAT strategy decides to cooperate or defect based on its own past actions and the total number of cooperators in the previous round.
    The strategy maintains a Cooperative Threshold (CT) that determines when it switches from cooperation to defection, or vice versa.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.CT = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        own_action = history.my_actions[-1] if history else Action.C
        total_cooperators = np.sum(history.opponent_actions[-1]) if history else 0
        if self.CT < total_cooperators:
            return Action.C
        else:
            return Action.D

    def update_CT(self, total_cooperators):
        if (own_action := self.history.my_actions[-1]):
            new_CT = self.CT + 0.05 * (total_cooperators - self.CT) if own_action else self.CT - 0.05 * self.CT
            self.CT = new_CT if new_CT > 0 else 1

class Strategy_EXPLOITATIVE_521(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation = True
        self.total_cooperation_from_opponents = 0
        self.payoff = 0
        self.round = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        action = self.cooperation and Action.C or Action.D
        if history is not None:
            payoff, total_contributions = self._calculate_payoff(history)
            self.payoff += payoff
            if action == Action.C:
                self.total_cooperation_from_opponents += total_contributions
            if state.round_number > 1 and (action == Action.D and self.cooperation) or (action == Action.C and self.cooperation and (total_contributions < self.game_description.n_players // 2)):
                self.cooperation = not self.cooperation
            self.round += 1
        return action

    def _calculate_payoff(self, history: PlayerHistory) -> tuple[float, int]:
        payoff = 0
        total_contributions = 0
        for round_number in range(history.opponent_actions.shape[0]):
            if self.cooperation == (history.opponent_actions[round_number, :].sum() > 0):
                payoff += 1 - total_contributions / self.game_description.n_players + self.game_description.k / self.game_description.n_players * total_contributions
                total_contributions = history.opponent_actions[round_number, :].sum()
        return (payoff, total_contributions)

class Strategy_EXPLOITATIVE_528(BaseStrategy):
    """
    A Tit-for-Tat-Adaptive (TfTA) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_strategy = None
        self.own_strategy = Action.C

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            return self.own_strategy
        round = state.round_number - 1
        opponent_action = history.opponent_actions[round, :].mean()
        if self.opponent_strategy is None:
            self.opponent_strategy = Action.C if opponent_action == Action.C else Action.D
        if self.own_strategy == Action.C:
            payoff = self.game_description.k / self.game_description.n_players * (len(history.opponent_actions) - round) + 1 - int(opponent_action)
            if opponent_action == Action.C:
                self.own_strategy = Action.C
            else:
                self.own_strategy = Action.D
        elif self.own_strategy == Action.D:
            payoff = 1 + self.game_description.k / self.game_description.n_players * (len(history.opponent_actions) - round)
            if opponent_action == Action.C:
                self.own_strategy = Action.D
            else:
                self.own_strategy = Action.C
        if round == len(history.opponent_actions) - 1 and opponent_action != Action.C:
            self.own_strategy = Action.D
        return self.own_strategy

class Strategy_EXPLOITATIVE_543(BaseStrategy):
    """
    A strategy that starts by cooperating to encourage others, but responds defectively if cooperation is not reciprocated.
    The player adjusts its contributions based on the average total contributions of previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_contributions = 0.0
        self.average_contributions = 0.0
        self.rounds_played = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.rounds_played += 1
        if history is not None:
            total_contributions = sum(history.my_actions)
            self.total_contributions += total_contributions
            if self.rounds_played > 1:
                average_contributions = self.total_contributions / (self.rounds_played - 1)
                if total_contributions >= average_contributions or (average_contributions == 0 and total_contributions > 0):
                    return Action.C
                else:
                    return Action.D
            else:
                self.total_contributions = total_contributions
                self.average_contributions = total_contributions / (self.rounds_played - 1)
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_550(BaseStrategy):
    """
    A strategy inspired by Tit-for-Tat with an adaptive contribution mechanism.
    This strategy cooperates initially and adjusts its contribution based on opponents' cooperation history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_rate_history = [0]
        self.contribution_level = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.contribution_level = self.game_description.k
            return Action.C
        total_cooperators = sum(history.opponent_actions[-1])
        cooperation_rate = total_cooperators / state.round_number if state.round_number > 0 else 0
        self.contribution_level = self.game_description.k if cooperation_rate > 0.5 else 1
        return Action.C if self.contribution_level > 1 else Action.D

class Strategy_EXPLOITATIVE_557(BaseStrategy):
    """
    The Tit-for-Tat with Adjustment (TfTA) strategy in an N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.past_opponent_cooperation_count = 0
        self.total_rounds = self.game_description.n_rounds * self.game_description.n_players
        self.adjustment_threshold = math.floor(self.total_rounds * 0.6)
        self.cooperation_threshold = math.ceil(self.total_rounds * 0.4)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.past_opponent_cooperation_count += sum(history.opponent_actions[-1])
        cooperators = sum(history.opponent_actions[state.round_number - 1, :])
        if self.game_description.n_players == cooperators:
            return Action.C
        if cooperators < self.past_opponent_cooperation_count // self.adjustment_threshold:
            return Action.D
        if self.past_opponent_cooperation_count <= self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_559(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Adaptive Contribution Rate (TFTAC) strategy for N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_rate = random.uniform(0, 1)
        self.adaptation_rate = 0.01
        self.min_cr = 0.3
        self.max_cr = 0.7
        self.past_contributions = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return random.choice([Action.C, Action.D]) if self.contribution_rate > random.random() else Action.C
        action = Action.D
        self.past_contributions.append(1 if history.my_actions[-1] == Action.C else 0)
        if state.round_number < self.game_description.n_rounds - 1:
            action = Action.C if sum(self.past_contributions) > self.game_description.n_players - 1 else Action.D
        elif history is not None and len(self.past_contributions) > 0:
            cooperators = sum([1 for contrib in self.past_contributions if contrib == 1])
            non_contributors = len(self.past_contributions) - cooperators
            action = Action.C if cooperators > non_contributors else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.C if sum([1 for contrib in self.past_contributions if contrib == 1]) > len(self.past_contributions) - sum([contrib for contrib in self.past_contributions if contrib == 0]) else Action.D
        self.update_contribution_rate(self.past_contributions, self.contribution_rate)
        return action

    def update_contribution_rate(self, past_contributions: NDArray[np.bool_], cr):
        cooperation_trend = (sum([1 for contrib in past_contributions if contrib == 1]) + 1) / (len(past_contributions) + 2) - cr
        self.contribution_rate += self.adaptation_rate * cooperation_trend
        self.contribution_rate = max(self.min_cr, min(self.max_cr, self.contribution_rate))

class Strategy_EXPLOITATIVE_594(BaseStrategy):
    """
    Strategy Tit-for-Tat with Adaptive Contribution (TfTAC) for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_cooperation_rounds = 5
        self.history = []
        self.m = math.ceil(self.game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        total_cooperators = sum(history.opponent_actions[-self.m:, -1])
        if total_cooperators >= self.m:
            return Action.C
        return Action.D
