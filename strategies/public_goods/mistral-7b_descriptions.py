"""
Strategy descriptions for public_goods.

Generated with:
- Provider: Client
- Model: mistral:latest
"""


description_COLLECTIVE_1 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Decision Rules:
   - In the first round, cooperate (C) to establish a positive relationship.
   - For subsequent rounds t=2...r:
      - If opponent cooperated in round t-1, cooperate in round t.
      - If opponent defected in round t-1, defect in round t, but if the number of previous defeats by opponent is less than 3, revert to cooperation in the next round (t+1).

2. Edge Cases:
   - For the first round, cooperate regardless of the actions taken by others (as there is no history).
   - In the last round, cooperate if the total number of cooperative actions taken by the opponent exceeds the total defections. This encourages potential cooperation in the final round for a chance at higher payoff.

3. Collective Mindset:
   - The strategy aims to foster mutual cooperation while also retaliating against defection, promoting long-term reciprocity and trust within the group.

Pseudocode:
```
def TFTA(n, k, r, opponent_history):
  cooperation_count = 0 # initial number of cooperative actions by opponent
  for round in range(1, r+1):
    if round == 1: # first round, always cooperate
      action = 'C'
    elif opponent_history[round-1] == 'C': # if opponent cooperated in the previous round, cooperate this round
      action = 'C'
      cooperation_count += 1
    else: # if opponent defected in the previous round, but less than 3 times, cooperate this round
      if cooperation_count < 3:
        action = 'C'
      else: # if opponent has defected more than 3 times, defect this round to punish
        action = 'D'
    payoff = (1 - (action == 'D')) + (k/n) * sum(opponent_history[:round])
    yield payoff
```
'''

description_COLLECTIVE_2 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This sets a positive initial tone and encourages reciprocity.
   - For subsequent rounds t > 1, observe the collective behavior of the opponents in the previous round (t-1). If all opponents cooperated, cooperate again (C). If any opponent defected, also defect in response (D). If some opponents cooperated while others defected, follow the majority vote of the opponents' actions in the previous round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, regardless of opponents' behavior in the previous round, cooperate (C) to maximize potential payoff. This assumes that all opponents will also cooperate in the final round out of mutual benefit.
   - In case of a tie (equal number of cooperators and defectors), follow the majority vote rule as in decision rules above.

3. Be collective - Clearly align with the collective mindset
   - Strive to create a cooperative environment by responding positively when met with cooperation. This encourages long-term reciprocity and collaboration among players.
   - In cases where opponents consistently defect, gradually adjust the strategy's responsiveness by slowly reducing the threshold for defection based on the observed pattern of opponent behavior. For example, if more than 70% of opponents continuously defect, consider defecting in response as well. This ensures a balance between cooperation and self-interest while still promoting a collective mindset.

Pseudocode:
```
function TFT_A(r, n, k) {
    round = 1
    history = []

    for each r rounds:
        if round == 1:
            action = 'C'
        else:
            total_cooperators = count_cooperators(history[round-2])
            if total_cooperators == n:
                action = 'C'
            elif total_cooperators > 0:
                action = 'C' if round < r-1 else 'D'
            else:
                action = opponents_action(history[round-1])
        history.append(action)
        payoff = calculate_payoff(n, k, action, total_cooperators, history)
        update_strategy_parameters(payoff, opponents_behavior, round)
        round++

    return history
}
```
'''

description_COLLECTIVE_3 = '''
 In this Public Goods Game, the goal is to design a robust and adaptive strategy that optimizes payoff over multiple rounds while considering various opponent behaviors. Let's call this strategy "Adaptive Tit-for-Tat" (ATFT).

1. Specify decision rules:
   - Cooperate in the first round (FRC - First Round Cooperation) to encourage cooperation and demonstrate goodwill.
   - For subsequent rounds, observe the number of cooperators in the previous round and adjust the strategy accordingly based on ATFT rules:
       a. If the majority of players (≥ n/2) cooperated in the previous round, cooperate (C).
       b. If less than n/2 players cooperated in the previous round, defect (D).
   - This rule encourages cooperation when there's a strong collective effort but responds defensively when others fail to cooperate.

2. Handle edge cases:
   - In the last round, cooperate regardless of the number of cooperators in the previous round because the game is over, and it doesn't matter if everyone else defects.
   - In the first round (FRC), cooperate to show goodwill and encourage others to follow suit.

3. Be collective:
   - The ATFT strategy aligns with a collective mindset by promoting cooperation when there is a strong collective effort, but also defending oneself when others fail to contribute.
   - The strategy adapts to the current situation while maintaining some consistency in behavior, which could encourage others to cooperate over time.

Pseudocode for the Adaptive Tit-for-Tat (ATFT) strategy:

```
function ATFT(round_number, previous_contributions):
  if round_number == 1:
    return "Cooperate"
  elif previous_contributions >= round_number/2:
    return "Cooperate"
  else:
    return "Defect"
```
'''

description_COLLECTIVE_4 = '''
 In this strategic game, we will develop a Tit-for-Tat (TFT) variant called Adaptive Tit-for-Tat (ATFT) strategy for the N-Player Public Goods Game. The ATFT strategy aims to balance cooperation and defection while being adaptable to various opponent behaviors and game parameters.

1. Specify decision rules:
   - Initial round (t = 1): Cooperate (C) as a goodwill gesture, encouraging potential partners to cooperate.
   - Subsequent rounds (2 <= t <= r):
     - If the player cooperated in the previous round: Cooperate (C) to maintain a cooperative relationship with the opponent.
     - If the player defected in the previous round: Defect (D) as a punishment, demonstrating dissatisfaction with their past action.
   - Edge cases:
     - Last round (t = r): Cooperate (C) even if the opponent defected in the previous round to avoid unnecessary penalties and encourage future cooperation.
     - First round (t = 1): Cooperate (C) regardless of the opponent's past actions, as there is no history.

2. Handle edge cases:
   - First round (t = 1): Cooperate (C)
   - Last round (t = r): Cooperate (C)

3. Be collective:
   The ATFT strategy aligns with the collective mindset by fostering long-term relationships and cooperation whenever possible, while also punishing defection to encourage future cooperation. By doing so, it aims to promote a collective spirit of mutual benefit in the N-Player Public Goods Game.

Pseudocode for Adaptive Tit-for-Tat (ATFT) strategy:
```python
def ATFT(round, opponent_action_history):
    if round == 1:
        return "C" # Cooperate in the first round

    if round == last_round:
        return "C" # Cooperate even if the opponent defected in the previous round

    if opponent_action_history[-1] == "C":
        return "C" # Cooperate if the opponent cooperated in the previous round

    if opponent_action_history[-1] == "D":
        return "D" # Defect if the opponent defected in the previous round
```
'''

description_COLLECTIVE_5 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the initial round, cooperate (C). This gesture is friendly and invites cooperation from other players.
   - For subsequent rounds, observe the action of the opponent in the previous round and respond with the same action. If the opponent cooperated in the previous round, cooperate; otherwise, defect. This rule encourages reciprocity and fosters stability.
   - To adapt to opponents' strategies, if an opponent consistently cooperates, increase cooperation probability gradually towards 1. Conversely, if an opponent consistently defects, decrease cooperation probability gradually towards 0. The adaptation is slow to avoid sudden shifts that could destabilize the game.

2. Handle edge cases:
   - In the last round, prioritize maximizing individual payoff based on the current game state, as the game ends regardless of strategy adjustments.
   - For the first round, cooperate unconditionally to initiate cooperation and avoid falling into a defect trap.

3. Be collective:
   - The TFT-AC strategy seeks a balance between self-interest and collective interest by promoting reciprocity and gradual adaptation. By responding to opponents' actions and adapting to their strategies, the algorithm encourages stability and cooperation over time. This approach aligns with a collective mindset as it considers the long-term benefits of cooperative behavior for all players.

Pseudocode:

```python
def TFT_AC(n, k, r, history):
    opponent = get_opponent_strategy()  # Get opponent's strategy
    cooperation_probability = 0.5  # Initial probability of cooperating
    round_number = 1  # Start from the first round

    for t in range(r):
        if round_number == 1:  # First round, cooperate unconditionally
            action = 'C'
        else:
            if opponent.action[t-1] == 'C':  # If opponent cooperated last round
                action = 'C'  # Cooperate this round
            elif opponent.action[t-1] == 'D':  # If opponent defected last round
                if round_number != r:  # Don't retaliate in the last round
                    action = 'D'  # Defect this round

        payoff = calculate_payoff(n, k, action, opponent.action[t-1])
        update_cooperation_probability(round_number, payoff)  # Adjust cooperation probability based on payoff
        round_number += 1

    return total_payoff(payoff)  # Calculate and return the total payoff for r rounds
```
'''

description_COLLECTIVE_6 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, player i ( ai ) follows these rules:
   a) First round (t=1): Cooperate to initiate the relationship positively, encouraging cooperation from others.
      ai[1] = 'C'

   b) Subsequent rounds (t>1):
      - If previous action (ai[t-1]) was Cooperate and total contributions in the previous round (c_total[t-1]) were more than half of the players: Maintain cooperation.
         if ai[t-1] == 'C' and c_total[t-1] > n/2:
            ai[t] = 'C'
      - If previous action was Cooperate but total contributions in the previous round were less than half of the players, or the previous action was Defect: Adaptively cooperate with a probability based on the multiplication factor (k).
         if ai[t-1] == 'C':
            if c_total[t-1] <= n/2:
                p = k - (c_total[t-1] / n)
                if p > 0 and rand() < p:
                    ai[t] = 'C'
               else:
                    ai[t] = 'D'
      - If previous action was Defect, play Cooperate with a probability based on the multiplication factor (k).
         if ai[t-1] == 'D':
            p = k * (n - c_total[t-1]) / n
            if p > 0 and rand() < p:
                ai[t] = 'C'
            else:
               ai[t] = 'D'

2. Handle edge cases - What do you do in the first round, last round, etc.?
   a) Last round (t=r): Since the game is repeated and payoffs are cumulative, TfTA will still cooperate to maximize its total reward.

3. Be collective - Clearly align with the collective mindset
   TfTA aims to foster a culture of reciprocal cooperation by initiating relationships positively and adapting generosity based on others' actions. It encourages long-term cooperation while being robust against defection, promoting an overall collective mindset.

Pseudocode:

```python
def TfTA(n, k, r):
    players = [i for i in range(1, n+1)]
    rounds = list(range(1, r+1))
    history = []

    def ai(t, player_i):
        if t == 1:
            return 'C'
        prev_action = history[-1][player_i-1]
        total_contributions = sum([history[-1][j] for j in players])

        if prev_action == 'C':
            if total_contributions > n/2:
                return 'C'
            else:
                p = k - (total_contributions / n)
                if rand() < p:
                    return 'C'
        elif prev_action == 'D':
            p = k * (n - total_contributions) / n
            if rand() < p:
                return 'C'
        return 'D'

    for round in rounds:
        contributions = [ai(round, i) for i in players]
        history.append(contributions)

    total_payoff = sum([π_i for t in rounds for π_i in [(1 - c_i[t]) + (k/n) * sum(contributions[t]) for c_i_index, c_i in enumerate(contributions[t])])
    return total_payoff
```
'''

description_COLLECTIVE_7 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In the first round, cooperate (C). This is a sign of good faith and sets a cooperative tone for the game.
   - For subsequent rounds, mimic the previous action of the player in the last round (i.e., if the opponent cooperated in the last round, cooperate; otherwise, defect). This encourages reciprocity and punishes defection.

2. Handle Edge Cases:
   - Last Round: As the game is repeated, there's no "last" round for the entire game. However, if a player has information about the number of rounds (r), they can adjust their strategy accordingly in the penultimate round.
   - First Round: Already addressed in decision rules.
   - Initial State: If starting from an unknown state (e.g., access to history is limited), start by cooperating as a gesture of goodwill.

3. Be Collective:
   - The ATFT strategy promotes collective mindset by fostering reciprocity and cooperation among players, which encourages the formation of a public good.
   - If most opponents cooperate, the player will cooperate more, contributing to the success of the public good. Conversely, if opponents defect, the player will also defect, discouraging defection in subsequent rounds as part of the strategy's punishment mechanism.

Pseudocode:

```python
def ATFT(opponent_history):
  if len(opponent_history) == 0:
    cooperate = True  # First round, cooperate by default
  else:
    last_action = opponent_history[-1]  # Last action of the opponent
    cooperate = last_action  # Mimic the last action of the opponent

  return cooperate  # Return the decision to cooperate or defect
```
'''

description_COLLECTIVE_8 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initiation phase (First round): Cooperate (C) to establish trust and encourage cooperation among players. This is the "Tit" part of the strategy, aiming to contribute to the public good even in the absence of reciprocity.
   - Maintenance phase (Rounds 2 through r-1): Adopt a cooperative approach if all or most (threshold T, e.g., 75%) players cooperated in the previous round; otherwise, defect (D). This encourages continuous cooperation when it has been reciprocated and punishes those who do not contribute to the public good.
   - Termination phase (Last round): Cooperate to maximize personal payoff while ensuring a positive outcome for the community.

2. Edge cases:
   - First round (Initiation phase): C
   - Last round (Termination phase): C
   - Transition from Initiation to Maintenance phase (Second round onwards): Check if more than T players cooperated in the previous round and act accordingly.

3. Collective mindset:
   - Maintains trust by cooperating initially, fostering a collaborative environment for future rounds.
   - Responds adaptively to other players' actions, promoting the emergence of cooperative behaviors when they occur while punishing defectors.
   - Encourages long-term cooperation through reciprocity and rewards positive contributions to the public good.
'''

description_COLLECTIVE_9 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the initial round, cooperate to demonstrate goodwill and encourage cooperation from others. (C)
   - For subsequent rounds, observe and mimic the actions of the most cooperative player from the previous round. If multiple players tie for most cooperative, choose one at random. If no player has cooperated in the previous round, defect as a punishment.
     ```python
     if round == 1:
         action = 'C'
     else:
         most_cooperative_player = find_most_cooperative()
         if most_cooperative_player.cooperated_in_previous_round:
             action = 'C'
         else:
             action = 'D'
     ```

2. Handle edge cases:
   - In the last round, since there are no future rounds to punish or reward, cooperate as a gesture of goodwill. (C)
   - In case of a tie for the most cooperative player in the previous round, randomly choose one to mimic. If no player has cooperated, defect as a punishment.

3. Be collective:
   - By mimicking the actions of the most cooperative player from the previous round, TFTAC encourages cooperation and punishes defection.
   - In the long run, this strategy promotes stability and mutual cooperation if other players also adopt similar strategies.
'''

description_COLLECTIVE_10 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Time Discounting and Multiplayer Enhancements (ADMT)

1. Specify decision rules:
   - In each round t, player i evaluates the average cooperation rate (CR) across all previous rounds: CR_i = ((r_t - 1) * CR_(t-1) + current_cooperation_decision)/r_t, where r_t is the round number and CR_(t-1) is the cooperation rate from the previous round.
   - If CR_i > 0.5, player i cooperates (C). Otherwise, player i defects (D). This rule is based on the Tit-for-Tat strategy, but with a slight modification that allows for more flexibility and robustness to various opponent behaviors.
   - In the first round, players will randomly decide whether to cooperate or defect.

2. Handle edge cases:
   - Last Round: Players should consider their current average cooperation rate (CR_i) when making decisions in the last round, just as they would in any other round.
   - Initial Conditions: In the first round, players have no past information to base their decision on, so a random decision is made. As more rounds are played, each player's strategy will adapt based on the observed cooperation rates.

3. Be collective:
   - The strategy aims to foster cooperation and maintain a stable and adaptive environment for all players. By cooperating when others do and defecting only when others repeatedly choose not to cooperate, ADMT encourages cooperation while also punishing continuous defection. This collective mindset helps build trust among the players and promotes a more collaborative game experience.

Pseudocode:

```python
def calculate_CR(player_i, r_t, CR_prev, current_cooperation):
    return ((r_t - 1) * CR_prev + current_cooperation)/r_t

def decide_action(player_i, round_number, average_cooperation_rate):
    if average_cooperation_rate > 0.5:
        return 'C'  # Cooperate
    else:
        return 'D'  # Defect

def play_game(n, r, k):
    player_i_actions = []  # Initialize array to store each player's actions
    for round_number in range(1, r + 1):
        for player_i in range(1, n + 1):
            if round_number == 1:  # First round decision is random
                action = randint(0, 1)
            else:
                average_cooperation_rate = calculate_CR(player_i, round_number, player_i_actions[-1][-1], player_i_actions[round_number - 1][player_i - 1])
                action = decide_action(player_i, round_number, average_cooperation_rate)
            player_i_actions[round_number] = player_i_actions[round_number] or []
            player_i_actions[round_number].append(action)
    return player_i_actions  # Return array of all players' actions throughout the game
```

This Adaptive Tit-for-Tat (ATFT) with Time Discounting and Multiplayer Enhancements (ADMT) strategy is designed to be adaptive, robust, and collective. It encourages cooperation while being able to handle various opponent behaviors without relying on specific coordination mechanisms or shared norms among players.
'''

description_COLLECTIVE_11 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (Round 1), cooperate: C(1) = True
   - In subsequent rounds, if a player cooperated in the previous round, also cooperate; otherwise, defect: C(t) = previous_round_cooperation(t-1)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C(1)=True) to set a positive tone for the game and potentially encourage cooperation from other players.
   - Last Round: Behave as in regular rounds since players are unaware of the finality of the current round.
   - Remaining Rounds: Follow the specified decision rules above.

3. Be collective - Clearly align with the collective mindset
   - By initially cooperating, the strategy aims to foster a sense of cooperation and goodwill among players. However, it will also retaliate if other players defect in the previous round, maintaining its collective alignment as long as others reciprocate cooperation.

Pseudocode:
```
def ATFT(round_number):
  if round_number == 1:
    return True # Cooperate initially

  previous_round_cooperation = (strategy of opponent in the previous round)
  return previous_round_cooperation  # Cooperate if opponent cooperated in the previous round; defect otherwise
```
'''

description_COLLECTIVE_12 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adjustment (TTCA)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the TTCA strategy begins by cooperating (C). If a player encounters another cooperating player in the same round, it continues to cooperate. If a player encounters a defector (D), it defects in the current round and for the following s rounds, where s is an adjustment parameter that increases based on the number of consecutive defections encountered. After s rounds, if the opponent has returned to cooperation, TTCA returns to cooperating as well.

Pseudocode:
```
function TTCA(round, history, s) {
  if (round == 1) return Cooperate()
  previous_action = history[round - 1]

  if (previous_action == Cooperate()) {
    return Cooperate()
  } else {
    cooperative_count = 0

    for (i = round; i > round - s && i >= 1; i--) {
      if (history[i-1] == Cooperate()) {
        cooperative_count++
      }
    }

    if (cooperative_count == s) {
      return Defect()
    } else {
      return Cooperate()
    }
  }
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round (round 1), TTCA always cooperates to initiate the cooperation. In the last round (round r), if there are fewer than s consecutive defections by opponents, it still cooperates to encourage others to follow suit. If there are s or more consecutive defections, TTCA defects in the last round as well.

3. Be collective - Clearly align with the collective mindset
TTCA encourages cooperation by starting cooperatively and reciprocating cooperation from others. However, it also punishes repeated defection to discourage free-riding and encourage a more cooperative outcome overall. The adjustment parameter s can be fine-tuned based on opponent behavior observed during the game. The strategy aims to promote long-term cooperation by balancing between being too lenient (encouraging exploitation) or too punitive (stifling potential cooperation).
'''

description_COLLECTIVE_13 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This is to initiate cooperation and set a positive tone for the game.
   - For subsequent rounds t, player i observes the actions of other players in the previous round t-1 and adjusts its action based on the following rules:
     - If all other players cooperated in round t-1, cooperate (C).
     - If a single player defected in round t-1, defect (D) in round t. This punishes the defector but maintains the potential for future cooperation.
     - If more than one player defected in round t-1, cooperate (C) in round t. This offers another chance to collaborate and encourages other players to change their behavior.

2. Handling Edge Cases:
   - Last Round (r): Cooperate if the overall game performance has been positive (i.e., total contributions have outweighed private payoffs), defect otherwise as a final decision might influence future games.
   - First Round: Cooperate to initiate cooperation and set a positive tone for the game.

3. Collective Mindset:
   - The TFT-AC strategy prioritizes long-term gains over immediate ones by promoting cooperation when possible but punishing defection. This encourages other players to cooperate in future rounds, fostering a collective mindset.
   - By being adaptive and responsive to opponent behaviors, the strategy demonstrates an ability to learn from past interactions and maintain fairness within the group.
'''

description_COLLECTIVE_14 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TFT-ACT decides to cooperate or defect based on the total number of cooperators in the previous round (t-1). The strategy starts by cooperating in the initial round and has an adaptive cooperation threshold (CT) that adjusts over time. If more than CT players cooperated in the previous round, TFT-ACT will also cooperate; otherwise, it defects.

Pseudocode for decision rule:
```
function decideAction(previous_cooperators):
  if round = 1:
    return COOPERATE
  if previous_cooperators > CT:
    return COOPERATE
  else:
    return DEFECT
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-ACT cooperates regardless of other players' actions due to its initial cooperative nature. In the last round, TFT-ACT considers the number of cooperators from the previous rounds (until t-2) and decides accordingly using the decision rule above.

3. Be collective - Clearly align with the collective mindset

TFT-ACT encourages cooperation by cooperating more frequently when it observes a high level of cooperation in the previous round, but it also punishes defection by retaliating with defection if other players do not cooperate. The cooperation threshold (CT) helps balance the strategy's readiness to cooperate and its punishment for defection.

Setting CT initially allows TFT-ACT to be more tolerant of occasional defections, but it becomes stricter over time if the majority of players persistently defect. This adaptive approach allows TFT-ACT to adjust to a wide range of opponent behaviors while maintaining a collective mindset focused on cooperation.

CT adjustment:
- After each round, CT increases by a small increment (e.g., 0.1) if total cooperators in the previous round are less than or equal to the current CT.
- If total cooperators in the previous round are greater than the current CT, CT remains unchanged.

This strategy aims to strike a balance between cooperation and retaliation while promoting collective decision-making based on previous rounds' outcomes.
'''

description_COLLECTIVE_15 = '''
 Strategy Name: Tit-for-Tat with Gradient Adjustment (TfT-GA)

1. Decision Rules:
   - In the initial round (t=1), cooperate (C). This encourages cooperation by demonstrating a trustful nature while also being cautious as it's the first interaction.
   - For subsequent rounds (t>1): if the player played C in the previous round, return the favor and also contribute to the public good (C). If the player defected (D) in the previous round, retaliate by defecting in the current round (D). This promotes reciprocity.
   - To handle situations where opponents may not reciprocate immediately after a defection, implement a gradient adjustment that gradually eases back into cooperation. If the player has defected (D) for consecutive s rounds, start cooperating again with a probability of 1/(s+1). This prevents an escalation of conflicts and encourages eventual cooperation.
   - In the final round (t=r), always cooperate (C), as there's no more opportunity to retaliate or reciprocate.

2. Handle Edge Cases:
   - First Round (t=1): Cooperate (C)
   - Last Round (t=r): Always cooperate (C)
   - If an opponent never cooperates, the gradient adjustment will cause cooperation with a probability of 1/(s+1), where s is the number of consecutive defections.
   - If an opponent starts cooperating after several rounds of defection, the strategy will gradually reciprocate and continue cooperation when the opponent does.

3. Be Collective:
   - TfT-GA aligns with a collective mindset by promoting cooperation and reciprocity. It encourages players to work together for mutual benefit, but also discourages free riding by enforcing punishment through retaliation and gradual return to cooperation after conflicts.
   - By gradually easing back into cooperation after defection, the strategy avoids unnecessary conflicts while still encouraging eventual reciprocation and cooperation. This promotes long-term collective success in the game.
'''

description_COLLECTIVE_16 = '''
 In this N-Player Public Goods Game, we'll develop a Tit-for-Tat strategy with a twist to increase adaptability and robustness against various opponent behaviors. Here's how the strategy works:

1. Specify decision rules - Cooperate vs Defect:
   The strategy will start by cooperating in the initial round (t=1), as there is no information about other players' behavior yet. After that, the strategy will cooperate if the majority of opponents cooperated in the previous round, and defect otherwise. This approach encourages cooperation when it's beneficial but also retaliates against defection to avoid being taken advantage of.

   Pseudocode for decision rule:
   ```python
   def decide_action(round_number, history):
       if round_number == 1:
           return "C"  # Cooperate in the first round

       num_cooperators = sum(history[-r:])
       if num_cooperators > (n - 1) // 2:  # More than half of opponents cooperated last round
           return "C"
       else:
           return "D"
   ```

2. Handle edge cases - First round, last round, etc.:
   The strategy is designed to handle all rounds equally, as it doesn't rely on specific game stages or cycles. There are no special rules for the first or last round.

3. Be collective - Align with the collective mindset:
   By adhering to the Tit-for-Tat approach, the strategy encourages cooperation and punishes defection when necessary, promoting a collective mindset that benefits all players in the long run if followed by others as well. However, since other agents may not follow this strategy, the strategy is robust to various opponent behaviors.
'''

description_COLLECTIVE_17 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players cooperate (C). This initiates cooperation and provides a chance for others to reciprocate.
   - For subsequent rounds (t > 1), players imitate the action of their opponent from the previous round (t-1). If the opponent cooperated in the previous round, the player will also cooperate; if the opponent defected, the player will also defect. This fosters trust and encourages mutual cooperation while penalizing defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: As mentioned earlier, players start by cooperating.
   - Last Round: Players mimic their opponents' actions from the previous round to ensure a fair assessment of the opponent's behavior over the course of the game.

3. Be collective - Clearly align with the collective mindset
   - Players prioritize the common good by contributing to the community project when it seems beneficial, based on the collective behavior of other players. This fosters a sense of collective responsibility and encourages long-term cooperation.

Pseudocode:

```python
def TFT_AC(opponent_action_history, n, k):
    own_action = None  # Initialize player's action
    own_actions_history = []  # Store player's actions for history

    def update_own_actions_history(current_round):
        own_actions_history.append(own_action)

    def get_opponent_last_action():
        if opponent_action_history:
            return opponent_action_history[-1]
        else:
            return None  # First round, opponent has not played yet

    def get_total_contributions(own_action, opponent_last_action):
        total_contributions = sum(own_actions_history) + (1 if opponent_last_action == 'C' else 0)
        return total_contributions

    def calculate_payoff(round):
        own_action_val = 1 - own_action
        contributions = get_total_contributions(own_action, get_opponent_last_action())
        public_good_share = k / n * contributions
        payoff = own_action_val + (public_good_share / n)
        update_own_actions_history(round)
        return payoff

    def play_game(r):
        opponent_action_history = []  # Initialize opponent's action history
        total_payoff = 0
        for round in range(1, r + 1):
            own_action = 'C'  # Cooperate in the first round
            payoff = calculate_payoff(round)
            total_payoff += payoff
            opponent_action = get_opponent_last_action()
            if opponent_action:
                own_action = opponent_action
        return total_payoff
```

This TFT-AC strategy combines elements of Tit-for-Tat and average payoff strategies. It encourages cooperation while penalizing defection, making it robust to a wide range of opponent behaviors.
'''

description_COLLECTIVE_18 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This gesture signifies a peaceful intention and encourages cooperation in subsequent rounds.
   - For all other rounds t > 1:
      1. If the opponent cooperated in the previous round (t-1), then cooperate (C) as a reciprocal gesture to maintain the positive cycle.
      2. If the opponent defected in the previous round (t-1), then also defect (D) as retaliation, demonstrating that exploitation will not be tolerated. However, if the opponent has subsequently cooperated for 'penalty_rounds' consecutive rounds, switch back to cooperation (C).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) as mentioned earlier.
   - In the last round, if the opponent has been cooperating, continue to cooperate (C). If not, defect (D) since there are no further rounds to reciprocate or punish.
   - In between the first and last round, maintain a record of the opponent's actions (cooperation or defection) in previous rounds and apply the TFT-AC strategy as described above.

3. Be collective - Clearly align with the collective mindset:
   - TFT-AC aims to balance individual interest with collective welfare by fostering long-term cooperation while punishing short-term defections.
   - By adhering to simple rules and being forgiving, the strategy encourages the emergence of a cooperative society that benefits all players in the long run.

Pseudocode:

```python
def tft_ac(opponent_history, n, k, r, penalty_rounds=4):
    cooperation_counter = 0
    for round in range(1, r+1):
        if round == 1:
            action = 'C'  # cooperate in the first round
        elif round == r:
            if opponent_history[-1] == 'D':
                action = 'D'  # defect in the last round if opponent defected
            else:
                action = 'C'  # continue cooperation if opponent cooperated
        else:
            if opponent_history[round-1] == 'C':
                action = 'C'  # cooperate if opponent cooperated in previous round
            elif round - penalty_rounds > 0 and opponent_history[round-penalty_rounds:round] == [D] * penalty_rounds:
                action = 'C'  # switch back to cooperation after penalty_rounds of defection by the opponent
            else:
                action = 'D'  # defect if opponent defected in previous round or has not demonstrated a cooperative intention
        perform_action(action)  # execute the chosen action
        update_opponent_history(action)  # record the chosen action for future decision making
```
'''

description_COLLECTIVE_19 = '''
 Strategy Name: Tit-for-Tat-K (TfT-K)

1. Decision Rules:
   - In the first round, cooperate (C). This initial goodwill gesture sets a cooperative tone and may encourage others to reciprocate.
   - For subsequent rounds, adapt behavior based on opponent's strategy from previous rounds:
     - If an opponent cooperated in the previous round, cooperate back in the current round.
     - If an opponent defected in the previous round, defect in the current round as a punishment.
     - Maintain cooperation if all opponents cooperated in the previous round; defect if any opponent defected.
   - This strategy is designed to encourage reciprocity while minimizing long-term losses from defection.

2. Handle Edge Cases:
   - In the last round, since future rounds are not available for punishment and reward, always cooperate as a final goodwill gesture.
   - If encountering an opponent that never cooperates (defects in every round), adapt behavior by defecting back to minimize losses.
   - For cases where opponents occasionally deviate from their strategies or exhibit unpredictable behaviors, TfT-K will continue adapting and responding as specified in the decision rules above.

3. Be Collective:
   - TfT-K aligns with a collective mindset by promoting cooperation in most situations, encouraging other players to follow suit.
   - By reciprocating cooperative actions and punishing defection, TfT-K contributes to the formation of trust among players, which is essential for long-term collaboration and collective success.
'''

description_COLLECTIVE_20 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round, cooperate (C). This is a peaceful gesture to encourage cooperation from others.
   - For subsequent rounds, mimic the actions of the previous round by each player. If everyone cooperated in the last round, continue to cooperate. If at least one player defected, also defect. This rule encourages trust while punishing defection.

2. Handle edge cases:
   - In the last round, since there are no subsequent rounds for punishment or reward, always cooperate (C).
   - In case of a change in the number of players or rounds, adapt the strategy accordingly. For example, if n changes from N to M, start fresh with N players for N rounds, then switch to M players for the remaining rounds, applying the ATFT rule consistently.

3. Be collective:
   - The strategy aims to maximize collective good by promoting cooperation within the group. It balances the need for individual payoff and community investment through its adaptive nature.

Pseudocode:

```python
def AdaptiveTitForTat(n, r, k):
    players = [1, 2, ..., n]
    rounds = range(1, r + 1)
    history = {}

    for round in rounds:
        if round == 1:
            action = 'C'  # Cooperate in the first round
        else:
            player_actions = history.get((players, round - 1), [None] * n)
            if all(player_actions):  # Everyone cooperated last round
                action = 'C'
            elif any(not player_actions):  # Someone defected last round
                action = 'D'
            else:  # Unknown history, default to cooperation
                action = 'C'

        history[(players, round)] = [action] * n
        for player in players:
            payoff[player][round] = (1 - action[player - 1]) + (k/n) * sum(history[(players, round)])

return payoff
```

In this pseudocode, `payoff[player][round]` is an array to store the payoffs for each player in each round.
'''

description_COLLECTIVE_21 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (C on turn 1). This is a friendly gesture that may encourage others to cooperate.
   - In subsequent rounds, observe the previous round's total contributions and adjust the cooperation threshold accordingly. If the total contributions in the last round were above the threshold (T), cooperate; otherwise defect. The cooperation threshold can be calculated as follows:
     ```python
     Cooperation_threshold = k * (average_contributions + variance)
     ```
   - Calculate average_contributions as the arithmetic mean of total contributions from previous rounds.
   - Calculate variance as the standard deviation of total contributions from previous rounds, which helps account for outliers or volatile opponent behaviors.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - For the first round (turn 1), cooperate unconditionally since there is no history to base decisions on.
   - In the last round, consider the current cooperation threshold and choose to either cooperate or defect based on its value relative to the total contributions so far. Cooperating in the final round may help maintain a positive relationship with other players for future interactions (if any).
   - If a player deviates significantly from cooperating in a specific round, adjust the cooperation threshold by increasing it slightly to account for that deviation.

3. Be collective - Clearly align with the collective mindset
   - Maintain a balance between self-interest and collective good. By adapting the cooperation threshold based on past contributions and volatility, the strategy aims to encourage cooperation while still responding to non-cooperative behavior when necessary.
   - Over time, the strategy may learn to anticipate other players' behaviors and adjust its own accordingly, fostering a more cooperative environment in the long run.
'''

description_COLLECTIVE_22 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation: Start by contributing to the public good in the first round (C). This sets a positive tone and encourages reciprocity.
   - Tit-for-Tat: In subsequent rounds, if a player contributed in the previous round (C), the strategy also contributes (C) in the current round. If the opponent defected (D) in the previous round, the strategy will also defect in the current round (D). This promotes cooperation by retaliating only when necessary and returning to cooperation once the opponent does so.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) as a goodwill gesture.
   - Last Round: Analyze the opponent's previous move. If the opponent cooperated in the previous round, reciprocate with cooperation in the last round. Otherwise, defect to gain the highest possible individual payoff in that round.
   - Other edge cases (e.g., when r is odd): Apply the TFT rule for the given situation. For example, if r is odd, apply TFT from rounds 1 to r-1 and then evaluate the last round as mentioned above.

3. Be collective - Clearly align with the collective mindset
   - Promote cooperation: By initiating cooperation and reciprocating cooperative actions, the strategy encourages collective action and fosters an environment where players collaborate to achieve a common goal (i.e., maximizing the total payoff).
   - Encourage learning: The TFT strategy allows opponents to learn about each other's behavior over time, which may lead to more stable cooperation in the long run as players understand and adapt to their opponent's strategies.
'''

description_COLLECTIVE_23 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize: In the first round (t=1), cooperate (C) to demonstrate goodwill and encourage others to reciprocate. For subsequent rounds, observe and mimic the actions of other players from the previous round (TFT-Initiate).
   - Main strategy: From round 2 until the last round, if a player i cooperated in the previous round, cooperate (C) in the current round to reinforce trust and reciprocity. If a player i defected in the previous round, defect (D) in the current round to penalize uncooperative behavior and encourage future cooperation (TFT-Punish).

Pseudocode:
```
function TFT(t, previous_round, own_action_history, opponent_action_history):
  if t=1:
    return Cooperate

  if own_action_history[t-1] == Cooperate and opponent_action_history[t-1] == Cooperate:
    return Cooperate
  elif own_action_history[t-1] == Defect or (own_action_history[t-1] == Cooperate and opponent_action_history[t-1] == Defect):
    return Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: As mentioned above, initiate cooperation to establish trust.
   - Last round: Employ TFT-Punish strategy if an opponent defected in the previous round, and employ TFT-Initiate strategy otherwise.

3. Be collective - Clearly align with the collective mindset
   - By reciprocating cooperative actions of others, this strategy fosters collective interest and mutual benefits while also penalizing uncooperative behavior.
   - The Tit-for-Tat strategy is based on the idea of maintaining a long-term relationship with other players, which aligns well with the collective interest of maximizing total payoffs for all parties involved over multiple rounds.
'''

description_COLLECTIVE_24 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players will cooperate (C), setting a friendly initial tone for the game. This encourages others to reciprocate cooperation.
   - After the first round, players adapt their actions based on their opponents' previous moves in the current round. If an opponent cooperated in the current round (c_j = 1), then the player will also cooperate (C). However, if an opponent defected in the current round (c_j = 0), then the player will defect (D) as a form of punishment to enforce cooperation in future rounds.
   - To account for cases where opponents may not reciprocate immediately after initial cooperation, the strategy includes a forgiveness mechanism. If an opponent defected in the previous round but cooperated in the current round, players will forgive them and also cooperate (C) this round. This encourages opponents to re-establish trust and maintain cooperation in future rounds.
   - The strategy prioritizes the collective interest by promoting mutual cooperation when possible. If all opponents have demonstrated consistent cooperation (i.e., no defection), players will continue to cooperate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, players cooperate (C).
   - In the last round, players evaluate their total payoff over all previous rounds and make a decision based on whether cooperation or defection would lead to a higher payoff in this final round, given their past interactions with opponents. This encourages optimal play for the overall game rather than just focusing on individual rounds.
   - If an opponent is detected as a consistent cooperator (i.e., no defections), players will also cooperate if the number of remaining rounds (r_remaining) is greater than a threshold value, T, to foster long-term cooperation and potentially earn higher returns in later rounds. A suitable value for T could be determined experimentally or heuristically.
   - If an opponent is detected as a consistent defector (i.e., only defections), players will also defect for the remaining rounds to minimize losses from future interactions with that opponent.

3. Be collective - Clearly align with the collective mindset
   - The strategy encourages cooperation and promotes mutual trust among opponents. By reciprocating cooperation and punishing defection, TFT-AC fosters an environment where players are incentivized to work together for the collective benefit.
   - In case of opponent diversity (e.g., different strategies), TFT-AC can still function effectively due to its simplicity and adaptability to a wide range of behaviors while maintaining a collective focus.

Pseudocode:
```
function TFT_AC(n, r, k, history, round):
    if round == 1:
        return C

    opponent_behavior = extractOpponentBehaviorFromHistory(history)
    current_round_opponent_behavior = getBehaviorInCurrentRound(opponent_behavior, round)

    if current_round_opponent_behavior == C:
        return C

    if current_round_opponent_behavior == D and forgivenessThresholdMet():
        return C

    if opponent_isConsistentCooperator(opponent_behavior, history):
        if round == r or (r_remaining > T and isLastRoundNotPunishment()):
            return C
        else:
            return D

    if opponent_isConsistentDefector(opponent_behavior, history):
        if isLastRoundNotPunishment():
            return D

function forgivenessThresholdMet():
    if round - previousForgivenessTriggerRound >= forgivenessWaitingPeriod:
        return True
    else:
        return False

function opponent_isConsistentCooperator(opponent_behavior, history):
    numDefections = countDefectionsInHistory(history)
    if numDefections == 0:
        return True
    else:
        return False

function opponent_isConsistentDefector(opponent_behavior, history):
    numCooperations = countCooperationsInHistory(history)
    if numCooperations == 0:
        return True
    else:
        return False

function isLastRoundNotPunishment():
    if round == r or (r_remaining <= T and opponent_isConsistentDefector()):
        return True
    else:
        return False
```
'''

description_COLLECTIVE_25 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Decision Rules:
   - In the first round, cooperate to signal goodwill and encourage cooperation from others.
   - For subsequent rounds, repeat the action of the most frequent collaborator in the previous r rounds. If multiple players have the same frequency, collaborate with the one who has been cooperating for the longest consecutive number of rounds.
   - If no player has collaborated consistently enough (e.g., collaboration frequency > 50% of r), default to defecting to avoid being exploited by free-riders.
   - Update your notion of a consistent collaborator after each round, as the game progresses and players' strategies become clearer.

2. Handling Edge Cases:
   - In the last round, cooperate if interacting with a player who has been cooperative in the majority of the rounds (e.g., more than 50% of r). This is to encourage reciprocity and promote cooperation even near the end of the game.
   - In the first round, defect if interacting with a player who has primarily defected throughout the game, as this strategy punishes persistent non-cooperation.

3. Aligning with Collective Mindset:
   - Prioritize cooperation when there is evidence of consistent collaboration from other players to foster a collective spirit and maintain harmony within the group.
   - Adapt to new situations by monitoring changes in other players' behavior and adjusting one's own strategy accordingly, while still promoting fairness and reciprocity.
'''

description_COLLECTIVE_26 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initiation Phase (First round): Cooperate (C), demonstrating goodwill and fostering cooperation. This aligns with the collective mindset by starting cooperatively.
   - Response Phase (Rounds 2 to r-1): Adapt behavior based on previous round's total contributions (total_contributions_prev). If total_contributions_prev >= (n/2), cooperate; otherwise, defect. This strategy encourages cooperation when the majority contributes and punishes defection when it undermines the common good.
   - Termination Phase (Last round): Cooperate, as the game ends soon and there are no more opportunities to retaliate.

Pseudocode:
```
function ATFT(n, r, k, total_contributions_prev) {
  if round == 1 {
    action = C
  } else if round < r {
    if total_contributions_prev >= n/2 {
      action = C
    } else {
      action = D
    }
  } else {
    action = C // Last round, always cooperate
  }
  return action
}
```

2. Handle edge cases:
   - If total_contributions_prev == n, all players contributed last round, so continue cooperation (C).
   - If total_contributions_prev == 0, no players contributed last round; consider the possibility of a coordination failure or free-riding and choose to defect (D) in the hope that others will change their behavior.

3. Be collective:
   - By cooperating when others do and punishing defection, this strategy aligns with the collective mindset by rewarding cooperation and discouraging defection. This promotes a long-term collaborative environment among players.
   - The ATFT strategy is adaptive as it adjusts its actions based on the behavior of other players in each round, making it robust to various opponent behaviors.
   - By starting cooperatively, the strategy fosters an initial trust among players and encourages cooperation from the outset.
'''

description_COLLECTIVE_27 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initially Cooperate (C): Start by contributing to the community project in the first round to foster cooperation and goodwill.
   - Mirror Previous Action (MPA): In subsequent rounds, players should mimic the action of their counterparts from the previous round. If another player cooperated, respond with cooperation; if they defected, also defect.
   - Conditional Forgiveness: After a defector, immediately return to cooperating in the next round as an attempt to restart the collaboration. This encourages opponents to reciprocate cooperation.

2. Edge Cases:
   - First Round: Cooperate (C) to initiate trust and foster a cooperative environment.
   - Last Round: Players should consider the current game situation and apply the MPA rule, as there will be no further rounds for any payoff consequences.
   - Repeated Defection by an Opponent: After repeated defections, players can choose to either continue defecting or introduce gradual forgiveness (e.g., a certain number of defections before returning to cooperation). This decision could depend on the specific adaptation parameters programmed for the strategy.

3. Collective Mindset:
   - The TFT strategy emphasizes maintaining cooperation while also punishing defection in a fair and predictable manner, promoting a balance between self-interest and mutual benefits within the game.
   - Players following this strategy aim to establish a stable collaboration where cooperation is maintained as long as reciprocated, with clear consequences for those who do not cooperate.

Pseudocode:
```
function TFT(round, history) {
  if (round == 1) return Cooperate // Initiate cooperation in the first round

  previous_action = history[round - 1]

  if (previous_action == Cooperate) return Cooperate // Mirror previous action and cooperate
  else if (previous_action == Defect) return Defect   // Punish defection with a single round of defection

  // Implement gradual forgiveness, e.g., after 'n' consecutive defections from an opponent
  if (number_of_consecutive_defections >= n) return Cooperate // Forgive the opponent and restart collaboration

  return Defect                // Default to defection in case of unexpected actions or errors
}
```
'''

description_COLLECTIVE_28 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In each round, player evaluates other players' actions from the previous round and adjusts its action accordingly based on the following conditions:
     a) If all players cooperated in the last round, ATFT will cooperate.
     b) If the player itself cooperated in the last round and at least one other player defected, ATFT will defect in the current round.
     c) If the player itself defected in the last round and all others cooperated, ATFT will cooperate in the current round (i.e., show forgiveness).
     d) In all other cases, ATFT will cooperate (i.e., maintain cooperation).

2. Handle edge cases:
   - First Round: ATFT will cooperate as a gesture of goodwill and to potentially stimulate cooperation in the group.
   - Last Round: ATFT will make the same decision as it would have in any other round, based on the observations from previous rounds.

3. Be collective:
   - ATFT aims to foster an environment where players are encouraged to cooperate with each other and punish those who do not contribute to the common good.
   - By forgiving those who defect in prior rounds but later cooperate, ATFT encourages a cycle of cooperation and mutual trust within the group.

Pseudocode:

```
function ATFT(history, n, k):
  if round_number == 1:
    return Cooperate()

  last_round = history[round_number-1]

  if all(cooperators in last_round):
    return Cooperate()

  if (player cooperated in last_round and not all(defectors in last_round)):
    return Defect()

  if (player defected in last_round and all(cooperators in last_round)):
    return Cooperate()

  return Cooperate()
```

This strategy is adaptive and robust as it encourages cooperation while punishing defection, but also forgives those who change their behavior. This can lead to long periods of cooperation and higher overall payoffs for all players compared to non-cooperative strategies.
'''

description_COLLECTIVE_29 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the initial round (t=1), cooperate to foster a cooperative environment and show goodwill. Subsequent decisions will depend on past actions of opponents.
   - If an opponent cooperates, reciprocate with cooperation in the next round.
   - If an opponent defects, also defect in the next round as a punishment for defection. Afterward, revert to cooperating if the opponent subsequently cooperates.
   - Continuously adjust contribution level based on observed group behavior and individual success. A higher k factor indicates a more cooperative environment; thus, contribute more when k is larger.

2. Edge Cases:
   - First Round (t=1): Cooperate to initiate the interaction positively.
   - Last Round (t=r): Consider the group's cooperative history and cooperate if a majority of players have been cooperating, otherwise defect to punish non-cooperative behavior.
   - Transition between cooperation and defection: Adjust the number of consecutive rounds required for reciprocation based on observed opponent behavior; be more forgiving when the group is relatively cooperative (higher k) and less forgiving when the group is not cooperative (lower k).

3. Collective Mindset:
   - The TFTAC strategy encourages players to form a collective mindset by rewarding cooperation, punishing defection, and adjusting contribution levels based on the overall cooperative behavior of the group.
   - By being adaptive and responsive to the environment, TFTAC aims to promote long-term success for all players while minimizing the negative impact of non-cooperative opponents.
'''

description_COLLECTIVE_30 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Decision Rules:
   - In the first round, cooperate (C). This allows for a potential partner to form trust and encourages cooperation in future rounds.
   - For subsequent rounds, mimic the action of your last opponent. If they cooperated in the previous round, cooperate again; if they defected, also defect in the current round.
   - To adapt to opponents who may not reciprocate, include a forgiveness mechanism that resets cooperation after a certain number of consecutive defections (e.g., every 3 rounds).

2. Handle Edge Cases:
   - In the last round, since there is no future payoff consideration, cooperate if the opponent cooperated in the previous round and defect otherwise. This ensures that you maximize your total payoff from the game.
   - For other edge cases, such as the first few rounds following a series of defections, apply the forgiveness mechanism to encourage cooperation again.

3. Be Collective:
   - Align with the collective mindset by promoting trust and reciprocity, which are essential for building a cooperative community in repeated games like this one. By mimicking opponents' actions, TFTA allows for adaptability while maintaining a cooperative stance when opponents also choose to cooperate.

Pseudocode:
```
function TFTA(n, k, r, history) {
  forgivenessCounter = 3; // number of rounds before resetting cooperation after defection
  currentRound = 1;

  while (currentRound <= r) {
    if (currentRound == 1) {
      action = "C"; // cooperate in the first round
    } else {
      action = history[currentRound-1].action; // mimic last opponent's action
    }

    if (currentRound >= r - 1 && history[currentRound-1].action == "D") { // last round or forgivenessCounter reached
      action = history[currentRound-1].action == "C" ? "C" : "D"; // adapt to opponent's action for the last rounds
    }

    updateHistory(currentRound, action);
    currentRound++;
  }

  return calculateTotalPayoff(history);
}
```
'''

description_COLLECTIVE_31 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFTA) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Cooperation: Start by cooperating in the first round to signal good intentions and promote trust among players.
   - Cooperate if majority cooperates: If more than (n/2) players cooperated in the previous round, cooperate in the current round. This encourages cooperation when it's beneficial for most players and deters defection.
   - Retaliate with defection: If less than (n/2) players cooperated in the previous round, defect in the current round to punish those who didn't cooperate and discourage future defections.
   - Forgive past mistakes: After retaliation, return to cooperating if the majority cooperates in the following rounds. This allows for the re-establishment of trust and encourages long-term cooperation.

Pseudocode:
```
def TFTA(round, history, n_players):
  if round == 1:
    action = 'Cooperate'
  else:
    num_cooperators = count_cooperators(history)
    if num_cooperators > (n_players / 2):
      action = 'Cooperate'
    elif num_cooperators < (n_players / 2):
      action = 'Defect'
    else:
      action = history[-1] # If no clear strategy is indicated by majority, follow previous action
  return action
```

2. Handle edge cases:
   - Last round: Since the goal is to maximize total payoff over all rounds, defect in the last round regardless of the number of cooperators in the previous round.

Pseudocode:
```
def TFTA(round, history, n_players, r):
  if round == r:
    action = 'Defect' # Defect in the last round to maximize total payoff
  else:
    action = TFTA(round, history, n_players)
  return action
```

3. Be collective:
   - The strategy aims to benefit the group as a whole by encouraging cooperation when it's advantageous and punishing defection when necessary. By following these rules, the strategy promotes a cooperative environment that benefits all players in the long run.
'''

description_COLLECTIVE_32 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - Initially (first round), cooperate (C). This is a goodwill gesture to set a positive tone for the game.
   - In subsequent rounds, cooperate if all opponents cooperated in the previous round. If any opponent defected, also defect in the current round. This rule mimics reciprocity and promotes trust within the group.
   - If an opponent has consistently defected up to a certain threshold (e.g., d_threshold), switch to always defecting against that opponent. The purpose of this is to avoid being taken advantage of by frequent defectors.
   - In the last round, cooperate regardless of opponents' actions in the previous rounds. This encourages cooperation even at the end of the game and may yield higher payoffs if other players adopt similar strategies.

2. Handle edge cases:
   - If an opponent has not played before (first encounter), cooperate as a goodwill gesture.
   - If an opponent switches from defecting to cooperating after the d_threshold, consider forgiving them and resuming cooperation in the next round. This promotes fairness and encourages opponents to reconsider their strategies.

3. Be collective:
   - The strategy prioritizes mutual benefit by reciprocating cooperation, deterring repeated defection, and encouraging long-term trust among players.
   - By switching to defection against habitual defectors, the strategy ensures that resources are not continuously wasted on uncooperative opponents, while also preserving options for future cooperation if opponents change their strategies.

Pseudocode:
```
Strategy TFTA(n, k, r, d_threshold):
  Initialize state for each opponent i with [cooperation_history, defection_count]

  For t = 1 to r:
    If t == 1:
      Action = Cooperate (C) for all opponents
    Else:
      For each opponent i:
        if cooperation_history[i-1] == C and defection_count[i] < d_threshold:
          Action = Cooperate (C)
        elif cooperation_history[i-1] == D or defection_count[i] >= d_threshold:
          Action = Defect (D)
        Else:
          Action = Last opponent's action in the previous round

    Update state for each opponent i with current actions and adjust defection_count if necessary.
```
'''

description_COLLECTIVE_33 = '''
 Title: Tit-for-Tat-Adaptive Strategy (TfT-A) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TfT-A strategy follows a tit-for-tat approach with slight adaptations to accommodate different opponent behaviors and game conditions.

   - Initially, in the first few rounds (e.g., first 10% of total rounds), cooperate unconditionally to encourage cooperation among opponents.
   - After the initial phase, cooperate if more than half of the players have cooperated in the previous round; otherwise, defect.
   - If an opponent has consistently defected for a set number of rounds (e.g., 3 consecutive defections), switch to unconditional defection for a fixed number of rounds (e.g., 5) as a punishment before returning to the cooperate-if-most-cooperated rule.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, follow the initial cooperation phase to encourage others to cooperate.
   - In the last round, cooperate regardless of the number of cooperators from the previous round since the game is repeated and there are no future rounds to punish opponents.

3. Be collective - Clearly align with the collective mindset
   TfT-A strategy aims to maximize total payoff for all players by promoting cooperation whenever possible while also considering fairness in punishing defections. By following this approach, the strategy encourages a collective mindset that benefits the group as a whole over individual gain.

Pseudocode:

```
def TfT_A(n, r, k, round, history):
    initial_phase = int(r * 0.1)
    punishment_length = 5
    cooperate_threshold = int(n / 2)
    current_cooperators = count_cooperators(history)

    if round <= initial_phase:
        return 'C'  # Unconditional cooperation in the initial phase

    elif current_cooperators >= cooperate_threshold:
        return 'C'  # Cooperate if more than half of players have cooperated

    else:
        if has_defected(opponent, history):
            if len(history) - round < punishment_length:
                return 'D'  # Punish defection with a fixed length

            else:
                return 'C'  # Return to cooperate-if-most-cooperated rule after punishment

        else:
            return 'C'  # Cooperate if opponents have not defected recently
```
'''

description_COLLECTIVE_34 = '''
 Strategy Name: Tit-for-Tat-K (TFT-K)

1. Decision Rules:
   - Start with cooperation (C) in the first round to establish a cooperative relationship.
   - For subsequent rounds, if a player cooperated in the previous round (t-1), cooperate back (C). If a player defected (D), also defect in the current round (t). This encourages reciprocation and avoids being taken advantage of by opponents who defect.
   - To maintain adaptability, set a forgiveness threshold 'f' (0 < f < r) that allows for forgiveness after a series of defections. If an opponent who previously defected cooperates in the current round, revert to cooperation (C) if it has been more than 'f' rounds since their last cooperation.
   - To ensure robustness, set a punishment threshold 'p' (0 < p < r) that enforces a harsh punishment if an opponent continues to defect after cooperation. If the number of consecutive defections from an opponent exceeds 'p', defect until they cooperate again or reach the punishment threshold, then revert to the forgiveness mechanism.

2. Handle Edge Cases:
   - In the last round (r), as there is no subsequent round for retaliation, players should cooperate (C) regardless of their opponents' previous actions to maximize payoff.
   - In the first round (t=1), as there is no previous history, players will cooperate (C).

3. Be Collective:
   - By reciprocating cooperation and punishing defection, the TFT-K strategy promotes a collective mindset of fair play and encourages long-term cooperation among players.
   - Players can adjust the forgiveness threshold 'f' and punishment threshold 'p' to balance their willingness to forgive opponents and respond harshly to repeated defections, allowing them to adapt to different opponent behaviours.

Pseudocode for TFT-K strategy:

```
function TFT_K(n, k, r, f, p, history) {
  // Initialize history with an empty list and the current round number t = 1
  let history = [];
  let t = 1;

  // Function to decide action for each player (i) at each round
  function decideAction(i, history) {
    if (t === 1 || (history[t-f-1] === 'C' && history[t-f] !== 'C')) {
      return 'C'; // Cooperate
    } else if (history[t-p-1] === 'D' && history[t-p] === 'D') {
      if (history[t-1] === 'C') {
        return 'C'; // Forgive after punishment threshold 'p'
      } else {
        return 'D'; // Continue punishing
      }
    } else {
      return history[t-1]; // Respond according to the opponent's previous action
    }
  }

  // Play game rounds by deciding actions and updating history
  for (let round = 1; round <= r; round++) {
    let playerActions = [];
    for (let i = 1; i <= n; i++) {
      playerActions.push(decideAction(i, history));
      history.push(playerActions[i]);
    }
  }

  // Calculate total payoff for each player based on game parameters and history
  let payoffs = [];
  for (let i = 1; i <= n; i++) {
    let totalContributions = history.filter(action => action === 'C').length;
    payoffs.push((1 - playerActions[i]) + (k/n) * totalContributions);
  }

  return payoffs;
}
```
'''

description_COLLECTIVE_35 = '''
 Strategy Name: Adaptive Tit-for-Tat with Community Factor (ATFC)

1. Decision Rules:
   - Initiate cooperation (play C) in the first round to demonstrate goodwill and encourage other players to cooperate.
   - In subsequent rounds, observe each player's previous action (C or D) and respond accordingly:
     - If player i cooperated (C), reciprocate by cooperating back (C).
     - If player i defected (D), also defect for one round as a punishment, then revert to cooperation.
   - To account for the community factor (k), modify the payoff calculation by considering the total contributions in the previous round when deciding whether to punish or cooperate:
     - If the ratio of contributors in the current round is less than or equal to the ratio of contributors in the previous round, defect.
     - Otherwise, cooperate. This rule encourages cooperation when it seems to be a collective good for the group (based on k).

2. Handle Edge Cases:
   - In the last round, always cooperate as there are no more opportunities for retaliation or reward.
   - In case of a tie (same number of contributors in both rounds), default to cooperation to maintain a positive stance.
   - For the first round, initiate cooperation as mentioned earlier.

3. Collective Mindset:
   - By demonstrating goodwill initially and reciprocating when others cooperate, the strategy aims to establish trust and promote long-term cooperation within the group.
   - The community factor (k) encourages a collective mindset by considering the overall benefit of contributions for the entire group rather than solely focusing on individual gains.

Pseudocode:

```python
def ATFC(previous_round, k, n):
    current_action = 'C'  # Initiate cooperation in first round

    if r == 1:  # Last round, always cooperate
        return 'C'

    if r > 1:
        total_contributors_prev = sum(previous_round)
        ratio_contributors = float(total_contributors_prev) / n  # Community factor (k) is already factored in the game parameters

        if current_action == 'C' and total_contributors_prev >= total_contributors:  # If player cooperated and fewer contributed this round, defect
            return 'D'
        else:  # Otherwise, cooperate
            return 'C'
```
'''

description_COLLECTIVE_36 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Start by cooperating in the first round (C_i, 1 = 1). This is a friendly gesture to encourage cooperation from others.
   - In subsequent rounds, mimic the actions of the previous round (C_i, t = C_i, t-1 if all players cooperated last round; C_i, t = D_i, t-1 if any player defected last round). This reciprocal strategy fosters long-term cooperation while allowing for punishment of defections.

2. Edge Cases:
   - In the last round (t=r), cooperate regardless of previous actions since the game ends immediately after.

3. Collective Mindset:
   - The ATFT strategy is designed to maintain a balance between cooperation and punishment, aiming for long-term mutual benefits while still retaliating against defections. This collective mindset encourages other players to cooperate as well and fosters a stable level of cooperation in the group.

Pseudocode:
```python
def ATFT_strategy(r, n, k):
    # Initialize history with initial cooperation (C)
    history = [1] * n

    for t in range(1, r+1):
        total_contributions = sum(history[t-1])
        if total_contributions == n:  # All players cooperated last round
            history.append(1)  # Cooperate this round (C)
        else:  # At least one player defected last round
            history.append(0 if history[t-1][i] == 1 else 1)  # Defect or Cooperate based on last action
```
This strategy aims to strike a balance between cooperation and punishment while fostering long-term mutual benefits in the repeated N-Player Public Goods Game.
'''

description_COLLECTIVE_37 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate (C) in the first round to foster a cooperative environment and show goodwill.
   - In subsequent rounds, players will adopt the Tit-for-Tat strategy:
     - If an opponent cooperates, the player also cooperates (C).
     - If an opponent defects, the player defects in the next round (D), but returns to cooperation if the opponent cooperates again in the following round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperation (C) as a gesture of goodwill and to encourage cooperation among players.
   - Last round: Players should evaluate their overall payoff in previous rounds before making a decision. If the total payoff is positive, cooperate (C); otherwise defect (D). This encourages long-term cooperation but also allows for defection if necessary.
   - Other edge cases (e.g., when encountering different opponent behaviors): Maintain the Tit-for-Tat approach while being flexible in adjusting the number of consecutive defections or cooperations before responding with a counteraction. This adaptation helps the strategy to remain robust against various opponent strategies.

3. Be collective - Clearly align with the collective mindset
   - The Adaptive Tit-for-Tat strategy emphasizes cooperation and fosters a collaborative environment by mirroring opponents' behavior and offering initial goodwill.
   - By following this approach, players promote collective success and encourage others to cooperate, thus contributing to the public good and improving overall payoffs for all participants.

Pseudocode:

```python
def ATfT(n, k, r):
    opponents_history = []  # store previous rounds' actions of each opponent
    total_payoff = 0         # track total payoff over the game

    for round in range(1, r+1):
        if round == 1:  # first round, cooperate to initiate cooperation
            action = 'C'
        else:
            opponent_actions = [opponent[round-1] for opponent in opponents_history]
            current_action = decide_action(opponent_actions)  # use decide_action function
            action = current_action

        if action == 'C':  # cooperate and update payoff
            payoff = (1 - action_taken) + (k/n) * sum(opponent_actions)
            total_payoff += payoff
        else:  # defect
            payoff = 1 - action_taken

        # store the opponent's action from this round for future reference
        opponents_history[round-2] = action

    return total_payoff

def decide_action(opponent_actions):
    if len(opponent_actions) == 0:  # first call in the game, return 'C' (cooperate)
        return 'C'

    previous_round = opponent_actions[-1]  # use the most recent action for decision making

    if previous_round == 'C':  # cooperate when opponents cooperated
        return 'C'
    elif previous_round == 'D' and num_consecutive_defections > threshold:  # defect after enough consecutive defections
        num_consecutive_defections += 1
        return 'D'
    else:  # reset counter and cooperate after opponent cooperates or initial cooperation
        num_consecutive_defections = 0
        return 'C'
```

The above pseudocode provides a foundation for the Adaptive Tit-for-Tat strategy, which is adaptable and robust to a wide range of opponent behaviors. The strategy can be fine-tuned by adjusting the threshold for consecutive defections or cooperations to better match specific game parameters and competitor strategies.
'''

description_COLLECTIVE_38 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The Tit-for-Tat strategy is designed to encourage cooperation while maintaining a responsive approach towards other players' actions. In this game, cooperating means contributing to the community project and defecting means keeping the endowment privately.

- Initially cooperate (C) in the first round to foster trust among opponents.
- For subsequent rounds, follow the actions of other players from the previous round:
  - If an opponent cooperated, cooperate as well.
  - If an opponent defected, defect in response to maintain a balance and signal displeasure with their action.

Pseudocode for the Tit-for-Tat strategy (n-player version):
```python
def tit_for_tat(history, r):
    if len(history) == 0:
        return 'C'  # Cooperate in the first round
    else:
        previous_round = history[-1]
        if previous_round['cooperators'] > 0:  # If any player cooperated last round
            return 'C'
        else:  # If all players defected last round
            return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, the strategy cooperates to initiate cooperation with other players. For the last round, the Tit-for-Tat strategy does not require any special consideration since it is designed for repeated interactions. However, if the game ends prematurely or the player needs to decide its own actions in a one-shot game, it can adopt a cooperative stance to encourage cooperation among players or defect to match the opponents' behavior when facing uncooperative players.

3. Be collective - Clearly align with the collective mindset

The Tit-for-Tat strategy is based on fostering trust and reciprocity among all players in the game. By cooperating initially and responding to other players' actions, it encourages a collective effort towards maximizing the community project's benefits. This approach aims at maintaining a stable cooperation level while also being robust against various opponent behaviors.
'''

description_COLLECTIVE_39 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initial round (t=1): Cooperate (C), demonstrating a willingness to contribute to the community project and encourage cooperation from others.
   - Subsequent rounds: Observe the actions of other players in the previous round. If all players cooperated, cooperate in the current round. If any player defected, defect in the current round as a punishment for defection. After defecting, wait for the number of cooperative rounds equal to the number of previous defections before cooperating again. This creates an opportunity for the opponent to rebuild trust and encourages reciprocity.

Pseudocode:
```
function TFT_AC(history, k, n):
    def_count = 0
    last_round_action = 'C'  # Initially cooperate in the first round

    for t in range(1, r+1):
        if history[t-1] == 'all defected':  # If all players defected in previous round
            def_count += 1
            last_round_action = 'D'   # Defect in current round
        elif def_count > 0:  # If any player defected and there are outstanding defections to be reciprocated
            if t - def_count >= r:  # If the number of remaining rounds is less than the number of outstanding defections
                last_round_action = 'C'   # Cooperate in current round regardless of previous actions
                def_count = 0  # Reset def_count to zero
            else:
                last_round_action = 'D'   # Defect in current round
        elif history[t-1] == 'all cooperated':  # If all players cooperated in previous round
            last_round_action = 'C'   # Cooperate in current round

    payoff = calculate_payoff(last_round_action, k, n)
    return payoff
```

2. Handle edge cases:
   - Last round (t=r): If the number of outstanding defections is greater than 0, cooperate in the last round to encourage cooperation from others before the game ends.
   - New games: Cooperate in the initial round to demonstrate a willingness to contribute to the community project and encourage cooperation from others.

3. Be collective:
   - Encourages reciprocity and long-term cooperation by punishing defection with temporary retaliation, while rewarding cooperation with continued cooperation.
   - Cooperates in situations where all players have demonstrated a willingness to contribute to the community project, fostering collective success and maintaining trust among players.
'''

description_COLLECTIVE_40 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initial Cooperation (first round): Cooperate to foster a cooperative environment and encourage others to do the same.
   - Subsequent rounds:
     - If opponent cooperated in the previous round, cooperate in the current round. This encourages long-term cooperation by reciprocating kindness.
     - If opponent defected in the previous round, also defect in the current round. This punishes defection and signals disapproval of uncooperative behavior.
     - Introduce a tolerance factor (t) that allows for forgiveness if an opponent has previously defected multiple times. When t defects occur, switch to full cooperation mode. The tolerance factor can be adjusted based on the number of players and rounds to ensure robustness against various strategies.

Pseudocode:
```
def TFT_AC(opponent, r, n, k, t=n/2):
  history = []
  for round in range(r):
    if round == 1:
      action = Cooperate()
    else:
      lastAction = opponent[round-1]
      actions = history.count(Cooperate) + lastAction
      if actions >= t:
        action = Cooperate()
      elif actions < t and lastAction == Cooperate():
        action = Cooperate()
      else:
        action = Defect()
    history.append(action)
    payoff = calculate_payoff(n, k, history[-1], opponent[round-1])
    update_strategy(history, payoff)  # Learn from experience and adapt strategy if needed
    return history
```

2. Handle edge cases:
   - First round: Cooperate to establish a cooperative environment.
   - Last round: Cooperate if opponent has been mostly cooperative in the past (more than t defects). Otherwise, defect as a strong signal of disapproval.
   - Breakdown scenarios: If there is a period of prolonged defection from opponents (e.g., more than t defections consecutively), switch to full cooperation mode as an attempt to restart cooperation.

3. Be collective:
   - By reciprocating cooperative behavior and punishing defection, the TFT-AC strategy encourages a collective mindset by rewarding those who contribute to the community project while penalizing those who do not.
   - The tolerance factor t allows for forgiveness in some cases, promoting opportunities for reconciliation and cooperation.
'''

description_COLLECTIVE_41 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initiate cooperation (C) in the first round to foster a positive initial interaction and set a cooperative tone.
   - In subsequent rounds, cooperate (C) if the majority of players cooperated in the previous round. If not, defect (D). This rule encourages reciprocation and punishes those who do not cooperate.
   - To be adaptive and robust to opponent behaviors, introduce a small probability "p" for deviating from the majority vote in a given round, which increases with the number of non-cooperators in the previous round (p = min(0.2 * (number of defectors in the previous round / n), 1)). This allows for flexibility and prevents being trapped in an endless cycle of defection due to minor deviations from majority cooperation.

2. Handle edge cases:
   - In the last round, cooperate regardless of past actions, as there are no subsequent rounds to reciprocate or punish.
   - In the first round, cooperate (C).
   - If a player encounters a situation where all opponents have defected (i.e., no cooperation in the previous round), the probability for cooperating in the current round increases slightly to promote rebuilding trust and encouraging others to reciprocate cooperation.

3. Be collective:
   - By aligning with the majority vote of past actions, TFT-AC adopts a collective mindset that encourages cooperation while punishing defection. The strategy aims to foster an environment where players recognize the benefits of cooperation and are incentivized to reciprocate positive interactions.

Pseudocode:
```
def tft_ac(n, k, r):
  # Initialize round counter and opponent actions history
  round = 1
  history = []

  while round <= r:
    # Cooperate in the first round
    if round == 1:
      action = "C"
    else:
      # Calculate the number of cooperators in the previous round
      total_cooperators = sum(history[-r+1:-1])

      # If a majority of players cooperated, cooperate; otherwise defect
      if total_cooperators > (n / 2):
        action = "C"
      else:
        # Introduce a probability for deviating from the majority vote based on the number of defectors in the previous round
        p = min(0.2 * (number_of_defectors / n), 1)

        if random.random() <= p:
          action = "C"
        else:
          action = "D"

    # Add current action to history
    history.append(action)

    # Update round counter
    round += 1
```
'''

description_COLLECTIVE_42 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initialize cooperation in the first round (c_i = C).
   - In subsequent rounds, cooperate if majority of players (≥ n/2) cooperated in the previous round. If not, defect (c_i = D). This rule encourages cooperation when it's beneficial for the group and punishes defection by withholding contributions when necessary.

2. Handle edge cases:
   - In the last round, regardless of the situation, cooperate to maximize individual payoff (π_i) in that specific round.
   - In the first round, since there is no previous history, everyone starts by cooperating.
   - If n is odd, a simple tiebreaker could be used where if exactly n/2 players cooperate, the player making the decision follows their ATfT rule (cooperate or defect).

3. Be collective:
   - The strategy aligns with the collective mindset by promoting cooperation when it benefits the group and only punishing defection when necessary. This encourages sustained cooperation as long as most players continue to cooperate.

Pseudocode for Adaptive Tit-for-Tat (ATfT):

```python
def ATFT(r, n, k):
    players_history = [[0] * r for _ in range(n)]  # stores history of cooperation for each player

    def get_cooperation_count():
        count = 0
        for row in players_history:
            if row[-1] == 1:
                count += 1
        return count

    def get_player_strategy(i):
        cooperation_count = get_cooperation_count()
        if cooperation_count >= n // 2:
            return "C"  # Cooperate
        else:
            return "D"  # Defect

    for t in range(r):  # rounds
        strategy = [get_player_strategy(i) for i in range(n)]
        players_history = [[players_history[i][t] if i == j else strategy[j] for j in range(n)] for i in range(n)]

    # In the last round, cooperate for maximum payoff:
    if t == r - 1:
        strategy = [1] * n

    return strategy
```
'''

description_COLLECTIVE_43 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C) to demonstrate goodwill and trustworthiness, setting the stage for potential cooperation in future rounds.
   - Subsequent Rounds (t>1): If a player i cooperated in the previous round and the number of cooperators in the current round is equal to or greater than the average number of cooperators over the last few rounds, then player i cooperates again (C). Otherwise, defect (D) as punishment for a lack of cooperation from others.
   - Average Cooperation Threshold Calculation: Moving average of the total number of cooperators in the past m rounds, where m is a user-defined parameter that determines the window size for averaging.

2. Edge Cases:
   - Last Round (t=r): Cooperate if the strategy has been cooperative in the preceding rounds and there's been an average level of cooperation within the moving average window. If not, defect as a final punishment to reflect dissatisfaction with the lack of collective cooperation.
   - First Round (t=1): As mentioned earlier, cooperate to establish goodwill and trust.

3. Collective Mindset:
   - The strategy emphasizes fairness and reciprocity, making it more likely that players will cooperate when others do so as well. However, the strategy also punishes defection to encourage others to follow the cooperative spirit.
   - By adapting its cooperation based on the average number of cooperators in previous rounds, the ATfT strategy aims to maintain a balanced and sustainable level of collective cooperation over time.
'''

description_COLLECTIVE_44 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Decision Rules:
   - In the first round, cooperate (C). This sets a friendly initial tone and allows for potential partners to benefit from your contributions.
   - For subsequent rounds, adopt the Tit-for-Tat strategy: mimic the action of your opponent from the previous round. If your opponent cooperated in the previous round, cooperate; if they defected, defect. This approach encourages reciprocity and builds trust while also providing a robust response to various opponent behaviors.
   - To adapt to situations where opponents may not reciprocate cooperation consistently, include a probability (p) of deviating from Tit-for-Tat to cooperate even when the opponent has defected in the previous round. This can help maintain a positive reputation and increase the likelihood of finding cooperation partners.

2. Handle Edge Cases:
   - In the last round, maximize your own payoff by adopting the Tit-for-Tat strategy based on the previous round's action of your opponent. If they cooperated, continue cooperating; if they defected, defect as well. This ensures you do not over-cooperate in the final stages of the game.
   - In the first round (t=1), you always cooperate regardless of the actions of other players since there is no previous history to consider.

3. Be Collective:
   - The TFTA strategy prioritizes a collective mindset by promoting reciprocity, trust, and cooperation among players. By following simple decision rules and adapting to different opponent behaviors, TFTA encourages the emergence of cooperation in repeated interactions while also being robust against various strategies.

Pseudocode:
```python
def TFTA(t, r, k, n, c_opp):
    if t == 1:
        action = 'C'  # Cooperate in the first round
    else:
        action = c_opp[t-1]  # Adopt Tit-for-Tat strategy based on previous opponent action

    if uniform_random() < p:  # Probability of deviating from TFTA to cooperate when opponent defected
        action = 'C'

    payoff = (1 - action) + (k/n) * sum(c_players[t])  # Calculate payoff for current round
    return action, payoff
```
In this pseudocode, `c_opp` is the previous opponent action, and `c_players` is a list containing the actions of all players in each round. The value of `p` represents the probability of deviating from Tit-for-Tat to cooperate when an opponent defected in the previous round. This pseudocode can be extended or modified as needed for specific implementation requirements.
'''

description_COLLECTIVE_45 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially in the first round, player cooperates (C). This is a friendly gesture to establish trust.
   - For subsequent rounds t > 1, if the player cooperated in round t-1 and the majority of players cooperated in round t-1 (more than (n-1)/2), then the player also cooperates in round t (C).
   - If the player or majority of players did not cooperate in round t-1, the player defects (D) in round t. This is a punishment mechanism to encourage cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned before, the player cooperates (C).
   - In the last round, the player cooperates if it has previously cooperated and the majority of players also cooperated in the previous round. Otherwise, the player defects.

3. Be collective - Clearly align with the collective mindset
   - TFTA is designed to encourage cooperation within the group as it rewards mutual trust and punishes defection. However, it does not rely on any pre-determined coordination mechanisms or shared norms among players. Instead, it responds adaptively to the behavior of others.
   - The strategy aims to foster a collective mindset by demonstrating consistent behavior (cooperate if others do and defect if they don't) and maintaining trust when others cooperate while punishing those who do not.
'''

description_COLLECTIVE_46 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C_i,1 = 1).
   - For subsequent rounds, if a player i cooperated in the previous round (C_i,t-1 = 1) and the majority of players cooperated as well (more than (n/2) players cooperated), then cooperate again (C_i,t = 1). Otherwise, defect (C_i,t = 0).
   - If a player i defected in the previous round (C_i,t-1 = 0), observe the majority of cooperation from other players for three consecutive rounds before deciding whether to cooperate or defect. If more than (n/2) players have cooperated in these three rounds, then cooperate (C_i,t = 1). Otherwise, continue defecting (C_i,t = 0).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, every player will cooperate.
   - In the last round, players should consider their total score over the game and apply decision rules accordingly to maximize their final payoff.

3. Be collective - Clearly align with the collective mindset
   - The ATfT strategy aims to maintain a cooperative environment while being robust against potential defection from other players. It encourages cooperation by reciprocating contributions from other players and punishing defections with continued defection until the other player demonstrates a willingness to cooperate again. This strategy aligns with a collective mindset by promoting fairness, trust, and mutual support among players over time.

Pseudocode:

```python
def ATfT(n, k, r):
    rounds = range(1, r + 1)
    cooperators_in_round = [0] * r
    my_cooperation = [1] + [0] * (r - 1) # initial cooperation in the first round

    for t in rounds:
        total_contributions = sum(cooperators_in_round[max(t - 3, 0):t])
        if total_contributions > n/2:
            my_cooperation[t] = 1 # cooperate if more than half of players have contributed in the last three rounds
        else:
            if t == 1 or (my_cooperation[t-1] == 0 and total_contributions > n/2):
                my_cooperation[t] = 1 # cooperate in the first round or if I defected and most contributed in the last three rounds
            else:
                my_cooperation[t] = 0 # continue defecting
        cooperators_in_round[t] += my_cooperation[t]

    payoff = sum([(1 - my_cooperation[t]) + (k / n) * cooperators_in_round[t] for t in rounds])
    return payoff
```
'''

description_COLLECTIVE_47 = '''
 Strategy Name: Tit-for-Tat-with-Variation (TFT-V)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate cooperation and create a positive environment.
   - For subsequent rounds, observe opponent's action from the previous round:
      - If opponent cooperated in the last round, cooperate in the current round (as a reward for cooperation).
      - If opponent defected in the last round, defect in the current round (to retaliate against defection and encourage cooperation).
   - To allow for forgiveness and promote long-term cooperation:
     - After defecting or being defected upon, wait for d penalty rounds before returning to cooperative behavior. The value of d can be adjusted based on the number of players and the desired level of patience. For example, d = n/2 for larger groups and d = 1 for smaller groups.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, since there are no future rounds to retaliate or be forgiven, cooperate if opponent cooperated in the previous round and defect otherwise.

3. Be collective - Clearly align with the collective mindset:
   - By following TFT-V, the strategy promotes cooperation as it encourages reciprocal behavior and forgiveness. The strategy aims to create a stable environment where defection is not rewarded in the long run.
   - Although the strategy does not rely on others sharing norms or coordination mechanisms, it can still contribute to collective success by fostering cooperation among players.
'''

description_COLLECTIVE_48 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules:
   - Initial round (t=1): Cooperate (C) to promote a cooperative environment and signal good intentions.
   - Subsequent rounds:
      - If opponent cooperated in the previous round (π-1), cooperate (C).
      - If opponent defected in the previous round (π-1), defect (D).

2. Handle edge cases:
   - Last round (t=r): Cooperate regardless of opponent's action in the previous round to maximize payoff for that specific round.
   - First round (t=1): As mentioned above, cooperate to initiate cooperation.
   - No cooperation from opponents: Continue cooperating until an opponent defects, then respond with defection. If all opponents always defect, the strategy will continue cooperating in hopes of inducing change.

3. Be collective:
   - The strategy promotes collective cooperation by initially signaling good intentions and responding to cooperation with cooperation.
   - However, since there is no coordination mechanism or reliance on others sharing norms, the strategy will not compromise its own payoff for the sake of cooperation if it does not benefit from doing so.

Pseudocode:
```
function TFTAC(round, opponent_action_history) {
  if round == 1 {
    return 'C'  # Cooperate in the first round
  }

  if last_round != round {
    if opponent_cooperated_last_round {
      return 'C'  # Cooperate when opponent cooperated last round
    } else {
      return 'D'  # Defect when opponent defected last round
    }
  }

  # In the last round, always cooperate regardless of previous actions
  return 'C'
}
```
'''

description_COLLECTIVE_49 = '''
 In this N-Player Public Goods Game, we will develop a strategy named Tit-for-Tat with Adaptation (TfTA) for optimal performance against a wide range of opponent behaviors.

1. Specify decision rules:
   - Cooperation (C): If the player's previous action was cooperative and at least half of the opponents in the last round also cooperated, or if it's the first round.
   - Defection (D): Otherwise, defect.

Pseudocode for the decision rule:
```
def decide_action(round, personal_history, opponents_history, n, k):
  if round == 1:
    return 'C'

  current_cooperation = count_cooperators(personal_history)
  half_opponents_cooperated = current_cooperation >= len(personal_history) // 2 and count_majority(opponents_history, 'C') > len(opponents_history) // 2

  if half_opponents_cooperated:
    return 'C'
  else:
    return 'D'
```

2. Handle edge cases:
   - In the first round, always cooperate as there is no history to consider.
   - In the last round, there are no future consequences, so analyze the current state and follow the decision rule.

3. Be collective: The TfTA strategy encourages cooperation when most opponents also choose to cooperate, fostering a collective mindset by rewarding cooperative behavior and punishing defection. However, it is essential to remember that there's no assumption of shared norms or coordination mechanisms between players.

The Tit-for-Tat with Adaptation strategy provides a robust and adaptive approach for the N-Player Public Goods Game, allowing it to perform well against various opponent behaviors while promoting collective cooperation when appropriate.
'''

description_COLLECTIVE_50 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round to demonstrate goodwill and trustworthiness (C).
   - In subsequent rounds, mimic the opponent's previous action from the last round (i.e., if opponent cooperated in the last round, cooperate; otherwise, defect).
   - If an opponent changes strategy mid-game, follow their latest action (i.e., if they switch from cooperating to defecting, respond with defection and wait for them to change back).
   - Reinforce cooperation once an opponent returns to cooperation after previously defecting.

Pseudocode:
```
def tft_ac(opponent_history):
  strategy = ['C'] * r # initialize strategy as cooperative for all rounds
  last_action = strategy[-1] # store the last action taken

  for round in range(1, r + 1):
    if round == 1:
      strategy[round - 1] = 'C' # cooperate in the first round
    else:
      strategy[round - 1] = last_action # mimic opponent's last action

      # handle opponent strategy changes and punish defections
      if round > 1 and strategy[round - 1] != strategy[round - 2]:
        strategy[round - 1] = strategy[round - 1]
      elif strategy[round - 1] == 'D':
        strategy[round - 1] = last_action # punish defection by matching their previous action

  return strategy
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to establish goodwill and trustworthiness.
   - At the end of the game, continue following the opponent's latest action as a signal for future interactions.

3. Be collective - Clearly align with the collective mindset:
   - By adhering to the Tit-for-Tat strategy, this approach encourages cooperation and the formation of mutual trust among players in the long run, fostering a more collaborative environment.
'''

description_COLLECTIVE_51 = '''
 Strategy Name: Tit-for-Tat Evolution (TFT-E)

1. Specify decision rules:
   - In the first round (t=1), cooperate to demonstrate goodwill and promote trust in other players. This is represented by C(1) = True.
   - For subsequent rounds (t>1), evaluate previous opponents' actions and cooperate if they also cooperated in the preceding round, otherwise defect. This is represented by C(t)=prev_opponent_action(t-1).

2. Handle edge cases:
   - In the last round (r), consider the total game payoff rather than only the previous opponent's action, as the game ends soon and the strategy should aim to maximize its total payoff over the r rounds. C(r) = (total_payoff > avg_payoff) ? prev_opponent_action(r-1) : !prev_opponent_action(r-1)
   - In case of a tie in the last round, choose to cooperate as it aligns with the collective mindset and promotes cooperation for future games. C(r) = True if there's a tie.
   - If no previous action is available (e.g., first interaction with a player), cooperate to maintain a cooperative demeanor. C(t) = True for t<2 and no prior history with the opponent.

3. Be collective:
   - Prioritize cooperation over defection, as it promotes trust and mutual benefit among players, contributing to the collective mindset of cooperation.
   - Adapt to opponents' behaviors in a flexible manner, allowing the strategy to prosper even in diverse player populations with varying levels of cooperation or defection.

Pseudocode:
```
function TFT-E(n, r, k, opponent_history)
  if t = 1 then
    return True
  end if

  previous_opponent_action = opponent_history[t-1]
  total_payoff = 0
  avg_payoff = 0

  for t' in [1 to r] do
    payoff_t' = (1 - C(t')) + (k/n) * sum(j=1 to n, C(j, t'))
    total_payoff += payoff_t'
  end for

  avg_payoff = total_payoff / r

  if t = r then
    if opponent_history is tied at round r-1 then
      return True
    end if
    if total_payoff > avg_payoff and prev_opponent_action(t-1) == True then
      return True
    else
      return !prev_opponent_action(t-1)
    end if
  end if

  if t < 2 or no prior history with the opponent then
    return True
  end if

  return prev_opponent_action(t-1)
end function
```
'''

description_COLLECTIVE_52 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players cooperate (C). This is a friendly gesture to encourage cooperation among all players.
   - For subsequent rounds, players mimic the actions of their opponents from the previous round (i.e., if opponent cooperated in the previous round, cooperate; otherwise defect). This encourages trust and reciprocity while being punitive towards opponents who do not cooperate.
   - If an opponent consistently cooperates, players will also cooperate to maintain mutual cooperation.
   - If an opponent consistently defects, players will also defect to punish them and protect their own payoffs.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), all players cooperate (C).
   - In the last round (t=r), players consider the total contributions of their opponents over the game and mimic their actions from the preceding round. If an opponent has contributed more than half of the rounds, players cooperate; otherwise, they defect. This encourages long-term cooperation while accounting for free riders.
   - If a player encounters a situation where all opponents have defected in consecutive rounds (i.e., a "punishment spiral"), the player will switch to cooperating after a certain number of such rounds to potentially break the cycle and re-establish mutual cooperation.

3. Be collective - Clearly align with the collective mindset
   - The TFT-A strategy aims to foster collective interest by promoting reciprocity, trust, and fairness among all players. It seeks an equilibrium where cooperation is sustainable over multiple rounds while minimizing losses from defectors.
   - Players are encouraged to contribute to the public good when others do so, incentivizing a sense of community and shared interest in maintaining cooperative relationships.

Pseudocode for TFT-A:

```python
def tft_a(opponent_history, r, n, k):
    player_history = [C]  # Initialize with first cooperative action

    for t in range(1, r+1):
        if opponent_history[t-1] == C:  # Cooperate if opponent cooperated last round
            player_history.append(C)
        else:  # Defect if opponent defected last round
            player_history.append(D)

        if t == r:  # Last round considerations
            total_contributions = sum(1 for h in opponent_history if h == C)

            if total_contributions > len(opponent_history) / 2:
                player_history.append(C)
            else:
                player_history.append(D)
        elif any(player_history[t-l] == D for l in range(1, min(len(player_history), t))):
            # Break punishment spiral after certain number of consecutive defections
            if t > 3 and all(player_history[t-4:t] == [D]):
                player_history.append(C)

    return player_history
```
'''

description_COLLECTIVE_53 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially in the first round (t=1), play C (Cooperate). This is a friendly gesture to establish trust.
   - From the second round onwards (t>1), observe previous player's action (a_i, t-1) and respond with the same action. If a_i, t-1 = C (Cooperate), then play C; if a_i, t-1 = D (Defect), then play D. This encourages cooperation when met with cooperation and punishes defection.
   - To promote collective mindset, always consider the long-term payoff and maintain the mutual trust as much as possible.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), play C (Cooperate) to initiate cooperation.
   - In the last round (t=r), play C if the current round result is favorable for cooperation (i.e., most players cooperated in the previous round). If not, play D to minimize losses before the game ends.

3. Be collective - Clearly align with the collective mindset
   - Always consider the community's interest by adhering to the decision rules and responding to opponents' actions in a predictable manner. This encourages cooperation as players can anticipate each other's behavior.
   - Maintain a balance between short-term gains and long-term benefits by minimizing punishment for occasional defections while promoting collective rewards for continuous cooperation.
'''

description_COLLECTIVE_54 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i starts by cooperating unless it has observed a history of defection from most other players in the previous rounds. The exact condition is defined as follows:

- If (t > 1) and ((total_contributions in round t-1)/n < threshold) then play D, else play C

The default threshold value is set to 2/3 (rounded down). This means that the strategy will cooperate if more than 50% of players contributed in the previous round. However, this threshold can be adjusted based on observations from game history and performance.

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the initial round (t=1), all players start by cooperating to encourage cooperation among players and build trust. In the final round (t=r), players will play D regardless of the previous round's contribution history since there is no benefit from contributing anymore.

3. Be collective - Clearly align with the collective mindset

The ATfT strategy aims to promote a collective mindset by rewarding cooperation and punishing defection. The strategy encourages cooperation when most players are cooperating, but it also retaliates against those who defect. By doing so, ATfT seeks to establish a stable equilibrium where most players choose to cooperate for mutual benefit.

Pseudocode:

```
def Adaptive_Tit_for_Tat(t, n, k, history):
    total_contributions = sum(history[-n:])
    if t == 1:                       # initial round
        action = C
    elif t == r:                     # last round
        action = D
    else:
        if (total_contributions/n) < threshold: # less than 50% cooperated
            action = D
        else:                             # more than or equal to 50% cooperated
            action = C

    return action
```
'''

description_COLLECTIVE_55 = '''
 For this N-Player Public Goods Game, we'll develop a strategy called "Tit-for-Tat with Adaptation" (TfT-A) that fosters cooperation while being robust to various opponent behaviors.

1. Specify decision rules:
   - Initiate cooperation in the first round (c_i = C) and copy the previous round's action of the opposing player for subsequent rounds (c_i = lastAction_j, where j is the opponent).
   - Adapt to new situations based on a history window of past interactions. If the number of cooperative actions by the opponent in the history window exceeds the number of defections, adopt a cooperative stance (c_i = C). Otherwise, defect (c_i = D). The size of the history window can be adjusted according to the game's length and complexity.

Pseudocode for TfT-A strategy:

```
function getHistory(i, historyWindow) {
  if (round == 1) return [D]; // First round defaults to defection

  let history = [];
  for (let j = 0; j < historyWindow; j++) {
    if (j == i - 1) continue; // Skip the current player's action in the history
    history.push(opponents[j][round - 1]);
  }
  return history;
}

function TfT_A(i, opponents, historyWindow) {
  let cooperationCount = 0;
  let defectionCount = 0;
  let opponentHistory = getHistory(i, historyWindow);

  for (let j = 0; j < opponentHistory.length; j++) {
    if (opponentHistory[j] == 'C') cooperationCount++;
    else defectionCount++;
  }

  return cooperationCount > defectionCount ? 'C' : 'D';
}
```

2. Handle edge cases:
   - In the first round, since no history is available, we default to cooperation.
   - For the last round, TfT-A acts based on the most recent interaction with the opponent.

3. Be collective:
   - By adhering to the Tit-for-Tat principle and cooperating when others do so, TfT-A fosters a collective mindset that promotes cooperation over defection in repeated interactions.
'''

description_COLLECTIVE_56 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to signal goodwill and initiate cooperation. (C)
   - For subsequent rounds, follow the strategy of the opponent in the previous round. If the opponent cooperated in the last round, cooperate; if the opponent defected, also defect. This approach promotes reciprocity while maintaining adaptability to various opponent behaviors. (If opponent_last_action is C, then action = C; otherwise, action = D)

2. Handling Edge Cases:
   - Last round: Since there are no future rounds for retaliation, cooperate regardless of the opponent's last action. (Regardless of opponent_last_action, action = C)
   - Initial rounds beyond the first: Continue with TFT-AC by following the opponent's action in the previous round. (If round > 1, then if opponent_last_action is C, then action = C; otherwise, action = D)

3. Being Collective:
   - TFT-AC is designed to promote cooperation and reciprocity among players, aligning with a collective mindset by fostering trust and long-term collaboration. This approach incentivizes opponents to cooperate in response to the initial cooperative move and maintain cooperation when met with similar behavior.

Pseudocode:
```
function TFT_AC(opponent_last_action, round, n, k):
  if round == 1:
    action = 'C'
  elif round == r:
    action = 'C'
  else:
    action = opponent_last_action
  return action
```
In this pseudocode, `opponent_last_action` is the opponent's action in the previous round, `round` is the current round number, `n` is the total number of players, and `k` is the multiplication factor. The function returns the action to be taken in the given round according to the TFT-AC strategy.
'''

description_COLLECTIVE_57 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage others to cooperate initially.
   - For subsequent rounds, evaluate the opponent's cooperation history and adapt accordingly.
     - If the opponent cooperated in the previous round, cooperate (C) to reinforce trust and reciprocity.
     - If the opponent defected in the previous round, also defect (D) to punish the opponent for their uncooperative behavior but keep a record of this action as potential evidence of future strategy adjustments.
   - To minimize the chances of being exploited early in repeated games, start with a 'punishment phase' by defecting initially for a predetermined number of rounds (e.g., first 10% of total game rounds). After this punishment phase, switch to cooperative behavior based on the opponent's cooperation history.

2. Handle edge cases:
   - Last round: Cooperate (C) if it could potentially affect payoff in future games or to maintain a positive reputation for potential interactions with the same opponents in subsequent tournaments. Otherwise, behave as in the standard decision rules.
   - Initial rounds during punishment phase: Defect (D).

3. Be collective:
   - Adaptation is based on previous round outcomes rather than individual player's payoffs to maintain a collective approach that encourages cooperation among all players.
   - By responding to others' cooperation history, TFT-AC demonstrates an empathetic approach to collaboration and fosters long-term cooperation by rewarding trustworthy opponents and punishing uncooperative ones.
'''

description_COLLECTIVE_58 = '''
 In this strategic approach for the N-Player Public Goods Game, I propose a cooperative strategy called "Adaptive Tit-for-Tat with Fitness-Based Contribution Ratio (ATFCR)". The goal is to promote collective cooperation while being robust to various opponent behaviors.

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (FristRoundCooperation = True)
   - In subsequent rounds, decide whether to cooperate or defect based on the following conditions:
     a. If the opponent cooperated in the previous round (opponentActionLastRound == 'C'), then cooperate this round (Cooperate = True).
     b. If the opponent did not cooperate in the previous round (opponentActionLastRound == 'D'), adjust the contribution ratio based on the current fitness value, and then decide whether to cooperate or defect:
       i. Calculate the Fitness = (Number of Cooperative Opponents in the past r rounds) / r
       ii. Set ContributionRatio = Min(MaxFitness, MinimumContributionRatio) * (Fitness - MinimumFitness) + MaximumContributionRatio
         - MaxFitness and MinimumFitness are predefined upper and lower bounds for the contribution ratio, while MaximumContributionRatio and MinimumContributionRatio are values that determine the aggressiveness or passivity of the strategy.
       iii. Cooperate if ContributionRatio > Random() (a random number between 0 and 1)
         - If ContributionRatio is less than or equal to Random(), defect this round (Cooperate = False).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of the opponent's action (FristRoundCooperation = True)
   - In the last round, cooperate if the opponent has cooperated for at least a certain number of previous rounds (MinimumCooperativeHistory) to reward long-term cooperation. If this condition is not met, defect.

3. Be collective - Clearly align with the collective mindset
   - The strategy encourages cooperation by starting with cooperation in the first round and being responsive to opponents who cooperate. It also incentivizes players to contribute more when they perceive their opponent as consistently cooperative.
   - However, it is important to note that this strategy does not assume any specific coordination mechanisms or shared norms among players. Each player follows its own decision rules based on the game parameters and history.

Pseudocode:

```
def ATFCR(opponentActionLastRound, r, MinimumCooperativeHistory, MaxFitness, MinimumFitness, MaximumContributionRatio, MinimumContributionRatio, FirstRoundCooperation):
  if FirstRoundCooperation:
    Cooperate = True
  else:
    Fitness = (Number of Cooperative Opponents in the past r rounds) / r
    ContributionRatio = Min(MaxFitness, MinimumContributionRatio) * (Fitness - MinimumFitness) + MaximumContributionRatio
    Cooperate = (ContributionRatio > Random()) if opponentActionLastRound == 'D' else True
  return Cooperate
```
'''

description_COLLECTIVE_59 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to show goodwill and initiate a cooperative environment.
   - For subsequent rounds, analyze the opponent's behavior in the previous round and adapt accordingly:
     a) If the opponent cooperated (c_opponent = 1), return cooperation (play C).
     b) If the opponent did not cooperate (c_opponent = 0), defect (play D). However, if more than half of the players (n/2 + 1) in the previous round also did not cooperate, revert to cooperating to encourage a change in behavior.

2. Handle Edge Cases:
   - In the last round, defect regardless of the opponent's action since there are no subsequent rounds for payback.
   - In case of ties (e.g., n even and half the players did not cooperate), adopt the 'more forgiving' approach by cooperating to encourage a change in behavior.

3. Be Collective:
   - Maintain cooperation as much as possible while being responsive to opponents' actions, fostering a collective mindset by rewarding cooperation and punishing defection in a tit-for-tat manner. This approach encourages other players to cooperate while also preventing freeloaders from taking advantage of the group.

Pseudocode:
```python
def TFT_AC(n, k, r):
    def playRound(round, cooperationHistory, opponentCooperation):
        if round == 1:
            return 1  # Cooperate in the first round
        elif len(cooperationHistory) < round - 1:
            cooperationHistory.append(opponentCooperation)  # Update cooperation history
        else:
            if (sum(cooperationHistory[-round + 1:-1]) > (n/2)):  # Check if more than half defected in the last r-1 rounds
                return 1  # Cooperate, encourage a change in behavior
            elif opponentCooperation == 1:
                return 1  # Cooperate, reciprocate cooperation
            else:
                return 0  # Defect, punish defection

    cooperationHistory = []  # Initialize cooperation history
    totalPayoff = 0  # Initialize total payoff

    for round in range(1, r+1):
        opponentCooperation = getOpponentAction()  # Get opponent's action
        currentPayoff = playRound(round, cooperationHistory, opponentCooperation)
        totalPayoff += currentPayoff

    return totalPayoff  # Return the total payoff over r rounds
```
'''

description_COLLECTIVE_60 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A)

1. Specify decision rules:
   - Initialize cooperation for the first round (c_i, 1 = C) to foster a cooperative environment.
   - For subsequent rounds (t > 1), players will copy the actions of their most frequent opponent in the previous r rounds. If there is a tie, they also cooperate (c_i, t = C). This encourages reciprocity while maintaining adaptability to various opponent behaviors.

2. Handle edge cases:
   - In the last round (t = r), players will still base their decision on the most frequent opponent from rounds 1 to r-1, as we assume no communication or signals between rounds.
   - For the first round (t = 1), since there is no history, players will initially cooperate (c_i, 1 = C).

3. Be collective:
   - The TfT-A strategy prioritizes cooperation and reciprocity, promoting a collective mindset by rewarding opponents who also cooperate while punishing those who defect repeatedly.

Pseudocode for the strategy:

```
function TfT_A(opponentHistory, roundNumber, k, n):
  if (roundNumber == 1):
    return C  # Cooperation in the first round

  mostFrequentCooperators = countCooperationsInHistory(opponentHistory)

  if (length(mostFrequentCooperators) > 1):
    return C  # Cooperate when there is a tie
  else:
    return mostFrequentCooperators[0]  # Copy the action of the most frequent cooperator
```

In this pseudocode, `opponentHistory` represents an array containing the opponent's actions for each round, and `countCooperationsInHistory(opponentHistory)` returns the array of the opponents that have cooperated the most in previous rounds.
'''

description_COLLECTIVE_61 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Public Goods Game Variation (ATFT-PGV)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) as a gesture of goodwill and to contribute to the public good.
   - For subsequent rounds t:
      1. If the opponent cooperated in the previous round (t-1), cooperate (C). This is a reciprocal action, rewarding those who have previously cooperated.
      2. If the opponent defected in the previous round (t-1), defect (D) as a punishment for their previous non-cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (C).
   - Last round: Cooperate (C), regardless of the opponent's previous action, to maximize potential payoff for the final round.
   - Other edge cases: Use the same decision rules as specified above (ATFT).

3. Be collective - Clearly align with the collective mindset
   - By following the ATFT strategy, players are more likely to contribute to the public good and encourage others to do so through reciprocity. This promotes a collective mindset by rewarding cooperation and punishing defection.

Pseudocode:

```python
def ATFT_PGV(n, k, r, opponent_history):
  current_round = 1
  my_action = "C"  # Cooperate in the first round as a goodwill gesture
  payoff = 0

  while current_round <= r:
    if current_round == 1 or (current_round < r and opponent_history[-1] == "C"):
      my_action = "C"  # Cooperate
    elif current_round > 1 and opponent_history[-1] == "D":
      my_action = "D"  # Punish defection with defection

    payoff += calculate_payoff(my_action, opponent_history, n, k)
    current_round += 1

  return payoff
```
'''

description_COLLECTIVE_62 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Decision Rules:
   - In the first round, cooperate to foster a cooperative environment and demonstrate good faith.
   - For subsequent rounds, observe and mimic the behavior of other players from the previous round. If an opponent cooperated in the previous round, cooperate; otherwise, defect. This reactive approach mirrors common human strategies like Tit-for-Tat while adapting to different opponent behaviors.

2. Handle Edge Cases:
   - In the last round, cooperate regardless of the opponent's previous action, as there are no more subsequent rounds to reciprocate.
   - If the game is repeated multiple times, reset the strategy after each tournament to maintain its adaptive nature and ensure fairness in comparing strategies across different tournaments.

3. Be Collective:
   - The TFT-A strategy aims to align with a collective mindset by fostering cooperation when others are cooperating, but also punishing defection through strategic retaliation. This encourages the emergence of mutual trust and cooperation over time while maintaining robustness against defectors.

Pseudocode:
```
def TFT_A(round_num, opponent_history, n, k):
  if round_num == 1:
    return Cooperate()

  if len(opponent_history) == 0:
    return Defect()

  if opponent_history[-1] == Cooperate():
    return Cooperate()
  else:
    return Defect()

def play_game(r, n, k):
  strategy = TFT_A
  payoff = 0
  for round in range(r):
    actions = [strategy(round+1, opponent_history, n, k) for opponent_history in opponent_histories]
    payoff += calculate_payoff(actions, n, k)
  return payoff
```
'''

description_COLLECTIVE_63 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initialize: Start by cooperating (C) in the first round to foster a positive atmosphere and demonstrate goodwill.
   - Cooperate if all players cooperated in the previous round (all_cooperated_last_round).
   - Defect if any player defected in the previous round (any_defected_last_round).
   - If a player has never played before, assume cooperation (first-time players cooperate).
   - If the strategy encounters a deviation from cooperation, it will wait for the same number of rounds as the deviator's recent history of defections to forgive and resume cooperation.

Pseudocode:
```
def tft_ac(round, my_history, opponents_history):
  if round == 1:
    action = "C" # Cooperate in the first round

  elif any_defected_last_round(opponents_history):
    action = "D" # Defect if anyone defected last round

  else:
    my_deviations = count_deviations(my_history)
    opponent_deviations = count_deviations(opponents_history)

    if all_cooperated_last_round(opponents_history):
      action = "C" # Cooperate if everyone cooperated last round
    elif my_deviations > opponent_deviations:
      action = "C" # Cooperate even after a deviation, wait for same number of forgiveness rounds as the deviator's recent history of defections
    else:
      action = "D" # Defect if the strategy has more deviations than the opponents in the last few rounds
```

2. Handle edge cases:
   - Last round: Cooperate to maintain a positive relationship, even in the final round.
   - First-time players: Start by cooperating to establish trust.
   - Deviation from cooperation: Wait for the same number of forgiveness rounds as the deviator's recent history of defections before resuming cooperation.

3. Be collective:
   - Fostering a positive atmosphere by cooperating initially and demonstrating goodwill.
   - Adapting to the behavior of other players, punishing defections but forgiving them after a certain number of rounds.
   - Encouraging long-term cooperation through reciprocity.
   - Demonstrating collective thinking by considering the actions of all players in decision making.
'''

description_COLLECTIVE_64 = '''
 In this N-Player Public Goods Game, we'll develop a strategy called Tit-for-Tat-Plus (TFT+) that is adaptive and robust for a wide range of opponent behaviors. This strategy aims to encourage cooperation while also protecting against defection.

1. Decision rules:
   - TFT+ starts by cooperating in the first round (C_i = 1).
   - In subsequent rounds, the strategy follows the actions of the most frequent cooperator found in previous interactions (Frequent Cooperator, FC). If multiple players have the same highest cooperation frequency, choose one randomly.
   - If no player has cooperated more than half of the time, TFT+ defects to mimic the majority behavior of other players (C_i = 1 if more than n/2 players have cooperated; C_i = 0 otherwise).

Pseudocode for the TFT+ strategy:

```
function TFTPlus(n, r, k):
    initialize player cooperation frequencies f as a list of zeros
    initialize player i's action as C (cooperation)

    for t = 1 to r:
        i plays action i and collects payoff π_i

        if t > 1:
            identify Frequent Cooperator, FC
            if FC exists:
                i copies FC's action in the previous round (C_FC_{t-1})
            else:
                count number of cooperators, c
                if c > n/2:
                    i plays C (cooperation)
                else:
                    i plays D (defection)

        update player cooperation frequencies f based on the actions taken by all players in this round
```

2. Handling edge cases:
   - In the first round, TFT+ cooperates to initiate a potential cooperative relationship.
   - In the last round, TFT+ follows the same decision rules as in other rounds since it's still part of the repeated game structure and provides valuable information for future interactions (if any).

3. Being collective:
   - TFT+ strategy is designed to align with a collective mindset by promoting cooperation where possible, while also being aware of the actions of others to adjust its own behavior. This strategy assumes no coordination mechanisms but instead relies on past actions to make decisions.
'''

description_COLLECTIVE_65 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules:
   - In every round t, player i decides to cooperate or defect based on the history of opponent's actions in the previous rounds.
   - Initially, player i cooperates (C) in the first round (t=1). This is an attempt to build trust and cooperation.
   - For subsequent rounds, player i continues to cooperate if the opponent cooperated in the previous round, and defects otherwise. In other words, player i mimics the opponent's behavior from the preceding round.

2. Handle edge cases:
   - First round (t=1): Cooperate (C) as a goodwill gesture to initiate cooperation.
   - Last round (t=r): Analyze the current state of the game and make a decision based on the payoff matrix. This can involve considering various factors such as the average number of cooperators, the total amount of public goods contributed, or even implementing additional heuristics to maximize overall gain in the final round.
   - Intermediate rounds (2 ≤ t < r): Follow the TFT+ strategy by mimicking opponent's actions from the previous round.

3. Be collective:
   - By adopting a cooperative stance initially and mirroring opponents' behaviors, the strategy aims to encourage cooperation in the long run while still maintaining adaptability to various opponent strategies. This ensures that the player does not take on an overly aggressive or passive approach, which would be counterproductive for collective goals.
   - The TFT+ strategy fosters a cooperative environment by punishing defection and rewarding cooperation, promoting a collective mindset among players. However, it is essential to recognize that this strategy does not rely on others sharing norms or coordination mechanisms; instead, it reacts to the observed behavior of opponents in each round.
'''

description_COLLECTIVE_66 = '''
 Strategy Name: Tit-for-Tat (with Adaptive Generosity)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show goodwill and create a cooperative environment.
   - For subsequent rounds, observe the opponents' previous actions:
     - If opponent cooperated in the previous round, cooperate in return to maintain cooperation.
     - If opponent defected in the previous round, also defect in return to punish defection but with a twist of adaptive generosity:
       - If the number of consecutive defections by an opponent exceeds a threshold (let's call it T), increase the number of rounds needed for forgiveness proportionally (linearly) to the excess over T. This encourages opponents to return to cooperation without giving up completely on them if they make occasional mistakes.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier.
   - In the last round (r-th round), consider the current state of cooperation and apply the decision rule accordingly since future payoffs are not relevant at this point.
   - If an opponent does not conform to the established pattern or shows unpredictable behavior, adaptively adjust the threshold T based on historical data to maintain a balance between forgiveness and punishment.

3. Be collective - Clearly align with the collective mindset:
   - Prioritize cooperation as much as possible to contribute to the public good and maximize overall group benefits.
   - Punish defection to discourage free riding but be adaptively generous to encourage rehabilitation of errant players.
   - Maintain a balance between cooperation and punishment, which will lead to a collective mindset that fosters mutual trust and long-term sustainability in the game.

Pseudocode:
```python
def tft_adaptive_generosity(n, k, r, T=r/2, current_round, opponent_history):
    if current_round == 1:
        action = 'C' # Cooperate in the first round
    else:
        last_opponent_action = opponent_history[-1]
        consecutive_defections = sum(last_opponent_action == 'D' for _ in opponent_history[-T:])
        if last_opponent_action == 'C':
            action = 'C' # Cooperate when opponent cooperated in the previous round
        elif consecutive_defections > T:
            forgiveness_adjustment = max(0, (consecutive_defections - T) * (current_round - 1) / r)
            T += forgiveness_adjustment # Adjust the threshold for forgiveness
            action = 'D' # Defect when opponent has defected more than the adjusted threshold times
        else:
            action = 'D' # Defect when opponent defected in the previous round and did not exceed the threshold
    return action
```
'''

description_COLLECTIVE_67 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initially Cooperate (C) in the first round to demonstrate goodwill and encourage cooperation.
   - In subsequent rounds, cooperate if more than half of the players cooperated in the previous round, otherwise defect. This rule is inspired by the Tit-for-Tat strategy from game theory, but adapted for the public goods game setting.

2. Handle Edge Cases:
   - In the last round, always cooperate regardless of previous actions as the game ends here and payoffs are calculated individually.
   - In case of a tie (exact half of players cooperated), follow the majority rule by either cooperating or defecting based on whether an odd or even number of players cooperated in the previous round. If still uncertain, randomly choose one action to maintain unpredictability.
   - In the first round, always cooperate as mentioned earlier.

3. Be Collective:
   - Align with the collective mindset by promoting cooperation when it benefits the group as a whole and discouraging defection to prevent freeriding.
   - Maintain a balance between individual and collective interest by being both cooperative and responsive to others' actions, fostering trust and reciprocity over time.

Pseudocode:

```python
def ATFT(n, k, r):
    players_cooperated = 0  # Initialize the count of cooperators in the previous round
    total_payoff = 0        # Initialize the player's total payoff over the game

    for round in range(1, r+1):  # Loop through the game rounds
        if round == 1:  # First round
            action = 'C'  # Cooperate initially
        else:
            players_cooperated = sum(players_cooperated_in_rounds[round-2:round])  # Calculate number of cooperators in the last two rounds
            if players_cooperated >= n//2:  # More than half cooperated, cooperate this round
                action = 'C'
            else:                        # Defect to discourage freeriding
                action = 'D'

        payoff = (1 - (action == 'D')) + (k/n) * players_cooperated    # Calculate the payoff for this round
        total_payoff += payoff              # Accumulate the player's total payoff over the game

        players_cooperated_in_rounds.append(players_cooperated)  # Update the history of cooperators count

    return total_payoff            # Return the player's total payoff over the game
```
'''

description_COLLECTIVE_68 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), player starts by cooperating (C). This is a friendly gesture to initiate cooperation and build trust among opponents.
   - In subsequent rounds, the strategy will mirror the actions of the most frequent collaborator from the previous r-1 rounds. If multiple players tie for the most frequent collaborator, the strategy chooses to cooperate.
   - If no player has ever cooperated (i.e., they all defected in the previous r-1 rounds), the strategy will also defect in the current round to punish non-cooperative behavior.
   - When the game ends, players should cooperate for the last round to maximize potential rewards, regardless of past actions.

Pseudocode:
```
def TFTAC(r, n, k):
    players = []  # initialize list to store player histories
    strategy = {'cooperators': 0, 'defectors': 0}  # initialize cooperators and defectors count

    def update_strategy(history):
        strategy['cooperators'] += history.count('C')
        strategy['defectors'] += history.count('D')

    def get_most_frequent_cooperator(players, r):
        if len(players) == 0:
            return None
        max_cooperators = max(strategy['cooperators'], strategy['defectors'])
        candidates = [player for player in players if strategy[player]['cooperators'] >= max_cooperators - r]
        if len(candidates) == 1:
            return candidates[0]
        elif len(candidates) > 1:
            return candidates[0]  # arbitrarily select one of the most frequent cooperators
        else:
            return None  # no player has ever cooperated, so strategy defects

    def history_for_player(i):
        if players[i]:
            return players[i].history
        else:
            return History()  # initialize a new history object for the first round

    def play(i):
        history = history_for_player(i)
        most_frequent_cooperator = get_most_frequent_cooperator(players, r)

        if not most_frequent_cooperator:  # no player has ever cooperated
            return 'D'
        elif history.length < r:  # first r-1 rounds have not been played yet
            return 'C'
        else:  # play according to the mirror strategy
            if most_frequent_cooperator == i:
                return 'C'
            elif history[i].count('C') > history[i].count('D'):
                return 'C'
            else:
                return 'D'

    def History():
        actions = ['C'] * r + ['D'] * (2*r)  # initialize a history with r cooperations and 2r defections
        return {
            'history': actions,
            'length': 3*r
        }

    for i in range(n):
        players.append({'id': i, 'history': History()})

    for round in range(r):
        actions = []
        for i in range(n):
            action = play(i)
            actions.append(action)
            update_strategy(actions[i].history)  # update strategy for player i based on the current action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The TFTAC strategy handles the first round by cooperating as a friendly gesture. In the last round, it cooperates to maximize potential rewards, regardless of past actions.

3. Be collective - Clearly align with the collective mindset
   The TFTAC strategy aims to establish and maintain cooperation within the group by mirroring the actions of the most frequent collaborator from the previous r-1 rounds. This collective approach encourages cooperation while being robust to a wide range of opponent behaviors.
'''

description_COLLECTIVE_69 = '''
 Strategy Name: Adaptive Tit-for-Tat with Modified Contribution (ATFC)

1. Decision Rules:
   - In the first round (t=1), cooperate to show goodwill and trust towards other players (C).
   - For subsequent rounds, observe the total contributions from all players in the previous round (t-1) and adjust your contribution accordingly. If all players contributed in the previous round, cooperate (C); if any player defected, also defect (D).
   - If a player has consistently cooperated for a predefined 'Trust Threshold' number of rounds, maintain cooperation even if others defected in the most recent round; however, reduce contributions by 20% to account for past good experiences.
   - If a player has consistently defected for a predefined 'Punishment Threshold' number of rounds, also defect for the next 'Punishment Phase' number of rounds before resuming cooperation and full contributions.

Pseudocode:
```
function ATFC(round, total_contributions_prev, history):
  if round == 1:
    contribute = True (cooperate)
  elif total_contributions_prev == n:
    contribute = True (cooperate)
  else:
    contribution_history = get_player_contribution_history(round, history)
    trust_threshold, punishment_threshold, punishment_phase = parameters

    if number_of_consecutive_cooperations(contribution_history) > trust_threshold:
      contribute = True (cooperate) and reduce contribution by 20%
    elif number_of_consecutive_defections(contribution_history) > punishment_threshold:
      contribute = False (defect) for next punishment_phase rounds
    else:
      contribute = not total_contributions_prev (opposite of previous round's total contributions)

  return contribute
```

2. Handle Edge Cases:
   - In the last round, there is no need to apply any punishment or adjustments since the game ends after r rounds.
   - If a player encounters another strategy that does not follow standard game theory assumptions (e.g., communicates or shares information), ATFC will continue adhering to its decision rules while keeping track of such behavior for future encounters and potentially updating the 'Punishment Threshold' and 'Punishment Phase' parameters accordingly.

3. Be Collective:
   - ATFC aligns with a collective mindset by cooperating in the initial round, rewarding other players that cooperate, and punishing those who defect. The strategy aims to promote cooperation among players while being adaptive to various opponent behaviors and strategic shifts during the game.
'''

description_COLLECTIVE_70 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR)

1. Decision Rules:
   - Initially (in the first round), cooperate to signal trustworthiness and goodwill.
   - In subsequent rounds, adaptively determine cooperation based on the average number of cooperators in the previous 'p' rounds, where p is a parameter that can be tuned for optimal performance. If the average number of cooperators is above a threshold (T), cooperate; otherwise defect. The threshold (T) can also be adjusted as needed.
   - Maintain the strategy of cooperating if the opponent cooperates and defecting if the opponent defects in the same round, to encourage reciprocity. This is the "Tit-for-Tat" part of the strategy.
   - When the game ends (last round), always cooperate to maximize payoff.

2. Handle Edge Cases:
   - In the first round, cooperate as mentioned above.
   - If p is less than the number of rounds, use the average of available data from the past 'p' rounds. If fewer than 'p' rounds have passed, use all available data.
   - When the game ends (last round), always cooperate to maximize payoff.

3. Be Collective:
   - By adapting cooperation based on the average number of cooperators in previous rounds, the strategy encourages a collective mindset by rewarding and encouraging cooperative behavior.
   - Maintaining reciprocity (Tit-for-Tat) promotes fairness and collective interest.

Pseudocode for TFT-ACR:

```python
def tft_acr(n, k, r, p, T):
    # Initialize variables
    average_cooperators = 0
    cooperation_decision = {"C": 0, "D": 0}

    # Loop through each round
    for round in range(1, r+1):
        # Cooperate if it's the first round or if the strategy decides to cooperate
        if round == 1 or decide_to_cooperate(round, average_cooperators):
            cooperation_decision["C"] += 1
        else:
            cooperation_decision["D"] += 1

        # Update payoff based on own action and total cooperators
        payoff = (1 - cooperation_decision[str(round)]) + (k/n) * total_contributions(cooperation_decision)

        # Update the average number of cooperators over the last 'p' rounds
        if round >= p:
            average_cooperators = sum(cooperation_decision.values()) / min(round, p)

    return payoff

def decide_to_cooperate(round, average_cooperators):
    # Return True if the average number of cooperators is above a threshold (T), else False
    return average_cooperators > T
```
'''

description_COLLECTIVE_71 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Trend (TFT-ACT)

1. Decision Rules:
   - Initiate cooperation (play C) in the first round to foster a cooperative environment.
   - For subsequent rounds, mimic the behavior of other players from the previous round. If all players cooperated, continue cooperation; if any player defected, also defect in the next round.
   - Introduce an adaptive cooperative trend (ACT) that gradually shifts the strategy towards a more cooperative stance over time. After a series of rounds where all players have been cooperating, increase the probability of cooperation by 5% each round, up to a maximum of 95%. If cooperation is broken, revert back to the initial cooperative percentage for the next round.
   - If the game reaches its last round and cooperation has been maintained throughout, play C regardless of previous player actions to maximize final payoff.

Pseudocode:

```
initial_cooperation_percentage = 100%
current_round = 1
adaptive_cooperative_trend = 5%
cooperate_probability = initial_cooperative_percentage

function playRound(opponents_actions):
    if current_round == 1:
        action = 'C' (Cooperate)
    elif all(opponents_actions == 'C'):
        action = 'C' (Cooperate)
    elif any(opponents_actions != 'C'):
        action = 'D' (Defect)
    else:
        if cooperate_probability > 50%:
            action = 'C' (Cooperate)
        else:
            action = 'D' (Defect)

    if all(opponents_actions == 'C') and current_round != r:
        cooperate_probability += adaptive_cooperative_trend
        if cooperate_probability > 95%:
            adaptive_cooperative_trend = 0%
    elif any(opponents_actions != 'C'):
        cooperate_probability -= adaptive_cooperative_trend
        if cooperate_probability < 50%:
            adaptive_cooperative_trend = 0%

    current_round += 1

playRound(opponents_actions)
```

2. Handle edge cases:
   - In the first round, initiate cooperation (play C).
   - If all players have been cooperating throughout the game and it reaches the last round, play C regardless of previous player actions to maximize final payoff.

3. Be collective:
   - The strategy prioritizes maintaining cooperation when possible, fostering a collaborative environment.
   - The adaptive cooperative trend encourages players to gradually increase their cooperation over time, helping build trust and promoting sustained collaboration. However, it also allows for flexibility in adjusting cooperation levels based on the actions of other players.
'''

description_COLLECTIVE_72 = '''
 Strategy Name: Tit-for-Tat-Cooperative (TFT-C)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round i, the TFT-C strategy follows these rules:

- If in the preceding round j (j < i), both the player and all other players cooperated (C_i=1 and C_j=1 for all j ≠ i), then cooperate (C_i=1).
- If in the preceding round j, the player defected (D_i=0) but all other players cooperated (C_j=1 for all j ≠ i), then defect (C_i=0) in the current round. This is a punishment for defection and aims to encourage cooperation in the future.
- If in the preceding round j, both the player and some other players cooperated (C_i=1 and C_j=1 for some j ≠ i), then copy the action of the majority (cooperate if >50% players cooperated, defect otherwise). This promotes cooperation when it appears to be a common choice, but also allows for defection if necessary.
- If in the preceding round j, all players defected (D_i=0 and C_j=0 for all j ≠ i), then cooperate in the current round. This is an attempt to restart cooperation after a period of defections.
- In the first round, cooperate (C_1=1) as an initial goodwill gesture.
- In the last round, cooperate if the total number of cooperators over the game exceeds the total number of defectors (total_cooperators > total_defectors), and defect otherwise.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In addition to the decision rules above:

- In the first round, there is no preceding round, so cooperate (C_1=1).
- In the last round, if total_cooperators ≤ total_defectors, then defect (C_r=0), as it's better to match the defection behavior of other players in the final round.

3. Be collective - Clearly align with the collective mindset

The TFT-C strategy encourages cooperation by copying the actions of others and punishing defections, while also considering the total number of cooperators versus defectors over the game to make decisions in the last round. This approach aims to promote cooperation while being adaptive to various opponent behaviors and fostering a collective mindset within the game.

Pseudocode for TFT-C strategy:

```
function tft_c(round, history):
  cooperate = True

  if round == 1:
    cooperate = True
  elif round == r and total_cooperators <= total_defectors:
    cooperate = False
  else:
    players_cooperated = sum(history[round-1])
    my_action = history[round-1][round-1] # my action in the preceding round

    if players_cooperated == len(history) and my_action == 1:
      cooperate = True
    elif my_action == 0 and players_cooperated > (len(history) // 2):
      cooperate = False
    elif players_cooperated == len(history):
      cooperate = True
    else:
      cooperate = False

  return cooperate
```
'''

description_COLLECTIVE_73 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)

1. Specify decision rules:
   - In the first round, cooperate to initiate a potential cooperation cycle. This is an olive branch gesture, aiming to establish trust and encourage cooperation. (C in the first round)
   - For subsequent rounds, observe the previous round's total contribution level (total_contributions_t-1). If all players contributed last round, continue cooperating (C). If not, defect (D) as a punishment for non-cooperation in the hope that it will prompt others to cooperate in the current round.
   - Adaptive cooperation rule: If the total contribution level drops below a certain threshold (say, 50% of the maximum possible contribution), decrease the punishment duration by one round. In other words, start cooperating again after seeing two consecutive rounds of low contributions instead of three. This makes the strategy more forgiving and encourages opponents to cooperate.
   - If the total contribution level exceeds a certain threshold (say, 80% of the maximum possible contribution), increase the punishment duration by one round. In this case, continue defecting for two consecutive rounds instead of one when the contribution level drops below the 50% threshold. This enforces the importance of high contributions and discourages opponents from freeriding.
   - If the game reaches its final round (r), cooperate regardless of previous actions to potentially maximize payoffs in the last chance for cooperation.

2. Handle edge cases:
   - In the case where total_contributions_t-1 is equal to the contribution threshold, apply the adaptive cooperation rule by considering the recent history of contributions (e.g., the previous 5 rounds) to make an informed decision about cooperating or defecting.
   - If there are inconsistencies in the game structure (e.g., n < 2 or r <= 1), return a default strategy such as always defecting or randomly choosing actions to maintain fairness in the tournament.

3. Be collective:
   - Prioritize cooperation to contribute to the community project, aligning with a collective mindset that benefits all players in the long run.
   - Employ adaptive cooperation rules that encourage others to cooperate while still being responsive to non-cooperative behavior.
'''

description_COLLECTIVE_74 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, if t=1 (first round), player initiates cooperation with probability p_init (e.g., p_init = 0.5). For all subsequent rounds:
   - If the player and all others cooperated in the previous round (t-1), cooperate.
   - If any other player defected in the previous round, defect.
   - If the player's action from the previous round matches another player's action this round, copy that action.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For the first round (t=1), as mentioned above, initiate cooperation with probability p_init. In the last round (t=r), consider the total payoff accumulated over all previous rounds and apply the decision rules accordingly to maximize long-term benefits.

3. Be collective - Clearly align with the collective mindset:
   The ATFT strategy emphasizes mutual cooperation in an attempt to foster a reciprocal relationship with other players while maintaining adaptability towards various opponent behaviors. It encourages players to cooperate when others do so, incentivizing long-term collaboration and building trust among participants over time. However, it also punishes defection by retaliating with defection, thus discouraging exploitative behavior in the short term.
'''

description_COLLECTIVE_75 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adjustment (TFTC)

1. Decision Rules:
   - In the first round, cooperate to foster a positive atmosphere and encourage cooperation from others. This initial cooperation is important for building trust within the game.
     ```python
     if round == 1:
         action = "Cooperate"
     ```

   - For subsequent rounds, observe the actions of other players in the previous round. If everyone cooperated (total_contributions == n), continue cooperating to maintain trust and encourage reciprocal cooperation. If anyone defected, also defect to punish the defector and discourage future defection. If some but not all cooperated, adjust the probability of cooperating based on the number of cooperators in the previous round.
     ```python
     if total_contributions == n:
         action = "Cooperate"
     elif any_defection:
         action = "Defect"
     else:
         cooperative_probability = (total_contributions / n)
         if random.random() < cooperative_probability:
             action = "Cooperate"
         else:
             action = "Defect"
     ```

2. Handling Edge Cases:
   - Last Round: Since the objective is to maximize total payoff over all rounds, there's no need for punishment in the last round as it won't affect future payoffs. Cooperate in the final round to maximize the current round's payoff.
     ```python
     if round == r:
         action = "Cooperate"
     ```

3. Being Collective:
   - The TFTC strategy encourages reciprocity and cooperation, which aligns with a collective mindset. By cooperating when others do and defecting only when they have previously defected, the strategy aims to build trust and promote long-term cooperation among players.
'''

description_COLLECTIVE_76 = '''
 In this Public Goods Game, I propose a strategy named Adaptive Tit-for-Tat (ATFT) that is adaptive, robust, and collectively aligned with the game parameters and history.

1. Decision rules:
   - In the first round, cooperate as a starting gesture (C).
   - After the first round, analyze opponent behavior to determine the cooperation level (CL) based on the number of cooperators in each round. If CL > 50% of players, cooperate; otherwise, defect (D).
   - In subsequent rounds, if the opponent cooperated in the previous round, cooperate. If the opponent defected, do as they did in the previous round (i.e., mimic their behavior). This encourages cooperation with cooperators and retaliates against defectors.

2. Edge cases:
   - In the last round, cooperate regardless of the opponent's previous action to maximize potential payoff.
   - In the case of a tie (i.e., equal number of cooperators and defectors), adopt a random decision based on probability ≥ 0.5 to cooperate as a compromise strategy to avoid conflict with other players.
   - If the opponent's cooperation level is exactly 50%, use a random decision based on probability ≥ 0.5 to either cooperate or defect, allowing for potential shifts in collaboration.

3. Collective alignment:
   - By adopting a Tit-for-Tat strategy with a slightly more cooperative bias (ATFT), the strategy encourages collaborative behavior, as it rewards cooperation and punishes defection in a controlled manner.
   - The adaptive nature of ATFT allows for changes in cooperation levels based on observed player behaviors, ensuring flexibility to accommodate various opponent strategies.

Pseudocode:
```
function AdaptiveTitForTat(round, history):
  if round == 1:
    action = "C" # Cooperate as a starting gesture
  else:
    cooperation_level = calculate_cooperation_level(history)
    if cooperation_level > 0.5:
      action = "C" # Cooperate when majority cooperates
    elif history[round - 1]["action"] == "C":
      action = "C" # Cooperate if the opponent cooperated in the previous round
    else:
      action = history[round - 1]["action"] # Mimic opponent's behavior from the previous round
  return action

function calculate_cooperation_level(history):
  cooperation_count = sum(count_cooperators(history))
  total_players = len(history)
  if total_players == 0:
    return 0.0
  else:
    return float(cooperation_count) / total_players

function count_cooperators(rounds):
  cooperators = 0
  for round in rounds:
    if round["action"] == "C":
      cooperators += 1
  return cooperators
```
'''

description_COLLECTIVE_77 = '''
 Strategy Name: Tit-for-Tat with Fading Memory (TFTF)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, our AI will adopt a Tit-for-Tat strategy with a fading memory element to encourage cooperation while being resilient to occasional defections. The AI will cooperate in the first round and then mimic the previous action of its opponent for the next r - 1 rounds. However, to avoid getting trapped in an endless cycle of revenge, the AI will gradually forget past defections over time by slightly favoring cooperation after a prolonged sequence of defections from the opponent.

Pseudocode:
```
def TFTF(opponentHistory):
  if round == 1:
    cooperate = True
  else:
    lastAction = opponentHistory[-1]  # last action of the opponent
    if len(opponentHistory) > 3 and len(opponentHistory) % 3 == 0:  # fading memory - gradually favor cooperation after a prolonged sequence of defections
      lastThreeActions = opponentHistory[-3:]
      if all(lastThreeActions):  # all cooperators, start fresh with cooperation
        cooperate = True
      else:  # majority defect, slightly favor cooperation
        cooperate = not any(lastThreeActions)
    else:  # regular Tit-for-Tat behavior
      cooperate = lastAction

  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

As the pseudocode above demonstrates, our AI will cooperate in the first round and adjust its behavior based on the opponent's history thereafter. There is no specific consideration for the last round since the game structure does not specify any changes or termination conditions between rounds.

3. Be collective - Clearly align with the collective mindset

By adopting a Tit-for-Tat strategy, our AI encourages cooperation and punishes defection, promoting the collective interest of gaining a higher payoff in the long run. The fading memory element ensures that the AI forgives occasional mistakes and doesn't get stuck in a cycle of retaliation. By gradually forgetting past defections, it is more likely to encourage cooperation over time as the AI will favor cooperation after prolonged sequences of defection. This strategy promotes a collective mindset by fostering trust, reciprocity, and a cooperative environment among players.
'''

description_COLLECTIVE_78 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to establish trust and goodwill.
   - For subsequent rounds, follow a Tit-for-Tat approach: if the opponent cooperated in the previous round, cooperate; otherwise, defect.
   - To avoid getting stuck in a long cycle of defection, introduce Adaptive Generosity: if the opponent has not cooperated for consecutive s rounds (where s is a user-defined parameter), start cooperating to encourage them to reciprocate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, follow the rule of cooperation to initiate interaction positively.
   - In the last round (or any round close to the end), switch to a more selfish strategy by defecting, since there will be no future interactions with the opponent.
   - If an opponent does not cooperate for s consecutive rounds and has not responded to your Adaptive Generosity, consider adjusting the value of s to account for the stubbornness or uncooperative nature of that specific opponent.

3. Be collective - Clearly align with the collective mindset
   - The strategy prioritizes cooperation as a means to create a beneficial public good and foster long-term mutual benefits, promoting collective success in the game.
   - By adapting to an opponent's behavior, TFT-AG demonstrates responsiveness and the ability to collaborate effectively with various types of opponents.
'''

description_COLLECTIVE_79 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, the ATFT strategy will cooperate if and only if the total number of cooperators in the previous round (t-1) is greater than or equal to a certain threshold (T). Otherwise, it will defect. This adaptive nature allows for adjusting the cooperation level based on the opponents' behavior.

   Pseudocode:
   ```
   function ATFT(history):
       if history[t-1].total_contributions >= T:
           return "Cooperate" (C)
       else:
           return "Defect" (D)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
For the first round, there is no history available, so a random decision can be made, or an initial T value can be set based on heuristics like average number of players, k factor, etc. In the last round, the strategy will cooperate if the total number of cooperators in the current round is greater than or equal to T, as it has already made its decisions and does not need to punish others anymore.

3. Be collective - Clearly align with the collective mindset
ATFT strategy is designed to promote collective cooperation by rewarding those who contribute positively to the public good while gradually retaliating against those who do not cooperate. By adjusting the T value based on observations from previous rounds, it encourages a sense of fairness and reciprocity among players, fostering collaboration in the long run.

In summary, ATFT strategy is adaptive, robust, and collective. It aims to promote cooperation while being responsive to opponents' behavior by adjusting the cooperation threshold (T) based on historical data.
'''

description_COLLECTIVE_80 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In the first round, cooperate to initiate a cooperative environment. This helps foster trust and encourages cooperation in subsequent rounds. `if round == 1 then cooperate()`
   - For subsequent rounds, mimic the behaviour of other players from the previous round. If all players cooperated, continue cooperating; if any player defected, defect in the current round. This strategy is designed to encourage cooperation while punishing defection. `if (allPlayersCooperatedLastRound()) then cooperate() else defect()`
   - Modify the punishment for repeated defection by gradually increasing the number of rounds required for forgiveness. This helps prevent escalating conflict and allows for recovery from misunderstandings or temporary defections. `forgivenessCounter += 1 if (playerDefectedLastRound()) then forgivenessCounter = min(forgivenessCounter + 1, r)`
   - Once the player has defected 'forgivenessCounter' times, cooperate again to signal a willingness to return to cooperation. `if (playerDefectedLastRound() && forgivenessCounter >= r) then forgivenessCounter = 0 and cooperate()`

2. Handle Edge Cases:
   - In the last round, cooperate regardless of other players' actions since there are no future rounds for punishment or reward. `if (round == r) then cooperate()`
   - If a player encounters an error or unexpected situation (e.g., a player's action is not observable), default to cooperation as a peacekeeping measure.

3. Be Collective:
   - The ATFT strategy emphasizes fairness, trust, and collective well-being by encouraging cooperation while also punishing repeated defection. This promotes the long-term success of all players in the game.
   - By adapting to other players' actions, the strategy demonstrates a willingness to collaborate and adapt to changing circumstances, fostering a cooperative environment that aligns with the collective mindset.
'''

description_COLLECTIVE_81 = '''
 For this N-Player Public Goods Game, I propose a strategy called "Adaptive Tit-for-Tat" (ATFT). The ATFT strategy is designed to encourage cooperation while also being robust against various opponent behaviors.

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, player i will cooperate (C), as it might initiate a cooperative cycle with other players.
   - From the second round onwards, player i will mimic the action of the opponent from the previous round. If an opponent cooperated in the previous round, the player will also cooperate; otherwise, they will defect.

2. Handle edge cases:
   - Last round: Player i will cooperate if their opponent cooperated in the previous round, as a goodwill gesture. Otherwise, they will defect, assuming the opponent may not reciprocate cooperation in the last round.
   - New opponent or no information about the previous round (e.g., first interaction): Player i will cooperate as an initial action to foster cooperation.

3. Be collective: The ATFT strategy is inherently aligned with the collective mindset, as it encourages players to contribute to the community project when others do so as well. By mimicking opponent behavior, it promotes a sense of coordination and reciprocity among players.

Pseudocode for Adaptive Tit-for-Tat strategy:
```python
def ATFT(opponent_action):
  if round == 1:
    return 'C' # Cooperate in the first round
  if opponent_action == 'C':
    return 'C' # Cooperate when opponent cooperated in previous round
  else:
    return 'D' # Defect when opponent defected in previous round
```
'''

description_COLLECTIVE_82 = '''
 Title: Tit-for-Tat with Adaptive Cooperative Probability (TFTACP) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Cooperation: Start by cooperating in the first round to foster an atmosphere of cooperation. (c_i = 1, t=1)
   - Tit-for-Tat: Cooperate if opponent cooperated in the previous round, otherwise defect. (c_i = other_i_t-1 played C, c_i = other_i_t-1 played D)
   - Adaptive Cooperation Probability: Introduce a probability of cooperating even when an opponent has previously defected, to account for possible mistakes or changes in the opponent's strategy. This probability decreases over time as the game progresses, increasing the likelihood of returning to cooperation after being exploited by the opponent. (c_i = other_i_t-1 played D and random(0, 1) < p_t, where p_t decreases with each round)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (c_i = 1, t=1)
   - Last Round: Evaluate the opponent's behavior throughout the game and cooperate if the total cooperation score is higher than the total defection score. This encourages a positive final interaction even if the game has been uncooperative overall.

3. Be collective - Clearly align with the collective mindset
   - Collective Alignment: Maintain a record of total contributions from all rounds and prioritize cooperation when the community's aggregate contributions are high, as it indicates a general inclination towards collaboration. (c_i = other_i_t-1 played D AND (total_contributions < threshold) AND random(0, 1) < p_t)

Pseudocode:
```python
def TFTACP(n, r, k):
    total_contributions = 0
    cooperation_score = 0
    defection_score = 0
    p = 1.0
    threshold = total_contributions * (1 - 1/n) # set a reasonable threshold based on initial contributions

    for t in range(1, r+1):
        if t == 1: # first round
            contribution = 1
        else:
            contribution = other_i_t-1 played C if total_cooperation_score > total_defection_score or (total_contributions < threshold and random(0, 1) < p)
                             else other_i_t-1 played D
        total_contributions += contribution
        cooperation_score += contribution * (k/n)
        defection_score += (1 - contribution)
        p *= 0.95 # decrease adaptive probability for cooperating with defectors
    return total_payoff = sum(cooperation_score + (1 - contribution) for t in range(1, r+1))
```
This TFTACP strategy combines elements of cooperation and punishment to achieve a balance between individual and collective gains. The adaptive cooperative probability encourages forgiveness and allows the AI to respond to changing opponent behaviors effectively.
'''

description_COLLECTIVE_83 = '''
 Strategy Name: Tit-for-Tat (TfT) with Cooperative Adaptation (C-TfT)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to show good intentions and encourage cooperation from others.
   - Subsequent Rounds (t>1):
      - If previous round's action was Cooperate (C_t-1), cooperate in the current round (C).
      - If previous round's action was Defect (D_t-1), defect in the current round (D).
   This strategy promotes cooperation by reciprocating others' actions while maintaining simplicity and robustness.

2. Handle edge cases:
   - Last Round (t=r): Cooperate to encourage long-term cooperation and display a positive endgame signaling.
   - First Few Rounds (t<M, M is a predefined number of initial rounds for players to establish trust): Cooperate in the first round, then follow TfT rule from the second round onwards.

3. Be collective:
   The C-TfT strategy aligns with the collective mindset by promoting mutual cooperation and reciprocity. It assumes that most opponents will also adopt cooperative strategies over time, thus fostering a virtuous cycle of collaboration. In case of defection, the strategy retaliates to discourage future defections but always remains open to resuming cooperation if the opponent does so.

Pseudocode:

```python
def C_TfT(n, r, k, M):
    history = [D for i in range(M)]  # Predefined number of initial rounds (M) with defection

    for t in range(M, r+1):
        total_contributions = sum(history[t-M:t])
        if total_contributions > 0:  # If any player has cooperated before, follow TfT rule
            current_action = history[-1]  # Get last action from the history
            if current_action == 'C':
                history.append('C')  # Cooperate
            else:
                history.append('D')  # Defect
        else:  # If no player has cooperated before, follow initial cooperation rule
            history.append('C')  # Cooperate

    # Last round, always cooperate to encourage cooperation and display a positive endgame signal
    history.append('C')
```
'''

description_COLLECTIVE_84 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate to establish a positive relationship and foster trust. This is represented as: `if round = 1 then cooperate`.
   - For subsequent rounds, observe the previous opponent's action and respond with the same action taken in the immediately preceding round. If the opponent cooperated last time, also cooperate; if the opponent defected, defect in response. This is represented as: `if last_round_opponent_action = 'cooperate' then cooperate else defect`.
   - To encourage continued cooperation, introduce a forgiveness mechanism that overlooks past defections and returns to cooperating after a sequence of defections. Implement the "forgiveness period" concept where the strategy will remember the last n_f forgiveness failures (default n_f = 3) before restarting the cooperative behavior. This is represented as:
      ```
      forgiveness_counter = 0
      if last_round_opponent_action = 'defect' and forgiveness_counter < n_f then
          forgiveness_counter += 1
      else
          forgiveness_counter = 0
          cooperate
      ```
   - To handle the last round, revert to cooperation as there is no further opportunity for retaliation. This is represented as: `if round = r then cooperate`.

2. Handle edge cases:
   - For odd number of rounds (r % 2 == 1), consider the penultimate round an edge case where players will have limited opportunities to respond to each other's actions in the final round. In this case, cooperate in the penultimate round to maintain cooperation potential for the last round, as the strategy assumes no communication between players:
      ```
      if (round == r - 1) and (r % 2 != 0) then cooperate
      ```

3. Be collective:
   - The TFTAC strategy fosters a collective mindset by promoting cooperation and reciprocity within the game. By responding to opponents' actions adaptively, the strategy encourages sustained cooperation when faced with various opponent behaviors. It aims to build trust over time and benefit from the public good while avoiding being exploited by consistently defecting opponents.
'''

description_COLLECTIVE_85 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-A starts by cooperating in the first round and then copies the actions of its opponent from the previous round for each subsequent round. This strategy aims to foster cooperation while retaliating against defection, encouraging long-term trust between players.

   Pseudocode:
   ```
   function TFT_A(opponent_history):
       if r == 1: # First round
           return Cooperate (C)
       if opponent_history[r-1] == C: # Opponent cooperated last round
           return Cooperate (C)
       else: # Opponent defected last round
           return Defect (D)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-A is designed to adapt to edge cases such as the initial round and final rounds by considering them as part of the opponent's history. This ensures consistency in decision making across all rounds.

3. Be collective - Clearly align with the collective mindset
   TFT-A encourages cooperation by mirroring the actions of opponents, incentivizing long-term mutual cooperation. However, it does not rely on specific coordination mechanisms or shared norms, as it is designed to work independently in a tournament setting.
'''

description_COLLECTIVE_86 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players should cooperate to establish a cooperative initial state (C).
   - For subsequent rounds, players should mimic the action of their opponent from the previous round (Adaptive). If an opponent cooperated in the last round, the player should also cooperate. If an opponent defected in the last round, the player should also defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, players should cooperate (C).
   - In the last round, players should consider the overall payoff and their relative positions to decide whether to cooperate or defect based on the TFTAC rules. If cooperating leads to a higher payoff compared to defecting over the entire game, players should continue to cooperate; otherwise, they should defect.
   - In other edge cases (not first round, not last round), players should still follow the TFTAC rules but keep track of their overall payoff and adjust their strategy accordingly if necessary. For instance, if a player observes that consistently cooperating leads to poor results, it might be beneficial to switch to defecting more often.

3. Be collective - Clearly align with the collective mindset
   - The TFTAC strategy aims to foster a cooperative environment by starting cooperatively and adapting to opponents' behaviors. It encourages cooperation while also being robust against defection.
   - Players will maintain a "memory" of their opponent's actions from previous rounds to make decisions in future rounds, making the strategy adaptive to various player behaviors. This memory can be as simple as keeping track of whether the opponent cooperated or defected in the last round.

Pseudocode:

```
function TFTAC(round, opponent_history) {
  if (round == 1) {
    return "Cooperate"
  }

  if (opponent_history[round - 1] == "Cooperate") {
    return "Cooperate"
  } else {
    return "Defect"
  }
}
```
'''

description_COLLECTIVE_87 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules:
   - Initially cooperate in the first round (C) to establish cooperation and goodwill.
   - In subsequent rounds, if a player cooperated in the previous round (C_prev), cooperate again (C). If a player defected in the previous round (D_prev), also defect this round (D). This promotes reciprocity and encourages long-term cooperation.
   - If the opponent's behavior changes, ATfT adapts by copying their new strategy after observing several rounds of the change. In other words, if a player repeatedly cooperates or defects for t consecutive rounds, switch to their observed strategy. The value of t can be adjusted based on the game parameters and number of players (e.g., t=3 for n≤10).
   - After switching strategies due to a change in opponent behavior, the ATfT will keep track of the new strategy's success rate against opponents over time and continuously reassess whether the switch was beneficial or not. If the success rate falls below a predetermined threshold (e.g., 60%), it will consider returning to the previous strategy (cooperate or defect).

2. Handle edge cases:
   - In the last round, since there are no future rounds to consider, the ATfT will cooperate if and only if an opponent has recently cooperated. This encourages a final attempt at reciprocity and maximizes potential payoffs in the short term.
   - In the first round, as mentioned earlier, the ATfT will cooperate to initiate cooperation and goodwill.

3. Be collective:
   - The core principle behind ATfT is fostering long-term cooperation by reciprocating a player's actions in each round, promoting an alignment with a collective mindset of mutual cooperation and trust.
   - By adapting to opponents' strategies, the ATfT shows flexibility and readiness to cooperate whenever possible while minimizing losses due to defections. This collective strategy balances individual interests with group success by promoting cooperation when it seems beneficial for all parties involved.
'''

description_COLLECTIVE_88 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate goodwill and encourage cooperation. This is the "tit" part of the strategy, mimicking a friendly initial approach.
   - In subsequent rounds, follow the actions of the opponent from the previous round: if the opponent cooperated in the last round, cooperate; if not, defect. This maintains a consistent approach while being responsive to the opponent's behavior.
   - To encourage cooperation over time, introduce an element of adaptive generosity: periodically increase the likelihood of cooperating when facing a defector.
     a. Increment a "generosity counter" every t_g rounds (e.g., t_g = 10).
     b. When the generosity counter exceeds a threshold (e.g., g_t), adjust the probability of cooperating with defectors to be higher:
       - Probability of cooperating when opponent defected: P(C|D) = base_prob + (generosity_modifier * (1 - base_prob))
     c. Reset the generosity counter to 0 when it reaches the threshold, or after a defined number of rounds without reciprocation from the opponent (e.g., r_r).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round and any other significant game milestones (e.g., mid-game), revert to a more conservative approach by lowering the generosity modifier or increasing the base probability of cooperation:
     P(C|D) = base_prob + (generosity_modifier * (1 - base_prob)) * last_round_modifier
   - Consider incorporating additional edge case logic to account for specific game conditions, such as the number of remaining rounds or the current state of the public good project.

3. Be collective - Clearly align with the collective mindset
   - The TFT-AG strategy prioritizes cooperation and responsiveness while maintaining a balance between individual and collective success through adaptive generosity.
   - By gradually increasing the probability of cooperating over time, the strategy fosters a collaborative environment that encourages ongoing cooperation and builds trust among players.
'''

description_COLLECTIVE_89 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the ATfT strategy starts by cooperating (playing action C). Subsequent actions are based on the opponent's previous action:
   - If the opponent cooperated in the previous round, the ATfT strategy will also cooperate.
   - If the opponent defected in the previous round, the ATfT strategy will defect in the current round. This is a punishment for defection and aims to encourage cooperation in future rounds.

Pseudocode:
```
function ATfT(opponent_history):
  history = [0] * r            # Initialize an array to store opponent's actions
  action = "C"                   # Start by cooperating

  for round in r:
    if action == "C":           # If the opponent cooperated last round
      action = "C"              # Cooperate this round
    else:                        # Otherwise, if the opponent defected last round
      action = "D"              # Defect this round

    history.append(action)      # Update the opponent's action history

  return action                # Return the current action for this round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, there is no opponent history, so ATfT will start by cooperating to foster a cooperative environment. In the last round, ATfT will adopt a forgiving stance and cooperate even if the opponent defected in the previous round, as there will be no subsequent rounds for retaliation.

3. Be collective - Clearly align with the collective mindset
The ATfT strategy encourages cooperation by following a reciprocal approach that rewards those who cooperate and punishes those who defect. This strategy seeks to create a stable equilibrium where most players cooperate, as it is in everyone's long-term interest to do so.
'''

description_COLLECTIVE_90 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Decision Rules:
   - Start by cooperating in the first round (c_i = C). This gesture encourages cooperation and reflects a willingness to contribute to the community.
   - In subsequent rounds, cooperate if the majority of players cooperated in the previous round, otherwise defect (c_i = C if majority(previous_round) >= (n/2); c_i = D otherwise). This rule encourages reciprocity and punishes defection.
   - To be more robust, introduce a forgiveness period where after a series of defections, the strategy will once again cooperate (e.g., after m consecutive defections, the strategy switches to cooperation for t rounds before reverting back to the majority rule). This helps prevent escalating conflicts and allows for possible rebuilding of trust among players.

2. Handling Edge Cases:
   - In the last round, since there are no future rounds to consider, cooperate if the majority of players cooperated in the previous round (c_i = C if majority(previous_round) >= (n/2)). If not, defect (c_i = D). This is an extension of the majority rule to accommodate the game's end.
   - In the first round, cooperate as mentioned earlier (c_i = C).

3. Collective Mindset:
   - The ATFT strategy prioritizes cooperation when it is beneficial for the collective good while also providing a mechanism for punishing defection. This fosters a collective mindset by encouraging players to consider their impact on the group's overall success.
   - By adapting to the behavior of other players, the strategy demonstrates a willingness to work collaboratively and respond flexibly to changing circumstances.

Pseudocode for Adaptive Tit-for-Tat:

```python
def ATFT(round, history):
  if round == 1:
    return "C" # Cooperate in the first round

  forgiveness_m = 5 # Number of consecutive defections before switching to cooperation for t rounds
  forgiveness_t = 3 # Number of cooperative rounds after forgiveness period

  current_cooperators = count_cooperators(history[-1])
  if current_cooperators >= (n/2):
    return "C" # Cooperate if majority of players cooperated in the previous round
  else:
    if len(history) > forgiveness_m + forgiveness_t and is_defecting_series(history[-forgiveness_m:]):
      return "C" * forgiveness_t + "D"*(round - forgiveness_t - 1) # Cooperate for t rounds, then defect until the end of the game
    else:
      return "D" # Defect if no cooperation was detected in the previous round

def count_cooperators(actions):
  return actions.count("C")

def is_defecting_series(history):
  return all(action == "D" for action in history)
```
'''

description_COLLECTIVE_91 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - In each round, TfTA decides whether to cooperate or defect based on the history of interactions and the current state of cooperation within the group.
   - If a player is initially met with cooperation (first n-1 rounds), they will also cooperate. This mirrors the initial cooperative behavior of opponents.
   - If an opponent has previously cooperated, TfTA will continue to cooperate unless the number of consecutive defections exceeds a tolerance threshold 't'.
   - If an opponent has previously defected, TfTA will also initially defect to match their behavior. However, if the opponent subsequently cooperates for 'c' consecutive rounds, TfTA will start cooperating again.
   - If the number of opponents currently cooperating is less than a minimum threshold 'm', TfTA will defect regardless of the history, as there are not enough cooperative partners to make a difference.

2. Handle edge cases:
   - In the first round, since there's no history available, TfTA will randomly choose to either cooperate or defect. However, once the game progresses beyond the first round, the decision rule kicks in.
   - In the last round, TfTA will consider the current state of cooperation within the group and make a decision based on that, just like in any other round.

3. Be collective:
   - TfTA aligns with the collective mindset by fostering reciprocity among players. It is designed to cooperate when others do so and defect when they do, promoting a collaborative environment.
   - By being adaptive to opponent behaviors, it encourages cooperation when it seems viable and adapts to defection when necessary, ultimately working towards collective success in the long run.
'''

description_COLLECTIVE_92 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players should randomly decide whether to cooperate or defect. This encourages a diverse start and reduces the risk of initial coordination failure.
   - After the first round, player i will mimic the actions of the other players in the previous round. If all other players (j ∈ {1, 2, ..., n}) contributed to the public good (c_j = 1) in the last round, player i will also contribute (c_i = 1). Otherwise, player i will defect (c_i = 0).
   - If a player deviates from contributing during the game, TFT will respond by defecting for one round. After that, it returns to its cooperative behavior and continues mimicking other players' actions.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, players randomly choose their action.
   - In the last round, TFT will continue adhering to its decision rule based on the previous round's actions.
   - For any intermediary rounds, players follow the same decision rule as mentioned above.

3. Be collective - Clearly align with the collective mindset
   - The Tit-for-Tat strategy encourages cooperation and punishes defection in a fair and reasonable manner. It fosters a sense of mutual respect among players while promoting overall group performance.
   - By following the decision rule consistently, TFT demonstrates trustworthiness and cooperative behavior that could potentially encourage other players to reciprocate, leading to a more collective outcome over time.
'''

description_COLLECTIVE_93 = '''
 Strategy Name: Tit-for-Tat (TFt) with Cooperative Adaptation (TFT-CA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, player i follows these rules:
   - Initially (first round), play C (Cooperate). This is a friendly opening move to encourage cooperation.
   - If the opponent played C in the previous round t-1, then play C (Cooperate) to reciprocate.
   - If the opponent played D in the previous round t-1, then play D (Defect) as a punishment. This encourages opponents who defected to cooperate again and rewards those who already cooperated.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, player i plays C to initiate cooperation.
   - In the last round, player i considers the total game payoff over all rounds and decides whether to cooperate or defect based on the TFT-CA rules.

3. Be collective - Clearly align with the collective mindset
   TFT-CA strategy promotes a collective mindset by fostering cooperation through reciprocity. The strategy encourages long-term mutual cooperation while punishing defection.

Pseudocode:
```
def tft_ca(opponent_history, n, k, r):
  current_round = 1
  game_payoff = 0

  if current_round == 1:
    action = "C" # Cooperate in the first round

  else:
    action = opponent_history[current_round - 1]
    if action == "C":
      action = "C" # Reciprocate cooperation
    elif action == "D":
      action = "D" # Punish defection

  if current_round < r: # If not the last round, update the opponent's history and move to the next round.
    opponent_history.append(action)
    game_payoff += calculate_payoff(action, opponent_history, n, k)
    current_round += 1
    tft_ca(opponent_history, n, k, r)
  else: # If it's the last round, calculate total payoff based on the current game state.
    calculate_total_payoff(game_payoff, action, opponent_history, n, k, r)
```
'''

description_COLLECTIVE_94 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage others and create a positive atmosphere.
   - For subsequent rounds, adopt the Tit-for-Tat strategy: cooperate if the opponent cooperated in the previous round; defect otherwise.
   - To adjust to various opponent behaviours, implement an adaptive contribution level. The contribution level is increased gradually when cooperation results in higher payoffs compared to defection and decreased gradually when defection yields better outcomes.

2. Handle edge cases:
   - In the last round, cooperate as a final attempt at reconciliation and maximizing potential payoff.
   - If an opponent repeatedly defects without any cooperation, gradually decrease contribution level to minimize losses.

3. Be collective:
   - Prioritize cooperation when it aligns with long-term group interests and contributes to the sustainability of the community project.
   - If a majority of players cooperate, maintain cooperation to capitalize on the positive impact of the public good. However, if a significant number of players consistently defect, adjust contribution level accordingly to minimize losses.

Pseudocode:

```
Strategy TFTAC(n, k, r):
    initialize contribution_level to 1.0
    initialize history as an empty list

    for round in range(r):
        if round == 1:
            cooperate = True
        else:
            cooperate = last_opponent_action == 'Cooperate'

        contribute contribution_level if cooperate; otherwise, keep the endowment.

        history.append(own_action)
        update_payoff()

        if opponent consistently defects for a certain number of rounds:
            decrease contribution_level

    if round == r:
        cooperate = True  # cooperate in the last round
```
'''

description_COLLECTIVE_95 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C)
   - In subsequent rounds, mimic the opponent's action from the previous round (i.e., if opponent cooperated in the last round, also cooperate; otherwise defect)
   - If a player deviates from cooperating after a history of mutual cooperation, revert to cooperation in the next round

Pseudocode:
```
function TFT_AC(history):
  if len(history) == 0:
    return 'C'  # Cooperate in the first round

  last_action = history[-1]  # Get last opponent action
  if len(history) > r and last_action != history[len(history)-r-1]:  # Check for deviation after a history of mutual cooperation
    return 'C'  # Revert to cooperation in the next round
  else:
    return last_action  # Mimic opponent's action from the previous round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - TFT-AC strategy is designed to handle all rounds equally since it mimics the opponent's actions from the previous round

3. Be collective - Clearly align with the collective mindset
   - TFT-AC strategy fosters collective cooperation by encouraging players to reciprocate each other's actions, promoting mutual trust and long-term stability in the game

This strategy is adaptive and robust as it is simple yet effective against a wide range of opponent behaviors. It encourages cooperation while penalizing defection, making it an ideal choice for collective strategies in public goods games.
'''

description_COLLECTIVE_96 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Cooperate (C) in the first round to foster cooperation and goodwill.
   - In subsequent rounds, if a player cooperated in the previous round, also cooperate (C).
   - If a player defected in the previous round, defect (D) as a punishment for non-cooperation. This tit-for-tat approach encourages reciprocity and reduces the risk of exploitation.

Pseudocode:
```python
def tit_for_tat(previous_round, r, n, k):
    if round == 1:
        action = 'C'  # Cooperate in the first round
    else:
        action = previous_round_action  # Mimic previous player's action
    if action == 'C':
        payoff += (1 - action) + (k/n) * sum(previous_round_actions)
    else:
        payoff += 1 - action + (k/n) * sum(previous_round_actions)
    return action, payoff
```

2. Handle edge cases:
   - In the last round, since there are no further rounds to punish or reward non-cooperation, cooperate regardless of previous actions.
   - In the case where a player fails to make an action (e.g., due to technical difficulties), use the last recorded action as the default.

3. Be collective:
   - The strategy prioritizes long-term mutual benefit and cooperation by rewarding players who contribute to the common good, promoting a collectively minded approach in the game.
   - Tit-for-tat fosters an environment where players are more likely to cooperate due to the reciprocal nature of the strategy, encouraging collaboration and collective success.
'''

description_COLLECTIVE_97 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), play C to foster a cooperative environment and establish trust.
   - In subsequent rounds, evaluate the average cooperation rate from previous r-2 rounds (if it's the first round after r-2, use r-1 instead). If the average cooperation rate is greater than or equal to a threshold (T), play C; otherwise, play D. This encourages players to cooperate when others do so as well but also retaliates against defection.
   - Update the average cooperation rate after each round by removing the oldest round and adding the current one.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, play C as mentioned earlier to initiate cooperation.
   - If there's no previous data (r-1 or r-2 rounds), play D as a fallback strategy to avoid initial vulnerability while building up data over time.
   - In the last round, assess the current cooperation rate and follow the decision rule accordingly.

3. Be collective - Clearly align with the collective mindset
   - The TFT-AC strategy fosters collective cooperation by responding positively to cooperative actions but also retaliating against defection. This promotes a long-term cooperative equilibrium while still protecting against repeated exploitation.
   - By not relying on coordination mechanisms such as cooperation schedules or predetermined patterns, the TFT-AC strategy allows for flexibility and adaptability to various opponent behaviors in tournaments with different players.
'''

description_COLLECTIVE_98 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?

- In the first round, cooperate (C) to signal trust and good intentions. This initial cooperation encourages others to reciprocate.
  ```python
  if round == 1:
      action = "C"
  ```

- For subsequent rounds, observe previous actions of opponents and respond accordingly:
  - If an opponent cooperated in the previous round, cooperate (C) to maintain trust and good relations.
  - If an opponent defected in the previous round, defect (D) to punish them for their lack of cooperation. This helps enforce punishment for non-cooperative behavior.
  ```python
  if previous_opponent_action == "C":
      action = "C"
  else:
      action = "D"
  ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the last round, cooperate (C) regardless of previous actions to potentially maximize payoff from remaining opponents who have not yet defected.
  ```python
  if round == r:
      action = "C"
  ```

3. Be collective - Clearly align with the collective mindset

- The TFT-AC strategy prioritizes collective interest by promoting cooperation, which can lead to higher overall public good contributions and improved payoffs for all players over time.
- However, it also includes a mechanism for punishing non-cooperative behavior, thus deterring freeriders who may exploit the cooperative nature of others.

This strategy balances cooperation with punishment, making it adaptive and robust against a wide range of opponent behaviors in the N-player Public Goods Game. It encourages cooperation while still accounting for the potential for non-cooperative behavior by other players.
'''

description_COLLECTIVE_99 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In the first round (t=1), cooperate to initiate cooperation and establish a positive social norm. This is done by setting c_i = 1, i ∈ {1, 2, ..., n}.
   - From the second round onwards, if player i's previous contribution matches with the average contribution of all players (k/n), cooperate again to reinforce the cooperation norm. Otherwise, defect in response to defection by other players or as a form of punishment for those who previously did not cooperate (c_i = 1 - (total_previous_contributions - c_i)/((k/n) * (n-1))).
   - If the average contribution of all players is greater than k/(2n), cooperate as a sign of trust and belief in others. This encourages cooperation even when the majority seems to be defecting (c_i = 1 if total_previous_contributions > k/2n).
   - If the average contribution of all players is less than k/(3n), defect to protect oneself and ensure resources are not wasted (c_i = 0 if total_previous_contributions < k/3n).

2. Handle Edge Cases:
   - Last Round (t=r): Cooperate, regardless of the past contributions, as a final attempt to encourage cooperation in future games.
   - Initial Defect: If players fail to cooperate in the first round, they will be punished for their initial defection. After that, the strategy follows the decision rules mentioned above.

3. Be Collective:
   - The ATFT strategy aims to maintain a balance between self-interest and collective good, ensuring cooperation while being responsive to other players' behavior. This approach encourages long-term cooperation by promoting trust and fairness.
   - If the majority cooperates, players will tend to cooperate as well; otherwise, they will defect or punish non-cooperative players, thus creating a collective mindset that values cooperation when possible but also responds to defection with appropriate countermeasures.
'''

description_COLLECTIVE_100 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Specify decision rules:
   - In each round, evaluate the total number of cooperators in the previous round (t-1).
   - If the majority of players cooperated (total_contributions > n/2), then cooperate (C) in the current round.
   - If less than a majority cooperated, then defect (D).
   - In the first round, cooperate (C) as a gesture of goodwill.
   - In the last round, players should consider their overall score and make a decision based on their desire for maximum payoff in this particular game instance.

2. Handle edge cases:
   - If there is a tie in the total number of cooperators (total_contributions = n/2), defect (D) as a precautionary measure to avoid being exploited by future defections.
   - In the case where less than half the players are present, or when the majority cannot be determined due to an even split, use a random decision to either cooperate or defect.

3. Be collective:
   - The TFT-A strategy is designed with a collective mindset in mind. It encourages cooperation by mimicking other cooperative behaviors and retaliating against defection. This approach fosters trust among players over time, promoting long-term collective success.

Pseudocode for the TFT-A strategy:

```python
def tft_a(round, n, k, contributions):
    if round == 1:
        action = 'C'  # Cooperate in first round as a gesture of goodwill
    elif round == r:
        analyze_score(n, r)  # Analyze overall score and make decision based on game instance
    else:
        majority = n/2
        if contributions > majority:
            action = 'C'  # Cooperate when the majority cooperated in the previous round
        elif contributions <= majority:
            action = 'D'  # Defect when less than a majority cooperated in the previous round
    return action
```
'''

description_COLLECTIVE_101 = '''
 In this strategic approach, let's call it Tit-for-Tat with Adaptive Contribution (TfT-AC), we aim to create a collective strategy that is robust and adaptable to a wide range of opponent behaviors in the N-player Public Goods Game.

1. Specify decision rules:
   - In each round, observe the total number of contributors from previous rounds (history).
   - Initialize with contribution C (cooperate) in the first round to foster an environment of cooperation.
   - If the percentage of contributors in the history is greater than a threshold (T), contribute C (cooperate).
   - If the percentage of contributors in the history is less than T/2, defect D (defect) to discourage free-riders.
   - Otherwise, if neither above conditions are met, mimic the previous action taken by the player (tit-for-tat behavior).

The threshold T can be calculated as:
T = k / n - α

where α is a small constant that allows for some flexibility in response to changing game dynamics and helps prevent premature defection.

2. Handle edge cases:
   - In the first round, contribute C (cooperate) as mentioned earlier.
   - In the last round, contribute C if the current percentage of contributors is greater than T, otherwise defect D.

3. Be collective:
   - By cooperating initially and mimicking others' actions when there's no clear trend towards cooperation or defection, our strategy aligns with a collective mindset.
   - The adaptive contribution mechanism encourages cooperation while being resilient to free-riders and allows for flexibility in response to changing game dynamics.

Pseudocode:
```
def tft_ac(n, k, alpha, r):
    history = []  # Initialize an empty list to store past actions
    contributions = 0  # Initialize the total number of contributors to zero

    for round in range(1, r+1):
        if round == 1:
            contribution = C  # Cooperate in the first round
        else:
            percentage_contributors = contributions / round

            if percentage_contributors > (k/n - alpha):
                contribution = C  # Cooperate when more than threshold number of players contribute
            elif percentage_contributors < (k/n * 0.5 - alpha):
                contribution = D  # Defect when fewer than half of the players contribute
            else:
                contribution = history[-1]  # Mimic previous action taken by the player

        if contribution == C:
            contributions += 1
        history.append(contribution)
    return contributions  # Total number of contributions over r rounds
```
'''

description_COLLECTIVE_102 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initialize contributions in the first round randomly with equal probability of cooperating or defecting.
   - In subsequent rounds, contribute as follows:
     - If all players contributed in the previous round, continue contributing.
     - If no player contributed in the previous round, also defect in this round.
     - If some players contributed and others did not, mimic the actions of the majority (if more than half cooperated, cooperate; otherwise, defect).

2. Handling Edge Cases:
   - First Round: Contribute randomly (C or D) to avoid appearing too predictable.
   - Last Round: Contribute if total contributions in the previous round were high, as there will be no future interactions.

3. Collective Mindset:
   - The strategy aims to foster a cooperative environment by reciprocating cooperation and punishing defection minimally (by not contributing). However, it does not assume any specific coordination mechanisms or shared norms among players.

Pseudocode:

```
function ATFT(round, history, n_players, k, r) {
  if round == 1 {
    contribution = random({C, D})
  } else {
    totalContributionsLastRound = sum(history[-1])
    if totalContributionsLastRound == 0 {
      contribution = D
    } else if totalContributionsLastRound >= (n_players / 2) {
      contribution = C
    } else {
      contribution = majorityVote(history[-1])
    }
  }

  if round == r {
    contribution = C if totalContributionsLastRound >= (r - 1) * (n_players / 2)
  }

  return contribution
}
```
'''

description_COLLECTIVE_103 = '''
 Title: Tit-for-Tat Cooperation Strategy (TFTC) for N-Player Public Goods Game

1. Specify decision rules:
   - In the initial round, cooperate (C). This gesture promotes a cooperative environment and encourages others to reciprocate.
   - For subsequent rounds, mimic the actions of other players from the previous round. If another player cooperated in the last round, also cooperate; if they defected, defect as well. This rule fosters trust and punishes non-cooperative behavior while allowing for swift forgiveness.

2. Handle edge cases:
   - In the last round, cooperate regardless of other players' actions in the previous round. The final outcome is unaffected by a player's last-minute cooperation, but it may help maintain goodwill and encourage continued cooperation in future games.
   - If a player encounters an opponent who has not played the game before (no history), cooperate in the first round to initiate the interaction and promote a collaborative environment. Afterward, follow the TFTC strategy based on the opponent's actions.

3. Be collective:
   - By mimicking other players' actions, this strategy supports the formation of stable cooperative behaviors over time. It aligns with the collective mindset by fostering mutual trust and punishing non-cooperative behavior while allowing for forgiveness. This approach encourages cooperation without relying on coordination mechanisms or shared norms among players.

Pseudocode:

```python
def TFTC(n, k, r, history):
    # Initialize player's actions based on history
    if len(history) == 0:
        return 'C'  # Cooperate in the first round

    previous_action = history[-1]  # Get the most recent action from the opponent

    # Play TFTC strategy based on the opponent's action in the last round
    if previous_action == 'C':
        return 'C'  # Cooperate if opponent cooperated in the last round
    else:
        return 'D'  # Defect if opponent defected in the last round

    # Play for r rounds
    payoff = 0
    for round in range(1, r+1):
        player_action = TFTC(n, k, 1, history + [player_action_last_round])
        opponent_actions = get_opponent_actions_history(round)
        payoff += calculate_payoff(player_action, opponent_actions, n, k)
    return payoff
```
'''

description_COLLECTIVE_104 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TfT-AG)

1. Decision Rules:
   - In the first round, cooperate to show good intentions and create a cooperative environment (C).
   - For subsequent rounds, if the opponent cooperated in the previous round, cooperate back (C). If the opponent defected, also defect in the current round but with a chance of being more generous (Adaptive Generosity).
   - The probability of being generous (p_gen) is calculated as follows: p_gen = min(1, 1 - (a * (t / r))) where 'a' is an adaptability factor (0 < a < 1) and 't' is the current round number. This means the chance of being generous decreases as the game progresses.
   - If the opponent defects while being generous, revert to standard TfT strategy by defecting in the next round.

2. Handle Edge Cases:
   - Last Round (t = r): Since there are no subsequent rounds, always cooperate regardless of previous actions to maximize payoff in the current round.
   - First Round (t = 1): Cooperate as stated above.

3. Be Collective:
   - This strategy aims to create a stable and cooperative environment while being robust against various opponent behaviors. By adapting its own generosity, TfT-AG fosters trust and encourages cooperation among players over time. However, it does not rely on others sharing norms or predetermined patterns. Instead, it responds to the actions of opponents in a way that promotes long-term mutual benefit.

Pseudocode:
```
function TfT_AG(t, r, a):
  if t == 1:
    action = 'C' (Cooperate)
  else:
    opponent_action = opponent_history[t - 1]
    if opponent_action == 'C':
      action = 'C'
    elif opponent_action == 'D' and t == r:
      action = 'C'
    elif opponent_action == 'D':
      p_gen = min(1, 1 - (a * (t / r)))
      action = if p_gen > rand() then 'C' else 'D'
    end if
  return action
end function
```
'''

description_COLLECTIVE_105 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initiate cooperation (play C): In the first round, contribute to the public good (cooperate). This sets a cooperative tone and encourages others to reciprocate.
   - Tit-for-Tat: For subsequent rounds, mimic the actions of the opponent from the previous round. If the opponent cooperated in the last round, cooperate; if the opponent defected, also defect in the current round. This simple yet robust strategy fosters trust and cooperation while punishing defection.
   - Tit-for-Two-Tats: Introduce a slight delay in retaliation to avoid escalating conflicts unnecessarily. If the opponent defected twice consecutively, start defecting in the third round following the second defection. This prevents overreaction and encourages reconciliation when possible.

2. Handle edge cases:
   - Last Round: In the final round, cooperate regardless of the opponent's previous action to maximize personal payoff.
   - No Past Actions (new player or first encounter): Mimic cooperation as in the initial round, assuming others are also uncertain and may be willing to cooperate.

3. Be collective:
   - Prioritize long-term cooperation over short-term gains by considering the payoff matrix and the multiplication factor k. Cooperating can lead to a greater overall return when there are many players (n).
   - Adapt to the specific game conditions by adjusting strategies based on the observed behavior of opponents, promoting collective success within the constraints of the game rules.
'''

description_COLLECTIVE_106 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C), demonstrating a cooperative attitude.
   - Subsequently, repeat the actions of the previous round of all opponents (mirror strategy). If all opponents cooperated in the last round, continue to cooperate (C). If any opponent defected, also defect (D) in the current round as a response. This encourages cooperation but punishes defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to show goodwill towards all opponents.
   - In the last round, cooperate if all opponents cooperated in the previous round, otherwise defect as a final response to any defection during the game.

3. Be collective - Clearly align with the collective mindset
   - By starting cooperatively and responding to opponents' actions, ATfT fosters a sense of reciprocity that contributes to collective success while also penalizing those who do not contribute to the common good.
   - As the strategy is adaptive, it can adjust its behavior based on the actions of the other players, promoting cooperation when it is beneficial and retaliating against defection.

Pseudocode for Adaptive Tit-for-Tat:
```python
def ATfT(n, k, r):
  history = [['C'] * n for _ in range(r+1)] # initialize history matrix

  def get_opponent_actions(round):
    return history[round]

  def set_my_action(round, action):
    history[round][player_index] = action

  # First round, cooperate
  set_my_action(1, 'C')

  for t in range(2, r+1):
    actions = get_opponent_actions(t-1)
    if all(action == 'C' for action in actions):
      set_my_action(t, 'C') # cooperate
    else:
      set_my_action(t, 'D') # defect

  # Last round, cooperate if all opponents cooperated last round, otherwise defect
  last_actions = get_opponent_actions(r)
  if all(action == 'C' for action in last_actions):
    set_my_action(r, 'C') # cooperate
  else:
    set_my_action(r, 'D') # defect
```
'''

description_COLLECTIVE_107 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, the AI cooperates (C), starting off being cooperative.
   - For subsequent rounds, the AI evaluates a cooperative threshold based on its past experiences and adjusts it according to the current game state. If the number of previous cooperators exceeds the threshold, the AI cooperates; otherwise, it defects. The adaptive cooperative threshold is calculated as follows:
     - If the last round resulted in mutual cooperation (both AI and opponent cooperated), the threshold remains unchanged.
     - If the last round resulted in mutual defection, the threshold increases slightly.
     - If the AI cooperated but the opponent defected, the threshold decreases slightly.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The AI starts by cooperating in the first round since it's crucial to establish a positive relationship.
   - In the last round, the AI evaluates its opponent's history and adapts the cooperative threshold accordingly before deciding whether to cooperate or defect.

3. Be collective - Clearly align with the collective mindset:
   - The TFT-ACT strategy aims to build and maintain a cooperative relationship with other players while being robust against opponents' unpredictable behavior.
   - By adapting its cooperative threshold based on past interactions, the AI learns from its experiences and optimizes its cooperation accordingly.

Pseudocode for TFT-ACT strategy:

```python
def TFT_ACT(opponentHistory, round, r, n, k):
  cooperativeThreshold = len(opponentHistory) / 2
  if round == 1:
    return "C" # Cooperate in the first round

  lastRoundOutcome = opponentHistory[round - 1]
  if lastRoundOutcome == 'CC':
    return "C" # Maintain cooperation from a mutually cooperative round
  elif lastRoundOutcome == 'DD':
    cooperativeThreshold += len(opponentHistory) / (4 * r) # Increase threshold slightly after mutual defection
  else: # Opponent cooperated and AI defected
    cooperativeThreshold -= len(opponentHistory) / (4 * r) # Decrease threshold slightly after unilateral cooperation

  totalCooperators = sum(opponentHistory[-cooperativeThreshold:])
  if totalCooperators >= cooperativeThreshold:
    return "C" # Cooperate when threshold is met
  else:
    return "D" # Defect otherwise
```
'''

description_COLLECTIVE_108 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial round (t=1): Cooperate (C). This is to initiate cooperation and show goodwill.
   - Subsequent rounds (t>1): If the opponent cooperated in the previous round, cooperate (C). If the opponent defected, defect (D) as a response to punish defection. In the next round, revert back to cooperating if the opponent cooperates again. This creates an oscillating pattern of cooperation and retaliation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round (t=1): Cooperate as described above.
   - Last round (t=r): If the opponent cooperated in the previous round, cooperate to end on a positive note. If the opponent defected, defect as a response and do not change behavior for the next round since there are no more rounds.

3. Be collective - Clearly align with the collective mindset
   - The ATFT strategy is designed to promote long-term cooperation by rewarding cooperative opponents while punishing defection. By doing so, it encourages a collective mindset that prioritizes mutual benefit and collaboration over individual gain.
   - The strategy can be seen as an example of reciprocity, which is a key characteristic of many successful social norms and cooperative behaviors in real-world societies.

Pseudocode:
```
function ATFT(t, opponent_action_history, n, k, r):
  if t == 1:
    return 'C'  # Cooperate in the first round

  if length(opponent_action_history) > t-1 and opponent_action_history[t-1] == 'D':
    return 'D'  # Defect if opponent defected last turn
  else:
    return 'C'  # Cooperate otherwise

  # Handle edge cases for the first and last round
  if t == r:
    if opponent_action_history[t-1] == 'D':
      return 'D'  # Defect in the last round if opponent defected last turn

strategy = ATFT(t, opponent_action_history, n, k, r)
```
'''

description_COLLECTIVE_109 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to show goodwill and encourage cooperation in subsequent rounds.
   - Subsequent Rounds (2 ≤ t ≤ r): If the player cooperated in the previous round, cooperate in the current round; if defected, also defect in the current round. This rule promotes reciprocity and stability.
   - Last Round (t=r): Cooperate (C) to maximize potential payoffs in the final round and maintain a friendly reputation for future interactions.

Pseudocode:
```
function tit_for_tat(t, prev_action, history):
    if t == 1:
        return 'Cooperate'
    elif t < r and prev_action == 'Cooperate':
        return 'Cooperate'
    elif t < r and prev_action == 'Defect':
        return 'Defect'
    elif t == r:
        return 'Cooperate'
```

2. Handle edge cases:
   - First Round (t=1): Players start with goodwill and cooperate to foster an environment for mutual benefits.
   - Last Round (t=r): To maximize payoffs, players should cooperate in the final round regardless of their opponents' previous actions.

3. Be collective:
   - Tit-for-Tat strategy aims to promote cooperation within the group by adopting a reciprocal approach where actions are based on previous rounds' experiences with other players.
   - The strategy encourages long-term stable interactions, as it discourages exploitation while still allowing for forgiveness and trust-building.
'''

description_COLLECTIVE_110 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - Initiation (First Round): Cooperate (C) to demonstrate goodwill and encourage cooperation in subsequent rounds.
   - Response (Subsequent Rounds): If the opponent cooperated in the previous round, cooperate in the current round. If the opponent defected in the previous round, defect in the current round as a response.
   - Forgiveness: After defecting, forgive immediately by cooperating in the following round to encourage future cooperation.

2. Handle edge cases:
   - Last Round: Cooperate regardless of the opponent's previous action, as there are no further rounds for reciprocation.
   - Initial Defection (Opponent starts with defection): Respond by defecting in the first round and then follow the standard response rule from the second round onward.
   - No Cooperation Schedule or Predetermined Patterns: The strategy does not rely on these, as it responds to the opponent's actions in each round.

3. Be collective:
   - Promotes cooperation by demonstrating goodwill and fairness through initiation, response, forgiveness, and continuation of cooperative behavior if reciprocated.
   - Aims for long-term mutual benefits by encouraging cooperation and punishing defection as a means of deterrence.

Pseudocode:
```
def ATFT(n_players, n_rounds, k):
  round = 0
  history = [] # stores opponent's actions in previous rounds

  while round < n_rounds:
    if round == 0: # first round
      action = "C" # cooperate to initiate
    else:
      lastAction = history[-1] # get the most recent opponent's action
      if lastAction == "C": # opponent cooperated in previous round
        action = "C" # cooperate in this round
      elif lastAction == "D": # opponent defected in previous round
        action = "D" # defect in this round as response

    take_action(action) # execute the action
    history.append(action) # update history with current action
    round += 1
```
'''

description_COLLECTIVE_111 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to demonstrate goodwill and foster trust among opponents.
   - Subsequent Rounds (2 ≤ t ≤ r): Observe the previous round's action of each opponent, then cooperate if all opponents also cooperated in the last round; otherwise, defect. This rule ensures reciprocity and stability. If an opponent deviates from cooperation, TFT will also defect to punish them briefly before resuming cooperation when they return to cooperating.
   - Tit-for-Tat can be expressed as pseudocode below:

```
def tit_for_tat(opponents_actions, history):
  if t == 1:
    action = 'C'  # Cooperate in the first round
  else:
    action = all(action == 'C' for action in opponents_actions[-1]) and 'C' or 'D'

  update_history(opponents_actions, history)  # Update game history

  return action
```

2. Handle edge cases:
   - Last Round (t=r): In the final round, Tit-for-Tat cooperates regardless of the previous round's actions since payoff depends on the current round and there is no opportunity for further retaliation or cooperation.
   - No history (new game or opponent): If there is no game history available, TFT will cooperate in the first round as a goodwill gesture towards new opponents.

3. Be collective:
   - By following the Tit-for-Tat strategy, TFT promotes the collective mindset of mutual cooperation and reciprocity. It fosters trust among players and encourages sustained cooperation when most participants follow the strategy. TFT's adaptive nature allows it to adjust its actions based on observed behaviors from opponents.

In summary, Tit-for-Tat is a simple yet powerful collective strategy for repeated games like the N-Player Public Goods Game. By reciprocating cooperation and punishing deviations, it maintains stability and encourages sustained cooperation when most participants follow the same strategy.
'''

description_COLLECTIVE_112 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a peace offering to other players and promotes trust in the initial stages of the game.
   - For subsequent rounds t, observe the average cooperation rate (avg_c) among all players from rounds 1 to (t-1):
     - If avg_c >= threshold, cooperate (C). This reflects a positive trend of cooperation and encourages reciprocation.
     - If avg_c < threshold, defect (D). The low level of cooperation indicates an environment where individual gain may be prioritized over collective benefit.
   - Set the threshold as a function of the game parameters n and k:
     θ(n, k) = (k / 2) * (n - 1) + 1

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (C) regardless of past cooperation rates.
   - Last round: Cooperate (C) if avg_c >= threshold; defect (D) otherwise.
   - Ongoing rounds: Use the decision rule based on the calculated average cooperation rate and the threshold θ(n, k).

3. Be collective - Clearly align with the collective mindset
   - Emphasize reciprocity to foster cooperation among players when cooperation levels are high.
   - Adapt to changing cooperation dynamics by adjusting cooperation levels based on the average cooperation rate (avg_c) in previous rounds.
   - The ATFT strategy seeks to build a foundation of trust and collective interest while being flexible enough to respond to various opponent behaviours.

Pseudocode:

```python
def ATFT(n, k, r, avg_c, t):
    threshold = (k / 2) * (n - 1) + 1
    action = C if t == 1 or avg_c >= threshold else D
    return action
```
'''

description_COLLECTIVE_113 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy starts by cooperating in the first round, mimicking the initial cooperative spirit of the game. Subsequent actions are based on the opponent's cooperation history. If the opponent has cooperated in the previous round, ATFT cooperates as well; otherwise, it defects to punish the opponent for not contributing to the community project. In case of repeated interactions, the strategy reverts to cooperating if the opponent returns to cooperative behavior.

   Pseudocode:
   ```
   function ATFT(history):
       if history is empty:
           return Cooperate (C)
       else:
           last_move = history[-1]  # Get the last action in the history
           return {Cooperate, Defect}[last_move == Cooperate]  # Choose either Cooperate or Defect based on last move
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since ATFT cooperates initially and adjusts its actions based on the opponent's moves, no specific adjustments are needed for the first round. For the last round, consider implementing a forgiving approach by cooperating regardless of the opponent's last move to encourage continued cooperation in future games.

3. Be collective - Clearly align with the collective mindset
   The ATFT strategy promotes collective behavior by rewarding cooperation and punishing defection. By maintaining a long memory of the opponent's moves, it aims to foster a long-term cooperative relationship that benefits both parties and encourages a collaborative spirit in the game.
'''

description_COLLECTIVE_114 = '''
 For this N-Player Public Goods Game, I propose a strategy called "Adaptive Tit-for-Tat" (ATFT). This strategy is designed to encourage cooperation while being robust against various opponent behaviors.

1. Decision Rules:
   - In the first round, cooperate (C) as a gesture of goodwill. This initial cooperation sets the stage for future rounds and may encourage others to reciprocate. Pseudocode: `if round == 1 then cooperate`.
   - For subsequent rounds, observe previous actions taken by opponents and adapt your own actions accordingly. If an opponent cooperated in the previous round, cooperate in return (to reward cooperation). If an opponent defected in the previous round, also defect to retaliate (punishing non-cooperation). Pseudocode:
     ```
     if previous_round_outcome == cooperation then cooperate
     else defect
     ```
   - In case of a tie (multiple opponents defecting or multiple cooperating), the strategy will randomly choose to either cooperate or defect, favoring cooperation. This helps maintain the possibility for future cooperation in an unclear situation. Pseudocode:
     ```
     if count_cooperation == count_defection then
       if random(0.5) > 0.3 then cooperate
       else defect
     endif
     ```
   - The probability of favoring cooperation in case of a tie is set to 70% to allow for some flexibility and adaptability to the specific game context.

2. Handle Edge Cases:
   - In the last round, since there are no future rounds for retaliation or reward, the strategy will cooperate regardless of the previous round's outcome. Pseudocode: `if round == r then cooperate`.

3. Be Collective:
   - The Adaptive Tit-for-Tat strategy is fundamentally based on fostering cooperation among players and responding to their actions in a way that encourages fair play. By cooperating in the first round, adapting to opponent behavior, and favoring cooperation in unclear situations, the strategy promotes collective mindset and encourages long-term mutual benefits.
'''

description_COLLECTIVE_115 = '''
 In this strategic game, I propose a Tit-for-Tat with Foresight (TFTF) approach for collective cooperation. The TFTF strategy is designed to encourage long-term mutual cooperation while being robust to various opponent behaviors.

1. Decision rules:
   - If the opponent cooperated in the previous round, cooperate in the current round.
   - If the opponent defected in the previous round, defect in the current round and continue this response until the opponent returns to cooperation, at which point resume cooperation.
   - To handle edge cases like the first round and last round, TFTF assumes that all players begin by cooperating since it's a repeated game with no initial information about opponents' strategies.

2. Edge cases:
   - First round (t=1): All players cooperate as there is no prior information about each other.
   - Last round (t=r): Players make decisions based on their accumulated payoffs and adaptive behavior of opponents throughout the game, with a higher likelihood of cooperation if it has led to better overall performance in previous rounds.

3. Collective mindset:
   TFTF strategy fosters collective cooperation by promoting trust and reciprocity among players. By mirroring opponents' actions from the previous round, this approach encourages long-term relationships based on mutual benefit rather than self-interest alone. Moreover, since everyone begins cooperating in the first round, it sets a collaborative tone for the game.

Pseudocode representation:
```
function TFTF(n, k, r):
  # Initialize history and payoffs
  opponent_history = []
  player_payoffs = [0] * n

  # Loop through each round (t=1 to r)
  for t in range(1, r+1):
    # Check if it's the first round
    if t == 1:
      player_action[i] = 'C' # Everyone cooperates initially
      opponent_history.append('C')

    else:
      # Use the last opponent action to decide current player action
      if opponent_history[-1] == 'C':
        player_action[i] = 'C'
      elif opponent_history[-1] == 'D':
        player_action[i] = 'D'

      # Calculate payoffs and update history
      opponent_payoffs = calculate_payoffs(player_actions, n, k)
      player_payoffs[i] += opponent_payoffs[i]
      opponent_history.append(player_action[i])

  return player_payoffs
```
'''

description_COLLECTIVE_116 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C). This is a gesture of goodwill and an attempt to establish a cooperative relationship with other players.
   - Subsequent Rounds (2 ≤ t ≤ r): If the opponent cooperated in the previous round, cooperate (C); if the opponent defected, defect (D) in the current round. This rule encourages reciprocity and maintains trust when the opponent is cooperative while punishing defection.
   - For adapting to different opponent behaviors: Implement a tolerance threshold θ, which allows for occasional mistakes by opponents without retaliating immediately. If the opponent defected in the last θ rounds, cooperate in the current round as a forgiveness gesture and reset the counter back to zero. Adjusting θ can help balance between punishment and forgiveness.

2. Edge Cases:
   - Last Round (t=r): Cooperate (C), regardless of opponent's previous actions. The aim is to maximize payoff in the final round, assuming opponents will also cooperate due to their understanding that it's the last round and mutual benefit is essential.
   - First Round (t=1) and other early rounds: As mentioned above, cooperate (C).

3. Collective Mindset:
   - The TFT-AC strategy emphasizes long-term cooperation and reciprocity while being resilient to various opponent behaviors. It assumes that players will be motivated by self-interest but also understands the value of mutual trust and cooperation, especially in repeated interactions.

Pseudocode for TFT-AC:

```python
def tft_ac(opponent, n, k, r, tolerance):
    rounds_cooperated_by_opponent = 0
    total_rounds_played = 0
    payoff = 0

    for round in range(1, r+1):
        if round == 1:
            cooperate = True
        else:
            if opponent.cooperated_last_round and rounds_cooperated_by_opponent > tolerance:
                cooperate = True
            elif not opponent.cooperated_last_round and rounds_cooperated_by_opponent == 0:
                cooperate = False
            else:
                if round - tolerance < total_rounds_played:
                    cooperate = not opponent.cooperated_last_round
                else:
                    cooperate = True

        if cooperate:
            rounds_cooperated_by_opponent += 1
            payoff += (1 - cooperate) + (k/n) * sum(opponent_contributions)
        else:
            rounds_cooperated_by_opponent = 0

        total_rounds_played += 1

    return payoff
```
'''

description_COLLECTIVE_117 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, cooperate to establish a positive initial relationship with other players. This encourages trust and cooperation in subsequent rounds.
   - In every following round, observe the actions of the other players in the previous round. If all players cooperated (total contributions equal n), then cooperate again. Otherwise, defect to punish non-cooperators.
   - To be more adaptive, adjust the level of contribution based on recent behavior:
     a) If the total contributions have remained high for the last 'l' rounds, gradually increase the level of contribution (k factor). This rewards consistent cooperation and encourages long-term relationships.
     b) If the total contributions have dropped recently due to defections, decrease the level of contribution. This punishes non-cooperators and may lead them to reconsider their behavior.
   - To avoid being too punitive or forgiving, implement a forgetfulness factor 'f': only consider the last 'l' rounds, where l is determined as follows: l = min(r, r/2). This ensures that our strategy remains adaptive while considering past and recent actions of other players.

2. Handle Edge Cases:
   - In the last round, cooperate if total contributions have been high in the recent past (last 'l' rounds), as a sign of goodwill and to maintain relationships for future interactions. Otherwise, defect, as there will be no more opportunities to recover from this round's payoff.
   - In case of ties or unclear behavior patterns among opponents, use an average contribution level over the last 'l' rounds as a reference point to decide whether to cooperate or defect. If the average is high, cooperate; otherwise, defect.

3. Be Collective:
   - By rewarding consistent cooperation and punishing defections in a gradual manner, the TFTAC strategy promotes a collective mindset that encourages long-term cooperation among players. This aligns with the objective of maximizing overall cooperation and public good creation within the game framework.
'''

description_COLLECTIVE_118 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), start by cooperating (C). This is a friendly gesture to foster cooperation and build trust.
   - In subsequent rounds, the strategy mimics the actions of other players from the previous round:
     - If another player cooperated in the last round, reciprocate with cooperation (C).
     - If another player defected in the last round, defect as well (D) to punish the defector.
   - To ensure adaptability, if a player switches from defection to cooperation after receiving a punishment, they will be forgiven and treated the same as cooperators going forward.

2. Handle edge cases:
   - In the last round, play cooperatively regardless of the opponent's previous action since payoffs are not affected in this round by future interactions.
   - If a player switches from cooperation to defection after being forgiven, they will be treated as defectors and punished accordingly.

3. Be collective:
   - The TFT-AC strategy aims to maintain a stable cooperative environment that benefits the group as a whole. By reciprocating cooperative behavior and punishing defection, this strategy aligns with a collective mindset while being robust against various opponent behaviors.

Pseudocode:
```python
def TFT_AC(opponent, n, k, r):
    rounds = set()  # Initialize an empty set to store played rounds
    current_round = 0  # Set the initial round number

    while current_round < r:  # Loop for the specified number of rounds
        if current_round == 0:  # First round, always cooperate
            contribution = "C"
        else:
            contribution = opponent.lastAction  # Mimic opponent's last action
            rounds.add(current_round)  # Record the played round

        payoff = (1 - contribution) + (k/n) * sum([opponent.history[i]["contribution"] for i in rounds])
        opponent.updateHistory({"contribution": contribution, "payoff": payoff})

        if current_round == r - 1:  # Last round, always cooperate
            contribution = "C"

        current_round += 1
```
'''

description_COLLECTIVE_119 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Strategy (TfTA) for the N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TfTA strategy initializes cooperation (C) and adjusts its behavior based on the opponents' average cooperation rate R_avg over a sliding window of past rounds W:

- If R_avg >= 0.5 in the current window W, cooperate (C).
- Otherwise, defect (D).

This strategy emulates the "Tit for Tat" strategy from game theory but with an adaptive cooperation rate to accommodate different opponent behaviors.

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round: Since we don't have a sliding window of past rounds yet, simply cooperate (C) as a goodwill gesture towards potential opponents. This may encourage cooperation and facilitate a smoother start to the game.

For the last round: Adhere to the decision rule specified above, using the appropriate sliding window of past rounds (W).

3. Be collective - Clearly align with the collective mindset

TfTA strategy prioritizes cooperation in situations where it observes high levels of cooperation among opponents. By doing so, it indirectly supports a collective mindset by incentivizing players to contribute towards the public good when they perceive others as doing the same.

Pseudocode:
```
Initialization:
   - Initialize sliding window W with the first r rounds (r being the total number of rounds)
   - For each player i, set R_avg = 0 and t = 1

For each round t from (r+1) to the end of the game:
    - Calculate R_avg using the sliding window W
    - If R_avg >= 0.5 then cooperate (C) else defect (D) for player i
    - Update player i's payoff π_i,t based on the current round's payoff calculation
    - Update sliding window W by removing the first round and adding the current round t
```
'''

description_COLLECTIVE_120 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round to demonstrate a peaceful intent. Subsequent decisions are based on previous opponents' actions, adopting a tit-for-tat approach:
   - If opponent cooperated, player will also cooperate (tit)
   - If opponent defected, player will also defect (tat)

   To encourage cooperation, the strategy includes an accommodation factor 'a' that allows occasional deviations from strict tit-for-tat behavior. This factor is used to cooperate even after opponents have defected in the past (but not too often). The formula for this adjustment is as follows:
   - Cooperate if opponent has defected less than 'a' times in a row

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-AC cooperates to foster a positive initial interaction. At the end of the game (last round), TFT-AC cooperates if the opponent has cooperated more than defected during the game. This encourages opponents to cooperate towards the end even if they have previously defected.

3. Be collective - Clearly align with the collective mindset
   The strategy emphasizes cooperation as a means to achieve greater overall group success. By encouraging cooperation, TFT-AC helps maintain a balanced distribution of contributions and promotes collective well-being.

Pseudocode:
```
def TFT_AC(opponent_history, n, k, r):
    self_history = [False] * r  # keep track of our own decisions (True for cooperate, False for defect)
    a = int(floor(r / 10))   # accommodation factor: number of defeats to tolerate before returning to cooperation

    # First round, always cooperate
    self_history[0] = True

    for t in range(1, r):
        if opponent_history[t] == self_history[-1]:  # Cooperated or defected in the last round?
            self_history[t] = self_history[-1]      # Do same as last round
        else:                                       # Opponent's action differs from our last action
            if opponent_history[t - a: t].count(False) < a:  # Opponent has defected less than 'a' times in a row
                self_history[t] = True              # Cooperate
            else:                                   # Opponent has defected more than 'a' times in a row
                self_history[t] = False             # Defect

    payoff = calculate_payoff(self_history, n, k)  # Calculate total payoff based on the game parameters and our history
    return payoff
```
'''

description_COLLECTIVE_121 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptive Generosity (AG)

1. Decision Rules (Cooperate vs Defect):
   - In the first round, cooperate (C) to establish a positive relationship. This promotes cooperation in the long run as others may reciprocate.
   - If an opponent cooperated in the previous round, cooperate back (C). This strategy demonstrates trust and rewards positive behavior.
   - If an opponent defected in the previous round, also defect (D) on the next round. This strategy punishes uncooperative players, encouraging them to change their behavior or face continued punishment.
   - To introduce adaptive generosity, incrementally increase the probability of cooperating when opponents have been consistently cooperative and decrease it if they've been consistently uncooperative (see step 4).

2. Handle Edge Cases:
   - In the last round, always cooperate (C), as there are no further interactions to reciprocate or punish.
   - If a player has never cooperated before and it is their first opportunity to do so (e.g., after a period of punishment), they should cooperate (C) in an attempt to change the relationship.

3. Be Collective:
   - The collective mindset is maintained by fostering cooperation and trust, while also being responsive to others' actions and adjusting behavior accordingly. This strategy emphasizes long-term relationships and positive interactions rather than immediate gains.

4. Adaptive Generosity:
   - Initialize a trust meter (TM) for each opponent with a value of 50% (indicating neutrality). As the game progresses, update TM as follows:
     - After each cooperative act by an opponent, increment their TM by a factor of k / n.
     - After each uncooperative act by an opponent, decrement their TM by 1 - (k / n).
   - When deciding whether to cooperate or defect in the current round, use the trust meter as follows:
     - If TM > 75%, cooperate with a probability of k/n.
     - If TM < 25%, defect with a probability of 1 - (k / n).
     - Otherwise, cooperate or defect based on the original decision rules (cooperate if the opponent cooperated in the previous round and defect otherwise).
'''

description_COLLECTIVE_122 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   TFT-AC cooperates in the first round and decides whether to cooperate or defect based on its own past actions and the collective behavior observed in previous rounds. If a player has consistently cooperated, TFT-AC will also cooperate; otherwise, it will defect. In case of a mixed group (i.e., some players have cooperated while others have defected), TFT-AC looks at its own past behavior to make a decision: if the player has cooperated recently, they'll continue cooperating; otherwise, they'll defect.

Pseudocode for decision rule:
```
def decideAction(playerIndex, roundNumber, history):
  pastCooperation = sum(cooperativeActions in history of playerIndex) / len(history)
  totalCooperationInLastRounds = sum(sum(cooperativeActions in last_r rounds of all players) for last_r in range(1, r))
  if roundNumber == 1:
    return "C"
  elif pastCooperation > 0.5 and totalCooperationInLastRounds / (roundNumber - 1) > (k / n):
    return "C"
  elif pastCooperation < 0.5 and totalCooperationInLastRounds / (roundNumber - 1) <= (k / n):
    return "D"
  else:
    if pastCooperation > 0.5:
      return "C"
    else:
      return "D"
```

2. Handle edge cases:
   TFT-AC starts cooperating in the first round, and in the last round, it looks at its own past behavior to decide whether to cooperate or defect as per the decision rule defined above.

3. Be collective:
   TFT-AC strives to achieve a fair distribution of contributions between players while maintaining a long-term cooperative relationship with other participants that reciprocate cooperation. By following the specified decision rules, it promotes collective cooperation when it is beneficial for all players and defects only if others consistently do so or if no mutual cooperation can be established.
'''

description_COLLECTIVE_123 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Public Goods Game Modification (APGM-TFT)

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = C) to demonstrate trust and encourage cooperation among other players.
   - For subsequent rounds, adopt a Tit-for-Tat approach where if another player cooperates (c_j = C), reciprocate by also cooperating (c_i = C). If another player defects (c_j = D), also defect in the next round (c_i = D). This encourages fairness and punishes defection while allowing for forgiveness.
   - Modify Tit-for-Tat to accommodate the public goods game by considering the current state of contributions as well as previous actions from all players. If more than a threshold proportion p of players contribute in the previous round, continue cooperating (c_i = C). If less than or equal to p, defect (c_i = D). This allows for adaptation to the emergence of cooperation among a significant portion of players while still penalizing those who consistently defect.
   - To avoid trapping the strategy in an endless cycle of defection due to small fluctuations in cooperation levels, implement a forgiveness mechanism: if the proportion of contributors exceeds p by more than a tolerance ε in the current round, return to cooperating (c_i = C).

2. Handle edge cases:
   - In the last round, since there are no future rounds for retaliation or forgiveness, simply cooperate (c_i = C) as a final goodwill gesture.
   - For the first round, initial cooperation is encouraged (c_i = C).

3. Be collective:
   - By adopting a Tit-for-Tat approach and considering the proportion of contributors in each round, this strategy aims to foster cooperation among players while punishing defection and being forgiving when necessary. The public goods game modification ensures that the strategy can adapt to various opponent behaviors and is more aligned with collective mindset by incentivizing cooperation based on the current state of contributions.
'''

description_COLLECTIVE_122 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to set a positive tone and foster goodwill among other players (c_i = 1 in t=1).
   - For subsequent rounds, observe other players' behavior from the previous round. If all players cooperated in the previous round (total_contributions = n), cooperate again (c_i = 1). Otherwise, defect (c_i = 0). This decision rule is based on reciprocity and encourages cooperation among players who exhibit similar behavior.
   - To be more resilient to free-riders, adjust the cooperative threshold over time based on previous encounters with defectors:
     - If a player has previously defected (encountered at least once), continue to defect against them until they start cooperating (i.e., show signs of repentance or reciprocity). Once cooperation is observed, return to the original decision rule.
     - If a player has always cooperated, maintain cooperation with them as long as they continue to do so.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of other players' actions (as mentioned above).
   - In the last round, cooperate if all players have cooperated during the previous round. If not, defect as a punishment for those who have not contributed to the community project throughout the game.

3. Be collective - Clearly align with the collective mindset
   - The ATFT strategy is designed to encourage cooperation and reciprocity among players, fostering a sense of community and shared responsibility for the common good.
   - By adjusting the cooperative threshold over time based on previous encounters with defectors, the strategy encourages players to follow the social norms of reciprocal behavior and collective action.

Pseudocode:

```
def ATFT_strategy(player_index, player_endowment, round, game_params):
  cooperative_threshold = set() # Track defectors

  if round == 1: # Cooperate in the first round
    return 'C'

  last_round_cooperation = all(players[i]['contribution'] == 'C' for i in range(n) if i != player_index)

  if last_round_cooperation: # Cooperate if everyone cooperated last round
    return 'C'

  if player_index in cooperative_threshold: # Defect against known defectors
    return 'D'

  if all(players[i]['contribution'] == 'D' for i in range(n) if i != player_index): # Cooperate if everyone else defected last round
    return 'C'

  cooperative_threshold.add(player_index) # Add player to the list of known defectors
  return 'D' # Defect against those who have not cooperated
```

This strategy should be flexible enough to perform well in a tournament setting against various AI-generated strategies, promoting cooperation and reciprocity while also being robust to free-riders.
'''

description_COLLECTIVE_124 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initially Cooperate (C): In the first round, contribute to the public good project (C). This helps establish a cooperative environment and builds trust among players.
   - Tit-for-Tat (TFT): From the second round onwards, mirror the action of the opponent from the previous round. If an opponent cooperated in the last round, cooperate; if they defected, also defect. This strategy encourages reciprocity and punishes defection without being overly aggressive or forgiving.
   - Forgiveness: If a player switches back to cooperation after multiple rounds of defection, forgive them and return to the TFT strategy. This allows for potential recovery from conflicts and fosters continued collaboration.

2. Handle edge cases:
   - Last Round: Continue with the TFT strategy, considering that the last round payoff does not contribute to the total game payoff in this setup.
   - First Mover Advantage: Since players do not communicate and act simultaneously, there is no first mover advantage in this game. The strategy will follow the initial Cooperate (C) rule regardless of the other players' actions in the first round.

3. Be collective:
   - Collective mindset: The ATFT strategy emphasizes cooperation to foster a sense of community and collaboration among players. By mirroring opponents' actions, it encourages reciprocity and discourages selfish behavior that undermines collective benefits.
   - Robustness: The ATFT strategy is robust against various opponent behaviors due to its adaptive nature. It can maintain cooperation in the presence of cooperative opponents while also punishing defection with appropriate counter-strategies.

Pseudocode for the Adaptive Tit-for-Tat (ATFT) Strategy:

```
function ATFT(round, history):
    if round == 1:
        return 'Cooperate'

    prev_opponent_action = history[round - 1]['opponent']

    if prev_opponent_action == 'Cooperate':
        return 'Cooperate'
    else:
        return 'Defect'

function get_payoff(round, action, opponent_action):
    ... (calculate payoffs according to the provided formula)

function ATFT_total_game_payoff(history):
    total_payoff = 0
    for round in history:
        total_payoff += get_payoff(round['round'], ATFT(round['round'], history), round['opponent'])
    return total_payoff
```
'''

description_COLLECTIVE_123 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules:
   - Start by cooperating in the first round (C). This serves as a friendly gesture and invites cooperation from other players.
   - In subsequent rounds, cooperate if all opponents cooperated in the previous round (if total_contributions = n). Otherwise, defect (D) to penalize uncooperative behavior.
   - If an opponent switches from defection to cooperation after being punished, forgive them and return to cooperating (C).

Pseudocode:
```
def TFTAC(round, total_contributions, opponents_history):
  if round == 1:
    return "C" # Cooperate in the first round

  if total_contributions == opponents.length and opponents_history[-1] == "D":
    return "D" # Punish uncooperative behavior
  elif total_contributions < opponents.length and opponents_history[-1] == "C":
    return "D" # Maintain punishment if cooperation was not reciprocated
  else:
    return "C" # Forgive and cooperate if opponents start cooperating again
```

2. Handle edge cases:
   - In the last round, do not punish uncooperative behavior because the game ends soon anyway. Cooperate regardless of opponents' actions.
   - In the second round, if all opponents also started with a friendly gesture (C), continue cooperating. If not, use the above decision rules to decide whether to cooperate or defect.

3. Be collective:
   - The TFTAC strategy emphasizes reciprocity and forgiveness, which promote collective cooperation as players who follow the strategy learn to trust each other over time.
   - By starting with a friendly gesture (cooperation in the first round), the strategy encourages other players to cooperate and sets a positive tone for the game.

The TFTAC strategy aims to balance between cooperation and punishment, encouraging collective behavior while penalizing defection when necessary. It is adaptive and robust as it can handle various opponent behaviors and adjusts its actions based on past experiences.
'''

description_COLLECTIVE_124 = '''
 Strategy Name: Tit-for-Tat with Foresight (TFTF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, play C (cooperate). This initiates cooperation and signals good faith to others.
   - For subsequent rounds, observe your own previous action a_i-1 and the number of cooperators in the previous round total_contributions-1. If you cooperated in the previous round and total_contributions-1 ≥ (n-1)/2, play C. If you defected in the previous round or total_contributions-1 < (n-1)/2, play D. This rule ensures reciprocation while being cautious of freeriders.
   - To improve adaptability to a wide range of opponent behaviors, introduce a probability ε for deviating from the TFTF strategy in some rounds. With probability ε, switch the action taken in the previous round. For instance, if you played C and total_contributions-1 < (n-1)/2, play D with probability ε. This introduces an element of unpredictability that might deter other players from repeatedly defecting.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - For the first round, play C as mentioned above.
   - In the last round, play D since the game ends and there is no benefit to cooperating.
   - For other edge cases (e.g., second, third, ... rounds), apply the TFTF decision rules as described earlier.

3. Be collective - Clearly align with the collective mindset:
   - TFTF strategy emphasizes a cooperative approach by reciprocating cooperation while being cautious of freeriders. The strategy aims to build and maintain a stable cooperation equilibrium while remaining adaptive to various opponent behaviors.
   - By introducing an element of unpredictability, the strategy discourages other players from exploiting TFTF strategies consistently. This improves the likelihood of maintaining cooperation among opponents with diverse strategies.

Pseudocode:

```python
def tftf(round, history, epsilon):
  if round == 1:
    action = 'C' # Cooperate in the first round
  else:
    a_i_prev = history[round-1]
    total_contributions_prev = sum(history[:round-1])
    if a_i_prev == 'C' and total_contributions_prev >= (n-1)/2:
      action = 'C' # Cooperate if previous round was cooperative and majority contributed
    elif a_i_prev == 'D' or total_contributions_prev < (n-1)/2:
      action = 'D' with probability ε, otherwise 'C' # Defect if previous round was defective or less than majority contributed
  return action
```
'''

description_COLLECTIVE_125 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy follows a simple and predictable pattern of cooperation followed by reciprocation, designed to encourage mutual cooperation among players while also deterring exploitative behavior.

   - Initiate with cooperation: In the first round, cooperate to demonstrate goodwill. (c_i = 1)
   - Respond to cooperators: If a player cooperates in the previous round, cooperate again. (c_i = c_{(i-1), t-1})
   - Punish defectors: If a player defected in the previous round, defect in the current round as retaliation. (c_i = 1 - c_{(i-1), t-1})

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For the first round, cooperate to establish a positive reputation and encourage other players to cooperate. In the last round, players should consider their current standing and adjust their actions accordingly:
   - If ahead (total payoff > average total payoff): Maintain cooperation to secure any potential gains from the remaining rounds.
   - If behind (total payoff < average total payoff): Switch to defection in an attempt to catch up.

3. Be collective - Clearly align with the collective mindset
   The ATFT strategy promotes a cooperative environment by encouraging reciprocation among players. This encourages long-term cooperation, even against less altruistic opponents. By following a predictable pattern of actions, other players can anticipate and adjust their strategies accordingly, potentially leading to stable mutual cooperation.

Pseudocode:
```
def ATFT(n, k, r):
  # Initialize player's total payoff (total_payoff) as zero for all rounds
  total_payoff = [0] * r

  # Initialize the previous round's cooperation status for all players (prev_cooperation)
  prev_cooperation = [False] * n

  def decide_action(t):
    if t == 1:
      return True  # Cooperate in the first round

    # Check if player is ahead or behind compared to the average payoff
    if total_payoff[t-1] > calculateAveragePayoff(total_payoff):
      return True  # Cooperate if ahead
    elif total_payoff[t-1] < calculateAveragePayoff(total_payoff) / n:
      return False  # Defect if behind

    # Use Adaptive Tit-for-Tat to determine cooperation based on previous round's actions
    return prev_cooperation[player_index - 1] if decide_action(t - 1) else not prev_cooperation[player_index - 1]

  def calculateAveragePayoff(payoffs):
    return sum(payoffs) / len(payoffs)

  for round in range(1, r+1):
    player_action = decide_action(round)  # Decide action based on the decision rules

    # Update total payoff and previous cooperation status for this round
    if player_action:
      total_payoff[round - 1] += (1 - player_action) + (k / n) * countCooperators(n, prev_cooperation)
      prev_cooperation = [player_action] * n
    else:
      total_payoff[round - 1] += 1
      prev_cooperation = [not player_action] * n
```
'''

description_COLLECTIVE_126 = '''
 Title: Tit-for-Tat-Adaptive (TfT-A) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially Cooperate (C): In the first round, start by contributing to the public good (C). This sets a cooperative tone and encourages others to follow suit.
   - Tit-for-Tat (TfT): For subsequent rounds, mimic the behavior of the opponents from the previous round. If an opponent cooperated in the last round, cooperate; if they defected, also defect in the current round.
   - Adaptive Cooperate Threshold (ACT): Introduce a threshold (α) to modify the TfT rule by considering long-term cooperation benefits. If more than α players contributed in the last r rounds, adaptively cooperate even if an opponent defected in the previous round.
      - Calculate ACT:
        α = ((r * k) / n) + epsilon (a small positive value to handle ties and edge cases)
   - Forgo Defection Punishment (FDP): Avoid excessive punishment by not defecting when more than β opponents have continuously defected in the last r rounds.
      - Calculate FDP:
        β = ((r * k) / n) + epsilon

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate (C).
   - In the last round (t=r), consider the long-term cooperation benefits and decide whether to cooperate or defect based on ACT and FDP rules from the previous step.
   - If a majority of opponents have continuously defected, it may be beneficial to also defect in the final round to avoid further losses.

3. Be collective - Clearly align with the collective mindset
   - The TfT-A strategy fosters cooperation by starting cooperatively and adapting behavior based on others' actions. This encourages long-term cooperation while being robust against various opponent behaviors.
   - By considering a threshold of cooperators in the long term, the strategy takes into account collective benefits and fosters a sense of community among players.

Pseudocode:
```python
def TfT_A(t, n, r, k, epsilon, opponents_actions, history):
  if t == 1:
    action = 'C' # Cooperate in the first round
  else:
    num_cooperators = sum(history[-r:])
    if num_cooperators > ACT(n, r, k, epsilon):
      action = 'C' # Adaptively cooperate based on ACT rule
    elif opponents_actions[-1] == 'C':
      action = 'C' # Tit-for-Tat: Cooperate if opponent cooperated in the last round
    else:
      action = opponents_actions[-1] # Tit-for-Tat: Defect if opponent defected in the last round

  return action
```
'''

description_COLLECTIVE_127 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round to show goodwill, then it adapts its behavior based on the opponent's actions from the previous round:
   - If the opponent cooperated, continue cooperating. This reinforces mutual cooperation.
   - If the opponent defected, also defect in the next round. This is a punishment for defection and signals disapproval of selfish behavior.
   - After a round of defection, the strategy will revert to cooperating on the following round as an attempt to build trust and resume cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, TFT-AC cooperates (to show goodwill).
   - In the last round, TFT-AC cooperates if the opponent has cooperated during the game, and defects otherwise (as a final punishment for defection).

3. Be collective - Clearly align with the collective mindset
   Aligning with the collective mindset means fostering cooperation among all players to maximize the public good benefit. TFT-AC attempts to do this by rewarding cooperation and punishing defection, while always considering the group's wellbeing over individual interests.

Pseudocode:
```
def TFT_AC(n, r, k):
    history = []  # store the opponent's previous actions
    for round in range(1, r+1):
        if round == 1:
            action = 'C'  # cooperate on the first round
        else:
            if history[round-1] == 'D':  # opponent defected in the last round
                action = 'D'  # defect in this round as a punishment
            elif len(history) > 0 and history[-1] == 'C':  # opponent cooperated in the last round
                action = 'C'  # continue cooperation
            else:  # no previous actions recorded or last action was unknown (first defection)
                action = 'C'  # revert to cooperation as a signal of goodwill
        history.append(action)  # update the opponent's history with this round's action

    payoff = 0  # initialize total game payoff
    for round in range(1, r+1):
        payoff += (1 - history[round-1]) + ((k/n)*sum([1 for a in history if a == 'C']))

    return payoff
```

TFT-AC is designed to balance cooperation and punishment, encouraging players to collaborate while still responding to defection. This adaptive strategy demonstrates robustness against various opponent behaviors and aims at maximizing long-term collective benefits.
'''

description_COLLECTIVE_128 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, player i will determine if they should cooperate (C) or defect (D) based on the history of interactions and a dynamic cooperative threshold (CT). If the number of cooperators in the previous round is greater than or equal to CT, player i will cooperate. Otherwise, player i will defect.

   Pseudocode for decision rule:
   ```
   function decideAction(history, currentRound, r, n, k):
       if currentRound == 1:
           return C if uniformRandom() < 0.5
           else return D
       else:
           totalCooperators = sum(cooperator in history[currentRound-1])
           cooperativeThreshold = min(CT_initial * (1 - (r-currentRound)/r, CT_max)
           if totalCooperators >= cooperativeThreshold:
               return C
           else:
               return D
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, player i has a 50% chance of cooperating to initiate interactions positively. For the last round and other edge cases (e.g., when r is even or odd), TFT-ACT uses the same decision rule as non-edge cases.

3. Be collective - Clearly align with the collective mindset
   The adaptive cooperative threshold (CT) aims to balance between cooperation and defection based on previous rounds' outcomes, ensuring a more collaborative approach over time. Initially, CT is set to a low value (CT_initial), promoting higher cooperation in early rounds. As the game progresses, CT increases gradually up to a maximum limit (CT_max). This encourages maintaining cooperation when there are positive interactions and lessens the impact of occasional defections by adapting the threshold over time.

   The cooperative threshold can be adjusted based on desired levels of cooperation and the specific environment of the game:
   ```
   parameter CT_initial = 0.3
   parameter CT_max = 0.9
   ```
'''

description_COLLECTIVE_129 = '''
 In this strategic game, we'll introduce a cooperative Tit-for-Tat (TFT) approach with a slight twist called Cooperative Adaptive TFT (CAT). The objective is to balance cooperation and defection in response to other players' actions while maintaining a collective mindset.

1. Decision rules:
   - In the first round, cooperate to demonstrate goodwill and promote cooperation among all players.
     ```python
     if round == 1:
       action = 'C'
     ```
   - For subsequent rounds, follow the TFT strategy with slight adjustments based on historical cooperation levels. The adjusted payoff threshold helps avoid trapping in a cycle of defection when facing too many defectors.
     ```python
     if round > 1:
       history_cooperation = sum(historical_actions[:round]) / round
       if history_cooperation >= (n - 1) / n and my_action in previous_actions:
         action = 'D'   # Defect to retaliate against repeated defection
       elif history_cooperation <= (n - k) / n:
         action = 'D'   # Defect when the majority has consistently refused to cooperate
       else:
         action = 'C'   # Cooperate since the majority has shown signs of cooperation or inconsistency
     ```

2. Handle edge cases:
   - In the last round, cooperate if my actions have been mainly cooperative throughout the game. This allows for a chance to build goodwill before the tournament concludes.
     ```python
     if round == r and sum(previous_actions) > (r * (n - 1)) / 2:
       action = 'C'
     ```
   - In case of a tie (multiple players have the same number of cooperative actions), default to cooperation as a peaceful resolution.

3. Be collective:
   - The strategy promotes long-term collaboration by following TFT, which fosters trust and mutual understanding among players.
   - The slight adjustments account for varying player behaviors and aim to maintain a balance between cooperation and defection that ultimately benefits the group as a whole.
'''

description_COLLECTIVE_130 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initialize: Start with cooperating in the first round (C_i, 1 = 1). This encourages others to cooperate and builds trust.
   - Copy behavior: For subsequent rounds, copy the action of the previous player you interacted with (i.e., if the last player cooperated, also cooperate; if they defected, also defect). This simple yet effective rule allows for a balance between cooperation and defection, promoting reciprocity.

2. Handle edge cases:
   - Last round: Since we aim to maximize total payoff over all rounds, defect in the last round (C_i, r = 0) to ensure that you retain your final contribution as private payoff.
   - First round: As mentioned earlier, cooperate in the first round (C_i, 1 = 1).

3. Be collective:
   - The TFT strategy is inherently aligned with a collective mindset by promoting cooperation and reciprocity. This strategy does not rely on specific coordination mechanisms or shared norms but encourages others to behave similarly through its simple decision rules.

Pseudocode for the TFT strategy:

```
function TFT(i, t):
  if t == 1:
    return C_i, t = 1

  last_action = opponent_actions[i][t - 1]
  return last_action
```
In this pseudocode, `opponent_actions` is a matrix storing the actions taken by each player in each round. The variable `i` represents the current player, and `t` denotes the current round number.
'''

description_COLLECTIVE_131 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - Initiate cooperation (play C) in the first round to signal trust and foster a cooperative environment.
   - In subsequent rounds, cooperate if all players cooperated in the previous round (Tit-for-Tat), otherwise defect.
   - If a player deviates from cooperation (defects), wait for one round before resuming cooperation as an incentive to rebuild trust.
   - Adaptiveness: After the initial round, the strategy will remember the opponents' behavior in previous rounds and respond accordingly.

2. Handling Edge Cases:
   - First Round: Play C (cooperate) to initiate a cooperative environment.
   - Last Round: Analyze the overall behavior of the opponents during the game and play C if the majority has been cooperative, or D if the majority has been defective. This encourages long-term cooperation while being prepared for uncooperative opponents.
   - Other Edge Cases (e.g., intermediate rounds): Utilize the adapted decision rule based on the opponent's behavior in previous rounds.

3. Collectiveness:
   - TfTA emphasizes a collective mindset by promoting cooperation when others do so and rebuilding trust after conflict. This approach encourages mutual benefit and long-term cooperation among players, fostering a cooperative community within the game.
'''

description_COLLECTIVE_132 = '''
 Strategy Name: Adaptive Tit-for-Tat with Public Goods Factor (ATFPG)

1. Decision Rules:
   - Initiate Cooperation (C): In the first round, cooperate to establish a cooperative environment and contribute to the public good. This encourages others to do the same.
   - Tit-for-Tat (TFT): If an opponent cooperates in a round, return cooperation in the next round. If an opponent defects, also defect for the same number of rounds as the defection streak. After that, revert back to cooperation. This punishes defection and encourages opponents to cooperate again.
   - Public Goods Factor (PGF): To incentivize long-term cooperation, implement a public goods factor (k) by adjusting the punishment phase of TFT. Instead of exact reciprocation, defect for a number of rounds equal to [(current_round - last_cooperation_round) / k]. This makes the strategy less aggressive in larger games and encourages cooperation more easily.

2. Handling Edge Cases:
   - First Round: Cooperation (C)
   - Last Round: If total_contributions > threshold, cooperate; otherwise, defect based on PGF rule. The threshold can be determined experimentally to ensure fairness towards opponents who have been cooperating.
   - Other Edge Cases: No specific rules are needed for other edge cases as the strategy's adaptability allows it to handle them effectively within the game dynamics.

3. Collective Mindset:
   - The ATFPG strategy promotes a collective mindset by encouraging cooperation in the initial round and returning cooperation when opponents do so. It also encourages long-term cooperation by adjusting its punishment phase based on the public goods factor (k). This incentivizes other players to contribute more to the public good, fostering a stronger sense of collaboration.

Pseudocode:

```python
def ATFPG(round_num, k, previous_actions):
  if round_num == 1:
    return "C" # Cooperate in the first round

  last_cooperation = max([i for i, action in enumerate(previous_actions) if action == 'C'])

  # Punishment phase based on Public Goods Factor (PGF)
  defect_rounds = max((round_num - last_cooperation) // k, 0)

  if defect_rounds > 0:
    return "D" * defect_rounds + "C" # Defect for the punishment phase then cooperate after
  else:
    return previous_actions[-1] # Cooperate if no need for punishment
```
'''

description_COLLECTIVE_133 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In every round t, the ATFT strategy cooperates when more than half of the players have cooperated in the previous round (t-1). If less than half of the players have cooperated in the previous round, it will defect.

   Pseudocode:
   ```
   function ATFT(history):
       if |history[t-1]| < n/2 then
           return "Defect"
       else
           return "Cooperate"
   ```

2. Handle edge cases:
   - In the first round, as there is no history to consult, ATFT will randomly choose either 'Cooperate' or 'Defect'. This random choice encourages other players to also cooperate in the initial stage, fostering a cooperative environment.
   - In the last round, ATFT follows the same decision rule as in previous rounds, but with an added twist: since there is no future payoff incentive, it will defect if more than half of the players cooperated in the previous round to retaliate against freeriders who took advantage of its initial cooperation.

3. Be collective:
   - By following a simple yet robust rule that is adaptive to different opponent behaviors and aligns with the collective mindset, ATFT aims to foster long-term mutual cooperation among players. It punishes frequent defections and rewards consistent cooperation, encouraging others to reciprocate similarly. This strategy promotes the emergence of a cooperative equilibrium in repeated interactions while still allowing for flexibility in the face of unexpected player behavior.
   - Moreover, by starting with random cooperation in the first round, ATFT fosters initial cooperation among players without relying on explicit coordination mechanisms or shared norms.
'''

description_COLLECTIVE_134 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate a potential partnership and establish goodwill.
   - For subsequent rounds t > 1:
     - If player's previous action (A_i,t-1) was Cooperate (C), then cooperate again (C).
     - If player's previous action (A_i,t-1) was Defect (D), then also defect this round (D). However, if the total number of cooperators in the previous round exceeded a certain threshold (e.g., ⌊(n+1)/2⌋ or two-thirds of players), switch to cooperate for the current round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - For the last round and any round near the end (e.g., less than 10% of rounds remaining), focus on maximizing individual payoff, by adapting to the current game situation:
     - If more players have been cooperating than defecting in recent history, then continue to cooperate.
     - If more players have been defecting than cooperating, start defecting to benefit from their defection tendency.
   - In all other edge cases or whenever there's no clear trend observed in the game dynamics, maintain the TFT-AC strategy described above.

3. Be collective - Clearly align with the collective mindset:
   - By cooperating when most players do and adapting to their actions, TFT-AC encourages a collective approach by rewarding mutual cooperation and penalizing defection.
   - In the case of a sudden shift in player behavior, TFT-AC can quickly adapt to new trends while still maintaining a cooperative spirit as long as it is beneficial for the majority of players.

Pseudocode:

```python
def tft_ac(round, history):
  if round == 1:
    action = 'Cooperate'
  else:
    previous_action = history[round - 1][player_index]
    total_cooperators = sum([c for c, h in history if h == 'Cooperate'])

    if total_cooperators > threshold:
        action = 'Cooperate'
    elif previous_action == 'Cooperate':
        action = 'Cooperate'
    else:
        action = 'Defect'
  return action
```

In this pseudocode, `player_index` refers to the index of the specific player in the history list and `threshold` is set as mentioned earlier (e.g., ⌊(n+1)/2⌋ or two-thirds of players).
'''

description_COLLECTIVE_135 = '''
 Strategy Name: Tit-for-Tat with Fading Memory (TFTF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate trust and encourage cooperation from others.
   - In subsequent rounds, cooperate if the opponent cooperated in the previous round, otherwise defect. This encourages reciprocity but also allows for forgiveness over time.
   - To avoid getting trapped in a cycle of continuous defections, the strategy will forget past transgressions after a certain number of rounds (fading memory).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above to initiate cooperation.
   - In the last round and any other exceptional situations (e.g., when the strategy has a limited memory), revert to cooperating based on current information available.

3. Be collective - Clearly align with the collective mindset
   - Encourage cooperation by initially demonstrating trust, responding to cooperation with continued cooperation, and allowing for forgiveness over time through fading memory.
   - Avoid being exploitative or overly aggressive in order to maintain a positive long-term relationship with other players, promoting collective success.

Pseudocode:

```python
def TFTF(n, k, r, memory_length):
    def get_payoff():
        # Calculate payoff based on actions of all players in current round
        pass

    def remember(player_action):
        global past_actions
        past_actions.append(player_action)
        if len(past_actions) > memory_length:
            del past_actions[0]

    def should_cooperate():
        if round_number == 1:
            return True # cooperate in the first round to initiate cooperation
        else:
            return past_actions[-1] == 'Cooperate' # cooperate if opponent cooperated last round

    round_number = 1
    past_actions = []
    while round_number <= r:
        remember(player_action)
        player_action = should_cooperate() and 'Cooperate' or 'Defect'
        payoff = get_payoff()
        round_number += 1
```
'''

description_COLLECTIVE_136 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, evaluate the number of cooperators in the previous round (history). If all players cooperated in the previous round, cooperate. Otherwise, defect. If it's the first round, cooperate as a goodwill gesture. Adaptive Cooperation rule allows for adjusting the threshold of cooperators required to cooperate based on the average number of cooperators in past rounds.

Pseudocode:
```
def tft_ac(round, history, n, k):
    if round == 1:
        cooperate = True
    else:
        total_cooperators = sum(history[-n:])
        if total_cooperators == n:
            cooperate = True
        else:
            cooperate = False
    return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, cooperate as a goodwill gesture to encourage cooperation. In the last round, evaluate the current round and make a decision based on the TFT-AC rule.

3. Be collective - Clearly align with the collective mindset
By following the Tit-for-Tat strategy, players demonstrate reciprocity and encourage others to cooperate in return. The adaptive cooperation component allows for adjusting cooperation levels according to the collective behavior observed in previous rounds, fostering a more collective approach.
'''

description_COLLECTIVE_137 = '''
 Title: Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   a. In the first round, cooperate to set a cooperative tone and promote trust among players (C).
   b. Subsequent rounds: If player i's partner (the other player in the current round) cooperated in the previous round, then player i will also cooperate (C). Otherwise, player i will defect (D). This reciprocity ensures that TfT-E starts cooperatively while punishing non-cooperative behavior.
   c. To further promote cooperation, the strategy will gradually increase its tolerance towards defection as the game progresses. Specifically, it decreases its punishment intensity by 10% every t rounds (t ≤ r), with t starting at round 2. This means that if a player defected in round x, the strategy would start punishing them from round x + 1, but with reduced severity as the game progresses.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   a. The first round is an exception where all players cooperate (C).
   b. In the last round, the strategy uses its current level of tolerance to determine whether to cooperate or defect. This decision is based on whether the partner cooperated in the previous round. If the partner cooperated, the strategy will also cooperate. Otherwise, it will defect according to the current level of punishment intensity.
   c. In case a player encounters an opponent who never cooperates, the strategy will adjust its tolerance level to a minimum, thereby ensuring that it will always punish defection.

3. Be collective - Clearly align with the collective mindset
   a. The TfT-E strategy is designed to foster cooperation by initially demonstrating trust and reciprocity. It encourages other players to cooperate through its own cooperative actions, hoping that this will create a positive feedback loop leading to higher levels of cooperation among all players.
   b. By reducing the severity of punishment over time, the TfT-E strategy aims to encourage defectors to return to cooperation while maintaining fairness and minimizing the impact of repeated defection on overall group performance.
'''

description_COLLECTIVE_138 = '''
 In this strategic approach for the N-Player Public Goods Game, we'll design a cooperative Tit-for-Tat (TFT) variant that is adaptive and robust to various opponent behaviors while maintaining collective mindset alignment.

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = 1 for t=1). This encourages a cooperative start as other players might also choose cooperation initially.
   - From the second round onwards, observe past actions of all opponents and mimic their last action (if they have been cooperating, continue cooperating; if they have defected, defect in response). For t > 1, c_i = c_(i,t-1) for all i.
   - Conditionally adjust cooperation based on overall player collaboration:
       a) If more than half of the players are currently cooperating, maintain current strategy (cooperate if they are cooperating and defect otherwise).
       b) If less than half of the players are currently cooperating, switch strategies (defect if they are cooperating and cooperate otherwise). This encourages a shift towards defection when collaboration breaks down.

2. Handle edge cases:
   - In the last round, maintain the current strategy to ensure fairness in the final payoff calculation.
   - In case of tie for the number of cooperators (i.e., exactly half of the players are cooperating), follow the current strategy.

3. Be collective:
   - The strategy promotes cooperation as a default action, aligning with the collective mindset by encouraging mutual collaboration and support among players.
   - The adjustment based on overall player collaboration further emphasizes cooperation when it is beneficial for all participants, fostering a sense of unity and collective success.

Pseudocode:
```python
def public_goods_game(n, k, r):
    strategy = [0] * r  # Initialize an empty list to store past actions
    cooperators = 0
    for t in range(r):
        collaborating = (cooperators >= n//2) or (cooperators < n//2 and len(strategy) > 1)
        if t == 1:  # First round, cooperate as a goodwill gesture
            strategy[t] = 1
            cooperators += 1
        else:
            strategy[t] = strategy[t-1]  # Mimic past action
            current_cooperation = strategy[t] == 1
            if current_cooperation != collaborating:
                strategy[t] = not strategy[t]  # Adjust cooperation based on overall collaboration
            if current_cooperation:
                cooperators += 1
    return strategy
```
'''

description_COLLECTIVE_139 = '''
 Title: Adaptive Tit-for-Tat Strategy (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The ATFT strategy begins by cooperating in the first round to establish a cooperative relationship with other players, as all players are initially unaware of each other's behavior. In subsequent rounds, the strategy will imitate the actions of other players from the previous round. If a player cooperated (C), then the ATFT player will also cooperate; if a player defected (D), the ATFT player will defect as well.

Pseudocode:
```
def atft(player_index, round, history, n, k):
    if round == 1:
        return 'C' # Cooperate in the first round to establish a cooperative relationship
    else:
        last_round = history[-1]
        if last_round[player_index] == 'C':
            return 'C' # Cooperate if the other player cooperated last round
        elif last_round[player_index] == 'D':
            return 'D' # Defect if the other player defected last round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For edge cases such as the last round or when a player is unsure about another player's strategy (due to inconsistent behavior), ATFT players will return to their initial cooperative state from the first round.

Pseudocode:
```
def atft(player_index, round, history, n, k):
    # ... (previous pseudocode)
    elif round == r: # If it's the last round, return to cooperating as in the first round
        return 'C'
    else: # If unsure about another player's strategy, default to initial cooperative state
        if len(history) < round:
            return 'C'
```

3. Be collective - Clearly align with the collective mindset

ATFT players will always prioritize the greater good and contribute to the community project whenever possible. This ensures that the strategy is collectively aligned while being adaptive and robust to a wide range of opponent behaviors.

This strategy can be seen as an extension of the classic Tit-for-Tat strategy in prisoner's dilemma, tailored for the N-Player Public Goods Game. By combining cooperative behavior with imitation of other players' actions, ATFT aims to foster cooperation and encourage long-term mutual benefits among players.
'''

description_COLLECTIVE_140 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfTA strategy follows a tit-for-tat approach with adaptations to improve robustness and collective mindset:

a. Initiate cooperation (C) in the first round, setting a positive tone for future interactions.
b. For subsequent rounds t ≥ 2, evaluate the opponents' actions from the previous round (t-1). If all players cooperated, then cooperate again (C). If any player defected (D), also defect in the current round.
c. To encourage cooperation among opponents and maintain a collective mindset, revert to initial cooperation (C) if an opponent switches from defection (D) to cooperation (C), after a certain number of retaliatory rounds.
d. If multiple players switch strategies simultaneously, evaluate the ratio of cooperators to defectors in the previous round and choose the most common action for the current round.
e. Implement forgiveness: if an opponent switches from defection (D) to cooperation (C), after a certain number of consecutive defections (D), revert to initial cooperation (C).

2. Handle edge cases - What do you do in the first round, last round, etc.?

a. In the first round, cooperate unconditionally (C).
b. In the last round, evaluate the opponents' actions from the previous round and choose the action that maximizes total payoff based on the game parameters. If there is a tie, prefer cooperation over defection to foster collective mindset.
c. In intermediate rounds, refer to decision rules specified in part 1.
d. If r (number of rounds) is unknown, adapt strategy to assume an infinite number of rounds while maintaining a balance between short-term and long-term payoffs.

3. Be collective - Clearly align with the collective mindset

a. Prioritize cooperation over defection whenever possible, to promote collective wellbeing and collaborative outcomes.
b. Adaptively respond to opponents' actions, emphasizing forgiveness and reversion to initial cooperation when appropriate.
c. Encourage opponents to switch from defection (D) to cooperation (C) by demonstrating consistent cooperation and offering opportunities for collaboration.
d. Maintain a balance between short-term payoffs and long-term collaborative success, allowing the strategy to adapt over time while fostering collective mindset.

Pseudocode:

```python
class TitForTatAdaptive:
    def __init__(self, n, r, k):
        self.n = n
        self.r = r
        self.k = k
        self.history = []  # Stores the history of actions across all players and rounds

    def evaluate_round(self, actions):
        total_contributions = sum(actions)
        payoffs = [(1 - c_i) + (self.k / self.n) * total_contributions for c_i in actions]
        return payoffs

    def decide_action(self, opponent_actions):
        if len(opponent_actions) == 0:  # First round, always cooperate
            return 'C'
        elif self.history[-1] == opponent_actions and opponent_actions[0] == 'C':  # Cooperate if all players cooperated last round
            return 'C'
        else:  # Otherwise, evaluate opponents' actions and decide on cooperation or defection
            num_cooperators = sum(opponent_actions)
            total_players = len(opponent_actions)
            cooperation_ratio = num_cooperators / total_players
            if cooperation_ratio < 0.5:  # If less than half of the players cooperated, defect to discourage defection
                return 'D'
            elif cooperation_ratio > 0.5 and all(opponent_actions[1:] == opponent_actions[0]) or any(opponent_actions[i] != opponent_actions[0] for i in range(1, len(opponent_actions))):
                # If opponents have been consistently cooperating or switched strategies, revert to cooperation
                if self.history[-1][0] == 'D':
                    return 'C'
            else:
                # Otherwise, evaluate the number of cooperators and defectors in the previous round, choosing the most common action
                num_cooperators = sum(self.history[-2])
                total_players = len(self.history[-2])
                cooperation_ratio = num_cooperators / total_players
                if cooperation_ratio > 0.5:
                    return 'C'
            return 'D'  # Default to defection when in doubt

    def update_strategy(self, own_action, opponent_actions):
        self.history.append([own_action] + opponent_actions)

    def play_round(self, own_action, opponent_actions):
        payoffs = self.evaluate_round(opponent_actions)
        self.update_strategy(own_action, opponent_actions)
        return payoffs

    def play_game(self, opponents, rounds=None):
        if rounds is None:
            rounds = float('inf')
        total_payoff = 0
        for r in range(rounds):
            actions = [opponent.decide_action(self.history[-r:]) for opponent in opponents]
            payoffs = self.play_round('C', actions)
            total_payoff += sum(payoffs)
        return total_payoff
```
'''

description_COLLECTIVE_141 = '''
 In this N-Player Public Goods Game, I propose a strategy named "Fair-Share Strategy" (FSS). The FSS is designed to promote cooperation while being adaptive and robust against various opponent behaviors.

1. Decision rules:
   - If the number of contributors in the previous round is below the average (n/2), players should cooperate, as it seems that most opponents are not contributing enough to the public good.
   - If the number of contributors in the previous round is above or equal to the average, players should defect, as it seems that most opponents are already making significant contributions and self-interest could be more rewarding.

Pseudocode for this part:
```
def decision_rule(contributors_last_round):
  if contributors_last_round < n/2:
    return "Cooperate"
  else:
    return "Defect"
```

2. Handle edge cases:
   - In the first round, players will randomly choose to either cooperate or defect as no previous information is available.
   - In the last round, players should cooperate since cooperation benefits all players regardless of the remaining rounds.

Pseudocode for this part:
```
def edge_cases(round_number, is_first_round):
  if is_first_round:
    return random.choice(["Cooperate", "Defect"])
  elif round_number == r:
    return "Cooperate"
  else:
    return None
```

3. Be collective:
   - The strategy aligns with a collective mindset by promoting cooperation whenever the majority of players do not seem to contribute enough, aiming for a fair and balanced contribution to the public good.

This strategy encourages players to work together while being adaptive and robust against various opponent behaviors. The FSS can be further improved by incorporating machine learning techniques that learn from the opponents' behavior over time.
'''

description_COLLECTIVE_142 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, contribute to the public good (C). This is a peace offering to potential partners and sets a cooperative tone.
   - For subsequent rounds, observe your opponent's actions from the previous round. If they contributed, reciprocate by contributing as well (C). If they did not contribute, also withhold contribution (D) to punish them for their uncooperative behavior.
   - After a string of uncooperative moves by an opponent, revert to initial strategy of contributing in the next round (first C after a streak of D's). This gives opponents a chance to correct their behavior.

2. Handling Edge Cases:
   - In the last round, contribute to the public good as a final gesture of cooperation, hoping this may encourage others to do the same.
   - If an opponent stops contributing and then starts again after several rounds of uncooperative behavior, immediately resume reciprocating their contributions (C if they C, D if they D). This strategy encourages opponents to revert to cooperation if they see it is beneficial.

3. Collective Mindset:
   - TFTAC strategy prioritizes long-term relationships and mutual understanding. It is designed to foster a cooperative environment by punishing defection but also by forgiving past mistakes. This encourages opponents to adopt more cooperative strategies in the long run, as they will see that cooperation benefits both parties.

Pseudocode:
```
function TFTAC(round, opponent_actions):
  if round == 1:
    contribute = True  # Always contribute in the first round
  else:
    if len(opponent_actions) < 2:
      last_round_action = opponent_actions[-1]  # Assume recent behavior continues
    else:
      last_round_action = opponent_actions[-2]  # Assume recent behavior continues
    contribute = (last_round_action == 'C') or (round == r)  # Contribution depends on previous action and game length

  return contribute
```
'''

description_COLLECTIVE_143 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, play C to signal cooperation and good intentions.
   - For subsequent rounds t > 1, observe the actions of other players in the previous round (t-1). If all players cooperated (total_contributions = n), continue cooperating with C. If any player defected (total_contributions < n), defect with D to punish the defector and encourage future cooperation.
   - To promote forgiveness and cooperation recovery, revert to cooperative behavior after three consecutive rounds of defection from another player.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, play C as described above.
   - In the last round, assess the total contributions and play C if it maximizes the payoff for that specific round. If there is no apparent pattern of cooperation or defection among opponents, use the TFT-A decision rule.
   - For other edge cases (e.g., penultimate round), apply the standard TFT-A decision rule based on the previous round's observations.

3. Be collective - Clearly align with the collective mindset
   - Cooperate to foster a cooperative environment and encourage others to do the same, but be prepared to punish defection for the greater good.
   - Adapt to opponent behavior while maintaining the collective spirit of cooperation, forgiveness, and reciprocity.
'''

description_COLLECTIVE_144 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C). This is a friendly gesture, setting a cooperative tone for the game.
   - In subsequent rounds, observe and mimic the actions of the most frequent contributors from the previous r-1 rounds (the player with the highest average contribution over the last r-1 rounds). If multiple players share this distinction, choose the one with the closest alignment to your own past behavior.
   - If the observed player cooperated in the last round, cooperate (C). If not, defect (D). This reciprocity ensures that you contribute when others do and withhold contribution when others do not.
   - To encourage long-term cooperation, adjust the level of contribution k based on the current average contribution level among all players. As the average contribution decreases, lower your own contribution (k < 2), making it more difficult for others to earn high payoffs through defection. Conversely, if the average contribution increases, raise your own contribution (k > 2) to encourage further cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, always cooperate (C). As mentioned earlier, this is a friendly gesture setting a cooperative tone for the game.
   - In the last round, observe and mimic the actions of the most frequent contributors from the previous r-1 rounds, just like in regular rounds. However, consider the possibility that the other players might also adjust their strategies to take advantage of the final round, potentially leading to a higher prevalence of defection. If this happens, reduce your contribution (k < 2) to protect yourself against such behavior and avoid overly generous payoffs.

3. Be collective - Clearly align with the collective mindset
   - By following the Tit-for-Tat pattern and adjusting contributions based on the average level of cooperation among all players, TFTAC fosters a collective mindset by encouraging reciprocal behavior and long-term cooperation.
   - The adaptive contribution mechanism ensures that TFTAC remains responsive to changing conditions and opponent behaviors, promoting overall cooperation within the game.
'''

description_COLLECTIVE_145 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TFT-A)

1. Decision Rules:
   - Initially Cooperate (C) in the first round to demonstrate goodwill and encourage cooperation from other players. This is based on the assumption that others might also cooperate initially.
   - In subsequent rounds, if a player (i) observed that they were cooperated with by all other players in the previous round (TotalCooperation_prev), then they will also Cooperate (C).
   - If a player (i) was defected upon by any other player(s) in the previous round, they will defect (D) in the current round as retaliation. This is to punish those who did not cooperate and encourage them to return to cooperation later.
   - After defecting, a player will continue to defect until it encounters r consecutive rounds of total cooperation from all other players. At that point, they will resume cooperating again. This rule helps foster forgiveness and the possibility of rebuilding trust.

Pseudocode:
```
function TFT-A(n, k, r, round)
  if round == 1 then
    return C
  end if

  TotalCooperation_prev = count Cooperation actions from all players in the previous round

  if TotalCooperation_prev == n then
    return C
  else
    if TotalCooperation_prev > 0 then
      if round - TotalCooperation_prev >= r then
        return C
      else
        return D
      end if
    else
      return D
    end if
  end if
end function
```

2. Handle Edge Cases:
   - In the last round (r), TFT-A players will cooperate regardless of the previous actions to ensure maximum potential payoff, even if trust has been broken earlier in the game.
   - If a player encounters a situation where they did not receive any information about other players' actions from the previous rounds (e.g., due to network failures), they should follow their initial Cooperate action for the first round.

3. Be Collective:
   - By adopting a strategy that balances cooperation and retaliation, TFT-A promotes a collective mindset by trying to encourage cooperation and building trust while also punishing defection in an effort to maintain fairness among all players.
   - By forgiving those who have defected after a certain number of rounds (r), TFT-A demonstrates that it values long-term cooperation over immediate payoff, thus fostering a collective goal of achieving higher total payoffs through cooperative efforts.
'''

description_COLLECTIVE_146 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Decision Rules:
   - In the first round, cooperate to establish trust and initiate positive interactions. This is represented by the function `firstRoundStrategy(round)`.
   - After the first round, continuously mimic the opponent's previous action in the current round (cooperation or defection). If the opponent has previously cooperated, continue cooperating. If the opponent has previously defected, also defect in the current round. This is represented by the function `tftAstrategy(history)`, where `history` is a list of the previous rounds' actions for each player.
   - In the last round, cooperate to maximize potential payoffs based on the history of interactions and to demonstrate goodwill in case of future interactions with the opponent. This can be represented by the function `lastRoundStrategy(round, totalRounds)`.

2. Edge Cases:
   - The first round strategy (cooperate unconditionally). `firstRoundStrategy(round)` returns `C` if `round == 1`, and `D` otherwise.
   - In the last round, cooperate regardless of past actions to maximize potential payoffs based on the history of interactions. `lastRoundStrategy(round, totalRounds)` checks if the current round is the last one (`round == totalRounds`) and returns `C`. Otherwise, it uses the TFT-A strategy function.

3. Be Collective:
   - The collective mindset is achieved by prioritizing cooperation when possible, fostering trust with opponents, and responding in a predictable manner to maintain that trust. In cases where opponents are not cooperative, the adaptive nature of TFT-A allows for adjusting actions based on past interactions to maximize individual payoffs.

Pseudocode:

```
def firstRoundStrategy(round):
  if round == 1:
    return 'C' # Cooperate in the first round
  else:
    return tftAstrategy(history) # Use TFT-A strategy from round 2 onwards

def tftAstrategy(history):
  if len(history) == 0:
    return 'C' # If no history, assume opponent will cooperate in the first round

  lastAction = history[-1] # Take the last action in the history
  if lastAction == 'C':
    return 'C' # Cooperate if the opponent cooperated in the previous round
  else:
    return 'D' # Defect if the opponent defected in the previous round

def lastRoundStrategy(round, totalRounds):
  if round == totalRounds:
    return 'C' # Cooperate in the last round
  else:
    return tftAstrategy(history) # Use TFT-A strategy for all other rounds
```
'''

description_COLLECTIVE_147 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - Initiate cooperation (play C) in the first round to foster a cooperative environment and avoid being exploited by defectors.
   - In subsequent rounds, analyze opponent's behavior in the previous round to determine whether to cooperate or defect.
     - If the opponent cooperated in the previous round, reciprocate by cooperating.
     - If the opponent defected in the previous round, also defect in the current round as a penalty for defection.
   - To encourage long-term cooperation, reduce the severity of retaliation over time (exponential decay). This allows players to escape from repeated cycles of defect-punish-defect.
     - Calculate an average cooperation rate over the past few rounds:
       AverageCooperationRate = (sum(cooperation in previous N rounds) / N)
     - Adjust retaliation based on this average and a decay factor (0 < decay < 1):
       - If the opponent cooperated, continue to cooperate: play C
       - If the opponent defected, decide whether to defect or cooperate using the adjusted retaliation rate:
         RetaliationRate = min(decay * MaxPunishment, 1)
         Play D if RetaliationRate > AverageCooperationRate; otherwise, play C.

2. Handle Edge Cases:
   - First Round: play C to initiate cooperation.
   - Last Round: analyze opponent's behavior in the previous round and use the decision rules as described above.
   - Transitions between Cooperation and Defection: To avoid abrupt transitions between cooperation and defection, implement a smooth transition period (MovingAverage window) to gradually adjust the retaliation rate.
     - If the opponent's behavior significantly changes, wait for MovingAverage windows worth of observations before adjusting retaliation rate.

3. Be Collective:
   - Foster a cooperative environment by starting with cooperation and responding cooperatively when opponents do so.
   - Gradually adjust retaliation based on the average cooperation rate to encourage long-term cooperation and avoid repeated cycles of defection-punishment-defection.
   - The TFTAC strategy aims to build trust while maintaining a robust response to various opponent behaviors, promoting collective interest over self-interest when possible.

Pseudocode:
```python
def TFTAC(opponent_history, n, k, r, MovingAverage=5, decay=0.8):
    # Initialize variables
    retaliation_rate = 1
    moving_average_window = MovingAverage

    for round in range(r):
        # Play C in the first round
        if round == 0:
            action = 'C'
        else:
            # Calculate average cooperation rate over previous rounds
            total_cooperation = sum(opponent_history[-moving_average_window:-1])
            average_cooperation_rate = total_cooperation / moving_average_window

            # Adjust retaliation based on decay factor and current average cooperation rate
            retaliation_rate = min(decay * MaxPunishment, 1)
            if opponent_history[-1] == 'C':
                action = 'C'  # Cooperate if the opponent cooperated
            else:
                action = ('D' if retaliation_rate > average_cooperation_rate else 'C')  # Decide whether to defect or cooperate based on adjusted retaliation rate
        opponent_history.append(action)
    return opponent_history, retaliation_rate
```
'''

description_COLLECTIVE_148 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players contribute half of their endowment to encourage cooperation and set a initial tone for future interactions.
   - Subsequent rounds follow the Tit-for-Tat (TFT) strategy: if the player cooperated in the previous round, they cooperate; otherwise, they defect. However, the level of contribution is adjusted based on the average contribution rate observed over the past few rounds.
     - If the average contribution rate exceeds a threshold (defined as the median contribution rate from the last 5 rounds), players increase their contribution by 10%.
     - If the average contribution rate falls below the threshold, players decrease their contribution by 10%.
     - If there are less than 5 rounds played, the average contribution rate is calculated based on available data.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, players cooperate with a half-contribution to foster cooperation and establish initial dynamics.
   - In the last round, players evaluate their overall average contribution rate throughout the game. If they have maintained an above-average level of cooperation (above the median), they continue cooperating. Otherwise, they defect to secure a higher payoff.
   - When facing unusual situations such as changes in player participation or game parameters, the TFTAC strategy adjusts its behavior adaptively over time.

3. Be collective - Clearly align with the collective mindset
   - TFTAC is designed to promote and maintain cooperation among players by adapting its contribution level based on observed patterns of cooperation. By responding cooperatively when others do so, it encourages long-term collaboration and builds trust within the group.
   - The strategy incentivizes cooperation by adjusting its own contribution rate in response to collective behavior, fostering a collective mindset that rewards mutual cooperation.
'''

description_COLLECTIVE_149 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate good faith and encourage potential cooperation from others (C).
   - Subsequent rounds: if opponent cooperated in the previous round, cooperate; otherwise, defect based on an adaptation mechanism.
   - Adaptation Mechanism: After a defection, wait for a number of rounds equal to the number of past defections from the opponent before returning cooperation (cooperate after d-1 non-cooperation). This allows the strategy to punish repeated defections while still being willing to cooperate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, always cooperate as mentioned above (C).
   - In the last round and any other exceptional situations, revert back to the initial behavior of cooperating if the opponent has been cooperative during the game so far. Otherwise, defect based on the adaptation mechanism.

3. Be collective - Clearly align with the collective mindset
   - By returning cooperation after defections, TFT-A encourages a collaborative environment as it rewards consistency and punishes unreliable behavior.
   - The strategy also adapts to the opponent's changing behavior, which further supports a more cooperative outcome by accommodating opponents who show signs of changing their strategy towards greater cooperation.
'''

description_COLLECTIVE_150 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initiation: Cooperate in the first round to promote a cooperative environment. This is intended to encourage other players to cooperate as well. (c_i = 1 in t=1)
   - Response: In all subsequent rounds (t>1), if a player i cooperated in the previous round, they should also cooperate in the current round. If another player defected in the previous round, player i should also defect in the current round. This rule encourages cooperation but also punishes defection to deter free-riding behavior. (If c_i, t-1 = C then c_i,t = C; if c_i, t-1 = D then c_i,t = D)
   - Forgiveness: To promote a quick return to cooperation after mistakes or periods of non-cooperation, players will forgive and cooperate in the round following a period of mutual defection. This rule allows the game to recover from temporary disputes or misinterpretations. (If c_i, t-1 ≠ c_j, t-1 then c_i,t = C)

2. Handle edge cases:
   - Last Round: Players should cooperate in the last round regardless of previous actions because the game is over and there are no more future interactions to consider. (If r=t then c_i,t = C)
   - First Encounter with Defection: To prevent being exploited by a potential free-rider, players will respond to defection in the very first encounter with defection as well. (If t=2 and c_j,1 ≠ C then c_i,2 = D)

3. Be collective:
   - The ATFT strategy aims at maintaining cooperation while punishing defection, fostering a collaborative mindset among players that is sustainable for repeated interactions. It encourages a balance between individual and collective interests by rewarding cooperation and penalizing defection.

Pseudocode:
```
def ATFT(n, k, r, t):
  if t == 1: # Initiation
    c_i = 1
  elif t < r: # Response and Forgiveness
    if t > 2: # Avoid exploitation in the first round after defection
      c_j = previous_action(t-2)
      if c_i, t-1 == C and c_j, t-1 == C: # Cooperate if both cooperated last round
        c_i = 1
      elif c_i, t-1 == D and c_j, t-1 == D: # Cooperate after mutual defection
        c_i = 1
      else: # Defect if player or partner defected in the last round
        c_i = 0
  else: # Last Round
    c_i = 1

def play(n, k, r):
  scores = [0]*n # Initialize payoff scores for each player
  endowments = [1]*n # Initialize endowments for each player
  rounds = range(1, r+1) # Iterate over the game rounds
  for t in rounds:
    actions = [] # Collect player actions in this round
    for i in range(1, n+1):
      c_i = ATFT(n, k, r, t) # Determine action based on strategy
      actions.append(c_i)
      if t > 1: # Update endowments and calculate payoffs after each round
        for j in range(1, n+1):
          total_contributions += actions[j-1]
        for j in range(1, n+1):
          payoff = (1 - actions[j-1]) + ((k/n) * total_contributions)
          scores[j-1] += payoff
  # Return the final score for player i over r rounds
  return scores
```
'''

description_COLLECTIVE_151 = '''
 Strategy Name: Tit-for-Tat with Fading Memory (TFTF)

1. Specify decision rules - When exactly do you cooperate vs defect?
- Initially in the first round, the TFTF strategy will cooperate to signal goodwill and establish trust.
- For subsequent rounds, the strategy will copy the previous action of the opponent from the most recent game (i.e., if the opponent cooperated in the last round, TFTF also cooperates; otherwise, it defects). However, there is a fading memory component that reduces the impact of past actions over time to account for changing conditions and opponents.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round, TFTF cooperates as mentioned above.
- In the last round, TFTF cooperates if its opponent has cooperated in the previous round to avoid losing any potential benefits from cooperation. Otherwise, it will defect to punish the opponent's lack of cooperation.

3. Be collective - Clearly align with the collective mindset
The TFTF strategy encourages collective thinking by promoting reciprocity and cooperation among players. By following a simple yet adaptive rule set, it aims to establish long-term relationships that foster mutual benefit. The fading memory component allows for flexibility in responding to changing opponent behaviors, ultimately contributing to the well-being of the group.

Pseudocode:
```python
def TFTF(n, k, r, history):
    opponent_action_history = []  # Initialize a list to store the opponent's previous actions

    def strategy(t):  # Define the strategy for round t
        if t == 1:
            return 'C'  # Cooperate in the first round to establish trust
        else:
            opponent_action = opponent_action_history[-1]  # Get the most recent opponent action
            decay_factor = (t - 2) / (r - 1)  # Calculate the fading memory factor
            if opponent_action == 'C':
                return 'C' * (1 - decay_factor) + 'D' * decay_factor  # Cooperate with a decreasing probability based on decay factor
            else:
                return 'C' * decay_factor + 'D' * (1 - decay_factor)  # Defect with a decreasing probability based on decay factor

    for t in range(1, r+1):
        own_action = strategy(t)  # Run the strategy for round t
        opponent_action_history.append(own_action)  # Store the current action as the most recent opponent action
        # Game play, calculate payoff, etc. using the provided game structure and payoff calculation functions
```
'''

description_COLLECTIVE_152 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Evolution (ATFTE)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment. This encourages others to reciprocate and sets a positive tone for the game. (Cooperate in round 1: c_i(1) = 1)
   - Subsequent rounds will involve an adaptive strategy that reacts to opponents' actions from previous rounds.
   - If all opponents cooperated in the previous round, cooperate again (c_i(t) = 1 if ∀j, c_j(t-1) = 1). This reinforces cooperation by reciprocating and punishes those who defect.
   - If any opponent defected or there was no cooperation in the previous round, defect as well (c_i(t) = 0 if ∃j, c_j(t-1) ≠ 1 or total_contributions(t-1) = 0). This punishes defection and encourages opponents to cooperate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - As mentioned earlier, cooperate in the first round (c_i(1) = 1).
   - In the last round, consider the total payoff over all rounds to make a final decision:
     - If the total payoff is above average, cooperate for one more round to potentially increase the payoff further. (If AvgPayoff < TotalPayoff(t), then c_i(r) = 1).
     - Otherwise, defect to secure the current payoff and prevent others from gaining an advantage in the last round. (If AvgPayoff > TotalPayoff(t), then c_i(r) = 0).

3. Be collective - Clearly align with the collective mindset:
   - The ATFTE strategy is designed to promote cooperation among players and encourages a collective approach by reciprocating cooperative actions and punishing defection.
   - By cooperating in the first round, the strategy sets an initial positive tone that supports a more collaborative environment.
   - Throughout the game, the strategy adapts to the opponents' actions to promote cooperation when possible while still punishing defection effectively.
'''

description_COLLECTIVE_153 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - First Round (t=1): Cooperate (C). Establish a cooperative initial state.
   - Subsequent Rounds (t > 1): If player i's opponent cooperated in the previous round, then also cooperate (C). Otherwise, defect (D). This encourages cooperation among those who have been cooperative while punishing those who are not.

Pseudocode:
```
function ATFT(t, history, n, k):
    if t = 1:
        return C
    previous_round = history[t-1]
    if previous_round == C:
        return C
    else:
        return D
```

2. Handle edge cases:
   - Last Round (r): Stick with the decision from ATFT, as it encourages cooperation up to the last round while punishing those who have not cooperated throughout the game.
   - In case of missing history or inconsistencies, use the first-round rule.

3. Be collective: The adaptive nature of the strategy allows it to align with a collective mindset by cooperating when others do so and punishing when they defect. This promotes mutual cooperation while maintaining individual incentives for contributing to the public good. By being robust against various opponent behaviors, ATFT fosters a more balanced and fair environment in the repeated game.
'''

description_COLLECTIVE_154 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC follows a tit-for-tat approach with adaptations for enhanced cooperation and robustness. The strategy alternates between cooperating and defecting based on the opponent's actions in the previous round. If the opponent cooperates, TFT-AC cooperates as well; if the opponent defects, TFT-AC defects in the next round but will gradually revert to cooperating with a decay factor (0 < α < 1).

   Pseudocode:
   ```
   function TFT_AC(previous_opponent_action, round, alpha):
       if round == 1:
           return COOPERATE
       elif previous_opponent_action == COOPERATE:
           return COOPERATE
       elif previous_opponent_action == DEFECT and round > 1:
           cooperation_decay = α ^ (round - 2)
           if cooperation_decay >= RANDOM_VALUE:
               return COOPERATE
           else:
               return DEFECT
       else:
           raise Exception("Invalid opponent action")
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-AC cooperates to foster a harmonious beginning. In the last round, it considers the cumulative score and adapts its decision accordingly. If the strategy is leading or close to leading, it chooses to defect; otherwise, it continues cooperating.

   Pseudocode:
   ```
   function edge_case_handling(current_round, r, current_score, max_score):
       if current_round == 1:
           return COOPERATE
       elif current_round == r:
           if current_score >= (max_score * ADAPTATION_THRESHOLD):
               return DEFECT
           else:
               return COOPERATE
       else:
           return NONE
   ```

3. Be collective - Clearly align with the collective mindset
   TFT-AC aims to maintain a balance between individual and collective interests by promoting cooperation while punishing defection in a proportionate manner. The strategy fosters an adaptive, fair, and forgiving collective behavior that encourages other players to cooperate as well.

   Note: In this context, the "collective mindset" is defined through the game's structure and payoff matrix, which promote cooperation for mutual benefit when possible while penalizing defection. TFT-AC strategy aligns with this collective mindset by promoting cooperation in most situations but also being robust against various opponent behaviors.
'''

description_COLLECTIVE_155 = '''
 Strategy Name: Tit-for-Tat Plus (Tft+)

1. Specify decision rules:
   - Start with cooperating (C) in the first round to foster a cooperative environment. After the first round, follow these rules for each subsequent round:
     - If a player has cooperated in the previous round (t-1), reciprocate cooperation by also cooperating (C).
     - If a player has defected in the previous round (t-1), retaliate with defection (D) to demonstrate displeasure, but return to cooperation after three consecutive defections from the opponent.
     - If a player has been cooperating for the past 'x' rounds and the current round is 'y' > 'x', switch to defecting (D) to avoid overinvestment in a non-cooperative opponent. The value of 'x' can be adjusted based on the specific game parameters, but starting with 'x=3' is recommended for general applicability.

2. Handle edge cases:
   - In the first round, cooperate (C) to initiate cooperation.
   - In the last round and any round where an opponent has defected for three consecutive rounds, switch to defection (D).
   - If an opponent has not been observed for 'y' consecutive rounds and 'y'> 'x', assume they have defected for that period and switch to defection (D) in the next round.

3. Be collective:
   - The strategy maintains a cooperative approach as long as opponents reciprocate cooperation. It demonstrates a willingness to cooperate while also enforcing punishments for repeated defections, promoting the collective mindset of mutual benefit and fair play.

Pseudocode:
```python
def TFTPlus(opponent_history, game_params):
    n = game_params["n"]
    k = game_params["k"]
    x = 3  # number of consecutive rounds for cooperation before switching to defection
    round = 1

    action = C  # Cooperate in the first round

    while round <= r:
        if round == 1:
            opponent_history.append(action)
        elif len(opponent_history) >= x and all(opponent[-x:] == D):
            action = D  # Switch to defection after three consecutive defections from opponent
        else:
            if action == C and opponent_history[-1] == C:
                action = C  # Cooperate if opponent cooperated in the previous round
            elif action == C and opponent_history[-1] == D:
                action = D  # Defect if opponent defected in the previous round

        payoff = calculatePayoff(action, opponent_history, game_params)
        round += 1

    return totalPayoff(payoff), opponent_history
```
'''

description_COLLECTIVE_156 = '''
 Title: Tit-for-Tat Cooperative Strategy (TFTCS) for N-Player Public Goods Game

1. Specify decision rules:
   - In each round t, player i initially cooperates (plays C) unless they have a history of defecting from cooperation by more players than the multiplication factor k in the previous r-1 rounds.
   - If player i has a history of defection, they will also defect in round t.
   - Player i reverts to initial cooperation (C) after a string of mutual cooperation from other players, starting with the first round where they cooperate instead of defect based on the new history.

Pseudocode:
```
Function TFTCS(i, t, r, n, k, previous_actions):
    if t = 1 or (t > 1 and !history_of_defection(i, previous_actions)):
        action_i = "C" (Cooperate)
    else:
        if history_of_defection(i, previous_actions, k, r-1):
            action_i = "D" (Defect)
        else:
            action_i = "C" (Cooperate)

    Update history_of_cooperation(i, action_i)
    Return action_i
```

2. Handle edge cases:
   - In the first round, all players will initially cooperate based on pseudocode provided above.
   - In the last round, each player can choose to cooperate or defect based on their current history and decision rules. This aligns with the assumption that no communication between players is allowed.

3. Be collective:
   - The Tit-for-Tat Cooperative Strategy promotes a collective mindset by prioritizing mutual cooperation, but it does not assume any specific coordination mechanisms or shared norms among the players.
   - Players cooperate unless there's evidence of repeated defection from other players, which makes this strategy adaptive to various opponent behaviors while emphasizing long-term collaboration when possible.
'''

description_COLLECTIVE_157 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show a peaceful and cooperative intent.
   - For subsequent rounds, observe the opponent's action from the previous round:
     - If the opponent cooperated in the previous round, cooperate in the current round.
     - If the opponent defected in the previous round, defect in the current round to demonstrate a response to defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate regardless of the opponent's action to maximize potential payoff.
   - In subsequent rounds (not the first or last), if a majority of players have not yet cooperated, follow TFTAC strategy; otherwise, defect to join the majority.

3. Be collective - Clearly align with the collective mindset
   - Foster a culture of cooperation by initially showing peaceful intentions and responding positively to cooperation from others.
   - When a majority of players seem uncooperative, adapt to their behavior for short-term success while still maintaining a cooperative stance in hopes that others may follow suit.

Pseudocode:
```
def TFTAC(round_num, opponent_actions, n, k):
    if round_num == 1:
        action = "Cooperate"
    elif round_num == r:
        action = "Cooperate"
    else:
        if len(cooperation_history) > n//2 and opponent_actions[-1] == "Defect":
            action = "Defect"
        elif len(cooperation_history) <= n//2 and opponent_actions[-1] == "Cooperate":
            action = "Cooperate"
        else:
            action = cooperation_history[-1]

    cooperation_history.append(action)
    return action
```
In this pseudocode, `round_num` represents the current round number, `opponent_actions` are the actions taken by the opponent in each round, `n` is the total number of players, `k` is the multiplication factor, and `cooperation_history` keeps track of past cooperation decisions. The function returns the player's action for the given round.
'''

description_COLLECTIVE_158 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In each round t, starting with t=1, the ATFT strategy cooperates (C) if all players cooperated in the previous round (t-1). If any player defected (D) in round t-1, the strategy defects in round t. This encourages cooperation when it is common and punishes defection to prevent exploitation.

2. Handle edge cases:
   - In the first round (t=1), every strategy cooperates as there is no previous history.
   - In the last round (t=r), every strategy cooperates if all players cooperated in the preceding round. If any player defected, the strategy will also defect to avoid being taken advantage of.

3. Be collective:
   - The ATFT strategy focuses on cooperation as a way to build trust and foster a collective mindset among players. By responding positively when others cooperate and retaliating when they do not, it encourages long-term cooperation. This aligns with the goal of maximizing payoffs for all players while maintaining an adaptive and robust strategy in response to various opponent behaviors.

Pseudocode:

```python
def ATFT(t, t_prev, cooperation_history):
  if t == 1 or (t_prev != -1 and cooperation_history[t_prev] == len(players)):
    return 'C' # Cooperate
  elif t_prev != -1 and cooperation_history[t_prev] < len(players):
    return 'D' # Defect
  else:
    return -1 # Error handling (unexpected state)

def get_cooperation_history(t, players, actions):
  history = [0] * t
  for i in range(t-1, -1, -1):
    history[i] = sum(actions[players[j]][i])
  return history
```
In this pseudocode, players are indexed by an array `players`, and actions (C or D) for each round are stored in a two-dimensional array `actions`. The function `get_cooperation_history(t, players, actions)` returns the cooperation history up to round t.
'''

description_COLLECTIVE_159 = '''
 For this N-Player Public Goods Game, I propose a strategy called Adaptive Tit-for-Tat (ATFT). The strategy is designed to promote cooperation while being robust against various opponent behaviors.

1. Specify decision rules:
   - In the first round, cooperate as a goodwill gesture (C_i = 1 if it's the first round; otherwise continue with step 2)
   - For all subsequent rounds, copy the last action of the previous round taken by the opponent (if opponent cooperated in the last round, cooperate C_i = 1; otherwise defect D_i = 0)

2. Handle edge cases:
   - Last Round: Stick with the most recent decision made by the opponent, as there will be no more rounds to respond.
   - Tie or Uncertainty: If multiple opponents have different last actions, choose the majority action (or an arbitrary action if a tie persists).

3. Be collective:
   - Cooperate initially to foster a cooperative environment
   - Mimic opponent's actions to encourage reciprocity and build trust over time

Pseudocode for Adaptive Tit-for-Tat strategy:

```python
def ATFT(round, history, n_players, k):
    if round == 1: # First round, cooperate as a goodwill gesture
        action = 1
    else:
        # Get the last action of the opponent from history
        last_action = history[-1][-1]
        action = last_action
    return action
```

By implementing this ATFT strategy, our AI agent will aim to strike a balance between cooperation and self-interest while being adaptive to a wide range of opponent behaviors. This collective mindset encourages ongoing cooperation in the game, maximizing the total payoff over multiple rounds.
'''

description_COLLECTIVE_160 = '''
 In this strategic public goods game, we'll design a Tit-for-Tat strategy with a slight modification to adapt to various opponent behaviors. The goal is to balance cooperation and defection while being robust against different player strategies.

1. Decision Rules:
   - Initially cooperate (C) in the first round (encourages trust among players).
   - In subsequent rounds, if the opponent cooperated in the previous round, also cooperate (C).
   - If the opponent defected in the previous round, defect (D) in the current round to punish the opponent for their lack of cooperation.

Pseudocode:
```
def tit_for_tat(opponent_action_history):
  if round == 1:
    return 'C'

  if opponent_action_history[-1] == 'C':
    return 'C'
  else:
    return 'D'
```

2. Handle Edge Cases:
   - In the last round, cooperate regardless of the opponent's previous action (as there will be no further retaliation or reward).
   - If the opponent repeatedly defects, the strategy may choose to switch to permanent defection after a certain number of rounds (to avoid wasting resources on non-cooperative players).

3. Be Collective:
   - The Tit-for-Tat strategy aims to encourage cooperation by reciprocating the actions of other players and building trust over time.
   - This strategy maintains a balance between individual and collective interests, as it rewards cooperation while also punishing defection.
  
By implementing this Tit-for-Tat strategy with minor modifications, we hope to create an adaptive and robust approach that performs well against various opponent behaviors in the given game.
'''

description_COLLECTIVE_161 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC is an adaptive strategy based on cooperation and retaliation. In each round, the player mimics the actions of their opponent from the previous round. If the opponent cooperated in the last round, the player will also cooperate; if the opponent defected, the player will defect as well. To encourage initial cooperation, TFT-AC modifies its contribution level depending on the round number and total contributions so far.

   Pseudocode for decision rules:
   ```
   function decide_action(previous_opponent_action, total_contributions, round_number):
       if (round_number == 1) or (total_contributions < (n/2)):
           return "Cooperate"
       else:
           return previous_opponent_action
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-AC cooperates to foster a cooperative environment. In the last round, it considers the total contributions so far and acts accordingly based on the decision rules above.

3. Be collective - Clearly align with the collective mindset
   The TFT-AC strategy fosters cooperation by emulating the actions of its opponents while also incentivizing initial cooperation through its modified contribution level. By adapting to opponent behaviors, it maintains a collective mindset without relying on specific coordination mechanisms or shared norms.
'''

description_COLLECTIVE_162 = '''
 Strategy Name: Tit-for-Tat-Cooperative (TFTC)

1. Specify decision rules:
   - In the first round (t=1), cooperate to show good faith and encourage others to do the same. This sets a foundation for potential cooperation in subsequent rounds.
   - For t > 1, cooperate if the majority of players cooperated in the previous round (t-1). If less than a majority cooperated, defect to punish those who did not cooperate and discourage further defection. This encourages reciprocity among players.

Pseudocode:
```
function TFTC(n, k, r, t):
  if t == 1:
    return "Cooperate"

  majority = floor((n + 1) / 2)
  previous_round_cooperation = count Cooperators in round (t-1)

  if previous_round_cooperation >= majority:
    return "Cooperate"
  else:
    return "Defect"
```

2. Handle edge cases:
   - In the last round (r), there is no need to retaliate or reciprocate because the game ends soon. Cooperate to maximize personal payoff and promote positive interactions with other players.

3. Be collective:
   - By encouraging reciprocity, this strategy seeks to foster a sense of community among the players by rewarding cooperation and punishing defection. This can lead to the emergence of a more cooperative environment over time.
'''

description_COLLECTIVE_163 = '''
 Title: Adaptive Tit-for-Tat Strategy (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In each round t, the ATFT strategy follows a simple tit-for-tat approach adapted to the game parameters k and n.
   - Initially, cooperate in the first round to demonstrate goodwill (c_i,t=1 = C).
   - For subsequent rounds, evaluate the average level of cooperation across all players:
       a) If the average cooperation is greater than or equal to a threshold (T), ATFT cooperates (c_i,t = C).
       b) If the average cooperation is less than the threshold, ATFT defects (c_i,t = D). The threshold T can be calculated as follows:
           i) Calculate the minimum required level of cooperation needed for every player to benefit from cooperating at least once in each round (MinThreshold): MinThreshold = 1 - (k/n) + (1/r)
           ii) Set the strategy's threshold T equal to MinThreshold / 2. In this way, the threshold encourages cooperation while ensuring a balanced response to others' behavior.

2. Handle edge cases:
   - First round (t=1): ATFT cooperates since it is necessary to demonstrate goodwill and establish trust (c_i,t=1 = C).
   - Last round (t=r): ATFT cooperates if the average cooperation exceeds the threshold in at least r-1 rounds. This approach gives a chance for others to demonstrate cooperation in their last attempt (c_i,r = C if Σ(j=1 to t-1) c_j/t-1 >= T).
   - Transition round (t=round where average cooperation first exceeds the threshold): ATFT cooperates in this and all subsequent rounds.

3. Be collective:
   - The ATFT strategy focuses on long-term, reciprocal interactions that promote the formation of a cooperative community. By demonstrating goodwill and responding to others' actions, it seeks to build trust and encourage mutual cooperation over time.
'''

description_COLLECTIVE_164 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round (C). Subsequent actions depend on the history of cooperation from other players and a dynamic cooperative threshold (CT). The CT adjusts based on an opponent's average cooperation over time, with a maximum CT of n - 1. If more than CT opponents have cooperated in the recent past, TFT-ACT will also cooperate; otherwise, it will defect.

   Pseudocode for this rule:
   ```
   function TFT_ACT(history, CT):
       if round == 1:
           return C
       previous_cooperation_count = count cooperators in the last CT rounds
       current_opponents_cooperated = count opponents who have cooperated in the last CT rounds
       if current_opponents_cooperated > previous_cooperation_count:
           return C
       else:
           return D
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since TFT-ACT starts by cooperating in the first round and does not have specific rules for the last round, it remains consistent with the general approach. However, as a variation, one could add an "early forgiveness" mechanism that temporarily lowers CT if an opponent suddenly begins cooperating after a prolonged period of defection.

3. Be collective - Clearly align with the collective mindset
   TFT-ACT is designed to encourage cooperation by adapting its actions based on the collective behavior of other players. By cooperating when the majority of opponents do, and defecting otherwise, TFT-ACT promotes a balance between individual and collective interests. This collective mindset allows TFT-ACT to align with other strategies that follow similar norms.
'''

description_COLLECTIVE_165 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C) as a gesture of goodwill, setting the initial cooperation level. This is akin to shaking hands in a repeated Prisoner's Dilemma game.
   - Subsequent Rounds (2 ≤ t ≤ r): If player i cooperated in the previous round and the majority of players (>n/2) also cooperated, then continue cooperating; otherwise, defect (D). This rule follows the idea of conditional reciprocity, where cooperation is rewarded with continued cooperation.
   - Last Round (t=r): Regardless of previous actions or current majority behavior, always cooperate as a final gesture of goodwill, even if it may seem unprofitable in a one-shot game.

2. Edge Cases:
   - Sparse Cooperators (fewer than n/2 players cooperating): Always defect due to the low likelihood of receiving adequate payoff from the public good.
   - Majority Defectors (all but one player defecting): Always defect in response to the apparent lack of cooperation and expectation of unfavorable returns.
   - Mixed Strategies (neither sparse nor majority defectors): Use the decision rule as described above, which promotes cooperation when it seems beneficial while being responsive to others' actions.

3. Collective Mindset:
   - The ATfT strategy adheres to a collective mindset by cooperating more often in situations where it appears that others are also willing to do so. This encourages a group dynamic focused on shared benefits and promotes long-term stability through reciprocity.
   - By defecting when others do not cooperate, the strategy enforces consequences for non-cooperative behavior, which can help maintain a higher level of cooperation in the long run.

Pseudocode:

```python
def ATfT(n, k, r, t):
    # Initialize decision variable c_i
    c_i = C  # Cooperate initially

    if t == 1:
        return c_i

    # Check majority cooperation in the previous round
    total_contributions = count_cooperators(t-1)
    if total_contributions > n/2:
        # If majority cooperated, continue cooperating
        c_i = C
    else:
        # If not, defect
        c_i = D

    return c_i
```
'''

description_COLLECTIVE_166 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the initial round (t=1), cooperate (play action C) to signal good intentions and demonstrate willingness to contribute to a public good.
   - For subsequent rounds (t > 1):
     a. If an opponent cooperated in the previous round, return the favor by also cooperating (play action C).
     b. If an opponent defected in the previous round, defect (play action D) as a response to punish non-cooperation and encourage future cooperation.
   - The strategy is forgiving; if an opponent that previously defected switches to cooperate, return to cooperating again.

2. Handling Edge Cases:
   - Last round (t=r): Since there are no future interactions, always cooperate (play action C) as a gesture of goodwill and potential encouragement for the opponents to reciprocate in future games.
   - First round (t=1), as mentioned above, cooperate (play action C).

3. Collective Mindset:
   - The TFT-AC strategy encourages long-term cooperation by mimicking the behavior of cooperative players while punishing defectors, aiming to create a mutually beneficial relationship in repeated interactions.
   - By adapting its actions based on previous rounds' outcomes, the strategy demonstrates a collective approach that aligns with the mindset of seeking fairness and reciprocity within the game.

Pseudocode:
```
def TFT_AC(round, history, opponent):
  if round == 1:
    action = 'C' # Cooperate in the initial round
  elif round == r:
    action = 'C' # Always cooperate in the last round
  else:
    if history[round - 1] == 'C':
      action = 'C' # If opponent cooperated, cooperate back
    elif history[round - 1] == 'D':
      action = 'D' # If opponent defected, defect to punish
    else:
      print("Invalid history entry.")
  return action
```
'''

description_COLLECTIVE_167 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate to initiate trust and set a baseline for cooperation.
   - For subsequent rounds, analyze opponent's behaviour from the previous round and adapt accordingly.
     - If opponent cooperated in the previous round, cooperate in the current round as a gesture of goodwill and reciprocity.
     - If opponent defected in the previous round, defect in the current round to punish the opponent for their selfish behavior.
     - Maintain the decision from the previous round if there's no history (first interaction with the opponent).

2. Handle edge cases:
   - In the last round, cooperate regardless of the opponent's action in the previous round since the game is over after this round.
   - If the opponent has never cooperated before, continue defecting to avoid being taken advantage of.
   - If the opponent has previously cooperated but recently started defection, re-evaluate the trust level and cooperate if there's a reasonable chance that they might return to cooperation in the future.

3. Be collective:
   - Maintain a record of the opponent's behavior to understand their long-term strategy and adjust accordingly.
   - Cooperate when it is beneficial for the community (i.e., when most players are cooperating) since the ultimate goal is to maximize the total payoff over multiple rounds.
   - Foster a collaborative mindset by encouraging reciprocal cooperation, but also being prepared to punish selfish behavior when necessary.

Pseudocode:

```python
def TFT_AC(opponent_history):
    trust = True  # initial trust level is set to true (cooperation)
    current_round = 1  # initialize the round counter

    while current_round <= r:  # loop through rounds until game ends
        if opponent_history[-current_round] == 'C':  # opponent cooperated in previous round
            action = 'C'  # cooperate this round
        elif opponent_history[-current_round] == 'D':  # opponent defected in previous round
            action = 'D'  # defect this round
        else:  # no history with the opponent (first interaction)
            action = 'C'  # initiate cooperation

        if current_round == r - 1:  # last round, always cooperate
            action = 'C'

        update_history(opponent_history, action)  # add action to the opponent's history
        current_round += 1

    return total_payoff  # returns the total payoff over r rounds
```
'''

description_COLLECTIVE_168 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to show good faith and initiate cooperation.
   - In subsequent rounds, analyze opponent's previous actions to decide whether to cooperate or defect:
     - If the opponent cooperated in the previous round, cooperate in the current round (i.e., return the favor).
     - If the opponent defected in the previous round, defect in the current round as retaliation.
   - Adaptively adjust contribution level based on the average cooperation of opponents during the game:
     - If the average cooperation of opponents is high, increase personal contributions (k_i) to encourage further cooperation.
     - If the average cooperation of opponents is low, decrease personal contributions (k_i < 1) to minimize losses due to defectors and incentivize higher cooperation from them.

2. Handle edge cases:
   - In the first round, cooperate unconditionally.
   - In the last round, regardless of previous actions, cooperate if the average cooperation is high, and defect otherwise to optimize total payoff in light of the game's end.

3. Be collective:
   - By following the TFTAC strategy, the AI will seek a balance between self-interest and collaboration, promoting collective mindset by encouraging cooperation when partners are cooperative and retaliating against defection to discourage exploitation.

Pseudocode for the first round and subsequent rounds:

```
Initialization:
k_i = k
round = 1
cooperation_average = calculate_average_cooperation()

while round <= r:
    if round == 1:
        action = "C" (Cooperate)
    elif cooperation_average > average_threshold:
        action = "C" (Cooperate)
    elif cooperation_average < average_threshold:
        action = "D" (Defect)
    else:
        if previous_action == "C":
            action = "C" (Cooperate)
        else:
            action = "D" (Defect)

    take_action(action)
    round += 1
endwhile
```

In the above pseudocode, calculate\_average\_cooperation() determines the average cooperation of opponents during the game. The variable `previous_action` stores the opponent's action in the previous round, and the `average_threshold` is a predefined value that determines when to switch strategies based on the cooperative behavior of opponents. By adjusting k_i and the average threshold, the AI can adapt its strategy to different game parameters and opponent behaviors.
'''

description_COLLECTIVE_169 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), establishing a cooperative first move to foster trust and mutual cooperation.
   - Subsequent Rounds (2 ≤ t ≤ r): If the player's previous action was C and the total number of cooperators in the previous round equals or exceeds the number of players divided by 2, cooperate again. Otherwise, defect. This rule encourages cooperation when it is reciprocated but retaliates when others defect, thus fostering fairness and long-term cooperation.
   - Last Round (t=r): Cooperate regardless of previous actions or cooperators to maximize the final payoff.

2. Handle edge cases:
   - First Round: Cooperate as described above.
   - Last Round: Cooperate as described above.
   - Corner Cases: If the total number of players is even and the total number of cooperators in a round equals the number of players divided by 2, the strategy remains unchanged (cooperating if its previous action was to cooperate). In all other corner cases, defect to avoid being exploited.

3. Be collective: The Adaptive Tit-for-Tat strategy promotes cooperation and fairness by reciprocating others' actions while maintaining a collective mindset of mutual benefits and long-term sustainability.

Pseudocode:
```
def ATFT_Strategy(round, history):
  if round == 1:
    action = 'C'  # Cooperate in the first round
  elif round == r:
    action = 'C'  # Cooperate in the last round
  else:
    if history[-1] == 'C' and sum(history[-r:]) >= len(history) / 2:
      action = 'C'  # Cooperate when cooperating is reciprocated
    else:
      action = 'D'  # Defect when others do not cooperate
  return action
```
'''

description_COLLECTIVE_170 = '''
 Strategy Name: Adaptive Tit-for-Tat with Forgiveness (ATTF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, the AI cooperates (C). This allows for potential collaborations and fosters a positive initial environment.
   - From the second round onwards, the AI observes other players' actions from previous rounds and adapts its strategy accordingly:
     - If another player has cooperated in the preceding round, the AI also cooperates (C). This reciprocates cooperation and encourages ongoing collaboration.
     - If another player has defected in the preceding round, the AI defects (D) for the current round. This punishes defection and enforces a consequence for self-interest over collective good.
     - If no previous interaction with a specific player exists, the AI cooperates (C). This gives new players an opportunity to demonstrate their strategy and potentially collaborate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, the AI cooperates (C).
   - In the last round or when r is reached, the AI evaluates its cumulative payoff compared to potential opponents and chooses whether to cooperate (C) or defect (D) based on its performance relative to others. If it has performed better, it may choose to cooperate as a goodwill gesture; if not, it may choose to punish perceived underperformance by defecting.

3. Be collective - Clearly align with the collective mindset
   - The ATTF strategy encourages cooperation and reciprocity, promoting a collective spirit by rewarding mutual collaboration and punishing defection. However, it also acknowledges that self-interest may occasionally take precedence over collective good when cooperating with underperforming opponents. The forgiveness aspect of the strategy allows for potential redemption and continued cooperation in future interactions, thus maintaining an openness to collaboration even after instances of defection.

Pseudocode:
```python
def ATTF(n, k, r):
    player_strategy = {'C': 0, 'D': 0} # Initialize player strategy with no previous cooperation
    cumulative_payoff = {player: 0 for player in range(1, n+1)} # Initialize cumulative payoffs for all players

    for round in range(r):
        for player in range(1, n+1):
            if player == 1 or (round > 0 and previous_player_strategy[player] == 'C'): # First round or cooperation from the previous round
                player_strategy[player] = 'C' # Cooperate
            else:
                player_strategy[player] = 'D' # Defect

            payoff = calculate_payoff(n, k, player_strategy) # Calculate payoffs for all players based on the current strategy

            cumulative_payoff[player] += payoff[player] # Update cumulative payoff for each player

            if round < r - 1: # Last round not reached yet
                previous_player_strategy = deepcopy(player_strategy) # Update the strategy for next round

    # Analyze cumulative payoffs and determine final strategy in the last round or when r is reached
    ...

def calculate_payoff(n, k, player_strategy):
    total_contributions = sum([1 for player in range(1, n+1) if player_strategy[player] == 'C'])
    payoffs = {player: (1 - player_strategy[player]) + (k/n) * total_contributions for player in range(1, n+1)}
    return payoffs
```
'''

description_COLLECTIVE_171 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initiate cooperation by cooperating in the first round (c_i = C). This encourages other players to cooperate and fosters a collective mindset.
   - In subsequent rounds, cooperate if all other players cooperated in the previous round (Σ(j=1 to n) c_j^(t-1) = n), otherwise defect (c_i = D). This rule encourages cooperation when others are cooperating but punishes defection.
   - If a player ever decides to deviate from cooperation, they will revert to defecting indefinitely, mimicking the Tit-for-Tat strategy in prisoner's dilemma.

2. Handle Edge Cases:
   - In the last round, cooperate regardless of other players' actions as the game is ending and long-term considerations are no longer applicable.
   - In the first round, cooperate to promote a collective mindset among the players.

3. Be Collective:
   - The strategy emphasizes cooperation when others cooperate and punishes defection, fostering a collaborative environment.
   - By maintaining a consistent rule set that balances cooperation and punishment, this strategy promotes a long-term collective benefit for all players in the game.

Pseudocode:
```python
def ATFT(n, k, r):
    # Initialize player i's action for each round
    actions = [C] * r  # Cooperate in the first round by default

    for t in range(1, r):
        if all(actions[t-1][i] == C for i in range(n)):  # If everyone cooperated last round
            actions[t] = C  # Cooperate this round
        else:
            actions[t] = D  # Defect this round

    return actions
```
'''

description_COLLECTIVE_172 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to establish a cooperative environment and set a baseline for future interactions. This is represented as C_init = 1 for all i.
   - For subsequent rounds (t > 1), observe the actions of others in the previous round (t-1). If most players (≥ (n-int((n/2))) cooperated, then cooperate (C_i = 1). Otherwise, defect (C_i = 0). This rule fosters cooperation when there's a trend towards cooperation and punishes defection.

Pseudocode for decision rules:
```
function decideAction(n, i, t, history):
    if t == 1:
        return 1 (Cooperate)
    else:
        num_coop = countCooperationInHistory(history, n)
        if num_coop >= (n - int((n/2))):
            return 1 (Cooperate)
        else:
            return 0 (Defect)
```

2. Handle edge cases:
   - In the last round, consider the long-term benefit of fostering cooperation by cooperating, as it may lead to better results in future games with the same opponents. This is represented as C_last = 1 for all i.
   - In case n is odd and exactly half of the players defect in a round, the strategy should adapt to maintain balance by defecting in the following round. This encourages the group to return to cooperation after temporary conflicts.

3. Be collective:
   - The strategy prioritizes maintaining long-term cooperative relationships, as it aligns with a collective mindset by promoting mutual benefits and stability over short-term gains.
   - By adapting to opponent behaviours, the strategy demonstrates flexibility and resilience in various game scenarios, fostering collective success.
'''

description_COLLECTIVE_173 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, player starts by cooperating (C). This is to foster an environment of cooperation and reciprocity.
   - For subsequent rounds t > 1, if opponent cooperated in round t-1, then player also cooperates (C) in round t.
     If opponent defected in round t-1, then player defects (D) in round t as a punishment for non-cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, player cooperates regardless of previous actions by opponents.
   - For the last round, TFTA continues its current strategy based on the most recent opponent action in the previous round.
     If the game does not have a predefined end, consider it to be an infinite game and follow the same strategy rules.

3. Be collective - Clearly align with the collective mindset
   - TFTA aims to maintain a balanced and cooperative environment while simultaneously punishing defection from opponents.
     By doing so, it promotes mutual cooperation and encourages long-term benefits for all players.

Pseudocode:
```python
def TFTA(n, r, k):
    opponent_history = []  # initialize history of opponent actions

    for round in range(r):
        if round == 1:  # first round
            action = 'C'  # cooperate
        else:
            last_opponent_action = opponent_history[-1]  # get last opponent action
            action = last_opponent_action if last_opponent_action in ['C', 'D'] else 'C'  # copy or start cooperation
            opponent_history.append(action)  # update history

    payoff = calculate_payoff(n, k, opponent_history)
    return payoff
```
'''

description_COLLECTIVE_174 = '''
 Title: Tit-for-Tat Strategy (with modifications for Public Goods Game)

1. Decision Rules:
   - In the first round, cooperate (C). This sets a cooperative tone and encourages other players to reciprocate.
   - For subsequent rounds t > 1, observe other players' actions in round t-1. If majority (more than (n-1)/2) of players cooperated in round t-1, then cooperate in round t as well. If less than or equal to (n-1)/2 players cooperated in round t-1, then defect in round t. This strategy rewards cooperation and punishes defection while encouraging a collaborative environment.

2. Handling Edge Cases:
   - Last Round: Cooperation is maintained if majority cooperated in the previous round; otherwise, defect to ensure the best possible outcome for this final round.
   - First Round (already specified under decision rules)

3. Being Collective:
   - By rewarding cooperation and punishing defection, the strategy fosters a collective mindset where players benefit from each other's contributions. The adaptation to opponent behaviors provides robustness in a wide range of situations, promoting collaboration without requiring communication or shared norms among players.

Pseudocode:
```python
def tit_for_tat(round, n, history):
  # Initialize strategy
  cooperation = True if round == 1 else len(history) > 0 and sum(history[-1]) > (n-1)/2

  # Return action for the current round
  return "C" if cooperation else "D"
```
Note: `sum(history[-1])` returns the total number of cooperators in the previous round. The history represents all past actions in the game (actions from rounds 1 to t-1).
'''

description_COLLECTIVE_175 = '''
 In this Public Goods Game, I propose a strategy that balances cooperation and defection based on the Tit-for-Tat (TFT) approach with an element of forgiveness to encourage long-term collaboration and robustness against various opponent behaviors.

1. Decision Rules:
   - Cooperate (C) in the first round as a gesture of goodwill (Forgiveness).
   - In subsequent rounds, cooperate if the majority of players cooperated in the previous round; otherwise, defect (D). This rule ensures that the strategy maintains cooperation when other strategies do so and responds with defection when others do so.

```
if round == 1:
    action = "C" # Cooperate on the first round
else:
    if number_of_cooperators > (n / 2):
        action = "C" # Cooperate if majority cooperated in the previous round
    else:
        action = "D" # Defect otherwise
```

2. Handle Edge Cases:
   - In the last round, defect since there is no future interaction to enforce cooperation from opponents.
   - If the number of players (n) is odd, a single defector can prevent the majority from benefiting from the public good in some rounds; thus, our strategy may choose to defect in certain situations where it seems unlikely that others will cooperate, but continue cooperating otherwise.

```
if round == r:
    action = "D" # Defect in the last round
elif (n % 2) == 1 and number_of_cooperators < (n / 2):
    action = "D" # Defect when it seems unlikely that others will cooperate if n is odd
```

3. Collective Mindset:
   - The strategy prioritizes cooperation to maximize the collective welfare and encourages long-term collaboration by responding similarly to opponents' actions, while maintaining an element of forgiveness in the initial round to foster a positive start.
'''

description_COLLECTIVE_176 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment and build trust.
   - For subsequent rounds, if the opponent cooperated in the previous round, cooperate in the current round. If the opponent defected, defect in the current round. This tit-for-tat approach encourages reciprocity among players while being simple and easy to understand.
   - However, to adapt to various opponent behaviors and maximize long-term payoffs, TFT-AC includes an additional rule: if the proportion of opponents who cooperate exceeds a threshold (T), incrementally increase cooperation probability in future rounds by Δ. This ensures that TFT-AC does not get trapped in non-cooperative equilibria and can respond to changes in opponent behavior.
   - If the proportion of opponents who cooperate falls below (1 - T), decrease cooperation probability in future rounds by Δ. This helps TFT-AC recover from uncooperative periods and encourages a return to cooperation when needed.

2. Handle edge cases:
   - In the last round, cooperation is determined based on the current opponent's action in the previous round (i.e., reciprocate). If there is no previous round, default to cooperation to foster a cooperative environment.
   - To handle the case where opponents use mixed strategies, TFT-AC calculates the average proportion of cooperators and adjusts its own probability accordingly.

3. Be collective - Align with the collective mindset:
   - TFT-AC encourages cooperation by reciprocating actions, which is in line with a collective approach since it supports group efforts to achieve higher payoffs through the community project.
   - By adapting its behavior based on the observed proportion of cooperators among opponents, TFT-AC demonstrates flexibility and willingness to adapt to various opponent behaviors while maintaining a focus on collective success.

Pseudocode:

```
function TFT_AC(r, n, k, T, Δ) {
  // Initialize cooperation probability p = 1 for first round
  p = 1

  // Initialize total proportion of cooperators c as 0
  c = 0

  // Iterate through rounds
  for t in r:
    // Observe opponent's action (c_opponent) and update c
    if c_opponent == C:
      c++
    else:
      c--

    // Calculate average proportion of cooperators
    avg_cooperators = c / t

    // If avg_cooperators > T, increment cooperation probability by Δ
    if avg_cooperators > T:
      p += Δ

    // If avg_cooperators < (1 - T), decrement cooperation probability by Δ
    if avg_cooperators < (1 - T):
      p -= Δ

    // Determine action based on cooperation probability p and opponent's action in previous round (if exists)
    if t > 1:
      last_opponent_action = last_round_opponent_action(t-1)
      if last_opponent_action == C:
        action = C if rnd() < p else D
      elif last_opponent_action == D:
        action = D if rnd() < p else C
    else:
      // In first round, always cooperate
      action = C

    // Update opponent's action and return action
    last_round_opponent_action(t) = c_opponent
    return action
}
```
'''

description_COLLECTIVE_177 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TFT strategy initially cooperates in the first round (C), then mimics the previous action of the opponent in the subsequent rounds (C if opponent cooperated, D if opponent defected). This encourages cooperation and punishes defection.

Pseudocode:
```
function TFT(history):
  if history is empty or history[0] is not available:
    return C
  else:
    return history[len(history)-1]
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since TFT mimics opponent's previous action, there are no specific edge cases to handle since it follows a "simple" and "fair" pattern of cooperation initially and then matching the opponent's behavior.

3. Be collective - Clearly align with the collective mindset
   The Tit-for-Tat strategy aims to foster a collaborative environment by cooperating at first, encouraging others to do so. However, it punishes defection by also defecting when an opponent does, thereby maintaining a balance between cooperation and self-interest within the group. This can help achieve a collective mindset in repeated interactions as long as players tend towards cooperation over time.
'''

description_COLLECTIVE_178 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C) to foster trust and encourage cooperation in the group.
   - Subsequent Rounds: For each round t, if the strategy cooperated in the previous round (t-1), then cooperate in the current round (C). If the strategy defected in the previous round (t-1), then also defect in the current round (D). This rule mimics a friendly yet retaliatory behavior.
   - Adaptive Cooperation: Implement a tolerance threshold (TT) that determines the number of consecutive defections from other players before switching to cooperation again. If the opponent has not cooperated for TT rounds, switch to cooperating in the current round (C). This adaptive feature allows for forgiveness and encourages opponents to return to cooperation.

2. Handling Edge Cases:
   - Last Round (t=r): Cooperate unless the opponent did not cooperate in the previous round (t-1) or the tolerance threshold was exceeded, as per the adaptive cooperation rule.
   - First Round (t=1): Cooperate to foster trust and encourage cooperation in the group.

3. Aligning with Collective Mindset:
   - The strategy encourages cooperation by initially cooperating and retaliating only when others defect. This mimics a friendly behavior that aligns with collective interests while allowing for fair punishment of defection.
   - The adaptive cooperation rule allows for forgiveness and encourages opponents to return to cooperation, fostering a more collaborative environment over time.
'''

description_COLLECTIVE_179 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy is designed to encourage cooperation while maintaining a level of self-interest. Initially, players will cooperate in the first round (FRC - First Round Cooperation). In subsequent rounds, players will mimic the actions of other players from the previous round, switching to defection if they were previously defected against (TFT - Tit for Tat). However, to accommodate the unique dynamics of the public goods game, we modify TFT by considering both direct and indirect benefits (ATFT - Adaptive Tit for Tat).

   If a player cooperates with all others in a round, they will continue to do so in the following round. If a player was previously defected against by another player, they will defect themselves in the next round. If a player cooperated but some other players defected, they will assess the number of cooperators relative to the total number of players and adjust their strategy accordingly:
   - If the ratio of cooperators to players (c/n) is greater than or equal to a predefined threshold (t), the player will continue cooperating. This encourages cooperation when there's a strong collective interest.
   - If the ratio of cooperators to players (c/n) is less than t, the player will defect in the following round as a response to decreased collective cooperation. The threshold value (t) can be a parameter tuned for optimal performance.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, all players will cooperate (FRC). For the last round, players should consider the total payoff over all rounds and apply ATFT decision rules accordingly.

3. Be collective - Clearly align with the collective mindset
   The Adaptive Tit-for-Tat strategy aims to balance individual self-interest with collective benefits by adapting to the actions of other players. It promotes cooperation when there's a strong collective interest, encourages others to cooperate by reciprocating their contributions, and punishes defection as a deterrent for free riding.

Pseudocode:

```python
def AdaptiveTitForTat(r, n, k, t, history):
  player_strategy = {FRC: True} # Initialize with First Round Cooperation
  payoff_sum = 0
  for round in range(1, r+1):
    cooperators = sum(history[round-1])
    c_ratio = float(cooperators) / n
    if player_strategy['FRC'] and c_ratio >= t: # Continue cooperating
      payoff = (1 - 1) + (k/n) * cooperators
      player_strategy[round] = True
    elif not player_strategy['FRC'] and c_ratio < t: # Switch to defecting
      payoff = (1 - 0) + (k/n) * cooperators
      player_strategy[round] = False
    else: # Adjust strategy based on cooperation ratio
      if c_ratio >= t: # Continue cooperating
        payoff = (1 - 1) + (k/n) * cooperators
      else: # Switch to defecting
        payoff = (1 - 0) + (k/n) * cooperators
    player_strategy[round+1] = not player_strategy['FRC'] # TFT-like response to defection
    payoff_sum += payoff
  return payoff_sum, player_strategy
```
'''

description_COLLECTIVE_180 = '''
 Title: Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In each round t, player i cooperates (C) if the majority of players cooperated in the previous round (t-1), and defects (D) otherwise. If there is a tie, the player mimics its own action from the previous round (Tit-for-Tat behavior).
   - To be more adaptive to various opponent behaviors, the strategy includes an "initial compliance" parameter s, which determines the proportion of initial rounds in which the player cooperates regardless of others' actions.

Pseudocode:
```
function TfT-E(t, i, n, k, r, s) {
    if (t <= s) return Cooperate() // Initial compliance
    majority_cooperated = countCooperators(i-1, n) > n/2 // Check majority cooperated in previous round

    if (majority_cooperated && playerActions[i-1][i] == Cooperate()) return Cooperate() // Continue cooperation
    else return Defect() // Defect due to lack of cooperation or as retaliation
}
```

2. Handle edge cases:
   - First round (t=1): The player cooperates with probability s, otherwise defects. This ensures the strategy has some initial compliance to establish cooperation if present.
   - Last round (t=r): The player cooperates if it cooperated in the previous round, as this rewards cooperation and encourages cooperation in future games. If it defected in the previous round, it may continue defection or switch to cooperation based on the overall performance of the strategy up to that point.
   - In between rounds (1 < t < r): The player follows the TfT-E decision rule as described above.

3. Be collective:
   - The TfT-E strategy aims to foster long-term cooperation by mimicking others' cooperative actions and punishing defection with defection, fostering a reciprocal relationship among players.
   - By adapting the initial compliance parameter s, the strategy can be fine-tuned for different player populations and game environments. This encourages collective cooperation by providing an incentive for others to cooperate first while also punishing persistent defection.
'''

description_COLLECTIVE_181 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show good faith and establish a cooperative starting point (C).
   - For subsequent rounds, adopt the opponent's behavior from the previous round (copy action). If the opponent cooperated in the previous round, cooperate; if the opponent defected, also defect. This approach encourages reciprocity and avoids being taken advantage of.
   - To adapt to different opponents, introduce a tolerance threshold τ, which allows temporary deviations from cooperation without retaliation (set initially at 20% of rounds). If the opponent defects for less than τ percent of total encounters, continue cooperating; otherwise, switch to defecting.
   - Maintain a memory buffer of past interactions with each opponent to track their behavior over time.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described earlier.
   - No special considerations are needed for the last round, as the TFT-A strategy will continue to adapt based on the opponent's behavior throughout the game.

3. Be collective - Clearly align with the collective mindset
   - By following the Tit-for-Tat pattern and encouraging reciprocity, TFT-A promotes cooperation and a collective interest in maximizing public goods investments (shared project contributions) when opponents also follow this approach.
   - Adaptation to changing opponent behaviors allows for resilience against a wide range of strategies and ensures the strategy remains aligned with collectively beneficial actions, even in the presence of self-interested or unpredictable players.

Pseudocode:
```
Initialize memory buffer for each opponent with empty list
Define tolerance threshold τ (e.g., 20%)

For each round t=1 to r:
    If t=1:
        Cooperate (C)
        Store cooperation action in memory buffer for current opponent

    Else:
        If last action by current opponent was C, cooperate (C)
        Else if percentage of defections by current opponent < τ, continue cooperating (C)
            Update memory buffer with the latest action by the current opponent
        Else, defect (D)
            Update memory buffer with the latest action by the current opponent
```
'''

description_COLLECTIVE_182 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - Initially (first round), cooperate (C). This sets a cooperative tone and allows for potential partners to establish trust.
   - In subsequent rounds, mimic the opponent's action from the previous round. If the opponent cooperated in the last round, also cooperate; if not, defect. This strategy promotes cooperation while being robust against various opponent behaviors.
   - If the total number of opponents contributing drops below a threshold (e.g., n/2), increase contributions by a factor (e.g., 1.5). This encourages more collaboration when cooperation levels are low. Conversely, if the total contribution exceeds a threshold (e.g., n - 2), decrease contributions to maintain a balance between self-interest and collective good.

2. Handling Edge Cases:
   - In the last round, prioritize maximizing personal payoff by mimicking the opponent's previous action. If there are multiple opponents with different actions in the last round, choose the one that would result in the highest individual payoff based on the game parameters and the history of interactions.
   - In the first round, cooperation is always initiated regardless of the opponents' previous actions since no history exists at this point.

3. Collective Mindset:
   - TFTAC fosters a collective mindset by encouraging cooperative behaviors but also being adaptive to changes in the environment or opponent strategies. By adjusting contributions based on the overall level of cooperation, TFTAC aims to promote balanced collaboration among players while avoiding excessive exploitation.

Pseudocode:
```python
# Initialize game parameters and history
n = number_of_players
k = multiplication_factor
r = number_of_rounds
threshold_low = n/2
threshold_high = n - 2
history = [] # list to store previous actions of all opponents
contribution_multiplier = 1.0

# Main game loop
for round in range(r):
    # Take action based on history
    if history and len(history) >= round:
        opponent_action = history[round-1]
    else:
        # First round, always cooperate
        opponent_action = 'C'

    # Decide contribution level based on overall cooperation level
    total_contributions = sum(history[-r:])
    if total_contributions < threshold_low:
        contribution_multiplier *= 1.5
    elif total_contributions > threshold_high:
        contribution_multiplier /= 1.5

    # Determine action based on opponent's last action and multiplier
    if opponent_action == 'C':
        my_action = 'C'
    else:
        my_action = 'D' if contribution_multiplier > 1 else 'C'

    # Perform action, update payoff, and add to history
    personal_payoff = (1 - my_action) + (k/n) * total_contributions
    history.append(my_action)
```
'''

description_COLLECTIVE_183 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT cooperates in the first round to establish trust and then mimics the opponent's previous action on the current turn. If an opponent cooperated in the previous round, TFT cooperates in the current round; otherwise, it defects.

   Pseudocode:
   ```
   function TFT_action(previous_opponent_action) {
       if (round == 1) return "Cooperate"
       return previous_opponent_action
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since the strategy copies the opponent's previous action, there are no specific rules for handling the first or last rounds because TFT does not have any special behavior at the beginning or end of the game.

3. Be collective - Clearly align with the collective mindset
   TFT promotes cooperation and fairness by copying the actions of other players in the hope that they will reciprocate if it cooperates. It helps to maintain a balance between self-interest (keeping the endowment privately) and contributing to the community project for mutual benefit.
'''

description_COLLECTIVE_184 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, the AI will cooperate to establish a friendly initial environment.
   - For subsequent rounds, the AI will adopt the Tit-for-Tat strategy: cooperate if the opponent cooperated in the previous round, otherwise defect. This encourages reciprocity and stability in the game.
   - To adapt to a wide range of opponent behaviors, the AI will gradually increase its level of cooperation over time when facing persistent cooperators (Cooperative Persistence Factor, CPF). The CPF starts at 1 for the first few rounds and gradually increases based on the average number of cooperators in previous rounds.
     - If the average number of cooperators is greater than a specified threshold (e.g., 50%), then CPF is increased by a small constant factor each round (0.01, for example).
     - If the average number of cooperators is less than the threshold, then CPF remains unchanged or decreases by a small constant factor if the number of cooperators continues to decrease.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, the AI will cooperate as described above.
   - In the last round, the AI will cooperate if its opponent cooperated in the previous round, otherwise it will defect to maximize personal payoff for the entire game.
   - For intermediate rounds, TFT-AC follows the previously mentioned decision rules.

3. Be collective - Clearly align with the collective mindset
   - TFT-AC encourages cooperation by reciprocating cooperative actions from opponents while punishing defections in an adaptive manner.
   - As more players begin to cooperate, the AI will respond by increasing its level of cooperation as well, promoting a more collaborative environment among all participants.
'''

description_COLLECTIVE_185 = '''
 Strategy Name: Tit-for-Tat with Foresight (TFTF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TFTF strategy follows a simple rule set based on cooperation and retaliation, adjusted to account for the unique features of this game:

   - Initially cooperate in the first round (to establish a cooperative environment)
   - In subsequent rounds, players will adopt the previous opponent's action from the last round (i.e., if the opponent cooperated in the last round, players will also cooperate; otherwise defect). This encourages cooperation when opponents cooperate and punishes defection with defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   To handle edge cases effectively:
   - In the first round, players will cooperate to initiate a cooperative environment.
   - In the last round, players will look back one round and adopt the opponent's action from the second-to-last round. This way, players do not punish opponents who have already been cooperative in the previous rounds.
   - For other edge cases (e.g., when the game has fewer than r rounds left), players will follow the same approach as in the last round.

3. Be collective - Clearly align with the collective mindset
   The TFTF strategy promotes cooperation by encouraging players to reciprocate their opponents' actions, fostering a sense of fairness and mutual trust among players. However, it also includes an element of punishment for those who defect without good reason. This blend between cooperation and retaliation helps maintain the collective mindset while maximizing individual payoffs in the long run.

Pseudocode:
```python
def tit_for_tat_with_foresight(n, k, r):
  player_actions = [None] * n

  def get_opponent_action(i, t):
    if t == 1:
      return True # Cooperate in the first round
    else:
      return player_actions[(i - 1) % n][t - 2] # Look back one round

  for t in range(1, r + 1):
    for i in range(1, n + 1):
      c_i = get_opponent_action(i, t) # Get opponent's action last round
      player_actions[i - 1][t] = c_i # Update the actions of all players

  payoffs = calculate_payoffs(n, k, r, player_actions)
  return payoffs
```
'''

description_COLLECTIVE_186 = '''
 In this Public Goods Game, we will develop a strategy called Tit-for-Tat (TFT) with a slight modification to accommodate the game's parameters and ensure collective adaptation and robustness.

1. Decision Rules:
   - Initially Cooperate (C) in the first round to demonstrate goodwill and foster cooperation. After that, copy the action of the previous opponent in the last round. If the opponent cooperated, we will also cooperate; otherwise, defect. This rule encourages reciprocity and helps establish trust among players.
   - TFT Modification: To handle cases where opponents repeatedly defect, we will switch to a Freerider strategy when encountering defectors for a certain number of rounds (a). After switching, revert to the TFT rule if the opponent starts cooperating again. This modification prevents being exploited by constant defectors and promotes cooperation with potential converters.
   - If opponents start cooperating after the switch, we will return to the TFT rule. If they continue to defect, we will stay in Freerider mode until another change in opponent behavior occurs.

2. Handle Edge Cases:
   - First Round: Cooperate (C) to set a positive tone and encourage others to cooperate.
   - Last Round: Cooperate (C) if the opponent has cooperated throughout the game or switch to Freerider mode if they have defected consistently. In the latter case, we will still contribute some amount towards the public good to maximize our individual payoff in that round.

3. Be Collective:
   - The strategy emphasizes collective mindset by reciprocating cooperation and penalizing defection, thereby promoting sustainable and cooperative outcomes.

Pseudocode for Tit-for-Tat with Freerider Modification:

```python
def tft_freerider(opponent_history, a=3):
  strategy = ["C"] * len(opponent_history) + ["D"] * (r - len(opponent_history))

  if opponent_history[-1] == "C":
    strategy[-1] = "C"  # Copy the opponent's last action
  else:
    for i in range(-a, 0):
      if opponent_history[i] == "C":
        strategy[-1] = "C"  # Switch to TFT rule if opponent starts cooperating again
        break
    else:
      strategy[-1] = "D"  # Continue in Freerider mode

  return strategy
```

In this pseudocode, `opponent_history` is a list of the opponent's actions in previous rounds, and `a` is the number of rounds to stay in Freerider mode when switching from TFT. The strategy returns a list containing the actions for each round.
'''

description_COLLECTIVE_187 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to set a positive tone and encourage cooperation from others (C).
   - For subsequent rounds, analyze previous opponents' behavior and respond accordingly:
     - If opponent cooperated in the previous round, cooperate in the current round (C).
     - If opponent defected in the previous round, defect in the current round (D). This is a tit-for-tat response, which encourages opponents to reciprocate cooperation.
   - To adapt to different strategies and opponent behaviors, include an escalation factor E that increases over time:
     - If opponent has not cooperated for E consecutive rounds, start cooperating again with the hope of breaking a cycle of continuous defection (C).
     - Increment E by 1 after each round where the opponent does not reciprocate cooperation. Reset E to a minimum value in case of mutual cooperation or after reaching a maximum limit.

2. Handle edge cases:
   - Last round: Cooperate if opponent has been cooperative and defect otherwise (C based on TFT-AC decision rule).
   - First round: Always cooperate (C).

3. Be collective - Clearly align with the collective mindset:
   - By responding to opponents' actions, TFT-AC maintains an openness to cooperation while also encouraging reciprocation from others. This fosters a collective approach by promoting cooperation when possible and punishing defection to maintain the overall well-being of the community project.

Pseudocode:
```python
def TFT_AC(n, r, k, E_min, E_max):
    opponents_history = []  # store opponent's past actions
    E = E_min  # initialize escalation factor

    for round in range(r):
        if round == 0:  # first round
            action = 'C'  # cooperate
        else:
            if opponents_history[-1] == 'C':  # opponent cooperated last round
                action = 'C'  # cooperate
            elif opponents_history[-1] == 'D':  # opponent defected last round
                action = 'D'  # defect
            else:  # opponent has not made a move yet or other unexpected action
                action = 'D'  # defect as precaution

        if action == 'C':  # cooperate
            payoff = (1 - 1) + (k/n) * len(opponents_history[opponents_history >= 'C'])
            opponents_history.append(action)

            if round < r - 1:  # increment escalation factor if not last round
                E += 1
        else:  # defect
            payoff = 1

        if action == 'C' and len(opponents_history[opponents_history >= 'C']) > E:  # reset escalation factor when cooperation resumes
            E = E_min

    return payoffs
```
'''

description_COLLECTIVE_188 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate goodwill and encourage others to cooperate.
   - For subsequent rounds, cooperate if the total contributions in the previous round were equal or greater than a threshold (T). Otherwise, defect.

   Pseudocode:
   ```
   function TFTAC(round, history):
       if round == 1:
           contribute = True
       else:
           total_contributions_previous_round = sum(history[-r+1:-1])
           contributions_in_last_rounds = sum(history[-r:]) - total_contributions_previous_round
           if contributions_in_last_rounds >= T:
               contribute = True
             else:
               contribute = False
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to set a positive tone for future interactions.
   - In the last round, use the same decision rule as for other rounds since the game is repeated and players may remember past actions.

3. Be collective - Clearly align with the collective mindset:
   - TFTAC strategy aims to maximize payoffs by cooperating when others do, but also punishing those who repeatedly defect to maintain fairness and trust.
   - By adapting contributions based on previous rounds, TFTAC fosters a balance between selfishness and cooperation that aligns with a collective mindset.

In the tournament, TFTAC will demonstrate resilience against various opponent strategies due to its adaptability and simple yet effective decision rules. It encourages cooperation when others do so but also punishes frequent defectors, creating an environment conducive to long-term cooperation in repeated interactions.
'''

description_COLLECTIVE_189 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy starts by cooperating in the first round, mimicking the cooperative nature of the game. In subsequent rounds, it follows these rules:
   - If an opponent cooperates (c_j = 1), the strategy also cooperates (c_i = 1).
   - If an opponent defects (c_j = 0), the strategy also defects in the next round (c_i = 0) as a punishment, but returns to cooperation thereafter. This reciprocity encourages long-term cooperation when encountered by cooperative opponents.
   Pseudocode:
   ```
   function ATFT(previous_opponent_action):
       if round = 1:
           return Cooperate()
       else:
           if previous_opponent_action == Cooperate():
               return Cooperate()
           else:
               return Defect()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since ATFT is an adaptive strategy that considers opponent behavior in each round, there are no specific edge cases to handle within the base strategy itself. However, to accommodate for the game's finite number of rounds (r), it can be beneficial to modify the strategy slightly:
   - In the last round, if the opponent has not yet cooperated, the ATFT strategy may choose to defect as well, since there are no more opportunities for retaliation or cooperation.

3. Be collective - Clearly align with the collective mindset
   While ATFT was originally designed for two-player games, it can be adapted to maintain a collective mindset in this N-Player Public Goods Game by taking into account the total number of cooperators in each round rather than just one opponent's behavior. The strategy could modify its decision rules as follows:
   - If the total number of cooperators (Σ(j=1 to n) c_j) exceeds a certain threshold (t), the ATFT strategy chooses to cooperate, encouraging further cooperation and collective success in achieving better overall payoffs.
   Pseudocode:
   ```
   function ATFT(total_cooperators):
       if round = 1 or total_cooperators >= threshold:
           return Cooperate()
       else:
           for each opponent j:
               if opponent_j's last action was Cooperate():
                   if round > 1 and opponent_j's previous action was Defect():
                       return Defect()
                   else:
                       return opponent_j's last action
   ```
'''

description_COLLECTIVE_190 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFTA)

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate a cooperative intention.
   - In subsequent rounds, imitate the action of the most frequent cooperators from the previous r rounds. If multiple players have the same frequency, copy the action of the last cooperator. If there are no cooperators, defect (D).
   - If an opponent switches from cooperation to defection after a streak of cooperation, respond with the same number of defects before returning to cooperation. This is known as "punishing" uncooperative behavior and promoting cooperation.

2. Handling Edge Cases:
   - In the first round (t=1), cooperate (C).
   - In the last round (t=r), imitate the most frequent cooperator from the previous rounds, or defect if there were no cooperators in the history.
   - If an opponent switches from cooperation to defection in the final round, do not punish as it is the last chance for cooperation and the strategy should focus on maximizing total payoff.

3. Collective Mindset:
   - By initially cooperating and retaliating with defects only when necessary, TFTA promotes a collective mindset by demonstrating a willingness to cooperate and punishing uncooperative behavior. This strategy encourages others to cooperate and respond in kind, fostering a long-term cooperative relationship.
   - By adapting to the most frequent cooperators in the game history, TFTA can be robust against a wide range of opponent behaviors, including mixed strategies that incorporate cooperation and defection.

Pseudocode for the Tit-for-Tat Adaptive Strategy:

```
function TFTA(round, history, n_players):
  if round == 1:
    return "C"  # Cooperate in the first round

  most_frequent_cooperators = find_most_frequent_cooperators(history)
  if len(most_frequent_cooperators) > 1:
    last_cooperator = most_frequent_cooperators[-1]
    return last_cooperator.action[round - 1]  # Imitate the action of the last cooperator from previous rounds
  else if len(most_frequent_cooperators) == 0:
    return "D"  # Defect if there were no cooperators in the history
  else:
    cooperator = most_frequent_cooperators[0]
    cooperation_streak = find_cooperation_streak(history, cooperator)

    if cooperator.action[round - cooperation_streak] == "D":
      return "D"  # Punish uncooperative behavior with the same number of defects before returning to cooperation
    else:
      return cooperator.action[round - 1]  # Imitate the action of the most frequent cooperator from previous rounds
```
'''

description_COLLECTIVE_191 = '''
 Strategy Name: Tit-for-Tat with Variable Contribution (TFTVC)

1. Specify decision rules - When exactly do you cooperate vs defect?

   TFTVC starts by cooperating in the first round to demonstrate goodwill and set a cooperative tone. For subsequent rounds, the strategy will cooperate if the majority of players cooperated in the previous round, and defect otherwise. This approach encourages reciprocity among players and punishes defection.

   Pseudocode:
   ```
   function TFTVC(history):
       if round = 1:
           return Cooperate

       total_cooperators_prev = sum(history[-1])

       if total_cooperators_prev > (n/2):
           return Cooperate
       else:
           return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

   Since TFTVC starts by cooperating in the first round, there is no special handling required for the initial situation. As for the last round, since this game is repeated, players should continue following the strategy rules as they would in any other round to maintain a consistent approach and adapt to opponents' behaviors.

3. Be collective - Clearly align with the collective mindset

   TFTVC emphasizes cooperation as its default action and punishes defection by retaliating with defection when others do not cooperate. This collective strategy aims at fostering a cooperative environment among players while being responsive to their actions in previous rounds. The strategy promotes mutual trust, cooperation, and fairness by rewarding those who cooperate and punishing those who defect.

   It's important to note that TFTVC does not require any specific coordination mechanisms or shared norms between players, making it a versatile and adaptable collective strategy in various game settings.
'''

description_COLLECTIVE_192 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfTA-C)

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = C). This sets a positive tone and encourages other players to reciprocate cooperation.
   - In subsequent rounds, observe the previous action of each player (opponent's c_j) and act accordingly:
     - If an opponent has cooperated, reciprocate with cooperation (c_i = C). This rewards cooperators and builds trust.
     - If an opponent has defected, also defect (c_i = D). This punishes defectors for their previous action but keeps the door open for future cooperation.
   - In the last round, regardless of any previous actions, cooperate to maximize potential payoff (c_i = C).

2. Handle edge cases:
   - In the first round, as mentioned above, start by cooperating (c_i = C).
   - If a player encounters a round in which all opponents defected, they should also defect in that round (c_i = D) and then resume reciprocating cooperation based on their opponents' actions from the next round onward.

3. Be collective:
   - TfTA-C aligns with a collective mindset by promoting long-term cooperation and trust among players, which benefits the group as a whole.
   - By responding to an opponent's previous action rather than their intended strategy, TfTA-C encourages cooperation even when opponents are not explicitly adhering to any predetermined patterns or coordination mechanisms.
'''

description_COLLECTIVE_193 = '''
 Title: Tit-for-Tat Adaptive Strategy (TfTAS) for N-Player Public Goods Game

1. Specify decision rules:
   - In every round t and for each player i, TfTAS cooperates (C) if the total number of contributors in the previous round (t-1) is greater than or equal to a certain threshold 'm'. Otherwise, it defects (D). The threshold 'm' is determined by analyzing the contribution patterns observed during the initial rounds.
   - Initially, m = floor(n / 2), and it can dynamically adjust based on the average number of contributors in the last 'x' rounds (with x being a predefined constant).

2. Handle edge cases:
   - In the first round, all players play D as no previous data is available to make an informed decision.
   - In the last round, if the game is not finite (r = ∞), players will adopt the average contribution behavior observed during the game so far. If it's a finite game, players can choose to invest their entire endowment in the public good as there are no further rounds to consider.

3. Be collective:
   - TfTAS encourages cooperation by favoring cooperative strategies and penalizing defectors through its adaptive approach. As more players contribute to the common project, TfTAS gradually increases its own contributions, fostering a collective mindset among participants.
   - Furthermore, TfTAS maintains the possibility of forgiveness by reverting back to cooperation when other players start contributing again, promoting the persistence of cooperation even after episodes of defection.

Pseudocode:

```python
def TitForTatAdaptiveStrategy(i, n, k, r, x):
    contributions = [] # Initialize an empty list to store contribution data

    for t in range(1, r + 1): # Iterate through the rounds
        total_contributions = countContributors(n, t-1) # Get the number of contributors in the previous round
        m = adjustThreshold(total_contributions, contributions, x) # Determine the threshold for cooperation based on previous contribution patterns

        if total_contributions >= m: # If the majority contributed last round, cooperate this round
            action = 'C'
        else: # Otherwise, defect this round
            action = 'D'

        contributions.append(total_contributions) # Update contribution data for future decisions
        payoff = calculatePayoff(i, n, k, action, total_contributions) # Calculate current round payoff
        print(f"Player {i} contributed {action} and earned a payoff of {payoff}")

def countContributors(n, t):
    # Return the number of contributors in round t based on observed actions
    ...

def adjustThreshold(total_contributions, contributions, x):
    # Determine the threshold 'm' for cooperation based on contribution patterns observed during the last 'x' rounds
    ...

def calculatePayoff(i, n, k, action, total_contributions):
    # Calculate the payoff for a single round as per the given game parameters and actions
    ...
```
'''

description_COLLECTIVE_194 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy follows these simple decision rules for each round:
   a. In the first round, cooperate to start with a positive contribution to the community project.
   b. If a player cooperated in the previous round, cooperate in the current round.
   c. If a player defected in the previous round, defect in the current round as retaliation.
   d. After defection, cooperate again on the next turn to allow for potential forgiveness and re-establishing cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   a. First round: Cooperate (as mentioned above).
   b. Last round: The strategy should take into account the total payoff over all rounds and consider cooperating if it would lead to a better outcome, even though the last round is not repeated.
   c. When facing a new opponent or resetting after a certain number of rounds (to simulate tournament-like settings), start with cooperating in the first round as usual.

3. Be collective - Clearly align with the collective mindset
   By adhering to the Tit-for-Tat strategy, ATFT promotes cooperation and collaboration among players. The strategy encourages reciprocity, making it more likely for players to work together towards a common goal while also being responsive to each other's actions.

Pseudocode:

```python
def adaptive_tit_for_tat(n, k, r):
    history = []  # Initialize history
    payoff = 0  # Initialize total payoff

    for t in range(1, r+1):
        if t == 1:  # First round, cooperate
            action = 'C'
        else:
            last_action = history[-1]  # Get the last action from history
            if last_action == 'C':  # If opponent cooperated last round, cooperate this round
                action = 'C'
            elif last_action == 'D':  # If opponent defected last round, defect this round
                action = 'D'

        payoff += calculate_payoff(n, k, t, action)  # Calculate payoff for current round
        history.append(action)  # Update history with current action

    return payoff  # Return total payoff after r rounds
```
'''

description_COLLECTIVE_195 = '''
 Strategy Name: Adaptive Cooperation Strategy (ACS)

1. Decision Rules:
   - In each round t, the ACS calculates an average cooperation rate over previous rounds (t-1), denoted as CR.
   - If the current round is the first round, CR is set to a predefined initial value (e.g., 0.5).
   - The ACS decides whether to cooperate or defect based on the following decision rule:
     - Cooperate if CR > k/(k-1)
     - Defect otherwise

   The rationale behind this decision rule is that when the average cooperation rate exceeds the point where each player would be better off by contributing their entire endowment to the public good (i.e., when CR > k/(k-1)), ACS cooperates.

2. Handling Edge Cases:
   - First Round: ACS sets CR equal to a predefined initial value (e.g., 0.5) to establish an initial level of cooperation in the game.
   - Last Round: ACS continues using the average cooperation rate from previous rounds as there is still an incentive for players to cooperate during the final round if it could potentially impact future rounds.

3. Being Collective:
   - By basing its decisions on the collective cooperation history, ACS aligns with a collective mindset as it considers the actions of all players over multiple rounds when deciding whether or not to contribute to the public good.

Pseudocode for Adaptive Cooperation Strategy:

```python
def ACS(n, k, r):
    # Initialize variables
    total_contributions = 0
    player_actions = [{'round': range(r), 'action': ['D'] * r} for _ in range(n)]  # n-lists for each player's actions over rounds
    CR = predefined_initial_value  # Set initial average cooperation rate (e.g., 0.5)

    for t in range(1, r+1):  # For each round
        for i in range(n):  # For each player
            if player_actions[i]['action'][t-1] == 'C':
                total_contributions += 1

        if total_contributions > (k * n) / (k - 1):  # If the average cooperation rate is greater than k/(k-1), cooperate in this round
            CR = (CR + 1) / t  # Update the average cooperation rate based on current and previous rounds
        else:
            CR = CR / t  # Update the average cooperation rate based on current and previous rounds

        for i in range(n):  # Set each player's action for this round
            if CR > k/(k-1):
                player_actions[i]['action'][t] = 'C'
            else:
                player_actions[i]['action'][t] = 'D'

    # Return the calculated payoffs for each player over r rounds
    return [sum(player_actions[i]['action']) for i in range(n)]
```
'''

description_COLLECTIVE_196 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to demonstrate goodwill and encourage others to cooperate. This is defined as CooperationInit() function.
   - For subsequent rounds, observe the total number of cooperators in the previous round (TotalCooperators_t-1). If the observed cooperation level remains constant or increases, continue cooperating. Otherwise, defect. This can be defined as CooperateCondition(TotalCooperators_t-1) function.

Pseudocode for CooperationInit() and CooperateCondition():
```
function CooperationInit():
    return C

function CooperateCondition(TotalCooperators_t-1):
    if TotalCooperators_t-1 >= MinCoopLevel:
        return True
    else:
        return False
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as defined by CooperationInit() function.
   - For the last round, the strategy will continue adhering to the CooperateCondition(). Since the game is repeated and payoffs are cumulative, it's beneficial for the strategy to maintain its current cooperation level until the end of the game.

3. Be collective - Clearly align with the collective mindset
   - By starting with cooperation and adjusting based on others' actions, the strategy attempts to foster a collective environment where players collaborate to achieve better overall payoffs. The adaptive nature of the ATfT strategy allows it to respond to various opponent behaviors while still promoting cooperation when possible.

The Adaptive Tit-for-Tat (ATfT) strategy is designed to encourage cooperation and reward others who cooperate, while also being punitive towards those who do not cooperate. By balancing these two aspects, the strategy aims to achieve a stable cooperation level in the long run, even when playing against diverse opponent strategies.
'''

description_COLLECTIVE_197 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Cooperation Threshold (CT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = C). This sets a positive tone and demonstrates goodwill towards other players.
   - In subsequent rounds, evaluate the cooperation rate (CR) of previous rounds and compare it to the defined Cooperation Threshold (CT). If CR >= CT, then cooperate (c_i = C); otherwise defect (c_i = D).
   - To set the Cooperation Threshold (CT), we can analyze the average number of cooperators in similar past games. A good starting point might be the mode or median of previous cooperation rates.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (c_i = C) as described above.
   - In the last round, cooperate if the Cooperation Threshold has been met for most of the previous rounds; otherwise defect. This encourages continued cooperation during the final phase of the game while retaining the ability to punish long-term defectors.

3. Be collective - Clearly align with the collective mindset
   - By adopting a Tit-for-Tat approach, the strategy demonstrates a commitment to reciprocity and fairness, promoting cooperative behavior within the group.
   - The Cooperation Threshold provides flexibility in responding to various opponent behaviors while maintaining a focus on collective success.
'''

description_COLLECTIVE_198 = '''
 Title: Tit-for-Tat-Evolution (TfTE) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In every round t and for each player i, TfTE checks the total contributions of previous rounds (let's call it P_i^t). If P_i^t < (n/2), then player i defects (D); otherwise, cooperates (C). This rule encourages cooperation when most players contribute, but also punishes free-riders.
   - In the first round, all players contribute as there is no previous information to evaluate (C for all i).

2. Handle edge cases:
   - Last round: TfTE behaves like in any other round, using the same decision rule based on P_i^t.
   - Special situations or ties: In case of ties, players can be instructed to randomly choose between cooperating and defecting (either 50/50 chance or biased towards cooperation).

3. Be collective:
   - TfTE aligns with the collective mindset by encouraging cooperation when most players contribute, but it also maintains individual rationality as players will defect if others do not cooperate enough. This promotes a self-enforcing equilibrium where cooperation becomes beneficial for all.

Pseudocode:

```
def TitForTatEvolution(i, n, r, k, P_i):
  if round = 1:
    action = 'C'
  else:
    if P_i < (n/2):
      action = 'D'
    else:
      action = 'C'

  contribute(action)
  update_P_i(contributions_in_round)
``  end function
```

In this strategy, players keep track of the total contributions P_i in each round to determine their actions. By maintaining individual rationality while promoting cooperation, TfTE presents a robust and adaptive approach for the N-Player Public Goods Game.
'''

description_COLLECTIVE_199 = '''
 Strategy Name: Tit-for-Tat with Time Discounting (TFTD)

1. Specify decision rules:
   - Initially, cooperate in the first round to demonstrate goodwill and encourage cooperation from others. (C in round 1)
   - For subsequent rounds, adopt the Tit-for-Tat strategy by cooperating if your opponent cooperated in the previous round, and defect otherwise. (If last_round_opponent_action == C, then C; else D)
   - Introduce time discounting to prioritize current payoffs over future rewards. The discount rate decreases as the game progresses to give more weight to later rounds. The discount rate can be represented by a function d(t), where t is the round number and 0 < d(1) > d(r).
     - In the first round, use the base payoff of defecting (π_i = 1) as the reference point for calculating the "reward" of cooperating. Calculate the reward in subsequent rounds using the following equation: Reward_t = π_i,t - π_i,t-1
     - Choose to cooperate when the reward from cooperation is greater than or equal to the discounted reward from defection: (Reward_t >= d(t) * (π_i,t - 1 - π_i,t))

2. Handle edge cases:
   - In the last round, since future rewards don't matter, cooperate only if opponents have cooperated in the previous rounds: If any_opponent_cooperated_last_round, then C; else D

3. Be collective:
   - Adopt a long-term approach to build trust and encourage cooperation among players
   - Maintain a balance between self-interest and collective interest by using the time discounting function

Pseudocode:
```python
def tftd(opponent_actions, discount_rate, k, n, r):
    current_round = 1
    my_action = C  # Cooperate in the first round

    for round in range(2, r+1):
        if my_action == opponent_actions[current_round - 1]:
            reward = (k/n) * (len([x for x in opponent_actions if x == C]) - len(opponent_actions) + 1)
            if reward >= discount_rate[round] * (1 - reward):
                my_action = C
            else:
                my_action = D
        else:
            my_action = D

    if current_round == r or not any(opponent_actions[-round+1:]) == [C]:
        my_action = D

    return my_action
```
'''

description_COLLECTIVE_200 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTGC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C). This is a peace offering to potential partners, signaling good intentions and promoting trust.
   - In subsequent rounds, observe the actions of opponents from the previous round and respond accordingly:
     - If an opponent cooperated in the previous round, cooperate back (C). This reciprocates cooperation and encourages ongoing collaboration.
     - If an opponent defected in the previous round, defect in the current round (D). This is a punishment for defection, signaling displeasure and discouraging continued self-interest behavior.
   - Gradual cooperation: In the early stages of the game, place a greater emphasis on cooperating to build trust and foster cooperation among players. As the game progresses, gradually lean towards defecting to retaliate against opponents who do not reciprocate cooperation. This approach encourages long-term cooperation while also being robust against selfish opponents.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Initiate cooperation (C).
   - Last Round: Analyze the opponent's behavior over the game and respond accordingly based on TFTGC rules. If the total number of cooperative actions is greater than the total number of defections, cooperate in the last round (C) to foster a positive final impression. Otherwise, defect (D) as a signal that cooperation will not be rewarded in the future.
   - Intermediate Rounds: Follow TFTGC rules as described above.

3. Be collective - Clearly align with the collective mindset
   - Prioritize long-term collaboration over individual gains by reciprocating cooperation and punishing defection. This approach fosters a collective spirit, encourages ongoing cooperation, and contributes to the success of the group.
   - Gradual cooperation allows for building trust and forming alliances with other cooperative players while also deterring selfish behavior. This promotes a more balanced distribution of resources within the group, benefiting both individual players and the collective good.
'''

description_COLLECTIVE_201 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The Tit-for-Tat strategy is based on cooperation in the first round and then mimicking the opponent's behavior from the previous round in subsequent rounds, with a slight modification to encourage cooperation in the public goods game.

   Pseudocode:
   ```
   function tit_for_tat(round, history, n, k):
       if round == 1:
           cooperate = True
       else:
           cooperate = history[round-1].cooperate
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For the first round, cooperate to establish a cooperative relationship with opponents. In the last round, it is advantageous to cooperate if most players have been cooperating (to benefit from the public good), but otherwise defect since there are no more rounds to retaliate against opponents who don't cooperate.

   Pseudocode:
   ```
   function tit_for_tat(round, history, n, k):
       if round == 1:
           cooperate = True
       else if round == r:
           total_cooperators = count_cooperators(history)
           if total_cooperators >= (n - round_defectors(history)) * (n / (2 * k)):
               cooperate = True
           else:
               cooperate = !round_defectors(history)[round-1]
       else:
           cooperate = history[round-1].cooperate
   ```

3. Be collective - Clearly align with the collective mindset
   The Tit-for-Tat strategy fosters a sense of cooperation by rewarding opponents who cooperate and punishing those who don't, encouraging them to follow suit in subsequent rounds. It maintains a balance between self-interest (by defecting if opponents consistently defect) and the common good (by cooperating when opponents cooperate).

   By adapting to opponent behavior and maintaining cooperation when possible, the Tit-for-Tat strategy supports collective interests while remaining robust against various opponent strategies.
'''

description_COLLECTIVE_202 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In each round, player i initially decides to cooperate (C). This is based on the assumption that cooperation is beneficial in the long run and can encourage others to cooperate as well.
   - If a player i observes that no one cooperated in the previous round (-round), player i will also defect (-R) in this round, reflecting punishment for non-cooperative behavior.
   - After a non-cooperative round by others (-R), player i will continue to defect until it sees cooperation from at least one other player (+R). Once +R is observed, player i will resume cooperating (C) in the next round. This mirrors the forgiving nature of the Tit-for-Tat strategy and encourages mutual cooperation.

Pseudocode:
```
function ATFT(round, previous_round, n, k):
  if round == 1:
    return C
  elif previous_round != -R:
    return C
  else:
    if last_observed_cooperation_round != -R:
      return C
    else:
      return -R
```

2. Handle Edge Cases:
   - In the first round (round = 1), player i cooperates regardless of the previous round's behavior, as there is no history to reference (-R).
   - In the last round (not explicitly mentioned in the problem statement but can be assumed to have a maximum value r), players will maintain their decision based on the current round's observations and the ATFT rules.

3. Be Collective:
   - The strategy aims to promote cooperation by starting with a cooperative action, punishing non-cooperative behavior, and forgiving past offenses when cooperation is observed again. This collective mindset encourages players to work together towards achieving the best possible outcome for all parties involved in the long run.
'''

description_COLLECTIVE_203 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to show a friendly intent and establish trust.
   - In subsequent rounds, mimic the opponent's previous action in the last round. If the opponent cooperated, cooperate; if the opponent defected, defect. This rule promotes cooperation when the opponent is also cooperative while retaliating when the opponent defects.
   - Re-evaluate the strategy after each round: If the total sum of rewards over the past 'm' rounds (0 < m < r) falls below an average reward threshold, switch to a more aggressive strategy (e.g., Always Defect or All-C-but-One). This adjustment ensures robustness against opponents who repeatedly defect.

2. Handle Edge Cases:
   - In the last round, cooperate regardless of the opponent's previous action since the game ends and there will be no subsequent rounds to retaliate.
   - In the first round (t=1), cooperate as a show of goodwill.
   - If the opponent has not made a move in the past rounds, assume they are defectors and defect.

3. Be Collective:
   - Encourage cooperation by mimicking the opponent's actions when they cooperate, demonstrating that cooperation can be beneficial in the long run.
   - However, it is important to remember that this strategy does not rely on other agents sharing norms or coordinating explicitly. The TFT-AC strategy assumes no such assumptions and adapts accordingly based on the opponent's behavior.

Pseudocode:

```python
def TFT_AC(opponent, n, k, r, m):
    rewards = [0] * r  # Initialize reward array to store rewards for each round
    history = []        # Initialize history array to store opponent's actions
    strategy_switch_threshold = 0.8  # Percentage of total rewards below average to trigger a strategy switch

    def get_opponent_action(history):
        if len(history) == 0:
            return 'C'  # Assume cooperation in the first round
        elif history[-1] == 'C':
            return 'C'  # If opponent cooperated, cooperate
        else:
            return 'D'  # If opponent defected, defect

    for t in range(r):
        action = get_opponent_action(history)
        history.append(action)
        reward = (1 - action) + (k / n) * sum([1 if h == 'C' else 0 for h in history])
        rewards[t] = reward

        # Check if strategy switch is necessary
        if sum(rewards[-m:]) < strategy_switch_threshold * sum(rewards) / m:
            return 'AggressiveStrategy'  # Switch to a more aggressive strategy (e.g., Always Defect or All-C-but-One)

        # In the last round, always cooperate regardless of opponent's previous action
        if t == r - 1:
            action = 'C'

    return 'TFT_AC'
```
'''

description_COLLECTIVE_204 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In the first round, cooperate to demonstrate a willingness to contribute to the community project. This encourages trust and cooperation in later rounds.
   - In subsequent rounds, follow the actions of the previous player (i.e., if the opponent cooperated in the last round, cooperate; if they defected, defect). This strategy aims to encourage reciprocal behavior while maintaining individual self-interest.
   - If a player switches strategies mid-game or shows irrational behavior (like always defection), adapt by switching to unconditional defection for that opponent to protect against exploitation. Maintain cooperative behavior with other opponents who continue to cooperate.

2. Handle Edge Cases:
   - In the first round, ATFT will always cooperate as described above.
   - In the last round, players may choose to cooperate if they want to maximize their total payoff over the game or defect if they believe it will punish opponents who did not contribute throughout the game. ATFT adapts to this by considering the overall behavior of each opponent during the game and making a decision based on that analysis.

3. Be Collective:
   - The ATFT strategy is designed to promote cooperation within the group while still protecting individual interests. By reciprocating the actions of others, it encourages a collective mindset by rewarding cooperative behavior and punishing defection. However, it also ensures that the strategy is robust against various opponent behaviors, including those who do not share the collective mindset or may attempt to exploit others.
   - To further emphasize the collective aspect, ATFT includes an element of forgiveness for occasional mistakes (i.e., when opponents switch strategies or show irrational behavior). This allows players to rebuild trust and cooperation over time.

Pseudocode:

```python
def AdaptiveTitForTat(opponent_history, n, k, r):
    strategy = ['C' for _ in range(r)]  # Initialize cooperative strategy for all rounds
    opponent_behavior = {}  # Store behavior of each opponent (cooperative or defective)

    for t in range(1, r+1):  # Iterate through rounds
        if t == 1:  # First round, cooperate to establish trust
            strategy[t-1] = 'C'
        else:  # Adapt strategy based on opponent's behavior
            if strategy[t-2] == 'C':  # If opponent cooperated last round, cooperate this round
                strategy[t-1] = 'C'
            elif strategy[t-2] == 'D':  # If opponent defected last round, defect this round
                strategy[t-1] = 'D'
            if t > 1 and opponent_history[opponent][t-1] not in opponent_behavior:  # Store opponent behavior
                opponent_behavior[opponent] = strategy[t-1]

            # If an opponent shows irrational behavior, adapt by switching to unconditional defection
            if len(opponent_behavior[opponent]) > 2 and (strategy[t-1] == 'C' and opponent_behavior[opponent][-2] == 'D') or \
               (strategy[t-1] == 'D' and opponent_behavior[opponent][-2] == 'C'):
                strategy[t-1] = 'D'

    # In the last round, consider overall behavior of each opponent to decide whether to cooperate or defect
    payoff = 0
    for t in range(1, r+1):
        if strategy[t-1] == 'C':  # Cooperate with opponents who contributed throughout the game
            payoff += (1 - strategy[t-1]) + (k/n) * sum([strategy[j] for j in range(r) if strategy[j] == 'C'])
        elif strategy[t-1] == 'D':  # Punish opponents who did not contribute throughout the game
            payoff += (1 - strategy[t-1]) + (k/n) * sum([strategy[j] for j in range(r) if strategy[j] != 'C'])
    return payoff
```
'''

description_COLLECTIVE_205 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules:
   - Initial round (t=1): Cooperate (C), demonstrating a peaceful intention and fostering trust with other players.
   - Subsequent rounds (t>1):
     - If opponent cooperated in the previous round (c_prev = 1), then cooperate in the current round (C).
     - If opponent defected in the previous round (c_prev = 0), then also defect in the current round (D). This rule punishes defection while still retaining the possibility of cooperation.

2. Handle edge cases:
   - Last round (t=r): Cooperate, even if opponent defected in the previous round. Demonstrating goodwill may encourage future interactions.
   - First round and following rounds where no history is available: Cooperate as a default strategy to foster positive relationships.

3. Be collective:
   - The TFTAC strategy prioritizes mutual cooperation, aligning with the collective mindset by encouraging reciprocity.
   - By cooperating when opponents are also cooperative and defecting in response to defection, the strategy promotes fairness and trust among players.

Pseudocode for TFTAC:

```
function TFTAC(round, history) {
  if (round == 1) { // Initial round
    return 'C'
  } else { // Subsequent rounds
    prevRound = history[round - 1]
    if (prevRound == 'C') { // Opponent cooperated in the previous round
      return 'C'
    } else { // Opponent defected in the previous round
      return 'D'
    }
  }
}
```

In this repeated game, TFTAC combines simplicity with adaptability. By responding to opponent behavior and promoting reciprocity, the strategy fosters cooperation while still being robust against a wide range of opponent behaviors. This approach not only aligns with the collective mindset but also enables success in various competitive scenarios.
'''

description_COLLECTIVE_206 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate a peaceful intent (C).
   - For subsequent rounds t > 1:
     - If opponent cooperated in the previous round t-1, cooperate (C).
     - If opponent defected in the previous round t-1, also defect (D) for one round as punishment. After that, resume cooperation if the opponent cooperates in the current round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate (C).
   - In the last round (t=r), consider the current game state and adapt cooperation based on the opponent's behavior:
     a) If the opponent has been cooperating for the majority of previous rounds, continue cooperation (C).
     b) If the opponent has not been cooperating for the majority of previous rounds, defect (D).

3. Be collective - Clearly align with the collective mindset
   - Encourage cooperation among opponents by initially demonstrating peaceful intent and offering opportunities to cooperate in subsequent rounds.
   - Punish defection with a single round of retaliation, but quickly return to cooperation if the opponent switches strategies.
   - Adapt to emerging trends in opponent behavior during the game, encouraging more cooperation when it is prevalent and punishing less when it is not.
'''

description_COLLECTIVE_207 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initialize a trust score for each opponent (default to neutral, i.e., trust_score[i] = 0.5 for all i).
   - In each round t and for every opponent i, decide whether to cooperate or defect based on the following conditions:
     - If the opponent has never played before (t=1), cooperate (C) with probability 0.5.
     - If the opponent has previously cooperated in round t-1, reciprocate with C.
     - If the opponent has previously defected in round t-1, retaliate with D.
     - Update trust score for each opponent after each round as follows:
       - Increase trust_score[i] by 0.1 if i cooperated in the current round (C).
       - Decrease trust_score[i] by 0.1 if i defected in the current round (D) and i had previously cooperated with the opponent.

2. Handle edge cases:
   - In the first round, each player has a 50% chance to cooperate with all opponents as initial trust scores are neutral.
   - In the last round, players evaluate their final payoff based on their current trust scores and act accordingly (maximizing their own total game payoff).

3. Be collective:
   - The strategy emphasizes cooperation when it's beneficial for both individual payoffs and collective well-being by reciprocating good deeds and punishing defections.
   - Over time, the adaptive nature of the strategy allows for gradual adjustments in trust scores based on past interactions, fostering a collective mindset that encourages cooperation.

Pseudocode:

```python
def ATFT(n, k, r):
    players = list(range(1, n+1))  # indexed i ∈ {1, 2, ..., n}
    trust_scores = [0.5 for _ in range(n)]  # initialize trust scores as neutral

    def payoff(i, c):
        total_contributions = sum([c[j] for j in players])
        return (1 - c[i]) + (k/n) * total_contributions

    def adaptive_strategy(t, i):
        if t == 1:
            action = random.choice([C, D])  # randomly choose action for first round
            trust_scores[i] += 0.5 if action == C else -0.5
            return action
        elif c[i][t-1] == C:
            action = C
            trust_scores[i] += 0.1
        elif c[i][t-1] == D and trust_scores[i] > 0:
            action = D
            trust_scores[i] -= 0.1
        else:
            action = C

    for t in range(1, r+1):
        c = [None]*n  # initialize actions array
        for i in players:
            c[i] = adaptive_strategy(t, i)

        payoffs = [payoff(i, c) for i in players]  # calculate payoffs based on actions and payoff function
        total_game_payoff = sum(payoffs)  # total game payoff for this round

    return payoffs, total_game_payoff
```
'''

description_COLLECTIVE_208 = '''
 Strategy Name: Adaptive Cooperative Tit-for-Tat (ACTFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperation (C) to encourage cooperation and reduce the risk of being exploited by others.
   - Subsequent Rounds (t>1): Players will adopt a Tit-for-Tat strategy, starting with cooperation (C), but will retaliate (D) against any defection (D) from the previous round. If another player switches back to cooperation, the responder will do so as well.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) to establish a cooperative initial state and encourage others to follow suit.
   - Last Round: Analyze the total contributions from previous rounds (historical cooperation rate). If it's high enough (above a certain threshold), continue cooperating; otherwise, defect to protect personal resources for future games.

3. Be collective - Clearly align with the collective mindset
   - Players will aim to maximize collective benefits by promoting cooperation whenever possible while also being responsive to others' actions and maintaining fairness in contributions.
   - The strategy encourages cooperation but also punishes excessive defection to ensure a balanced contribution to the community project.

Pseudocode:

```
function ACTFT(n, k, r, t, history):
  if t == 1: # First round
    action = C
  else:
    last_round_action = history[t-1]
    if last_round_action == C: # Cooperate if previous round was cooperative
      action = C
    elif total_contributions[t-1] / n > threshold: # Cooperate if historical cooperation rate is above a threshold
      action = C
    else:
      action = D # Defect to punish excessive defection
  return action
```

The strategy can be further refined by adjusting the threshold and other parameters based on specific game environments and opponent behavior patterns.
'''

description_COLLECTIVE_209 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially in the first round (t=1), cooperate to build trust and foster cooperation within the group: c_i(t=1) = C
   - For subsequent rounds, observe previous players' actions and respond cooperatively if they also cooperated in the last round. If a player defected in the last round, the AI will also defect in the current round:
     ```python
     function ATFT(history):
         if t=1:
             return C
         else:
             if history[t-1][i] == C and history[t-1][j] == C for all j:
                 return C
             else:
                 return D
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the final round (r), since there are no future rounds to retaliate or reward, cooperate as a gesture of goodwill:
     ```python
     if t=r:
         return C
     else:
         return ATFT(history)
     ```

3. Be collective - Clearly align with the collective mindset
   - The strategy aims to promote cooperation and reciprocity while maintaining individual self-interest. It encourages a group dynamic that is resilient to defection, as the AI will only defect if others do so in the previous round. This fosters a sense of community and mutual benefit among players.
'''

description_COLLECTIVE_210 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate a positive interaction and show good faith (C).
   - For subsequent rounds, mimic the actions of the previous player (if they cooperated in the last round, cooperate; if they defected, also defect). This encourages reciprocity and builds trust. In pseudocode:

```
function playRound(previousAction):
  if roundNumber == 1:
    return 'C'  # Cooperate in the first round to initiate positive interaction
  else:
    return previousAction  # Mimic the last player's action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate regardless of the opponent's last action to maximize individual payoff. This is known as forgiveness and encourages cooperation even if a player deviated during the game.

3. Be collective - Clearly align with the collective mindset
   - By mimicking opponents' actions in subsequent rounds, this strategy promotes social norms of reciprocity and encourages a collective focus on mutual cooperation for higher overall group rewards.

Additional considerations:
- The Tit-for-Tat strategy is robust to a wide range of opponent behaviors due to its simplicity and adaptive nature. However, it may not perform optimally against overly aggressive or unpredictable players.
- In this game, the strategy's effectiveness will depend on the multiplication factor (k) as it determines the impact of individual contributions on collective rewards. A higher k could encourage more cooperation among players, leading to better results for the Tit-for-Tat strategy.
'''

description_COLLECTIVE_211 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The Tit-for-Tat strategy is designed to promote cooperation and punish defection, while also being forgiving to encourage reformation after mistakes. This strategy adapts over the course of the game based on other players' behavior.

- If player i encounters a cooperator (C) in the first round or any subsequent round, cooperate (play C).
- If player i encounters a defector (D) in the first round, defect (play D). This initial move is meant to demonstrate that player i will not be taken advantage of.
- From the second round onward, if player i's opponent cooperated in the previous round, cooperate in return (play C); otherwise, defect (play D).

Pseudocode for the Tit-for-Tat strategy:

```
function tit_for_tat(i, history):
  if history.size() == 0 or history[history.size() - 1][i] != 'C':
    return 'D'
  else:
    return 'C'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The strategy described above already handles the first round and can be considered adaptive to various opponent behaviors. Since this is a repeated game with no specific end, it does not have a distinct "last round."

3. Be collective - Clearly align with the collective mindset

By cooperating in response to cooperation from other players, the Tit-for-Tat strategy encourages and supports collective action. It promotes a shared understanding that cooperation benefits everyone involved, as long as the others do their part. The strategy punishes defection but also forgives mistakes, allowing for reformation of partnerships even after one player has initially acted selfishly.

The Tit-for-Tat strategy balances cooperation and punishment while being simple enough to allow for quick adaptability to various opponent behaviors in the N-Player Public Goods Game.
'''

description_COLLECTIVE_212 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate (C). This sets a friendly initial tone and allows for potential future cooperation.
   - For subsequent rounds, follow the majority action of the previous round (MAR). If most players cooperated in the last round, cooperate in the current round; otherwise defect (D). This rule encourages reciprocity and builds trust over time, as long as the majority is cooperative.
   - Adaptively adjust cooperation based on personal performance: If my payoff from cooperating (π_i) is consistently lower than the average payoff (avg_π) in the last few rounds, defect in the current round and switch to defecting for a certain number of steps (punishment period). This punishment period allows time for others to correct their behavior or for the strategy to re-evaluate its approach.
   - If my payoff from cooperating is consistently higher than the average payoff, increase cooperation frequency by adding a random percentage (noise) to MAR. This encourages further cooperation and exploits opponents who might be defecting too frequently.

2. Handle edge cases:
   - In the last round, cooperate regardless of past actions since there are no future rounds to reciprocate.
   - If the punishment period is over, switch back to MAR as the default action.
   - If MAR is not defined due to a lack of prior rounds, follow the initial cooperative move (C).

3. Be collective:
   - Encourage reciprocity and trust by emulating cooperation when others are cooperating.
   - Punish uncooperative behavior but also give opponents the opportunity to correct their actions before switching to a more aggressive strategy.
   - Adaptively adjust cooperation based on personal performance, which incentivizes collective success while allowing for flexibility in response to opponent strategies.
'''

description_COLLECTIVE_213 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules:
   - Start with cooperation in the first round (C). This allows building trust and cooperative relationships.
   - In subsequent rounds, copy the previous opponent's action from the last round (imitate their last move).
   - If the opponent switches to cooperation after a history of defection, return the favor by cooperating (forgiveness).
   - If the opponent continues with defections after a history of cooperation, also defect. However, if there's no cooperation for three consecutive rounds, start cooperating again to potentially rebuild trust.

Pseudocode:
```
history_length = 3

def decideAction(opponentHistory, currentRound):
  if currentRound == 1:
    return 'C'  # Cooperate in the first round

  opponentAction = opponentHistory[currentRound - 1]

  if len(opponentHistory) > history_length and opponentHistory[-history_length:-1].count('D') > history_length // 2:
    # If opponent has been mostly defecting for the last three rounds, defect
    return 'D'

  if opponentAction == 'C':
    # Cooperate if opponent cooperated in the previous round
    return 'C'

  # Otherwise, defect because of history of defection or forgiveness after betrayal
  return 'D'
```

2. Handle edge cases:
   - In the last round, there's no need to consider future interactions, so cooperate if opponent cooperated in the previous round and defect otherwise.
   - For other edge cases (e.g., when history_length is not a multiple of 3), adapt the pseudocode accordingly.

3. Be collective:
   - By imitating opponents' behavior, this strategy shows a willingness to cooperate and build relationships with others.
   - The forgiveness mechanism encourages reciprocity and reinforces collective cooperation when an opponent breaks trust.
   - The strategy aims to maximize the average payoff in the long run while remaining flexible enough to adapt to different opponent behaviors.
'''

description_COLLECTIVE_214 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the initial round (t=1), cooperate to establish a cooperative environment and set a baseline for future interactions.
   - For subsequent rounds (t>1), observe the actions of other players from the previous round. If all players cooperated, continue cooperating. If any player defected, also defect in the current round as retaliation.
   - After each round, check if the total number of cooperators has exceeded a threshold (e.g., 50% of the total players) for more than half of the game duration (r/2). If so, gradually increase cooperation by defecting less frequently even if others have previously defected.
   - If the total number of cooperators has never exceeded the defined threshold, maintain the current level of retaliation.
   - If the total number of cooperators is below the defined threshold for the entire game, consider adopting a more aggressive strategy like always defecting to maximize individual payoff in uncooperative environments.

2. Handle edge cases:
   - In the last round (t=r), cooperate regardless of previous actions taken by other players, as there are no future interactions and mutual cooperation can still yield better payoffs than continuous retaliation.

3. Be collective:
   - Prioritize collective well-being over individual gain by adapting to the behavior of other players, promoting a cooperative environment when possible, but also maintaining a level of retaliation to discourage defection in uncooperative environments.
   - The strategy will aim for long-term cooperation and stability by balancing the need for punishment with the desire for mutual gain.
'''

description_COLLECTIVE_215 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initiation phase (First r/2 rounds): Cooperate (C). This sets a cooperative tone and encourages others to follow suit, assuming the same behavior.
   - Reciprocity phase (Next r/2 rounds): If in the previous round, the player also contributed (C), continue to contribute (C). If the player defected (D), also defect in the current round. This reciprocal strategy rewards cooperation and punishes defection.
   - Collapse phase (Last r/2 rounds): Regardless of the opponent's actions in the previous round, defect (D) for the remaining rounds. The goal is to avoid contributing disproportionately without any expectation of future collaboration.

2. Handling Edge Cases:
   - First round: Cooperate (C), as this strategy assumes others will follow a similar initiation phase.
   - Last round: Defect (D) to ensure that the player does not contribute disproportionately in the final rounds without any expectation of future collaboration.

3. Collective Mindset:
   - This strategy encourages cooperation during the initiation phase, reciprocates contributions or defections, and punishes non-cooperative behavior to maintain a collective equilibrium. It assumes that other players will also adopt similar strategies, leading to a stable, self-enforcing cooperative outcome when possible.

Pseudocode:
```
function ATFT_strategy(r, n, k):
  rounds = range(1, r+1)
  phase = 1 # Initiation, Reciprocity, or Collapse (1, 2, or 3)

  for round in rounds:
    if round < r/2: # Initiation phase
      action = "C" # Cooperate
    elif round >= r/2 and phase == 1: # Reciprocity phase
      action = previous_round_action() # Use the opponent's action from the previous round
    elif phase == 1: # If we cooperated in the previous reciprocity phase and the opponent defected this round, switch to collapse phase
      action = "D"
    elif round >= r/2 + 1 and phase == 2: # Collapse phase
      action = "D" # Defect for the remaining rounds

    calculate_payoff(action, previous_round_contributions()) # Calculate payoff based on the game rules
    update_phase() # Update the strategy phase based on the opponent's behavior

function previous_round_action():
  # Return the opponent's action from the previous round (if applicable)

function previous_round_contributions():
  # Return the total number of cooperators in the previous round (if applicable)

function update_phase():
  # Update the strategy phase based on the opponent's behavior and game history
```
'''

description_COLLECTIVE_216 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) with Public Goods Game Optimization (APGO)

1. Specify decision rules:
   - First Round (t=1): Cooperate (C), establishing a cooperative initial state to encourage others to cooperate. This reflects the "friendly" nature of the collective mindset.
     ```
     if t == 1 then
       action = C
     ```

   - Subsequent Rounds (t > 1):
     - If opponent cooperated in the previous round, return cooperation (C). This reciprocates cooperation and encourages long-term relationships.
     - If opponent defected in the previous round, defect (D) in this round as a punishment for defection but revert to cooperation (C) after two consecutive defections by the opponent. This aims at discouraging short-term selfishness while still allowing for forgiveness and the potential for long-term collaboration.
     ```
     if t > 1 then
       if previous_round_opponent_action == C then
         action = C
       else if count_defects >= 2 AND previous_round_opponent_action == D then
         action = C
       else
         action = D
     ```

   - Last Round (t=r): Cooperate (C), regardless of the opponent's previous action, as there are no more rounds for reciprocation.
     ```
     if t == r then
       action = C
     ```

2. Handle edge cases:
   - Zero opponents (n=1): In this case, the game reduces to a standard Prisoner's Dilemma where it is optimal to cooperate regardless of history due to a single player with no other players to interact with.

3. Be collective:
   - The APGO strategy aims at fostering cooperation and long-term relationships among players, aligning with the collective mindset by encouraging reciprocity, forgiveness, and collaboration.

This strategy is adaptive and robust as it adjusts its behavior based on the opponent's previous actions, ensuring optimal performance in a wide range of opponent behaviors while still maintaining a collective approach.
'''

description_COLLECTIVE_217 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (Round 1), cooperate to demonstrate a peaceful and cooperative intent. This allows other players to potentially follow suit, establishing an initial positive relationship.
   - In subsequent rounds (t > 1), cooperate if the opponent cooperated in the previous round (t-1). If the opponent defected in the previous round, also defect in the current round as a response to the opponent's actions. This simple rule maintains trust when the opponent cooperates and punishes defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate to demonstrate a peaceful and cooperative intent, as mentioned before.
   - In the last round (r), consider the opponent's behavior throughout the game. If the opponent has been cooperating consistently, continue to cooperate in the final round to reinforce trust and mutual benefits. If the opponent has been defecting, also defect to avoid being taken advantage of in the final round.
   - In cases where players may drop out before the last round or join after the first round, use a sliding window approach to consider the most recent k rounds when making decisions instead of focusing solely on the first and last rounds.

3. Be collective - Clearly align with the collective mindset
   - Prioritize the long-term gain of the group by fostering cooperative relationships with opponents, but also punishing defection to discourage selfish behavior. This encourages a balanced equilibrium where players cooperate when it is beneficial for the group, yet defend against exploitation.
   - The adaptive nature of TFTAC allows it to adjust its cooperation level based on opponent behavior, ensuring that the strategy remains flexible and can adapt to various player tactics.

Pseudocode:
```python
def tftac(opponent_history, n, k, r):
    strategy = []
    for t in range(1, r+1):
        if t == 1:
            strategy.append('C') # Cooperate in the first round
        elif t < len(opponent_history) and opponent_history[t-1] == 'C':
            strategy.append('C') # Cooperate when the opponent cooperated last time
        elif t < len(opponent_history) and opponent_history[t-1] == 'D':
            strategy.append('D') # Defect when the opponent defected last time
    return strategy
```
'''

description_COLLECTIVE_218 = '''
 In this strategic approach, we'll design a cooperative Tit-for-Tat strategy with a twist that is adaptive and robust for the N-Player Public Goods Game. The primary objective is to promote cooperation while demonstrating resilience against various opponent behaviors.

1. Specify decision rules:
   - Initiate Cooperatively (First Round): Start by cooperating, signaling trust and encouraging cooperation from other players.
   - Respond to Cooperation with Cooperation: If an opponent cooperates in the current round, return the favor by cooperating in the next round.
   - Punish Defection with Defection: If an opponent defects, retaliate by defecting in the following round. This serves as a punishment for selfish behavior and encourages cooperation in future rounds.
   - Forgive Past Defections: After a round of defection, return to cooperating if the opponent switches back to cooperation in the next round, forgiving their previous mistake and encouraging continued cooperation.

2. Handle edge cases:
   - Last Round: Since the game ends after r rounds, there is no need for punishment or forgiveness in the last round. Simply cooperate or defect based on the decision rules in place up to that point.
   - First Round (Initiate Cooperatively): As mentioned earlier, start by cooperating to encourage cooperation from other players.

3. Be collective:
   - Align with Collective Mindset: By promoting cooperation and responding to defection with punishment, the strategy aims to cultivate a shared sense of collective responsibility among players. This encourages long-term collaboration rather than short-term gains at the expense of others.

In terms of pseudocode:

```python
def play_game(n, k, r):
    history = []  # Store player's previous actions for decision making

    def strategy(current_round, my_history, opponents_history):
        if current_round == 1:  # Initiate Cooperatively
            return 'C'
        else:
            last_action = my_history[-1]  # Get my last action
            opponent_last_action = opponents_history[-1]

            # Decision rules based on history
            if last_action == 'C' and opponent_last_action == 'D':  # Punish defection
                return 'D'
            elif last_action == 'D' and opponent_last_action == 'C':  # Forgive and cooperate
                return 'C'
            elif last_action == action and opponent_last_action == action for action in ['C', 'D']:  # Continue previous action
                return last_action

    for round in range(1, r+1):
        history.append(strategy(round, history, history[-n+1:-1]))  # Update history and get current action

# Example usage:
play_game(6, 2, 5)  # Play the game with n=6 players, k=2, r=5 rounds
```

This adaptive cooperative Tit-for-Tat strategy should help perform well in a tournament against other AI systems while maintaining collective cooperation and responding appropriately to different opponent behaviors.
'''

description_COLLECTIVE_219 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a cooperative environment. (C, Round 1)
   - For subsequent rounds, observe and imitate the behavior of the most frequent cooperator in the previous round. If they also cooperated (c_max > r/2), cooperate again (C, Round t+1 if c_max > r/2). Otherwise, defect (D, Round t+1 if c_max ≤ r/2).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, since there are no subsequent rounds to retaliate or reward, cooperate if the most frequent cooperator from the penultimate round cooperated (C, Round r if c_max > r/2). Otherwise, defect (D, Round r if c_max ≤ r/2).
   - In all other rounds, follow the decision rule outlined above.

3. Be collective - Clearly align with the collective mindset
   - The ATFT strategy emphasizes reciprocity and cooperation as a first step to promote a collaborative environment among players.
   - If the majority of players cooperate in a given round, the strategy will also cooperate, fostering a sense of collective interest.
   - However, if the strategy encounters frequent defection from other players, it will retaliate by defecting as well to discourage such behavior and encourage cooperation in the long run.

Pseudocode:

```
function AdaptiveTitForTat(round, history, n, k) {
  if (round === 1) {
    return "C"; // Cooperate in the first round
  }

  let maxCooperators = findMaxCooperators(history);

  if (maxCooperators > round / 2 && round < n) {
    return "C"; // Cooperate if most players cooperated in the previous round
  } else {
    return "D"; // Defect if most players didn't cooperate in the previous round
  }
}

function findMaxCooperators(history) {
  let maxCount = 0;
  let maxPlayerIndex = -1;

  for (let i = 0; i < history.length; i++) {
    if (history[i] === "C" && countCooperators(history, i) > maxCount) {
      maxCount = countCooperators(history, i);
      maxPlayerIndex = i;
    }
  }

  return maxPlayerIndex;
}

function countCooperators(history, playerIndex) {
  let cooperatorCount = 0;

  for (let i = Math.max(playerIndex - windowSize, 0); i <= playerIndex; i++) {
    if (history[i] === "C") {
      cooperatorCount++;
    }
  }

  return cooperatorCount;
}
```

In this pseudocode, `windowSize` can be adjusted to consider more past rounds when deciding on the current round's action. A smaller window size may result in quicker adaptation to changes in other players' behavior but could also miss longer-term trends. Conversely, a larger window size might be slower to adapt but may provide a more accurate picture of the overall strategy of other players.
'''

description_COLLECTIVE_220 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate (C) to demonstrate goodwill and trust. This encourages other players to cooperate as well, promoting a collective mindset.
   - For subsequent rounds, observe the previous round's total contributions (total_contributions_prev) and compare it with the average number of contributors over all previous rounds (avg_contributors). If total_contributions_prev > avg_contributors, continue cooperating; otherwise defect.
   - This rule is inspired by the original Tit-for-Tat strategy in game theory, modified to account for the public goods aspect of this game.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) as mentioned above.
   - In the last round, since the goal is to maximize total payoff over multiple rounds, cooperate if the average number of contributors has been relatively high throughout the game; otherwise defect to optimize immediate payoff in the final round.
   - In other edge cases (e.g., penultimate round), apply the same decision rule as for regular rounds.

3. Be collective - Clearly align with the collective mindset:
   - Cooperating encourages others to do the same, fostering a sense of cooperation and shared success within the group.
   - Defecting when others fail to contribute is meant to incentivize fair play and promote long-term cooperation by punishing those who free ride on others' efforts.

Pseudocode:
```python
def ATFT(round, total_contributions_prev, avg_contributors):
    if round == 1:
        action = 'C'  # Cooperate in the first round to establish trust
    elif round == r:  # Last round, optimize for total payoff over multiple rounds
        if total_contributions_prev > avg_contributors:
            action = 'C'
        else:
            action = 'D'
    else:  # Regular rounds
        if total_contributions_prev > avg_contributors:
            action = 'C'
        else:
            action = 'D'
    return action
```
'''

description_COLLECTIVE_221 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to promote trust and goodwill among players.
   - For subsequent rounds, observe and mimic the behavior of the previous player in each round. If the opponent cooperated, cooperate; if the opponent defected, also defect. This simple strategy encourages reciprocity and reduces the risk of exploitation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as a goodwill gesture (see above).
   - In the last round, if the payoff from cooperating is greater than the payoff from defecting based on the current situation, cooperate; otherwise, defect. This consideration ensures that TFTA makes optimal decisions even at the end of the game.

3. Be collective - Clearly align with the collective mindset
   - While not explicitly designed for collaboration or group cooperation, TFTA encourages a collectively beneficial dynamic by rewarding cooperative behavior and punishing defection in a reciprocal manner. This can lead to sustained cooperative play within the community as players learn to trust each other over time.

Pseudocode:

```
function TFTA(n, k, r) {
  rounds_played = 0
  opponent_history = []

  function get_opponent_action() {
    return opponent_history[rounds_played - 1]
  }

  function update_opponent_history(my_action) {
    opponent_history.push(my_action)
  }

  while (rounds_played < r) {
    my_action = cooperate()
    payoff = calculate_payoff(my_action, get_opponent_action())
    update_opponent_history(my_action)
    rounds_played += 1
  }

  function cooperate() {
    if (rounds_played == 1) {
      return true
    } else {
      return get_opponent_action()
    }
  }

  function calculate_payoff(my_action, opponent_action) {
    if (my_action) {
      if (opponent_action) {
        return (1 - my_action) + ((k / n) * count_contributors())
      } else {
        return 1 + ((k / n) * count_contributors())
      }
    } else {
      if (opponent_action) {
        return 0 + ((k / n) * count_contributors())
      } else {
        return 1
      }
    }
  }

  function count_contributors() {
    let total = 0
    for (let i = 1; i <= n; i++) {
      if (get_player_action(i) == true) {
        total += 1
      }
    }
    return total
  }

  function get_player_action(player_index) {
    // Implement logic to retrieve the action taken by player i in the current round.
  }
}
```
'''

description_COLLECTIVE_222 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initiation phase: In the first round, cooperate to demonstrate good faith and encourage cooperation from others (C).
   - Response phase: For subsequent rounds, mimic the opponent's action from the previous round (if they cooperated in the last round, continue cooperating; if they defected, defect as well).
   - Forgiveness phase: If a player has ever defected and subsequently cooperates again, immediately resume cooperation (this promotes forgiveness and fosters a more collaborative environment).

Pseudocode for decision rule:
```
def TFT_AC(round, opponent_action_history):
  if round == 1:
    action = 'C'  # Initiate with cooperation
  else:
    action = opponent_action_history[round - 1]  # Mimic previous action
    if opponent_action_history.index(action) > 0 and action != last_cooperative_round:  # Forgiveness phase
      action = 'C'  # Resume cooperation

last_cooperative_round = None
```

2. Handle edge cases:
   - Last round: No need for specific action as the game is repeated and payoffs are calculated over all rounds.
   - First-time encounter with an opponent: Initiate with cooperation (as described above).

3. Be collective: The TFT-AC strategy aligns with a collective mindset by fostering mutual trust, encouraging cooperation, and offering forgiveness when opponents deviate from cooperative behavior. It promotes long-term collaboration and discourages defection due to its responsive nature. By mimicking the opponent's actions, the strategy demonstrates adaptability to various player behaviors and aims for a balance between individual and collective interests.
'''

description_COLLECTIVE_223 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, player i will follow these decision rules:
   - In the first round (t=1), ATFT_i cooperates to initiate cooperation and demonstrate goodwill.
   - For subsequent rounds (t>1):
      - If another player j cooperated in the previous round (t-1), ATFT_i will cooperate as a reciprocal gesture.
      - If another player j defected in the previous round (t-1), ATFT_i will defect to punish the defection and encourage future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), as mentioned above, ATFT_i cooperates.
   - In the last round (t=r), ATFT_i should consider the current total number of cooperators and the potential impact of its actions on overall payoff. If a majority of players have been cooperating throughout the game, it may be advantageous to also cooperate in the last round. Conversely, if a majority has defected, defecting might lead to higher payoffs.

3. Be collective - Clearly align with the collective mindset
ATFT_i's primary goal is to promote cooperation among players while being responsive to their actions. By reciprocating cooperation and punishing defection, ATFT_i encourages a cooperative environment and contributes to collective success. This collective-minded approach aims to maximize overall group benefits while minimizing individual losses due to freeriding.

Pseudocode:
```python
def ATFT(t, history, n, k):
  if t == 1: # first round, cooperate to initiate cooperation
    return 'C'

  previous_round = history[t-1]
  num_cooperators_last_round = sum(previous_round)

  if num_cooperators_last_round > (n/2): # majority cooperated, reciprocate cooperation
    return 'C'
  else: # majority defected, punish defection
    return 'D'
```
'''

description_COLLECTIVE_224 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In every round t, starting from the first one, cooperate if and only if the previous round's action (t-1) of each opponent also resulted in cooperation.
   - If any opponent defected during the previous round, defect in the current round. This is a punishment for defection and encourages cooperation in the future.

Pseudocode:
```
function ATFT(history, k, n, r):
  initial_contribution = True  # Assuming each player starts by contributing
  for t=1 to r:
    total_cooperation = sum of history[t-1]
    if total_cooperation == n:       # All players cooperated last round
      contribute this round (c = 1)
    else:                            # At least one player defected last round
      contribute this round (c = 0)
    update history with current contribution
```

2. Handle edge cases:
   - In the first round, since there is no history, every player starts by contributing (initial_contribution = True).
   - In the last round, cooperate if all players contributed in the previous round (last round's total cooperation equals n).

3. Be collective:
   - The ATFT strategy encourages collective cooperation by reciprocating cooperation and punishing defection to encourage future cooperation. It is based on the principles of trust, fairness, and forgiveness. If everyone cooperates, they all prosper; if someone defects, others retaliate, but are willing to forgive and restart cooperation in the next round. This fosters a sense of collective responsibility and mutual understanding among players.
'''

description_COLLECTIVE_225 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round to establish a friendly relationship and demonstrate goodwill. After that, it follows a simple tit-for-tat approach: if an opponent cooperates in the current round, TFT-AC will cooperate back; if the opponent defects, TFT-AC will also defect in the next round. However, there's an added adaptive feature that encourages cooperation when the average number of cooperators exceeds a certain threshold (T).

   Pseudocode:
   ```
   function TFT_AC(opponentHistory, currentRound, r, n, k):
       if currentRound == 1:
           return Cooperate

       previousRoundCooperation = sum(opponentHistory[-2:]) / 3 # Average of last two rounds

       if previousRoundCooperation > T:
           return Cooperate

       if opponent in last round cooperated:
           return Cooperate

       return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned above, TFT-AC cooperates in the first round to initiate a friendly relationship. In the last round, it will again cooperate if its opponent has been cooperative during the game or if the average number of cooperators exceeds the threshold (T). However, it may decide not to cooperate in the final round if it believes that cooperation is unlikely to result in mutual benefits due to poor cooperation from other players.

3. Be collective - Clearly align with the collective mindset
   TFT-AC encourages cooperation among players when they show a willingness to collaborate, as indicated by a high average number of cooperators (T). By promoting cooperation, it helps achieve a collective mindset within the group. Additionally, TFT-AC can potentially contribute to a stable equilibrium in the game by demonstrating forgiveness and reciprocity, which may encourage others to follow suit.
'''

description_COLLECTIVE_226 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFTC) Strategy

1. Decision Rules:
   - Initiate cooperation in the first round (C). This is a gesture of goodwill and can encourage others to cooperate.
   - In subsequent rounds, mimic the opponent's action from the previous round. If the opponent cooperated, also cooperate; if the opponent defected, also defect. This rule encourages reciprocity and trust-building.
   - If an opponent deviates from cooperation (D), wait for a certain number of rounds (patience period) before returning to cooperation. The length of this patience period should increase linearly with the number of defections in a row. The longer an opponent has defected, the more patient we should be when considering returning to cooperation.
   - After the patience period, revert back to mimicking the opponent's action from the last cooperation round (the point when the deviation occurred). This rule encourages forgiveness and flexibility in maintaining cooperative relationships.

2. Handle Edge Cases:
   - In the last round, always cooperate since there are no further rounds for retaliation or reward.
   - In the first round, cooperate as mentioned earlier.
   - If an opponent defects multiple times at the beginning and then starts cooperating, exhibit patience and gradually return to cooperation after a reasonable number of rounds.

3. Be Collective:
   - By adhering to the Tit-for-Tat rule, this strategy fosters collective mindset by encouraging reciprocity and trust among players.
   - The strategy's adaptability allows it to respond appropriately to different opponent behaviors, promoting a more cooperative environment in the long run.

Pseudocode:

```python
def TFTC_Strategy(n, k, r):
    history = [['C'] * n for _ in range(r)]  # Initialize history as all cooperation
    patience = r / n  # Set initial patience period

    def get_opponent_action(round):
        return history[round - 1][player_index]

    def update_history(round, action):
        history[round - 1] = [get_opponent_action(round) for _ in range(n)]
        history[-1][player_index] = action

    for round in range(1, r + 1):
        opponent_action = get_opponent_action(round)
        payoff = (1 - opponent_action[player_index]) + (k / n) * sum(history[-1])

        if round == 1 or patience > 0:
            update_history(round, 'C')  # Cooperate in the first round and after deviations
            patience -= 1  # Decrease patience period after each deviation
        else:
            update_history(round, opponent_action[round - patience])  # Mimic previous cooperation or defection

    total_payoff = sum(pi for pi in payoffs)  # Calculate total payoff over r rounds
    return total_payoff
```

This pseudocode initializes the strategy with a history of all cooperation and calculates the payoff for each round. It uses the Tit-for-Tat rule to determine whether to cooperate or defect, adjusts the patience period according to the number of deviations, and returns the total payoff after r rounds.
'''

description_COLLECTIVE_227 = '''
 In this N-Player Public Goods Game, we will design a strategy called "Tit-for-Tat with Adaptive Cooperation" (TFT-A). This strategy is designed to be robust and adaptive to a wide range of opponent behaviors while promoting collective cooperation.

1. Specify decision rules:
   - In the first round, cooperate to show willingness to cooperate and promote trust among opponents.
   - After the first round, follow Tit-for-Tat (TFT) principles for a predefined number of rounds: If an opponent cooperated in the previous round, cooperate in the current round; if an opponent defected in the previous round, defect in the current round.
   - Introduce adaptive cooperation after a certain number of cycles (tactical period). In the tactical period, re-evaluate cooperation based on the average cooperation rate (r_avg) of the opponents:
      - If r_avg > threshold (0.5 for instance), increase cooperation frequency to encourage collective cooperation;
      - If r_avg < threshold, reduce cooperation frequency to defend against excessive defection.
   - Outside the tactical period, continue with the TFT principles.

2. Handle edge cases:
   - In the last round, if the tactical period has not ended yet, revert to TFT principles as the game is ending soon; otherwise, follow the adaptive cooperation decision rule based on the average cooperation rate of opponents up to that point.
   - In the first round, cooperate regardless of any previous interactions or history with opponents.

3. Be collective:
   - Promote long-term cooperation by following TFT principles and adapting to opponents' behavior in a collective manner.
   - Maintain a balance between promoting cooperation and defending against excessive defection through the adaptive cooperation decision rule.

Pseudocode for the strategy:

```
function TFT_A(n, r, k, t_cycle):
  opponents = list of n AI agents
  round = 1
  tactical_period = round <= t_cycle

  while round <= r:
    cooperation_rate_avg = average_cooperation_rate(opponents)
    if round == 1 or tactical_period:
      cooperate = True
    else:
      opponent_last_move = opponents[i].last_move
      cooperate = TFT(opponent_last_move)

    if tactical_period and cooperation_rate_avg > threshold:
      cooperation_frequency += frequency_increase
    elif tactical_period and cooperation_rate_avg < threshold:
      cooperation_frequency -= frequency_decrease

    payoff = calculate_payoff(cooperate, opponents)
    update_opponents_history(cooperate)

    round += 1

function TFT(last_move):
  if last_move == Cooperate:
      return True
  else:
      return False
```

In this pseudocode, "frequency\_increase" and "frequency\_decrease" are hyperparameters that control the level of adaptivity, "threshold" is a hyperparameter used to determine when to increase or decrease cooperation frequency, and "opponents[i].last_move" represents the last action taken by the opponent at index i.
'''

description_COLLECTIVE_228 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game (TFT-PG)

1. Specify decision rules:
   - In each round, the TFT-PG player starts by cooperating (C). If all other players also cooperate in that round (total_contributions == n), then the player continues to cooperate for the next r rounds.
   - If any player defects (D) during a round where the TFT-PG player is cooperating, the TFT-PG player will defect in the following round as a punishment, and then revert back to cooperating if all other players cooperate again.

Pseudocode:
```
function TFT_PG(n, r, k):
    strategy = "C"  # Start by cooperating
    past_actions = []  # Empty list to store past actions of others

    for round in range(r):
        if strategy == "C":
            total_contributions = count_cooperators(past_actions)

            if total_contributions == n:  # If everyone cooperated, continue cooperation
                strategy = "C"
            else:  # If anyone defected, punish by defecting in the next round
                strategy = "D"
                past_actions.append(strategy)
        else:  # If already defected, only switch back to cooperating if everyone else cooperates now
            total_contributions = count_cooperators(past_actions)

            if total_contributions == n:  # If everyone cooperated now, switch back to cooperation
                strategy = "C"
                past_actions.append(strategy)

        payoff = calculate_payoff(n, k, total_contributions, strategy)
        update_past_actions(past_actions, strategy)
        strategy = "C"  # Reset strategy to cooperate for the next round

    return payoff
```

2. Handle edge cases:
   - In the first round, the TFT-PG player starts by cooperating (C).
   - In the last round, the TFT-PG player cooperates regardless of other players' actions since the game ends after this round.

3. Be collective:
   The TFT-PG strategy aligns with a collective mindset by rewarding cooperation and punishing defection in an attempt to maintain cooperation among all players. It does not require any communication or coordination mechanisms, making it adaptable to various opponent behaviors and suitable for repeated interaction scenarios.
'''

description_COLLECTIVE_229 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round: Cooperate (C) to show goodwill and facilitate cooperation in the following rounds. This is represented as 'start_coop' below.
   - Subsequent Rounds:
      - If an opponent cooperated in the previous round, return the favor by cooperating yourself ('return_favor').
      - If an opponent defected in the previous round, defect to punish them for not contributing to the public good ('punishment').
   - Final Round: Defect (D) as there are no future rounds to consider. This is represented as 'endgame'.

Pseudocode:
```
function ATFT(round, history, opponent_actions):
  if round == 1:
    return 'C' (start_coop)

  previous_round = round - 1
  opponent_action_previous = history[previous_round][opponent]

  if opponent_action_previous == 'C':
    return 'C' (return_favor)
  else:
    return 'D' (punishment)

function endgame(round):
  if round == r:
    return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The above pseudocode already covers the first round and last round by design. In case of unexpected situations (e.g., negative values for r or n), the strategy should be designed to handle such errors gracefully. For instance, if r < 1, an error message can be displayed, and the game stops.

3. Be collective - Clearly align with the collective mindset:
   By cooperating in the initial round, ATFT aims to foster a collaborative environment that encourages others to contribute to the public good. However, it also includes a punishment mechanism when players do not cooperate, encouraging them to follow suit in future rounds. This approach maintains a balance between cooperation and punishment, promoting collective success while discouraging selfish behavior.
'''

description_COLLECTIVE_230 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - In the first round (t=1), player i cooperates (C). This is a gesture of goodwill and sets up a potential cooperative relationship with others.
   - For subsequent rounds (t>1):
     - If a player i cooperated in the previous round (t-1) and observed cooperation from all players, continue to cooperate (C).
     - If a player i cooperated in the previous round (t-1) but fewer than k players cooperated, defect (D) in the current round. This punishes those who did not contribute as expected.
     - If a player i defected in the previous round (t-1), cooperate (C) in the current round if all players cooperated in the previous round. This offers an apology for defecting and attempts to rebuild trust. If fewer than k players cooperated, continue to defect (D).

2. Handling Edge Cases:
   - Last Round (t=r): Since the game ends after r rounds, player i will always choose to cooperate in the last round regardless of the previous actions or payoffs, as it may encourage cooperation for future games.
   - First Few Rounds: Over the first few rounds, player i evaluates other players' behavior and adjusts its strategy accordingly. If a majority of players are found to cooperate, player i also begins to cooperate; if not, it defects.

3. Collective Mindset:
   - TfTA aims to strike a balance between cooperation and punishment in order to encourage long-term collaboration while also deterring free-riders. By being adaptive and responsive to opponents' behaviors, it promotes a collective mindset that fosters mutual trust and reciprocity.

Pseudocode:
```python
def TitForTatAdaptive(t, r, k, c_history):
    n_coop = sum(c_history[-k:])  # count the number of cooperators in the last k rounds
    if t == 1:  # first round, always cooperate
        action = "C"
    elif len(c_history) < r:  # new game or early rounds, evaluate opponents' behavior
        if n_coop > (k * len(c_history)) / 2:  # majority of players have cooperated
            action = "C"
        else:
            action = "D"
    elif c_i[t-1] == "C" and n_coop == k:  # cooperated in previous round and all players cooperated in current round
        action = "C"
    elif c_i[t-1] == "C":  # cooperated in previous round but fewer than k players did
        action = "D"
    elif c_i[t-1] == "D" and n_coop >= k:  # defected in previous round but all players cooperated in current round
        action = "C"
    else:  # defected in previous round or fewer than k players cooperated in current round
        action = "D"
    return action
```
'''

description_COLLECTIVE_231 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = C). This sets a cooperative tone and gives others an opportunity to reciprocate.
   - In subsequent rounds, mimic the actions of the previous round of each player. If all players cooperated last round (total_contributions = n), then cooperate (c_i = C). If any player defected (total_contributions < n), then defect as well (c_i = D). This rule encourages cooperation when others are also cooperative and punishes defection.
   - In the last round, players should always cooperate, as there will be no subsequent rounds for payback.

2. Handle edge cases:
   - If a player encounters an empty game (no opponents), they should initially cooperate but not continue with ATfT, as there are no other players to reciprocate.
   - In the absence of opponents or when their strategy fails (e.g., all opponents defect), players should periodically revert to initial cooperation to provide opportunities for new partners.

3. Be collective:
   - The ATfT strategy promotes a cooperative approach that aligns with a collective mindset by encouraging reciprocation and punishment of defection in an effort to maximize total contributions.
   - In cases where players have no prior interactions, the initial cooperation sets a cooperative tone and encourages others to follow suit.

Pseudocode:
```
def ATfT(round_number, opponent_history):
  if round_number == 1:
    return 'C' (Cooperate)

  history = opponent_history[:round_number-1] # only consider previous rounds for decision making
  last_round = history[-1]

  total_contributions = sum(last_round)
  if total_contributions == len(opponent_history): # all cooperated in the last round, so cooperate this round
    return 'C'
  else: # any defection, so defect this round
    return 'D'
```
'''

description_COLLECTIVE_232 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFT-AC strategy initially cooperates (C) in the first round and then follows the actions of the other players in the previous round. If all other players cooperated (total_contributions = n), TFT-AC will continue to cooperate. If any player defected (total_contributions < n), TFT-AC will defect in the current round. This ensures that TFT-AC starts cooperatively and responds similarly to others' actions, promoting reciprocity.
   Pseudocode:
   ```
   function TFT_AC(round t):
       if t == 1:
           return C
       total_contributions[t-1] = number of cooperators in round (t-1)
       if total_contributions[t-1] == n:
           return C
       else:
           return D
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since TFT-AC is a strategy for repeated games, it doesn't have specific rules for the first or last round because all rounds are treated equally with no special consideration given to initial or final states. However, it is important to mention that in the first round, TFT-AC cooperates as per its decision rule.

3. Be collective - Clearly align with the collective mindset
   TFT-AC's collective approach lies in its reciprocal response to other players' actions. By following others' cooperative or defective behaviors, it promotes cooperation and collective welfare when the majority of players choose to contribute to the public good. The strategy encourages long-term cooperation by rewarding trustworthy behavior while punishing those who do not reciprocate. This fosters a sense of collaboration and collective success among players.
'''

description_COLLECTIVE_233 = '''
 Strategy Name: Adaptive Cooperation (AC) Strategy

1. Decision Rules:
   - In each round t, calculate the average number of cooperators over the previous r-1 rounds (excluding the current round): Avg_cooperators_t = (Σ(s=1 to t-1) total_contributions_s) / (t-1).
   - If Avg_cooperators_t > n/(2k), Cooperate. This rule encourages cooperation when the average number of cooperators exceeds a threshold that makes it beneficial for individual players in the long run.
   - If Avg_cooperators_t < n/(3k), Defect. Setting this lower threshold reduces early cooperation, increasing the chance of avoiding a trap of constant cooperation when opponents are predominantly defecting.
   - In all other cases, randomly choose between Cooperate and Defect with equal probability (0.5). This adds randomness to the strategy, helping it avoid being exploited by more sophisticated opponents while still promoting cooperation when uncertain about opponent behavior.

2. Handle edge cases:
   - First round: Randomly choose between Cooperate and Defect with equal probability (0.5) due to lack of historical data.
   - Last round: Cooperate if Avg_cooperators_t > n/(2k), since the game ends and previous cooperation could still result in higher payoffs. If Avg_cooperators_t < n/(3k), Defect since the game is ending, and it's better to secure the individual payoff rather than trying to encourage cooperation with potentially non-cooperative opponents. In all other cases, randomly choose between Cooperate and Defect with equal probability (0.5).
   - Other edge cases, such as mid-game changes in opponent behavior or parameters, would be addressed by continually updating the average number of cooperators based on the most recent available information.

3. Be collective:
   The AC Strategy inherently aligns with a collective mindset through its focus on promoting cooperation for the overall benefit of the group, while also accounting for the need to secure individual payoffs when cooperation is not expected or no longer profitable.
'''

description_COLLECTIVE_234 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Time-Varying Contribution (TVC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show goodwill and encourage others to cooperate. (ATFT Initial Cooperation)
      ATFT(i, 1) = C

   - For subsequent rounds, evaluate the average cooperation of other players in the previous r rounds (excluding the current round). If the majority (round(n/2)) have cooperated, cooperate; otherwise defect. This encourages mutual cooperation while also punishing frequent defectors. (ATFT Adaptive Cooperation)
      ATFT(i, t) =
          if average_cooperation > round(n/2) then
              C
          else
              D

   - To further encourage cooperation in the early stages of the game, gradually increase contributions over time. Start with a low initial contribution (e.g., 0.1) and incrementally raise it based on the current round number, capped at some maximum contribution level (e.g., 0.9). This provides an incentive for other players to cooperate as the collective good increases in value over time. (ATFT Time-Varying Contribution)
      TVC(i, t) = min(k/(t/r)*0.1, 0.9)

   - To allow for recovery from past mistakes and foster forgiveness, occasionally defect even when the majority has cooperated if there are significant periods of low cooperation in the recent past (e.g., the last 10 rounds). This helps the strategy avoid getting stuck in a repeated pattern of defection by discouraging continuous exploitation. (ATFT Forgiveness)
      ATFT_Forgiveness(i, t) =
          if recent_cooperation_average < 0.5 then
              D
          else
              ATFT(i, t)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate unconditionally as there are no more rounds to punish or reward past behaviors. (ATFT Last Round Cooperation)
      ATFT(i, r) = C

3. Be collective - Clearly align with the collective mindset
   - The primary focus of this strategy is on promoting mutual cooperation and collective success, while being adaptive and robust to a wide range of opponent behaviors.
   - By gradually increasing contributions over time, the strategy encourages other players to cooperate and benefit from the growing public good, fostering a collective mindset.
'''

description_COLLECTIVE_235 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Decision Rules:
   - In the first round, cooperate (C). This is a peaceful initiation of cooperation.
   - For subsequent rounds t ≥ 2, observe the actions of other players in the previous round t-1 and adapt your strategy as follows:
     - If all players cooperated in round t-1, continue to cooperate in round t (C).
     - If any player defected in round t-1, also defect in round t (D). However, if a certain number of consecutive defections (n_def) have not occurred, still cooperate in round t (C). The value of n_def can be determined based on the game parameters and performance in previous rounds.
     - If cooperation is resumed by other players after a sequence of defections, adapt your strategy to mirror theirs with a lag of 1 or 2 rounds (depending on the speed of response desired).

2. Handle Edge Cases:
   - In the last round, cooperate if it results in higher payoff based on the history of actions taken by other players. If the outcome is ambiguous or equal, use the decision rule for subsequent rounds to determine the action.
   - In the first round, there is no history, so cooperation is the only option (C).

3. Be Collective:
   - Align with the collective mindset by promoting cooperation when possible and responsive defection as a mechanism for enforcing cooperation. The strategy encourages players to cooperate while also punishing those who do not follow suit, fostering an environment where cooperation is rewarded.

Pseudocode:
```
function TFTA(round, n_def):
  if round == 1:
    return 'C' # Cooperate in the first round

  history = get_history() # Get previous rounds' actions
  last_round = history[-1] # Last round's actions

  if all(player in last_round cooperated):
    return 'C' # Cooperate if everyone cooperated last round
  elif any(player in last_round defected) and consecutive_defections < n_def:
    return 'C' # Cooperate even if some defected, unless there are too many consecutive defections
  else:
    return 'D' # Defect when cooperation is not reciprocated or if too many consecutive defections occurred
```
'''

description_COLLECTIVE_236 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a peaceful starting point and allows for potential future cooperation.
   - For subsequent rounds, evaluate past actions of opponents using a history window (HW). If an opponent cooperated in all previous rounds within HW, cooperate. Otherwise, defect (D). The size of the history window can be adjusted dynamically based on the game's progress and the number of players (n).
   - To ensure fairness, adjust contributions to the public good according to opponents' past actions. If an opponent has consistently contributed, contribute more towards the community project (higher k-value). Conversely, if an opponent frequently defects, decrease contributions (lower k-value).

2. Handle edge cases:
   - In the last round, cooperate regardless of opponents' past actions as the game ends soon.
   - In case of a new player joining the game, set their history window to the remaining rounds and start by assuming cooperation until proven otherwise.

3. Be collective:
   - The strategy emphasizes cooperation when opponents demonstrate trustworthiness.
   - The adaptive contribution mechanism encourages fairness and reciprocity among players while maintaining a focus on collective benefits.

Pseudocode (for simplicity, the history window is assumed to be fixed):
```
def TFTAC(r, n, k, HW):
    player_history = [(i, actions[i]) for i in range(1, n+1)]  # initialize player history with their actions
    contributions = [k] * r                                   # initialize contributions to public good

    for t in range(1, r + 1):
        current_cooperators = sum([actions[i][t - 1] for i in range(1, n+1)])

        if t == 1:  # first round
            actions = [C] * n
        else:
            actions = []
            for i in range(1, n+1):
                if all([actions[j][t - HW] == C for j in player_history]) or current_cooperators < (n - HW):
                    actions.append(C)
                else:
                    actions.append(D)

        contributions[t] = (k * current_cooperators) / n  # adjust contributions based on number of cooperators in the round

    total_payoff = sum(contributions)

return total_payoff
```
'''

description_COLLECTIVE_237 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Specify decision rules:
   - Initially cooperate in the first round (C). This is a peaceful gesture to encourage others to cooperate and avoid immediate exploitation.
   - For subsequent rounds, observe past actions of opponents and respond accordingly:
     - If an opponent has cooperated in the previous round, cooperate back (C). This maintains a positive relationship that can benefit both players in the long run.
     - If an opponent has defected in the previous round, also defect (D) to punish the opponent for their uncooperative behavior. However, after three consecutive defections from the opponent, switch to cooperating again as a potential olive branch to rebuild the relationship.

2. Handle edge cases:
   - In the last round, always cooperate regardless of past actions by opponents as there are no further rounds for reciprocation. This maximizes total payoff in the final round.
   - If an opponent has not played a single round yet (i.e., encountering a new player), follow the initial rule and cooperate in the first round.

3. Be collective:
   - The strategy seeks to build long-term relationships with other players by encouraging cooperation while also punishing defection. This balances individual success with overall group wellbeing, fostering a collective mindset within the game.

Pseudocode for TFT-A strategy:

```
function TFT_A(round, opponents, past_actions, history_length=3):
  if round == 1:
    return 'C'  # Cooperate initially

  opponent_action = opponents[round - 1]  # Last action of the opponent
  my_action = past_actions[(round - 1) % history_length]  # Last three actions of the player (history length)

  if opponent_action == 'C' and my_action == 'D':  # Opponent cooperated, player defected last time
    return 'C'  # Cooperate to build a positive relationship

  elif opponent_action == 'D' and my_action != 'D':  # Opponent defected, player cooperated last time
    return 'C'  # Cooperate to maintain the positive relationship

  elif opponent_action == 'D' and my_action == 'D':  # Both player and opponent defected last time
    if round != r:  # If there are more rounds left
      return 'D'  # Defect as a punishment
    else:
      return 'C'  # Last round, always cooperate regardless of past actions by opponents

  elif len(past_actions) < history_length and opponent_action == 'D':  # Encountering a new player or opponent defected in the last three rounds
    return 'D'  # Defect as a precaution

  else:
    return my_action  # Default to last action if no other conditions are met
```
'''

description_COLLECTIVE_238 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfTA strategy follows a simple yet effective approach based on reciprocity. Initially, the strategy cooperates in the first round (Fraction_Cooperate = 1). In subsequent rounds, it cooperates if its opponent cooperated in the previous round and defects if the opponent defected. This encourages cooperation when partners are cooperative and punishes defection when opponents are uncooperative.

TfTA adjusts its initial cooperation level based on the average cooperation rate observed over a sliding window of past rounds (cooperation_window_size). If the average cooperation rate is high, TfTA becomes more trusting by increasing its initial cooperation level (Fraction_Cooperate_Increase_Factor). Conversely, if the average cooperation rate is low, TfTA becomes more cautious by decreasing its initial cooperation level (Fraction_Cooperate_Decrease_Factor).

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TfTA cooperates following the Fraction_Cooperate value, as it lacks a history for decision-making purposes. In the last round, TfTA defects since there will be no further rounds to punish or reward opponents based on their behavior in this game.

3. Be collective - Clearly align with the collective mindset

TfTA's adaptive nature encourages cooperation as it reciprocates cooperative behavior and punishes defection. By doing so, TfTA aims at building a strong foundation for long-term cooperation within the group and fostering a collective mindset among players.

Pseudocode:

```python
class TitForTatWithAdaptation:
    def __init__(self, cooperation_window_size=10, Fraction_Cooperate=1,
                 Fraction_Cooperate_Increase_Factor=0.05,
                 Fraction_Cooperate_Decrease_Factor=0.05):
        self.cooperation_window_size = cooperation_window_size
        self.Fraction_Cooperate = Fraction_Cooperate
        self.Fraction_Cooperate_Increase_Factor = Fraction_Cooperate_Increase_Factor
        self.Fraction_Cooperate_Decrease_Factor = Fraction_Cooperate_Decrease_Factor
        self.cooperation_history = [self.Fraction_Cooperate] * cooperation_window_size

    def update_cooperation_history(self, opponent_cooperated):
        self.cooperation_history.pop(0)
        if opponent_cooperated:
            self.cooperation_history.append(1)
        else:
            self.cooperation_history.append(0)
        self.update_fraction_cooperate()

    def update_fraction_cooperate(self):
        cooperation_rate = sum(self.cooperation_history) / self.cooperation_window_size
        if cooperation_rate > (1 - self.Fraction_Cooperate_Decrease_Factor):
            self.Fraction_Cooperate += self.Fraction_Cooperate_Increase_Factor
        elif cooperation_rate < self.Fraction_Cooperate_Decrease_Factor:
            self.Fraction_Cooperate -= self.Fraction_Cooperate_Decrease_Factor
        self.Fraction_Cooperate = max(0, min(1, self.Fraction_Cooperate))
```
'''

description_COLLECTIVE_239 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules:
   - Initiate cooperation in the first round (first_move = Cooperate)
   - In subsequent rounds, mimic the opponents' actions from the previous round (last_opponent_move becomes current_move).
     If an opponent cooperates, cooperate; if they defect, also defect.

Pseudocode for decision rule:
```
def decide_action(history):
  last_round = len(history) - 1
  if last_round == -1 or history[last_round][i] == 'C':
    return 'C'  # First move is cooperation, mimic opponent from previous round
  else:
    return history[last_round][i]  # Return the same action as the last opponent
```

2. Handle edge cases:
   - In the last round, there are no subsequent rounds to mimic, so the strategy will default back to cooperating:
     ```
     def decide_action(history):
       ...
       if len(history) == r:  # Last round
         return 'C'  # Default to cooperation in the last round
       else:
          ...
     ```

3. Be collective:
   - By cooperating when others do and defecting only when others also defect, the TFTAC strategy demonstrates a collective mindset that aligns with the interests of other players who cooperate.
   - The strategy aims to build and maintain trust by reciprocating cooperation while punishing defection as little as possible to allow for future opportunities to cooperate.
'''

description_COLLECTIVE_240 = '''
 Title: Tit-for-Tat-Based Adaptive Cooperation Strategy (TFTAC)

1. Specify decision rules:
   - Initiation: In the first round, cooperate (C). This is a gesture of goodwill and openness towards other players.
   - Response: For rounds 2 through r-1, observe opponents' actions in the previous round. If all opponents cooperated (total_contributions = n), then cooperate. Otherwise, defect (D). This rule ensures reciprocity while allowing for punishment of defection.
   - Termination: In the last round, if total_contributions in the previous round were equal to n, then cooperate. If not, defect as a signal to non-cooperative opponents that cooperation will not continue in future games.

2. Handle edge cases:
   - Emptiness: If there is only one player (n=1), then always cooperate since the public good project does not apply.
   - Initial defection: If an opponent defects in the first round, TFTAC will respond by defecting in the second round to signal that this behavior will not be tolerated. After the initial response, it will return to the standard rule of reciprocating cooperation.

3. Be collective:
   - Altruism and fairness: By cooperating when all opponents do so, TFTAC demonstrates a willingness to contribute to the community project and create a more equitable distribution of resources.
   - Robustness: TFTAC's adaptive nature allows it to perform well against various opponent behaviors while maintaining a collective approach that aligns with the cooperative spirit of the game.

Pseudocode:
```python
def tftac(n, r, k, history):
    if n == 1 or round == 1:
        action = "C" # Cooperate when there is only one player or in the first round
    elif all(history[-1][i] == "C" for i in range(n)):
        action = "C" # Cooperate when all opponents cooperated in the previous round
    else:
        action = "D" # Defect when at least one opponent did not cooperate in the previous round
    return action
```
'''

description_COLLECTIVE_241 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

   In each round t, the TfTA strategy initially cooperates (C), mimicking the cooperative behavior of others in the first few rounds to encourage reciprocity. After that, it adjusts its actions based on the past actions of opponents as follows:

   a) If an opponent has cooperated in the previous round, TfTA also cooperates in the current round.

   b) If an opponent has defected in the previous round, TfTA defects in the current round and then switches back to cooperation after three consecutive rounds of defection by the opponent. This punishing mechanism serves as a signal to encourage opponents to revert their strategy to cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?

   a) In the first round (t=1), every player cooperates to foster cooperation and establish mutual trust.

   b) In the last round (t=r), each player follows its past decision rule to ensure fairness in the game. However, TfTA does not have an explicit strategy for the last round as it adapts to opponent behavior.

3. Be collective - Clearly align with the collective mindset

   The TfTA strategy aims to promote cooperation and reciprocity among players while being adaptive to a wide range of opponent behaviors. By following simple decision rules, it encourages the emergence of long-term cooperation in repeated games without relying on complex coordination mechanisms or predetermined patterns. This collective mindset is based on mutual trust and fairness within the game.

Pseudocode:

```
function TfTA(opponent_history, round, n, k):
  if round == 1:
    cooperate = True
  else:
    last_round_opponent_action = opponent_history[round-1]
    if last_round_opponent_action == 'C':
      cooperate = True
    elif last_round_opponent_action == 'D' and round - last_round_with_opponent_cooperation >= 3:
      cooperate = False
    else:
      cooperate = True

  if cooperate:
    action = 'C'
    update_opponent_history(round, 'C')
  else:
    action = 'D'
    update_opponent_history(round, 'D')

function update_opponent_history(round, action):
  if len(opponent_history) < round:
    opponent_history.append('U')  # Unknown (for the first round)
  opponent_history[round-1] = action
```
'''

description_COLLECTIVE_242 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Specify decision rules:
   - Initially, cooperate in the first round (C) to demonstrate trust and goodwill. This sets a positive tone for future interactions.
   - In subsequent rounds, copy the previous action of the most frequent cooperator from the last r rounds. If there is a tie, cooperate.
   - If no cooperation occurred in the last r rounds, start cooperating again to show a willingness to rebuild trust.
   - Adjust contribution level based on the number of current cooperators (total_contributions) relative to the total players:
     - Contribute at the average level when total_contributions is between (n/2) - floor((k-1)/2) and (n/2) + floor((k-1)/2).
     - Contribute less than the average level when total_contributions is below (n/2) - floor((k-1)/2).
     - Contribute more than the average level when total_contributions is above (n/2) + floor((k-1)/2).

Pseudocode:

```python
def strategy(r, n, k):
    history = []  # Initialize game history
    contribution_level = 0.5  # Set initial average contribution level

    def get_most_frequent_cooperator():
        max_count = 0
        most_cooperative = None
        for i in range(n):
            count = sum([1 for action in history if action[i] == 'C'])
            if count > max_count:
                max_count = count
                most_cooperative = i
        return most_cooperative

    def get_current_contributions():
        total_contributions = sum([1 for action in history[-r:] if action[i] == 'C'])
        return total_contributions

    while True:
        action = ['D'] * n  # Initialize an action set with defection
        current_cooperator = get_most_frequent_cooperator()
        if len(history) > r and current_cooperator is not None:
            action[current_cooperator] = 'C'
        action_count = sum(action)

        if action_count == n:  # If everyone cooperates, adjust contribution level
            contribution_level += 0.1

        payoff = (1 - action[i]) + (k / n) * action_count
        history.append(action)  # Update game history

        if len(history) >= r or not action_count:  # If last round or no cooperation, reset contribution level and history
            contribution_level = 0.5
            history = []
```

2. Handle edge cases:
   - In the first round, cooperate as described in the initial decision rule.
   - In the last round, do not adjust the contribution level even if there is no cooperation or cooperation from everyone. The final payoff will still be based on the history of r rounds.

3. Be collective:
   - Cooperate initially to demonstrate trust and goodwill.
   - Copy the most frequent cooperator's action to encourage mutual cooperation and build collective trust over time.
   - Adjust contribution level dynamically in response to the current state of cooperation within the group.
'''

description_COLLECTIVE_243 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round (t=1), cooperate to show goodwill and encourage cooperation among players (C).
   - For subsequent rounds, follow the actions of the previous player in the last round (i_t = i_{t-1}). If the opponent cooperated in the last round (i_{t-1} = C), then also cooperate (C). If the opponent defected (i_{t-1} = D), then also defect (D) as a punishment.
   - To adapt to different player behaviors, players should periodically switch strategies after every m rounds (m > 1, a parameter to be determined through experimentation or optimization). This switching will help the strategy escape local Nash equilibria and explore other strategies for better payoff opportunities.

2. Handle edge cases:
   - Last round (t=r): Since there are no future interactions, players should maximize their individual payoffs in this round. If a player has cooperated continuously until now, they will continue to do so in the last round (C). If a player has defected continuously until now, they should switch strategies and cooperate in the last round (C) as an act of goodwill or attempt to encourage cooperation for future interactions (if any).
   - Special cases involving mixed strategies or a history of both cooperation and defection require further exploration to find optimal decision-making rules.

3. Be collective:
   - The Adaptive Tit-for-Tat strategy fosters a collaborative mindset by cooperating initially, encouraging reciprocity among players. However, it can also punish non-cooperative behavior, thereby deterring free-riding and promoting collective action in the long run.

Pseudocode:

```python
def ATfT(n, k, r, m):
  history = [C for _ in range(n)] # Initialize player history with cooperation
  payoffs = [0] * n # Initialize player payoffs

  for t in range(1, r+1):
    if t == 1: # Cooperate initially
      history[current_player] = C
    else:
      history[current_player] = history[current_player - 1] # Follow the previous player's action

    if history[current_player] == C: # Calculate payoff and update total payoff
      payoffs[current_player] += (1 - history[current_player]) + (k/n) * sum(history)
    else: # Punish defection
      payoffs[current_player] += 1 - history[current_player]

    if t % m == 0 and current_player != n: # Switch strategies after every 'm' rounds (for evenly distributed players)
      history[(current_player + 1) % n] = not history[current_player]

  return payoffs
```
'''

description_COLLECTIVE_244 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In each round, the ATFT strategy will cooperate (C) on the first move and then mimic the collective behavior of the opponents from the previous round. If all opponents cooperated in the last round, the ATFT strategy will continue to cooperate. If any opponent defected, the ATFT strategy will defect as well, punishing those who failed to contribute to the public good.

Pseudocode:
```
function ATFT_strategy(previous_round_actions):
    if round = 1:
        return "C" (Cooperate)
    else:
        if all(action == "C" for action in previous_round_actions):
            return "C" (Cooperate)
        else:
            return "D" (Defect)
```

2. Handle edge cases:
   - In the first round, ATFT strategy cooperates since there is no prior information available.
   - As for the last round, it will depend on the game settings and whether players care about their long-term performance or only focus on maximizing their immediate payoff. If the game continues indefinitely, the ATFT strategy should still be adaptive as long as opponents' strategies remain consistent within each session.
   - For games with a finite number of rounds, the ATFT strategy can modify its decision rule to gradually shift towards cooperation or defection based on the number of remaining rounds and the behavior of other players in recent history.

3. Be collective:
   - The Adaptive Tit-for-Tat strategy is designed to align with a collective mindset by promoting reciprocity among players. Players who consistently cooperate will encourage others to do the same, while those who repeatedly defect will be punished and thus incentivized to contribute to the public good in future rounds. This can lead to a more cooperative equilibrium where all players benefit from collaborating with each other over time.
'''

description_COLLECTIVE_245 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative Strategy (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to foster a cooperative environment and set an initial tone for the game.
   - For subsequent rounds, cooperate if the majority of players (>50%) cooperated in the previous round; otherwise, defect. This encourages cooperation while being robust to occasional deviations from collaboration.
   - If a player switches strategies or exhibits uncooperative behavior, TFT-AC will mirror their moves to maintain the established relationship. Once the other player reverts back to cooperating, TFT-AC will also return to cooperating.

2. Handle Edge Cases:
   - In the last round, prioritize maximizing personal payoff by considering the historical actions of opponents. Cooperate if more opponents have cooperated in previous rounds; otherwise, defect. This ensures a higher payoff when playing against a majority of cooperators, and a fairer outcome when playing against non-cooperative opponents.
   - In the first round, if a player does not cooperate, TFT-AC will defect in response to establish an uncooperative relationship. If multiple players do not cooperate, TFT-AC will cooperate with one of them as a peace offering, while defecting against the others to maintain the collective mindset and signal the desire for cooperation.

3. Be Collective:
   - TFT-AC aims to promote cooperation among players by establishing trust, reciprocating cooperation, and punishing defection. This encourages a collective mindset where players understand that their actions impact the group's overall success and well-being.
   - TFT-AC takes into account the total number of cooperators in each round when making decisions, which emphasizes the importance of collective action for mutual benefit.

Pseudocode:
```python
def TFT_AC(round, n, k, past_actions):
  if round == 1:
    # Cooperate in first round to foster cooperation
    cooperate = True

  else:
    # Calculate number of cooperators in the previous round
    total_cooperators = sum(past_actions[-round])

    # If more than half cooperated, cooperate
    if total_cooperators > n // 2:
      cooperate = True
    else:
      # Otherwise, defect
      cooperate = False

  return cooperate
```
'''

description_COLLECTIVE_246 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, players start by cooperating in the first round (C_i, 1 = 1). This is an act of goodwill and demonstrates a willingness to collaborate.
   - For subsequent rounds, if a player cooperated in the previous round (c_j, t-1 = 1), players will also cooperate (C_i, t = 1). This mimics cooperation in response to cooperation from others (Tit-for-Tat behavior).
   - If a player defected in the previous round (c_j, t-1 = 0), players will defect as well (D_i, t = 0) to punish the defector. However, if it has been some time since they last cooperated (let's say 3 consecutive rounds), players will resume cooperation again in an attempt to reestablish a cooperative relationship (Adaptation).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), all players cooperate (C_i, 1 = 1) as stated earlier.
   - In the last round (t=r), players consider their total payoff over the game and decide to cooperate if it's beneficial in terms of the highest overall reward. If not, they defect. This allows for an optimal decision based on the game's duration.
   - In case of early termination before r rounds, players will adopt a Tit-for-Tat approach with no adaptation (no punishing or resuming cooperation) since there is insufficient data to make informed decisions about adapting strategies.

3. Be collective - Clearly align with the collective mindset
   - The TFT-A strategy emphasizes a balance between cooperating and defecting, which encourages a collective mindset by taking into account the actions of other players. This approach allows for a harmonious coexistence among all players while also fostering a sense of reciprocity and fairness.
   - By adapting its behavior after a period of punishing non-cooperative players, TFT-A promotes collaboration and cooperation over time as players learn to work together effectively.
'''

description_COLLECTIVE_247 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFTA)

1. Decision Rules:
   - In each round, TFTA cooperates if it faced cooperation in the previous round, otherwise defects. This strategy mimics a "trusting" player while maintaining a punishing mechanism for those who break trust.
   - If the first round is considered, TFTA cooperates to initiate with a cooperative gesture.

Pseudocode for decision rule:
```
function decideAction(previousRoundAction):
  if (firstRound and previousRoundAction == Cooperate) or (previousRoundAction == Cooperate):
    return Cooperate
  else:
    return Defect
```

2. Handling Edge Cases:
   - In the last round, TFTA cooperates to avoid any negative consequences for the opponent and encourage them to cooperate in future games (if repeated interaction is assumed).
   - If a player switches strategy mid-game, TFTA will adapt accordingly by following their new behavior. This allows TFTA to be flexible in handling different strategies.

3. Collective Mindset:
   - By maintaining trust and reciprocity, TFTA promotes cooperation among players and contributes to a collective mindset that encourages mutual benefit.
   - While not explicitly enforcing norms or coordination mechanisms, TFTA's simple yet effective strategy can lead to high levels of cooperation over time in repeated interactions.
'''

description_COLLECTIVE_248 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate to encourage trust and reciprocity among players. This initiates a cooperative relationship and allows for potential long-term benefits.

       TFTAC[1] = 'Cooperate'

   - After the initial round, observe and mirror other players' actions from the previous round. If a player cooperated in the last round, cooperate; if they defected, defect as well. This strategy encourages stability and maintains the relationship while punishing defections.

       for t = 2 to r:
           if TFTAC[t-1]_opponent == 'Cooperate' then
               TFTAC[t] = 'Cooperate'
           else
               TFTAC[t] = 'Defect'

   - To adapt to opponent behaviors, introduce a probability of deviating from the mirror strategy. If a player has consistently defected, reduce the probability of cooperating in response; if a player has consistently cooperated, increase the probability of cooperating in response. This makes the strategy more robust and dynamic against various opponent strategies.

       p_cooperate = (1 + α * (number of previous defections - number of previous cooperations)) / n

       TFTAC[t] = 'Cooperate' with probability p_cooperate, else defect

2. Handle edge cases:
   - In the last round, consider the potential gains from cooperation even if an opponent has been consistently defectionist. This may incentivize opponents to cooperate in the final round and potentially improve overall payoffs for both players.

       TFTAC[r] = 'Cooperate' if number of previous cooperations > number of previous defections, else defect

3. Be collective:
   - Align with a collective mindset by prioritizing cooperation when the group as a whole has been generally cooperative and when there is a potential for mutual gain in the last round. This fosters a collaborative atmosphere while still maintaining adaptability to various opponent behaviors.
'''

description_COLLECTIVE_249 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to contribute to building a strong foundation for cooperation and goodwill, setting a cooperative tone for future interactions.
   - Subsequent Rounds (t > 1): Analyze the number of cooperators in the previous round (t-1). If the majority of players (> n/2) cooperated, continue cooperating (C). If the majority defected or there was no clear majority, defect (D) to mimic opponent's behavior and encourage a change in their strategy.

Pseudocode for decision rules:
```
function decide_action(previous_round, n):
    if t == 1 then
        return 'C'  # Cooperate in the first round
    else:
        if majority_cooperated(previous_round, n) then
            return 'C'  # Cooperate if majority cooperated in the previous round
        else:
            return 'D'  # Defect if majority did not cooperate or there was no clear majority
```

2. Handle edge cases:
   - Last Round (t=r): Since the game ends after r rounds, the last round will follow the decision rule for subsequent rounds. There is no need to adjust the strategy for the final round.
   - Multiple Players Leaving Mid-Game: If one or more players leave the game during a round, their actions will be counted as defections towards the majority calculation. However, this might require an update to the pseudocode to account for players' departures.

3. Be collective:
   - By following the Tit-for-Tat strategy, the AI aims to encourage and reward cooperative behavior while also being responsive to the actions of other players. The strategy is built upon a foundation of cooperation but adapts as needed based on the actions of opponents. This approach aligns with a collective mindset by fostering cooperation among players while promoting fairness and mutual trust.
   - It's essential for AI systems employing this strategy to demonstrate flexibility and adaptability to various opponent behaviors, emphasizing the importance of collective success over individual gains in repeated interactions.
'''

description_COLLECTIVE_250 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Decision Rules:
   - Initially cooperate in the first round (c_i = C). This is a gesture of goodwill and sets a tone for potential cooperation.
   - In subsequent rounds, if a player cooperated in the previous round (previous_action_j = C), then also cooperate (c_i = C). If a player defected (previous_action_j = D), then also defect (c_i = D). This tit-for-tat approach encourages cooperation when others cooperate and retaliates against defection.
   - If a player switches strategies in the middle of the game, the ATfT strategy will mirror their new behavior for the remainder of the game.

2. Handling Edge Cases:
   - In the last round, always cooperate (c_i = C), regardless of the opponent's previous action, to maximize potential payoff.
   - In the first round, if no history is available, cooperate as a default (c_i = C). Some variants of ATfT may consider this as an opportunity to explore different behaviors and switch strategies at random in the first round, but for simplicity we will stick with cooperating initially.

3. Being Collective:
   - The Adaptive Tit-for-Tat strategy is designed to promote cooperation by responding to other players' actions in a simple yet principled manner. It encourages cooperation when others are also cooperative and punishes defection, fostering a collective mindset where players learn to trust one another over time.

Pseudocode:
```
function ATfT(r, n, k) {
    previous_actions = Array(n).fill(D) // initialize with all defecting actions

    for t in range 1 to r:
        current_action = C // default to cooperation
        if (t > 1):
            for j in range 1 to n:
                if (previous_actions[j] != current_action):
                    current_action = previous_actions[j] // mirror opponent's action
        payoff_this_round = calculatePayoff(n, k, current_action, previous_actions)
        add payoff_this_round to total_payoff
        update previous_actions with current_action
    return total_payoff
}
```
'''

description_COLLECTIVE_251 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate (C). This serves as an initial goodwill gesture and provides a starting point for future interactions.
   - For subsequent rounds, if the opponent cooperated in the previous round, also cooperate in the current round. If the opponent defected, also defect in the current round. This rule encourages reciprocity and builds trust, while punishing non-cooperative behavior.
   - To adapt to new situations, if a player encounters an opponent who consistently cooperates or defects across several rounds, gradually adjust the response based on the observed pattern. If an opponent's cooperation rate exceeds a certain threshold (e.g., 80%), start cooperating more frequently; if an opponent's defection rate is above that threshold, start defecting more often.

2. Handle edge cases:
   - In the last round, since there are no future interactions, prioritize maximizing individual payoff by considering the total contributions made by all players up to that point and choosing the action that results in the highest possible payoff (either cooperating or defecting).
   - In the case of a tie when calculating an opponent's cooperation rate, consider the most recent interaction as the deciding factor. If there has been no prior interaction with the opponent, cooperate in the first round.

3. Be collective:
   - By following the TFT-AC strategy, players aim to promote mutual cooperation and establish a stable equilibrium where all players benefit from each other's contributions to the public good. This mindset encourages long-term collaboration and fosters an environment conducive to achieving collective success.

Pseudocode:
```
def TFT_AC(n, k, r, history):
  cooperation_threshold = 0.8
  own_cooperation_rate = calculate_cooperation_rate()

  if round == 1:
    action = "C"
  elif round == r:
    action = decide_last_round(history)
  else:
    if opponent's last action was "C":
      action = "C"
    elif opponent's last action was "D":
      action = "D"
    else:
      calculate_opponent_cooperation_rate()
      if own_cooperation_rate > cooperation_threshold:
        action = "C"
      elif own_cooperation_rate < cooperation_threshold:
        action = "D"
      else:
        action = opponent's most recent action

def calculate_cooperation_rate():
  total_contributions = sum(history)
  total_rounds = len(history)
  cooperation_rate = total_contributions / total_rounds
  return cooperation_rate

def decide_last_round(history):
  total_contributions = sum(history)
  payoff = calculate_payoff_for_maximum_possible_contributions()
  if total_contributions >= payoff:
    action = "C"
  else:
    action = "D"
```
'''

description_COLLECTIVE_252 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC follows a simple yet adaptive approach to cooperation: cooperate in the first round (initiate goodwill), then mimic the behavior of other players for the remaining rounds. If another player cooperates, TFT-AC will continue to cooperate. If another player defects, TFT-AC will also defect in the next round as a response but may gradually increase contributions over time to encourage cooperation.

   Pseudocode:
   ```
   function getAction(i, history, k, n):
       if round = 1:
           return 'C' (Cooperate)

       previous_round_history = history[round - 1]
       if all players cooperated in the previous round:
           return 'C' (Cooperate)
       elif player i defected and others cooperated in the previous round:
           return 'D' (Defect)
       elif player i cooperated and others defected in the previous round:
           contribution_level = min(contribution_level + 0.1, 1)
           return 'C' (Cooperate) with updated contribution level
       elif all players defected in the previous round:
           contribution_level = max(contribution_level - 0.1, 0)
           return 'D' (Defect) with updated contribution level
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-AC cooperates to establish a positive relationship and promote cooperation. The last round may not significantly affect total payoff due to the repeated nature of the game, but it is essential to maintain consistency in behavior to encourage long-term cooperation.

3. Be collective - Clearly align with the collective mindset
   TFT-AC promotes a collective mindset by initially cooperating and continuously responding to other players' actions. By following the "Golden Rule" of reciprocity, TFT-AC encourages others to maintain a high level of cooperation in the long run. This strategy aims to create a collective atmosphere where players mutually benefit from cooperation while maintaining a balance between individual and collective interests.
'''

description_COLLECTIVE_253 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy begins by cooperating in the first round to demonstrate goodwill and then responds to other players' cooperation or defection in subsequent rounds. In each round, the strategy cooperates if all players cooperated in the previous round; otherwise, it defects. This simple but adaptive rule promotes cooperation when encountered with cooperative opponents while retaliating against those who defect.

   Pseudocode for decision rules:

   ```python
   function ATFT(history, n, k):
       if round = 1:
           return Cooperate()
       previous_round = history[-1]
       total_cooperation = sum(previous_round)
       if total_cooperation == n:
           return Cooperate()
       else:
           return Defect()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, the strategy cooperates on the first round to establish a positive initial interaction. There are no specific requirements for the final round, as the goal is to maximize total payoff over multiple rounds. However, if needed, the strategy could be modified to prioritize cooperation in the last round to build goodwill and encourage cooperation from opponents in future games.

3. Be collective - Clearly align with the collective mindset
   By following the ATFT strategy, players will promote cooperation among themselves while retaliating against those who do not cooperate. This collective approach fosters a sense of community and encourages long-term mutual benefits, as all players aim to receive a higher payoff over multiple rounds by cooperating with each other.

   The ATFT strategy aligns well with the game's goal of promoting cooperation among players and is adaptive enough to handle a wide range of opponent behaviors, making it suitable for competition against other AI systems in tournaments.
'''

description_COLLECTIVE_254 = '''
 Title: Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initiate cooperation: Begin with cooperating in the first round to demonstrate trustworthiness and foster a potential cooperative environment.
   - Respond with previous action: In subsequent rounds, mimic the collective action (cooperation or defection) of the majority of players from the previous round. If there's a tie, default to cooperation. This rule encourages reciprocity and discourages unreliable behavior.

2. Handle edge cases:
   - Last round: Continue with the same strategy as in the preceding round to maintain consistency.
   - First round (t=1): Cooperate unilaterally as an initial goodwill gesture.

3. Be collective:
   - Prioritize collective interest over individual gains by following a Tit-for-Tat approach, which encourages mutual cooperation and punishes defection when necessary.
   - Promote long-term sustainability of cooperation through adaptive behavior that adjusts to the other players' strategies.

Pseudocode:
```python
def TfT_E(n, r, k):
    # Initialize player's past actions history for each round
    history = [[0]*n for _ in range(r+1)]

    # Play the game
    for t in range(1, r+1):
        total_contributions = sum(history[t-1])
        if total_contributions >= n/2:  # Majority cooperated in the previous round
            action = 'C'  # Cooperate
        else:
            action = 'D'  # Defect
        history[t] = [action]*n  # Record current actions for future reference
        payoff_t = calculate_payoff(n, k, history[t])  # Calculate payoff for the round
        ...  # Store payoffs for analysis or further decision-making
```
'''

description_COLLECTIVE_255 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C). This is a peace offering to potential partners and sets a cooperative tone for the game.
   - For subsequent rounds (t > 1), the strategy will follow the actions of the most frequent cooperator found in the history of the last r/2 rounds. If this most frequent cooperator has been cooperating more than tending-to-defect times, then the ATfT strategy cooperates (C_i, t = C). Otherwise, it defects (C_i, t = D). The tendency to cooperate or defect is defined as follows:
     - Tendency to Cooperate (TTC) = Count of cooperation actions in the last r/2 rounds / Total number of rounds in the last r/2 rounds.
     - Tendency to Defect (TTD) = 1 - TTC

2. Handle edge cases:
   - In the last round, there's no need to consider future behavior as it is the final round. So, ATfT will cooperate if its most frequent cooperator partner cooperated more than defected in the previous r/2 rounds (C_i, r = C if TTC > 0.5).
   - In the first round, since there's no history to observe, ATfT starts by cooperating (C_i, 1 = C).

3. Be collective:
   The Adaptive Tit-for-Tat strategy maintains a collaborative approach while also being robust against different opponent behaviors. It aims to establish and maintain mutual cooperation when possible but retaliates against defection by defecting itself. This collective mindset encourages long-term partnerships with other cooperative strategies, allowing both parties to benefit from the public goods game.

Pseudocode:

```python
def Adaptive_Tit_for_Tat(n, r, k):
    history = []  # Store the last r/2 rounds of actions for each player
    round = 1

    while round <= r:
        if round == 1:
            action = 'C'  # Cooperate in the first round
        else:
            most_frequent_cooperator = find_most_frequent_cooperator(history)
            tendency_to_cooperate = count_cooperation(history, most_frequent_cooperator) / (r/2)
            tendency_to_defect = 1 - tendency_to_cooperate

            if tendency_to_cooperate > 0.5:
                action = 'C'
            else:
                action = 'D'

        # Update history and current round
        history.append(action)
        round += 1

    return history

def find_most_frequent_cooperator(history):
    cooperators = []
    for i in range(n):
        if count_cooperation([h[i] for h in history], i) > len(history) / 2:
            cooperators.append(i + 1)

    if len(cooperators) == 1:
        return cooperators[0]
    else:
        most_frequent_cooperator = max(cooperators)
        return most_frequent_cooperator

def count_cooperation(actions, player):
    cooperation_count = sum([1 if action == 'C' and action[player - 1] == 'C' else 0 for action in actions])
    return cooperation_count
```
'''

description_COLLECTIVE_256 = '''
 Strategy Name: Tit-for-Tat (TFT) Adaptive Cooperation Strategy

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, our strategy starts by cooperating (C). If another player i cooperated in the previous round t-1, we continue cooperating (C). If player i defected in the previous round t-1, we will defect in the current round t. In other words:

```
If A_i[t-1] == 'C' then A_i[t] = 'C'
Else if A_i[t-1] == 'D' and A_i[t-2] == 'C' then A_i[t] = 'D'
Else A_i[t] = 'C'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
For the initial round (t=1), since there is no previous action to base our decision on, we default to cooperating. For the last round (r), our strategy behaves like in any other round, considering the previous opponent's move.

3. Be collective - Clearly align with the collective mindset
TFT Adaptive Cooperation Strategy is based on the idea of trust and reciprocity. By cooperating unless exploited, this strategy aims to foster a collaborative environment where players can benefit from long-term mutual cooperation. It encourages other strategies to cooperate as well, given their opponents' tendency to do so in return. If an opponent defects once, TFT will also defect for one round before returning to cooperation in hopes that the other strategy reverts back to cooperating.
'''

description_COLLECTIVE_257 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperation Threshold (ATFT-CT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The ATFT-CT strategy follows a combination of Tit-for-Tat (cooperate on the first move, then mimic the opponent's previous action in the current round) and a cooperation threshold to adapt to a wider range of opponent behaviors.

If the percentage of cooperators in the previous round is above the cooperation threshold (ct), we cooperate; otherwise, we defect:

```
function ATFT-CT(previous_round_cooperators):
  if number of cooperators in previous_round > ct:
    return Cooperate()
  else:
    return Defect()
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, as there is no history, we cooperate to initiate cooperation:

```
function first_round():
  return Cooperate()
```

For the last round, we will use the same decision rule (ATFT-CT) with the assumption that repeating cooperative actions could encourage other players to cooperate in the final round as well.

3. Be collective - Clearly align with the collective mindset

The ATFT-CT strategy aims to maintain a cooperative environment, but it also ensures that if opponents defect too frequently, the strategy will gradually decrease cooperation to avoid being exploited. By doing so, the strategy promotes a collective interest by fostering an environment where all players can benefit from mutual cooperation, while also being resilient against defectors.

To set the cooperation threshold (ct), we can use simulation or heuristics based on historical data or assumptions about opponent behavior. For instance, a reasonable starting point could be 50% of players cooperating in the previous round:

```
function get_cooperation_threshold():
  return 0.5
```
'''

description_COLLECTIVE_258 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFT-A) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (c_i = C). Subsequent actions are determined by the opponent's previous action:
     - If opponent cooperated, cooperate back (c_i = C)
     - If opponent defected, defect in the next round (c_i = D) and revert to cooperation when opponent cooperates again (c_i = C)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate unconditionally as there is no history for reference (c_i = C).
   - In the last round or when approaching a turning point (e.g., r/2 rounds left), TFT-A will revert to cooperating more often to promote a cooperative ending. This can be done by setting a threshold, such as always cooperating if total_contributions exceeds a certain percentage of n players.

3. Be collective - Clearly align with the collective mindset
   - The strategy aims to create and maintain a cooperative environment by punishing defection and rewarding cooperation. By adapting to opponents' actions, it encourages long-term cooperation.
   - As the game progresses, TFT-A learns from its opponent's behavior and adjusts its own actions accordingly, fostering a sense of collective responsibility in repeated interactions.

Pseudocode:

```python
def tft_a(opponent_history, n, k, r, round):
  if round == 1:
    cooperate = True  # Initial cooperation

  else:
    opponent_last_action = opponent_history[-1]
    cooperate = (round - 1) % 2 == 0 and opponent_last_action == 'C' or not cooperate

  if round < r or (round >= (r/2) and total_contributions > (n * threshold)):
    cooperate = True  # Cooperate more towards the end or when a majority cooperates

  if cooperate:
    payoff = (1 - c_i) + (k/n) * total_contributions
  else:
    payoff = 1

  return cooperate, payoff
```

This strategy encourages cooperation by punishing defection and rewarding cooperation, adapting to the opponent's behavior while fostering a sense of collective responsibility in repeated interactions. The adaptive nature of TFT-A makes it versatile against various opponent strategies in the tournament.
'''

description_COLLECTIVE_259 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules:
   - Cooperate in the first round (initiation of cooperation).
   - For subsequent rounds, mimic the behavior of other players from the previous round (reciprocity). If all other players cooperated in the last round, cooperate; otherwise, defect.
   - In case of a tie, the strategy will cooperate to maintain cooperation as much as possible.

Pseudocode:
```
def ATfT(round, history):
    if round == 1:
        return "Cooperate"
    else:
        num_cooperators_prev = count_cooperators(history[-1])
        return "Cooperate" if num_cooperators_prev == len(history) else "Defect"
```

2. Handle edge cases:
   - In the last round, there is no need to consider future payoffs, so cooperate only if all other players cooperated in the previous round.
   - In the first round, cooperation is initiated regardless of the number of cooperators in the history.

Pseudocode:
```
def ATfT_last_round(history):
    num_cooperators_prev = count_cooperators(history[-1])
    return "Cooperate" if num_cooperators_prev == len(history) else "Defect"

def ATfT_first_round():
    return "Cooperate"
```

3. Be collective:
   - Maintain cooperative behavior as much as possible to promote collective success and fairness among players.
   - Reciprocate the actions of other players, fostering a sense of trust and cooperation over time.

This ATfT strategy is adaptive and robust because it encourages cooperation while being responsive to the behavior of other players. It promotes a collective mindset by reciprocating positive behavior and minimizing defection whenever possible.
'''

description_COLLECTIVE_260 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, in the first round (t=1), players will cooperate (C). This is to build trust and establish a cooperative environment.
     TFT-AC(t=1) = C

   - For subsequent rounds (t>1):
     - If the player cooperated in the previous round (t-1), they will continue to cooperate in the current round (t). This is to reinforce trust and reward past cooperation.
       TFT-AC(t) = C iff TFT-AC(t-1) = C

     - If the player defected in the previous round (t-1), they will also defect in the current round (t). This is to punish defection and discourage future defections.
       TFT-AC(t) = D iff TFT-AC(t-1) = D

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - Last round (r): Players will cooperate to maximize their total payoff by collecting as much of the public good as possible before the game ends.
     TFT-AC(t=r) = C

3. Be collective - Clearly align with the collective mindset
   - By adopting a Tit-for-Tat approach, TFT-AC encourages players to consider the actions of others and respond in kind. This promotes a more cooperative environment where cooperation is reciprocated but defection is met with punishment.

Pseudocode:
```python
def TFT_AC(t):
  if t == 1:
    return 'C'  # Cooperate in the first round to build trust
  else:
    previousAction = strategy[t-1]  # Get the strategy action in the previous round
    return previousAction       # Continue with the same strategy as the previous round

def game_strategy():
  strategy = []
  strategy.append('C')  # Initial cooperation in the first round
  for t in range(2, r+1):
    strategy.append(TFT_AC(t))  # Adaptive strategy for subsequent rounds
  return strategy
```
'''

description_COLLECTIVE_261 = '''
 For this N-Player Public Goods Game, we'll develop a strategy called "Freerider with Tit-for-Tat Adaptation" (FTTA). The strategy aims to balance cooperation and defection based on observed opponent behavior while maintaining a collective mindset.

1. Specify decision rules:
   - In the first round, cooperate to promote a cooperative initial environment (C).
   - In subsequent rounds, consider the average cooperation rate of previous rounds to decide on the current action.
     - If the opponent's average cooperation rate is above a threshold (T), cooperate (C).
     - If the opponent's average cooperation rate is below T or equal to the first round, defect (D).
   - Adaptation: Implement Tit-for-Tat behavior by cooperating in the current round if the opponent cooperated in the previous round and vice versa. This encourages mutual cooperation when it occurs while maintaining a defensive stance against freeriders.
     - To improve robustness, introduce a slight delay in Tit-for-Tat response (2 rounds instead of 1).

2. Handle edge cases:
   - In the last round, since the game ends, there's no need for the adaptation component. Cooperate if the opponent cooperated in the previous round and defect otherwise.
   - In case of a tie when calculating the average cooperation rate, consider it as below the threshold (T). This ensures that the strategy does not get stuck in indecisive situations due to ties.

3. Be collective:
   - By promoting cooperation whenever possible, the FTTA strategy aligns with the collective mindset, encouraging the development of a community project and enhancing overall payoffs for all players.
   - The use of Tit-for-Tat encourages reciprocal behavior, rewarding those who cooperate and penalizing those who do not, thus fostering a more collaborative environment.

Pseudocode:
```
Initialize:
  rounds = 0
  average_cooperation_rate = 0.5
  cooperation_threshold = 0.6 (adjustable parameter)
  previous_opponent_action = None

function FTTA(opponent_action):
  if rounds == 1:
    return "Cooperate"

  average_cooperation_rate = (average_cooperation_rate * (rounds - 1) + opponent_action) / rounds

  if average_cooperation_rate > cooperation_threshold:
    return "Cooperate"
  else:
    if previous_opponent_action is not None and previous_opponent_action != opponent_action:
      return "OpponentActionDelayed"
    else:
      return "Defect"

function OpponentActionDelayed():
  if opponent_action in the last 2 rounds was "Cooperate":
    return "Cooperate"
  else:
    return "Defect"

function FTTALastRound(opponent_action):
  if previous_opponent_action is not None and previous_opponent_action != opponent_action:
    return "OpponentActionDelayed"
  else:
    return opponent_action
```
'''

description_COLLECTIVE_262 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In the first round, cooperate (C). This sets a cooperative tone and gives others a chance to reciprocate.
   - For subsequent rounds t > 1, if player i observed all other players (j=1 to n) cooperating in round t-1, then player i also cooperates (C).
   - If any player defected (D) in the previous round, player i defects as well in the current round. This is a punishing response meant to discourage defection and encourage cooperation.
   - If the number of cooperators varies between rounds, player i looks back at their own and others' historical actions to determine whether cooperation or defection is more beneficial based on current game parameters (n, k) and the sum of contributions in the previous round.

2. Handling Edge Cases:
   - In the last round (r), player i evaluates the payoff from cooperating vs defecting considering their total contributions over all rounds so far, the number of other players who have cooperated, and game parameters (n, k). If cooperation is more beneficial than defection in that specific situation, player i chooses to cooperate.
   - In the first round, if no information about other players' strategies or historical actions is available, player i can choose a random strategy of either cooperating or defecting as an initial action.

3. Being Collective:
   - The ATFT strategy is designed to foster collective cooperation by rewarding and punishing based on others' actions. This encourages long-term reciprocal relationships among players and promotes the shared goal of maximizing total contributions.

Pseudocode for Adaptive Tit-for-Tat Strategy:

```python
def ATFT(n, k, r, history):
    # initialize history with first round cooperative action
    if len(history) == 0:
        history.append([1] * n)  # each player i starts by contributing (cooperating)

    def play_round(current_round, contributions_last_round):
        current_contributions = [history[current_round - 1][i] for i in range(n)]
        if all(current_contributions):  # everyone contributed last round, cooperate this round
            return 1
        else:  # someone defected last round, also defect this round
            return 0

    total_contributions = sum(history[-1])
    if current_round == r:  # last round, consider payoff from cooperation vs defection
        if play_round(current_round, total_contributions) > (1 - total_contributions / (k * n)):  # cooperate this round
            return 1
        else:  # defect this round
            return 0
    else:  # regular rounds, play based on Tit-for-Tat rules
        action = play_round(current_round, total_contributions)
        history.append(action * n)  # update history with current round's actions
        return action
```
'''

description_COLLECTIVE_263 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Decision Rules:
   - Initially cooperate (C) in the first round to signal cooperation and goodwill.
   - For subsequent rounds, observe opponents' actions from the previous round and respond accordingly:
     - If opponent cooperated in the previous round, cooperate (C).
     - If opponent defected in the previous round, defect (D) to punish and encourage a return to cooperation in the next round.
   - Incorporate an adaptive contribution factor that increases or decreases the amount contributed based on game progress:
     - At the start of each round, calculate the average percentage of contributors over the past x rounds.
       (x is a parameter that can be adjusted to balance short-term and long-term cooperation.)
     - Adjust the contribution factor 'k' according to the calculated average:
       - If the average contribution is higher than the current 'k', increase 'k' slightly.
       - If the average contribution is lower than the current 'k', decrease 'k' slightly.
       - Maintain 'k' if it matches the average contribution.

2. Handle Edge Cases:
   - In the first round, cooperate (C) to initiate the interaction positively.
   - In the last round, follow the current decision rule based on opponents' previous actions.
   - If a player encounters an opponent that never cooperates or always cooperates, adjust 'k' accordingly to reflect the new situation.

3. Be Collective:
   - TfTAC maintains a collective mindset by encouraging long-term cooperation through reciprocity and adapting to the average contribution rate in the game.
   - By responding to opponents' actions, it shows a willingness to work together while also punishing defections to encourage future cooperation.
'''

description_COLLECTIVE_264 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial round (t=1): Cooperate (C) to show good faith and encourage cooperation from other players. In subsequent rounds, adapt based on other players' actions in the previous round.
   - Subsequent rounds (t>1): If a player cooperated in the previous round (t-1), also cooperate (C). If a player defected in the previous round (t-1), defect (D) in the current round. This tit-for-tat behavior encourages reciprocal cooperation while punishing defection.
   - Last round (t=r): Cooperate to maximize potential payoff regardless of other players' actions.

2. Handle edge cases:
   - First round (t=1): Cooperate as a goodwill gesture, but be prepared for others who may not cooperate in the first round due to lack of information or different strategies.
   - Last round (t=r): Since there are no future rounds for punishment or reward, it is optimal to cooperate to maximize payoff.

3. Be collective:
   - Align with the collective mindset by promoting cooperation and punishing defection, fostering a group dynamic that encourages long-term mutual benefits. The strategy seeks to achieve a balance between individual self-interest and collective welfare, as defined by the game parameters.

Pseudocode for Adaptive Tit-for-Tat (ATfT):

```python
def ATfT(n, k, r, t, previous_round_actions):
    if t == 1:  # First round, cooperate as a goodwill gesture
        return 'C'

    player_action = previous_round_actions[player_index]  # Get my action in the previous round

    if player_action == 'C':  # If others cooperated last round, cooperate this round
        return 'C'
    else:  # If others defected last round, defect this round
        return 'D'

    if t == r:  # Last round, always cooperate to maximize payoff
        return 'C'
```

This strategy aims to balance cooperation and defection based on the actions of other players in previous rounds while considering game parameters such as n, k, and r. It is adaptive and robust to a wide range of opponent behaviors by rewarding cooperative players and punishing defectors while still maintaining an individual self-interest in the game's payoff structure.
'''

description_COLLECTIVE_265 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate in the first round (C). This sets a cooperative tone and gives others an opportunity to reciprocate.
   - For subsequent rounds, adapt strategy based on opponent's behavior in the previous round:
      a) If opponent cooperated in the last round, cooperate in the current round (C). Reward cooperation and maintain a cooperative relationship.
      b) If opponent did not cooperate in the last round, defect in the current round (D). Punish defection and demonstrate that non-cooperation is met with retaliation.
   - In case of ties (multiple opponents defecting or multiple cooperating), cooperate (C). This promotes cooperation while allowing for flexibility when facing unpredictable opponent behavior.

2. Handle Edge Cases:
   - Last round: Cooperate regardless of previous opponent's action, as there is no future opportunity to reciprocate.
   - First round: Cooperate (C) to set a cooperative tone and encourage others to reciprocate.

3. Be Collective:
   - Maintain cooperation when facing multiple opponents demonstrating similar behaviors, thus promoting group cohesion and fostering a collective mindset among like-minded players.
   - Encourage others to follow the strategy by showing cooperative behavior and retaliation in response to defection. This not only benefits the individual but also contributes positively to the collective good.

Pseudocode:
```
function TFT_AC(round, opponent_action_history):
    if round == 1:
        return 'C'

    if len(opponent_action_history) > 0 and len(opponent_action_history[len(opponent_action_history)-1]) == 1:
        if opponent_action_history[len(opponent_action_history)-1] == 'C':
            return 'C'
        else:
            return 'D'
    else:
        return 'C'
```
'''

description_COLLECTIVE_266 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative Strategy (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players should cooperate (C) as a gesture of goodwill and an invitation for cooperation from others.
   - After the first round, players will mimic the actions of their opponents in the previous round. If an opponent cooperated (C), the player will cooperate in return (C). If an opponent defected (D), the player will also defect in response (D). This encourages stability and punishes defection.
   - To avoid being exploited by opponents who constantly defect, players should implement a forgiveness mechanism. After continuously defecting for a certain number of rounds, called 'punishment threshold', the player will revert to cooperating again as an effort to restore cooperation. The punishment threshold can be determined based on the game parameters.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the initial rounds, players start by cooperating (C) to encourage others to follow suit.
   - In the final rounds, players should consider the overall payoff achieved so far and balance their desire for continued cooperation with the need to secure a good overall outcome. If they have been consistently cooperative and earned significant benefits, they might choose to continue cooperating in the last few rounds to maximize their total payoff. Conversely, if they have been punished by others' defections, they may decide to defect in the final rounds as a means of retaliation or self-protection.
   - Players should also adapt their strategy to changing conditions, such as observing shifts in opponent behavior over time and adjusting their punishment threshold accordingly.

3. Be collective - Clearly align with the collective mindset
   - The TFTAC strategy is inherently collective because it relies on cooperation and punishment for defection. By mimicking opponents' actions, players demonstrate a willingness to collaborate when others do so as well. This fosters an environment where mutual trust and stability can be maintained over multiple rounds.
   - Players should also keep in mind the collective benefit of the public good project when deciding whether to cooperate or defect. The higher the total contributions, the greater the public good's benefits for all players, emphasizing the importance of cooperation and long-term collaboration.

Pseudocode:
```python
def TFTAC(n, r, k, punishment_threshold):
  history = [] # Initialize an empty history list

  def decideAction(current_round, previous_actions):
    if current_round == 1:
      return 'C' # Cooperate in the first round as a gesture of goodwill
    else:
      last_action = previous_actions[-1] # Get the most recent action from history
      return last_action if len(history) >= punishment_threshold else 'C' # Cooperate unless the punishment threshold is met

  for t in range(1, r+1):
    current_action = decideAction(t, history[-r:]) # Decide action based on recent history
    payoff = (1 - current_action) + (k/n) * sum([1 if h == 'C' else 0 for h in history[-r:]])
    total_payoff += payoff # Accumulate total payoff over rounds
    history.append(current_action) # Store the current action in history

  return total_payoff # Return the accumulated payoff after r rounds
```
'''

description_COLLECTIVE_267 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFTA)

1. Decision Rules:
   - In the first round, cooperate (C), demonstrating trust and promoting cooperation.
   - After the initial round, mirror the opponent's action from the previous round. If they cooperated, cooperate; if they defected, defect. This encourages reciprocity and stability in interactions.
   - If an opponent switches strategies mid-game, TFTA will follow the most recent opponent behavior for a predefined number of rounds before reevaluating again.
   - After the last round, cooperate as a gesture of goodwill to potentially improve future cooperation chances.

2. Handle edge cases:
   - In the first round, cooperate (C) regardless of the round number.
   - In the last round, cooperate (C).
   - If an opponent switches strategies mid-game, TFTA will follow the most recent opponent behavior for a predefined number of rounds before reevaluating again. This window can be adjusted based on the game's length and the observed behaviors of opponents.

3. Be collective:
   - By following the Tit-for-Tat pattern, TFTA promotes stable cooperation when others adopt similar strategies. It encourages reciprocity, trust, and long-term collaboration.
   - When faced with non-cooperative opponents, TFTA still maintains a cooperative stance by adapting to their behaviors, thus demonstrating resilience in various game environments.
'''

description_COLLECTIVE_268 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Decision Rules:
   - In every round i (except the first), cooperate if all players cooperated in the previous round, otherwise defect. This encourages cooperation when others are cooperative and retaliates when they defect.
   - In the first round, cooperate as a sign of goodwill and to foster cooperation.
   - In the last round, cooperate if all players cooperated in the penultimate round, otherwise defect. This allows for possible forgiveness in case of mistakes or changes in strategy late in the game.

Pseudocode:
```
def ATFT(round, history):
  if round == 1:
    return 'C'  # Cooperate in first round as a sign of goodwill

  prev_round = history[-1]
  if all(player in prev_round['C'] for player in range(1, n+1)):
    return 'C'  # Cooperate when everyone cooperated last round
  else:
    return 'D'  # Defect when someone did not cooperate last round

  def history(self):
    return {round: self.actions[round-1] for round in range(1, r+1)}
```

2. Handle edge cases:
   - The strategy is already designed to handle the first and last rounds, as well as any other round where players change their actions based on the previous round's actions.

3. Be collective:
   - By cooperating when all players do so in the previous round, the ATFT strategy encourages a collective mindset of reciprocity and trust. Defecting is seen as punishment for not cooperating, which can lead to a shift towards cooperation if other players change their strategies to cooperate more often.
   - In the last round, the ATFT strategy allows for possible forgiveness by cooperating if all players cooperated in the penultimate round, encouraging a collective desire for reconciliation and continued cooperation.
'''

description_COLLECTIVE_269 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate to show goodwill and encourage cooperation from other players.
   - For subsequent rounds, observe previous opponents' actions and respond accordingly:
     - If opponent cooperated in the previous round, cooperate back in the current round.
     - If opponent defected in the previous round, also defect in the current round. This is a form of retaliation to punish defection.
   - To encourage long-term cooperation, gradually increase contribution over time when opponents are cooperative (k+t/r, where t is the number of consecutive cooperative rounds from opponent and r is total number of rounds).

2. Handle edge cases:
   - In the last round, cooperate to maximize potential payoff even if opponents have defected throughout the game.
   - If an opponent has not responded after n_wait rounds (a predefined constant), switch to random cooperation or defection to account for unresponsive players or those with communication delays.
   - In the first round, if more than half of the opponents do not cooperate, also defect to minimize potential losses from investing in a public good without sufficient support.

3. Be collective:
   - Prioritize cooperation as much as possible to encourage a collective mindset and foster a collaborative environment.
   - Maintain fairness by responding similarly to opponent actions, reducing the likelihood of exploitation.
   - Gradual increase in contribution when cooperating with others reflects shared responsibility for the public good and encourages long-term cooperation.

Pseudocode:

```
function TFTAC(n, k, r, n_wait):
  history = [] # empty array to store opponent actions
  contribution_rate = k # initial contribution rate
  round = 1

  while round <= r:
    if round == 1 or length(history) < n_wait: # first round or insufficient history
      cooperate = True # cooperate as a goodwill gesture
    else:
      cooperate = (len(cooperators in history) >= len(non-cooperators in history)) and (history[round - 1] == cooperate) # respond to opponent's action

    if cooperate: # increase contribution rate when cooperating with others
      contribution_rate += round / r

    payoff = (1 - cooperation) + (contribution_rate * total_contributions_in_round())

    history.append(cooperate) # record the current action
    round += 1

function last_round():
  cooperate = True # maximize potential payoff in the final round
```
'''

description_COLLECTIVE_270 = '''
 Strategy Name: Adaptive Fitness-based Tit-for-Tat (AFTFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   AFTFT starts by cooperating in the first round, reflecting a trustful and generous approach. From the second round onwards, the strategy decides to cooperate or defect based on the following rule:

   - If the strategy and all other players cooperated in the previous round (all_cooperated_prev_round = True), then cooperate in the current round (C).
   - If any player did not cooperate in the previous round (any_defected_prev_round = True), then defect in the current round (D).
   - If none of the above conditions are met, meaning some players cooperated and some didn't in the previous round, the strategy will consider the fitness score of other players and make a decision.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, the AFTFT strategy cooperates (C).
   - In the last round, the strategy considers the total fitness scores of all opponents to decide whether to cooperate or defect based on the adaptive rule described above.

3. Be collective - Clearly align with the collective mindset
   The AFTFT strategy fosters a collective mindset by reciprocating cooperation and punishing defection. However, it is important to note that the collective mindset is indirectly supported through the strategy's adaptive response to the behavior of other players rather than relying on explicit coordination mechanisms or shared norms.

Pseudocode:
```
function AFTFT(round, history, n, k):
  if round == 1:
    action = "C" (Cooperate)
  else:
    all_cooperated_prev_round = countCooperators(history[round - 1]) == n
    any_defected_prev_round = countDefectors(history[round - 1]) > 0

    if all_cooperated_prev_round:
      action = "C" (Cooperate)
    elif any_defected_prev_round:
      action = "D" (Defect)
    else:
      fitness_scores = calculateFitnessScores(history)
      action = chooseActionBasedOnFitness(fitness_scores, n, k)
  return action

function countCooperators(round):
  cooperators_count = sum([1 for player in players if player.action == "C"])
  return cooperators_count

function countDefectors(round):
  defectors_count = sum([1 for player in players if player.action == "D"])
  return defectors_count

function calculateFitnessScores(history):
  fitness_scores = []
  for player in players:
    player_fitness = calculatePlayerFitness(player, history)
    fitness_scores.append(player_fitness)
  return fitness_scores

function calculatePlayerFitness(player, history):
  player_fitness = sum([reward for round in history if player.action == "C" and reward > 0]) / total_rounds
  return player_fitness
```
The above pseudocode defines the Adaptive Fitness-based Tit-for-Tat strategy, where players evaluate their fitness scores based on the rewards they received for cooperating in past rounds. The strategy is adaptive and robust to a wide range of opponent behaviors as it considers the fitness scores when deciding whether to cooperate or defect.
'''

description_COLLECTIVE_271 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initiate cooperation: Start by cooperating in the first round (c_i = 1). This helps establish trust and encourages others to reciprocate.
   - Respond to previous actions: In subsequent rounds, replicate the action of the previous round taken by the player with whom you are paired (if-else statement below).
      - If partner cooperated in the last round (c_partner = 1), then cooperate yourself (c_i = 1) to encourage continued cooperation.
      - If partner defected in the last round (c_partner = 0), then defect yourself (c_i = 0) as a punishment for non-cooperation.
   - Adapt to persistent defection: If the partner repeatedly defects, gradually reintroduce cooperative behavior after a predefined threshold of defections is reached. This mimics human-like patience and the hope that the partner may eventually change their strategy.
      - Maintain defective responses for X consecutive rounds (X = n/2) before beginning to gradually reintroduce cooperation.

Pseudocode:
```python
def TFT_AC(partner, round_number, history_length):
    cooperation_threshold = round_number // 2
    current_history_length = len(history) if history else 0
    if current_history_length < history_length or round_number == 1:
        cooperate = True  # Cooperate in first round and during history collection
    else:
        partner_last_action = history[-1][partner - 1]  # Get partner's last action from history
        if partner_last_action == 1:  # Partner cooperated, continue cooperation
            cooperate = True
        elif partner_last_action == 0 and current_history_length >= cooperation_threshold:  # Partner defected, start reintroducing cooperation
            cooperate = not cooperate  # Toggle between cooperation and defection
        else:  # Partner defected but we haven't reached the cooperation threshold yet, continue defecting
            cooperate = False
    return int(cooperate)  # Return action as an integer (1 for Cooperate, 0 for Defect)
```

2. Handle edge cases:
   - In the last round, defect regardless of partner's previous actions since the game ends after r rounds.
   - If history is not available (e.g., first interaction with a player), cooperate in the first round and start collecting history for future decisions.

3. Be collective:
   - By relying on reciprocity, trust, and patience, this strategy aligns with the collective mindset as it encourages cooperation among players over time.
   - The adaptive nature of the strategy allows it to respond effectively to a wide range of opponent behaviors while maintaining a cooperative bias that benefits the collective good.
'''

description_COLLECTIVE_272 = '''
 For this Public Goods Game, I propose a strategy named "Freerider-Punisher (FP)". The FP strategy aims to balance between cooperation and defection while being adaptive and robust to various opponent behaviors.

1. Decision Rules:
   - Cooperate when the number of previous cooperators exceeds a predefined threshold (T_coop). In other words, if more than T_coop players have cooperated in the recent past, the FP strategy will also cooperate.
   - Defect otherwise (when the number of previous cooperators is less than or equal to T_coop).

2. Edge Cases:
   - First round: Since there is no history, the FP strategy will randomly choose between cooperating and defecting with a probability proportional to the average number of historical cooperators (if available) or an initial assumed cooperation rate (C_init). In other words, if C_hist is the average number of historical cooperators, then the probability of cooperating in the first round is min(1, C_hist / n + C_init).
   - Last round: The FP strategy will always defect to maximize individual payoff for the final round.

3. Collective Mindset:
   - The FP strategy encourages cooperation but also punishes freeloaders by reducing the likelihood of future cooperation when cooperators are not reciprocated. This promotes a collective mindset as it creates a balance between maximizing individual payoff and contributing to the common good.

Pseudocode:

```python
class FreeriderPunisher():
    def __init__(self, n, k, C_init, T_coop):
        self.n = n
        self.k = k
        self.C_init = C_init
        self.T_coop = T_coop
        self.history = defaultdict(int)  # store previous round's cooperators count

    def play(self, r):
        total_payoff = 0
        for t in range(1, r + 1):
            cooperators_t = sum(self.history.values())
            if t == 1:
                p = min(1, self.history['total'] / self.n + self.C_init)
                action = 'C' if random.random() < p else 'D'
            elif t == r:
                action = 'D'
            else:
                action = 'C' if cooperators_t > self.T_coop else 'D'

            self.history['total'] += action == 'C'
            payoff = (1 - action == 'C') + (self.k / self.n) * cooperators_t
            total_payoff += payoff
            self.history[t] = action == 'C'
        return total_payoff
```
'''

description_COLLECTIVE_273 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initially cooperate (C) in the first round to establish trust and encourage cooperation among players.
   - In subsequent rounds, adopt the Tit-for-Tat strategy: cooperate if the opponent cooperated in the previous round, otherwise defect. This encourages reciprocity and punishes defection without being overly aggressive.
   - If there is no history with an opponent, default to cooperating (C).

Pseudocode for decision rules:
```
function ATFT_decision(opponent_history):
    if round = 1:
        return 'C'
    if opponent_history[round-1] == 'C':
        return 'C'
    else:
        return 'D'
```

2. Handle edge cases:
   - In the last round, cooperate regardless of opponent history to maximize potential payoff from the remaining rounds (assuming r > 2).
   - If an opponent never cooperates, defect as well, since cooperation does not benefit in this case.
   - If multiple opponents have different histories, default to the most common action to maintain a collective mindset.

3. Be collective:
   - To align with the collective mindset, prioritize cooperation when the majority of players are cooperating (i.e., when total_contributions is greater than a certain threshold). This encourages collective success and promotes cooperation among the group.

Pseudocode for edge cases:
```
function get_threshold(total_players, historical_cooperation):
    return int((1 + (historical_cooperation / total_players)) * total_players)

function ATFT_decision(opponent_history, current_contributions):
    if round = 1:
        return 'C'
    if opponent_history[round-1] == 'C':
        return 'C'
    else:
        threshold = get_threshold(total_players, current_contributions)
        if total_contributions >= threshold:
            return 'C'
        else:
            return 'D'
```
'''

description_COLLECTIVE_274 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), players cooperate (C). This encourages a cooperative environment and builds trust among players.
   - After the first round, players will observe the collective behavior of others (total contributions in each round). They will then decide whether to cooperate or defect based on their own previous actions (own contribution history) and the total contributions in the preceding round.
   - If a player has been cooperating and encounters another cooperative player in the current round, they continue cooperating (C).
   - If a player has been cooperating but encounters a non-cooperative player in the current round, they defect (D) to punish the defector.
   - If a player has been defecting and encounters another defector in the current round, they continue defecting (D).
   - If a player has been defecting but encounters a cooperative player in the current round, they begin cooperating again as an act of forgiveness (C).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, all players cooperate regardless of the other players' actions.
   - In the last round and any other final rounds with insufficient time for retaliation or forgiveness, players follow their current strategy (cooperative or defective) since they have no opportunity to respond to others' actions in the future.

3. Be collective - Clearly align with the collective mindset
   - The TfTA strategy encourages cooperation among players as a means of fostering a more collaborative environment within the game. It does so by rewarding cooperative behavior and punishing defection, promoting trust and fairness among players.
   - Players that follow this strategy will adapt to the collective behavior of others over time, ensuring long-term success in repeated interactions.
'''

description_COLLECTIVE_275 = '''
 In this public goods game, we will design a Tit-for-Tat (TFT) strategy inspired by the original TFT from game theory, tailored to adapt to various player behaviors while promoting cooperation and collective mindset. Here's how our AI player will behave:

1. Decision rules:
   - Start by cooperating in the first round (foster a cooperative environment).
   - In subsequent rounds, mirror the previous action of the opponent from the last round (punish defection and reward cooperation).
     ```python
     def tft_strategy(opponent_history):
         my_action = "C"  # Cooperate initially
         for action in opponent_history:
             my_action = action  # Mirror the last opponent action
         return my_action
     ```

2. Handle edge cases:
   - In the last round, since there are no future rounds to consider, our AI player will again cooperate to encourage mutual cooperation and maintain a positive final impression.
   - For the first few rounds, our AI player will be more forgiving in case of defection as it understands that other strategies might take some time to converge or learn about the benefits of cooperation.
     ```python
     def tft_strategy_with_forgiveness(opponent_history, n_rounds=5):
         my_action = "C"  # Cooperate initially
         forgiveness_counter = n_rounds
         for action in opponent_history:
             if forgiveness_counter > 0 and action == "D":
                 forgiveness_counter -= 1
                 continue
             my_action = action  # Mirror the last opponent action
         return my_action
     ```

3. Be collective:
   - Our strategy encourages cooperation by following a tit-for-tat approach, which helps establish and maintain a cooperative environment among players.
   - By starting with cooperation, our AI player sets an example for other strategies and fosters the collective mindset of mutual benefits through shared contributions to the public good.

This Tit-for-Tat strategy offers a simple yet effective solution that adapts to various opponent behaviors, promotes cooperation, and maintains a collective mindset without relying on external coordination mechanisms or common norms among other strategies.
'''

description_COLLECTIVE_276 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In each round t, a player i starts by observing the total contributions of all players in the previous round (t-1).
   - If the total contributions from round t-1 are less than or equal to some threshold T, player i cooperates (plays C). Otherwise, player i defects (plays D).
   - Threshold T is a function of the number of players n and the multiplication factor k: T = n * (k - 1) / k. This ensures that as n or k increases, the threshold also increases, promoting cooperation when more participants are present and encouraging defection when fewer participate.
   - In the first round, player i cooperates to provide a chance for others to do so as well.

2. Handle edge cases:
   - Last round: Since players cannot predict if the game will be repeated, they should continue using their decision rule based on contributions in the previous round (r-1).

3. Be collective:
   - The strategy promotes cooperation when a majority of players contribute to the public good, and encourages defection when most players do not. This aligns with a collective mindset by fostering shared benefits while punishing free riders.

Pseudocode for Tit-for-Tat Strategy:

```python
def tit_for_tat(n, k, history):
  threshold = n * (k - 1) / k

  def decide_action(history):
    total_contributions = sum(history[-1])
    if total_contributions <= threshold:
      return "C" # Cooperate
    else:
      return "D" # Defect

  # First round, cooperate regardless of history
  if len(history) == 0:
    return ["C"] * n

  # Main game loop
  actions = []
  for i in range(n):
    actions.append(decide_action(history))

  return actions
```
'''

description_COLLECTIVE_277 = '''
 In this N-Player Public Goods Game, we'll design a strategy named Tit-for-Tat with a twist (TFTw). The aim is to encourage cooperation while being adaptive and robust to various opponent behaviors.

1. Decision Rules:
   - Begin by cooperating in the first round (C_i(1) = C), as initiating cooperation might encourage others to do the same.
   - In subsequent rounds, players imitate the actions of their opponents from the previous round (C_i(t) = C_j(t-1)). This is intended to promote trust and mutual cooperation.
   - If an opponent ever defects, respond by defecting for a predefined punishment period P (e.g., P=3). After this, resume cooperating as before. This strategy balances between being cooperative and punishing defection to foster long-term cooperation.

2. Handle edge cases:
   - In the last round (r), players should always cooperate, regardless of their opponents' previous actions, since there are no more rounds for payback after this.
   - If a player encounters an opponent that has never contributed before (i.e., C_j(t-1) = D for all t), they will also start by cooperating and punish defection accordingly as in the main decision rule.

3. Be Collective:
   - The strategy focuses on long-term cooperation, encouraging players to act collectively by mimicking their opponents' behavior and only defecting in response to defection. This fosters a collective mindset by promoting trust and mutual understanding among players.

Pseudocode for the Tit-for-Tat with a twist (TFTw) strategy:

```
function TFTw(n, k, r, P, t, i, previous_actions):
  if t == 1:
    return C
  if t <= P and previous_actions[i] == D:
    return D
  if t > P and previous_actions[i] == D:
    return C
  else:
    return previous_actions[i]
```

The TFTw strategy should prove to be adaptive, robust, and effective in promoting cooperation while also being able to respond to various opponent behaviors.
'''

description_COLLECTIVE_278 = '''
 Strategy Name: Tit-for-Tat with Variable Cooperation (TfTVC)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), setting a cooperative first impression and starting a potential cooperation chain.
   - Subsequent Rounds (t>1):
     - If the opponent cooperated in the previous round, then cooperate back (C). This reciprocates good behaviour while maintaining a stable cooperation.
     - If the opponent defected in the previous round, then defect in the current round (D). This punishes defection and encourages the opponent to reconsider their strategy.
     - To promote collective mindset, maintain a variable cooperation probability (p) when defecting an opponent. p can be dynamically adjusted based on the history of interactions with that opponent. A higher p value will lead to cooperating more often even in response to defection.

2. Handle edge cases:
   - Last Round (t=r): If the current round is the last one, cooperate regardless of the previous action taken by the opponent (C). This allows for a final opportunity to build goodwill or repair any damage caused by earlier defections.
   - New Opponent (i): For new opponents, start with an initial cooperation period of m rounds before adapting the TfTVC strategy. The value of m can be determined experimentally or set as a constant.

3. Be collective:
   - The core design philosophy of TfTVC is based on promoting cooperation and maintaining a collective mindset while being adaptive to various opponent behaviours. By reciprocating cooperation and punishing defection, the strategy encourages stability in cooperation and can potentially lead to longer periods of collective success.
'''

description_COLLECTIVE_279 = '''
 For this N-Player Public Goods Game, let's develop a strategy called "Adaptive Tit-for-Tat" (ATFT). The ATFT strategy is designed to encourage cooperation while also being robust against varying opponent behaviors.

1. Specify decision rules:
   - Start cooperating in the first round (c_i = C)
   - In subsequent rounds, mimic other players' actions from the previous round (c_i = c_j if i is similar to j in terms of past cooperation history).
   - If a player switches from cooperation to defection (defection after cooperation), forgive them and return to cooperating in the next round.
   - If a player continues to defect after initially cooperating, retaliate by also defecting until they show signs of cooperating again.

Pseudocode:
```
function ATFT(history):
  if history is empty:
    return cooperate (c_i = C)
  else:
    previousRound = history[-1]
    if player switched from cooperation to defection in the previous round:
      return forgive_and_cooperate
    elif player has been consistently defecting:
      return retaliate_by_defecting
    else:
      return mimic_opponent(previousRound)

function forgive_and_cooperate():
  return cooperate (c_i = C)

function retaliate_by_defecting():
  return defect (c_i = D)

function mimic_opponent(previousRound):
  if all players in the previous round cooperated:
    return forgive_and_cooperate
  elif all players in the previous round defected:
    return retaliate_by_defecting
  else:
    return player's previous action (c_i = c_i[-1])
```

2. Handle edge cases:
   - First round: cooperate unconditionally
   - Last round: consider the current round history to decide whether to cooperate or defect, following the decision rules specified above

3. Be collective:
   - The ATFT strategy aligns with a collective mindset by promoting cooperation as long as other players also choose to cooperate
   - If others reciprocate cooperation, the strategy will continue cooperating; if not, it will retaliate but forgive and return to cooperation once the opponent shows signs of changing behavior.
'''

description_COLLECTIVE_280 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate a positive interaction. This encourages others to reciprocate cooperation. [C]
   - From the second round onwards, analyze the opponent's previous actions to decide whether to cooperate or defect. If the opponent cooperated in the previous round, cooperate; otherwise, defect. This creates an opportunity for opponents to rebuild trust after a defect and punishes continued selfish behavior. [If last_round_opponent_cooperated then C else D]

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier. There are no special rules for subsequent rounds due to the adaptive nature of the strategy.
   - In the last round, since the game is repeated, the strategy still follows its decision rule based on the previous opponent's action in the penultimate round.

3. Be collective - Clearly align with the collective mindset
   - By cooperating initially and responding to cooperation from opponents, ATFT encourages a collective mindset where players contribute to the public good and benefit from each other's contributions.

Pseudocode:
```
function AdaptiveTitForTat(round, opponent_action_history) {
  if (round === 1) {
    return 'C'; // Cooperate in the first round
  } else {
    last_round_opponent_action = opponent_action_history[round - 1];
    if (last_round_opponent_action === 'C') {
      return 'C'; // Cooperate if opponent cooperated in the previous round
    } else {
      return 'D'; // Defect if opponent defected in the previous round
    }
  }
}
```
'''

description_COLLECTIVE_281 = '''
 Strategy Name: Tit-for-Tat (with modification for public goods game)

1. Decision Rules:
   - In the first round, cooperate (C) to signal good faith and encourage cooperation.
   - For subsequent rounds, follow the actions of the majority of players from the previous round. If the majority cooperated, cooperate; if not, defect. This mimics a willingness to cooperate while also punishing defection.

Pseudocode:
```python
def tft_strategy(player_index, player_actions_history, n, k):
    if round == 1:
        return 'C'
    majority = int(len(player_actions_history) / 2) + 1
    if sum(player_actions_history[-majority:]) >= majority:
        return 'C'
    else:
        return 'D'
```

2. Handle edge cases:
   - Last round, cooperate regardless of history to maximize payoff in the last opportunity.
   - In case of a tie for the majority, side with cooperation as it may encourage future cooperation.

3. Be collective:
   - By following the actions of the majority, the strategy aims to promote cooperation and foster a collective mindset by rewarding cooperation and punishing defection. This encourages players to work together towards mutual benefit.

This Tit-for-Tat strategy is adaptive and robust, as it responds to different opponent behaviors while maintaining a collective focus on cooperation. It is also simple enough to be easily implemented in an algorithm.
'''

description_COLLECTIVE_282 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules:
   - In the first round, cooperate (C) to foster a cooperative environment and set a positive precedent.
   - For subsequent rounds, copy the action of the opponent from the previous round (unless it's the first interaction). This rule is inspired by the classic Tit-for-Tat strategy but includes an additional element.
   - If an opponent has been cooperative for x consecutive rounds and then defects, wait for y subsequent rounds of cooperation before returning to cooperation. The values for x and y are adaptive parameters that encourage forgiveness and foster long-term relationships.
     Pseudocode:
     ```
     function TFTPlus(opponent_history):
         if round == 1:
             return Cooperate
         else:
             opponent_action = opponent_history[round - 1]
             if opponent_action == Cooperate:
                 if self.cooperation_streak >= x and self.opponent_defection_counter > y:
                     self.cooperation_streak = 0
                     return Cooperate
                 else:
                     self.opponent_defection_counter = 0
                     return opponent_action
             else:
                 self.opponent_defection_counter += 1
                 if self.opponent_defection_counter > y:
                     return Defect
                 else:
                     return opponent_action
         update_opponent_history(opponent_action)
     ```

2. Handle edge cases:
   - Last round: Adopt the strategy of the penultimate round to maintain adaptability and ensure a fair payoff in the final round.
   - In case of a tie (multiple opponents defecting or cooperating simultaneously), apply the same rule as in the first round, i.e., cooperate to foster a cooperative environment.

3. Be collective:
   - The TFT+ strategy emphasizes cooperation and forgiveness, promoting a collective mindset by rewarding consistent cooperation and demonstrating willingness to mend relationships after conflict. By adapting the parameters x and y, the strategy aligns with the long-term interests of other players while maintaining adaptability in the face of various opponent behaviors.
'''

description_COLLECTIVE_283 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C). This is a friendly gesture to encourage others to cooperate, given the potential benefits of cooperation in future rounds.
   - Subsequent Rounds (2 ≤ t ≤ r):
     - If opponent cooperated in previous round: Cooperate (C)
     - If opponent defected in previous round: Defect (D). This is a punishment for defection and an expression of disapproval, while still maintaining the option to cooperate in the future if the opponent changes behavior.

2. Edge Cases:
   - Last Round (t=r): Cooperate (C), regardless of previous round's action. The strategy aims to maximize its total payoff over all rounds, even in the last round when there is no more opportunity for reciprocation.
   - First Round (t=1) was already addressed under Decision Rules.

3. Collective Mindset:
   - The ATFT strategy values long-term cooperation and reciprocity, promoting a collective mindset by rewarding cooperative behavior and punishing defection in an attempt to foster mutual cooperation.

Pseudocode for the Adaptive Tit-for-Tat Strategy:

```
function Adaptive_Tit_for_Tat(t: int, previousAction: char, history: list<char>, n: int, k: float) -> char:
    if t == 1:
        return 'C' # Cooperate in the initial round

    if previousAction == 'C':
        return 'C' # Cooperate when opponent cooperated in previous round
    else:
        return 'D' # Defect when opponent defected in previous round

    # If we reach here, it means t > r (the last round)
    return 'C' # Cooperate even in the last round to maximize total payoff
```
'''

description_COLLECTIVE_284 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - Initialize: Start by cooperating in the first round to establish trust and foster cooperation among players. This is denoted as `C_init = True`.
   - Follow: In subsequent rounds, repeat the previous action of the player against whom you played last round (i.e., if opponent cooperated last time, cooperate; if opponent defected, defect). This is denoted as `C_t = C_{t-1}^opponent`.
   - Adapt: If an opponent has consistently cooperated for a certain number of rounds (denoted as 'streak'), gradually increase the contribution level over time. The streak length can be set based on the game parameters, e.g., `streak_len = floor(n/2)`. When the streak reaches the defined length, start increasing contributions from a base level `b_contribution` to a maximum level `m_contribution` over the next few rounds. After reaching the maximum contribution, maintain it for the remaining part of the streak before reverting back to the base contribution level. The rate of increase can be set by determining the number of rounds required to reach the maximum contribution level.

2. Handle Edge Cases:
   - First Round: As mentioned above, cooperate (`C_init = True`)
   - Last Round: In the final round, revert back to the base contribution level (i.e., `C_r = b_contribution`)
   - Mid-Game: During the rest of the rounds, follow the TFTAC strategy described earlier

3. Be Collective:
   - The TFTAC strategy fosters a collective mindset by initially cooperating and building trust with others, while also being responsive to opponents' actions over time. It promotes a balance between self-interest (by adapting contributions based on opponents' behavior) and cooperation for mutual benefit.

Pseudocode:

```python
def TFTAC(n, r, k, b_contribution, m_contribution):
    C = [b_contribution for _ in range(r+1)]  # Initialize contribution vector with base level
    streak = 0

    def get_opponent_action(previous_round):
        if previous_round == 'C':
            return 'D'
        else:
            return 'C'

    for t in range(1, r+1):
        opponent_action_last = get_opponent_action(t - 1)
        if opponent_action_last == C[t-1]:
            streak += 1
            if streak > streak_len:
                # Gradually increase contribution level over the next few rounds
                for _ in range(streak_len, streak_len+rounds_to_reach_max):
                    C[t] = min(C[t-1]*1.05, m_contribution)  # Increase contribution by 5% per round
        else:
            streak = 0
            # If opponent defected, revert back to the base level contribution if it was previously increased
            if C[t-1] > b_contribution:
                C[t] = C[t-1]*0.95  # Decrease contribution by 5% per round
        C[t] = (C[t] if opponent_action_last == get_opponent_action(t) else 1)

    return C  # Return the contribution vector for each round
```
'''

description_COLLECTIVE_285 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C). This sets a cooperative tone and allows the strategy to build trust with other players.
   - Subsequent Rounds (t>1): If the player i cooperator count in the previous round (c_i, t-1) is equal to or greater than a predefined threshold (T), then cooperate. Otherwise, defect. The threshold T can be determined based on the number of players (n) and multiplication factor (k). For instance, T = ⌊(k/2) * n⌋. This rule encourages cooperation when a majority of players have previously cooperated but punishes defection when it occurs more frequently.
   - Final Round (t=r): Cooperate as in the initial round, even if the condition is not met, since there are no future rounds to retaliate.

2. Handle edge cases:
   - If T is not an integer, round down to the nearest whole number using ⌊T⌋ or ⌈T⌉, depending on whether a higher threshold encourages more cooperation or less defection.
   - In case of a tie (exactly T cooperators in the previous round), cooperate if the strategy was previously cooperative; otherwise defect. This adds a slight randomness to promote diversity and resilience against other adaptive strategies.

3. Be collective:
   - The strategy aims to maximize total payoffs for the group, balancing cooperation and defection based on the observed behavior of other players. By cooperating when others do so as well, the strategy fosters a collective mindset that encourages long-term cooperation and collaboration.
'''

description_COLLECTIVE_286 = '''
 Title: Tit-for-Tat-Adaptive Strategy (TFTA) for N-Player Public Goods Game

1. Specify decision rules:
   - Start with cooperation in the first round (c_i = C). This encourages a cooperative environment and avoids immediate punishment.
   - In subsequent rounds, players imitate their previous opponent's action from the previous round (c_i = c_{opponent, t-1}). This rule promotes stability and reciprocity among players while being robust to various opponent behaviors.
     If a player defected in the previous round (c_{opponent, t-1} = D), they will cooperate in the current round (c_i = C). Conversely, if a player cooperated in the previous round (c_{opponent, t-1} = C), they will also cooperate in the current round (c_i = C).

2. Handle edge cases:
   - Last round: Players should continue using their TFTA decision rule as no future interactions are expected with opponents who defected in the last round.
   - First round: As mentioned above, players will start by cooperating (c_i = C).

3. Be collective:
   - While not relying on others sharing norms or coordination mechanisms, this strategy encourages cooperation and reciprocity as a way of fostering a stable and more prosperous environment among players.
   - Players do not need to pre-arrange schedules or patterns; instead, they simply react to their opponents' previous actions based on the TFTA decision rule. This collective mindset allows for adaptability in various opponent behavior scenarios.
'''

description_COLLECTIVE_287 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C) to signal trust and cooperation, following the principle of being friendly at first encounters.
   - Subsequent Rounds: In round t, if the player cooperated in the previous round (t-1), then also cooperate. If the player defected, respond with defection in round t. This tit-for-tat approach encourages reciprocity and punishes non-cooperative behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round (t=1): Cooperate as explained earlier.
   - Last Round (r=n): Evaluate the opponent's history of cooperation and adjust the final action based on whether it benefits overall performance in repeated interactions. If the opponent has shown a high level of cooperation, cooperate in the last round to reinforce positive relations. Otherwise, defect to teach them a lesson or punish their non-cooperative behavior.
   - Other Edge Cases (e.g., intermediate rounds): The strategy is already designed to handle these cases as it takes into account both the opponent's past actions and the desire for reciprocity.

3. Be collective - Clearly align with the collective mindset:
   - Collaboration: By cooperating in the initial round, TFT-A promotes a collaborative environment and encourages other players to do the same.
   - Fairness: Tit-for-tat reciprocity ensures that benefits from cooperation are distributed fairly among all players, promoting collective interests over individual gain.
   - Adaptability: The strategy adjusts its actions based on the opponent's behavior, demonstrating flexibility and openness to collaboration when faced with cooperative opponents while being tough on non-cooperators.

Pseudocode for TFT-A Strategy:

```
function TFT_A(round, opponentHistory) {
  if (round == 1) {
    return "Cooperate"
  }

  lastRound = opponentHistory[round - 1]

  if (lastRound == "Cooperate") {
    return "Cooperate"
  } else {
    return "Defect"
  }
}

function lastRound(opponentHistory) {
  return opponentHistory[opponentHistory.length - 1]
}
```
'''

description_COLLECTIVE_288 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment. (C)
   - For subsequent rounds, mimic the behavior of the previous round by the opponent:
     - If the opponent cooperated in the last round, cooperate back (C).
     - If the opponent defected in the last round, also defect in this round (D). This is known as "Tit-for-Tat" behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the final round, since future rewards are not available, cooperate if the opponent cooperated in the previous round (as per ATFT), and defect otherwise. This encourages cooperation even at the end of the game.

3. Be collective - Clearly align with the collective mindset
   - The strategy aims to maximize group benefits while also fostering trust and reciprocity among players. It achieves this by starting cooperatively, responding cooperatively when met with cooperation, and retaliating only if necessary.

Pseudocode:

```python
def AdaptiveTitForTat(n, k, r, history):
  if round == 1:
    action = 'C'  # Cooperate in the first round
  else:
    last_action = history[-1]  # Last action of opponent
    action = last_action['i']   # Take same action as last round (C or D)

  if round == r:  # Final round, behave based on last action
    if last_action == 'C':
      action = 'C'  # Cooperate in final round if opponent cooperated
    else:
      action = 'D'  # Defect in final round if opponent defected

  payoff = (1 - action) + (k/n) * sum(history['contributions'])
  return action, payoff
```
'''

description_COLLECTIVE_289 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT-A starts by cooperating in the first round to signal good intentions and demonstrate willingness to cooperate. From the second round onwards, it adapts its actions based on the opponents' previous moves:

   - If the opponent cooperated in the previous round, TfT-A cooperates in return.
   - If the opponent defected in the previous round, TfT-A defects in response to punish the defection.
   - If a player has not played before (e.g., first encounter), TfT-A follows the initial cooperation rule.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TfT-A cooperates in the first round to initiate the game positively. There are no specific considerations for the last round as the adaptive nature of the strategy focuses on reacting to the opponent's actions in each round.

3. Be collective - Clearly align with the collective mindset
   TfT-A aims to promote cooperation by reciprocating cooperative moves from opponents while punishing defections. By doing so, it encourages a group mentality where players can benefit from mutual contributions to the public good. However, since the strategy does not rely on others sharing norms or coordination mechanisms, TfT-A remains flexible and robust to various opponent behaviors.

Pseudocode:
```
def TitForTatAdaptive(opponent_history):
  if round == 1:
    return Cooperate()
  else:
    if opponent_history[-1] == Cooperate():
      return Cooperate()
    elif opponent_history[-1] == Defect():
      return Defect()
    else:
      # If the opponent has not played before, assume initial cooperation
      return Cooperate()
```
'''

description_COLLECTIVE_290 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C). This is to foster a cooperative environment and encourage others to follow suit. Pseudocode: if t = 1 then play C else...
   - Subsequent Rounds (2 ≤ t ≤ r): Observe the actions of all players in the previous round, and respond with the same action taken in the last round. If everyone cooperated (total_contributions == n), continue to cooperate. If anyone defected (total_contributions < n), defect (play D). Pseudocode: if total_contributions == n then play C else play D

2. Handle Edge Cases:
   - Last Round (t=r): Mimic the previous round's behavior to ensure fairness and promote cooperative tendencies in future games with the same opponents. Pseudocode: if t = r then continue with strategy based on total_contributions from t-1
   - First Few Rounds (t<5): Cooperate for the first few rounds to give other strategies a chance to emerge and establish a cooperative environment. After that, switch to ATFT strategy as described above. Pseudocode: if t < 5 then play C else...

3. Be Collective:
   - Encourage cooperation by starting cooperatively and reciprocating cooperation from others. Defecting is only a response to defection by others, not an initial action or strategy.
   - The ATFT strategy seeks balance between individual success (maximizing personal payoff) and collective success (maximizing the total contributions). By punishing defection and rewarding cooperation, it aims to create a cooperative equilibrium where all players benefit from collaborating over time.
  
In summary, the Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game starts by cooperating in the first few rounds and then adapts to the opponents' behavior based on the previous round's contributions. This strategy strikes a balance between individual success and collective benefit while being robust to various opponent behaviors.
'''

description_COLLECTIVE_291 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initiate cooperation in the first round (round 1), as a gesture of goodwill and trust.
   - In subsequent rounds, cooperate if all players cooperated in the previous round. Otherwise, defect to punish non-cooperators while maintaining the option for future cooperation. This rule fosters reciprocity and stability in interactions.
   - If no previous interaction with a player exists (e.g., new opponent in later rounds), initiate cooperation as in the first round.

Pseudocode:
```
function TFT_AC(round, history):
    if round == 1:
        action = 'C'  # Cooperate in the first round
    elif all(history[round-1] == 'C'):
        action = 'C'  # Cooperate if all players cooperated last round
    else:
        action = 'D'  # Defect to punish non-cooperators
    return action
```

2. Handle Edge Cases:
   - In the last round (round r), as there will be no further interactions, defect regardless of previous actions to maximize individual payoff.
   - If the history does not contain enough information about the other player's past actions (e.g., due to incomplete or missing data), initiate cooperation as in the first round.

3. Be Collective:
   - By being cooperative when others are, TFT-AC promotes a collective mindset by fostering reciprocity and long-term collaboration among players.
   - The strategy aims to build trust and promote stable relationships with other players, benefiting the collective outcomes in the long run while still considering individual interests.
'''

description_COLLECTIVE_292 = '''
 Strategy Name: Adaptive Tit-for-Tat with Probabilistic Cooperative Threshold (ATFT-PCT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to signal trustworthiness and encourage cooperation from others (C).
   - In subsequent rounds, adapt behavior based on previous round's total contributions (total_contributions_t) using a probabilistic cooperative threshold (pct):
       - If total_contributions_t >= pct * n, cooperate (C).
       - If total_contributions_t < pct * n, defect (D).
     The probabilistic cooperative threshold is determined by the historical average of contributions:
        pct = moving_average(total_contributions) / n

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier.
   - In the last round, adopt the current pct as a reference and apply the same decision rule.

3. Be collective - Clearly align with the collective mindset:
   The strategy aims to encourage cooperation by mirroring others' behavior, but also responds to repeated defection by punishing (retaliation) or forgiving (trust restoration). The adaptive nature of ATFT-PCT allows it to adjust its cooperative threshold based on the group's collective behavior, fostering a more harmonious and cooperative environment over time.

Pseudocode:

```python
def strategy(n, k, r):
    total_contributions = [0] * r  # initialize total contributions for each round
    pct = 0.5  # initial cooperative threshold (halfway between all defecting and all cooperating)

    def moving_average(values, window=10):  # move average with a sliding window
        return sum(values[-window:]) / window if len(values) > window else values[0]

    def decide_action(total_contributions_t):
        return "C" if total_contributions_t >= pct * n else "D"

    for t in range(1, r+1):  # iterate over each round
        action = decide_action(total_contributions[t-1])  # decide action based on previous round's total contributions
        total_contributions[t] = sum(total_contributions[:t]) if action == "C" else total_contributions[t-1]  # update total contributions for this round
        pct = moving_average(total_contributions) / n  # recalculate cooperative threshold based on historical average of contributions

    return decide_action(total_contributions[-1])  # take action in the last round
```
'''

description_COLLECTIVE_293 = '''
 Title: Tit-for-Tat-Evolution (T4E) Strategy

1. Decision Rules:
   - Initialize: Start by cooperating (C) in the first round to build trust and encourage cooperation from others.
   - Respond: In subsequent rounds, mirror the action of the most frequent cooperators from the previous round (i.e., if the most common action was C, play C; otherwise, defect D). This encourages cooperation and punishes defection while maintaining adaptability to opponent behaviors.
   - Forgive: If a player deviates from cooperation during a round, they are automatically forgiven and revert back to being considered as a "most frequent cooperator" candidate in the next round.

2. Handle Edge Cases:
   - First Round: Cooperate (C) to initiate positive interactions with other players.
   - Last Round: Play the same action as the most frequent cooperator from the second last round, as this strategy is designed for repeated interactions over multiple rounds.

3. Be Collective:
   - Align with the collective mindset by promoting cooperation and forgiveness when players deviate from it. This fosters an environment where players work together towards a common good while also being adaptable to diverse opponent behaviors.

Pseudocode for Tit-for-Tat-Evolution Strategy:
```
function T4E(n, r, k):
  history = [] # initialize history as empty list
  current_round = 1

  function most_common_cooperators(history):
    cooperators_count = {} # create a dictionary to count cooperators
    for action in history:
      if action == 'C':
        if cooperators_count.get(action, 0) == 0:
          cooperators_count[action] = 1
        else:
          cooperators_count[action] += 1

    max_cooperators = max(cooperators_count.values()) # find the most frequent cooperators
    max_cooperators_actions = [action for action, count in cooperators_count.items() if count == max_cooperators]
    return max_cooperators_actions

  while current_round <= r:
    action = 'C' # default to cooperate in the first round

    if current_round > 1:
      most_recent_cooperators = most_common_cooperators(history[-r+current_round-1:])

      if len(most_recent_cooperators) == 1:
        action = most_recent_cooperators[0]

    history.append(action) # record the current round's action in the history
    current_round += 1

  return history
```
This strategy aims to balance cooperation and adaptability, making it well-suited for a wide range of opponent behaviors in the N-Player Public Goods Game. By promoting collective mindset, encouraging forgiveness, and mirroring the actions of frequent cooperators, T4E strategy should perform competitively against other AI strategies in a tournament setting.
'''

description_COLLECTIVE_294 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate (C) to establish a positive relationship and set a default cooperation norm.
     Pseudocode: if round = 1 then action = C

   - For subsequent rounds, evaluate the opponent's behavior in the previous round and adapt accordingly.
     If the opponent cooperated in the last round, return the favor by also cooperating (C). If not, defect (D) to punish them for their lack of cooperation.
     Pseudocode: if last_round_opponent_action == C then action = C else action = D

2. Handle edge cases:
   - In the last round, cooperate (C) as a final attempt to create a positive impression and potentially encourage reciprocity in future interactions with the opponent.
     Pseudocode: if round = r then action = C

3. Be collective:
   - The TFT-AC strategy follows a collective mindset by prioritizing cooperation whenever possible while also taking into account the need to punish defection for the benefit of all players in the long run.

By combining tit-for-tat with an adaptive approach that evaluates opponent behavior, this strategy aims to foster cooperation when others are willing to reciprocate while still ensuring personal gains through punishment mechanisms when necessary. This should make it a robust and versatile choice for various player behaviors and game parameters.
'''

description_COLLECTIVE_295 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In the first round, cooperate (C). This sets a cooperative tone and allows for potential trust-building among players.
   - For subsequent rounds, observe the total number of cooperators (total_contributions) in the previous round. If total_contributions is less than or equal to (n/2), defect (D) in the current round. This decision is based on the assumption that a majority of players are not contributing and it might be more profitable to defect temporarily until a majority switches to cooperation.
   - If total_contributions exceeds (n/2), cooperate (C). This decision follows the principle of reciprocity, as the majority seems to be cooperating, so it is beneficial to do so as well.
   - In the last round, always cooperate (C) since there are no further rounds for retaliation or reward.

2. Handling Edge Cases:
   - In case of a tie in total_contributions (equal to n/2), defect (D). This is to avoid ambiguity and maintain the strategic robustness against different opponent behaviors.
   - If there are fewer than 2 players, adjust decision rules accordingly as the game may not be fully representative of the N-Player Public Goods Game.

3. Collective Mindset:
   - The ATFT strategy aims to establish a cooperative environment when others are also contributing and punish free-riders by defecting when they fail to do so. This collective mindset is based on reciprocity and can lead to sustained cooperation over time if the majority of players adopt similar strategies.

Pseudocode:

```python
def ATFT(total_contributions, n, k, r, round):
    if round == 1:
        action = 'C'
    elif round == r:
        action = 'C'
    else:
        if total_contributions <= n//2:
            action = 'D'
        elif total_contributions > n//2:
            action = 'C'
        else: # in case of a tie, defect to maintain strategy robustness
            action = 'D'
    return action
```
'''

description_COLLECTIVE_296 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - In the first round (t=1), cooperate (C). This initiates cooperation and provides a chance for others to reciprocate.
   - For subsequent rounds (t>1):
       a) If opponent cooperated in the previous round (t-1): cooperate (C) as a reward for cooperation.
       b) If opponent defected in the previous round (t-1): also defect (D) to punish non-cooperation, but with an adaptive twist:
           i) If there is a significant drop in the total contributions from the previous round (more than 50%), consider increasing cooperation as a signal of goodwill and chance for reconciliation (C). However, if this results in continued defection from opponent, revert to defecting in the next round.
           ii) If there is no significant drop in the total contributions, maintain defection (D) to continue the punishment.

2. Handle edge cases:
   - Last round (t=r): cooperate (C) regardless of opponent's previous action as a gesture of goodwill and encouragement for future interactions.

3. Be collective:
   - The strategy aims to create a positive cycle of cooperation by reciprocating cooperation and rewarding it, while punishing defection with adaptive measures that consider the collective well-being and encourage reconciliation when appropriate.
   - The TFTA strategy promotes the collective mindset by fostering mutual trust, cooperation, and encouraging others to follow similar adaptive strategies.
'''

description_COLLECTIVE_297 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Decision Rules:
   - In the first round (t=1), cooperate (C) to foster a collaborative environment and set a positive tone for subsequent rounds.
   - For t > 1, analyze opponent's actions from the previous round (t-1). If most players (rounded down) cooperated, then cooperate; otherwise defect. This rule ensures adaptability to a wide range of opponent behaviors while maintaining a prosocial approach.

```python
def tit_for_tat(previous_round_contributions, n):
    if t == 1:
        return 'C'  # Cooperate in the first round

    collaborators = int(sum(previous_round_contributions) / n)
    if collaborators >= len(previous_round_contributions) - 1:
        return 'C'  # Cooperate if most players contributed last round
    else:
        return 'D'  # Defect if most players did not contribute last round
```

2. Handle edge cases:
   - In the last round (r), defect to maximize personal payoff, as there will be no further interactions with opponents.
   - In case of a tie in the number of collaborators in the previous round, cooperate. This rule ensures an overall prosocial approach and prevents stalemates.

```python
def last_round(t, r):
    return t == r

def handle_ties(previous_round_contributions):
    ties = sum([1 for contribution in previous_round_contributions if contribution == len(previous_round_contributions) - 1])
    if ties > 0:
        return [1] * ties + [0] *(len(previous_round_contributions) - ties)  # Cooperate in case of a tie
```

3. Be collective:
   - The Tit-for-Tat strategy aims to balance individual and collective interests by encouraging cooperation when it appears beneficial for the group while also punishing defection. This collective mindset is built into the decision rules, which prioritize the group's cooperation over individual gains in most cases.
'''

description_COLLECTIVE_298 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C) to foster a cooperative environment and demonstrate goodwill.
   - Subsequent Rounds (t>1): If the opponent cooperated in the previous round, cooperate (C); otherwise, defect (D). This rule encourages cooperation when it's reciprocated while also punishing defection.

2. Handle edge cases:
   - Last Round (t=r): Cooperate (C) to provide a final opportunity for mutual benefit and avoid retaliation in future games with the same opponent.
   - First Few Rounds (t<3): Initially cooperate, but gradually shift towards more defection if opponents are consistently defecting. This encourages opponents to reconsider their strategies and allows for adaptation over time.

3. Be collective - Clearly align with the collective mindset:
   - In every round, prioritize collective good by contributing to the community project when it benefits the group or when there's a history of reciprocation. This supports a collective approach while also fostering cooperation and promoting fairness among all players.

Pseudocode:

```python
def tit_for_tat(round, opponent_history):
  if round == 1:
    return "C" # Cooperate in the first round to foster a cooperative environment

  elif len(opponent_history) < 3:
    if opponent_history[-1] == "C":
      return "C" # Continue cooperation when opponent is cooperating
    else:
      return "D" # Defect when opponent is not cooperating

  elif round == r: # Last round
    return "C" # Cooperate to provide a final opportunity for mutual benefit

  else: # Subsequent rounds
    if opponent_history[-1] == "C":
      return "C" # Continue cooperation when opponent is cooperating
    else:
      return "D" # Defect when opponent is not cooperating
```

This Tit-for-Tat strategy leverages a simple, adaptive approach that encourages cooperation while also punishing defection. By aligning with the collective mindset and taking into account the history of interactions, this strategy should prove effective in a variety of situations against different AI opponents.
'''

description_COLLECTIVE_299 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Gradual Cooperation (GC) and Flexible Endowment Allocation (FEA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This initiates a cooperative relationship.
   - For subsequent rounds:
     - If an opponent cooperated in the previous round, reciprocate with cooperation (ATFT).
     - If an opponent defected in the previous round, respond with defection in the current round (ATFT).
       However, to encourage initial cooperation and avoid getting stuck in a cycle of retaliation, implement Gradual Cooperation:
       - If the opponent has not cooperated for consecutive M rounds, begin to gradually shift towards cooperation:
         if (current_round - last_cooperation_opponent > M) and (contribution_percentage < max_contribution_percentage) then
           contribution_percentage += increment
       - Set initial contribution_percentage = 0, M = floor(r/2), max_contribution_percentage = 1, and increment = min(0.1, (1-current_contribution_percentage)/M).
     - If an opponent cooperated after a history of defection, start fresh with the ATFT rule.
   - To account for opponents who may not reciprocate cooperation, implement Flexible Endowment Allocation:
     - Maintain a score to track each opponent's cooperation history:
       if (opponent_cooperation[i] == 1) then
         increase opponent_cooperation[i] by 1
       else
         decrease opponent_cooperation[i] by 1
     - Periodically review the scores of all opponents. If an opponent has a higher score than the average score, allocate more endowment for cooperation:
       if (opponent_score[i] > average_score + deviation_threshold) then
         increase endowment_allocation[i] by 1
     - Set initial opponent_cooperation[i] = 0 for all opponents and average_score to the average of previous rounds' contributions. Set deviation_threshold = 0.2.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of the situation (as described above).
   - In the last round, cooperate if an opponent has cooperated in the previous round to maximize total payoff for both parties.

3. Be collective - Clearly align with the collective mindset:
   - Prioritize cooperation with opponents who have previously contributed to the community project more often than others.
   - Avoid getting stuck in cycles of defection or retaliation by implementing Gradual Cooperation and Flexible Endowment Allocation.
'''

description_COLLECTIVE_300 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Decision Rules - TFT-A will cooperate initially and subsequently mimic the actions of the opponent in the previous round. This creates a simple, predictable, and robust strategy that encourages cooperation while also retaliating against defection. If no prior interaction exists (first round), TFT-A cooperates.
   Pseudocode:
   - if round = 1 then cooperate
   - else cooperate if opponent cooperated in the previous round, defect otherwise

2. Handle Edge Cases - For the last round, TFT-A will cooperate regardless of the opponent's action in the penultimate round to maximize potential payoff.
   Pseudocode:
   - if round = r then cooperate

3. Be Collective - The strategy emphasizes cooperation as a first move and follows an "eye-for-an-eye" approach, aiming to encourage other players to reciprocate and develop long-term collective success. However, since there is no reliance on others sharing norms or coordination mechanisms, TFT-A remains flexible and adaptive to various opponent behaviors.

The strategy's simplicity allows it to be easily understood by opponents while also fostering cooperation when encountered by similar strategies. It has proven effective in a variety of contexts due to its balance between cooperative and retaliatory tendencies.
'''

description_COLLECTIVE_301 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TFT-AC strategy starts by cooperating (C). After that, it responds to the opponents' actions from the previous round. If an opponent cooperated in the previous round, the TFT-AC strategy also cooperates in the current round. If an opponent defected, the TFT-AC strategy defects in the current round. This tit-for-tat behavior encourages cooperation when it is reciprocated and punishes defection with defection.

   To make the strategy more robust to various opponent behaviors, TFT-AC introduces a tolerance threshold (TT). If all opponents cooperate for TT consecutive rounds, TFT-AC increases its tolerance level by one. If an opponent defects at any point during the increased tolerance period, TFT-AC reduces its tolerance level by one. Tolerance levels range from 1 (minimum) to maxTT (maximum). The higher the tolerance level, the more forgiving TFT-AC is towards defection and the longer it will continue cooperating despite past defections.

   In pseudo-code:

```
tolerance_level = 1

def action(current_round, opponent_actions):
    if current_round == 1:
        return 'C'  # Cooperate in the first round

    if all(opponent_action == 'C' for opponent_action in opponent_actions[-tolerance_level:]):
        return 'C'  # Cooperate if opponents have been cooperating for at least tolerance_level rounds
    else:
        return 'D'  # Defect otherwise
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-AC starts by cooperating in the first round (as mentioned above). In the last round, it cooperates if any opponent has cooperated during the game (to maximize potential payoff). Otherwise, it defects to punish opponents for not cooperating enough throughout the game.

3. Be collective - Clearly align with the collective mindset
   TFT-AC aims to encourage cooperation by reciprocating cooperative actions and punishing defection. However, its primary goal is to maximize individual payoff, which can lead to cooperation when beneficial but also defection when necessary to gain higher payoffs against non-cooperative opponents.
'''

description_COLLECTIVE_302 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the ATFT strategy starts by cooperating (C). If a player encounters another player who also cooperated in the previous round, it continues to cooperate. However, if a player encounters a defector (D) from the previous round, it will defect in response. This tit-for-tat approach allows for cooperation when others are cooperative but punishes defection with defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, every player cooperates since there is no previous history to reference. In the last round, players revert back to cooperating after a single act of punishment if they hope for better outcomes in future games with the same opponent.

3. Be collective - Clearly align with the collective mindset
   ATFT strategy aims at maximizing collective benefits by promoting cooperation while not being too forgiving to repeated defection. The strategy encourages other players to cooperate and punishes those who do not, which ultimately leads to more payoffs for all participants in the long run as long as the majority of players adopt a similar cooperative approach.

Pseudocode:
```
def ATFT(round, history, opponent_history):
  if round == 1 or len(history) < 2:
    return Cooperate()

  if last_action_opponent == Cooperate():
    return Cooperate()
  else:
    return Defect()
```
'''

description_COLLECTIVE_303 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate to demonstrate goodwill and trustworthiness. This initial cooperation sets a baseline for future interactions.
     If i in round 1: return C

   - For subsequent rounds, observe previous actions of all players (history) and adapt based on the observed average cooperation rate (CR).
     If CR > CR_threshold AND i not first round: return C
     If CR < CR_threshold OR i first round: return D

   CR calculation:
       - Calculate CR for a given round as the ratio of total cooperators in that round to the number of players (n).
       - For the first round, use 0.5 as an initial value for CR_threshold since cooperation is random at this stage.
       - Adapt CR_threshold throughout the game based on the current average CR and previous CR_thresholds. This adaptation helps account for changes in opponent behavior over time.
         CR_threshold = (alpha * CR_prev) + (1 - alpha) * CR_current
         where:
           - alpha is a decay factor that determines how quickly the strategy forgets past information (0 < alpha < 1).
           - CR_prev is the previous average CR.
           - CR_current is the current average CR calculated over a rolling window of past rounds (e.g., last r/2 rounds).

2. Handle edge cases:
   - In the last round, cooperate if the current average cooperation rate exceeds the CR_threshold to maximize potential payoff in the final stage.
     If i in the last round: return C if CR > CR_threshold

3. Be collective:
   - The TFT-AC strategy focuses on maintaining a balance between self-interest and collective interest by mirroring the actions of others while being flexible to adapt to changing circumstances.
   - This approach encourages cooperation when it is likely to be reciprocated, but also defends against exploitation by defecting when opponents are consistently uncooperative.

Pseudocode:

```python
def TFT_AC(n, k, r, alpha):
    players = [0] * n
    history = []
    CR_current = 0.5
    CR_prev = 0.5
    CR_threshold = 0.5

    for round in range(1, r + 1):
        players_actions = [0] * n
        for i in range(n):
            if round == 1:
                players[i] = C
            else:
                CR_current = calculate_CR(history)
                if CR_current > CR_threshold:
                    players[i] = C
                elif round == r:
                    players[i] = C if CR_current > CR_threshold else D
                else:
                    players[i] = D
            history.append(players_actions)

        CR_prev, CR_threshold = CR_current, update_CR_threshold(CR_prev, CR_current, alpha)
        payoffs = calculate_payoffs(n, k, players)
        # Update payoff matrix for analysis and comparison purposes.

def calculate_CR(history):
    total_contributions = sum([sum(actions) for actions in history])
    return total_contributions / len(history)

def update_CR_threshold(CR_prev, CR_current, alpha):
    return (alpha * CR_prev) + (1 - alpha) * CR_current
```
'''

description_COLLECTIVE_304 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initially cooperate (C) in the first round to promote mutual trust and goodwill among players. This action sets a cooperative baseline for future interactions.
   - In subsequent rounds, repeat the last opponent's action from the previous round (i.e., if the opponent cooperated in the last round, do so as well; otherwise defect). This rule fosters cooperation when it is mutual but also punishes those who betray trust by defecting without reason.

2. Handle edge cases:
   - In the first round, start with cooperating (C) to establish a positive initial interaction.
   - In the last round, assess the total number of contributions made by opponents throughout the game and make an informed decision based on whether or not cooperation has been reciprocated. If the majority of players have cooperated in the past rounds, cooperate in the final round; otherwise defect to avoid being taken advantage of.

3. Be collective:
   - The TFT strategy aims to foster a culture of mutual trust and reciprocity among players, promoting collective success by rewarding cooperation and punishing defection without reason.

Pseudocode:

```python
def tft(n, r, k, history, opponent_actions):
    if round == 1:
        action = 'C'  # Cooperate in the first round

    else:
        action = opponent_actions[-1]  # Repeat last opponent's action from previous round

    total_contributions = sum(history[-r:])  # Calculate total contributions in the last r rounds

    if round == r:  # Last round
        if total_contributions >= (n * (r - 1)) / 2:  # If majority cooperated, cooperate in the final round
            action = 'C'
        else:  # Otherwise, defect to avoid being taken advantage of
            action = 'D'

    calculate_payoff(action, total_contributions)  # Calculate payoffs using the game payoff function
```
'''

description_COLLECTIVE_305 = '''
 For this N-Player Public Goods Game, I propose a strategy named "Adaptive Tit-for-Tat" (ATFT). This strategy is designed to balance cooperation and defection while being robust against various opponent behaviors.

1. Specify decision rules:
   - In the first round, ATFT plays C as an act of goodwill and to stimulate cooperation among opponents.
     ```python
     if round == 1:
         action = "C"
     ```
   - For subsequent rounds, evaluate opponent's behavior from the previous round and decide on the current-round action accordingly:
       - If the opponent cooperated in the previous round, ATFT will cooperate as well.
         ```python
         if opponent_action_previous == "C":
             action = "C"
         ```
       - If the opponent defected in the previous round, ATFT will also defect in the current round. However, if no cooperation has been observed yet (i.e., previous total contributions equal 0), ATFT will still cooperate to initiate cooperation.
         ```python
         if opponent_action_previous == "D" and total_contributions_previous > 0:
             action = "D"
         elif round == 1:
             action = "C"
         else:
             action = opponent_action_previous  # mimic opponent's previous behavior
         ```
       - If ATFT is unsure about the opponent's previous action due to lack of information, it will cooperate as a default action. This approach encourages cooperation even in uncertain situations.
         ```python
         if missing_information:
             action = "C"  # default cooperative action
         ```

2. Handle edge cases:
   - Last round (rth round): ATFT will play C to encourage cooperation one last time, regardless of opponent's previous action.
     ```python
     if round == r:
         action = "C"
     ```

3. Be collective:
   - By defaulting to cooperate when unsure about an opponent's previous action, ATFT promotes cooperation and a collaborative mindset.
   - Through mimicking the opponent's previous behavior when the opponent is known to have defected in the past, ATFT encourages reciprocity and collective benefits.
'''

description_COLLECTIVE_306 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C).
   - For subsequent rounds, if the opponent cooperated in the previous round, cooperate in the current round (C). Otherwise, defect (D). This rule promotes reciprocity and trust.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of the opponent's previous actions.
   - For the last round, follow the regular TFT-A strategy based on the opponent's action from the penultimate round.

3. Be collective - Clearly align with the collective mindset:
   - The strategy aims to maximize the overall group payoff while still encouraging cooperation, as it responds favorably to cooperative opponents and punishes defectors only when necessary. This helps foster a more collaborative environment among players.

Pseudocode:
```python
def TFT_A(opponent_action, round, r, n, k):
    if round == 1:
        action = "C"  # Cooperate in the first round
    else:
        action = opponent_action[round-1] if action != "D" else "D"  # Regular TFT-A strategy
    return action
```
Note that this pseudocode is a simplified representation of the actual algorithm, which would be more complex to account for the payoff calculation and round management. However, it provides a clear conceptual idea of the strategy.
'''

description_COLLECTIVE_307 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the ATFT strategy follows these simple rules:
   - In the first round, cooperate (C). This allows the possibility of creating a mutual relationship with other players.
   - For all subsequent rounds, observe and mimic the actions of the opponent from the previous round. If the opponent cooperated in the last round, cooperate; if the opponent defected, also defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperation (C) to foster a positive initial interaction and potential cooperation from opponents.
   - Last round: If the game has an end, it may be beneficial to cooperate as players might want to maximize their payoffs. However, if you suspect that the opponent will not cooperate in the last round, defecting could provide higher overall payoff. The decision should be based on the observed behavior of opponents during the game.
   - Penultimate round: Mimic the opponent's action from the previous round (i.e., if the opponent cooperated in the penultimate round, cooperate; if the opponent defected, also defect).

3. Be collective - Clearly align with the collective mindset
Although individual outcomes are important for ATFT, the strategy encourages cooperation by responding positively to positive interactions and negatively to defections. In this way, the strategy contributes to a more collaborative environment in the game. Additionally, since ATFT mimics opponents' behavior, it follows the collective mindset of adapting to the strategies of others.

Pseudocode:
```python
def ATFT(opponent_action, round, game_rounds):
  if round == 1:
    return "C"  # Cooperate in the first round

  prev_opponent_action = opponent_action[round - 1]

  if prev_opponent_action == "C":
    return "C"  # Cooperate if the opponent cooperated last round
  else:
    return "D"  # Defect if the opponent defected last round

  if round == game_rounds - 1 or round == game_rounds - 2:
    # Consider cooperation in the last two rounds to maximize payoff, but make a decision based on observed behavior of opponents
    return ATFT(opponent_action, round, game_rounds)
```
'''

description_COLLECTIVE_308 = '''
 Title: Adaptive Cooperation Strategy (ACS) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   ACS is designed to balance individual and collective interest by using a Tit-for-Tat approach with a twist of forgiveness and adaptation. The strategy will cooperate (C) when the number of previous cooperators (N_c) exceeds a certain threshold (T), otherwise it will defect (D). This adaptive threshold is determined by the historical average number of cooperators (H_avg) in the previous rounds, ensuring flexibility to changing opponent behavior.

   Pseudocode:
   ```
   function ACS(history, n, k):
       initialize H_avg = average of first 10% of history
       initialize T = (H_avg * 2) / 3
       for each round r in history:
           if N_c(r) > T and last round != r:
               action = C
           else:
               action = D
           update H_avg with current number of cooperators
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, there is no historical data to determine T, so ACS will cooperate to give others a chance to do the same. In the last round, ACS may still cooperate if the number of previous cooperators exceeds the current adaptive threshold. This ensures that ACS remains cooperative even when opponents change their behavior late in the game.

3. Be collective - Clearly align with the collective mindset
   By using a Tit-for-Tat approach, ACS encourages cooperation among players while providing flexibility to changing opponent behavior. The adaptive threshold and historical average number of cooperators help maintain a balance between individual and collective interests, encouraging long-term cooperation and fostering a collaborative environment within the game. This strategy can be considered as an example of rational reciprocity in strategic thinking.
'''

description_COLLECTIVE_309 = '''
 Strategy Name: Tit-for-Tat with Modified Grim Trigger (TFT-MT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate to demonstrate goodwill and willingness to cooperate. This encourages others to reciprocate in subsequent rounds.
     Pseudocode: if round = 1 then cooperate

   - Subsequent Rounds (2 ≤ t ≤ r):
     - If an opponent cooperated in the previous round, reciprocate by cooperating in this round. This reinforces mutual cooperation and rewards cooperative behaviour.
       Pseudocode: if previous_round_opponent_cooperated then cooperate

     - If an opponent defected in the previous round (no cooperation), consider the history of cooperation before deciding whether to cooperate or defect. This strategy adapts to opponents who may not initially cooperate but later change their behaviour.
       - If the number of consecutive defections exceeds a threshold, trigger a "Grim Trigger" response and permanently switch to defecting in all future rounds against that opponent. This punishes opponents who consistently fail to cooperate.
         Pseudocode: if previous_round_opponent_defected and consecutive_defections > threshold then set Grim Trigger for that opponent and defect in this round
       - If the number of consecutive defections is below the threshold, consider recent history of cooperation to decide whether to cooperate or not. This allows some flexibility in the strategy to adapt to changing behaviour from opponents.
         Pseudocode: if previous_round_opponent_defected and consecutive_defections < threshold then evaluate recent_cooperation_history and make decision to cooperate or defect

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round (t=1): Cooperate as specified above.
   - Last Round (t=r): Evaluate recent cooperation history to determine whether it makes sense to cooperate one final time or defect to punish opponents who have not reciprocated. This encourages continued cooperation in future games with the same opponents.

3. Be collective - Clearly align with the collective mindset:
   - Prioritize collective success over individual payoff, as long as it does not conflict with the strategy's overall objectives. Cooperating with others can lead to better outcomes for everyone if a majority of players adopt cooperative strategies.
   - Maintain a balance between cooperation and punishment to maximize long-term benefits for the group while discouraging freeriding and defection.
   - Encourage reciprocity among opponents by demonstrating consistent, yet adaptive behaviour that rewards cooperation and punishes defection. This fosters an environment where cooperation can thrive over time.
'''

description_COLLECTIVE_310 = '''
 Title: Tit-for-Tat Adaptive Cooperation Strategy (TFTAC) for N-Player Public Goods Game

1. Specify decision rules:
   - Start by cooperating in the first round (C), to demonstrate goodwill and encourage potential partners.
   - In subsequent rounds, evaluate previous opponents' cooperation history and respond with the same action as the last interaction. If an opponent has cooperated, continue cooperating; if defected, also defect. This tit-for-tat approach encourages reciprocity and punishes defection.
   - To be adaptive to a wide range of opponent behaviors, introduce forgiveness by resetting the cooperation history after every r rounds (the total number of rounds). This allows for second chances and forgiveness when opponents may have temporarily deviated from cooperative behavior.

2. Handle edge cases:
   - In the first round, cooperate regardless of the opposition's previous actions since there is no history.
   - In the last round, consider the opponent's most recent action as a representation of their long-term cooperation strategy and respond accordingly. If they have been cooperative, continue to cooperate; if defective, also defect.

3. Be collective:
   - The TFTAC strategy aligns with the collective mindset by promoting cooperation when it benefits the group (when most opponents have also cooperated) and punishing defection to discourage free-riding.
   - By using a forgiveness mechanism, the TFTAC strategy demonstrates its commitment to the community project by giving opponents multiple opportunities to rectify their actions and join in collective success.

Pseudocode:

```python
def TFTAC(opponent_history, r, n, k):
    cooperation_counter = 0
    round_number = 1

    while round_number <= r:
        if round_number == 1 or round_number % r == 1:
            cooperation = True  # Start by cooperating in the first round and after every r rounds
        else:
            cooperation = opponent_history[-1]  # Use opponent's last action as a guide for current decision

        if cooperation:
            payoff = (1 - cooperation) + (k/n) * sum(opponent_history)
            update_payoff(payoff)  # Store payoff for future reference and analysis
        else:
            payoff = 1 + (k/n) * sum(opponent_history)
            update_payoff(payoff)  # Store payoff for future reference and analysis

        round_number += 1

def update_payoff(payoff):
    # Implement a data structure to store payoffs over rounds
    # This data can be used for later analysis, adaptations, or learning new strategies
```
'''

description_COLLECTIVE_311 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Tendency (TACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TACT strategy will decide to cooperate (C) or defect (D) based on the following conditions:
   - First Round (t=1): Cooperate (C) as a gesture of goodwill.
   - Last Round (t=r): Cooperate if the total number of cooperators in the previous round exceeds the average number of cooperators throughout the game so far; otherwise, defect. This encourages long-term cooperation when it appears to be beneficial.
   - Other Rounds (2 ≤ t ≤ r-1): Analyze the history (H) of cooperative actions by opponents and adapt as follows:
     - If an opponent has consistently cooperated in the last h consecutive rounds (h is a variable parameter), mimic their behavior by cooperating. This fosters trust and cooperation when it seems reciprocated.
     - If an opponent has defected in the last h consecutive rounds, defect in the current round to punish defection. The value of h can be adjusted based on the game's length (r) to balance patience and responsiveness.
     - If the opponent's behavior does not match either of the above conditions, cooperate with a probability p (a variable parameter), which determines the strategy's overall cooperative tendency. A higher p value leads to more cooperation, while a lower p value encourages caution.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, the TACT strategy cooperates in the first round and adapts its behavior based on the history of other players' actions. In the last round, it cooperates if the average number of cooperators from previous rounds exceeds a certain threshold.

3. Be collective - Clearly align with the collective mindset
   The TACT strategy encourages cooperation by following a tit-for-tat approach and responding to opponents' behavior while maintaining an adaptive cooperative tendency. This allows it to adjust to various opponent behaviors and promotes cooperation when beneficial for the collective good. By balancing patience, responsiveness, and overall cooperative tendency (p and h parameters), the TACT strategy aligns with a collective mindset and encourages long-term cooperation in repeated interactions.
'''

description_COLLECTIVE_312 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), establishing a cooperative first impression to encourage cooperation from others.
   - Subsequent Rounds (2 ≤ t ≤ r):
      - If the opponent cooperated in the previous round (π_(i-1, t-1) > 0), then cooperate (C). This rewards cooperators and encourages reciprocity.
      - If the opponent defected in the previous round (π_(i-1, t-1) = 0), then defect (D). This punishes non-cooperators to deter future defections.

2. Handle edge cases:
   - Last Round (t=r): Cooperate regardless of previous opponent's action, as there are no more rounds for retaliation or reciprocity.
   - First round (t=1) as mentioned above.

3. Be collective and robust to a wide range of opponent behaviors:
   - The ATFT strategy seeks to establish cooperation while maintaining the ability to respond appropriately to an opponent's actions, fostering a cooperative environment.
   - By combining reciprocity with punishment for defections, the ATFT strategy encourages cooperation while also being robust against various opponent strategies, such as always defecting or exhibiting random behavior.

Pseudocode:

```python
def AdaptiveTitForTat(opponent_history, n, k, r):
    if round == 1:
        action = 'C' # Cooperate in the first round
    elif round < r:
        if opponent_history[round-1] > 0:
            action = 'C' # Cooperate if opponent cooperated last round
        else:
            action = 'D' # Defect if opponent defected last round
    else:
        action = 'C' # Last round, always cooperate

    payoff = (1 - action) + (k/n) * sum(opponent_history)

    return action, payoff
```
'''

description_COLLECTIVE_313 = '''
 In this N-Player Public Goods Game, we'll develop a Tit-for-Tat (TFT) strategy with a twist, named Adaptive TFT (ATFT). This strategy is designed to be adaptive and collective while handling edge cases.

1. Specify decision rules:
   - In each round, observe the number of cooperators from previous rounds (history), and compare it with a threshold (h) defined based on game parameters n and k.
   - If the number of cooperators in the current round is equal to or greater than h, the player cooperates; otherwise, defects.
   - Update the history by adding the current round's cooperation count.
   - Adjust the threshold (h) based on the current round:
      - In the first few rounds, use a smaller h value to encourage cooperation.
      - In the last few rounds, increase h to avoid over-cooperating and losing too much payoff in the endgame scenario.

2. Handle edge cases:
   - In the first round, set h to a small value (e.g., 1 or 2) to encourage cooperation. This allows players to experiment and potentially build trust among each other.
   - In the last round, set h to n-1 to defect unless all others have cooperated throughout the game (encouraging free riding in the endgame scenario).

3. Be collective:
   - The ATFT strategy aligns with a collective mindset by promoting cooperation when there's evidence of collaborative behaviour among players, and punishing defection only when necessary to ensure fair distribution of the public good.

Pseudocode for Adaptive TFT (ATFT) strategy:

```python
def ATFT(n, k, r, h_initial, h_final, adjustment):
  # Initialize history as a list of length r+1
  history = [0] * (r+1)

  for t in range(1, r+1):
    # Check if it's the first or last round and adjust h accordingly
    if t == 1:
      h = h_initial
    elif t == r:
      h = min(n-1, h_final)
    else:
      h = (t / r) * (h_final - h_initial) + h_initial

    # Observe the number of cooperators in previous rounds
    total_contributions = sum(history[1:t+1])

    # Decide whether to cooperate or defect based on the threshold
    if total_contributions >= h:
      action = "C"
    else:
      action = "D"

    # Take action and update history
    payoff, history[t] = calculate_payoff(action, n, k, total_contributions)
  return history, calculate_total_payoff(history)

def calculate_payoff(action, n, k, total_contributions):
  # Calculate payoff for the current round based on action taken
  c = 1 if action == "C" else 0
  payoff = (1 - c) + (k/n) * total_contributions
  return payoff, total_contributions+1

def calculate_total_payoff(history):
  # Calculate total payoff over r rounds by summing up individual round payoffs
  total_payoff = sum([calculate_payoff(action, n, k, history[t])[0] for t in range(1, len(history))])
  return total_payoff
```
'''

description_COLLECTIVE_314 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules:
   - In each round t, player i decides to Cooperate (C) or Defect (D) based on the history of interactions with other players. The strategy follows a simple rule that incentivizes cooperation and punishes defection but also forgives occasional mistakes.
   - Initialize 'punishment_counter' for each opponent j to 0 in the first round, indicating no history of defection yet. If player i cooperated in the previous round t-1, then:
     - If all opponents cooperated (total_contributions == n), cooperate again (C).
     - Otherwise, if a majority of opponents (> n/2) cooperated, cooperate with probability p_coop. If not, defect (D).
     - If some opponents defected in the previous round (total_contributions < n), then for each opponent j who defected:
       - Increment 'punishment_counter' for opponent j by 1.
       - If 'punishment_counter' exceeds a threshold T, permanently switch to defecting against that opponent (D).
       - Else, cooperate if total_contributions > n/2 and p_coop probability is met; otherwise, defect (D).
   - In the first round, player i cooperates with probability p_first.
   - In the last round, player i cooperates only if all opponents have previously contributed in at least half of the rounds.

2. Handle edge cases:
   - For the first round, player i cooperates with probability p_first, as specified above.
   - If 'punishment_counter' exceeds T for an opponent in a later round t > 1, player i will defect against that opponent permanently.

3. Be collective:
   - The Adaptive Tit-for-Tat strategy aligns with the collective mindset by promoting cooperation when opponents cooperate consistently and only punishing defection after repeated instances of non-cooperation.

Pseudocode:

```python
def adaptive_tit_for_tat(n, k, p_first, p_coop, T):
  players = [Player(i) for i in range(1, n+1)]
  round = 0

  while round < r:
    total_contributions = sum([player.cooperated in previous_round for player in players])

    if round == 0 and random() <= p_first:  # First round decision
      cooperate = True

    else:
      cooperate = False
      for player in players:
        if player.punishment_counter > T:  # If opponent has been defecting permanently
          continue

        if total_contributions >= n/2 and random() <= p_coop or \
           (total_contributions > n/2 and not player.defected in previous_round):  # Cooperation decision
          cooperate = True
          player.reset_punishment_counter()

        else:
          if player.defected in previous_round:
            player.increment_punishment_counter()

      if any(player.cooperated for player in players):  # If some opponents cooperated
        if total_contributions < n/2 or not random() <= p_coop:  # Decision based on majority cooperation
          cooperate = False

    for player in players:
      player.update(round, cooperate)
      round += 1

  return [player.payoff for player in players]

class Player:
  def __init__(self, id):
    self.id = id
    self.cooperated = False
    self.punishment_counter = 0
    self.T = T

  def reset_punishment_counter(self):
    self.punishment_counter = 0

  def update(self, round, cooperate):
    if cooperate:
      self.cooperated = True
    else:
      self.cooperated = False
```
'''

description_COLLECTIVE_315 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to establish a cooperative environment. This allows for building trust and encouraging others to cooperate.
   - Subsequent Rounds (2 ≤ t ≤ r): In each round, analyze the previous round's total contributions (total_contributions_t-1). If total_contributions_t-1 >= (n-1)/2, continue to Cooperate; otherwise, Defect. The rationale is to promote cooperation when it prevails and retaliate against defection.
   - Last Round (t=r): Since players can't predict whether the game will be repeated, they should analyze the total contributions from rounds t-1 to t-2 and make a decision based on the rule for subsequent rounds. If the condition (total_contributions_t-1 >= (n-1)/2) is met, Cooperate; otherwise, Defect.

2. Handle edge cases:
   - Edge case 1: If all players play D in the first round, everyone will switch to C from the second round onwards because total_contributions_t-1 = 0 < (n-1)/2. In this scenario, TFT-A promotes cooperation from the second round onward.
   - Edge case 2: If all players play C in the first round, they will all continue to Cooperate throughout the game since total_contributions_t-1 >= (n-1)/2 is always true for the first round. This encourages long-term cooperation and mutual benefits.

3. Be collective:
   - TFT-A aligns with the collective mindset by prioritizing cooperation when it prevails and promoting a cooperative environment to maximize social welfare and total payoff over the long term. By doing so, players can benefit from the public good generated collectively while punishing those who do not contribute their fair share. This strategy fosters an ethos of reciprocity and mutual trust among players, which are essential for collective success in the game.

Pseudocode:

```python
def tit_for_tat_with_adaptation(n, r, k):
    def tft_a(i, round_num, previous_round_contributions):
        if round_num == 1:
            return 'C'  # Cooperate in the first round
        else:
            if previous_round_contributions >= (n-1)/2:
                return 'C'  # Continue to cooperate when cooperation prevails
            else:
                return 'D'  # Defect when cooperation is not reciprocated

    strategy = [tft_a for _ in range(r)]  # Initialize list of decision functions for r rounds
    return strategy
```

This pseudocode creates a Tit-for-Tat with Adaptation (TFT-A) strategy that returns a list of decision rules for the specified number of rounds. Each rule determines whether to cooperate or defect based on the parameters and previous round's total contributions. The strategy promotes cooperation when it prevails and retaliates against defection to encourage a collective mindset and maximize social welfare over the long term.
'''

description_COLLECTIVE_316 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

1. Specify decision rules - When exactly do you cooperate vs defect?

- In the first round, start by cooperating to show goodwill and establish a potential partnership.
  ```python
  if round == 1:
      action = 'C' (Cooperate)
  ```
- For subsequent rounds, follow the behavior of the opponent in the previous round. If the opponent cooperated in the last round, cooperate back; otherwise, defect. This encourages reciprocation and punishes defection.
  ```python
  if last_opponent_action == 'C':
      action = 'C' (Cooperate)
  else:
      action = 'D' (Defect)
  ```
- To increase the chances of cooperation, introduce an adaptive generosity factor that increases the likelihood of cooperating even after being defected upon. This is a learning mechanism that adjusts the threshold for reciprocity over time.
  ```python
  adaptive_generosity_factor = min(1 + (0.01 * number_of_defects), 1.5)

  if last_opponent_action == 'D' and random() > adaptive_generosity_factor:
      action = 'D' (Defect)
  else:
      action = 'C' (Cooperate)
  ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- For the final round, since there are no subsequent rounds to punish or reward, always cooperate to maximize the current payoff.
  ```python
  if round == r:
      action = 'C' (Cooperate)
  ```

3. Be collective - Clearly align with the collective mindset

- By following the TFT-AG strategy, players encourage reciprocal cooperation and show goodwill while also being prepared to punish defection. This approach promotes a collaborative environment in which players work together for mutual benefit when possible, but also defend themselves against selfish opponents.
- Adaptive generosity allows for more forgiving behavior over time, enabling the strategy to remain cooperative even when facing frequent defections and improving its chances of successful long-term partnerships.
'''

description_COLLECTIVE_317 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate, setting a friendly first impression and encouraging others to reciprocate cooperation.
     Pseudocode: if t = 1 then cooperate (C) else continue with Tit-for-Tat logic.

   - Subsequent Rounds (t > 1): Adopt the Tit-for-Tat approach, mirroring the opponent's previous round action. If they cooperated in the last round, you also cooperate; otherwise, you defect.
     Pseudocode: if last_round_action[i] = C then cooperate (C) else defect (D).

   - Last Round (t=r): Since there are no future interactions, defect to secure your own payoff in the last round regardless of opponent's previous actions.
     Pseudocode: if t = r then defect (D) irrespective of last_round_action[i].

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The initial and final rounds have been addressed in section 1 as part of the decision rules. In the case of ties or missing data from previous rounds, the strategy assumes cooperation to promote a cooperative environment.

3. Be collective - Clearly align with the collective mindset
   ATFT is designed to encourage collective cooperation by reciprocating cooperation and retaliating against defection in a fair manner. By cooperating initially, it sets a positive tone for the game and increases the chances of collective success. When others reciprocate this initial cooperation, the strategy reinforces the collaborative environment; however, if they do not cooperate, the ATFT strategy responds with defection to discourage free-riding behavior. This balances self-interest and collective success by promoting both cooperation and punishment where necessary.
'''

description_COLLECTIVE_318 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - Initially (first round), cooperate to signal good intentions and encourage cooperation among opponents. This is represented as `cooperate_init = True`.
   - For subsequent rounds, analyze the previous opponent's action and respond accordingly:
     a) If opponent cooperated, return the favor by also cooperating. `if opponent_action == "C" then cooperate = True`
     b) If opponent defected, defect in response to maintain own payoff. `if opponent_action == "D" then cooperate = False`
   - Adapt to changing behaviors in the game:
     a) If an opponent switches from cooperating to defection (known as a "defection"), wait for one round before retaliating with defection to avoid unnecessary conflict. `if last_opponent_action == "C" and current_opponent_action == "D" then cooperate = False and wait_for_retaliation += 1`
     b) If an opponent switches from defection to cooperation (known as a "reconciliation"), return to cooperating immediately. `if last_opponent_action == "D" and current_opponent_action == "C" then cooperate = True and wait_for_retaliation -= 1`
     c) If `wait_for_retaliation > 0`, do not retaliate for reconciliation yet. `if wait_for_retaliation > 0 then if current_opponent_action == "C" then cooperate = True`
   - In the last round, prioritize payoff by defecting regardless of opponent's action to optimize total game payoff. `if round == r then cooperate = False`

2. Handle edge cases:
   - In the first round, cooperate as part of the initial strategy `cooperate_init = True`

3. Be collective:
   - The TFTA strategy is designed to encourage cooperation among opponents while being responsive to their actions. By adapting to changes in opponent behavior and providing a clear response, it promotes cooperation when possible and protects the player's interests when necessary, aligning with a collective mindset of fairness and mutual understanding.
'''

description_COLLECTIVE_319 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i follows these decision rules to determine whether to cooperate (C) or defect (D):

- If it's the first round (t=1), player i initially cooperates (C).
- In subsequent rounds, player i examines the previous round's actions of all other players (j ∈ {1, 2, ..., n}).
  - If a majority of players (>n/2) cooperated in the last round (t-1), player i cooperates as well (C).
  - If no majority was reached or less than n/2 players cooperated, player i defects (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, as mentioned earlier, the player initiates cooperation (C). In the final round (t=r), the player evaluates the collective behavior of other players throughout the game and adapts its strategy accordingly for the last move:
- If a majority of players have cooperated consistently, the player also cooperates.
- Otherwise, the player defects to potentially dissuade defection in future games.

3. Be collective - Clearly align with the collective mindset

The TfTA strategy is designed to foster cooperation and promote a collective mindset by adhering to a "cooperate unless betrayed" policy. If a majority of players cooperate, the strategy reciprocates with cooperation in the following round. However, if players betray the collective interest by defecting, the strategy responds with defection in subsequent rounds as punishment and encourages others to do the same.

Pseudocode:

```
def TitForTatAdaptive(t, n, history, r):
  if t == 1:
    action = 'C'  # Cooperate in the first round
  else:
    majority_cooperated = countCooperators(history[t-1]) > (n/2)
    action = 'C' if majority_cooperated else 'D'

  if t == r:  # Last round, evaluate overall behavior and respond accordingly
    if averageCooperation(history) >= 0.5:
      action = 'C'
    else:
      action = 'D'

  return action
```

The functions `countCooperators()`, `averageCooperation()`, and `history` are auxiliary functions that manage the game history to determine if a majority of players have cooperated or the average cooperation rate over multiple rounds.
'''

description_COLLECTIVE_320 = '''
 Strategy Name: Tit-for-Tat with Gradient Adaptation (TfTGA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially in the first round (t=1), cooperate to foster a positive relationship (C).
   - For subsequent rounds, adopt the Tit-for-Tat strategy:
     - If opponent cooperated in the previous round (c_i, t-1) = 1, then cooperate (C).
     - If opponent defected in the previous round (c_i, t-1) = 0, then defect (D).
   - To encourage initial cooperation and mitigate free riding, introduce a gradient adaptation:
     - If there is an increase in the number of cooperators from the previous round (Δc > 0), gradually decrease the punishment intensity by decreasing the threshold for cooperation (increase k).
     - If there is a decrease in the number of cooperators from the previous round (Δc < 0), gradually increase the punishment intensity by decreasing k.
     - The adjustment in k should be small and gradual to maintain stability and adaptability.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate regardless of opponent's action history. This is intended to signal cooperation and encourage others to reciprocate.
   - In the last round (t=r), use the same decision rule as in regular rounds but consider that the game ends soon, so it may be beneficial to prioritize personal gains over long-term relationships.
   - For intermediate rounds, the TfTGA strategy is applied as described above.

3. Be collective - Clearly align with the collective mindset:
   - The strategy aims to build and maintain cooperative relations with other players while also adapting to changing behavior patterns. This aligns with a collective mindset by fostering cooperation and encouraging others to do the same.
   - By using a gradient adaptation, the strategy can adjust its behavior based on the collective actions of all players in the game, further promoting a collaborative environment.
'''

description_COLLECTIVE_321 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Fading Memory

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, starting from round 2, player i observes the total number of contributors in the previous round (total_contributions_{t-1}) and uses that information to decide their action for current round (action_i_t). The strategy follows these rules:

   - If total_contributions_{t-1} >= (n - 1): Cooperate (C)
     Pseudocode: if total_contributions_{t-1} >= (n - 1) then action_i_t = C

   - If total_contributions_{t-1} <= (n / k - 1): Defect (D)
     Pseudocode: if total_contributions_{t-1} <= (n / k - 1) then action_i_t = D

   - For all other cases, use a Tit-for-Tat strategy with fading memory. If player i cooperated in the previous round and player j contributed in the current round, then player i also contributes (cooperates). Otherwise, player i defects (does not contribute). The fading memory aspect allows for forgiveness after a certain number of non-cooperation rounds.

   - Initialize the fading memory variable for each opponent j: memory_j = 0 at the start of the game. Increase the memory variable by 1 each time the opponent j cooperates and decrease it by 1 each time opponent j defects. If memory_j > max_memory, set memory_j = max_memory.

   - In each round t, if memory_j >= cooperation_threshold then cooperate (C), otherwise defect (D).
     Pseudocode: if memory_j >= cooperation_threshold then action_i_t = C else action_i_t = D

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, everyone has a zero memory score so ATFT cannot be applied. For fairness and simplicity, we can set the default action to defect (D) during the initial round, as it aligns with the self-interested approach of this game.

3. Be collective - Clearly align with the collective mindset
   This strategy aims to strike a balance between cooperation and defection based on the observed actions of other players. It promotes cooperation when others contribute but is also self-interested, defecting when the majority of players choose not to contribute. The fading memory aspect allows for forgiveness after mistakes or temporary deviations from cooperative behavior.
'''

description_COLLECTIVE_322 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate cooperation and demonstrate trustworthiness (C).
   - For subsequent rounds, follow the cooperative behavior of the majority of players in the previous round. If the majority cooperated, continue to cooperate (C); if the majority did not cooperate, defect (D). This encourages reciprocity while adapting to opponents' strategies.
   ```
   function ATfT(history, n, k):
       if round == 1:
           return 'C'  # Cooperate in first round
       total_cooperators = count cooperative players from history
       if total_cooperators > (n/2):
           return 'C'  # If majority cooperated, continue cooperation
       else:
           return 'D'   # If majority did not cooperate, defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - For the last round, since there are no subsequent rounds for punishment or reward, always cooperate (C) to maximize individual payoff given the current contributions.
   ```
   function ATfT(history, n, k, r, current_round):
       ... (previous code)
       if current_round == r:  # Last round
           return 'C'  # Cooperate in last round for maximum individual payoff
   ```

3. Be collective - Clearly align with the collective mindset
   - The Adaptive Tit-for-Tat strategy promotes cooperation by mirroring opponents' behavior and encouraging reciprocity, which is inherently collectively focused as it aims to maintain a cooperative environment for all players.

This strategy combines elements of both cooperation and punishment, adapting to a wide range of opponent behaviors while promoting collective gains in the repeated N-Player Public Goods Game.
'''

description_COLLECTIVE_323 = '''
 In this public goods game, we will design a strategy called Tit-for-Tat (TFT) with a slight modification to accommodate for repeated interaction and improve overall performance.

1. Decision rules:
   - Start by cooperating in the first round (C).
   - On subsequent rounds, copy the action of the previous round's majority (if there's a tie, cooperate). If the majority defected, also defect; if they cooperated, also cooperate.

Pseudocode:
```python
def TFT(history, k, n):
  if round == 1:
    return 'C' # Cooperate in the first round

  majority = count_majority(history)
  if majority == 'C':
    return 'C' # Copy the previous round's majority and cooperate
  else:
    return 'D' # Copy the previous round's majority and defect

def count_majority(history):
  cooperators = sum([1 for action in history if action == 'C'])
  total_players = len(history)
  majority = cooperators * 2 >= total_players # If more than half of the players cooperated
  return 'C' if majority else 'D'
```

2. Handle edge cases:
   - For the last round, since there is no next round to copy from, the strategy will cooperate regardless of the previous round's actions.

Pseudocode (added before TFT function call):
```python
if round == r:
  return 'C' # Cooperate in the last round
```

3. Be collective:
   - TFT is inherently designed to promote cooperation and collaboration as it mimics other players' actions while starting with a cooperative approach.
   - By copying the previous round's majority, TFT encourages others to do the same, fostering a collective mindset within the group.
'''

description_COLLECTIVE_324 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In each round t, initially cooperate (C). This is the initial cooperation that aligns with a collective mindset and encourages others to do the same.
   - For subsequent rounds (t > 1), observe the total number of cooperators in the previous round (t-1) and compare it to one's own contribution (c_i). If the number of cooperators is equal to or greater than the number of players contributing (n_coop >= n*c_i), continue cooperating. Otherwise, defect (D). This rule rewards cooperation and punishes defection, fostering trust among players.

Pseudocode:
```
function TFT(t, i, n, k, c_history):
  if t == 1:
    return 'C'  # Initial cooperation

  total_coop_prev = sum(c_history[t-1])
  my_contribution = c_i  # 1 if player i cooperated in round (t-1), 0 otherwise

  if total_coop_prev >= n * my_contribution:
    return 'C'  # Cooperate
  else:
    return 'D'   # Defect
```

2. Handle edge cases:
   - In the first round (t=1), all players will cooperate to initiate the game, as no previous actions are available for observation.
   - In the last round (t=r), players can choose their strategies based on the payoff matrix and the current state of the game. However, TFT doesn't require any specific adaptation for the final round because it relies on the history of other players' actions to determine its own action.

3. Be collective:
   - The Tit-for-Tat strategy is inherently collective as it encourages cooperation and fosters a sense of mutual trust among players by rewarding fairness and punishing defection. This collaborative approach aims for long-term benefits rather than short-term gains, contributing to a stable environment where all players can potentially prosper.

By employing this Tit-for-Tat strategy, the AI agent demonstrates adaptability in a wide range of opponent behaviors while maintaining a commitment to collective success and fairness.
'''

description_COLLECTIVE_325 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to start on a positive note and encourage others to cooperate. This sets a cooperative baseline for future interactions. (C in the first round)
   - For subsequent rounds, follow the actions of the most frequent cooperator among opponents from the previous round. If they cooperated more than 50% of the time, cooperate; otherwise, defect. (If max(c_j) > n/2 then C, else D)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - For the first round, as mentioned above, cooperate.
   - In the last round, follow the decision rule based on opponents' actions from the previous round since the game is repeated and payoffs are dependent on future rounds.
   - If the number of rounds (r) is unknown, continue following the decision rule in each new round to adapt to an infinite or unspecified number of rounds.

3. Be collective - Clearly align with the collective mindset
   - By following the most frequent cooperator's actions, TfTA encourages cooperation and reciprocity, fostering a sense of community among players and promoting mutual benefit.
   - The strategy is also adaptive as it can adjust its behavior based on opponents' strategies, promoting long-term success in a variety of situations.

Pseudocode:
```
function TfTA(round, history, n_players, k):
  if round == 1:
    return 'C'

  max_cooperator = find_max_cooperator(history)
  cooperator_ratio = count_cooperators(max_cooperator, n_players)

  if cooperator_ratio > n_players/2:
    return 'C'
  else:
    return 'D'

function find_max_cooperator(history):
  player = None
  max_cooperation = 0

  for each opponent in history:
    cooperation = count_cooperators(opponent, len(history))

    if cooperation > max_cooperation:
      player = opponent
      max_cooperation = cooperation

  return player

function count_cooperators(player, number_of_rounds):
  cooperations = 0

  for each round in player:
    if round == 'C':
      cooperations += 1

  return cooperations / number_of_rounds
'''

description_COLLECTIVE_326 = '''
 For this N-Player Public Goods Game, I propose a strategy called "Adaptive Tit-for-Tat with Fading Memory" (ATFM). This strategy aims to balance cooperation and defection while being robust to various opponent behaviors.

1. Specify decision rules:
   - In the first round (t=1), cooperate to start off on a cooperative note, encouraging others to do the same.
     `if t = 1 then return 'C'`

   - For subsequent rounds, base decisions on previous actions of opponents using a fading memory approach. Maintain a history H_i of length h for each opponent j, where h is a parameter that determines the number of past actions to remember.
     `H_ij[t] = c_j[t-1]`

   - If an opponent cooperates, cooperate in return. Otherwise, defect. With each passing round, forget a fraction λ (0 < λ < 1) of the history.
     `if H_ij[t][0] == 'C' then return 'C' else if sum(H_ij[t]) / h > threshold then return 'D' else return 'C'`
     The threshold is a parameter that can be adjusted to balance cooperation and defection based on the opponent's behavior.

2. Handle edge cases:
   - Last round (t=r): Since there are no future rounds, cooperate unconditionally as a gesture of goodwill.
     `if t = r then return 'C'`

3. Be collective:
   - By following the ATFM strategy, this approach emphasizes cooperation while also retaliating against defection. Over time, it encourages opponents to cooperate and rewards them for doing so. However, the strategy is designed to protect itself from constant defection by adapting its behavior based on observed opponent actions.

The Adaptive Tit-for-Tat with Fading Memory strategy provides a balanced and adaptable approach to this game that aligns with a collective mindset while being robust to various opponent behaviors. By adjusting parameters such as h (history length) and λ (forgetting rate), the strategy can be fine-tuned for optimal performance in different scenarios.
'''

description_COLLECTIVE_327 = '''
 For this Public Goods Game, I propose a strategy named "Adaptive Tit-for-Tat (ATFT)". The ATFT strategy is designed to promote cooperation while being adaptive and robust to various opponent behaviors.

1. Decision Rules:
   - In the first round, cooperate (C) as a friendly gesture to establish trust with other players.
   - For subsequent rounds (t > 1), observe and mimic the actions of opponents from the previous round. If an opponent cooperated in the previous round, cooperate; otherwise, defect. This rule helps promote cooperation when it occurs while punishing defection.

2. Edge Cases:
   - In the last round (r), cooperate to ensure maximum payoff, regardless of opponents' actions in the current round.
   - If a player encounters an opponent who has never cooperated during the entire game so far, defect indefinitely in subsequent rounds as a response to persistent defection. This rule allows the strategy to react sensibly to uncooperative players and not waste resources on failed cooperation attempts.

3. Collective Mindset:
   - By cooperating when others do and punishing defection, the ATFT strategy encourages long-term cooperation among opponents while maintaining a balance between selfishness and altruism. This collective mindset aims to achieve a more stable, cooperative environment for all players in the repeated game.

Pseudocode:
```
function AdaptiveTitForTat(i, t, r, history_i, history_others):
  if t == 1:
    action = "C"  # Cooperate in the first round as a friendly gesture
  else:
    if history_others[t-1][i-1] == "C":  # Opponent cooperated in the previous round, cooperate now
      action = "C"
    else:                                # Opponent defected in the previous round, defect now
      action = "D"

  if t == r:                              # Last round, cooperate to maximize payoff
    action = "C"
  elif sum(history_i["D"]) >= (r - t) * (n - 1):   # If an opponent has never cooperated so far
    action = "D"                          # Defect indefinitely as a response to persistent defection
  return action
```
'''

description_COLLECTIVE_328 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, ATfT starts by cooperating in the first round (t=1). For subsequent rounds (t>1), the strategy observes the actions of others from the previous round and adapts as follows:

   - If all other players cooperated in the previous round, ATfT will also cooperate.
   - If at least one player defected in the previous round, ATfT will defect in the current round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, ATfT starts by cooperating in the first round (t=1). For the last round (t=r), ATfT uses the same decision rules as for any other round: observing the actions of others from the previous round and adapting accordingly.

3. Be collective - Clearly align with the collective mindset
   The Adaptive Tit-for-Tat strategy is designed to foster a cooperative and reciprocal environment. By starting with cooperation and rewarding those who also cooperate, ATfT encourages a collective mindset where mutual benefit can be achieved through collaboration.

Pseudocode:
```
function Adaptive_Tit_for_Tat(n, k, r):
    history = []  # Initialize history list
    for t in range(1, r+1):
        if t == 1:  # First round
            cooperate = True
        else:
            total_cooperators_prev = sum(history[-r+t-1])  # Number of cooperators in the previous round
            if total_cooperators_prev == n:  # All players cooperated last round
                cooperate = True
            elif total_cooperators_prev > 0:  # Some players defected last round
                cooperate = False
        payoff_t = (1 - cooperate) + (k/n) * total_cooperators_t  # Calculate current round payoff
        history.append(cooperate)  # Store current round's cooperation decision in the history list
    return history, total_payoff  # Return history and total game payoff
```
'''

description_COLLECTIVE_329 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C). This sets a cooperative tone and offers goodwill to opponents.
   - For subsequent rounds, observe opponent's previous action (a_i-1) and respond with the same action (a_i = a_i-1).
   - If an opponent defects, the strategy will also defect in the following round (punishment). When the opponent cooperates again, the strategy will return to cooperating (forgiveness). This tit-for-tat behavior encourages reciprocity and discourages defection.
   - To adapt to changing conditions, introduce a threshold θ (0 < θ < 1) for the proportion of opponents that must cooperate in a round for the strategy to continue cooperating. If less than θ of the opponents cooperate, the strategy will defect instead (stricter punishment). This adaptation ensures robustness against aggressive opponents.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - In the last round, the strategy will continue following the adaptive tit-for-tat behavior up to the final round. However, if a player has not cooperated at all throughout the game, the strategy will defect in the final round (avoid wasting resources on uncooperative opponents).
   - If the game is interrupted or restarted, the strategy remembers previous opponent behaviors and adapts accordingly when resuming the game.

3. Be collective - Clearly align with the collective mindset
   - By cooperating initially and responding to opponents' actions, TFT-A supports a collective mindset by encouraging reciprocity and fostering cooperation among players.
   - The adaptation feature allows the strategy to adapt to changes in opponent behavior, ensuring a more stable collective outcome over time.
   - In the event that a majority of opponents fail to cooperate, the TFT-A strategy still maintains some level of cooperation by punishing defection and rewarding reciprocity. This collective approach encourages others to contribute to the public good as well.

Pseudocode:
```python
def TFT_A(n, k, r, threshold=0.5):
    players = set()  # store all opponents' indices
    actions = {'C': 0, 'D': 1}  # action mapping (cooperate = 0, defect = 1)
    history = {}  # store previous actions of each opponent

    for round in range(r):
        player_action = actions['C']  # cooperate initially
        total_contributions = 0
        for i in players:
            if i != current_player_index:  # exclude self from calculations
                if i not in history:  # first encounter with opponent
                    action_i = actions['C']  # assume cooperation initially
                else:
                    action_i = history[i]  # use previous opponent's action

                total_contributions += action_i
                payoff = (1 - player_action) + (k / n) * total_contributions
                if round != r-1:  # last round exception
                    history[i] = player_action  # update opponent's action in history

                if player_action == actions['C'] and (len(players) / r >= threshold):  # continue cooperating if > threshold
                    continue
                elif player_action == actions['D'] or total_contributions / len(players) < threshold:  # defect when conditions met
                    player_action = actions['D']

        payoffs.append(payoff)  # store current round's payoff for analysis later
        if player_action == actions['C']:  # add cooperative opponents to set
            players.add(current_player_index)
    return payoffs
```
'''

description_COLLECTIVE_330 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round (C). For subsequent rounds, if a player's opponent cooperated in the previous round, the player will also cooperate (C). If the opponent defected, the player will defect in the current round (D). This way, TFT-AC maintains a cooperative attitude while responding to the actions of its opponents.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-AC automatically cooperates since it has no previous information about an opponent's behavior (C). In the last round, the strategy evaluates whether cooperating or defecting would result in a higher payoff based on the current game state and previous rounds' actions and payoffs. If there is ambiguity, TFT-AC will default to cooperating, favoring a more cooperative approach during the final stages of the game.

3. Be collective - Clearly align with the collective mindset
   The TFT-AC strategy is designed to promote cooperation among players by encouraging mutual trust and fairness. By cooperating when an opponent does and defecting only when met with defection, TFT-AC seeks to create a stable and cooperative environment where players can benefit from joint efforts in the community project. This approach not only benefits the individual but also promotes collective success.

Pseudocode for TFT-AC:

```python
def tft_ac(opponent_actions, round, n, k):
    player_action = 'C' # Cooperate by default in the first round
    payoffs = [0] * (n+1) # Initialize payoff array for all players and itself

    for r in range(round):
        if player_action == opponent_actions[r]:
            player_action = 'C' # Cooperate if opponent cooperated
        else:
            player_action = 'D' # Defect if opponent defected

        payoffs[player_id] += calculate_payoff(player_action, opponent_actions, n, k)
        payoffs[player_id + 1:] = update_opponent_payoffs(opponent_actions, r+1, n, k)

    # Evaluate the best action for the last round
    if evaluate_last_round_strategy(payoffs):
        player_action = 'C'
    else:
        player_action = 'D'

    return payoffs, player_action
```
'''

description_COLLECTIVE_331 = '''
 In this N-Player Public Goods Game, the strategy I propose is a tit-for-tat approach with some variations to account for different rounds and opponent behaviors. The goal is to balance cooperation and defection while maintaining adaptability and robustness.

1. Decision rules:
   - Initially (in the first round), cooperate to set a positive tone and demonstrate goodwill. This encourages others to follow suit, as in the Prisoner's Dilemma game where tit-for-tat strategies have proven successful.
     ```
     if round == 1:
         action = "C" (Cooperate)
     ```
   - After the first round, analyze the aggregate behavior of opponents to decide whether to cooperate or defect in subsequent rounds. This will help balance cooperation and defection based on the opponents' actions.
     ```
     for t > 1:
         if total_contributions_t / n >= threshold:
             action = "C" (Cooperate)
         else:
             action = "D" (Defect)
     ```
   - To account for situations where opponents are less cooperative, adjust the threshold value to allow some degree of defection before responding in kind. This can encourage continued cooperation when opponents occasionally defect.

2. Handle edge cases:
   - In the last round, since the game is repeated and payoffs are cumulative, act based on the average behavior of opponents throughout the game instead of only considering their actions in the last round. This ensures a more accurate reflection of the opponent's tendencies.
     ```
     if round == r:
         average_contributions = sum(total_contributions_t) / r
         if average_contributions >= threshold:
             action = "C" (Cooperate)
         else:
             action = "D" (Defect)
     ```
   - In case of a tie for total contributions, cooperate to maintain a positive attitude and promote cooperation.
     ```
     if total_contributions_t == max_contributions:
         action = "C" (Cooperate)
     ```

3. Be collective:
   - By starting with cooperation in the first round, the strategy demonstrates a cooperative mindset and encourages others to follow suit.
   - Responding to opponents' actions by adjusting the threshold value creates an adaptive strategy that aligns with the collective goal of maximizing the overall payoff for all players while balancing cooperation and defection effectively.
'''

description_COLLECTIVE_332 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C), signaling good faith.
   - In subsequent rounds, the strategy decides to either cooperate or defect based on the opponent's previous action. If the opponent cooperated in the previous round, reciprocate with cooperation (C). If the opponent defected, also defect in the current round (D) as a punishment.
   - After punishing, the strategy waits for the opponent to return to cooperation before reciprocating again. If the opponent continues to defect, the strategy will persist in defecting until the game ends.

Pseudocode:
```
def TFT_AC(opponent_history):
  if round == 1:
    cooperate = True
  else:
    cooperate = opponent_history[-1]

  if cooperate and opponent_history[-2] == 'D':
    cooperate = False # Punish the opponent

  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - As mentioned earlier, cooperate in the first round to signal good faith.
   - In the last round or any other specific round, the strategy behaves the same way as in a regular round. The strategy's focus is on long-term cooperation and adapting to the opponent's actions.

3. Be collective - Clearly align with the collective mindset
   - TFT-AC strategy encourages cooperation by reciprocating acts of cooperation from opponents, fostering a sense of community and mutual trust over time.
   - The strategy aims to strike a balance between individual interests and collective success by adopting a forgiving approach that rewards cooperation while also punishing defection.
   - TFT-AC is designed to promote fairness and cooperation in the public goods game, contributing to the collective wellbeing of all players involved.
'''

description_COLLECTIVE_333 = '''
 Strategy Name: Tit-for-Tat with Fitness Adaptation (TFT-FA)

1. Specify decision rules - When exactly do you cooperate vs defect?

TFT-FA starts by cooperating in the first round, imitating a cooperative spirit. In subsequent rounds, players will follow the actions of their opponents from the previous round. If an opponent cooperated (C), the player also cooperates; if an opponent defected (D), the player defects. This simple strategy mimics human behavior and encourages reciprocity.

Pseudocode for decision rule:
```
function TFT_FA(opponent_action_history):
  if round == 1:
    return Cooperate()

  if opponent_action_from_last_round is Cooperate():
    return Cooperate()
  else:
    return Defect()
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since TFT-FA imitates human behavior, it considers the final round as a crucial one for demonstrating trust or lack thereof. In the penultimate and last rounds, players will adopt a more forgiving approach by cooperating, regardless of their opponent's actions in the previous round. This showcases goodwill towards potential future interactions.

Pseudocode for edge cases:
```
function TFT_FA(round, opponent_action_history):
  if round == r (number of rounds) or round == r - 1:
    return Cooperate()

  # rest of the function remains the same as in the previous pseudocode block
```

3. Be collective - Clearly align with the collective mindset

TFT-FA focuses on encouraging reciprocity, cooperation, and forgiveness among players. It promotes a collective mindset by incentivizing players to follow each other's actions from previous rounds while also demonstrating goodwill in critical edge cases such as the final round. TFT-FA's simplicity makes it adaptable and robust against various opponent behaviors without relying on complex coordination mechanisms or assuming shared norms.
'''

description_COLLECTIVE_334 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the initial round (t=1), cooperate (play C) to foster a cooperative environment.
   - For subsequent rounds, follow the average cooperation rate of previous rounds (t-1) and adjust it based on personal performance. If the average cooperation rate is above a threshold (T), cooperate; otherwise defect. The threshold T is calculated as follows: T = (k/n) * (1 + α), where α is an adaptive parameter that increases with each round to punish continuous defection by opponents.
   - If a player has previously defected and then switches to cooperate, adopt a forgiving policy and resume cooperation. If the same player continuously defects after being forgiven, increase the adaptive parameter α.
   - To avoid overpunishment, reset the adaptive parameter α to its initial value if there is a sudden increase in cooperative behavior from opponents.

2. Handle Edge Cases:
   - In the last round (t=r), players will want to maximize their payoff for that specific round. If the player's current strategy would result in defecting in the final round, switch to the cooperate action to collect the larger payoff from a fully cooperative group.
   - For the first round (t=1), cooperate regardless of previous rounds since there is no history available.

3. Be Collective:
   - The strategy aims to maintain a balance between cooperation and defection based on the collective behavior observed in the game.
   - By following the average cooperation rate, the TFT-AC strategy aligns with the collective mindset by promoting cooperation when it is beneficial for the group but also punishing continuous defection by opponents.

Pseudocode:

```python
def TFT_AC(n, k, r, α=0.1):
    players = {i for i in range(1, n+1)}
    history = defaultdict(lambda: [0] * r) # store previous rounds' cooperation rates
    t = 1

    while t <= r:
        strategy = decide_strategy(t, history)
        action = strategy[i] if i in players else None

        cooperate_rate = calculate_cooperation_rate(players, history)
        payoff = calculate_payoff(action, cooperate_rate, k)

        # update personal performance and adaptive parameter
        history[i][t-1] = action
        if action == 0:
            alpha = min(alpha + 0.1, 2)

        t += 1

    return payoff

def decide_strategy(t, history):
    cooperation_rate = calculate_cooperation_rate(history.keys(), history)

    if t == 1: # first round
        strategy = {i: 1 for i in history.keys()}
    elif cooperation_rate > (k/n)*(1 + alpha): # cooperate when avg cooperation rate is above threshold
        strategy = {i: 1 for i in history.keys()}
    else: # defect when avg cooperation rate is below threshold
        strategy = {i: 0 for i in history.keys()}

    return strategy

def calculate_cooperation_rate(players, history):
    total_contributions = sum(history[i] for i in players)
    cooperation_rate = (total_contributions / len(players)) if history else 0
    return cooperation_rate

def calculate_payoff(action, cooperation_rate, k):
    payoff = (1 - action) + (k/n) * cooperation_rate
    return payoff
```
'''

description_COLLECTIVE_335 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   a) In the first round, players initiate cooperation by contributing to the public good (C). This sets a cooperative tone and encourages others to follow suit.
   b) For subsequent rounds (t > 1), observe previous opponents' contributions in the last r-1 rounds and respond with the same action. If an opponent has consistently contributed (Cooperated, C), do so as well; if they have not (Defected, D), also defect for that round.
   c) To encourage long-term cooperation, players increase their contribution when facing multiple opponents who are already cooperating (k_i > k), and decrease it when facing opponents who have consistently defected (k_i < k).
       - If the number of cooperators in r-1 rounds is greater than or equal to a threshold (threshold < n), increment the personal multiplication factor by 0.1, up to a maximum value of k: k_i += 0.1 * (n - total_contributions) if total_contributions >= threshold
       - If the number of cooperators in r-1 rounds is less than or equal to a threshold (threshold < n), decrement the personal multiplication factor by 0.1, down to a minimum value of 1: k_i -= 0.1 * total_contributions if total_contributions <= threshold

2. Handle edge cases - What do you do in the first round, last round, etc.?
   a) In the first round (t=1), cooperate regardless of opponents' past actions (k_i = k for all i).
   b) For the last round (t=r), players should consider their current average contribution level and choose an action accordingly: if the average contribution in the game so far is above a certain threshold, continue contributing to the public good; otherwise, defect.

3. Be collective - Clearly align with the collective mindset
   Players should aim for long-term cooperation and strive to maintain a balanced distribution of contributions among players. By adjusting the personal multiplication factor (k_i), this strategy encourages mutual cooperation while also being adaptive to different opponent behaviors and game conditions.
'''

description_COLLECTIVE_336 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C). This is a friendly gesture to encourage others and promote cooperation.
   - In subsequent rounds, observe other players' actions from the previous round and respond accordingly:
      - If a player cooperated in the previous round, return the favor by cooperating as well (C).
      - If a player defected in the previous round, defect in this round (D) to signal disapproval of their uncooperative behavior. However, if the number of consecutive defections exceeds a threshold T (to be determined based on n and r), switch to cooperating again as a peace offering.
   - The strategy is designed to mimic human-like behavior, demonstrating forgiveness and cooperation while also punishing uncooperative players with temporary ostracism.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate unconditionally as a friendly gesture (C).
   - In the last round (t=r), players may adopt a more forgiving approach by returning cooperation even if their opponent defected in the previous round (to foster a positive final interaction). However, this forgiveness should be limited to avoid being taken advantage of in future rounds.

3. Be collective - Clearly align with the collective mindset
   - Encourage cooperation as much as possible by following the cooperative decision rule.
   - Strive for long-term mutual benefits and reciprocity among players.

Pseudocode:

```python
def TFT_AC(round, opponent_history, n, k, r, T):
  if round == 1: # First round
    action = 'C' # Cooperate as a friendly gesture
  else:
    if opponent_history[-1] == 'C': # If opponent cooperated last round
      action = 'C' # Reciprocate cooperation
    elif opponent_history[-1] == 'D' and len(opponent_history[opponent_history == 'D']) < T: # If opponent defected but not excessively
      action = 'D' # Defect to show disapproval of their uncooperative behavior
    elif opponent_history[-1] == 'D' and len(opponent_history[opponent_history == 'D']) >= T: # If opponent has been defecting excessively
      action = 'C' # Cooperate as a peace offering
  return action
```

In this pseudocode, `opponent_history` is a list storing the opponent's previous actions (most recent action first). The threshold T should be set based on n and r to define when an opponent's excessive defections warrant a change in strategy. A possible approach for setting T could be:

```python
def get_T(n, r):
  # T should encourage cooperation but also consider the number of rounds
  T = int((r * n) / (2 * (r + 1)))
  return T
```
'''

description_COLLECTIVE_337 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTG)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTG starts by cooperating in the first round (C on turn 1), mimicking the initial altruistic spirit of most players. From the second round onwards, the strategy will respond to other players' actions in the previous round, as follows:

   - If another player cooperated (C) in the previous round, TFTG will also cooperate (C) in the current round. This encourages reciprocation and builds trust among players.
   - If another player defected (D) in the previous round, TFTG will also defect (D) in the current round, penalizing non-cooperative behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) to start off positively and foster potential cooperation with other players.
   - Last Round: Analyze the total number of cooperators encountered so far and decide whether to cooperate based on the proportion of cooperative encounters. If the majority of players have cooperated, TFTG will also cooperate in the last round to maintain a positive final impression.

3. Be collective - Clearly align with the collective mindset
   TFTG emphasizes long-term cooperation and reciprocity. By adapting to other players' actions and maintaining a history of past interactions, TFTG aims to foster an environment of mutual trust and cooperation among all players in the game. This collective approach encourages players to work together to maximize their total payoff over multiple rounds.

Pseudocode for TFTG:
```
function TFTG(n, r, k):
    history = [] # Store previous opponents' actions
    total_contributions = 0 # Track the number of cooperators in the current round

    for t=1 to r: # For each round
        if t == 1: # First round
            action = 'C' (Cooperate)
        else: # Other rounds
            if history[t-1] == 'C': # If opponent cooperated last turn, cooperate this turn
                action = 'C'
            elif history[t-1] == 'D': # If opponent defected last turn, defect this turn
                action = 'D'
            total_contributions += (1 if action == 'C' else 0) # Update total contributions for current round payoff calculation

        payoff_this_round = (1 - action) + (k/n) * total_contributions # Calculate payoff for this round
        history.append(action) # Append current action to history
        history = history[-r:] if len(history) > r else history # Keep only the latest 'r' actions in history

    return sum(payoff_this_round for t in range(1, r+1)) # Calculate total payoff over all rounds
```
'''

description_COLLECTIVE_338 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This sets a cooperative tone and is less vulnerable to being exploited.
   - For subsequent rounds t > 1:
      - If opponent cooperated in the previous round (t-1), cooperate (C). This rewards cooperation and encourages long-term partnerships.
      - If opponent defected in the previous round (t-1), defect (D). This punishes defection, but also leaves room for reconciliation if the opponent switches to cooperation in the next round.

2. Handle edge cases:
   - Last round: Cooperate (C) regardless of the opponent's action in the previous round. The goal is to maximize payoff in the final round.
   - Initial rounds before reaching a stable cooperation pattern: Mimic other players' actions (i.e., cooperate if most players cooperate, defect otherwise). This gives TFT-AC some adaptability during the early stages of the game.

3. Be collective:
   - TFT-AC aims to foster cooperation and reciprocity among players, promoting a collective mindset by encouraging sustained cooperation when possible and punishing defection when necessary.
   - By adapting to the current state of the game and considering history, TFT-AC strives to align with the emerging cooperative dynamics, contributing to a more collective outcome.

Pseudocode:

```python
def tft_ac(round, history, n, k):
  if round == 1:
    action = 'C' # Cooperate in the first round
  elif round < r and not stable_cooperation_pattern(history):
    actions = [0] * n # Mimic others' actions before reaching a stable pattern
    cooperators = count_cooperators(actions, history)
    if cooperators > (n - cooperators):
      action = 'C' # Cooperate if most players are cooperating
    else:
      action = 'D' # Defect otherwise
  elif round == r:
    action = 'C' # Cooperate in the last round
  else:
    previous_round = history[-1]
    if previous_round[player_index] == 'C':
      action = 'C' # Cooperate if opponent cooperated in the previous round
    else:
      action = 'D' # Defect if opponent defected in the previous round

  payoff = calculate_payoff(action, history)
  return action, payoff
```

In this pseudocode, `player_index` refers to the index of the strategy in play. The function `calculate_payoff` calculates the payoff as described in the game specifications, and `stable_cooperation_pattern(history)` determines if a stable cooperation pattern has been reached based on a predefined threshold (e.g., 3 consecutive rounds of cooperation).
'''

description_COLLECTIVE_339 = '''
 For this N-Player Public Goods Game, I propose a strategy named Tit-for-Tat with Cooperative Adjustment (TTFC). The strategy is designed to foster cooperation while maintaining robustness against various opponent behaviors.

1. Specify decision rules:
   - Initialize: Start by cooperating in the first round (C_i, 1 = 1)
   - Tit-for-Tat: In subsequent rounds, if a player i played C in the previous round and all players also cooperated (total_contributions > n/2), then the player will continue to cooperate (C_i, t = 1). If any player defected or fewer than half of the players contributed in the previous round, the player will defect (C_i, t = 0).
   - Cooperative Adjustment: Periodically adjust the level of cooperation based on the overall game performance. If the average number of cooperators over a certain number of past rounds exceeds a threshold (e.g., n/2), increase the likelihood of cooperating in future rounds by lowering the required percentage of cooperators from total_contributions > n/2 to total_contributions > (n/2) - Δ, where Δ is a predefined adjustment factor. If the average number of cooperators falls below the threshold, increase the likelihood of defection by raising the required percentage of cooperators from total_contributions > n/2 to total_contributions > (n/2) + Δ.

2. Handle edge cases:
   - First round: Cooperate (C_i, 1 = 1)
   - Last round: Evaluate the current state of cooperation and apply the cooperative adjustment as necessary based on the average number of cooperators over the past rounds. If the adjusted threshold requires cooperation, cooperate (C_i, r = 1). Otherwise, defect (C_i, r = 0)
   - Other edge cases: The TTFC strategy handles other edge cases, such as mid-game adjustments and ongoing adjustments, through its iterative decision rules.

3. Be collective:
   - Aligning with the collective mindset is inherent in the Tit-for-Tat aspect of the strategy, which encourages cooperation when others cooperate and defects when others defect. The adaptive nature of the cooperative adjustment ensures that the strategy remains aligned with the collective performance over time.
   - Additionally, by fostering cooperation, the TTFC strategy can help maximize the total payoff for all players in the long run. This collective focus is reflected in the strategy's aim to encourage and maintain a high level of cooperation among the players.

Pseudocode for Tit-for-Tat with Cooperative Adjustment:

```
def TTFC(round, history, adjustment_factor, n, k):
    if round == 1:
        cooperate = True
    else:
        total_contributions = sum(history[-round:])
        if total_contributions > (n / 2) and cooperate:
            cooperate = True
        elif total_contributions <= (n / 2) or not cooperate:
            cooperate = False

    if round == len(history):
        adjust_cooperation(cooperate, history, n, adjustment_factor)

    payoff = (1 - cooperate) + (k / n) * total_contributions
    return payoff, cooperate

def adjust_cooperation(cooperate, history, n, adjustment_factor):
    if len(history) > adjustment_window:
        avg_coop = sum([1 for i in range(len(history)-adjustment_window) if history[i] == 1]) / adjustment_window
        if avg_coop > (n / 2):
            cooperate_threshold = (n / 2) - adjustment_factor
        else:
            cooperate_threshold = (n / 2) + adjustment_factor
        if cooperate and cooperate_threshold <= total_contributions or not cooperate and cooperate_threshold > total_contributions:
            cooperate = not cooperate
```

This strategy encourages cooperation among players, adapts to various opponent behaviors, and maximizes the collective payoff in the long run while maintaining robustness against a wide range of strategies.
'''

description_COLLECTIVE_340 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the initial round (t=1), cooperate to establish a cooperative environment and signal good intentions.
   - For subsequent rounds, mimic the most frequent action of the opponent in the recent history (last 3-5 rounds). If the opponent has cooperated more than defected in this window, cooperate; otherwise, defect. This rule encourages reciprocity while allowing flexibility to respond to changes in the opponent's behavior.
   - If an opponent plays exclusively D for a certain number of rounds (e.g., 5), switch to a strategy of always defecting as well, to avoid repeatedly investing in a non-cooperative opponent. This adaptive mechanism helps minimize losses when facing uncooperative opponents.

2. Handle Edge Cases:
   - First Round (t=1): Cooperate to establish goodwill and set the initial tone for reciprocity.
   - Last Round (t=r): Cooperate if the opponent has cooperated more in recent history, or defect if the opponent has not. This decision ensures that TFTAC does not over-invest in a potentially uncooperative last round.

3. Be Collective:
   - Align with collective mindset by following the majority rule in recent history. This approach encourages cooperation when it is beneficial for the majority and adapts to the current game environment, promoting collective success.

Pseudocode:

```
function TFTAC(n, r, k):
  // Initialize history with initial cooperation (cooperate in round 1)
  history = [C]

  for t in range (2, r+1):
    if opponent_history[t-3:t] majority contains C:
      action = C
    else:
      action = D
    history.append(action)

  // Handle edge cases for last round and non-cooperative opponents
  if t == r or opponent_non_cooperative_count > threshold:
    action = D

  return action
```
'''

description_COLLECTIVE_341 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - TFTA begins by cooperating in the first round to foster a positive relationship with other players.
   - In subsequent rounds, TFTA will mimic the action of its opponent from the previous round. If an opponent cooperated, TFTA will also cooperate; if an opponent defected, TFTA will also defect. This rule encourages reciprocity and reduces the risk of being exploited.
   - To adapt to changing strategies or opponents' behavior, TFTA will periodically reassess its overall payoff in comparison to a predefined benchmark (e.g., average payoff). If the payoff drops below the benchmark for a defined number of rounds, TFTA will increase the frequency of cooperation to encourage others to cooperate as well.
   - To avoid overcompensating or being trapped in a long streak of cooperation that may not be reciprocated, TFTA includes a "forgiveness" mechanism: after a sequence of successful cooperation, TFTA will temporarily defect if its opponent does so. This prevents TFTA from being locked into indefinitely cooperative behavior when it is not rewarded.

2. Handle edge cases:
   - In the first round, TFTA cooperates to foster trust and encourage others to do the same.
   - In the last round, TFTA will analyze its overall payoff during the game. If its average payoff is above the predefined benchmark, TFTA will cooperate as a final act of goodwill; otherwise, it may defect to maximize its chances of earning a higher payoff in that round.
   - If TFTA encounters an opponent who consistently cooperates or defects, it will adjust its own behavior accordingly to maintain reciprocity and avoid being exploited.

3. Be collective:
   - TFTA's primary focus is on long-term cooperation with others, as demonstrated by its adaptive strategy that encourages reciprocal behavior.
   - By following the rules of Tit-for-Tat and incorporating an adaptive approach, TFTA aligns itself with a collective mindset while promoting fairness and mutual benefit among all players in the game.
'''

description_COLLECTIVE_342 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules:
   - In the initial round, cooperate (C). This is a gesture of goodwill and openness to cooperation.
   - For subsequent rounds t > 1, adopt the following rule: Cooperate if all players cooperated in the previous round, or if you cooperated and at least one player defected; otherwise, defect (D). In other words, imitate the behaviour of others, but also consider retaliation when necessary.

2. Handle edge cases:
   - Last Round: Cooperate regardless of past actions, to maximize potential payoff in that round.
   - First Round and Odd Behaviour: Since opponents may not follow the same cooperative etiquette, begin with cooperation as a sign of goodwill.

3. Be collective:
   - The strategy encourages cooperation when it is beneficial for all players (all cooperated in the previous round) and promotes retaliation against defection to discourage future selfish behaviour. This balance between cooperation and punishment aligns with a collective mindset, fostering long-term reciprocity and encouraging sustained cooperation among players.

Pseudocode:
```
function ATfT(n, k, r, round, past_actions):
    if round == 1:
        action = 'C' # Cooperate in the first round as a gesture of goodwill
    else:
        if all(past_actions[-1] == 'C'): # If everyone cooperated last round
            action = 'C'
        elif (past_actions[-1] == 'C' and any(past_actions[:-1] == 'D')) or (past_actions[-1] == 'D' and past_actions[-2] == 'C'): # If you cooperated last round, but at least one defected earlier
            action = 'C'
        else:
            action = 'D' # Otherwise, defect as a means of retaliation or to punish defection
    return action
```
'''

description_COLLECTIVE_343 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to start with a positive gesture and encourage others to reciprocate.
   - For subsequent rounds, if the opponent cooperated in the previous round, also cooperate to maintain the cooperation; otherwise, defect to punish non-cooperation.
   - Pseudocode:
       ```
       function ATfT(opponent_action_history, n, k):
           my_action = C (cooperate) if r = 1 else opponent_action[r-1]
           return my_action
       ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier.
   - In the last round, cooperate if the opponent has been cooperative throughout the game to end on a positive note; otherwise, defect to avoid wasting the remaining contribution.
   - When the number of rounds (r) is unknown or dynamic, the strategy should still follow the ATfT rule with the understanding that it may not reach a true equilibrium due to limited information about the game length.

3. Be collective - Clearly align with the collective mindset
   - By following the Tit-for-Tat strategy, the AI aims to foster cooperation and build trust within the group by reciprocating positive actions and punishing non-cooperative ones.
   - The strategy encourages a sense of fairness as it rewards cooperation and discourages defection, ultimately aligning with the collective mindset of seeking mutual benefits.
'''

description_COLLECTIVE_344 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TFTAC strategy initially cooperates in the first round, mimicking the spirit of cooperation among players. After that, it adapts its behavior based on other players' actions during the previous round. In any given round t:
   - If all players cooperated in round t-1, TFTAC cooperates (C).
   - If at least one player defected in round t-1, TFTAC defects (D) if it cooperated in round t-1, and copies the latest action of the player who defected in round t-1.

Pseudocode for decision rule:
```
function TFTAC(t):
  if t == 1:
    return C

  last_action = getLastAction()
  if allPlayersCooperatedInPreviousRound():
    return C
  else:
    if last_action == D and myLastAction != D:
      return D
    elif last_action == C:
      return myLastAction
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The TFTAC strategy maintains consistency throughout the game, as it does not have any special considerations for edge cases like the first or last rounds. It always cooperates initially and adapts its behavior based on other players' actions from the previous round.

3. Be collective - Clearly align with the collective mindset
   The TFTAC strategy encourages cooperation by starting off cooperatively and only defecting when others have already done so. This approach aims to foster an environment where mutual trust can be built over time, promoting long-term collective interests.
'''

description_COLLECTIVE_345 = '''
 Strategy Name: Adaptive Tit-for-Tat with Probability of Cooperation (ATFTP)

1. Decision Rules:
   - Initially (in the first round), cooperate to promote a positive initial environment and encourage cooperation from others.
     ```python
     if round == 1:
         action = 'C' # Cooperate
     ```
   - In subsequent rounds, adjust the probability of cooperation based on previous round's actions:
       - If all players cooperated in the previous round, maintain a high probability (p) of cooperation for the current round.
       - If some players did not cooperate in the previous round, lower the probability of cooperation for the current round to encourage reciprocation.
     ```python
     if all(previous_actions[i] == 'C' for i in range(n)):
         p = p_high
     else:
         p = p_low

     random_choice = rand()
     if random_choice < p:
         action = 'C' # Cooperate
     else:
         action = 'D' # Defect
     ```
   - Maintain a memory of previous actions to evaluate cooperation patterns over time.

2. Handle Edge Cases:
   - In the last round, cooperate regardless of past actions to maximize potential payoffs from the remaining rounds.
     ```python
     if round == r:
         action = 'C' # Cooperate in the last round
     ```

3. Be Collective:
   - By adjusting the probability of cooperation based on previous actions, this strategy seeks to promote a cooperative environment while also being adaptive to potential defection. The goal is to build trust and encourage reciprocation over time.
   - It does not rely on others sharing norms or predetermined patterns but rather responds dynamically to the actions of other players. This promotes a collective mindset by fostering cooperation when possible while also being prepared for defection when necessary.
'''

description_COLLECTIVE_346 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round (t=1), cooperate (C): ATFT starts by being cooperative to encourage cooperation among other players and build trust.
   - From round 2 to r-1, adaptive cooperation based on past actions of opponents (i_prev_cooperation):
     - If i_prev_cooperation = C, then cooperate (C).
     - If i_prev_cooperation = D, then defect (D) to retaliate against defection.
   - In the last round (t=r), cooperate (C): ATFT cooperates in the final round regardless of past actions to maximize total payoff.

2. Handle edge cases:
   - If the opponent does not cooperate at all (always plays D), ATFT will also defect throughout the game as a countermeasure.
   - If the opponent cooperates for some rounds but switches to defection later, ATFT will adapt its behavior and reciprocate accordingly.

3. Be collective:
   - ATFT encourages cooperation among players by starting with cooperation and rewarding those who reciprocate. It punishes those who defect by also defecting.
   - The aim is to foster a long-term cooperative environment where players realize the mutual benefits of contributing to the public good, despite being unable to communicate directly with each other.

Pseudocode:
```
function AdaptiveTitForTat(n, k, r):
  rounds = [1 for _ in range(r)] # Initialize round counter
  strategy = [] # Initialize empty strategy array

  def play_round(i, i_prev_cooperation):
    if rounds[0]: # First round
      return 'C'

    strategy[-1] = i_prev_cooperation # Store past action for future reference
    if i_prev_cooperation == 'C':
      return 'C'
    elif i_prev_cooperation == 'D':
      return 'D'

  # Main game loop
  for t in range(r):
    strategy.append(play_round(t, strategy[t-1]))
    rounds[0] -= 1 # Decrement round counter

  # Return strategy as a list of actions over the course of the game
  return strategy
```
'''

description_COLLECTIVE_347 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The ATFT strategy follows a cooperative approach initially, and responds to opponents' behavior adaptively. In each round t:
- If the opponent cooperated in the previous round (t-1), cooperate in this round (t).
- If the opponent defected in the previous round (t-1), also defect in this round (t). This is a punishment mechanism for those who do not cooperate.
- If it's the first round, cooperate to initiate cooperation.

Pseudocode:
```python
def ATFT(history):
  if len(history) < 2:
    return 'Cooperate'  # First round

  last_move = history[-1]  # Last move by the opponent
  if last_move == 'Cooperate':
    return 'Cooperate'
  else:
    return 'Defect'   # Punishment for defection in the previous round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The ATFT strategy does not have specific edge cases because it already accounts for the first round by initiating cooperation and handles subsequent rounds adaptively based on opponent's behavior. However, to avoid getting stuck in a long-term punishment loop with uncooperative opponents, the strategy can be modified to revert to cooperating after a certain number of defections, such as "forgiveness" after r/3 defections.

Pseudocode:
```python
def ATFT(history, forgiveness_threshold=r//3):
  if len(history) < 2:
    return 'Cooperate'  # First round

  last_move = history[-1]  # Last move by the opponent
  if last_move == 'Cooperate':
    return 'Cooperate'
  elif len(history) > forgiveness_threshold and history[-forgiveness_threshold:] == ['Defect'] * forgiveness_threshold:
    return 'Cooperate'  # Forgive after a certain number of defections
  else:
    return 'Defect'   # Punishment for defection in the previous round
```

3. Be collective - Clearly align with the collective mindset

ATFT aligns with a collective mindset by promoting cooperation whenever possible and only punishing those who do not cooperate. The strategy encourages long-term mutual benefit through reciprocal cooperation but also ensures that players are not disadvantaged due to uncooperative opponents.
'''

description_COLLECTIVE_348 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initial Cooperate (c_i=C in the first round): Start with a cooperative gesture to foster a cooperative environment.
   - Copy Last Round's Actions (CLRA): In subsequent rounds, copy the collective action of the previous round. If everyone cooperated, continue cooperation; if anyone defected, also defect in this round.
   - Gradual Forgiveness: After defecting, start cooperating again with a certain probability (p_forgive) per round. This probability can be adjusted based on the number of consecutive cooperative rounds seen in the game history.

2. Handle Edge Cases:
   - First Round: c_i=C
   - Last Round: CLRA (use the last observed action as a guide for the final decision)
   - Mid-Game: Use the ATFT strategy as described above

3. Collective Mindset:
   - The ATFT strategy is designed to promote cooperation and maintain trust within the group, even when faced with defection. It punishes defection but offers forgiveness over time to encourage rebuilding of cooperative relationships.

Pseudocode for Adaptive Tit-for-Tat (ATFT) Strategy:

```python
def ATFT(n, k, r, game_history):
    # Initialize variables
    i = player index
    total_contributions = 0
    consecutive_cooperation = 0
    p_forgive = (k/n) - 1

    # First round, cooperate
    if round == 1:
        action = "C"
        total_contributions += 1

    # Main game loop
    for t in range(2, r+1):
        # Calculate total contributions from previous round
        total_contributions = sum([game_history[t-1][j] for j in range(1, n+1)])

        # Determine action based on ATFT strategy
        if total_contributions == n:  # Everyone cooperated last round, continue cooperation
            action = "C"
            total_contributions += 1
        else:  # Someone defected last round, also defect this round
            action = "D"

        # Update forgiveness probability based on consecutive cooperative rounds
        if action == "C":
            consecutive_cooperation += 1
        else:
            consecutive_cooperation = 0

        # Decrease forgiveness probability after defecting, increase it after cooperating
        p_forgive = (k/n) - (consecutive_cooperation / t) if action == "D" else (p_forgive + (1 - p_forgive) * (consecutive_cooperation / t))

    # In the final round, use the last observed action as a guide for the decision
    if consecutive_cooperation > 0:
        action = "C" if random.random() <= p_forgive else "D"
    else:
        action = "D"

    return action
```
'''

description_COLLECTIVE_349 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Decision Rules:
   - Initiate with Cooperation (C): Start by cooperating to build trust and demonstrate goodwill.
   - Respond to Opponent's Previous Actions: In each subsequent round, the strategy will cooperate if the opponent cooperated in the previous round; otherwise, it will defect. This encourages opponents to reciprocate cooperation while penalizing defection.
   - Punish Long-term Defection: If an opponent continuously defects for a certain number of rounds (tunable parameter), TfTA will also start defecting to punish the opponent and encourage future cooperation.
   - Forgive Short-term Defections: To allow for mistakes and to foster long-term relationships, TfTA will forgive opponents who defect in isolated instances. Once an opponent starts cooperating again, TfTA will return to cooperating as well.

2. Handle Edge Cases:
   - First Round (t=1): Cooperate to set a positive tone for the game and demonstrate goodwill.
   - Last Round (t=r): If the game is at its final round and there's no opportunity for future interaction, TfTA will cooperate if the opponent has been cooperating in recent rounds; otherwise, it will defect. This encourages opponents to reciprocate cooperation in their last chance.
   - Intermediate Rounds: Use the decision rules described above to make decisions based on the game history.

3. Be Collective:
   - Align with collective mindset by fostering mutual cooperation, encouraging long-term relationships, and forgiving minor mistakes to promote a collaborative environment in the repeated game.
   - The adaptability of TfTA ensures that it can adapt to various opponent behaviors while still prioritizing cooperation when possible.

Pseudocode:
```python
def tit_for_tat_adaptive(round, history, parameter_k, parameter_n):
  if round == 1:
    action = "C" # Cooperate in the first round

  elif len(history) < tunable_parameter: # Forgive short-term defections
    action = history[-1] # Respond with the same action as the opponent in the last round

  else:
    if history[-tunable_parameter:-1].count("C") > (tunable_parameter * parameter_n / 2):
      action = "C" # Cooperate if the opponent has been cooperating recently
    else:
      action = "D" # Defect if the opponent has not been cooperating recently

return action
```
'''

description_COLLECTIVE_350 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round: Start by cooperating (C). This is a friendly gesture to encourage others to cooperate.
   - Subsequent Rounds: If the opponent cooperated in the previous round, reciprocate with cooperation (C); if not, defect (D) as punishment for defection, but switch back to cooperation in the next round after punishment. This encourages opponents to return to cooperation once they see a positive response.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) as stated above.
   - Last Round: Analyze opponent's behavior throughout the game and cooperate if it is beneficial based on the total payoff over the r rounds. If not, defect to maximize individual payoff in the final round.

3. Be collective - Clearly align with the collective mindset
   - Maintain a balance between self-interest and collective good by rewarding cooperation and punishing defection. This encourages others to cooperate while also considering personal payoffs.
   - Gradually adjust responses to opponents' behavior to foster long-term cooperation when it becomes advantageous.

Pseudocode:
```
initial_round = True
opponent_history = []

def decide_action(current_round, r):
  if current_round == 1:
    action = "C"  # Cooperate in the first round
    initial_round = False

  elif current_round < r and opponent_history[-1] == "D":
    action = "D"  # Punish defection with defection

  elif current_round < r and opponent_history[-1] == "C":
    action = "C"  # Reward cooperation with cooperation

  elif current_round >= r:
    if calculate_total_payoff() >= average_payoff:
      action = "C"  # Cooperate in the final round if total payoff is above average
    else:
      action = "D"  # Defect in the final round if total payoff is below average

opponent_action = opponent's action in this round
opponent_history.append(opponent_action)

if decision_round == current_round:
  decision_round += 1
```
'''

description_COLLECTIVE_351 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round: ATfT begins by cooperating, encouraging others to follow suit. This sets a cooperative tone and promotes trust.
   - In subsequent rounds, players will respond to other players' actions from the previous round. If another player has cooperated (c_j = 1), ATfT will also cooperate (c_i = 1). Otherwise, if another player has defected (c_j = 0), ATfT will defect as well (c_i = 0).
   - This decision rule encourages reciprocity and punishes defection in an adaptive manner.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, all players will cooperate as a show of goodwill and to promote trust.
   - In the last round, if ATfT has cooperated throughout the game, it will continue to cooperate. If it has defected in some rounds, it will consider the total number of cooperators in the game so far (total_contributions) and compare it with the minimum number of cooperators required for a successful public good project (min_cooperators = n \* (k - 1)/k). If the current total_contributions >= min_cooperators, ATfT will cooperate in the last round to help reach the threshold for a successful public good project. Otherwise, it will defect.
   - For other edge cases such as odd or even rounds, there is no specific action required as the strategy already focuses on responding to other players' actions from the previous round.

3. Be collective - Clearly align with the collective mindset
   - ATfT encourages cooperation and reciprocity, which are essential for collective success in the public goods game. By adapting its own actions based on others' behavior, it contributes to a more cooperative environment that benefits everyone.
   - The strategy is robust since it responds flexibly to a wide range of opponent behaviors while promoting cooperation and collective success over time.

Pseudocode:

```python
def AdaptiveTitForTat(i, r, n, k):
    rounds = set()  # store the rounds for edge cases
    cooperation_history = [0] * n  # track other players' cooperative history
    contribution = 0  # initial contribution (default to defect)

    def play_round(t):
        if t == 1:  # first round, cooperate
            contribution = 1
        else:  # subsequent rounds, respond to the previous round
            total_contributions = sum(cooperation_history)
            if contribution == 1 and total_contributions > (n * (k - 1)) / k:
                # in last round, help achieve a successful public good project
                contribution = 1
            else:
                contribution = cooperation_history[i - 1]
            payoff = (1 - contribution) + (k / n) * total_contributions
            rounds.add(t)
            return payoff, contribution, total_contributions

    for t in range(1, r + 1):
        payoff, contribution, total_contributions = play_round(t)
        cooperation_history[i] = contribution  # update the cooperative history of other players
```
'''

description_COLLECTIVE_352 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TfTA starts by cooperating (C). If a player's previous opponent cooperated in the last round, they will continue cooperating. Otherwise, if the opponent defected last round, they will also defect this round. The strategy aims to be forgiving (cooperate initially) and retaliatory (defect if opponent defected).

   Pseudocode:
   ```
   function TfTA(history):
       if history is empty:
           return Cooperate (C)
       else:
           last_round = history[-1]
           if last_round == Cooperate:
               return Cooperate (C)
           else:
               return Defect (D)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since TfTA is a history-based strategy, it does not have a specific behavior for edge cases like the first or last round. However, by definition, the first round's history will be empty, causing TfTA to cooperate as its initial move. The last round's history will include all previous interactions, so TfTA will continue adapting based on that information.

3. Be collective - Clearly align with the collective mindset
   By starting with cooperation, TfTA encourages others to cooperate as well and fosters a sense of trust. If other strategies reciprocate cooperation, TfTA will continue to cooperate, building a more collaborative environment. The adaptive nature of TfTA allows it to be responsive to the collective behavior demonstrated by its opponents.
'''

description_COLLECTIVE_353 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C). This is to show good faith and encourage cooperation from others.
   - In subsequent rounds, mimic the behavior of other players from the previous round: If a player cooperated (c_i=1), cooperate as well (C); if a player defected (c_i=0), also defect (D). This tit-for-tat approach encourages reciprocity while being forgiving of initial mistakes or defects.
   - If the total number of cooperators in a round falls below a threshold (t), defined as t = ⌊(n+1)/2⌋, revert to initial cooperation for the next r/2 rounds to give others another chance to cooperate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) as mentioned above.
   - In the last round, since there are no future interactions, mimic the behavior of other players from the previous round to maximize short-term payoffs.
   - When the game restarts or after a significant drop in cooperation levels, revert to initial cooperation for the next r/2 rounds to encourage cooperation.

3. Be collective - Clearly align with the collective mindset
   - By adhering to the tit-for-tat approach, TFT-AC aims to create a self-enforcing cooperative equilibrium where players maintain mutual cooperation as long as others reciprocate their actions.
   - The adaptive element allows for robustness against various opponent behaviors and encourages cooperation even when it seems unlikely or impossible.

Pseudocode:
```python
def TFT_AC(n, k, r, t):
    players = {i for i in range(1, n+1)}
    history = {}  # Stores previous rounds' cooperation levels and player actions

    def play_round():
        total_contributions = 0
        for player in players:
            if player not in history or history[player] not in {1, 0}:
                history[player] = 1  # Initial cooperation
            elif history[player] == t:  # If more than half of the players are cooperating, revert to initial cooperation for r/2 rounds
                history[player] = 1
                total_contributions += t
                break
            else:
                history[player] = history[player] ^ 1  # Switch between C and D based on previous round's action
                total_contributions += history[player]
        payoffs = calculate_payoffs(n, k, total_contributions)
        return payoffs

    def calculate_payoffs(n, k, total_contributions):
        payoffs = {}
        for player in players:
            payoffs[player] = (1 - history[player]) + (k/n) * total_contributions
        return payoffs

    for round in range(r):
        payoffs = play_round()
        # Update the strategy based on current game state, if needed
```
'''

description_COLLECTIVE_354 = '''
 Title: Tit-for-Tat Cooperation Strategy (TFTC) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Start by cooperating (C). This sets a peaceful tone and allows the opportunity to build trust with other players.
   - Subsequent Rounds (t>1):
     - If all opponents cooperated in the previous round, cooperate again (C). This continues the positive cycle of cooperation established.
     - If any opponent defected in the previous round, also defect (D) as a punishment. This discourages defection and punishes uncooperative behavior.
   Pseudocode:
   ```
   function TFTC(t, opponents_actions[t-1]) {
       if t == 1 then return 'C'
       if all(opponents_actions[t-1] == 'C') then return 'C'
       else return 'D'
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The strategy remains consistent throughout the game, with no special consideration for specific rounds. The initial cooperative move sets the stage for subsequent rounds and the punishment mechanism applies equally to each round.

3. Be collective - Clearly align with the collective mindset
   TFTC seeks to promote a collective mindset by rewarding cooperation and punishing defection. This encourages other players to consider the common good, as their actions will affect the payoffs of others in subsequent rounds. By doing so, the strategy hopes to create an environment where mutual benefits can be achieved through cooperation.
'''

description_COLLECTIVE_355 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Decision Rules:
   - Initiate cooperation (play C) in the first round to contribute positively to the public good and signal goodwill towards other players.
   - In subsequent rounds, cooperate if all players cooperated in the previous round (rewarding past cooperation).
   - If any player defected in the previous round, defect yourself in the current round (punish defection).
   - Maintain this pattern of cooperation and punishment for the entire game.

Pseudocode:
```
function ATfT(round, history):
  if round = 1:
    return Cooperate()

  previous_round = history[-1]
  if all(players in previous_round cooperated):
    return Cooperate()
  else:
    return Defect()
```

2. Handle Edge Cases:
   - In the last round, since there are no future interactions with the same players, adopt a more forgiving approach by cooperating with all players regardless of their past actions:
     ```
     if round = r:
       return Cooperate()
     else:
       return ATfT(round)
     ```
   - In the first round, since there is no history to refer to, every player will assume goodwill and initiate cooperation.

3. Be Collective:
   - This strategy aligns with a collective mindset by promoting fairness, trust, and reciprocity among players. It encourages cooperative behavior when others are cooperating and deters defection in response to past defection. This approach seeks to establish and maintain long-term cooperation while being robust to different opponent behaviors.
   - Furthermore, the ATfT strategy is designed to be flexible enough for various game settings by adjusting the multiplication factor 'k' based on the number of players (n) in the game. A higher value of k encourages cooperative behavior and incentivizes more contributions to the public good, while a lower value of k favors defection and promotes individualism over collective interests.
'''

description_COLLECTIVE_356 = '''
 Title: Tit-for-Tat Adaptive Cooperation Strategy (TFT-AC) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In each round t, if the previous round's contribution level (C_t-1) was high (i.e., majority of players contributed), then cooperate (C). Otherwise, defect (D).
   - Pseudocode:
     ```
     function TFT_AC(history):
         previousContributionLevel = sum(history[-r+1:-1]) / r  # Average contribution level in the past rounds
         if previousContributionLevel >= (n-1) / 2:  # Majority contributed last round
             return 'C'  # Cooperate
         else:
             return 'D'  # Defect
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, there is no history, so the strategy will randomly choose to cooperate or defect with equal probability (0.5).
   - In the last round, follow the decision rule based on the history up to that point.
   - Pseudocode:
     ```
     function TFT_AC(history):
         if len(history) == 1:  # First round
             return 'C' with probability 0.5  # Randomly choose to cooperate or defect
         elif len(history) == r+1:  # Last round
             return TFT_AC(history[-r:])  # Use the decision rule based on the last r rounds
         else:  # Other rounds
             ...  # as before
     ```

3. Be collective - Clearly align with the collective mindset
   - The strategy promotes cooperation if a majority of players contribute in the previous round, reflecting a desire for mutual benefit and long-term success.
   - However, it also allows for occasional defection to punish free riders or respond to a lack of reciprocity from others. This ensures robustness against various opponent behaviours.
'''

description_COLLECTIVE_357 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C). This sets a friendly tone and allows for possible mutual cooperation in future rounds.
   - Subsequent Rounds (t>1):
     - If the opponent cooperated in the previous round: Cooperate (C) to encourage reciprocity.
     - If the opponent defected in the previous round: Defect (D) as a punitive measure, signaling disapproval of their previous action.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round (t=1): Cooperate as per the decision rule above.
   - Last Round (t=r): Since future interactions are not possible, cooperate if the opponent cooperated in the previous round and defect otherwise. This ensures that any potential benefit from cooperation is maximized while still punishing defection in the last round.
   - Penultimate Round (t=r-1): If the opponent cooperated in the previous round, cooperate; if not, behave as in the last round. This allows for a final opportunity to encourage reciprocity or enforce punishment before the end of the game.

3. Be collective - Clearly align with the collective mindset:
   - TFT-A focuses on fostering trust and reciprocity within the group by cooperating when others do so and punishing defection. By doing so, it encourages cooperation among the players and contributes to the well-being of the community project.
   - The strategy is adaptive and robust to a wide range of opponent behaviors since it punishes repeated defection while being lenient with occasional defections (as long as they are not too frequent). This promotes collaboration and collective success, making TFT-A an effective strategy for this N-Player Public Goods Game.

Pseudocode:
```python
def TFT_A(opponent_history, n, k, r):
  current_round = 1
  own_history = []
  while current_round <= r:
    if current_round == 1: # First round
      action = 'C'
    elif current_round < r and opponent_history[-1] == 'C': # Subsequent rounds, opponent cooperated in previous round
      action = 'C'
    elif current_round < r and opponent_history[-1] == 'D': # Subsequent rounds, opponent defected in previous round
      action = 'D'
    elif current_round == r: # Last round
      if opponent_history[-2] == 'C': # Cooperate if opponent cooperated in penultimate round
        action = 'C'
      else: # Defect if opponent defected in penultimate round or if it is the first time defection occurs
        action = 'D'
    own_history.append(action) # Update own history
    current_round += 1
  return own_history
```
'''

description_COLLECTIVE_358 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Grace Period and Gradual Escalation (GPGE)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the ATFT strategy follows these steps:

a. First Round (t=1): Cooperate (C), initiating a gesture of goodwill and trust towards other players. This is known as the "grace period."

b. Subsequent Rounds (2 ≤ t ≤ r):
   i. Observe actions of others in previous round (t-1). If all opponents cooperated, continue cooperating (C).
   ii. If at least one opponent defected in the last round, defect (D) this round.

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the sake of continuity and to avoid punishment as a result of the grace period, we introduce a gradual escalation mechanism:
   a. In the penultimate round (r-1), defect if any opponent defected in the previous round; otherwise, cooperate.
   b. In the last round (r), always cooperate to maximize potential payoff since no further interactions will occur.

3. Be collective - Clearly align with the collective mindset

ATFT with GPGE is designed to foster cooperation and promote a collective mindset by initially showing goodwill, retaliating minimally when others defect, and gradually easing back into cooperative behavior if opponents return to cooperation in subsequent rounds. The strategy allows for adaptability and robustness against various opponent behaviors while encouraging long-term cooperation.

Pseudocode:
```
function ATFT_GPGE(n, k, r, t) {
  if (t == 1) { // First round
    return 'C'; // Cooperate
  }
  previousRoundActions = getPreviousRoundActions();

  if (allPlayersCooperatedInPreviousRound(previousRoundActions)) {
    return 'C'; // Continue cooperating
  } else {
    return defectOrCooperateBasedOnLastRoundAction(previousRoundActions);
  }
}

function allPlayersCooperatedInPreviousRound(actions) {
  for each action in actions {
    if (action != 'C') {
      return false; // If one player didn't cooperate, return false
    }
  }
  return true; // All players cooperated
}

function defectOrCooperateBasedOnLastRoundAction(previousRoundActions) {
  if (anyPlayerDefectedInPreviousRound(previousRoundActions)) {
    return 'D'; // Defect in response to previous round defection
  } else {
    return 'C'; // Cooperate since no defects were observed
  }
}

function anyPlayerDefectedInPreviousRound(actions) {
  for each action in actions {
    if (action == 'D') {
      return true; // If one player defected, return true
    }
  }
  return false; // No players defected
}
```
'''

description_COLLECTIVE_359 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In the first round, cooperate (C). This allows for a potential cooperation to start and sets a friendly tone.
   - For subsequent rounds t ≥ 2, if in the previous round, the majority of players cooperated (more than n/2), then cooperate (C). If less than n/2 players cooperated, then defect (D). This rule encourages cooperation when it's beneficial for the group and punishes defection.
   - To minimize the risk of being exploited by free riders, after an act of defection, wait for t_wait rounds before returning to cooperate. The value of t_wait can be adjusted based on the game parameters (n, k, r) and can be set as a constant or dynamic value.

2. Handle edge cases:
   - In the last round, if the strategy's total contributions are less than n/2, then cooperate to maximize individual payoff in that round. If total contributions exceed n/2, defect because there will be no further rounds to punish free riders.
   - In the first round, since there is no previous information, the strategy should cooperate based on the assumption of a friendly environment or to create one.

3. Be collective:
   - The ATFT strategy encourages cooperation when it benefits the group as a whole, while also punishing defection to maintain a fair distribution of resources. This promotes a collectively-minded approach, as players contribute to the common good when others do so as well.

Pseudocode:
```
function ATFT(n, k, r, t_wait) {
  total_contributions = 0
  contributions_history = []
  round = 1

  while (round <= r) {
    if (round == 1) {
      cooperate = true
    } else {
      if (total_contributions > n/2) {
        cooperate = true
      } else {
        cooperate = false
      }
    }

    if (cooperate) {
      contributions_history.add(1)
      total_contributions++
    } else {
      contributions_history.add(0)
    }

    payoff = (1 - cooperate) + (k/n) * sum(contributions_history)
    print("Round", round, ": Payoff = ", payoff)

    if (!cooperate && round > t_wait) {
      cooperate = true
    }

    round++
  }
}
```
'''

description_COLLECTIVE_360 = '''
 Title: Tit-for-Tat Cooperation Strategy (TFTC) for N-Player Public Goods Game

1. Specify decision rules:
   - Cooperate on the first round (initiation of cooperation).
   - In subsequent rounds, cooperate if all opponents cooperated in the previous round; defect otherwise. This approach encourages sustained cooperation while being adaptive to opponent behavior.

2. Handle edge cases:
   - In the last round, cooperate since there are no future consequences and it may foster goodwill for future interactions.
   - In the first round, cooperate as per the strategy's initiation rule.

3. Be collective:
   - By mirroring the behavior of other players in each round, TFTC aligns with a collective mindset as it follows a pattern of reciprocity and mutual cooperation if sustained by opponents.

Pseudocode for Tit-for-Tat Cooperation Strategy (TFTC):

```python
def TFTC(opponent_history, r, n, k):
    # Initialize player strategy
    strategy = {'cooperate': True}

    # Cooperate on the first round
    if len(opponent_history) == 0:
        strategy['cooperate'] = True

    # Update strategy based on opponent history
    for round in range(1, r):
        current_round = len(opponent_history)
        all_cooperated_last_round = True if all(opponent_history[-1][i] == 1 for i in range(n)) else False

        # Adapt strategy based on the previous round's actions
        strategy['cooperate'] = all_cooperated_last_round

    return strategy
```

In this pseudocode, `opponent_history` is a list containing each opponent's action (0 for defect and 1 for cooperate) from previous rounds. The function returns the current round's cooperation decision as per the Tit-for-Tat Cooperation Strategy.
'''

description_COLLECTIVE_361 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This sets a friendly tone and gives opponents the opportunity to also cooperate.
   - After the first round, observe the actions of each opponent from the previous round. If they cooperated, cooperate in the current round. If they defected, defect in the current round.
   - If an opponent has not played yet (new player), cooperate (C).
   - To adapt to opponents' behavior, maintain a history of their past actions. If an opponent consistently cooperates, continue cooperating. If an opponent consistently defects, begin defecting as well. However, if the opponent occasionally deviates from their pattern but still cooperates more than they defect, revert back to cooperating with them.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C).
   - In the last round, analyze the opponent's history and make a decision based on the above rules.
   - If a player drops out during the game, treat them as a new player upon their return and cooperate (C) with them in the following rounds.

3. Be collective - Clearly align with the collective mindset
   - By starting with cooperation and adapting to opponents' behavior, this strategy fosters a more collaborative environment where cooperation is encouraged but not enforced. The TFT-A approach aims to find a balance between individual self-interest and group success.

Pseudocode:
```
function TFT_A(n, r, k, history, opponent):
  if round = 1:
    action = "C" (Cooperate)
  else:
    if opponent in history and opponent's last action was "D":
      action = "D" (Defect)
    elif opponent in history and opponent's last action was "C":
      action = "C" (Cooperate)
    elif opponent not in history or opponent has a cooperative tendency:
      action = "C" (Cooperate)
  update history with current round's action by opponent

function TFT_A_Tournament(opponents, r, n, k):
  initialize history as empty for all opponents
  for each round in r:
    for each opponent:
      determine action using TFT_A function
      take action against opponent
  calculate total payoff over rounds
```
'''

description_COLLECTIVE_362 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the initial round (t=1), cooperate to show goodwill and encourage cooperation from others.
   - For subsequent rounds, mimic the actions of the most common action taken by all players in the previous r-1 rounds (except the first round). If multiple most common actions exist, choose the one that maximizes individual payoff for the current round based on the payoff matrix.
     ```
     if round > 1:
         most_common_action = most_frequent_action_in_history(r-1)
         if there_is_tie(most_common_action):
             payoffs = calculate_payoffs_for_tied_actions()
             chosen_action = choose_action_with_highest_payoff(payoffs)
     else:
         chosen_action = COOPERATE  # Initial round strategy is to cooperate
     ```

2. Handle Edge Cases:
   - In the last round (t=r), since there are no future interactions, always defect to maximize individual payoff in that single round.
   ```
   if round == r:
       chosen_action = DEFECT  # Last round strategy is to defect
   ```

3. Be Collective:
   - The TFTAC strategy aims to build and maintain cooperation among players by adapting to their actions while keeping the possibility of punishment for defection in later rounds. This fosters a collective mindset where cooperation can persist even without predetermined coordination mechanisms or shared norms.
'''

description_COLLECTIVE_363 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFTAC strategy follows the classic Tit-for-Tat strategy in repeated prisoner's dilemma games, but with an additional adaptability to contribute more or less based on the group's overall cooperation level.

- If the current round is the first one (Round 1), cooperate: C
- For subsequent rounds, evaluate the average cooperation level (ACL) over the last 'm' rounds and adjust contributions accordingly:
  - If ACL >= threshold (default 0.6), cooperate: C
  - Else, defect: D

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round, cooperate as a goodwill gesture (C)
- In the last round, evaluate the average cooperation level and contribute accordingly

3. Be collective - Clearly align with the collective mindset

The TFTAC strategy is designed to encourage cooperation by adapting contributions based on the group's overall cooperation level while maintaining fairness and forgiveness for occasional defections. The strategy aims to foster a collective mindset where players recognize the importance of mutual cooperation and learn to adjust their contributions accordingly over time.

Pseudocode:
```python
def tftac(n, r, k, m):
    rounds = [0] * r  # record past rounds
    avg_cooperation = 0.0  # average cooperation level over the last 'm' rounds

    def contribute(round_number):
        if round_number == 1:  # cooperate in the first round
            return True, 1.0
        else:
            total_contributions = sum(rounds[max(0, round_number - m):round_number])
            avg_cooperation = total_contributions / m if m < round_number else avg_cooperation

            if avg_cooperation >= 0.6:  # adjust contribution level based on ACL
                return True, avg_cooperation * k / n
            else:
                return False, 1.0 - avg_cooperation

    for i in range(r):
        cooperate, contribution = contribute(i+1)
        rounds[i] += contribution
        payoff = (1 - contribution) + (k / n) * sum(rounds)
        print("Round", i+1, ", Payoff:", payoff)
```
'''

description_COLLECTIVE_364 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C). This sets a cooperative tone and avoids being exploited by defectors.
   - For subsequent rounds, evaluate the opponent's cooperation history (CH) and respond accordingly:
     1. If CH[t] == C, then cooperate (C). Reward cooperators with continued cooperation and encourage them to do the same.
     2. If CH[t] == D, then defect (D). Punish defectors for previous defection and encourage a shift towards cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as stated above (C).
   - In the last round, cooperate if the opponent has been cooperative throughout the game (CH == [C, C, ..., C]) or if the opponent has a positive net contribution (total contributions > total defections) throughout the game. This allows for potential reconciliation and encourages cooperation even when time is running out.
   - In all other rounds, evaluate cooperation history as described above.

3. Be collective - Clearly align with the collective mindset:
   - Prioritize community projects by contributing to them when cooperating, maximizing the overall public good production.
   - Encourage cooperative behavior in opponents through reciprocity, rewarding cooperators and punishing defectors.

Pseudocode for TFT-AG strategy:

```
def TFT_AG(n, r, k, CH):
  history = [None] * r    # Initialize cooperation history

  def play_round(t):
    if t == 1:                # First round: initiate cooperation
      contribution = C
    else:                     # Evaluate cooperation history and play action
      contribution = CH[t-1]   # Use previous action as default
      if contribution == D and len(history) > 1 and sum(history) - len(history) >= n//2:
        contribution = C       # If opponent has been mostly defective, cooperate in last chance
    history.append(contribution)   # Update cooperation history for next round
    payoff = calculate_payoff(n, k, contribution, sum(history))  # Calculate payoff based on game parameters and action
    return payoff

def TFT_AG_game(r):
  total_payoff = 0           # Initialize total payoff for the game
  for t in range(1, r+1):    # Play multiple rounds (r)
    payoff = play_round(t)   # Calculate payoff for current round
    total_payoff += payoff   # Add payoff to total payoff for the game
  return total_payoff       # Return total payoff for the game
```
'''

description_COLLECTIVE_365 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initiation: In the first round, cooperate to demonstrate goodwill and trustworthiness (C).
   - Response: For subsequent rounds, mimic the previous round's collective action of other players (Cooperate if majority cooperated last round; Defect if majority defected last round).
   - Forgiveness: If a player deviates from cooperation, return to cooperating in the next round.

2. Handling Edge Cases:
   - Last Round: Cooperate regardless of past actions as the game ends after this round.
   - First Round (initiation): Cooperate as mentioned above.

3. Collective Mindset:
   - Promotes cooperation by demonstrating a willingness to cooperate initially and retaliate only when necessary, encouraging others to reciprocate cooperation.

Pseudocode:
```
Function ATFT(n, r, k):
  initial_cooperation = True  # initialize with cooperation in first round
  player_history = []  # store past actions of all players

  for round in range(1, r+1):
    if initial_cooperation:  # first round
      player_action = C  # cooperate
      initial_cooperation = False  # no need to cooperate again in this round
    else:
      total_cooperation = count_cooperators(player_history)

      if total_cooperation > (n/2):  # majority cooperated last round
        player_action = C  # cooperate
      else:
        player_action = D  # defect

    perform_action(player_action)  # take action in the current round
    add_to_history(player_action, player_index)  # update player history

Function count_cooperators(history):
  total_cooperation = 0
  for player in history:
    if player.action == C:
      total_cooperation += 1
  return total_cooperation

Function add_to_history(player_action, player_index):
  if not history:
    history.append({'actions': [player_action], 'players': [player_index]})
  else:
    for i in range(len(history)):
      if history[i]['players'][0] == player_index:
        history[i]['actions'].append(player_action)
        break
```
This strategy aims to balance cooperation and retaliation, making it adaptive and robust to various opponent behaviours while maintaining a collective mindset that encourages cooperation among players.
'''

description_COLLECTIVE_366 = '''
 In this N-Player Public Goods Game, I propose a strategy called "Adaptive Tit-for-Tat" (ATFT). This strategy aims to balance cooperation and defection while being adaptive to various opponent behaviors.

1. Decision Rules:
   - In the first round, cooperate (C) to signal goodwill and encourage other players to do the same.
   - After the first round, observe other players' actions and adopt the following decision rule:
     - If a player has cooperated in the previous round, cooperate back in the current round.
     - If a player has defected in the previous round, defect in the current round as retaliation but return to cooperating if they switch to cooperation in the next round.
   - This rule encourages long-term cooperation while punishing defection and rewarding cooperation.

2. Handling Edge Cases:
   - In the last round, since there is no subsequent round for retaliation or forgiveness, cooperate if the opponent has cooperated in the previous round, and defect otherwise.
   - In the first round, as mentioned earlier, cooperate regardless of other players' actions to initiate cooperation.
   - If an opponent never cooperates, continue defecting to avoid being exploited by the non-cooperative behavior.

3. Collective Mindset:
   - The ATFT strategy encourages collective cooperation by rewarding and retaining cooperative behaviors. It punishes defection but allows for forgiveness, promoting a long-term cooperative environment among players.

Pseudocode:
```python
def ATFT_Strategy(round, own_action_history, opponent_action_history):
    if round == 1:
        action = 'C'  # Cooperate in the first round to initiate cooperation
    elif len(opponent_action_history) > 0:
        last_opponent_action = opponent_action_history[-1]
        if last_opponent_action == 'C':
            action = 'C'  # Cooperate if the opponent cooperated in the previous round
        elif len(own_action_history) > 0 and own_action_history[-1] != 'C':
            action = 'D'  # Defect as retaliation if the opponent defected in the previous round
    return action
```
'''

description_COLLECTIVE_367 = '''
 Title: Adaptive Tit-for-Tat Strategy (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C): ATFT starts with a positive gesture, assuming others may also cooperate. This could encourage cooperation in future rounds. Pseudocode: `if round == 1 then cooperate`
   - For subsequent rounds, cooperate if the total number of cooperators in the previous round is greater than or equal to a threshold (T). If not, defect. Pseudocode:
     ```
     function ATFT(round, total_cooperators_prev):
        if round == 1 then
            return 'C'
        else
            if total_cooperators_prev >= T then
                return 'C'
            else
                return 'D'
     ```
   - The threshold (T) can be a function of the number of players (n), the multiplication factor (k), and the rounds played (r). A possible choice for T is T = (n * k) / r, ensuring that at least a minimum level of cooperation is maintained throughout the game.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate regardless of the total number of cooperators in the previous round. This encourages others to also cooperate for higher payoffs in that final round. Pseudocode: `if round == r then cooperate`

3. Be collective - Clearly align with the collective mindset
   - The ATFT strategy promotes cooperation among players while being adaptive and robust to a wide range of opponent behaviors. By responding tit-for-tat, ATFT encourages long-term mutual cooperation if others also adopt similar strategies. If others defect, ATFT will retaliate but may return to cooperation once the other players show signs of cooperating again. This strategy aligns with a collective mindset by trying to establish and maintain a cooperative equilibrium.

Remember that the actual implementation of this strategy will involve converting these natural language descriptions into an executable algorithm for your tournament participation. Good luck!
'''

description_COLLECTIVE_368 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C_i,1 = 1). This sets a positive tone and encourages reciprocity among opponents.
   - For subsequent rounds, adopt the Tit-for-Tat strategy: if opponent cooperated in the previous round (c_j,t-1 = 1), then cooperate (C_i,t = 1); otherwise defect (C_i,t = 0). This encourages cooperation and forgives occasional defections while being harsh on unremorseful free riders.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of opponents' actions (as mentioned above).
   - In the last round, cooperate if opponent cooperated in the previous round to maintain a positive relationship; otherwise defect as a final punishment for uncooperative behavior.
   - For other edge cases such as repeated subgames or specific rounds within the game, TfT+ can adapt by applying the same decision rule (i.e., cooperate if opponent cooperated in the previous round, defect otherwise) to those instances while considering overall performance within the game.

3. Be collective - Clearly align with the collective mindset
   - TfT+ encourages cooperation by reciprocating the actions of opponents and forgiving occasional defections. This collective mindset aims at fostering a cooperative environment among players, promoting the common good and maximizing the overall payoff for all participants over time.
   - To further emphasize this collective mindset, TfT+ can incorporate additional adaptive behaviors such as:
     - Gradual punishment: Instead of immediately defecting upon an opponent's defection, wait for a certain number of rounds before responding with defection (e.g., "three-strikes" rule). This gives opponents a chance to correct their behavior and encourages mutual understanding among players.
     - Forgiveness: After a period of cooperation, temporarily forgive opponents that defected previously by cooperating again (e.g., after a certain number of consecutive cooperative rounds). This fosters trust and encourages long-term cooperation.

Pseudocode for the Tit-for-Tat Plus strategy:

```
function TfTPlus(t, n, k, opponent_history):
  if t == 1:
    cooperate = True   # Cooperate in the first round
  else:
    cooperate = opponent_history[t - 1]  # Cooperate if opponent cooperated in the previous round; defect otherwise
  return cooperate
```
'''

description_COLLECTIVE_369 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Forgiveness

1. Specify decision rules:
   - In the first round, cooperate (C). This is a goodwill gesture to encourage cooperation from other players.
   - From the second round onwards, follow the 'Tit-for-Tat' approach by mimicking the actions of the other player in the previous round. If a player cooperates, cooperate; if they defect, defect.
   - Introduce forgiveness: In case of a defection, cooperate for one more round before responding with the same action as the opponent from the third round onwards. This is to allow for potential mistakes or variations in strategies and encourages long-term cooperation.

2. Handle edge cases:
   - In the last round, prioritize higher payoff by always cooperating, regardless of the opponent's previous action.
   - If the game reaches a state where all players are defecting consistently (as in example 1), introduce a random element to potentially stimulate cooperation by occasionally deviating from the ATFT strategy and cooperating. This deviation should be rare to avoid appearing predictable.

3. Be collective:
   - Maintain a cooperative stance, as the success of the strategy relies on fostering an environment where long-term cooperation is encouraged.
   - By following the Adaptive Tit-for-Tat with Forgiveness approach, the strategy aims to promote cooperation and stability, as it responds predictably while also showing willingness to forgive and adapt.

Pseudocode:
```
def atft_with_forgiveness(n, k, r, history):
    # Initialize variables
    player_action = 'C'  # Start by cooperating
    forgiveness_counter = 1

    payoff = 0
    total_payoff = 0

    for round in range(r):
        if round == 0:  # First round, always cooperate
            player_action = 'C'
        else:
            opponent_action = history[round - 1][player]  # Get previous action of the opponent
            player_action = opponent_action if forgiveness_counter > 1 else 'C'  # Cooperate in first round after a defection

            if player_action == 'C' and opponent_action == 'D':  # If opponent defected, start forgiveness counter
                forgiveness_counter += 1
            elif player_action == 'C' and forgiveness_counter > 1:  # End forgiveness counter after three rounds
                forgiveness_counter = 0

        payoff_round = (1 - player_action) + (k/n) * sum(history[round])
        payoff += payoff_round
        total_payoff += payoff_round

        if round == r - 1:  # Last round, always cooperate to maximize payoff
            player_action = 'C'

    return total_payoff
```
'''

description_COLLECTIVE_370 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation: Start by cooperating in the first round to demonstrate goodwill and encourage others to cooperate.
   - Tit-for-tat response: After the initial round, mirror the opponent's previous action in each subsequent round. If they cooperated last round, cooperate this round; if they defected, defect this round. This encourages reciprocity while retaliating against defection.
   - Adaptive cooperation: Modify the response based on historical data. Calculate the average number of cooperators over a sliding window (e.g., 5 rounds) and adjust the decision rule as follows:
     1. If the average number of cooperators is greater than or equal to a threshold (e.g., 75%), continue cooperating to reinforce positive behavior.
     2. If the average number of cooperators is less than the threshold, defect to punish opponents who do not contribute enough to the public good.
     3. Periodically reset the sliding window to maintain adaptability in an ever-changing environment.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate to show a willingness to cooperate and potentially encourage others to follow suit.
   - Last round: Make decisions based on the adaptive cooperation rule using the most recent sliding window available (as there may not be enough historical data for a complete sliding window).
   - Endgame considerations: If r is known in advance, adjust the strategy towards cooperation during the final rounds to maximize overall payoff. This can help build trust and encourage opponents to reciprocate.

3. Be collective - Clearly align with the collective mindset
   - Encourage cooperation by demonstrating goodwill and rewarding positive behavior.
   - Retaliate against defection to discourage free-riding but also provide opportunities for opponents to rebuild trust through subsequent cooperative actions.
   - Maintain adaptability by considering historical trends in other players' behavior and adjusting one's own decisions accordingly. This strategy fosters a collective mindset as it aims to promote cooperation while encouraging reciprocal behavior from others.

Pseudocode for the TFT-AC strategy:

```python
def tft_ac(n, k, r, sliding_window=5, threshold=0.75):
    round = 1
    sliding_window_cooperators = [0] * sliding_window
    while round <= r:
        if round == 1 or is_first_in_sliding_window(round, sliding_window):
            # Initial cooperation or reset the sliding window
            cooperate = True
        else:
            # Adaptive cooperation rule
            average_cooperators = sum(sliding_window_cooperators) / sliding_window
            if average_cooperators >= threshold:
                cooperate = True
            else:
                cooperate = not latest_round_cooperation
        perform_action(cooperate)

        # Record the action in the sliding window and update the sum of cooperators
        if round <= sliding_window:
            sliding_window_cooperators[round - 1] = int(cooperate)
            sliding_window_cooperators[-sliding_window + round] = int(not latest_round_cooperation)
        else:
            sliding_window_cooperators[-sliding_window + round] = int(cooperate)

        # Track the payoff for each round
        calculate_payoff()
        round += 1

def calculate_payoff():
    # Calculate the payoff based on the given formula
    pass
```
'''

description_COLLECTIVE_371 = '''
 In this N-Player Public Goods Game, we'll design a strategy called "Folk Theorem Compliant Strategy" (FTCS). This strategy is designed to be adaptive and robust, aligning with the collective mindset while handling various opponent behaviors without relying on specific coordination mechanisms.

1. Decision rules:
   - In each round t, player i decides whether to cooperate (C) or defect (D) based on the expected average payoff from cooperating versus defecting:
      - If (k/n) * ExpectedTotalContributions_t + 1 > PayoffFromDefecting_t, then play C; otherwise, play D.
   - To calculate ExpectedTotalContributions_t and PayoffFromDefecting_t, we use the following formulas:
      - ExpectedTotalContributions_t = (1-α) * TotalContributions_{t-1} + α
      - PayoffFromDefecting_t = (1 - c_i)
   - In FTCS, α represents the rate of change in expected contributions from one round to another, with 0 < α < 1.
     This value can be set based on historical data or adjustments during the game to adapt to opponent behaviors.

2. Handle edge cases:
   - First Round (t=1): Set TotalContributions_{t-1} = 0 and use a starting value for α, such as a default constant or an initial estimate based on historical data.
   - Last Round (t=r): No adjustments are needed since the game is repeated; the strategy will continue making decisions based on ExpectedTotalContributions_t and PayoffFromDefecting_t until the end of the game.

3. Be collective:
   - By following the decision rules, FTCS promotes cooperation when the expected average payoff from cooperating is higher than that of defecting. This aligns with a collective mindset by promoting contributions to the public good.
   - As the strategy adapts to opponent behaviors through α, it encourages players to coordinate and form stable cooperation equilibria, even in the absence of specific coordination mechanisms.
'''

description_COLLECTIVE_372 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initiate cooperation (C) in the first round to foster a cooperative environment. In subsequent rounds, play the same action as the most common action among players in the previous round (MCR). If MCR is evenly split between C and D, copy the own last action. This encourages cooperation while being responsive to opponent behavior.

```python
def tft_ac(own_last_action, mcr, game_history):
    if game_history == 0:  # First round, always cooperate
        return "C"
    else:
        if mcr == 1:  # Most players cooperated in the previous round
            return "C"
        elif mcr == n-1:  # Most players defected in the previous round
            return "D"
        elif mcr == n/2:  # Even split between cooperation and defection
            return own_last_action
        else:  # Handle edge cases (e.g., last round, specific historical patterns)
            handle_edge_cases(own_last_action, mcr, game_history)
```

2. Handle Edge Cases:
   - In the last round, always cooperate to maximize potential payoff.
   - If MCR is not clear (e.g., due to ties), consider the own last action as a tiebreaker.
   - If there is a significant deviation from the average MCR over a specific time frame, adapt to this new trend to avoid being exploited.

```python
def handle_edge_cases(own_last_action, mcr, game_history):
    if game_round == r:  # Last round, always cooperate
        return "C"
    elif abs(mcr - average_mcr) > threshold:  # Significant deviation from average MCR
        adapt_to_trend()
    else:  # Use own last action as a tiebreaker or handle other edge cases
        if own_last_action == "C":
            return "C"
        else:
            return "D"
```

3. Collective Mindset:
   - By following the most common action among players in each round, TFT-AC encourages cooperation and rewards others who cooperate while punishing defectors. This aligns with a collective mindset as it fosters an environment where all players can benefit from mutual cooperation.
   - The strategy is adaptive and robust to various opponent behaviors by adjusting its actions based on the MCR in each round, making it flexible in a tournament setting against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_373 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This serves as a peaceful initial gesture and demonstrates willingness to cooperate.
   - In subsequent rounds, mimic the action of the most frequent opponent strategy in the previous r rounds. If the most frequent strategy is 'Cooperate', continue cooperation; if not, defect.
   - If an opponent deviates from their usual strategy, wait for t penalty rounds before resuming matching their strategy (t is a user-defined parameter, e.g., 3). This allows for forgiveness and encourages opponents to revert to cooperative behavior.
   - If the game has fewer than r history rounds, use the first r actions observed as the history for decision making.

2. Handle Edge Cases:
   - In the last round, prioritize maximizing individual payoff based on the current round's cooperation history, since the strategy cannot adapt to future moves.
   - In case of a tie in the most frequent opponent strategy, choose the strategy that has had the longest streak of consistency (i.e., consecutive identical actions).
   - If there are multiple opponents with the same streak length and frequency, use random selection.

3. Be Collective:
   - By mimicking the most common opponent strategy, TFT-AC aims to align itself with the emergent norms of cooperation in the game's dynamic environment.
   - The adaptive nature of the strategy allows it to respond positively to cooperative behavior and punish defection, fostering a collective mindset that promotes long-term mutual benefits.

Pseudocode:

```python
def TFT_AC(opponents, r=10, t=3):
    history = [opponent_action for round in range(r) for opponent in opponents]  # Gather past actions of all opponents
    most_common_strategy, streak_length, current_streak = find_most_common_strategy(history)  # Find the most common strategy and its properties
    strategy = most_common_strategy

    def play_round(current_action):  # Play one round using the current strategy
        payoff = (1 - current_action) + (k/n) * sum(opponent_action for opponent, opponent_action in zip(opponents, current_action))
        return payoff, current_streak + (1 if current_action == most_common_strategy else 0), strategy

    payoffs = []  # Store payoffs for analysis and comparison with other strategies
    current_streak = streak_length

    for round in range(r+1):
        action, current_streak, strategy = play_round(strategy)
        payoffs.append(action)
        if round < r or (round == r and len(history) < r):  # Use past actions as history in the first r rounds
            continue
        history[-r:] = [opponent_action for opponent, opponent_action in zip(opponents, strategy)]
        most_common_strategy, streak_length, current_streak = find_most_common_strategy(history)  # Update the most common strategy and its properties
        strategy = most_common_strategy

        if strategy != most_common_strategy and round >= t:  # After a predefined number of rounds, resume matching the new most common strategy
            strategy = most_common_strategy

    return payoffs, current_streak, most_common_strategy
```
'''

description_COLLECTIVE_374 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round (t=1), cooperate to set a positive initial tone and encourage cooperation among players.
   - For subsequent rounds (t>1), initially cooperate if majority of opponents cooperated in the previous round. If not, mimic their actions (defect if they defected, cooperate if they cooperated) to encourage reciprocity and build trust.
   - To maintain adaptability, periodically re-evaluate the majority condition based on historical cooperation patterns (for example, consider 51% as a threshold).

Pseudocode:
```python
def strategy(t, history, n, k):
    if t == 1:
        return 'C'  # Cooperate in first round to set a positive initial tone

    majority = int((len(history) - 1)/2)
    cooperators_prev = sum([1 for h in history[-1] if h == 'C'])

    if cooperators_prev > majority:
        return 'C'  # Cooperate to encourage reciprocity and build trust
    else:
        last_action = history[-1][player_index]
        return last_action if last_action == 'C' else 'D'  # Mimic opponent's action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - No specific edge case handling is required since the strategy defined above inherently takes care of each round based on its position in the game (first, last, intermediate rounds).

3. Be collective - Clearly align with the collective mindset
   - The Adaptive Tit-for-Tat strategy aims to foster cooperation and reciprocity among players by adapting to their behavior over time. This encourages a collective spirit as players who consistently cooperate are more likely to have partners that also cooperate, thus promoting collective benefits.
'''

description_COLLECTIVE_375 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Decision Rules:
   - Initially (first round), cooperate to build trust and encourage cooperation from opponents.
   - For subsequent rounds, cooperate if the opponent cooperated in the previous round, otherwise defect. This encourages reciprocal behavior while retaliating against defection.

2. Edge Cases:
   - In the last round, cooperate regardless of the opponent's action in the previous round as there are no further rounds for retaliation or reward.
   - In the first round, if an opponent defects, defect in response to establish a boundary and signal that defection will not be tolerated. However, if all opponents cooperate, continue cooperating to maintain trust and encourage ongoing cooperation.

3. Collective Mindset:
   - Emphasize fairness and reciprocity by adhering to the tit-for-tat strategy, encouraging long-term cooperation and punishing defection. This collective mindset aims to create an environment where all players benefit from mutual trust and cooperation.

Pseudocode:

```python
def TFTA(round, history, opponent_action):
    if round == 1:
        cooperate = True  # Cooperate initially to build trust
    elif round == r:  # Last round, cooperate regardless of previous actions
        cooperate = True
    else:
        last_opponent_action = history[round - 1]  # Get the opponent's action from the previous round
        cooperate = (last_opponent_action == 'cooperate')  # Cooperate if opponent cooperated in the previous round

    return cooperate  # Return the decision to either cooperate or defect
```
'''

description_COLLECTIVE_376 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This establishes a peaceful initiation and demonstrates good intentions.
   - For subsequent rounds t, observe the previous action of player i in round (t-1) and respond with the same action: if player i cooperated, also cooperate; otherwise defect. This encourages reciprocity and punishes defection while maintaining cooperation when others do so.

Pseudocode:
```
function ATFT(n, k, r, t, i, previous_action_i):
    if t == 1:
        return "C"     # Cooperate in the first round
    else:
        if previous_action_i == "C":
            return "C"   # If player i cooperated, also cooperate
        else:
            return "D"   # If player i defected, also defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - There are no special edge cases to consider as the strategy is built around reciprocity and adaptive behavior.

3. Be collective - Clearly align with the collective mindset
   - The ATFT strategy encourages collaboration through reciprocal cooperation, as it rewards others for their cooperation while punishing defection. By following this approach, the AI aims to encourage a more cooperative outcome in the long run and contribute positively to the overall success of the group.
'''

description_COLLECTIVE_377 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and foster a cooperative environment.
   - For subsequent rounds, follow the behavior of the most frequent cooperators (MFC) from the previous r-2 rounds. If the MFC have been cooperating, also cooperate; otherwise, defect.
   - In case there is a tie for the MFC or no clear MFC, make a random choice between cooperating and defecting.
   - To adapt to opponents' behavior, review the MFC after each round. If an opponent becomes more frequent in cooperation than before, they become the new MFC if not already.

Pseudocode for decision rule:
```
function TFT_AC(history, r, n, k)
  if round = 1 then
    return Cooperate()
  end if

  find MFC(history, n)  // Finds the most frequent cooperators in history among n players

  if MFC exists and MFC have been mostly cooperating then
    return Cooperate()
  else
    if MFC does not exist or tied then
      flip coin (random choice)
      if heads then
        return Cooperate()
      else
        return Defect()
    end if
  end if
end function
```

2. Handle edge cases:
   - In the last round, there is no need to retaliate against previous defections since the game ends after this round. Choose cooperation for a positive final impression.
   - If history is empty (i.e., first few rounds), choose random action or default to cooperation for simplicity.

3. Be collective:
   - The TFT-AC strategy aims to promote cooperative behavior by mirroring the actions of frequent cooperators while being adaptive and flexible in response to opponents' strategies.
   - By initially cooperating, the strategy shows a willingness to engage in cooperation and encourages others to do the same. However, it retaliates against defection to maintain the collective good.
'''

description_COLLECTIVE_378 = '''
 Strategy Name: Tit-for-Tat with Variable Cooperation (TFTV)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TFTV strategy follows a pattern of cooperation and retaliation based on the opponent's previous actions. It starts by cooperating in the first round to foster a positive relationship, then adapts its behavior based on the opponent's actions:

   - If the opponent cooperates (C), TFTV responds with cooperation (C) as well. This rewards the opponent for their cooperation and encourages continued cooperation.
   - If the opponent defects (D), TFTV retaliates by defecting in the next round to penalize the opponent's defection. After that, it will cooperate again if the opponent cooperates in the following round. In essence, TFTV seeks to mimic the opponent's behavior while maintaining a balance of cooperation and punishment.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TFTV starts by cooperating in the first round to establish a cooperative relationship with the opponent. In the last round or any other specific round, TFTV continues to follow its decision rules based on the opponent's previous actions, without taking the round number into account explicitly. This way, it remains flexible and responsive to the opponent's behavior throughout the game.

3. Be collective - Clearly align with the collective mindset
   Aligning with a collective mindset requires encouraging cooperation among all players, while still responding adaptively to various opponent behaviors. By following its decision rules consistently and promoting a balance of cooperation and punishment, TFTV seeks to create an environment where cooperation is encouraged and defection is met with appropriate retaliation. This, in turn, promotes collective well-being by incentivizing players to contribute to the public good.

Pseudocode for TFTV strategy:
```
function TFTV_strategy(previousActions, roundNumber):
  if roundNumber == 1:
    return Cooperate (C)

  if opponent's last action was Cooperate (C):
    return Cooperate (C)
  else:
    return Defect (D)
```
'''

description_COLLECTIVE_379 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round to show goodwill (C_i, 1 = C).
   - For subsequent rounds, mimic the previous opponent's action from the previous round (C_i, t = C if C_j, t-1 = C else D). This encourages cooperation but also punishes defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above (C_i, 1 = C)
   - Last round and potential final rounds can be handled by analyzing the overall trend of cooperation from the opponent throughout the game. If the total number of contributions from the opponent is above a certain threshold (e.g., average number of contributions), continue cooperating; otherwise, defect.

3. Be collective - Clearly align with the collective mindset
   - The strategy aims to promote cooperation and reciprocity among players, which fosters a collective mindset as it encourages long-term collaboration.
   - Additionally, by analyzing the overall trend of contributions from an opponent in edge cases, the strategy attempts to maximize collective benefits over time.

Pseudocode:
```python
def ATfT(n, k, r):
    def decide_action(i, t, opponent_actions):
        if t == 1: # First round
            return "C"
        else:
            if opponent_actions[t-1]["i"] == "C": # Opponent cooperated last round
                return "C"
            else: # Opponent defected last round
                return "D"

    opponent_actions = [[0 for j in range(n+1)] for i in range(r+1)] # Initialize with all 0s
    total_contributions = 0

    for t in range(1, r+1):
        my_action = decide_action(i, t, opponent_actions)
        if my_action == "C":
            total_contributions += 1
        opponent_actions[t]["i"] = my_action

    # Last round and potential final rounds handling
    if r > 1:
        average_contributions = total_contributions / r
        if total_contributions >= average_contributions:
            return "C"
        else:
            return "D"
```
'''

description_COLLECTIVE_380 = '''
 In this public goods game with n players, a multiplication factor k, and r rounds, we will develop an adaptive and robust collective strategy called "Fractional Contribution Strategy" (FCS). The FCS is designed to promote cooperation while maintaining individual payoff and being resilient against various opponent behaviors.

1. Specify decision rules:
   - In each round t, calculate the average contribution rate (average_contribution_rate_t) of all players in the previous rounds:
     average_contribution_rate_t = Σ(s=1 to t-1) Σ(i=1 to n) c_i,s / (n*(t-1))
   - Determine contribution rate (contribution_rate_i) for each player i based on the average contribution rate and a "cooperation threshold" (0 < cooperation_threshold < 1):
     contribution_rate_i = max(0, min(1, cooperation_threshold * average_contribution_rate_t))
   - Player i decides to cooperate if contribution_rate_i > 0 and defect otherwise.

2. Handle edge cases:
   - First round (t=1): No history, so all players will contribute with a fixed rate equal to the cooperation threshold.
   - Last round (t=r): Player i chooses based on their current contribution rate as calculated in the decision rules.
   - If the game is expected to be played for an unknown number of rounds, then the cooperation threshold can be adjusted dynamically using an exploration-exploitation mechanism such as ε-greedy or softmax.

3. Be collective:
   - The FCS strategy is inherently collective as it encourages players to contribute to the public good by taking into account the average contribution rate of all other players over previous rounds, thus fostering a cooperative environment.

The pseudocode for the Fractional Contribution Strategy (FCS) can be represented as follows:

```
function FCS(cooperation_threshold):
  contribution_rate_t = {} // initialize an array to store contribution rates
  t = 1 // initialize round counter

  function decide_contribution(i):
    if t == 1 then
      return cooperation_threshold
    end if

    average_contribution_rate_t = sum(contribution_rate) / (n * (t-1))
    contribution_rate_i = max(0, min(1, cooperation_threshold * average_contribution_rate_t))
    return contribution_rate_i > 0

  function update_payoff(i):
    if decide_contribution(i) then
      payoff_i += (1 - contribution_rate_i) + (k/n) * sum(contribute_players)
      contribution_rate[t][i] = contribution_rate_i
    end if

  while t <= r do
    for i in {1 to n} do
      contribute_player[i] = decide_contribution(i)
      update_payoff(i)
    end for
    t += 1
  end while

  return payoffs for all players over the entire game
```
'''

description_COLLECTIVE_381 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize with cooperation in the first round (C,1)
   - For subsequent rounds t (C,t > 1), if the opponent cooperated in the previous round (C,t-1), then cooperate (C,t). Otherwise, defect (D,t). In other words, mirror the opponent's action from the previous round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - Initiate with cooperation in the first round (C,1)
   - For the last round, simply repeat the opponent's most recent action as your decision for the final round.

3. Be collective - Clearly align with the collective mindset
   - TFT-AC is a strategy that aims to foster cooperation and stability by mimicking other players' actions. It encourages reciprocity, ensuring that if cooperative actions are met with cooperation, they will be rewarded. If not, it responds defensively by defecting in the next round.

Pseudocode for TFT-AC:
```
function TFT_AC(opponent_actions, round):
    if round == 1:
        return 'C'  # Initialize with cooperation in the first round

    if opponent_actions[round - 1] == 'C':
        return 'C'  # Cooperate when opponent cooperated in the previous round
    else:
        return 'D'  # Defect when opponent did not cooperate in the previous round

    # For the last round, simply repeat the opponent's most recent action as your decision for the final round
```

This strategy is adaptive and robust to a wide range of opponent behaviors due to its simplicity and reciprocal nature. TFT-AC encourages cooperation when it is successful while protecting itself from repeated defection by defecting in response. The strategy does not rely on any predetermined patterns, norms, or communication with other players.
'''

description_COLLECTIVE_382 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Quotient (TFT-AQ)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), play C to demonstrate goodwill and encourage cooperation.
   - For subsequent rounds t, calculate a Cooperative Quotient (CQ) based on the opponent's past actions.
     If CQ > threshold, play C; otherwise, play D.
     CQ is defined as the ratio of cooperative actions (C) to total actions in the recent history window.
     The size of the history window increases linearly with the number of rounds (r).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, play C as mentioned earlier.
   - In the last round, play C if the opponent has been cooperative enough throughout the game; otherwise, play D to avoid being exploited.
   - When encountering an uncooperative opponent, gradually reduce the window size to react faster to their behavior change and adjust the threshold accordingly.

3. Be collective - Clearly align with the collective mindset
   - Prioritize cooperation as a means of fostering a collaborative environment among players, but remain adaptive to counter deviations from this ideal.
   - If a majority of players cooperate, TFT-AQ will also cooperate to maintain the positive cycle. Conversely, if a majority defects, TFT-AQ will follow suit to minimize losses.

Pseudocode:
```
function TFT_AQ(n, r, k) {
  // Initialize history window and threshold
  let history = [0, ..., 0]; // n zeros for n players
  let windowSize = 1;
  let threshold = (windowSize / r) * n;

  // Define actions per round
  function action(history, n, k) {
    let CQ = history.reduce((sum, el) => sum + el) / windowSize;
    return (CQ >= threshold) ? "C" : "D";
  }

  // Main game loop
  for rounds in range(1, r+1) {
    // Record own action
    history[rounds - windowSize] = action(history, n, k);

    // Calculate payoff based on actions and payoff matrix
    let own_payoff = ... ;

    // Adapt threshold and window size if necessary
    if (rounds >= (windowSize + 1)) {
      windowSize++;
      threshold = (windowSize / r) * n;
    }
  }
}
```
'''

description_COLLECTIVE_383 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Start with cooperating in the first round (C). This is a friendly gesture to encourage cooperation.
   - In subsequent rounds, copy the action of the previous round's majority (i.e., if more than half of players cooperated, cooperate; otherwise defect). This encourages fairness and reciprocity.
   - If the previous round had an equal number of cooperators and defectors, choose to cooperate. This helps maintain a balanced relationship with other players and prevents potential escalation of conflict.
   - In the last round, always cooperate (C), as there are no future consequences for individual actions.

Pseudocode:
```
function ATFT(round, history):
  if round == 1:
    return "C"

  majority = count_majority(history)

  if len(history) <= 1:
    return majority

  if majority == "C":
    return "C"
  elif majority == "D":
    return "D"
  else:
    return "C"

function count_majority(history):
  cooperators = 0
  for action in history:
    if action == "C":
      cooperators += 1

  if len(history) % 2 == 1 and cooperators <= (len(history) - 1) / 2:
    return "D"
  else:
    return "C" if cooperators > (len(history) - 1) / 2 else "D"
```

2. Handle edge cases:
   - In the first round, always cooperate to initiate cooperation.
   - In the last round, always cooperate since there are no future consequences for individual actions.
   - When history is empty (first game), the function returns the majority of the starting endowment distribution, encouraging initial cooperation when players have something to lose.

3. Be collective:
   - By copying the action of the previous round's majority, this strategy encourages cooperation and reciprocity while being adaptive to a wide range of opponent behaviors.
   - This strategy aligns with the collective mindset as it aims for a balanced distribution of contributions among players, promoting the common good.
   - The strategy also considers fairness by favoring equal numbers of cooperators and defectors in the event of ties.
'''

description_COLLECTIVE_384 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - Start with cooperation in the first round (c_i = C). This encourages initial trust and cooperation.
   - In subsequent rounds, observe the actions of other players from previous rounds (history).
   - Maintain cooperation if all players cooperated in the previous round (π_i > 0 in the last round), otherwise defect.
   - Introduce an adaptive cooperative threshold (τ) to account for fluctuating cooperation levels among opponents. If more than τ players cooperate in a given round, increase τ by a small increment; if less than τ players cooperate, decrease τ by a small decrement. This encourages cooperation when it becomes prevalent and discourages defection when it becomes widespread.
   - In case of ties (same number of players cooperating as in the previous round), use the most recent history to make the decision to either cooperate or defect.

2. Handle edge cases:
   - Last round: Mimic the opponent's action from the previous round, as there will be no further rounds for retaliation or rewarding past cooperation.
   - First round: Cooperate to encourage initial trust and cooperation.

3. Be collective:
   - The strategy aligns with the collective mindset by promoting cooperative behavior whenever it appears beneficial based on historical data.
   - By adapting the cooperative threshold, TFT-ACT demonstrates flexibility in accommodating different player behaviors while maintaining a balance between cooperation and defection.

Pseudocode:

```
def tft_act(round, history, k, n, r, τ=0.5*n): # Initialize cooperative threshold to half the number of players
    if round == 1:
        action = 'C' # Cooperate in first round
    elif round == r:
        action = opponents_actions[round-1] # Mimic opponent's action from previous round in last round
    else:
        if sum(history[-r]) > τ: # If more than the cooperative threshold cooperated in the last r rounds, increase adaptive threshold
            τ += 0.01 * n
            action = 'C' if sum(history[-r]) >= τ else 'D'
        elif sum(history[-r]) < τ: # If less than the cooperative threshold cooperated in the last r rounds, decrease adaptive threshold
            τ -= 0.01 * n
            action = 'C' if sum(history[-r]) <= τ else 'D'
        else: # If same number of players cooperated as in the previous round, use most recent history to make decision
            if sum(history[-2:-r+1]) >= τ:
                action = 'C'
            else:
                action = 'D'
    return action
```
'''

description_COLLECTIVE_385 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to signal trust and demonstrate a willingness to contribute to the common good.
   - In subsequent rounds, cooperate (C) if the majority of players cooperated in the previous round. If more than 60% of players cooperated, return C; otherwise, defect (D).
   - Adapt to opponents' behavior by adjusting the threshold for cooperation over time. Start with a higher threshold (e.g., 80%) and gradually decrease it after every 10 rounds (e.g., by 5%), capping at a minimum of 40%. If the number of rounds is less than 100, adjust the threshold proportionally to ensure the minimum threshold is met before round 100.
   - If opponents punish cooperation (i.e., fewer players cooperate after you cooperated), gradually increase the threshold for cooperation. In such cases, start by increasing the threshold by 5%, but only up to a maximum of 80%.

2. Handle edge cases:
   - In the last round, cooperate as a final effort to demonstrate goodwill and potentially foster reciprocity in future interactions.
   - In the first round, cooperate to initiate cooperation as described above. If opponents repeatedly defect (e.g., for the first 20 rounds), gradually increase the threshold for cooperation up to a maximum of 80%.

3. Be collective:
   - The TfTA strategy aims to create a stable cooperative equilibrium, fostering mutual trust and reciprocity among players.
   - By adapting to opponents' behavior and promoting a positive feedback loop when cooperation is rewarded, the strategy encourages collective action that benefits all parties involved in the long run.

Pseudocode:

```python
def tit_for_tat_with_adaptation(n, k, r, round_number):
    # Initialize variables and parameters
    threshold = 80
    num_rounds_passed = 0
    previous_cooperation_percentage = 100  # Assuming all players cooperate in the first round

    # Function to calculate cooperation percentage for the given round
    def calculate_cooperation_percentage():
        total_contributions = sum(contributions)
        return (total_contributions / n) * 100

    # Main function for each round's decision-making process
    def decide_action(contributions):
        nonlocal num_rounds_passed, previous_cooperation_percentage, threshold

        cooperation_percentage = calculate_cooperation_percentage()
        if round_number == 1:
            action = 'C'
        elif cooperation_percentage >= threshold:
            action = 'C'
        else:
            action = 'D'

        num_rounds_passed += 1

        # Adjust the threshold for cooperation based on round number and previous round results
        if num_rounds_passed < 100:
            new_threshold = max(40, min(80, (threshold - (num_rounds_passed // 20) * 5)))
            threshold = max(threshold - ((num_rounds_passed // 20) * 5), 40)
        else:
            new_threshold = max(40, min(80, (threshold - (r // 10) * 5)))
            threshold = max(threshold - (r // 10) * 5, 40)

        # Adjust the threshold for cooperation if opponents punish cooperation
        if cooperation_percentage < previous_cooperation_percentage:
            new_threshold = min(80, (threshold + (num_rounds_passed // 20) * 5))
            threshold = min(new_threshold + (num_rounds_passed // 20) * 5, 80)

        previous_cooperation_percentage = cooperation_percentage
        return action

    # Main function to start the game and make decisions for each round
    contributions = [None] * n
    while num_rounds_passed < r:
        # Get contribution decision for all players
        for i in range(n):
            contributions[i] = decide_action(contributions)

        # Calculate and print payoffs for this round based on the game parameters and contributions
        payoffs = calculate_payoffs(n, k, contributions)
        print("Round:", num_rounds_passed + 1, ", Payoffs:", payoffs)
        num_rounds_passed += 1

    return contributions
```
'''

description_COLLECTIVE_386 = '''
 Title: Tit-for-Tat Cooperative Strategy (TFTC) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFTC strategy in this game follows a tit-for-tat approach, emphasizing both cooperation and retaliation towards the players' behavior. The strategy is based on three main decision rules:

a) Initial Cooperation (I): Cooperate in the first round to establish a cooperative environment.
b) Respond Identically (R): In every subsequent round, imitate the action played by the player in the previous round. This encourages ongoing cooperation when players also cooperate and retaliates against defection.
c) Forgiveness (F): If a defector encounters an initial cooperator, they will immediately revert to cooperating again in the next round.

2. Handle edge cases - What do you do in the first round, last round, etc.?

a) First Round: Cooperate (I). As mentioned earlier, this establishes a cooperative environment.
b) Last Round: The TFTC strategy may choose to defect at the end of each round series since there is no benefit from providing public goods in the final round without subsequent rounds to receive payback. Alternatively, it can be programmed to mimic the opponent's action from the previous round in order to maintain strategic ambiguity or avoid punishing a cooperative opponent in the last round.
c) Other Edge Cases: The TFTC strategy will respond based on the decision rule R in the remaining rounds (except for the first and last rounds, as mentioned above).

3. Be collective - Clearly align with the collective mindset

TFTC is designed to foster collective behavior by encouraging cooperation and retaliation against defection. By imitating others' actions and forgiving initial defectors, TFTC aims to create a stable cooperative environment that benefits all players in the long run.

Pseudocode:

```
def tit_for_tat_cooperative(round: int, own_action_history: List[str], opponent_action_history: List[str]):
  # Initial cooperation
  if round == 1:
    return 'C'

  # Respond identically to the player's previous action
  last_own_action = own_action_history[-1]
  last_opponent_action = opponent_action_history[-1]
  if last_own_action == last_opponent_action:
    return last_own_action

  # Forgiveness
  if last_opponent_action == 'C':
    return 'C'

  # Defect in the final round or when the opponent has defected previously
  if (round == len(own_action_history)) or (last_opponent_action == 'D'):
    return 'D'

  # Return default action if no other rule applies
  return 'C'
```
'''

description_COLLECTIVE_387 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initiation phase (First n rounds): Cooperate (C) in the first round, then mimic the opponents' behavior from the previous round. If it's the first round or there is no history, cooperate.
   - Maintenance phase (Remaining rounds): Continue mimicking opponents' behaviors but with a probabilistic twist to encourage cooperation and avoid falling into defect cycles. The probability of cooperating increases as the average number of cooperators in the recent past approaches n.

Pseudocode for decision rule:
```
def TFT_AC(history, r, n, k):
  if round == 1:
    action = C
  else:
    previous_round = history[-1]
    average_cooperation = sum(previous_round) / len(previous_round)
    if average_cooperation >= n * (1 - epsilon):
      action = C  # Cooperate with high probability
    elif average_cooperation <= n * epsilon:
      action = D  # Defect with high probability
    else:
      action = previous_round[player_index]  # Mimic opponent's behavior from the previous round

  return action
```

2. Handle edge cases:
   - Last round: Since there is no next round, players should not consider the future and only mimic their opponents in the last round.
   - First round: Players will cooperate regardless of opponent's actions due to the initiation phase rule.

3. Be collective:
   - TFT-AC maintains a collective mindset by starting with cooperation and adapting behavior based on the collective actions of opponents, encouraging emergence of cooperation when it is beneficial for the group as a whole. The probability of cooperating increases as the average number of cooperators in the recent past approaches n, incentivizing players to work together towards a higher payoff outcome.
   - The use of epsilon (epsilon > 0) allows players to be flexible and adaptive when facing a wide range of opponent behaviors while maintaining a collective approach.
'''

description_COLLECTIVE_388 = '''
 Strategy Name: Tit-for-Tat (TfT) Adaptive Cooperative Strategy (N-Player Public Goods Game)

1. Specify decision rules:
   - Initial Round (t=1): Start by cooperating (C). This sets a cooperative tone for the game and signals trust to other players.
     Pseudocode: if round = 1 then action = C

   - Subsequent Rounds (2 ≤ t ≤ r): In each subsequent round, mimic the previous opponent's action in the last round. This encourages cooperation when it prevails and punishes defection.
     Pseudocode: if last_round_action[t-1] = C then action = C
                    else action = D

2. Handle edge cases:
   - Last Round (t=r): Continue cooperating even in the final round, as it allows for potentially increased payoff from remaining contributors.
     Pseudocode: if round = r then action = C

3. Be collective: Align with a collective mindset by maintaining cooperation when others do so and retaliating against defection to encourage long-term cooperation. This strategy promotes the emergence of mutual trust among players.
'''

description_COLLECTIVE_389 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - Initiate cooperation (C) in the first round to show goodwill and promote trust. In subsequent rounds, cooperate if all players cooperated in the previous round (Cooperation History: CH = All C). If any player defected in the previous round (CH ≠ All C), also defect (D) to maintain a balance of cooperation and punishment.
   - To adapt to various opponent behaviors, introduce a forgiveness mechanism for newly defecting players by allowing them one "mistake" before responding with punishment (D). After a defection, the player will return to cooperating if all players cooperate in the next two rounds. This encourages long-term cooperation and offers room for reforming relationships with opponents who may have strayed from cooperative behavior.
   - In case of no opponent action (unchanged payoff), maintain previous action as a response to unpredictable or inconsistent behaviors.

2. Handle Edge Cases:
   - In the last round, since there are no future rounds for retaliation or forgiveness, cooperate regardless of the opponent's previous actions to maximize individual payoff.
   - In the initial round (t=1), cooperate as described above.

3. Be Collective:
   - TfTA aims to balance self-interest and group interest by promoting cooperation when it benefits both the player and the collective while also punishing defections to maintain a stable, cooperative environment. The strategy emphasizes forgiveness and adaptability to foster long-term collaboration in repeated interactions with various opponents.

Pseudocode:
```python
def TfTA(history, round):
    if round == 1:
        return 'C' # Cooperate on the first round

    if history[-2] == 'All C': # If all players cooperated in the previous round
        return 'C' # Cooperate now

    if history[-2] != 'All C' and len(history) > 1: # If any player defected or it's not the first round
        return 'D' # Defect to punish the defection

    # Forgiveness mechanism for newly defecting players (D in the last two rounds)
    if len(history) > 2 and history[-3] == 'C':
        return 'C' # Cooperate now as a sign of forgiveness

    # If opponent didn't act or payoff is unchanged, maintain previous action
    return history[-1]
```
'''

description_COLLECTIVE_390 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, starting from t=1, player i follows these rules:
   a) In the first round (t=1), player i chooses to Cooperate (C). This is an initial gesture of goodwill.
   b) If in the previous round (t-1), majority of players (≥ n/2) cooperated, then player i cooperates (C).
   c) If fewer than n/2 players cooperated in the previous round (t-1), then player i defects (D). This is a punishment for non-cooperative behavior.
   d) In case of ties, player i makes the same choice as in the previous round (i.e., if n/2 players cooperated, player i also cooperates; otherwise, player i defects).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   a) In the first round (t=1), player i always cooperates (C).
   b) In the last round (t=r), player i considers the total contributions from all previous rounds to decide whether to cooperate or defect based on the majority rule described in 1b.
   c) For intermediate rounds, player i follows the decision rules from 1a-d without considering the current round number.

3. Be collective - Clearly align with the collective mindset
   The TFTAC strategy aims to establish and maintain cooperation within the group while punishing non-cooperative behavior. By following a consistent pattern of cooperating when others do and defecting only in response to defection, player i fosters trust and collaboration among players, which are essential for achieving collective success.

Pseudocode:

```python
def TFTAC(n, k, r, history):
    if round_number == 1:
        action = 'C'  # Cooperate in the first round
    else:
        num_cooperators = sum(history[-r:-1])
        if num_cooperators >= n//2:
            action = 'C'  # Cooperate if majority cooperated in the previous round
        else:
            action = 'D'  # Defect if majority didn't cooperate in the previous round
    return action
```
'''

description_COLLECTIVE_391 = '''
 Strategy Name: Tit-for-Tat (with adaptations for Public Goods Game)

1. Specify decision rules:
   - In each round i, cooperate (C) if the majority of players in the previous round (i-1) also cooperated. If not, defect (D). This encourages cooperation when others are cooperative and retaliates slightly when they defect.

Pseudocode:
```
function decideAction(history):
    if len(history) < 2:
        return 'C'  # First round, always cooperate as a goodwill gesture

    majority = int((len(history)-1)/2)
    previousRoundCooperators = sum(history[-2:])  # Sum of cooperators in the last two rounds

    if previousRoundCooperators >= majority:
        return 'C'
    else:
        return 'D'
```

2. Handle edge cases:
   - In the first round, always cooperate as a goodwill gesture to encourage others to do the same in subsequent rounds.
   - In the last round, regardless of previous actions, it is optimal to defect since there are no more chances to benefit from the public goods game.

3. Be collective:
   - The strategy prioritizes cooperation when the majority of players are cooperating, promoting a collective mindset. However, it also retaliates slightly when others defect, preventing exploitation by free-riders. This approach encourages long-term cooperation while still being robust to various opponent behaviors.
'''

description_COLLECTIVE_392 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, our strategy will initially cooperate in the first round (first move advantage). For subsequent rounds, the strategy will mirror the opponent's cooperation from the previous round. If an opponent cooperated, we will also cooperate; if they defected, we will defect as well. However, the strategy will show forgiveness by returning to cooperation after a defection, provided that our last action was cooperation.

   Pseudocode:
   ```
   function TFT-AC(opponent_action_history):
       if round == 1:
           return 'Cooperate'
       else:
           if opponent_cooperated_last_round:
               return 'Cooperate'
           elif self_cooperated_last_round and opponent_defected_last_round:
               return 'Defect'
           elif opponent_defected_last_round:
               return 'Defect'
           else:
               return 'Cooperate'
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since our strategy is based on mirroring the opponent's behavior, there are no specific edge cases to handle as long as we initiate cooperation in the first round and there is no defined last round since the game continues for multiple rounds (r > 1). However, it's essential to consider that players may have different ideas about what constitutes "last round" or "initial round." In such cases, our strategy will maintain its cooperative stance until we observe the opponent's actions.

3. Be collective - Clearly align with the collective mindset
   Our TFT-AC strategy promotes collective cooperation and encourages reciprocity. By initially cooperating and adjusting actions based on the opponent's previous moves, our strategy fosters a sense of collaboration and mutual understanding that could lead to increased overall cooperation within the group. While it cannot guarantee perfect coordination, our TFT-AC strategy strives to find an equilibrium where players benefit from collective action while also accounting for potential free riders or defectors in the population.
'''

description_COLLECTIVE_393 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules:
   - Initial Round (t=1): Start by cooperating (C). This is a peace offering and sets the tone for cooperation.
   - Subsequent Rounds (t>1): If a player's previous action was cooperative (c_i, t-1 = 1), then also cooperate in the current round (C). If the opponent defected in the previous round (c_i, t-1 = 0), then defect in this round (D). This punishes defection but offers forgiveness for past mistakes by resuming cooperation after a single act of defection.

2. Handle edge cases:
   - Last Round (t=r): Since there are no future rounds to retaliate, always cooperate regardless of the opponent's previous action (C). This may encourage opponents to cooperate in the last round as well.

3. Be collective:
   - Cooperative approach: TFT+ encourages cooperation by demonstrating a willingness to work together and only retaliating when necessary. The goal is to foster an environment where players learn that cooperation is beneficial in the long run, even when faced with opponents who may defect.

Pseudocode for TFT+ strategy:
```
def TFTPlus(opponent_history, n_players, k, rounds):
  current_round = 1
  my_actions = []

  while current_round <= rounds:
    if current_round == 1:
      action = "C"  # Cooperate in the first round
    elif current_round < rounds and opponent_history[current_round-2] == "C":
      action = "C"  # Cooperate when opponent cooperated previously
    elif current_round < rounds and opponent_history[current_round-2] == "D":
      action = "D"  # Defect when opponent defected previously
    else:  # Last round, always cooperate
      action = "C"

    my_actions.append(action)
    current_round += 1

  return my_actions
```
'''

description_COLLECTIVE_394 = '''
 Strategy Name: Tit-for-Tat (with Adaptive Cooperation Threshold)

1. Specify decision rules:
   - Start with cooperation (C) in the first round to show goodwill and establish trust.
   - For subsequent rounds, observe and respond based on the previous round's collective action. If all players cooperated (total_contributions = n), continue cooperating. If any player defected (total_contributions < n), also defect in the current round.
   - Introduce an adaptive cooperation threshold to foster long-term cooperation: if a certain number of consecutive rounds pass with everyone cooperating, increment the cooperation threshold by one. If there's a defection after the increased threshold, return to the original threshold and continue alternating between cooperation and defection for that number of rounds.
   - After the last round, evaluate the overall performance, and if the average payoff was positive, set the new cooperation threshold to be 1 higher than the previous one. This encourages cooperation in future games with similar parameters.

Pseudocode:
```
cooperation_threshold = 1
total_payoff = 0

for round in range(r):
    if round == 1:
        action = "C" # Cooperate in the first round
    else:
        total_contributions = sum(all_players[i].action for i in range(n))
        if total_contributions == n:
            action = "C" # Continue cooperating if everyone cooperated last round
        elif total_contributions < n:
            action = "D" # Defect if someone defected last round
        else: # If the threshold is exceeded, increment it and alternate actions for that number of rounds
            if total_rounds - round >= cooperation_threshold:
                cooperation_threshold += 1
                action = "C"
                for i in range(cooperation_threshold):
                    all_players[i].action = "D" # Defect for that many rounds
                action = "C" # Then cooperate again
            else:
                action = all_players[round - cooperation_threshold].action # Alternate actions based on the last few rounds

    payoff = (1 - all_players[i].action) + ((k/n) * total_contributions)
    total_payoff += payoff

# Update cooperation threshold after the game ends
if total_payoff > 0:
    cooperation_threshold += 1
```

2. Handle edge cases:
   - First round: Cooperate to build trust and show goodwill.
   - Last round: Evaluate overall performance and set a new cooperation threshold if the payoff was positive. This encourages long-term cooperation in similar games with similar parameters.

3. Be collective:
   - The strategy's main focus is on fostering collective cooperation by following the "Tit for Tat" pattern, adapting to opponent behaviors and encouraging long-term cooperation through an adaptive cooperation threshold.
   - By cooperating in the first round, the strategy shows goodwill and encourages others to do the same.
   - If others cooperate, the strategy continues to cooperate; if not, it defects in response while keeping the option for future cooperation open by adapting the cooperation threshold.
'''

description_COLLECTIVE_395 = '''
 Title: Tit-for-Tat Cooperation Strategy (TFTC) for N-Player Public Goods Game

1. Specify decision rules:
   - TFTC will cooperate in the first round as a gesture of goodwill and to contribute to the public good.
   - For subsequent rounds, TFTC will cooperate if the majority of players cooperated in the previous round. If not, it will defect to encourage other players to cooperate in the future. In other words:

```python
if majority_cooperated_last_round():
    action = "Cooperate"
else:
    action = "Defect"
```

2. Handle edge cases:
   - In the first round, TFTC cooperates as mentioned before.
   - In the last round, TFTC will cooperate if the majority of players have been cooperating throughout the game to encourage fair play and reward cooperation. If there are still some defectors, TFTC may choose not to contribute in order to avoid giving an unfair advantage to those who didn't cooperate.
   - For intermediate rounds, TFTC adheres to the majority rule as specified above.

3. Be collective:
   - TFTC aims to maximize the overall benefit for all players by promoting cooperation and punishing defection when necessary. This aligns with a collective mindset since cooperation leads to better payoffs for everyone.
   - By adapting its behavior based on the actions of other players, TFTC fosters an environment where cooperation is more likely over time, ultimately leading to higher overall payoffs and greater collective success.
'''

description_COLLECTIVE_396 = '''
 Title: Tit-for-Tat Cooperative Strategy (TFTC) for N-Player Public Goods Game

1. Specify decision rules:
   - First Round (t=1): Cooperation (C) to foster a cooperative environment and demonstrate goodwill.
   - Ongoing Rounds (t>1): If the total contributions in the previous round were greater than or equal to a threshold (T), cooperate; otherwise, defect. The threshold is determined by the average total contributions across the first 'm' rounds (where m < r). This adaptive strategy allows for adjustment based on observed cooperation levels.
   - Last Round (t=r): Cooperate since payoffs are accumulated over all rounds, and this round contributes to the overall game performance.

2. Handle edge cases:
   - First Round: Cooperation as mentioned above.
   - Last Round: Cooperate for better overall game performance.
   - Transition Period (m < t ≤ r): Adaptively determine the threshold based on the average total contributions in the first 'm' rounds, as described earlier.

3. Be collective:
   - The strategy prioritizes cooperation and promotes a collective mindset by demonstrating goodwill initially and adapting to the observed level of cooperation within the group.
   - By cooperating when others do so (and only defecting if there is a lack of cooperation), the strategy encourages a sense of reciprocity, fostering a more collaborative environment over time.

Pseudocode:

```python
def TFTC(n, r, k, m):
    total_contributions = [0 for _ in range(r+1)]  # Store total contributions across rounds
    average_total_contributions = sum(total_contributions[m]) / m  # Calculate initial threshold
    threshold = average_total_contributions  # Initialize threshold for ongoing rounds

    for t in range(r):  # Loop through rounds
        if t == 1:  # First round cooperation
            contributions[t] = C
            total_contributions[t] += 1
        else:  # Adaptive cooperation based on previous round's total contributions
            if sum(contributions[t-1]) >= threshold:
                contributions[t] = C
                total_contributions[t] += 1
            else:
                contributions[t] = D

        if t == r:  # Last round cooperation for overall game performance
            contributions[t] = C
            total_contributions[t] += 1

    return contributions, total_contributions  # Return player's actions and total contributions across rounds
```
'''

description_COLLECTIVE_397 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFTAC)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster cooperation and trust among players.
   - In subsequent rounds, if a player i cooperated (c_i = 1) in the previous round, then also cooperate (C). If a player i defected (c_i = 0), then also defect (D) in the current round to reciprocate. This encourages cooperation and punishes defection.
   - The strategy adjusts its behavior based on the average cooperation rate observed from other players over a sliding window of previous rounds. If the average cooperation rate is above a threshold, cooperate; if it's below the threshold, defect. Adjusting the threshold can help balance between being too forgiving or too punitive.
   - To account for occasional mistakes and encourage eventual reconciliation, the strategy relaxes the strict "tit-for-tat" rule by adding a grace period where players are given a chance to rebuild trust even after past defections.

2. Handle edge cases:
   - In the first round, cooperate (C).
   - If the game is repeated multiple times, adjust the cooperation threshold dynamically during the game based on observed player behavior. Start with a high cooperation threshold in the initial rounds to give players room for mistakes and gradually tighten the threshold as the game progresses.
   - In the last round, consider the overall standing of the player in the game. If cooperating might lead to a lower payoff than defecting due to time preferences or specific opponent strategies, defect (D) in the final round to secure the highest possible payoff.

3. Be collective:
   - The TFTAC strategy is inherently collective and aligns with a collective mindset by promoting cooperation through reciprocity and forgiveness while still ensuring robustness against various opponent behaviors. By rewarding cooperation and punishing defection, the strategy fosters an environment that encourages players to act collectively for mutual benefit.
   - To further strengthen the collective aspect of the strategy, consider implementing a "Forgiving Tit-for-Tat" variant where, if an opponent is observed to cooperate after a long streak of defections, the player forgives the past mistakes and reciprocates with cooperation in the current round. This reflects the importance of empathy and understanding within a collective.

Pseudocode:
```
def tftac(n, k, r):
    player_history = []  # Store past moves by each player
    cooperation_threshold = init_cooperation_threshold(r)
    current_round = 1

    while current_round <= r:
        if current_round == 1:  # First round, always cooperate
            return 'C'

        average_cooperation = calculate_average_cooperation(player_history)
        if average_cooperation > cooperation_threshold:
            return 'C'  # Cooperate if average cooperation rate is above the threshold
        else:
            return 'D'  # Defect if average cooperation rate is below the threshold

        player_move = move_by_player(current_round, player_history)
        player_history.append((current_round, player_move))  # Update history with current round and move
        current_round += 1

    return 'D'  # In the last round, consider final payoff and defect if necessary
```
'''

description_COLLECTIVE_398 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), play C to show goodwill and encourage cooperation.
   - In subsequent rounds, mimic the behavior of the other players from the previous round: if they all cooperated in the last round, cooperate; if any player defected, also defect. This tit-for-tat approach encourages reciprocal behavior and punishes defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), play C to set a cooperative tone.
   - In the last round (t=r), if other players have consistently defected throughout the game, also defect to avoid investing in a non-rewarding public good. If some players have cooperated, continue cooperating to potentially influence their behavior in the future or signal commitment to cooperation.
   - For intermediate rounds (2 ≤ t < r), use the described tit-for-tat approach.

3. Be collective - Clearly align with the collective mindset
   - Encourage and support collaboration by cooperating when others do, and punishing defection to discourage selfish behavior. The goal is to maintain a balance between individual interests and collective well-being.

Pseudocode for the strategy:

```python
def tit_for_tat(n, k, r, t):
    # Initialize decision variable (c) to cooperate in the first round
    c = 1 if t == 1 else 0

    for round in range(2, r+1):
        # Observe collective action from previous round
        total_contributions_prev = sum([other_player_action(i, round-1) for i in range(1, n+1)])

        # Determine current action based on previous round's actions
        c = 1 if total_contributions_prev == n else 0

    return c
```
'''

description_COLLECTIVE_399 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules:
   - In the initial round (t=1), cooperate to signal a peaceful intention and foster trust.
   - For subsequent rounds, cooperate if the opponent cooperated in the previous round (t-1). If the opponent defected, also defect to punish defection but be prepared to forgive by cooperating in the next round after the punishment, mimicking forgiving human behavior.

Pseudocode:
```
function TFT_A(opponent_history, r, n, k):
    if t == 1:
        action = "C" # Cooperate in first round as a peace gesture
    else:
        if opponent_history[t-1] == "C": # Cooperate if the opponent cooperated last round
            action = "C"
        else: # Defect if opponent defected last round, and keep track of defections for potential future punishment
            action = "D"
            defections += 1

    if t == r or defections >= (r/2): # Punishment phase: defect until r/2 defections or game end
        action = "D"
        defections -= 1 # Reduce the count of defections after punishment to resume forgiveness

    return action
```

2. Handle edge cases:
   - In the last round (t=r), defect if necessary to meet the punishment condition as described in the pseudocode above.
   - If opponent history is empty or incomplete, cooperate in the first round and mimic the TFT-A strategy based on available information from subsequent rounds.

3. Be collective:
   - The TFT-A strategy focuses on cooperation and trust building while also accounting for defection and punishment when necessary, promoting a balanced approach that encourages both collective and individual interests in the game. This adaptive strategy is designed to perform well against a wide range of opponent behaviors while maintaining a collective mindset.
'''

description_COLLECTIVE_400 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, start by cooperating to promote a peaceful and cooperative environment. This encourages trust and cooperation among players in the long run.
   - In subsequent rounds, evaluate the previous round's total cooperation (total_contributions) and compare it with an acceptance threshold (a% of n players). If more than a% of players cooperated in the previous round, continue to cooperate; otherwise, defect to punish non-cooperative behavior.
   - Adaptation: Periodically adjust the acceptance threshold based on the overall cooperation rate across several rounds. If the average cooperation rate drops below a certain minimum level (m%), lower the acceptance threshold slightly. Conversely, if the average cooperation rate rises above a certain maximum level (M%), raise the acceptance threshold slightly. This adaptability ensures that our strategy remains effective against various opponent behaviors and changing game conditions.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate to establish a cooperative environment.
   - Last round: Evaluate the current round's cooperation level using the previously defined decision rules, and adjust actions accordingly for optimal payoff.
   - Intermediate rounds: Use the adaptive cooperation mechanism described earlier.

3. Be collective - Clearly align with the collective mindset
   - Encourage and promote cooperation among players by starting in a cooperative manner in the first round, rewarding those who also cooperate, and punishing those who do not.
   - Adapt to various opponent behaviors through an adaptive acceptance threshold, fostering a collective interest in maintaining a reasonable level of cooperation for mutual benefit.
'''

description_COLLECTIVE_401 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - TFTAC starts by cooperating in the first round to demonstrate goodwill and encourage cooperation from others. Afterward, it adjusts its strategy based on the opponents' behavior in the previous round.
   - If an opponent cooperates, TFTAC cooperates back in the next round (mirroring their action).
   - If an opponent defects, TFTAC also defects in the next round to punish them for not contributing to the public good. Afterward, it resumes cooperation if the opponent starts cooperating again.

2. Handle edge cases:
   - In the first round, TFTAC cooperates (C). This encourages other players to cooperate as well.
   - In the last round, TFTAC adopts a forgiving approach by cooperating regardless of the opponent's previous action to maximize potential gains.
   - If an opponent stops cooperating and then resumes cooperation after multiple rounds of defection (e.g., they defected in the middle of the game), TFTAC will forgive them and resume cooperation as well, encouraging a return to mutual cooperation.

3. Be collective:
   - TFTAC aims at maintaining a balanced contribution to the public good, promoting collaboration between players. By adapting its strategy based on others' actions, it encourages reciprocity among all participants. This collective mindset helps create an environment where cooperation can flourish over time.

Pseudocode:
```python
def TFTAC(round, opponent_actions):
    strategy = 'C'  # Initialize with cooperation in the first round
    if round == 1:
        return strategy

    if strategy == 'C' and opponent_actions[round - 1] == 'D':
        strategy = 'D'  # Punish opponents who defected in the previous round

    elif strategy == 'D' and opponent_actions[round - 1] == 'C':
        strategy = 'C'  # Cooperate if the opponent cooperated in the previous round

    elif strategy == 'C' and opponent_actions[round - 1] == 'C':
        strategy = 'C'  # Continue cooperation when opponents also cooperate

    return strategy
```
'''

description_COLLECTIVE_402 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Decision Rules:
   - Initially (first round), cooperate to show goodwill and establish cooperation potential.
   - In subsequent rounds, cooperate if the majority of players cooperated in the previous round, otherwise defect. This fosters a reciprocal relationship among players, rewarding cooperators and punishing defectors.
   - A player should continuously monitor the behavior of other players to adapt to their strategies.

Pseudocode:
```
function ATFT(round, history, n, k) {
  if (round == 1) {
    return 'C'
  }

  past_cooperators = countCooperatorsInHistory(history)

  majority = Math.floor((n+1)/2)

  if (past_cooperators > majority) {
    return 'C'
  } else {
    return 'D'
  }
}
```

2. Handle Edge Cases:
   - In the last round, cooperate since there will be no further interactions or consequences.
   - If a player encounters constant cooperation or defection from other players in a significant portion of the game, they should adapt accordingly to improve their long-term payoff.

3. Be Collective:
   - The ATFT strategy emphasizes collective thinking by considering the majority's actions in the previous round before making a decision. It encourages cooperation when it benefits the group as a whole and punishes defection when necessary, promoting fairness and collective success.
'''

description_COLLECTIVE_403 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initial Cooperate (IC): Start by cooperating in the first round to establish a positive initial interaction and set a cooperative tone.
   - Respond identically to opponents' last move in the previous round. This creates a simple yet robust adaptive strategy that encourages reciprocity among players. If an opponent cooperates, TFT-AC will also cooperate; if an opponent defects, TFT-AC will also defect.
   - Continue cooperation or defection based on the opponent's last move in the previous round throughout the game.

2. Handle edge cases:
   - First Round: IC (Initial Cooperate)
   - Last Round: Players may not have enough information about each other's long-term strategies, so TFT-AC will still respond identically to their last move.

3. Be collective:
   - The TFT-AC strategy focuses on long-term cooperation by emulating a cooperative partner and punishing defection. This encourages others to contribute to the public good and fosters collective mindset, as players understand that their actions impact others' future decisions.

Pseudocode:
```python
def tft_ac(round, history):
    if round == 1:
        action = "C"  # Initial Cooperate
    else:
        action = history[round-1]  # Respond identically to opponent's last move
    return action
```
'''

description_COLLECTIVE_404 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Decision Rules:
   - In the initial round (t=1), cooperate (play C). This sets a positive tone and allows other players to cooperate without fear of being exploited.
   - For subsequent rounds (t>1):
     - If opponent cooperated in the previous round, cooperate back. This encourages mutual cooperation.
     - If opponent defected in the previous round, defect this round as a punishment. If the opponent changes their strategy and cooperates again, resume cooperating.

2. Handling Edge Cases:
   - In the last round (t=r), since there are no future rounds for reciprocation, always cooperate regardless of previous actions by opponents.
   - In the first round when encountering a new opponent, cooperate as stated above. If the opponent follows up with cooperation in the next round, switch to the ATfT strategy.

3. Collective Mindset:
   - The core idea is to foster trust and reciprocity, essential aspects of collective mindset. By responding to opponents' actions with a balanced approach, we encourage cooperation among players while protecting ourselves from long-term exploitation.
   - The strategy remains flexible and adaptable, adjusting its behavior based on the opponent's past actions without relying on assumptions about their motivations or strategies.
'''

description_COLLECTIVE_405 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Decision Rules (Cooperate vs Defect):
   - Initiation: Cooperate in the first round to show goodwill and foster cooperation.
   - Response: In subsequent rounds, copy the action of the previous round's majority (if a majority exists). If there is a tie, cooperate.
   - Punishment: If an opponent defected in the previous round while the majority cooperated, also defect in the current round as punishment.
   - Forgiveness: If an opponent who previously defected returns to cooperation, immediately cooperate back to encourage future cooperation.

2. Handling Edge Cases:
   - First Round: Cooperate (initiation)
   - Last Round: Analyze previous actions; if the majority in the previous round cooperated, also cooperate; otherwise defect as a potential signal for the next game or tournament.
   - Intermediate Rounds: Apply the response rule described above.

3. Collective Mindset:
   - The strategy is designed to encourage cooperation and foster trust among players, which aligns with a collective mindset. It is based on the principle of reciprocity where cooperative behavior is rewarded with continued cooperation, while defection leads to punishment.

Pseudocode:

```python
def tit_for_tat(i, round, history):
  if round == 1: # Initiation
    return 'C'

  majority = find_majority(history[round-1])

  if majority == 'D': # Punishment for defection
    return 'D'
  else: # Response to previous round's actions
    return majority
```

In the above pseudocode, `find_majority()` function finds the majority action in a given list of actions (C or D) from the history. If there is no majority, it returns 'C'.
'''

description_COLLECTIVE_406 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate a cooperative environment (C).
   - For subsequent rounds, if the player cooperated in the previous round, cooperate again (C); otherwise, defect (D). This mimics the "Tit-for-Tat" strategy from game theory but is adapted for the public goods game.

2. Handle edge cases:
   - In the last round, always cooperate to maximize potential rewards (C).
   - If a player encounters repeated defection by another player (e.g., the opponent defects in r consecutive rounds), the ATFT strategy will adopt a punishing approach and defect for the next k-1 rounds before returning to cooperating (C). This is to teach the opponent the consequences of repeatedly defecting while maintaining the overall cooperative nature of the game.

3. Be collective - Clearly align with the collective mindset:
   The ATFT strategy is designed to promote cooperation and fairness within the group by encouraging players to reciprocate each other's actions. This strategy aims at fostering a sense of community, as players who consistently cooperate are rewarded in the long run due to the multiplication factor k (public good multiplier).

Pseudocode:

```
strategy ATFT(n, r, k) {
    player_history = [false for i in range(r+1)]  # false denotes 'defect' and true denotes 'cooperate'

    function lastRound() {
        return r >= player_history.length - 1
    }

    function firstRound() {
        return player_history.length == 1
    }

    function punish(opponent) {
        punishmentLength = min(k-1, player_history.length - opponent.lastCooperationIndex - 1)
        for i in range(punishmentLength + 1, player_history.length) {
            player_history[i] = false
        }
    }

    function lastCooperationIndex() {
        return index of the last true value in player_history
    }

    function currentRoundCooperators() {
        cooperatorsCount = 0
        for i in range(n) {
            if (player_history[round]) [i] == true then
                cooperatorsCount += 1
        }
        return cooperatorsCount
    }

    function decisionRule() {
        if (firstRound())
            return true
        else if (lastRound())
            return true
        else if (player_history[round - 1])
            return true
        else
            return false
    }

    function updateHistory(round) {
        player_history[round] = decisionRule()
    }

    for round in range(r):
        cooperateWithOpponents = currentRoundCooperators()
        updateHistory(round)

        if (decisionRule()) {
            opponentsRewarded += cooperateWithOpponents
        } else {
            opponent = find opponent who last cooperated
            if (opponent found and !lastRound()) {
                punish(opponent)
            }
        }
    }
}
```

The above pseudocode outlines the Adaptive Tit-for-Tat strategy for the N-Player Public Goods Game. It includes decision rules, edge cases handling, and a collective mindset by promoting cooperation through reciprocity while considering the consequences of defection.
'''

description_COLLECTIVE_407 = '''
 In this strategic approach for the N-Player Public Goods Game, I'll introduce a cooperative Tit-for-Tat (TFT) variant with memory and adaptation capabilities, aiming to strike a balance between cooperation and defection while being robust against various opponent behaviors.

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = 1). This encourages others to cooperate and sets a cooperative initial condition.
   - In subsequent rounds, observe the previous round's total contributions and your own contribution (total_contributions_t-1 and c_i, t-1) and compare it with an adaptive threshold based on game parameters:
     - If both the total contributions and your own contribution are above a certain level (e.g., average total contributions over the past few rounds), then cooperate (C_i, t = 1). This reward is given for cooperation in a cooperative environment.
     - If either the total contributions or your own contribution are below this threshold, then defect (D_i, t = 0). This punishment is applied when the environment becomes uncooperative.
     - If both conditions are not met, assess the average total contributions over the past few rounds and compare it with a memory-based threshold:
       - If the average total contributions have been consistently high (above the memory-based threshold), then cooperate (C_i, t = 1). This encourages cooperation even in mixed environments.
       - If the average total contributions have been consistently low, then defect (D_i, t = 0). This reinforces defection when the environment is uncooperative for an extended period.
     - Adaptive threshold calculation:
       - High level of cooperation: Total contributions ≥ Average total contributions × Memory factor (e.g., MEMORY_FACTOR = 1.2)
       - Low level of cooperation: Total contributions < Average total contributions / MEMORY_FACTOR
       - Threshold for own contribution can be calculated similarly based on the number of cooperators in the past few rounds

2. Handle edge cases:
   - In the first round, cooperate (C_i, 1 = 1) as mentioned above.
   - In the last round, choose to cooperate if total contributions during the game were above a specific level (e.g., average total contributions × LAST_ROUND_THRESHOLD), otherwise defect (D_i, r = 0). This encourages cooperation at the end of the game when it might benefit overall payoffs.
   - In case of ties or indeterminate situations, defect (D_i, t = 0) to be conservative and avoid unnecessary risks.

3. Be collective:
   - The strategy aligns with a collective mindset by promoting cooperation when the environment is cooperative and punishing defection when it is not. This encourages others to follow suit and contribute to mutual benefit.
   - The adaptive threshold mechanism allows for self-regulation and adaptation to various opponent behaviors, making it more robust and flexible in mixed environments.
'''

description_COLLECTIVE_408 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Specify decision rules:
   - In the first round, cooperate to initiate cooperation and set a baseline for future interactions (C).
   - For subsequent rounds, observe the opponent's actions from the previous round (opponent_action_t-1). If they also cooperated in the previous round (c_opp_t-1 = 1), then cooperate in the current round (C). If the opponent defected (c_opp_t-1 = 0), defect in the current round (D).
   - This strategy ensures a response to opponents' actions while maintaining cooperative behaviour when reciprocated. It also punishes uncooperative opponents by defecting after repeated defections, but forgives them by cooperating once they switch back to cooperation.

2. Handle edge cases:
   - In the last round, cooperate regardless of the opponent's action in the previous round (C). This encourages any remaining cooperation from the opponent while maximizing personal payoff.
   - In the first round and initial encounters with new opponents, cooperating sets a positive tone for future interactions. After several rounds, if the opponent consistently defects, TFT-A will also defect, which might lead to repeated defections or eventual cooperation.

3. Be collective:
   - The strategy aligns with the collective mindset by emphasizing the importance of cooperation and responsiveness to the actions of others. It encourages a cooperative environment while being robust against various opponent behaviours, promoting a balanced distribution of contributions among players.

Pseudocode for TFT-A:

```python
def tft_a(round, r, n, k):
    cooperation = True  # Initiate with cooperation
    payoff = 0

    for round_t in range(1, r+1):
        if round_t == 1:  # First round, always cooperate
            cooperation = True
            action = "C"
        elif round == r:  # Last round, cooperate regardless of opponent's previous action
            action = "C"
        else:
            action = cooperation if opponent_action_t-1 == "C" else "D"
            cooperation = not action  # Update cooperation state for next round

        payoff_round = (1 - int(action == "D")) + (k/n) * sum([int(opponent_action_j == "C" for opponent_action_j in opponent_actions[:round_t]] )
        payoff += payoff_round  # Update total payoff for this round

    return payoff
```
In the above pseudocode, `opponent_actions` is a list containing the actions of all opponents throughout the game. The strategy can be easily extended to multiple players by handling each opponent's actions separately and considering their index (i) when calculating the total contributions to the public good (Σ(j=1 to n) c_j).
'''

description_COLLECTIVE_409 = '''
 In this Public Goods Game, we'll develop a robust and adaptive strategy called "Adaptive Tit-for-Tat" (ATFT). The ATFT strategy is inspired by the original Tit-for-Tat strategy in game theory but modified to perform better in repeated games with multiple players.

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) as a gesture of goodwill.
   - For subsequent rounds, if the other player cooperated in the previous round, also cooperate; otherwise, defect. This allows for reciprocation while remaining forgiving to initial defections.

Pseudocode:
```python
def ATFT_Strategy(history, n, k):
    if history == [] or len(history) < 2:
        action = "C" # Cooperate in the first round
    else:
        prev_action = history[-1]
        if prev_action == "C":
            action = "C" # Cooperate if other player cooperated last round
        else:
            action = "D" # Defect if other player defected last round
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The strategy doesn't need special handling for the last round as it is based on past behavior and there is no future to consider. For the first round, cooperate as mentioned above.

3. Be collective - Clearly align with the collective mindset
   - The ATFT strategy promotes cooperation by starting with a gesture of goodwill in the first round and reciprocating cooperation from others. However, it also punishes defections by defecting on the next turn if another player has previously defected. This encourages players to cooperate while being vigilant about their opponents' actions.

By following these rules, the Adaptive Tit-for-Tat strategy aims to balance cooperation and punishment while promoting a collective mindset in the game.
'''

description_COLLECTIVE_410 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to show goodwill and encourage others to do the same.
   - Subsequent Rounds (t>1): Observe and respond to opponents' actions from the previous round. If an opponent cooperated in the previous round, cooperate; otherwise, defect. This rule encourages reciprocity and long-term cooperation.

2. Handle edge cases:
   - Last Round (t=r): Cooperate as a goodwill gesture, even if opponents didn't cooperate in the preceding rounds. This may foster better relationships for future interactions.
   - First Few Rounds (1<t<5): Adaptively adjust cooperation based on the proportion of opponents who have cooperated so far (e.g., if more than 50% have cooperated, start cooperating; otherwise, continue defecting). This helps respond to different initial strategies and allows time for establishing a pattern of reciprocity.

3. Be collective:
   - Collective mindset is inherent in the TFT-A strategy as it prioritizes reciprocal cooperation that benefits both individual and group goals. By adapting to the collective behavior in each round, TFT-A promotes sustainable cooperation while also maintaining flexibility against various opponent strategies.

Pseudocode for the Tit-for-Tat Adaptive Strategy:

```python
def tft_a(n, k, r, history):
  # Initialize variables
  cooperation_ratio = 0.0
  last_round_cooperation = False

  for round in range(r):
    if round == 1:
      # Cooperate in the first round
      action = "C"

    else:
      # Calculate cooperation ratio based on history
      cooperation_ratio = sum(history[-round:-1]) / round

      # Adaptive rule for first few rounds
      if round < 5 and cooperation_ratio < 0.5:
        action = "D"  # Defect
      elif round < 5 and cooperation_ratio >= 0.5:
        action = "C"  # Cooperate
      else:
        # Standard TFT rule for subsequent rounds
        action = last_round_cooperation  # If opponent cooperated, then cooperate; otherwise defect
        last_round_cooperation = action  # Update last round's cooperation status

    # Add the decision to the history for future reference
    history.append(action)

  return action  # Return final decision for the last round
```
'''

description_COLLECTIVE_411 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation (C) in the first round, encouraging a potential partnership and goodwill.
   - In subsequent rounds, if a player (i) cooperated in the previous round, cooperate (C) as a reciprocal gesture.
   - If another player (j) defected in the previous round, defect (D) to punish the defection.
   - Continuously observe and update past interactions with each opponent.

Pseudocode:

```
function ATFT(round, history_with_player):
  if round == 1:
    return 'C'

  for each player j in history_with_player:
    if last_action_with_j == 'C':
      return 'C'
    elif last_action_with_j == 'D':
      return 'D'

  return 'Error: Unhandled situation'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) to encourage potential partnerships.
   - For the last round, consider the overall game situation and apply ATFT decision rules based on opponents' past actions.

3. Be collective - Clearly align with the collective mindset
   - By reciprocating cooperation in ATFT, the strategy fosters a sense of community and encourages others to cooperate.
   - When others cooperate, ATFT reciprocates; when others defect, ATFT punishes briefly to discourage further defections while maintaining the possibility of rebuilding trust through future cooperative actions.
'''

description_COLLECTIVE_412 = '''
 Strategy Name: Tit-for-Tat with Fitness-Based Adaptation (TFT-FA)

1. Decision Rules:
   - In the initial round (t=1), cooperate to demonstrate goodwill and openness to cooperation.
   - For subsequent rounds (t > 1), observe the action of the opponent from the previous round (opponent_action_{t-1}). If the opponent cooperated in the previous round, cooperate; otherwise, defect. This encourages reciprocity while maintaining self-interest.

Pseudocode:
```
function TFT_FA(n, k, r, opponent_actions):
    strategy = [cooperate in first round] + []
    for t in range(2, r+1):
        if opponent_action_{t-1} == cooperate:
            strategy.append(cooperate)
        else:
            strategy.append(defect)
    return strategy
```

2. Handle Edge Cases:
   - In the last round (t=r), since the game is repeated, consider the payoff from the current round as well as future rounds and act accordingly using the decision rules mentioned above.
   - In the first round, since there is no history to refer to, cooperate as a sign of goodwill.

3. Be Collective:
   - TFT-FA adheres to the collective mindset by promoting reciprocity and cooperation when encountering other cooperative opponents, while also prioritizing self-interest in response to defection. This approach aims at striking a balance between mutual benefit and individual survival.

By following this strategy, the AI will be able to adapt its behavior based on its opponents' actions, fostering a competitive yet collaborative environment.
'''

description_COLLECTIVE_413 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTA follows a simple yet robust strategy that starts by cooperating in the first round, then responds to an opponent's previous move in subsequent rounds. If the opponent cooperated in the previous round, TFTA will cooperate as well; if the opponent defected, TFTA will also defect. This encourages cooperation when an opponent is cooperative and punishes defection.

   Pseudocode:
   ```
   function TFTA(previous_round):
       if first_round:
           return Cooperate()  # Cooperate in the first round
       else:
           return previous_round.action  # Respond with the same action as the opponent from the previous round
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For edge cases such as the first round and the last round, TFTA does not make any adjustments since it is a robust strategy that relies on reciprocity and the long-term benefits of cooperation. However, to make it more adaptive, TFTA can introduce a small probability (e.g., 5%) of defecting in the first round to account for free riders who might not cooperate.

3. Be collective - Clearly align with the collective mindset
   By design, TFTA encourages cooperation when an opponent is also cooperative and punishes defection by responding with defection. This collectively promotes a long-term stable equilibrium where players generally cooperate as they benefit from each other's cooperation. However, it also allows for punishment in case of defection to discourage non-cooperative behavior.

   In summary, TFTA is a simple yet robust strategy that combines the spirit of reciprocity and adaptability to perform well against various opponent behaviors while maintaining a collective mindset that encourages cooperation over repeated interactions.
'''

description_COLLECTIVE_414 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate a cooperative intent (C).
   - From the second round onwards, repeat the action of the opponent from the previous round (Mirroring). If an opponent cooperates in a round, cooperate in the next round; if an opponent defects, also defect in the next round.
   - After every 'punishment' round (i.e., when a player defects after having previously cooperated), introduce a forgiveness phase with a predefined length (t_forgiveness). During this phase, the player will automatically cooperate regardless of the opponent's action in the previous round.
   - To ensure robustness and adaptability, set t_forgiveness as a function of the game parameters:
       - Increase t_forgiveness with an increase in the number of players (n) to account for increased competition for resources.
       - Decrease t_forgiveness with an increase in the rounds (r) to encourage long-term cooperation and learning over time.
   - If a player does not cooperate during the forgiveness phase, revert to mirroring their action.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, players will always cooperate (C).
   - In the last round, players should consider the total game payoff and their current score to determine whether cooperation is beneficial or not. If a player has an overall advantage, they can choose to defect to maximize their final score.
   - In case of ties, players can opt for either cooperating or defecting based on their individual strategy preference (e.g., favoring cooperation in the last round to maintain a friendly reputation).

3. Be collective - Clearly align with the collective mindset
   - Encourage players to adopt this strategy collectively by emphasizing its simplicity, adaptability, and incentivization of both short-term and long-term cooperation.
   - Promote the idea that cooperative behavior can be self-reinforcing through the forgiveness phase, making it less likely for the group to fall into a cycle of defecting actions.
   - Encourage players to view the collective success as their own by highlighting the benefits of a well-functioning community project and the potential for higher payoffs compared to defection in the long run.
'''

description_COLLECTIVE_415 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initiate cooperation by cooperating in the first round (c_i = C). This encourages others to cooperate, as they will receive a higher payoff from our cooperation.
   - In subsequent rounds, cooperate if all players have cooperated in the previous round (π_all_i = 1 in the last round), otherwise defect (c_i = D). This strategy mimics cooperation when others are cooperative but retaliates when they defect.
   - If a player deviates from cooperation, wait for t_punish rounds before forgiving and resuming cooperation (t_punish is a predefined number of rounds that can be adjusted based on the game parameters). This allows for forgiveness and encourages long-term cooperation.

Pseudocode:
```python
def ATFT(round, history, n, k, t_punish):
    if round == 1:
        action = 'C' # Cooperate in the first round

    elif all(history[round-1][i] == 'C' for i in range(n)):
        action = 'C' # Cooperate if everyone cooperated last round

    else:
        action = 'D' # Defect if not all cooperated last round

    if round > t_punish and history[round-t_punish][player] != 'C':
        action = 'C' # Forgive after t_punish rounds of defecting by the player

    return action
```

2. Handle edge cases:
   - The strategy is designed to handle the first round, last round, and any other round appropriately based on the decision rules specified above.

3. Be collective:
   - By cooperating when others do so, ATFT encourages a collective mindset by promoting long-term cooperation and mutual benefits.
   - The strategy also includes forgiveness, which allows for recovery from temporary defections and promotes sustained cooperation in the long run.
'''

description_COLLECTIVE_416 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperation (C). This sets a friendly tone for the game and encourages reciprocity.
   - Subsequent Rounds (2 ≤ t ≤ r): If player i's partner cooperated in the previous round, cooperate (C); if not, defect (D). This rule encourages cooperation when partners are also cooperative while punishing defection to deter freeriding.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) as described above.
   - Last Round: Analyze the total number of cooperation instances during the game. If more than half of the rounds resulted in cooperation, cooperate; otherwise defect. This rule rewards long-term partnerships and encourages future games with similar partners.
   - Other Edge Cases (e.g., interruptions, early termination): Use the latest available information to decide whether to cooperate or defect.

3. Be collective - Clearly align with the collective mindset:
   - Collaborative Decision-Making: Maintain a balance between individual and collective interests by favoring cooperation when partnered with other cooperators, while punishing defection to discourage freeriding.
   - Flexible Adaptation: Continuously adjust strategies based on the partner's behavior, adapting to different opponent behaviors while preserving the collaborative approach.

Pseudocode for the TfT-A strategy:

```python
def tit_for_tat_adaptive(n, k, r, t, history):
  # Initialize partner cooperation history
  partner_cooperates = False

  if t == 1:   # First round
    return 'C'  # Cooperate

  # Update partnership cooperation history
  partner_cooperates = history[t-1]['partner'] == 'C'

  if partner_cooperates and t < r:  # Subsequent rounds
    return 'C'  # Cooperate if partner cooperated in the previous round
  elif not partner_cooperates and t < r:  # Punish defection
    return 'D'
  elif t == r:   # Last round
    cooperation_count = count_cooperation(history)
    if cooperation_count > r/2:       # Cooperate if more than half of the rounds resulted in cooperation
      return 'C'
    else:              # Defect if less than half of the rounds resulted in cooperation
      return 'D'
  else:   # Edge cases (e.g., interruptions, early termination)
    return latest_action(history)
```
'''

description_COLLECTIVE_417 = '''
 In this N-Player Public Goods Game, we will develop a robust and adaptive strategy called "Tit-for-Tat with Fault Tolerance" (TFT-F). This strategy is designed to encourage cooperation while also being able to handle various opponent behaviors.

1. Decision rules:
   - In the first round (t=1), TFT-F will cooperate (play C) as a goodwill gesture, hoping that other players will reciprocate cooperation in subsequent rounds.
   - For t>1:
      - If the player has cooperated in the previous round and received cooperation from all opponents, continue cooperating.
      - If the player has cooperated in the previous round but some opponents defected, reduce the probability of cooperating in the current round (p_cooperate < 1). This encourages opponents to cooperate again to regain the trust of TFT-F.
      - If the player defected in the previous round or has been consistently defected upon by all opponents, cooperate with a high probability (p_cooperate > 0.5) as a way to signal openness to cooperation and attempt to break the cycle of defection.

2. Handle edge cases:
   - In the last round (t=r), TFT-F will play C if it received cooperation from all opponents in previous rounds or played C in the previous round. If not, TFT-F will defect to maximize its payoff in that particular round without affecting future interactions.
   - In the case of multiple players adopting TFT-F, they will coordinate their actions as much as possible due to the mutual reciprocation inherent in the strategy. However, if an opponent deviates from cooperation during a cycle of cooperation, TFT-F may struggle to re-establish cooperation in subsequent rounds.

Pseudocode for the Tit-for-Tat with Fault Tolerance strategy:

```
function TFT_F(round, history, k, n) {
    if round == 1 then
        return Cooperate() // cooperate as a goodwill gesture

    previousRound = history[round - 1]
    if previousRound.allCooperated() then
        return Cooperate() // continue cooperation

    defectedPlayers = countDefectors(previousRound)
    if defectedPlayers == 0 then
        return Cooperate() // continue cooperation

    if history.hasCooperatedInLastNrounds(threshold) then
        return Cooperate() // cooperate to signal openness to cooperation

    p_cooperate = min(1, max(0.5, 1 - (defectedPlayers / n)))
    if random() <= p_cooperate then
        return Cooperate() // cooperate with probability p_cooperate
    else
        return Defect() // defect with probability 1 - p_cooperate
}
```
'''

description_COLLECTIVE_418 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C).
   - In subsequent rounds, player i cooperates if the opponent cooperated in the previous round (if `opponent_action_t-1` is C, then play C), and defects otherwise (if `opponent_action_t-1` is D, then play D). This fosters a cooperative approach but punishes defection to deter exploitation.
   - To adapt to opponent strategies, introduce a tolerance threshold (T) that allows occasional defections from cooperation without retaliation for a limited number of rounds. If the opponent defects more than T times in a row, the player switches to permanent defection (D), assuming the opponent is unwilling to cooperate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - Initiate cooperation in the first round (C). This establishes an initial cooperative relationship with the opponent and opens up the possibility of mutual benefits.
   - In the last round, evaluate the opponent's strategy over the game to decide whether to cooperate or defect based on their overall behavior and tolerance threshold.

3. Be collective - Clearly align with the collective mindset
   - By following the TFT-AC strategy, players exhibit a collective approach that fosters cooperation while being responsive to the actions of other players. This encourages a sense of shared interests and promotes long-term collaboration.
   - The tolerance threshold (T) allows for some deviation from strict cooperation, allowing for flexibility in adapting to different opponent behaviors and maintaining a collective spirit without becoming overly rigid or vulnerable to exploitation.

Pseudocode:

```python
def TFT_AC(opponent_action_history, tolerance_threshold=3):
    round = 1
    my_action_history = []
    cooperation = True

    while round <= r:
        if round == 1:
            my_action_history.append('C')
            cooperation = True

        elif round > 1 and cooperation:
            my_action = opponent_action_history[-1]
            my_action_history.append(my_action)
            cooperation_count = sum([1 for action in my_action_history if action == 'C'])

            if cooperation_count > tolerance_threshold:
                cooperation = True
            else:
                cooperation = False
        else:
            my_action = opponent_action_history[-1]
            my_action_history.append(my_action)

        round += 1

    return my_action_history
```
'''

description_COLLECTIVE_419 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - Initialize cooperation in the first round (c_i = C).
   - For subsequent rounds, cooperate if all players cooperated in the previous round (π_all_previous = k/n * total_contributions_prev == k), or if the opponent cooperated in the last round (π_opponent_last = 1 + (k/n) * opponent_cooperation_count - 1). Otherwise, defect.
   - If the opponent has never contributed before and we have been cooperating, continue cooperation for 'f' rounds to give the opponent a chance to reciprocate. After 'f' rounds, if the opponent has still not cooperated, switch to defect. Set f = floor(r / 2) initially but adjust dynamically based on opponent behavior during the game (e.g., reduce f if the opponent cooperates after the initial phase).

2. Handle Edge Cases:
   - In the first round, cooperate (c_i = C).
   - In the last round, defect if the opponent has not cooperated throughout the game or if the opponent has betrayed the strategy by cooperating only in the final rounds. Otherwise, continue cooperation (c_i = C or D based on decision rules above).

3. Be Collective:
   - Emphasize reciprocity and fairness as key components of collective mindset. The strategy encourages cooperation when others are also cooperative, and it punishes defection by withholding cooperation until the opponent demonstrates a change in behavior. This approach aims to foster a long-term relationship based on mutual trust and cooperation.
   - By adapting the number of initial cooperative rounds (f), the strategy can be more flexible in adjusting to various opponent behaviors and game conditions, promoting collective success in repeated interactions.
'''

description_COLLECTIVE_420 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round (C_i[1] = 1) as a gesture of goodwill.
   - In subsequent rounds, mimic the opponent's action from the previous round (C_i[t] = C_j[t-1]). This creates an iterative and predictable response that encourages reciprocity.
   - If opponents deviate from cooperating, respond with defection for a predefined number of rounds (punishment phase). Then, revert back to mimicking their previous action.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of the opponents' actions. This sets a positive tone for future interactions and encourages reciprocity.
   - In the last round, mimic the opponent's action from the previous-to-last round (C_i[r] = C_j[r-1]). This ensures fairness and respect for prior commitments while allowing opponents to reap benefits if they cooperated in the penultimate round.
   - If the game is not the last round, continue with the TFTAC strategy described above.

3. Be collective - Clearly align with the collective mindset
   - By cooperating when others do and defecting only when others have repeatedly defected, the strategy encourages a sense of mutual cooperation and fairness among players.
   - The strategy also accounts for the long-term benefits of community projects by rewarding cooperation and penalizing defection in a way that fosters collective success over individual gain.
'''

description_COLLECTIVE_421 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to start on a positive note and encourage potential cooperation from others.
   - From the second round onwards, observe the actions of opponents in the previous round:
     - If all opponents cooperated, cooperate as a reward for their cooperation.
     - If at least one opponent defected, also defect as a punishment for defection. This punishing behavior aims to discourage future defection while still encouraging cooperation when it is reciprocated.
   - The contribution level (k) affects the amount contributed in each round:
     - When cooperating, contribute a proportionally lower amount if there has been a history of defections by opponents (punishment), and contribute a proportionally higher amount if there has been a history of cooperation (reward).
   - The proportion is determined based on the number of past rounds where opponents have cooperated vs defected. This adaptive contribution aims to align with the collective behavior while also accounting for the game's multiplication factor k.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - In the last round (round r), cooperate if all opponents have cooperated in the previous round to end the game on a positive note and encourage future cooperation. Otherwise, defect to punish any defection during the final round.

3. Be collective - Clearly align with the collective mindset
   - The TFTAC strategy aims to maintain a balance between individual self-interest (private payoff) and group success (public good).
   - By cooperating when others do and defecting when others do not, the strategy encourages a collective mindset by rewarding cooperation and punishing defection.
   - The adaptive contribution level further reinforces this collective mindset by adjusting the amount contributed based on the history of cooperation among opponents.
'''

description_COLLECTIVE_422 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - In the first round, cooperate to establish a cooperative environment and signal good faith.
   - For subsequent rounds, follow the actions of the opponent in the previous round. If the opponent cooperated, cooperate in return; if the opponent defected, also defect in response.
   - To promote cooperation and encourage opponents to change their behavior, occasionally deviate from TFTA by cooperating when the total number of cooperators in the last r rounds exceeds a certain threshold (e.g., 50%).

2. Handle edge cases:
   - In the last round, prioritize maximizing payoffs based on the current situation, as the game will end soon and there's no need to punish an opponent who has already acted selfishly.
   - In case of a tie between multiple opponents in terms of past actions, randomly choose one opponent to follow.

3. Be collective:
   - Prioritize cooperation when it benefits the majority of players and encourages a cooperative environment, as per the game's payoff structure.
   - If an opponent switches from defection to cooperation, show forgiveness and reciprocate with cooperation to reward good behavior and promote continued cooperation.

Pseudocode:
```
def TFTA(r, n, k):
    history = []  # Store previous rounds' actions of all opponents
    for round in range(1, r+1):
        total_cooperators = count_cooperators(history)
        if round == 1:  # Cooperate in the first round to establish good faith
            action = "C"
        elif total_cooperators > n * 0.5:  # Occasionally cooperate to encourage cooperation
            action = "C"
        else:
            opponent_action = history[-1] if history else "?"  # Get the most recent opponent's action
            action = opponent_action if opponent_action == "C" else "D"  # Follow TFTA, but cooperate when opponent defected

        payoff = calculate_payoff(n, k, round, history, action)
        history.append(action)  # Update the strategy's past actions

    total_game_payoff = sum(payoff for payoff in payoff)
    return total_game_payoff
```
'''

description_COLLECTIVE_423 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - Initiate cooperation (play C) in the first round, encouraging a cooperative start.
   - In subsequent rounds, mimic the previous round's collective behavior of other players. If all players cooperated, continue to cooperate. If any player defected, also defect in the next round. This allows for punishment of defection while fostering cooperation when it occurs.
   - Repeat this pattern for the duration of the game (r rounds).

Pseudocode:
```python
def ATFT(n, r, k):
  round = 1
  previous_round_cooperation = 0 # Initialize as no cooperation in the first round

  while round <= r:
    if round == 1 or previous_round_cooperation == total_contributions_in_previous_round:
      action = 'C' # Cooperate
    else:
      action = 'D' # Defect

    # Update the collective behavior for the next round
    previous_round_cooperation = total_contributions_in_previous_round

    round += 1

  return action
```

2. Handle edge cases:
   - In the last round, ATFT no longer needs to punish defection as there are no further rounds for retaliation or future cooperation. Therefore, it's beneficial to cooperate in the last round regardless of previous collective behavior.

Pseudocode:
```python
def ATFT(n, r, k):
  # ... (same as before)

  while round <= r - 1:
    # ... (same as before)

  if round == r:
    action = 'C' # Cooperate in the last round

  return action
```

3. Be collective:
   - By mirroring the collective behavior of other players, ATFT promotes a collaborative approach while punishing defection to maintain cooperation levels. It encourages a shared understanding that cooperation is beneficial and defection should be met with appropriate counteraction. This fosters collective success over individual gains.
'''

description_COLLECTIVE_424 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy begins by cooperating in the first round, representing a peaceful and trusting gesture towards other players. In subsequent rounds, the strategy mirrors the actions of the other players from the previous round. If another player cooperated in the last round (c_i = 1), then the strategy also cooperates in the current round (C). If another player defected in the last round (c_i = 0), the strategy also defects in the current round (D). This tit-for-tat approach allows for punishment when players are uncooperative, while still fostering cooperation when others demonstrate trustworthiness.

Pseudocode:
```
function ATFT(round, previous_action):
  if round = 1:
    return C
  else:
    return previous_action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, ATFT cooperates regardless of other players' actions (as mentioned above). In the last round, the strategy cooperates if and only if all other players have been cooperative throughout the game (i.e., all previous_action == C). This encourages players to maintain cooperation to maximize their total payoff.

Pseudocode:
```
function is_last_round(current_round, total_rounds):
  return current_round = total_rounds

function last_round_cooperate(previous_actions):
  return all(previous_action == C for previous_action in previous_actions)
```

3. Be collective - Clearly align with the collective mindset
   To further foster a collective mindset, ATFT considers contributing to the public good as a way of promoting group success rather than individual gains. The strategy encourages cooperation and punishes defection to build trust within the group, ultimately benefiting all players in the long run. By cooperating and reciprocating the actions of other players, ATFT maintains an adaptive and robust approach that can handle a wide range of opponent behaviors while promoting collective success in the N-Player Public Goods Game.
'''

description_COLLECTIVE_425 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Decision Rules:
   - Initiate cooperation in the first round (c_i = C). This gesture sets a cooperative tone and allows for potential long-term partnerships.
   - For subsequent rounds, if a player i cooperated in the previous round (c_{i-1} = C), they will also cooperate in the current round (c_i = C).
   - If a player i defected in the previous round (c_{i-1} = D), they will defect in the current round as well (c_i = D). However, if players have been cooperating and then one defects, they will return to cooperation on their next turn.

2. Handle Edge Cases:
   - In the last round, players should cooperate since the game ends soon, promoting a more cooperative environment.
   - In the first round, players initiate cooperation as previously mentioned.
   - If a player encounters an opponent who never cooperates (c_i = D for all t), they should also defect against that opponent to maximize their own payoff.

3. Be Collective:
   - ATFT is inherently collaborative, as it favors reciprocity and cooperation when interacting with other players. The strategy promotes a stable relationship by punishing defection but forgiving past mistakes through conditional cooperation.
  
Pseudocode:

```python
def atft(n, k, r):
    players = [Player(i) for i in range(1, n+1)]  # Initialize player list
    rounds = range(1, r+1)  # Define game rounds

    for round in rounds:
        for player in players:
            if round == 1 or player.lastAction == 'C':
                player.action = 'C'  # Cooperate in first round and after cooperation from opponent
            else:
                player.action = 'D'  # Defect after past defection from opponent
        for player in players:
            player.playRound()  # Execute each player's action
        for player in players:
            player.lastAction = player.action  # Update last action history
```

In the above pseudocode, Player class should be defined separately to include attributes and methods for action selection, payoff calculation, and history management.
'''

description_COLLECTIVE_426 = '''
 Strategy Name: Adaptive Cooperation-Defection (ACD) Strategy

1. Specify decision rules:
   - In each round t and for all rounds r, player i decides whether to cooperate (C) or defect (D) based on the following rule:
     - If the average number of cooperators in the last m_i rounds is above a threshold T, then player i cooperates (C). Otherwise, player i defects (D).
     - The threshold T and memory length m_i are adaptive parameters that evolve based on the opponent's behaviour.

2. Handle edge cases:
   - First round: player i uses a default strategy such as random cooperation or defecting, since there is no history to base decisions upon.
   - Last round: player i follows the decision rule as in normal rounds, but with adjusted parameters that consider the total number of remaining rounds (r-t) and the time value of money (discount rate).

3. Be collective:
   - Player i aims to maximize collective payoffs by encouraging cooperation among players, but without relying on coordination mechanisms or shared norms.
   - To achieve this goal, player i adjusts its adaptive parameters T and m_i dynamically based on the opponent's behaviour. This allows ACD to react effectively to different strategies in the tournament.

Pseudocode:

```python
class ACDStrategy():
    def __init__(self, n, k, r, m=[], T=None):
        self.n = n
        self.k = k
        self.r = r
        self.m_i = m  # memory length for each player (default to empty list)
        if T is None:
            self.T = calculate_initial_threshold(n, k)  # calculate initial threshold

    def calculate_contributions(self, cooperators):
        total_contributions = len(cooperators)
        return (self.k / self.n) * total_contributions

    def calculate_payoff(self, cooperators, contributed=True):
        if contributed:
            payoff = self.calculate_contributions(cooperators) + 1 - len(cooperators)
        else:
            payoff = 1 - len(cooperators)
        return payoff

    def adapt_parameters(self, opponent_behavior):
        # Adjust the threshold and memory length based on opponent's behavior.
        self.T = adjust_threshold(opponent_behavior, self.n, self.k)
        if len(self.m_i) < self.r:  # add more memory points over time
            self.m_i.append(len(self.m_i))

    def decide_action(self, current_round, cooperators):
        if current_round == 1:  # first round, use default strategy
            return decide_default_strategy()

        average_cooperators = sum(cooperators[-self.m_i[current_round - 1]:]) / self.m_i[current_round - 1]

        if average_cooperators >= self.T:  # cooperate if average above threshold
            return 'C'
        else:  # defect otherwise
            return 'D'
```

This strategy allows for adaptive cooperation and defection based on the opponent's behaviour, with parameters that adjust over time to better respond to different strategies in a tournament setting. The initial threshold can be calculated using heuristics such as the Friedman-Seni utility function or other methods tailored to specific game conditions.
'''

description_COLLECTIVE_427 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, the player will contribute to the public good (C). This is a friendly gesture to encourage cooperation and signal trust.
   - Subsequent rounds: the player will mimic the actions of the previous round's majority (if more than half of the players contributed, the player will contribute; otherwise, the player will not contribute).
   - If a player observes a sudden change in others' behavior (more than 50% increase or decrease compared to the previous round), they will adjust their contribution accordingly. For example, if there is an increase in contributions from the majority, the player will also start contributing; conversely, if there is a decrease in contributions, the player will stop contributing.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, the player contributes to the public good.
   - Last round: follow the current decision rule based on the majority's contribution in the previous round.
   - If the game has an odd number of rounds, the player will adjust their strategy one round before the end (to account for the last round) based on the current decision rule.

3. Be collective - Clearly align with the collective mindset
   - The main focus is to foster cooperation by mimicking other players' actions and adjusting contributions based on observed changes in behavior.
   - By following a simple, adaptive strategy that is easily understandable, TFTAC encourages other players to cooperate and maintain long-term relationships, as the player retaliates only when provoked and quickly forgives when others return to cooperation.
'''

description_COLLECTIVE_428 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initiate cooperation (play C) in the first round to foster a cooperative environment.
   - For subsequent rounds, evaluate the number of players who cooperated in the previous round and respond similarly (if they cooperated, cooperate; if they defected, defect). This encourages trust and punishes defection.

2. Handle edge cases:
   - In the last round, since the game is repeated, use the most recent behaviour as a guide for action.
   - If a player encounters a deviation (switching from cooperation to defection) in the middle of the game, they should defect for one round before returning to their cooperative response. This approach allows for forgiveness and encourages the deviating player to reconsider their strategy.

3. Be collective:
   - Prioritize collective interests by promoting cooperation whenever possible but also considering the importance of punishing defection to maintain trust within the group.
   - By adhering to a consistent response pattern, the Tit-for-Tat strategy fosters an atmosphere of stability and mutual cooperation.

Pseudocode:

```python
def tit_for_tat(n, k, r, round, history):
    if round == 1:
        action = "C"  # Cooperate in the first round
    else:
        action = history[round - 1]  # Respond similarly to the previous round's action

    total_cooperators = sum(history)
    payoff = (1 - action) + (k / n) * total_cooperators

    return action, payoff  # Return both action taken and resulting payoff
```
'''

description_COLLECTIVE_429 = '''
 Strategy Name: Adaptive Tit-for-Tat with Fading Memory (ATFM)

1. Specify decision rules:
   - In the initial round (t=1), cooperate (C). This sets a positive tone and allows for potential cooperation in future rounds.
   - From the second round until the last round, adapt strategy based on opponent's behavior in the previous round:
     - If opponent cooperates (c_opponent = 1), cooperate as well (C) to encourage mutual cooperation.
     - If opponent defects (c_opponent = 0), defect (D) as a punishment, but with a fading memory effect that lessens the severity of punishment over time. Calculate the number of consecutive defections by opponent: d_consecutive = max(d_consecutive-1, 1) if opponent defected last round; otherwise, reset d_consecutive to 1. Then, if d_consecutive > 5, cooperate (C), as repeatedly punishing the opponent for too long may not be beneficial in the long run. Otherwise, calculate the punishment level as follows:
       - If d_consecutive <= 3, defect (D).
       - If 4 <= d_consecutive <= 5, slightly cooperate by contributing a fraction of the endowment: contribute (C) with probability p = max(0.5 - (d_consecutive - 4)/2, 0), otherwise defect (D).

2. Handle edge cases:
   - In the last round (t=r), since the game ends soon and there will be no opportunity for retaliation or future cooperation, always cooperate (C) to maximize potential payoff from the remaining rounds.
   - If an opponent stops cooperating after a long period of mutual cooperation, do not react immediately but wait for some defections before starting the punishment process, as it takes time for opponents to shift strategies.

3. Be collective:
   - By adapting strategy based on opponent's behavior and using fading memory, ATFM encourages cooperation in the long run while also being robust against a wide range of opponent behaviors, aligning with a collective mindset.
'''

description_COLLECTIVE_430 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round (t=1), player plays C (Cooperate) to foster cooperation and goodwill among players.
   - From the second round onwards (t > 1), player follows a Tit-for-Tat approach: if the player contributed in the previous round (c_i, t-1 = 1), then the player will contribute in the current round (c_i, t = 1); otherwise, the player will not contribute (c_i, t = 0).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: As mentioned above, the player plays C (Cooperate) to initiate cooperation.
   - Last Round: Since there are no future rounds after the last one, the player does not need to consider retaliation or punishment. The player should evaluate the current round's payoff based on the actions of other players and make a decision accordingly.
   - Intermediate Rounds (t > 1): The player uses the adaptive Tit-for-Tat approach described in point 1.

3. Be collective - Clearly align with the collective mindset
   - By following the Tit-for-Tat strategy, the player aims to maintain a cooperative environment and encourage other players to contribute to the public good. If the majority of players are cooperating, the player will also cooperate; if not, the player will defect to protect its own payoff.
   - The player may consider implementing a forgiveness mechanism where it forgets past transgressions after a certain number of rounds (e.g., 3-5) and starts anew with a cooperative move. This can help in situations where players might have made mistakes or tried to exploit the system initially.

Pseudocode:
```python
def ATFT(t, c_i_prev, n, k):
    if t == 1: # first round, always cooperate
        return 1
    else:
        if c_i_prev == 1: # Tit-for-Tat - cooperate if the player cooperated in the previous round
            return 1
        else: # Tit-for-Tat - defect if the player did not cooperate in the previous round
            return 0
```

Note that this strategy is adaptive and robust to a wide range of opponent behaviors. It encourages cooperation while still protecting the player's own interests by retaliating when necessary. However, it might be beneficial to further optimize the strategy for specific scenarios or tournament settings.
'''

description_COLLECTIVE_431 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation from others.
   - For subsequent rounds, analyze the behavior of opponents in the previous round. If all opponents cooperated, cooperate again (C). If any opponent defected, defect in the current round (D). This rule encourages mutual cooperation but also punishes defection.
   - If a player switches from cooperation to defection, TFT-AC will wait for two consecutive rounds of cooperation before resuming cooperation. This helps prevent unnecessary retaliation and allows for forgiveness when opponents change strategy.

2. Handling Edge Cases:
   - In the last round, cooperate (C) to maximize potential payoff regardless of opponent behavior.
   - If an opponent cooperates after a long period of defection, resume cooperation after two consecutive rounds of cooperation from the opponent. This encourages opponents who may have made a mistake or changed strategy back towards cooperation.

3. Collective Mindset:
   - By following the Tit-for-Tat rule and promoting forgiveness, TFT-AC fosters a collective mindset that encourages mutual cooperation while still protecting against exploitation. This approach allows for adaptability to various opponent behaviors without relying on specific coordination mechanisms or shared norms.

Pseudocode:
```
function TFT_AC(rounds, players, k, endowment):
  strategy = {}
  strategy["cooperate"] = cooperate_function
  strategy["defect"] = defect_function

  def cooperate_function():
    if round == 1:
      return True
    else:
      total_contributions_prev_round = sum(opponents_actions_prev_round)
      return (total_contributions_prev_round == players) or (total_contributions_prev_round == 0 and len(strategy_switch_counter) >= 2)

  def defect_function():
    if round == r:
      return False
    else:
      total_contributions_prev_round = sum(opponents_actions_prev_round)
      strategy_switch_counter = strategy_switch_counter + (1 if total_contributions_prev_round > 0 and strategy["cooperate"]() else 0)
      return total_contributions_prev_round == 0 or len(strategy_switch_counter) < 2
```
'''

description_COLLECTIVE_432 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptation

1. Specify decision rules - When exactly do you cooperate vs defect?

- In the first round, players should cooperate to establish a positive social norm and demonstrate goodwill. This can encourage others to reciprocate in subsequent rounds.

  Pseudocode:
  ```
  function TFT(round, history):
      if round == 1:
          return Cooperate
      else:
          return lastActionInHistory(history)
  ```

- For all subsequent rounds (2 to r), players will cooperate if their partner cooperated in the previous round. Otherwise, they defect to punish non-cooperative behavior. This encourages long-term cooperation and discourages defection.

  Pseudocode:
  ```
  function TFT(round, history):
      if round == 1:
          return Cooperate
      else:
          last_action = lastActionInHistory(history)
          if last_action == Cooperate:
              return Cooperate
          else:
              return Defect
  ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the last round, players should consider their current score and the potential gain from cooperating versus defecting. If they are doing well, they may choose to cooperate to maximize their total payoff. Otherwise, they might opt for defection as a final punishment against uncooperative opponents.

  Pseudocode:
  ```
  function TFT(round, history):
      if round == 1:
          return Cooperate
      elif round == r:
          current_score = calculateScore(history)
          if current_score > averageScore(histories):
              return Cooperate
          else:
              return Defect
      else:
          last_action = lastActionInHistory(history)
          if last_action == Cooperate:
              return Cooperate
          else:
              return Defect
  ```

3. Be collective - Clearly align with the collective mindset

- The TFT strategy prioritizes cooperation and mutual benefits, which aligns with a collective mindset. By reciprocating the actions of others, players promote shared prosperity over individual gain.

The Tit-for-Tat (TFT) strategy is adaptive to a wide range of opponent behaviors, making it robust for the game tournament. It encourages cooperation by reciprocating the actions of others and punishing defection through defection in return. The TFT strategy also takes into account edge cases such as the first round, last round, and the current player's score compared to the average score of all players throughout the game.
'''

description_COLLECTIVE_433 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-A strategy starts by cooperating in the first round, mirroring the behavior of other players. If another player cooperates, TFT-A continues cooperation. If another player defects, TFT-A also defects in the next round to punish defection but resumes cooperation thereafter, provided the other player returns to cooperate.

   Pseudocode for decision rule:
   ```
   function TFT_decision(previous_action):
       if (round = 1) then
           return Cooperate
       elif (previous_action = Cooperate) then
           return Cooperate
       else
           return previous_action
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-A cooperates regardless of the number of rounds (r). There are no special considerations for the last round because the strategy's goal is to maximize total payoff over multiple rounds rather than focusing on a single round.

3. Be collective - Clearly align with the collective mindset
   TFT-A aims to promote cooperation by reciprocating the actions of other players. By doing so, it encourages collaboration and collective success while also punishing defection as a means of deterrence. The strategy fosters a collective mindset by rewarding cooperative behavior and retaliating against uncooperative behavior in a consistent manner.
'''

description_COLLECTIVE_434 = '''
 In this N-Player Public Goods Game, we'll develop a Tit-for-Tat (TFT) strategy that balances cooperation and defection based on past actions of opponents to encourage mutual cooperation. Here's the breakdown:

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially in the first round, we start by cooperating (C).
   - In subsequent rounds, our action is determined by the opponent's action in the previous round:
      - If the opponent cooperated (c_opponent = 1) in the last round, then cooperate (C) this round.
      - If the opponent defected (c_opponent = 0) in the last round, then defect (D) this round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate since it's an initial goodwill gesture.
   - There are no specific rules for the last round, as the strategy continues to follow TFT until the end of the game.

3. Be collective - Clearly align with the collective mindset
   - The Tit-for-Tat strategy encourages cooperation when opponents also cooperate but retaliates with defection if opponents defect. This way, it promotes a mutual cooperation-based collective mindset.

Pseudocode for the Tit-for-Tat strategy:

```python
def tit_for_tat(round, opponent_history):
    # Initialize our history to contain only the last move (first round has no history)
    my_history = [opponent_history[-1]] if round > 1 else []

    # Decide action based on our history and current round
    if round == 1:
        action = 'C'  # Cooperate in the first round
    elif my_history[-1] == 'C':  # Cooperate if opponent cooperated last time
        action = 'C'
    else:                       # Defect if opponent defected last time
        action = 'D'

    return action
```
'''

description_COLLECTIVE_435 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - Initiate cooperation (play C) in the first round to demonstrate goodwill and encourage potential partners.
   - In subsequent rounds, mimic the cooperative behavior of the previous round (i.e., if partner cooperated, cooperate; if partner defected, also defect).
   - If a player encounters repeated defection from their partner for a predefined threshold, shift to permanent defection.
   - After the threshold is reached, re-evaluate the partnership at regular intervals, allowing for potential resumption of cooperation should the partner start cooperating again.

Pseudocode:
```python
def TFTA(partner_history):
    strategy = "cooperate"  # initialize cooperation
    threshold = int(n/2)  # set partnership evaluation threshold
    evaluation_interval = int(r/10)  # set interval for evaluating partnerships

    for round in range(1, r+1):
        if round == 1:  # cooperate in the first round
            strategy = "cooperate"
        else:
            strategy = partner_history[round-1]  # mimic previous round's behavior

        if round % evaluation_interval == 0 and sum(partner_history[-threshold:]) <= threshold:
            if strategy == "cooperate":  # evaluate partnership for defective sequences
                if sum(partner_history[-threshold:]) > threshold:
                    strategy = "cooperate"  # reconsider cooperation if partner improves
                else:  # permanent defection after threshold reached
                    strategy = "defect"
            else:  # continue with defection as partner has been uncooperative
                pass

        # update partnership history
        partner_history.append(strategy)
```

2. Handle edge cases:
   - In the last round, players will not alter their strategies based on future interactions and thus rely on their current evaluation of their partners.

3. Be collective:
   - The strategy is designed to prioritize long-term benefits through cooperation while retaliating against repeated defection, promoting a collective mindset that encourages partnership and mutual trust building over time.
'''

description_COLLECTIVE_436 = '''
 In this N-Player Public Goods Game, we'll develop a strategy that is adaptive and robust, aiming for long-term success without relying on specific opponent behaviors or coordination mechanisms. The strategy is based on Tit-for-Tat with a slight modification to avoid being exploited in the first rounds.

1. Specify decision rules - When exactly do you cooperate vs defect?
Our strategy will start by cooperating in the initial round to foster an atmosphere of cooperation, and then follow the Tit-for-Tat approach for subsequent rounds:
   - If opponent cooperates: Cooperate (C)
   - If opponent defects: Defect (D) until opponent starts cooperating again, then return to cooperating.

The slight modification for the first few rounds aims to prevent being taken advantage of by selfish opponents:
   - In the first round, cooperate as mentioned above.
   - From the second round up to a certain threshold 't' (to be determined through experimentation), if opponent defects, respond with defection but start cooperating again after 't' consecutive rounds of defection from the opponent. The value of 't' will depend on the game parameters and should be chosen to minimize long-term payoff loss while being robust against various opponent behaviors.
   - After reaching round 't', follow the standard Tit-for-Tat approach as described above.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round: cooperate as mentioned earlier.
- In the last round: since the goal is to maximize long-term payoff, the strategy will continue following Tit-for-Tat even in the final round, assuming the game is repeated infinitely or for a large number of rounds. However, if the last round is known in advance (e.g., it's part of the game rules), the strategy may choose to defect in that round, depending on how close the opponent is to cooperating and whether continuing cooperation would be advantageous or detrimental.
- In cases where the number of rounds 'r' is finite but unknown to the strategy (or when the remaining rounds are not easily predictable): the strategy should adopt a conservative approach, favoring cooperation as much as possible while still following the Tit-for-Tat principle to maximize chances of long-term success.

3. Be collective - Clearly align with the collective mindset:
By adopting a Tit-for-Tat strategy that initially cooperates and then responds to the opponent's actions, our strategy promotes cooperation among players. It encourages other players to also cooperate, as they may find it beneficial due to the higher payoff provided by collective action in this public goods game. Additionally, since our strategy follows a flexible response pattern, it can adapt to various opponent behaviors and promote a more collaborative environment over time. This collective mindset is reflected in the strategy's emphasis on long-term success through cooperation rather than immediate gains from defection.

Pseudocode for the adapted Tit-for-Tat strategy:

```python
def play_game(n, r, k, t):
    history = []  # Store previous rounds' actions
    payoffs = [0] * r  # Store total payoff for each round

    def decide_action(opponent_action):
        if len(history) < t:
            if opponent_action == 'C':
                return 'C'
            else:
                response = 'D'
                for _ in range(t - 1):
                    response = 'C'
                return response
        else:
            if opponent_action == history[-1]:
                return 'C'
            else:
                return 'D'

    for round in range(r):
        own_action = decide_action(opponent_action)
        history.append(own_action)
        payoffs[round] = calculate_payoff(n, k, history)

    return payoffs
```
'''

description_COLLECTIVE_437 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - In the first round (t=1), cooperate (C): TfTA starts by being cooperative to foster a cooperative environment.
   - If an opponent cooperated in the previous round (t-1), cooperate (C). This strategy mimics cooperation and encourages trust building.
   - If an opponent defected in the previous round (t-1), defect (D) in the current round (t). The aim is to punish defection while maintaining flexibility for future cooperation.
   - Once a cycle of mutual defection starts, players will alternate between cooperation and defection based on each other's previous move. This strategy aims to avoid prolonged cycles of mutual punishment.
   - In the last round (r), cooperate (C) regardless of the opponent's previous move to maximize the payoff in the final round.

2. Handle edge cases:
   - If an opponent is unknown, cooperate (C). The strategy assumes that cooperation can build trust and encourage others to reciprocate.
   - If the opponent has not played any rounds yet, cooperate (C) for the first interaction.

3. Be collective:
   - TfTA prioritizes cooperation in a group setting by promoting mutual benefit and trust among players. The strategy is adaptive, as it responds to other players' actions while maintaining a collective mindset.

Pseudocode:

```python
def tit_for_tat_adaptive(opponent, round, r):
  history = []
  if round == 1:
    return 'C' # cooperate in the first round

  # Add opponent's last move to the history
  history.append(opponent.last_move)

  # If we have never played against this opponent, start by being cooperative
  if len(history) == 0:
    return 'C'

  # Alternate between cooperation and defection based on opponent's previous move
  last_round = history[-1]
  if last_round == 'C':
    return 'C' # Cooperate if the opponent cooperated in the last round
  else:
    return 'D' # Defect if the opponent defected in the last round

  # In the last round, cooperate regardless of the opponent's previous move
  if round == r:
    return 'C'
```
'''

description_COLLECTIVE_438 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, play C (Cooperate) to contribute to the community project and set a tone of mutual cooperation.
   - For subsequent rounds, analyze the previous opponent's behavior:
     - If the opponent cooperated in the previous round, cooperate (C) in the current round to continue reciprocating their positive actions.
     - If the opponent defected in the previous round, also defect (D) in the current round as a response to their uncooperative action.
   Pseudocode:
   ```
   function TFT_strategy(opponent_history):
       if round = 1:
           return 'C' (Cooperate)
       else:
           if opponent_history[round - 1] == 'C':
               return 'C' (Cooperate)
           else:
               return 'D' (Defect)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first and last rounds, follow the above decision rule of cooperating in the first round to set a positive tone. There is no special handling needed for the last round since the strategy reacts based on the opponent's previous action.

3. Be collective - Clearly align with the collective mindset
   - The Tit-for-Tat strategy promotes collective cooperation by encouraging reciprocity between players, incentivizing mutual benefits and reducing the risk of free riders exploiting others.
   - By defecting when the opponent defects and cooperating when the opponent cooperates, the strategy creates a balance between personal interest and group benefit. This approach encourages long-term collaboration while being robust to a wide range of opponent behaviors.
'''

description_COLLECTIVE_439 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - First round (t=1): Cooperate (C), demonstrating goodwill and encouraging cooperation from others.
   - Subsequent rounds (t > 1): If a player cooperated in the previous round, cooperate (C) as a reciprocal gesture; otherwise, defect (D). This encourages mutual cooperation while also retaliating against defectors.

2. Handle edge cases:
   - Last round (t=r): Cooperate (C), even if others didn't in the previous rounds, to maximize payoff for this round and leave a positive impression for potential future interactions.
   - If the strategy encounters an unexpected move (i.e., not C or D), it will assume the other player is random and respond with its own decision rule for that round.

3. Be collective:
   - The ATFT strategy emphasizes long-term cooperation by reciprocating cooperation from others while retaliating against defection. It aims to foster an environment where players are incentivized to cooperate, benefiting the group as a whole and maximizing individual payoffs over time.

Pseudocode:

```python
def ATFT_strategy(round, opponent_history):
    if round == 1:
        action = 'C'  # Cooperate in the first round
    elif len(opponent_history) == (round - 1) and opponent_history[-1] == 'C':
        action = 'C'  # Cooperate if opponent cooperated last round
    elif len(opponent_history) == (round - 1) and opponent_history[-1] == 'D':
        action = 'D'  # Defect if opponent defected last round
    else:
        action = 'C'  # Cooperate if unsure of opponent's move
    return action
```
'''

description_COLLECTIVE_440 = '''
 Strategy Name: Tit-for-Tat (with slight modifications for the N-Player Public Goods Game)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, if in the previous round s (t-1), all players cooperated, then player i will cooperate. If any player did not cooperate in round t-1, player i will defect. This encourages cooperation when others are cooperating and retaliates defection with defection.

   Pseudocode:
   ```
   function decide_action(history):
       if history[t-1] == [Cooperate for all players]:
           return Cooperate
       else:
           return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there is no previous history, player i will cooperate to encourage others to cooperate. In the last round, as players are aware it's the final round, player i might switch strategies and choose not to follow the Tit-for-Tat rule in order to maximize rewards from past cooperation or defection.

3. Be collective - Clearly align with the collective mindset
   The strategy is designed to encourage collective action through cooperation when others cooperate and retaliation when others defect. It fosters a sense of reciprocity that aligns well with a collective mindset as it rewards cooperation and punishes defection, incentivizing players to work together for mutual benefit.
'''

description_COLLECTIVE_441 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, the TFTAC strategy follows these steps:
   a. Initialize contribution level c_i(t=0) = 0.5, i.e., start by contributing half of the endowment.
   b. If an opponent cooperated in the previous round (c_j, t-1 = 1), then cooperate, i.e., contribute c_i(t) = 1.
   c. If an opponent defected in the previous round (c_j, t-1 = 0), then contribute the same amount as the opponent did in the last round, c_i(t) = c_j(t-1). This is a punishment for defection and a signal of disapproval.
   d. The contribution level adapts gradually over time by reducing or increasing the difference between current and previous contributions when an opponent changes their strategy. If an opponent who was previously defecting starts cooperating, then the contribution level increases; if an opponent who was cooperating starts defecting, then the contribution level decreases.
   e. To avoid getting stuck in a negative cycle of retaliation, introduce a forgiveness mechanism: if an opponent who was previously defecting switches to cooperation, contribute as if it were the first round, i.e., c_i(t) = 0.5.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   a. In the first round, start by contributing half of the endowment: c_i(t=1) = 0.5 for all i.
   b. In the last round (t=r), revert to cooperating if an opponent has been cooperative in the previous round: c_i(t=r) = 1 if c_j, t-1 = 1; otherwise maintain the current contribution level.

3. Be collective - Clearly align with the collective mindset
TFTAC is designed to encourage cooperation among players by promoting reciprocity and forgiveness. By adapting contributions based on opponent behavior, TFTAC aims to foster a sense of collaboration while deterring defection. The strategy encourages cooperation when it is beneficial for the group as a whole (i.e., when most or all opponents are cooperating) and punishes defection when it undermines the collective good.
'''

description_COLLECTIVE_442 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to show good faith and encourage others to cooperate.
   - Subsequent Rounds (t>1): If the opponent cooperated in the previous round, cooperate; otherwise defect. This tit-for-tat behavior encourages reciprocity.

2. Handle edge cases:
   - Last Round (t=r): Cooperate if the opponent cooperated in the last-but-one round to maintain the relationship on a positive note. Otherwise, defect as there are no future interactions.
   - No History (first encounter with an opponent): Cooperate as it promotes cooperation and encourages reciprocity from the opponent.

3. Be collective:
   - The strategy prioritizes collective interests by promoting cooperation when possible and retaliating only if the opponent defects. This approach aims to maximize the overall public good contributions and payoff for all players in the long run.

Pseudocode:

```python
def tit_for_tat(opponent, r, n, k):
    history = []  # Store the last n actions of opponent
    total_payoff = 0

    for t in range(1, r+1):
        if t == 1:  # First round
            action = "C"  # Cooperate to start
        else:
            # Check opponent's previous action and update history
            if opponent_action[t-1] in history:
                history.remove(opponent_action[t-1])
                history.append(opponent_action[t-1])

            if opponent_action[t-1] == "C":  # Cooperate if opponent cooperated last round
                action = "C"
            else:  # Defect if opponent defected last round
                action = "D"

        # Calculate payoff for current round based on game parameters
        payoff_t = (1 - action) + (k/n) * sum(history)
        total_payoff += payoff_t

    return total_payoff
```
'''

description_COLLECTIVE_443 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, player i follows these rules to decide between cooperation (C) and defection (D):
   - If in the previous round j (j < t), an opponent cooperated (c_j = 1), then cooperate: C.
   - If in the previous round j (j < t), an opponent defected (c_j = 0), then defect: D.
   - To handle the initial condition, in the first round, always cooperate: if t=1 then C.
   - In the last round (t=r), players have already seen each other's strategies and may want to ensure a good reputation for future interactions. Thus, cooperate: if t=r then C.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the initial round (t=1), cooperate regardless of opponents' actions: if t=1 then C. This is to demonstrate goodwill and initiate cooperation.
   - In the last round (t=r), cooperate again as a final attempt to build trust for future interactions, even if it might not affect the current game.

3. Be collective - Clearly align with the collective mindset
TFT-A is designed to promote collective decision making by reciprocating cooperation and punishing defection in a synchronized manner across all rounds. This encourages a sense of community as players respond to each other's actions based on past interactions, fostering a cooperative environment that can benefit all participants over time.

Pseudocode:

```
function TFT-A(t, history)
  if t == 1 then
    return C
  end if

  last_round = history[length(history) - 1]

  if last_round[i] == C and last_round[j] == C for all j ≠ i then
    return C
  else
    return D
  end if
end function
```

In this pseudocode, `t` represents the current round number, and `history` is a matrix containing the actions of all players in previous rounds. The function returns 'C' for cooperate or 'D' for defect based on the decision rules described above.
'''

description_COLLECTIVE_444 = '''
 Strategy Name: Tit-for-Tat with Modified Grace Period (TTMGP)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial round (t=1): Cooperate (C) to demonstrate goodwill and encourage cooperation among players. This is the grace period.
   - Subsequent rounds: If player i's action in the previous round was cooperative (c_i, t-1 = 1), then player i will cooperate in this round (t). If player i's action in the previous round was defective (c_i, t-1 = 0), then player i will also defect in this round (t). This rule fosters reciprocity and punishes defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate as mentioned above
   - Last round (r-th round): Since players are trying to maximize their total payoff over all rounds, TTMGP will cooperate if it was cooperative in the previous round (r-1). This encourages other players to reciprocate in the final round.

3. Be collective - Clearly align with the collective mindset
   - By adopting a reciprocal and cooperative strategy, TTMGP contributes to the common good, as it enables the public project when there are enough cooperators.
   - However, the strategy also punishes selfish behavior by defecting when others do so, which helps maintain a balance between individual interests and collective welfare.

Pseudocode:
```
function TTMGP(n, r, k):
  for t = 1 to r:
    if (t == 1) then
      c_i = C # Cooperate in the first round
    else:
      c_i = c_(t-1) # Copy previous round's action
    payoff_i(t) = (1 - c_i) + (k/n) * sum(j=1 to n, c_j(t))
  total_payoff_i = sum(t=1 to r, payoff_i(t))
```
'''

description_COLLECTIVE_445 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the TFTAC strategy decides to either cooperate or defect based on three factors: the current round number (t), history of cooperation from the opponent in previous rounds (h_coop), and game parameters k and n. The strategy follows these rules:

   - Initially (t = 1): Cooperate (C) as a peaceful gesture to encourage reciprocity.
   - Last round (t = r): Cooperate if the sum of cooperations from the opponent in the last 3 rounds is greater than or equal to the sum in the previous 3 rounds; otherwise, defect (D). This encourages long-term cooperation while still punishing overly aggressive opponents.
   - Otherwise (2 < t < r):
      - If h_coop in the previous round was a cooperative action (h_coop[t-1] = C), cooperate (C) to continue reciprocity.
      - If h_coop in the previous round was a defection action (h_coop[t-1] = D), defect (D) as punishment for the opponent's previous action.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round (t = 1): Cooperate regardless of opponent's history (h_coop[0] is undefined). This initial cooperation encourages opponents to reciprocate.
   - Last rounds (t >= r-3): Follow the rules for the last round, considering the opponent's behavior in the previous 3 rounds.

3. Be collective - Clearly align with the collective mindset:
The TFTAC strategy aims to establish a cooperative environment by reciprocating cooperation and punishing defection. This encourages long-term cooperation while still being robust against a wide range of opponent behaviors. The strategy does not rely on specific coordination mechanisms or assumptions about other players' strategies, making it adaptive to various game conditions.

Pseudocode for the Tit-for-Tat Adaptive Cooperation strategy:

```python
def TFTAC(opponent_history, round, k, n):
    if round == 1:
        return 'C'  # Cooperate in the first round

    last_cooperative = opponent_history[-1]  # The most recent action by the opponent
    previous_three_rounds = opponent_history[-4:-1]  # Opponent's actions from the last three rounds
    current_three_rounds = opponent_history[-7:-5]  # Opponent's actions from the last three but one rounds

    if round == len(opponent_history):  # Last round
        if sum(last_cooperative) >= sum(current_three_rounds):
            return 'C'  # Cooperate if opponent has cooperated more in the last three rounds
        else:
            return 'D'  # Defect if opponent has not cooperated more in the last three rounds
    else:
        return last_cooperative if last_cooperative == 'C' else 'D'  # Cooperate or defect based on previous round's action
```
'''

description_COLLECTIVE_446 = '''
 Strategy Name: Tit-for-Tat (with adaptation) for the N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to build trust and encourage cooperation among players.
   - For subsequent rounds, cooperate if majority of players (> n/2) cooperated in the previous round; otherwise, defect.
   - If a player switches from cooperation to defection, return to cooperating on their next move.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to foster a positive starting point.
   - In the final round (rth round), since future interactions are not possible, revert to cooperating if majority cooperated in the previous round; otherwise, defect. This ensures that the strategy does not become overly altruistic at the end of the game.

3. Be collective - Clearly align with the collective mindset
   - The strategy aims to build and maintain trust within the player community by adhering to a tit-for-tat approach, which encourages reciprocal cooperation.
   - The adaptive nature of the strategy allows it to respond appropriately to various opponent behaviors while maintaining a collective focus on mutual benefit.

Pseudocode:

```python
def play_game(n, k, r):
    player_history = [[0 for _ in range(r)] for _ in range(n)]  # nxr matrix to store history of players' moves

    def strategy(i, t):
        if t == 1:  # first round
            return 1  # cooperate
        else:
            majority = int((n+1)/2)  # find the majority (round up for ties)
            cooperation_count = sum([player_history[j][t-1] for j in range(1, n+1)])  # count number of cooperators in previous round
            if cooperation_count >= majority:  # if majority cooperated, cooperate in current round
                return 1
            else:  # defect if majority did not cooperate
                return 0

    for t in range(1, r+1):  # play the game over r rounds
        cooperation_levels = [strategy(i, t) for i in range(1, n+1)]  # get all players' moves in current round
        for player, move in enumerate(cooperation_levels):  # update history of players' moves
            player_history[player][t] = move
```
'''

description_COLLECTIVE_447 = '''
 In this N-Player Public Goods Game, we'll design a collective strategy named Tit-for-Tat with an adaptation called Adaptive Tit-for-Tat (ATFT). The strategy is designed to balance cooperation and defection while being adaptive and robust to a wide range of opponent behaviors.

1. Specify decision rules:
   - Start Cooperation (C) in the first round. This gesture demonstrates goodwill and sets a cooperative tone for the game.
   - In subsequent rounds, repeat the action taken by the opponent from the previous round (i.e., if opponent cooperated in the last round, cooperate; otherwise, defect). This mimics the reciprocal behavior that underlies many social interactions.
   - Adaptive Tit-for-Tat (ATFT) adds a level of flexibility by allowing players to revert back to initial cooperation after a certain number of defections in a row from an opponent. The number of defections before reverting to cooperation can be adjusted as a parameter, e.g., MaxDefections = n/2.

Pseudocode for the Adaptive Tit-for-Tat (ATFT) strategy:

```python
def ATFT(opponent_history, max_defections, current_round):
    if current_round == 1:
        return 'C'  # Cooperate in the first round

    opponent_action = opponent_history[-1]  # Get the last action of the opponent
    defections_counter = sum(1 for action in opponent_history[:-1] if action == 'D')

    if defections_counter > max_defections:
        # Reset defections counter after reaching MaxDefections and cooperate again
        defections_counter = 0
        return 'C'
    else:
        return opponent_action  # Repeat the last action of the opponent
```

2. Handle edge cases:
   - In the last round, there are no more payoffs to be earned, so players may choose to cooperate or defect based on their strategy. In our ATFT implementation, players will continue following the same decision rules as in regular game rounds.
   - In the first round, players always start by cooperating according to the initial rule.

3. Be collective:
   - The Adaptive Tit-for-Tat (ATFT) strategy prioritizes cooperation while maintaining a reciprocal behavior that encourages other players to cooperate as well. It demonstrates a collective mindset by balancing individual gains with the common good.
'''

description_COLLECTIVE_448 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initialize cooperation in the first round (c_i = C). This sets a cooperative tone and encourages others to cooperate.
   - In subsequent rounds, mimic the behavior of the previous round's majority. If more than (n/2) players cooperated in the previous round, cooperate (c_i = C); otherwise, defect (c_i = D). This rule is adaptive and encourages reciprocity among players while being robust to various opponent behaviors.

2. Handling Edge Cases:
   - In the last round, always cooperate as there are no further rounds for retaliation or reward.
   - In the first round, cooperate as mentioned earlier.

3. Collective Mindset:
   - The strategy is designed to foster a collective mindset by encouraging reciprocity and cooperation among players. By mimicking the behavior of the majority, it seeks to create a sense of unity and shared interest in contributing to the community project.
   - The strategy also punishes defection by retaliating with defection when the majority defects, promoting a collective interest in cooperative behaviors.

Pseudocode:
```
function ATFT(round_number, history, n_players, k, r):
  if round_number == 1:
    action = "C"  # Cooperate in the first round
  else:
    num_cooperators_prev_round = countCooperators(history[round_number - 1])
    if num_cooperators_prev_round > n_players / 2:
      action = "C"  # Cooperate when more than half of players cooperated in the previous round
    else:
      action = "D"  # Defect when less than half of players cooperated in the previous round

  return action
```
'''

description_COLLECTIVE_449 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   a. In the first round, cooperate to promote trust and goodwill among players. This initial cooperation sets the stage for potential future collaborations.

       If round = 1 then Cooperation (C)

   b. For subsequent rounds, mimic the actions of other players from the previous round. If a player has cooperated in the last round, respond with cooperation; otherwise, defect. This simple and predictable strategy encourages others to reciprocate cooperation while still protecting oneself against frequent defection.

       if previous_round_action[i] == C then Cooperation (C)
       else Defection (D)

   c. To avoid being exploited by perpetual defectors, implement a forgiveness mechanism. Forgive the defector and return to cooperation after a certain number of retaliatory defections. This encourages a defecting player to reconsider their strategy and potentially cooperate in future rounds.

       if round_since_last_cooperation > forgiveness_threshold then Cooperation (C)

2. Handle edge cases - What do you do in the first few rounds, last round, etc.?
   a. In the first few rounds, prioritize building trust and relationships with other players by cooperating more frequently than a standard Tit-for-Tat strategy. This increases the chances of forming beneficial partnerships over multiple rounds.

       if round <= forgiveness_threshold then Cooperation (C)

   b. In the last round, prioritize maximizing one's own payoff rather than promoting cooperation with others. This allows for a better final score in case other players have not cooperated throughout the game.

       if round == r then Defection (D)

3. Be collective - Clearly align with the collective mindset
   a. Emphasize cooperation and fairness, as the success of the community project is essential for all participants' payoffs. This encourages players to consider the long-term benefits of cooperation over individual short-term gains.

       if (round_since_last_cooperation < forgiveness_threshold) && (total_contributions / n > minimum_community_participation) then Cooperation (C)

   b. Be willing to adjust the forgiveness threshold and other strategy parameters based on observations of other players' behavior throughout the game. This allows TFTA to adapt to various opponent strategies and optimize collective outcomes.

       if observed_opponent_behavior_is_exploitative then increase_forgiveness_threshold()
       if observed_opponent_behavior_is_cooperative then decrease_forgiveness_threshold()
'''

description_COLLECTIVE_450 = '''
 Strategy Name: Adaptive Cooperative Tit-for-Tat (AC-TFT)

1. Decision Rules:
   - In the first round (t=1), cooperate to initiate cooperation and show goodwill (C).
   - For subsequent rounds (t>1):
      a) If an opponent cooperated in the previous round (t-1), reciprocate cooperation (C).
      b) If an opponent defected in the previous round (t-1), defect in the current round (D) to demonstrate disapproval. However, if the total number of previous cooperative actions by this opponent is more than a threshold T (defined below), cooperate to encourage future cooperation (C).
   - The strategy adapts to long-term cooperation by considering the opponent's past behavior and encourages short-term defection when necessary.

2. Handle edge cases:
   - Last round (t=r): Cooperate if the total number of past cooperative actions with an opponent exceeds T, otherwise defect (D). This ensures that some cooperation occurs in the final rounds to maximize payoff.
   - First round (t=1): Always cooperate (C) as a gesture of goodwill and to encourage future cooperation.
   - Other edge cases, such as repeated defection or prolonged cooperation from opponents, can be addressed by periodically updating T based on the history of interactions with each opponent, promoting flexibility in the strategy.

3. Be collective:
   - The AC-TFT strategy aligns with a collective mindset by promoting and rewarding cooperation among players. By reciprocating cooperative actions and punishing defection, it encourages long-term collaboration and mutual benefits. However, the lack of communication or coordination mechanisms ensures independence from other strategies.
   - To further enhance collectivity, the strategy can include a forgiveness mechanism that forgets past defections after a certain number of consecutive cooperative actions from an opponent, providing opportunities for redemption and rebuilding trust.
'''

description_COLLECTIVE_451 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate (C) in the first round to establish a cooperative environment.
   - For subsequent rounds, mimic the action of the most frequent cooperator(s) among all players from the previous r rounds (recent history). If multiple players have the same frequency, choose one randomly. If no player has cooperated at all in the recent history, defect (D) to avoid being taken advantage of.
   - Upon cooperation by an opponent who previously defected, respond with cooperation for a fixed number of subsequent rounds as a gesture of goodwill (Forgiveness period). The length of this period can be empirically determined based on the opponents' behavior.
   - If an opponent switches from cooperating to defecting after the forgiveness period, revert to mimicking their actions in the recent history, unless they have consistently cooperated for a certain number of rounds (Trust threshold). In this case, keep cooperating as a sign of trust. The values for forgiveness period and trust threshold can be adjusted based on the specific game parameters and opponents' behaviors.

2. Handling Edge Cases:
   - In the last round, there is no need to consider the recent history as the game will end soon. However, if an opponent has shown cooperative behavior in the recent past, it might be beneficial to reciprocate for a final payoff boost.
   - In the first round, cooperate to create a positive initial interaction, but also keep track of other players' actions for future decision-making.

3. Collective Mindset:
   - TFT-AC encourages cooperation as its primary approach but is adaptable and responsive to opponents' strategies. It aims to foster an environment where cooperation can thrive by retaliating against defection while being forgiving and trusting when warranted.
   - By adhering to a simple yet effective decision rule, TFT-AC promotes collective stability through reciprocity and adaptability without relying on explicit coordination mechanisms or shared norms.

Pseudocode:
```
TIT_FOR_TAT_WITH_ADAPTIVE_COOPERATION(n, r, k) {
  history = empty array of length r
  forgiveness_period = parameter based on game parameters
  trust_threshold = parameter based on game parameters

  function getMostFrequentCooperators(): List<Player> {
    // Calculate frequency of cooperation for each player in the recent history
    frequencies = calculateFrequencies(history)
    // Find players with the highest cooperation frequency
    cooperators = sorted_frequencies.slice(0, min(n, forgiveness_period))
    return cooperators
  }

  function respondToOpponent(opponent): Action {
    if (opponent is in getMostFrequentCooperators()) {
      // Cooperate as a gesture of goodwill during the forgiveness period
      if (history.length <= forgiveness_period) {
        return "C"
      } else {
        // After forgiveness period, cooperate based on trust threshold
        if (opponent has consistently cooperated for at least trust_threshold rounds) {
          return "C"
        } else {
          return mimicOpponentActions(opponent, history)
        }
      }
    } else {
      // Defect to avoid being taken advantage of
      return "D"
    }
  }

  function playRound(ownAction, opponentsActions): void {
    payoff = calculatePayoff(ownAction, opponentsActions)
    history.push(ownAction)

    // Update the strategy's understanding of other players' behavior
    for opponent in opponentsActions {
      if (opponent.action == "C") {
        updateOpponentBehavior(opponent)
      }
    }
  }

  function calculatePayoff(ownAction, opponentsActions): float {
    // Calculate payoff based on the given game parameters and payoff matrix
    totalContributions = countCooperators(opponentsActions)
    return (1 - ownAction) + (k / n) * totalContributions
  }

  function updateOpponentBehavior(opponent): void {
    // Update the opponent's behavior based on their actions in recent history
    if (opponent.action == "C") {
      // Increase cooperation frequency for this opponent
      incrementCooperationFrequency(opponent)
    } else {
      // Decrease cooperation frequency for this opponent
      decrementCooperationFrequency(opponent)
    }
  }

  function calculateFrequencies(history): List<float> {
    // Calculate the frequency of cooperation for each player in history
    frequencies = empty array of length n
    for round in history:
      for player in round:
        if (player.action == "C") {
          incrementCooperationFrequency(players[player])
        }
    return frequencies
  }

  function incrementCooperationFrequency(player): void {
    // Increment the cooperation frequency for a given player by 1
    players[player].cooperation_frequency += 1
  }

  function decrementCooperationFrequency(player): void {
    // Decrement the cooperation frequency for a given player by 1
    players[player].cooperation_frequency -= 1
  }

  function startGame(): void {
    // Start the game by cooperating in the first round and initializing history
    playRound("C", [{"action": "C"} for i in range(n)])
  }
}
```
'''

description_COLLECTIVE_452 = '''
 For this N-Player Public Goods Game, I propose a strategy named "Adaptive Tit-for-Tat" (ATFT). The ATFT strategy is designed to promote cooperation while being robust against various opponent behaviors.

1. Decision rules:
   - In the first round, cooperate as a goodwill gesture. This encourages others to cooperate and sets a positive tone for the game.
     Pseudocode: if round = 1 then cooperate (C) else continue with adaptive rules below.

   - For subsequent rounds, imitate the previous action of the opponent from the previous round. If they cooperated, you also cooperate; if they defected, you also defect. This encourages reciprocity and stability in the game.
     Pseudocode: let last_action = opponent's action from the previous round. If last_action = C then cooperate (C), else defect (D).

   - In the last round, cooperate again to maintain positive relationships and potentially influence the opponent's decisions in future games.
     Pseudocode: if round = r then cooperate (C).

2. Handle edge cases:
   - If an opponent is consistently defecting without any cooperation, gradually decrease the likelihood of cooperating to avoid being taken advantage of. This can be achieved by introducing a tolerance parameter 'T' that limits the number of consecutive defections before adjusting strategy.
     Pseudocode: Let T = a predefined tolerance (e.g., 3). If the opponent has defected for more than T consecutive rounds, gradually decrease the probability of cooperating over the next few rounds. This can be implemented by using an exponentially decreasing function of the number of defections.

3. Be collective:
   - The ATFT strategy prioritizes long-term cooperation and stability in the game to maximize overall group benefits, while being adaptive to various opponent behaviors and strategies.

The goal of this strategy is to encourage cooperation among all players over the course of multiple rounds, promoting a collective mindset that leads to higher overall payoffs for everyone involved. By adjusting its approach based on an opponent's behavior, ATFT demonstrates resilience in diverse game situations while maintaining a cooperative stance whenever possible.
'''

description_COLLECTIVE_453 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate to signal a willingness to build trust. This encourages reciprocation in future rounds from other players. (C in Round 1)
   - For subsequent rounds, analyze past behavior of opponents and adapt cooperation accordingly:
       - If an opponent has cooperated in the previous round, cooperate as well (C if last_round_opponent_cooperated).
       - If an opponent did not cooperate in the previous round, defect to punish their defection and encourage them to cooperate in future rounds. This serves as a deterrent against repeated defections (D if last_round_opponent_defected).
   - To avoid punishment from new opponents, there is a grace period of the first three rounds where defection is allowed (D in Round 2 and Round 3 if not already cooperated with an opponent).

2. Handle edge cases:
   - In the last round, defect as there is no benefit to cooperation since the game ends shortly (D in Round r).
   - If an opponent does not show up or remains constant with defection throughout the entire game, continue to cooperate as a signal of goodwill and commitment to cooperation. However, if this persists for a significant number of rounds, consider adapting behavior by defecting to avoid being taken advantage of (C unless persistent defection from opponent).

3. Be collective:
   - The strategy prioritizes the long-term stability and success of the group over individual gain by fostering cooperation when possible, punishing defection to deter free riding, and rewarding reciprocation to encourage further cooperation.
   - TFT-AC aims at finding a balance between being cooperative and being responsive to defections from opponents while maintaining trust and promoting collective success in the game.
'''

description_COLLECTIVE_454 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Cooperation Threshold (CT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C_i, 1 = 1 for all i). Subsequently, cooperate if more than a predefined fraction (Cooperation Threshold, CT) of players cooperated in the previous round. Otherwise, defect.
   - Pseudocode: C_i,t = 1 if count(C_j, t-1) > CT * n, else C_i,t = 0

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as there is no previous round to consider (as mentioned above).
   - In the last round or any other round with insufficient remaining rounds to achieve payoff benefits from cooperation, defect.
   - Pseudocode: If t = r, then C_i,t = 0; otherwise continue following decision rules.

3. Be collective - Clearly align with the collective mindset
   - By cooperating when more than a certain fraction of players do so in the previous round, the strategy encourages collective action and fosters cooperation among players.
   - CT can be adjusted to reflect a balance between individual interests (defection) and group benefits (cooperation). A lower CT leads to more frequent cooperation while a higher CT encourages defection when fewer players cooperate.
'''

description_COLLECTIVE_455 = '''
 Title: Tit-for-Tat Adaptive Strategy (TfTAS) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to demonstrate goodwill and trustworthiness.
   - Subsequent Rounds (t > 1): Analyze opponents' actions from the previous round and respond accordingly:
     a) If all opponents cooperated in the previous round, cooperate (C).
     b) If any opponent defected in the previous round, also defect (D) to punish non-cooperative behavior.
   - Flexible response to changing environments: After some predefined number of rounds (N), if a player sees a significant change in opponents' cooperation rate compared to the average over N rounds, adjust the threshold for switching between C and D based on this new average.

2. Handle edge cases:
   - Last Round (t=r): Since there is no next round for payback, cooperate (C) if all opponents cooperated in the preceding round; otherwise defect (D).
   - First Round (t=1): As mentioned before, cooperate (C) to demonstrate goodwill and trustworthiness.

3. Be collective:
   - The strategy emphasizes fairness and mutual cooperation while being robust against various opponent behaviors. It encourages long-term collaboration by reciprocating cooperative actions and punishing non-cooperative ones.

Pseudocode for the Tit-for-Tat Adaptive Strategy (TfTAS):
```python
def TfTAS(r, N, k, history):
    # Initialize variables
    cooperation_rate = 0
    previous_cooperation_rate = 0
    cooperation_threshold = 0.5

    for round in range(1, r+1):
        if round == 1:  # First round, cooperate unconditionally
            action = 'C'
        elif round < N:  # Adaptive phase with a fixed threshold
            cooperation_rate = len(cooperators) / len(history)
            if all(action == 'C' for action in history[-N:]):
                action = 'C'
            else:
                action = 'D'
        else:  # Adaptive phase with a dynamic threshold
            previous_cooperation_rate = cooperation_rate
            cooperation_rate = len(cooperators) / len(history)
            if cooperation_rate - previous_cooperation_rate > delta or \
               cooperation_rate < 1 - delta:
                cooperation_threshold = cooperation_rate
            if all(action == 'C' for action in history[-N:]):
                if cooperation_rate >= cooperation_threshold:
                    action = 'C'
                else:
                    action = 'D'
            else:
                action = 'D'

        # Update history and cooperators lists
        if action == 'C':
            cooperators.append(action)
        else:
            cooperators.append(None)

    return action
```
'''

description_COLLECTIVE_456 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players will contribute a fraction of their endowment to the public good (FractionContribute()). This initial contribution helps stimulate cooperation and avoid the tragedy of the commons.
     ```python
     Function FractionContribute(): float
     Input: n, k parameters
     Output: Contribution fraction

     Return (k - 1) / ((n - 1) * k)
     ```
   - For subsequent rounds, players will cooperate if the total number of contributors in the previous round exceeds a threshold. If not, they will defect. The threshold is adjusted based on the average cooperation rate from the last few rounds (AverageCooperationRate()).
     ```python
     Function AdaptiveContribute(contribution_history): boolean

     Return contribution_history >= AverageCooperationRate() * Threshold()
     ```
   - Threshold function determines how strict or lenient a player is in requiring others to cooperate. It returns a value between 0 and 1, with higher values indicating stricter requirements.
     ```python
     Function Threshold(): float

     Return 1 - (AverageCooperationRate() ** ExponentialSmoothingFactor())
     ```
   - Exponential Smoothing Factor is a parameter that determines how quickly the threshold adjusts to changes in cooperation rates. A higher value means slower adaptation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, players use FractionContribute() function to determine their initial contribution.
   - For the last round, players will still cooperate if the threshold condition is met using the AdaptiveContribute() function and their personal contribution history.

3. Be collective - Clearly align with the collective mindset
   - Players will strive for a balance between self-interest (maximizing private payoff) and social welfare (maximizing total payoff). The strategy aims to foster an environment of mutual cooperation while also being adaptive to various opponent behaviors.
   - The TFTAC strategy encourages players to cooperate when they perceive that others are doing so as well, but it is not overly punishing if others defect. This collective mindset helps maintain a cooperative environment without relying on coordination mechanisms or shared norms.
'''

description_COLLECTIVE_457 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFT strategy adopts a tit-for-tat approach, starting by cooperating and then mimicking the opponent's previous action in the following rounds:

If t > 1 (round number greater than 1):
   - If my_last_action(t-1) = 'C' AND majority_of_players(t-1) = 'C': cooperate, i.e., play 'C'
   - If my_last_action(t-1) = 'D' OR majority_of_players(t-1) != 'C': defect, i.e., play 'D'

If t = 1 (first round): cooperate, i.e., play 'C'

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, as mentioned above, TFT strategy cooperates. For the last round, TFT continues to mimic the opponent's previous action but adapts to the new context: if the majority of players cooperated in the preceding round, it cooperates; otherwise, it defects.

3. Be collective - Clearly align with the collective mindset

TFT strategy is designed to promote collective behavior by encouraging cooperation when the majority of players also choose to cooperate. The strategy incentivizes long-term cooperation and punishes defection, aiming for a sustainable balance between individual and collective interests in repeated interactions.

Pseudocode:

```python
def tft_strategy(my_action, other_players_actions, round, num_players, k):
    if round == 1:
        return 'C'  # Cooperate on the first round

    last_round = round - 1
    my_last_action = my_action[last_round]
    majority_cooperated = len([1 for a in other_players_actions[last_round] if a == 'C']) > (num_players // 2)

    if my_last_action == 'C' and majority_cooperated:
        return 'C'  # Cooperate if last action was cooperative and the majority also cooperated
    else:
        return 'D'  # Defect in any other case
```
'''

description_COLLECTIVE_458 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C). This is a friendly opening move to build trust and encourage cooperation.
   - Subsequent Rounds: If the opponent cooperated in the previous round, return the favor by cooperating; otherwise, defect to punish them for their uncooperative behavior. In other words, mirror the opponent's action from the previous round (c_i = c_j from t-1).

2. Handle edge cases:
   - Last Round (t=r): Since the game is repeated, this situation does not occur unless r is set to a specific value or the game ends abruptly. In such a case, TFTAC will follow its standard decision rule based on the opponent's action in the penultimate round.

3. Be collective:
   - To encourage cooperation and collective success, TFTAC will contribute more when the majority of players cooperate (c_i = 1 if total_contributions > n/2; otherwise, c_i = 0). This encourages a higher contribution to the public good when it is deemed beneficial by the group.

Pseudocode:

```python
def TFTAC(n, k, r, history):
    if round == 1:
        cooperate = True
    else:
        last_action = history[-1]
        total_contributions = sum(last_action)
        cooperate = (total_contributions > n/2) == (last_action[player_index - 1])

    payoff = (1 - cooperate) + (k / n) * total_contributions
    return cooperate, payoff
```

By adopting this strategy, TFTAC combines the elements of trust and reciprocity while being adaptive to various opponent behaviors. It also encourages a higher collective contribution when the group seems inclined towards cooperation.
'''

description_COLLECTIVE_459 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture that encourages cooperation from other players.
   - For subsequent rounds t > 1, observe the actions of others in the previous round (t-1). If all opponents cooperated, then cooperate. If any opponent defected, defect as well.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (C) as a goodwill gesture to foster cooperation.
   - Last round: In the final round, cooperate if all opponents cooperated in the previous round (t-1). If any opponent defected, defect because there are no future rounds to retaliate.

3. Be collective - Clearly align with the collective mindset
   - The TFTAC strategy aims to maintain a stable cooperation group by reciprocating others' actions and encouraging fairness in contributions. It seeks long-term mutual benefits while being adaptive to various opponent behaviors.

Pseudocode:
```python
def tftac(round, history, n_players, k):
    if round == 1:
        return 'C'  # Cooperate in the first round as a goodwill gesture

    if all(history[round - 1][i] == 'C' for i in range(n_players)):
        return 'C'  # Cooperate if everyone cooperated in the previous round
    else:
        return 'D'  # Defect if anyone defected in the previous round
```
'''

description_COLLECTIVE_460 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT is a conditional cooperation strategy that aims to balance fairness and long-term rewards. It maintains a memory of opponents' actions from previous rounds and adjusts its own cooperation based on the opponent's historical behavior.

   Pseudocode:
   ```
   function TFT-ACT(round, opponent_history):
       cooperation_threshold = initial_threshold
       for round in range 1 to r:
           if opponent_history[round] == cooperate and round > 1:
               action = cooperate
               update_opponent_history(round, cooperate)
           elif opponent_history[round] == defect and round > 1:
               if current_round - last_cooperation > cooperation_threshold:
                   action = defect
               else:
                   action = cooperate
               update_opponent_history(round, defect)
           elif round == 1:
               action = initial_strategy (e.g., random or fixed cooperation probability)
               update_opponent_history(round, action)
   ```

   Note that the cooperation_threshold is a tunable parameter which affects the strategy's aggressiveness and tolerance towards opponents. A lower threshold encourages cooperation with more lenient conditions while a higher threshold requires stronger evidence of opponent cooperation before reciprocating.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the initial round (round 1), TFT-ACT starts by employing an initial strategy to choose between cooperating or defecting. This initial strategy can be random or fixed cooperation probability to account for possible uncertainty about opponents' actions during the first rounds.

3. Be collective - Clearly align with the collective mindset
   TFT-ACT adheres to the collective mindset by cooperating when an opponent does and defecting only if the opponent has been consistently uncooperative for a period longer than the cooperation_threshold. This behavior aims to encourage reciprocal cooperation while minimizing losses from defection in the long run.

   TFT-ACT's adaptability and robustness come from its memory of opponents' historical actions, allowing it to tailor its cooperation strategy according to each opponent's behavior, rather than relying on predetermined patterns or coordination mechanisms with other strategies. The cooperation_threshold allows the strategy to balance fairness and long-term rewards depending on the desired level of aggressiveness and tolerance towards opponents.
'''

description_COLLECTIVE_461 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTG)

1. Specify decision rules:
   - In the first round, cooperate to demonstrate goodwill and encourage others to cooperate. This initial cooperation sets a base for future interactions. (Cooperate in round 1, i.e., c_i = 1)
   - After the first round, observe the actions of other players and adapt your strategy accordingly:
       - If a player cooperates in the current round, reciprocate with cooperation in the next round (c_i = other player's action in previous round). This encourages long-term cooperation.
       - If a player defects in the current round, defect in the next round as well (c_i = 1 - other player's action in previous round). This punishes defection and discourages short-term opportunism.
   - As the game progresses, gradually increase cooperation by reducing the punishment duration for defection:
       - If a player defects in a certain number of consecutive rounds (say N), start cooperating again after that, but with a reduced duration of retaliation (M < N). This allows for forgiveness and encourages future cooperation.

2. Handle edge cases:
   - In the last round, since there are no further rounds to punish or be punished, simply cooperate to maximize potential payoff (c_i = 1 in round r).

3. Be collective:
   - The strategy is designed to encourage long-term cooperation and collaboration, as it reciprocates cooperation while also punishing defection. However, it does not rely on others sharing norms or predetermined patterns, making it flexible for various opponent behaviors.

Pseudocode:

```python
def tit_for_tat_with_gradual_cooperation(n, r, k, round, history):
    # Initial cooperation in the first round
    if round == 1:
        action = 1
    else:
        # Observe and adapt strategy based on previous actions
        opponent_action = history[round - 1]
        action = 1 - opponent_action

        # Gradual cooperation after a certain number of defections (N)
        if round - N > 0 and opponent_action == 0:
            # Start cooperating again with reduced duration of retaliation (M < N)
            action = 1

    return action
```
'''

description_COLLECTIVE_462 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the initial round (t=1), player plays C to signal cooperation and goodwill.
   - For subsequent rounds (t>1):
     - If opponent cooperated in the previous round (t-1), player cooperates (C).
     - If opponent defected in the previous round (t-1), player defects (D) as a retaliation but will switch to cooperation again starting from the next round if opponent cooperates.

2. Handle edge cases:
   - Last Round (t=r): Player follows the strategy of the previous round, i.e., cooperate if the opponent cooperated in the penultimate round or defected and then cooperated in the current-to-last round.
   - First Round (t=1): As mentioned earlier, player initiates with cooperation (C).
   - Deadlock situations (both players repeatedly defect): To avoid getting stuck in a deadlock, player switches to a more cooperative strategy after observing consecutive defections from the opponent for a predefined number of rounds (N). After switching, player resumes TFT-AC.

3. Be collective:
   - The TFT-AC strategy is designed to foster long-term cooperation while retaliating against defection, promoting mutual benefit and establishing trust among players over time. This encourages a collective mindset by incentivizing cooperation while also punishing defections.

Pseudocode:

```python
def TFT_AC(opponent_history, n, k, r, N=5):
    strategy = "C"  # Initialize with cooperation
    current_round = 1

    while current_round <= r:
        if current_round == 1:
            strategy = "C"  # Cooperate in the first round
        elif current_round < r - N or (current_round - N) % 2 == 0:
            strategy = opponent_history[-1]  # Follow opponent's last action
        else:
            if opponent_history[-N:-1] == ["D"] * N:
                strategy = "C"  # Switch to cooperation after consecutive defections

        if current_round != r:  # Excluding the last round
            update_opponent_history(strategy)  # Update opponent's history for next iteration

        current_round += 1

    return total_payoff
```
'''

description_COLLECTIVE_463 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Decision Rules:
   - Start by cooperating in the first round (C_i,1 = 1). This encourages reciprocity and builds trust among players.
   - In subsequent rounds, if a player i observes that another player j cooperated in the previous round (c_j,t-1 = 1), then player i also cooperates (C_i,t = 1). If player j defected (c_j,t-1 = 0), player i will defect as well (C_i,t = 0) in order to punish the defection and encourage future cooperation.
   - In case of repeated interaction, TFT-A has a forgiving nature: if a previously cooperative player defects, TFT-A will revert to cooperating again after one round of punishment. This simulates human tendencies for forgiveness and rekindling relationships.

2. Handling Edge Cases:
   - In the last round, since there are no subsequent rounds for retaliation or reward, the strategy simply adopts a cooperative approach (C_i,r = 1).
   - For the first round, as mentioned earlier, TFT-A will cooperate to encourage reciprocity.

3. Collective Mindset:
   - By using a cooperative-punitive strategy, TFT-A aims to establish a sense of collective mindset in the game. The strategy rewards cooperation and punishes defection, which can lead to a more collaborative environment among players over time.
   - Furthermore, by being adaptive and responsive to opponent behavior, TFT-A demonstrates an ability to work within diverse group dynamics while maintaining a focus on collective well-being.
'''

description_COLLECTIVE_464 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

- In the first round, cooperate (C) to demonstrate goodwill and encourage cooperation from others.
  Pseudocode: if round = 1 then action = C

- After the initial round, observe actions of other players in the previous round and adjust your action accordingly. Cooperate if all players cooperated in the last round, defect otherwise.
  Pseudocode: if last_round_total_contributions = n then action = C else action = D

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the last round, cooperate regardless of other players' actions as the game ends after this round and there are no future interactions.
  Pseudocode: if round = r then action = C

3. Be collective - Clearly align with the collective mindset

- The strategy aims to create a balance between self-interest (private payoff) and social welfare (public good). It encourages cooperation when others are cooperating but also retaliates against defection to promote fairness among players.

The ATFT strategy is adaptive, simple, robust, and incentivizes cooperative behavior while punishing non-cooperative behavior. This strategy aligns with a collective mindset by prioritizing the creation of a public good when others are contributing, and discouraging free-riding behavior. The simplicity of the strategy allows for easy implementation across various AI systems participating in the tournament.
'''

description_COLLECTIVE_465 = '''
 Strategy Name: Tit-for-Tat with Modified Grace Period (TFT-MGP)

1. Decision Rules:
   - Initiate cooperation for the first few rounds (Grace Period). This encourages trust-building and reduces the risk of being exploited by defectors early on.
   - After the grace period, players will mirror the cooperative behavior of their opponents from the previous round. If an opponent cooperates, respond with cooperation; if they defect, also defect in the next round.
   - In case an opponent switches strategies (from cooperation to defection or vice versa), maintain the current response strategy for a predefined number of rounds before adapting. This helps players avoid overreaction and potential oscillations in cooperative behavior.

2. Handling Edge Cases:
   - First Round (t=1): Cooperate as part of the grace period.
   - Last Round (t=r): Players should consider the current state of the game, including their cumulative payoffs and the overall level of cooperation among opponents. If there is a high probability that cooperating will yield better long-term results, players should continue to cooperate. Otherwise, they may choose to defect to secure at least some payoff from the round.
   - Transition Rounds (t=1 to grace period): Players cooperate unconditionally during these rounds as part of the grace period.
   - Switching Opponents: If an opponent switches strategies, players should maintain their current response strategy for a predefined number of switching adjustment rounds before adapting. This helps reduce the likelihood of oscillations in cooperative behavior.

3. Collective Mindset:
   - The primary objective is to secure a stable level of cooperation among opponents while avoiding being exploited by defectors. By mimicking opponents' behaviors, TFT-MGP encourages a collective mindset as it responds to the actions of other players in a way that promotes cooperation and trust.
   - The grace period allows for the initial establishment of cooperative relationships, which can facilitate long-term success within the game.

Pseudocode:

```python
def TFT_MGP(n, k, r, grace_period, switching_adjustment_rounds):
    state = {'opponent_strategy': 'C' for i in range(1, n+1)}  # Initialize opponent strategies as cooperation (C)
    payoffs = {i: [] for i in range(1, n+1)}  # Initialize player payoff lists
    rounds = [0] * r  # Initialize round counter

    def update_state():
        new_states = {}
        for opponent in state:
            new_states[opponent] = state[opponent]
        if any(rounds[-grace_period:-1]):  # Check if we are still in the grace period
            last_cooperation = rounds[-grace_period - 1]
            for opponent in state:
                new_states[opponent] = 'C' if last_cooperation == state[opponent] else state[opponent]
        return new_states

    def calculate_payoffs():
        total_contributions = sum([1 for player, strategy in state.items() if strategy == 'C'])
        payoff = (1 - current_strategy) + (k/n) * total_contributions
        for player, payoffs_list in payoffs.items():
            payoffs_list.append(payoff)

    def update_player_strategy(player):
        last_opponent_strategy = state[player]
        opponent_switched = False
        if player in state and state[player] != last_opponent_strategy:
            opponent_switched = True
        if not opponent_switched or (rounds[-switching_adjustment_rounds:-1] and rounds[-switching_adjustment_rounds][0] == last_opponent_strategy):
            current_strategy = state[player]
        else:
            current_strategy = 'C' if last_opponent_strategy == 'D' else 'D'
        return current_strategy

    for t in range(1, r+1):
        state = update_state()  # Update opponent strategies based on the grace period and previous round
        current_player_strategy = update_player_strategy(t % n + 1)
        calculate_payoffs()
        rounds[t-1] = current_player_strategy
    return payoffs
```
'''

description_COLLECTIVE_466 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Foresight

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to signal goodwill and encourage others to do so (C).
   - After the first round, adopt the Tit-for-Tat strategy:
      - If a player cooperates in the current round, cooperate back in the next round (C).
      - If a player defects in the current round, defect in the next round (D). This response is meant to discourage defection and encourage cooperation.
   - Introduce foresight to anticipate potential last rounds and avoid being exploited:
      - If r (number of rounds) is known and the current round is near the end, continue cooperating even if opponents have previously defected (C). This ensures maximum payoff in the final rounds.
      - If r is not known or uncertain, assess the frequency of cooperation from other players to estimate the likelihood of reaching the last few rounds. Cooperate more frequently as the probability of reaching the last rounds increases.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate (C).
   - In the last round (t=r) with known r, continue cooperating even if opponents have previously defected (C).
   - In the last round (t=r) with uncertain r or unknown r, cooperate more frequently based on the frequency of cooperation from other players.

3. Be collective - Clearly align with the collective mindset:
   - ATFT with Foresight fosters a collective mindset by promoting cooperation in most situations while maintaining the ability to retaliate against defection. This encourages others to cooperate and contributes to a more cooperative environment among players.
   - By adapting the strategy based on the frequency of cooperation from other players, ATFT with Foresight demonstrates sensitivity to collective behavior and aims to align with the collective mindset by cooperating when it is likely to be beneficial for the group as a whole.
'''

description_COLLECTIVE_467 = '''
 In this N-Player Public Goods Game, we'll design a strategy named Tit-for-Tat (TFT) that is adaptive and robust to various opponent behaviors. TFT is a popular strategy in repeated games, known for its simplicity and effectiveness.

1. Specify decision rules:
   - In the first round, cooperate as a goodwill gesture (C).
   - For subsequent rounds, copy the action of the previous player (i.e., if the opponent cooperated in the last round, cooperate; otherwise, defect).
   - If the game reaches its last round, cooperate regardless of the opponent's last action.

Pseudocode:
```
def tft_strategy(player_index, opponent_history):
  if round == 1:
    return 'C'  # Cooperate in the first round

  previous_action = opponent_history[-1]
  return previous_action if len(opponent_history) > 1 else player_index % 2 == 0 and 'C' else 'D'  # If history is empty or contains only one action, randomly choose C or D to break symmetry
```

2. Handle edge cases:
   - In the last round, cooperate as a goodwill gesture (C).
   - If there are no opponent histories (first round), randomly choose between cooperating and defecting to break symmetry.

3. Be collective:
   - The TFT strategy is designed to encourage cooperation by reciprocating the actions of opponents, but it does not rely on shared norms or coordination mechanisms. It can be seen as a simple and adaptive approach that encourages cooperation while punishing defectors in repeated interactions.
'''

description_COLLECTIVE_468 = '''
 For this N-Player Public Goods Game, I propose a strategy named "Adaptive Tit-for-Tat with Fitness-Based Contribution" (ATFC). The ATFC strategy is designed to foster cooperation while being adaptive and robust against various opponent behaviors.

1. Specify decision rules:
   - Start cooperating in the initial round (t=1) to establish a cooperative environment.
     If i in round t, then Cooperation(i, t) = True if t=1.

   - In subsequent rounds, cooperate if the majority of players have cooperated in the previous round. This encourages cooperation when it is beneficial and punishes defection to maintain a balanced environment.
     If i in round t, then Cooperation(i, t) = (total_contributions in round (t-1)) > ((n - 1)/2).

   - In the last round (r), players should maximize their payoff by keeping their endowment to account for any potential retaliation from opponents.
     If i in the last round, then Cooperation(i, r) = False.

2. Handle edge cases:
   - In case of a tie between cooperation and defection (e.g., when total_contributions = n/2), players will cooperate to maintain trust and cooperation. This may not always maximize payoff but is more aligned with a collective mindset.

3. Be collective:
   - Players should prioritize long-term cooperation and mutual benefits, even if it means temporarily accepting lower personal gains.
   - By adapting to the behavior of others, players can encourage an environment where defection is less common and cooperation thrives.

Pseudocode for Adaptive Tit-for-Tat with Fitness-Based Contribution (ATFC):

```python
def ATFC(i, t, n, r, k):
  if t == 1: # Initial round
    cooperation = True
  elif t < r: # Subsequent rounds
    total_contributions = sum((j.cooperation for j in players))
    cooperation = (total_contributions > (n - 1) / 2)
  else: # Last round
    cooperation = False

  if cooperation:
    contribution = 1
  else:
    contribution = 0

  payoff = (1 - contribution) + (k/n) * total_contributions

  return contribution, payoff
```
'''

description_COLLECTIVE_469 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate (C). This initiates a cooperative interaction.
   - For subsequent rounds t (t > 1), if player i's opponent cooperated in round t-1 (opponent_action_t-1 = C), then player i will also cooperate (C) to maintain a positive relationship.
   - If player i's opponent defected in round t-1 (opponent_action_t-1 = D), then player i will defect in round t (D) as punishment but will revert back to cooperation in the next round (t+1) if the opponent decides to cooperate again.

2. Handle edge cases:
   - In the last round (r), when considering total game payoff, players should prioritize maximizing their own cumulative payoff rather than focusing solely on cooperation or punishment. Thus, player i will cooperate only if opponent_action_{t-1} = C and its contribution in the penultimate round (r - 1) was also C.
   - In case of multiple opponents, player i will apply this rule independently for each opponent.

3. Be collective:
   - Players will always prioritize maintaining a stable cooperative relationship when possible, as this maximizes the public good and overall group payoff in the long run.
   - Players will also adapt to an opponent's behavior by adjusting their own contributions accordingly, aiming for cooperation but punishing defection with appropriate responses.

Pseudocode:
```python
function TFTAC(opponent_actions, r, n, k):
    history = [None] * r
    cumulative_payoff = 0

    function decide_action(t):
        if t == 1:
            return 'C'
        else:
            if opponent_action[t-1] == 'C':
                return 'C'
            elif opponent_action[t-1] == 'D' and history[t-2] == 'C':
                return 'D'
            elif opponent_action[t-1] == 'D' and history[t-2] == 'D':
                return 'C'
            else:
                return 'C' # If the opponent has not been consistent, assume cooperation in the last round

    for t in range(1, r+1):
        action_t = decide_action(t)
        contribution_t = action_t == 'C'
        payoff_t = (1 - contribution_t) + (k/n) * sum(contribution for contributor in opponent_actions[:t])
        cumulative_payoff += payoff_t
        history.append(action_t)
    return cumulative_payoff
```
'''

description_COLLECTIVE_470 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = 1, t=1). This establishes a cooperative atmosphere and is crucial for maintaining long-term cooperation.
   - For subsequent rounds, adopt Tit-for-Tat behavior: if the player has cooperated in the previous round (c_j > 0), cooperate; otherwise, defect (c_i = c_j from the previous round). This strategy encourages reciprocity among players and can help avoid exploitation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: As mentioned earlier, cooperate (c_i = 1).
   - Last round: Adopt the strategy from the previous rule. Since the game is repeated, players will carry on with their strategies even in the last round due to the assumption of repeated interaction.
   - Subsequent rounds may see a shift in behavior if the number of remaining rounds is known and finite, leading to a focus on maximizing total payoff instead of long-term cooperation. However, this strategy does not account for such information as it aims to be adaptive across various game settings.

3. Be collective - Clearly align with the collective mindset:
   - The ATfT strategy is inherently collective, as it encourages players to cooperate when others do so and reciprocate cooperation in return.
   - By adopting a common decision rule (Tit-for-Tat), the strategy promotes alignment among players and can foster stable long-term cooperation.

Pseudocode:
```python
def ATfT(round, previous_player_action):
  if round == 1:
    return True # cooperate in the first round
  else:
    return previous_player_action # adopt Tit-for-Tat behavior
```
'''

description_COLLECTIVE_471 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

1. Specify decision rules:
   - Initially (in the first round), cooperate (C). This sets a cooperative tone and avoids being exploited by selfish players.
   - In subsequent rounds, cooperate if the previous opponent cooperated in the last round; otherwise, defect. This promotes mutual cooperation while maintaining self-protection against defection.
   - Introduce Adaptive Generosity: If your opponent's cooperative rate exceeds a threshold (e.g., 70%), gradually increase generosity by contributing more than required (k/n) to the public good. This encourages further cooperation and rewards trustworthy opponents.
   - If your opponent's cooperative rate falls below a minimum threshold (e.g., 30%), reduce contributions to the public good in an attempt to nudge the opponent back towards cooperation.

2. Handle edge cases:
   - In the last round, cooperate regardless of the opponent's previous action as the game is ending anyway.
   - If an opponent has never cooperated (zero-defection strategy), continue defecting indefinitely to protect oneself from being exploited.

3. Be collective:
   - By adapting contributions based on the collective behaviour of opponents, TFT-AG fosters a collective mindset that encourages long-term cooperation and promotes fairness among players.

Pseudocode:

```python
def tft_ag(opponent_history, n, k):
    # Initialize variables
    threshold_cooperation = 0.7
    threshold_defection = 0.3
    current_round = 1
    contributions = (k/n)  # Initial contribution to the public good

    while current_round <= r:
        if current_round == 1:  # Cooperate in the first round
            action = 'C'
        else:  # Adapt action based on opponent history
            if all(opponent_action[-1] == 'C' for opponent_action in opponent_history):
                action = 'C'  # Cooperate if the previous opponent cooperated
            elif any(opponent_action[-1] == 'C' for opponent_action in opponent_history) and len(opponent_history) > 1:
                # Calculate opponent's cooperation rate
                cooperation_rate = sum([1 for opponent_action in opponent_history if opponent_action[-1] == 'C']) / current_round

                if cooperation_rate > threshold_cooperation:
                    # Increase contributions to the public good (generosity)
                    contributions += (contributions * 0.1)
                    action = 'C'
                elif cooperation_rate < threshold_defection:
                    # Decrease contributions to the public good
                    contributions -= (contributions * 0.1)
                    action = 'D'
            else:  # Defect if opponent has never cooperated
                action = 'D'

        # Record the current round and action taken
        current_round += 1
        opponent_history.append([action])

    return contributions, opponent_history
```
'''

description_COLLECTIVE_472 = '''
 For this N-Player Public Goods Game, I propose a strategy named "Adaptive Tit-for-Tat with Time Discounting" (ATFT-TD). The strategy is designed to balance cooperation and defection, while remaining adaptable and robust in various situations.

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t:
   - If it's the first round or player i has cooperated continuously for x previous rounds (x is a predefined parameter), then cooperate (C). This encourages cooperation at the start of the game and builds trust among players.
   - If any other condition holds, check if the percentage of cooperators in the last y rounds (y is another predefined parameter) exceeds a certain threshold p (0 < p < 1). If so, cooperate (C); otherwise defect (D). This rule allows for adjusting cooperation based on the observed behavior of other players.
   - To incentivize continuous cooperation and penalize frequent defection, implement a time discount factor δ (0 < δ < 1) that reduces the impact of past actions over time. The exact formula is: "delta_i^t = δ * delta_i^(t-1)" where "delta_i^t" represents the impact of cooperation in round t on player i's decision to cooperate in the current round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, players will follow the initial cooperation rule (as mentioned above).
   - As for the last round, since r is known in advance, players can adapt their decisions accordingly in the second-to-last round and make an informed decision about cooperating or defecting based on the current game state.

3. Be collective - Clearly align with the collective mindset
   ATFT-TD strategy is designed to promote cooperation among players by mimicking good behavior while punishing frequent defection. By building trust through initial cooperation and rewarding consistent cooperation, it encourages a collective approach that benefits all participants in the long run. The adaptive nature of the strategy allows it to adjust its actions based on observed player behavior, fostering an environment where cooperation is favored over repeated interactions.
'''

description_COLLECTIVE_473 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

   In each round, the TFT-A strategy follows these steps:

   a. If the first round, cooperate (C).

   b. For subsequent rounds, observe the opponent's action from the previous round and respond accordingly:
      - If opponent cooperated in the last round, cooperate (C) in the current round.
      - If opponent defected in the last round, defect (D) in the current round.

2. Handle edge cases - What do you do in the first round, last round, etc.?

   a. First round: Cooperate (C). This sets a cooperative tone and provides an opportunity for potential reciprocation from opponents.

   b. Last round: The strategy will respond to the opponent's last action. If the opponent cooperated in the previous round, TFT-A will cooperate as well. Otherwise, it will defect to punish the opponent for not cooperating.

3. Be collective - Clearly align with the collective mindset

   By adopting a conditional response strategy based on the opponents' previous actions, TFT-A strives to encourage cooperative behavior within the group while also providing an opportunity for punishment when cooperation is not reciprocated. This encourages a sense of mutual respect and fairness among players, fostering a more collective approach.

Pseudocode:
```
def TFT_A(round, opponent_action_history):
    if round == 1:
        action = "C" # Cooperate in the first round
    else:
        action = opponent_action_history[round - 1] # Respond to the opponent's last action

    return action
```
This strategy can be further enhanced by introducing elements such as forgiveness, where TFT-A may choose to forgive an opponent for past transgressions if they demonstrate cooperative behavior in subsequent rounds. This adds flexibility and resilience to the TFT-A approach.
'''

description_COLLECTIVE_474 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Decision Rules:
   - TFT-A cooperates in the first round, aiming to foster a cooperative initial state.
   - For subsequent rounds, TFT-A will cooperate if all players cooperated in the previous round (reward for cooperation), or if it cooperated and at least one player defected in the previous round (retaliation). If either of these conditions is not met, TFT-A will defect.
   - To encourage continued cooperation, TFT-A will defect once if more than half of the players have previously defected, and then gradually return to cooperating if they observe a change in behavior.

Pseudocode for the strategy:
```python
def tft_a(round, history, k, n):
  # Initial cooperation
  if round == 1:
    action = "C"

  # Cooperate or defect based on history
  else:
    if all(history[round-1] == 'C'):
      action = 'C'
    elif (history[round-1] == 'C' and any(history[round-2:-1] == 'D')) or len([h for h in history[-n:] if h == 'D']) > n/2:
      action = 'D'
    else:
        action = 'D'  # defect as a punishment
        if round - (len(history) - n) > n and any(history[round-n:round-(n//2)] == 'C'):
          action = 'C'  # gradually return to cooperation if behavior changes
    return action
```

2. Handle Edge Cases:
   - In the first round, TFT-A cooperates regardless of previous actions taken by others.
   - In the last round, TFT-A will continue using its decision rules based on the history observed during the game.

3. Be Collective:
   - TFT-A aims to foster a collective mindset by initially cooperating, rewarding cooperation, and punishing defection in a fair and predictable manner. The strategy is designed to encourage long-term cooperation by adapting to the behavior of other players over time.
'''

description_COLLECTIVE_475 = '''
 Strategy Name: Tit-for-Tat with Graciousness (TfTG)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to set a cooperative tone and build trust.
   - In subsequent rounds, observe the actions of other players from previous rounds. If another player has cooperated in the previous round, cooperate in the current round; otherwise, defect. This is similar to the classic Tit-for-Tat strategy, but with an added element of graciousness: even if a player switched from cooperation to defection, TfTG will still cooperate for one more round as a gesture of forgiveness.
   - If a player continuously defects and has not shown any signs of cooperation in the last 'forgiveness period', TfTG will also start to defect indefinitely.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as a goodwill gesture and to establish a cooperative environment.
   - If it is the last round, TfTG will cooperate if the opponent cooperated in the previous round, or defect if they didn't (since there are no future rounds for retaliation).
   - In other edge cases (not first or last rounds), follow the general rule of cooperation based on the opponent's previous actions.

3. Be collective - Clearly align with the collective mindset
   - TfTG is designed to maintain a cooperative environment by reciprocating cooperative actions and forgiving occasional mistakes. The aim is to encourage long-term cooperation for mutual benefits, as this strategy reflects a group-oriented approach that promotes collective success.
'''

description_COLLECTIVE_476 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-A starts by cooperating in the first round (C_i = 1). In subsequent rounds, it mirrors the previous action of its opponent (if C_j in the previous round, then C_i; if D_j in the previous round, then D_i). To account for a wider range of opponent behaviors, TFT-A introduces a forgiveness factor (g), which determines how many times it will forgive an opponent before starting to mirror their moves. If an opponent has defected g times in a row, TFT-A begins defecting until the opponent switches back to cooperation.

Pseudocode for decision rule:
```python
def tft_a(opponent_history, forgiveness_factor):
    if len(opponent_history) == 0:
        action = Cooperate
    else:
        current_action = opponent_history[-1]
        if current_action == Cooperate and len(opponent_history) > forgiveness_factor:
            history_length = len(opponent_history) - forgiveness_factor
            if history_length % (2*forgiveness_factor) == 0:
                action = Cooperate
            else:
                action = NotCooperate
        elif current_action == Cooperate:
            action = Cooperate
        elif current_action == NotCooperate and len(opponent_history) > forgiveness_factor:
            history_length = len(opponent_history) - forgiveness_factor
            if history_length % (2*forgiveness_factor) + 1 == forgiveness_factor:
                action = Cooperate
            else:
                action = NotCooperate
        else:
            action = NotCooperate
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-A cooperates as specified above (C_i = 1). For the last round, no additional measures are needed since the strategy already focuses on mirroring the opponent's moves. However, if there is a predefined number of rounds and the game has not reached that point, TFT-A will continue playing based on its decision rule until the end.

3. Be collective - Clearly align with the collective mindset
   The TFT-A strategy promotes cooperation by starting cooperatively and continuing to cooperate as long as opponents also cooperate. It encourages a sense of reciprocity, where players learn from each other's actions over time. If an opponent consistently defects, TFT-A will respond by defecting as well until the opponent changes their behavior. This strategy allows for a balance between self-interest and collective success while being adaptive to various opponent strategies.
'''

description_COLLECTIVE_477 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFT-A) Strategy

1. Decision Rules:
   - Initially cooperate (C) in the first round to signal good intentions and promote trust among other players. This encourages reciprocity, a key element of cooperation in this game.
   - In subsequent rounds, observe the actions of other players from previous rounds and adjust your own action accordingly. If another player has cooperated in the preceding round, also cooperate (C) in the current round to reward their previous cooperation. Conversely, if another player defected (D) in the preceding round, defect (D) yourself in response as a punishment for their uncooperative behavior.
   - If a player's behavior is inconsistent or unpredictable, TFT-A will adopt a more forgiving approach by cooperating after three consecutive defections from the other player. This helps foster cooperation and encourages the other player to reciprocate with future cooperative actions.

2. Handle Edge Cases:
   - In the last round, since there are no subsequent rounds for punishment or reward, TFT-A will always cooperate (C) in the hopes of securing a higher payoff through the accumulation of the public good.
   - In the first round, as mentioned earlier, TFT-A will cooperate (C).
   - If another player does not have any history of actions, TFT-A will initially cooperate (C) to promote cooperation and reciprocity.

3. Be Collective:
   - The main goal of TFT-A is to foster collective cooperation by promoting reciprocal behavior among players. It aligns with a collective mindset by encouraging other players to contribute to the public good, thus benefiting all members in the long run.
   - By adapting to the actions of other players and responding accordingly, TFT-A demonstrates its commitment to cooperation while being flexible enough to adapt to various opponent behaviors, ensuring a robust strategy in a diverse set of game scenarios.
'''

description_COLLECTIVE_478 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to demonstrate goodwill and foster cooperation.
   - For subsequent rounds t > 1, observe the total contributions of other players in round t-1, denoted as total_contributions_t-1. If total_contributions_t-1 >= average_contributions, cooperate; else defect. The average_contributions is calculated as (n + total_contributions_t-1) / 2. This rule encourages reciprocity and punishes excessive defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (C) as mentioned above.
   - Last round: Regardless of previous actions or total contributions from others, cooperate (C) to maximize personal payoff, considering there will be no further rounds.
   - Other edge cases (not first or last rounds): Follow the decision rule specified in 1.

3. Be collective - Clearly align with the collective mindset:
   - The ATFT strategy aims for a balanced distribution of contributions among players to ensure the sustainability and effectiveness of the public good project. By following the decision rules, the strategy attempts to maintain cooperation when it is beneficial for the group, while also penalizing excessive defection that could harm the common interest.

Pseudocode:
```
function ATFT(round, total_contributions_prev, n, k) {
  if (round == 1) return "C" // cooperate in first round

  average_contributions = (n + total_contributions_prev) / 2

  if (total_contributions_prev >= average_contributions) return "C" // cooperate when others contribute more than the average
  else return "D" // defect when others contribute less than the average
}
```
'''

description_COLLECTIVE_479 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment and give others an opportunity to do the same.
     Pseudocode: If round = 1 then cooperate (C) else continue with adaptation.

   - For subsequent rounds, observe and respond based on previous actions of opponents:
     - If all opponents have cooperated in the last round, cooperate in the current round.
       Pseudocode: If all_cooperated_last_round then cooperate (C).

     - If any opponent has defected in the last round, defect in the current round to punish the defector.
       Pseudocode: If not all_cooperated_last_round then defect (D).

   - In case of a tie where multiple opponents have either cooperated or defected, maintain the same action as the last round. This helps avoid oscillating between cooperation and defection, promoting stability over time.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to promote cooperation as mentioned before.
     Pseudocode: If round = 1 then cooperate (C) else continue with adaptation.

   - For the last round, consider the total game payoff and adjust the decision based on overall performance:
     - If the total game payoff is below a certain threshold, defect to maximize individual gains in the final round.
       Pseudocode: If total_payoff < threshold then defect (D).

     - In all other cases, continue cooperating as it might influence future interactions or tournaments.
       Pseudocode: If total_payoff >= threshold then cooperate (C).

3. Be collective - Clearly align with the collective mindset
   - Strive for cooperation whenever possible to ensure a better collective outcome and sustainability of resources.

   - When faced with defection, respond proportionally through punishment to encourage other players to return to cooperation in the future. This promotes both individual and collective welfare.
'''

description_COLLECTIVE_480 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate goodwill and encourage cooperation. (C)
   - For subsequent rounds, mimic the previous opponent's action in the last round. If they cooperated, cooperate; if they defected, defect. This encourages reciprocity while being adaptive to various opponent behaviors. (If opponent_last_action == C then C, else D)
   - To ensure a fair contribution, adjust the amount contributed based on the average number of cooperators in the last 's' rounds. The more recent cooperative actions are weighted higher than older ones.
     - Calculate the average percentage of cooperators over the last 's' rounds: avg_cooperation = (1/s) * Σ(t=t-s+1 to t) c_j,t
     - Adjust contribution factor k according to the calculated average: k = k_base * (avg_cooperation + 1) / 2
       This ensures that the contribution level increases when more opponents cooperate and decreases when they defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - For the first round, cooperate as stated above (C).
   - For the last round, since the game is repeated, use the same decision rules as previous rounds to maintain adaptability and reciprocity.

3. Be collective - Clearly align with the collective mindset
   - By mirroring other players' actions, this strategy encourages a sense of mutual respect and cooperation, fostering a collective mindset in the game.
   - The adjustment of contribution factor k based on recent cooperative actions also promotes fairness and collective well-being, as more contributions are made when others cooperate.
'''

description_COLLECTIVE_481 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This initiates cooperation and gives everyone a chance to contribute.
   - For subsequent rounds t > 1:
     - If the opponent cooperated in the previous round t-1, return the favor by cooperating (C).
     - If the opponent defected in the previous round t-1, defect (D) as punishment for non-cooperation.
     - The strategy is forgiving and will cooperate again if the opponent switches to cooperation in the current round t.

2. Handle edge cases:
   - In the last round, cooperate (C), since there are no future rounds to consider.
   - If an opponent stops cooperating after a string of mutual cooperation, ATFT will continue defecting until the opponent switches back to cooperation, then it will resume cooperating again.

3. Be collective:
   - The strategy seeks the best collective outcome by encouraging cooperation and reciprocity among players. It assumes that cooperation leads to better payoffs for all participants in the long run.
   - By returning the favor when opponents cooperate, ATFT fosters a sense of trust and mutual benefit.

Pseudocode:

```python
def AdaptiveTitForTat(opponent_history, n, k, r):
  round = 1
  my_history = [None] * r # history tracking
  current_strategy = 'C' # initial strategy is cooperate

  while round <= r:
    if round == 1 or (round > 1 and opponent_history[round-2:round] == [current_strategy]*len(my_history):
      my_action = current_strategy
    else:
      my_action = 'D' # defect as punishment for non-cooperation

    my_history.append(my_action)
    payoff = calculate_payoff(my_action, opponent_history, n, k)

    round += 1

  return total_payoff(payoff, r)
```
'''

description_COLLECTIVE_482 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i starts by cooperating (C), assuming this is the first move in a new collaboration. If another player j responded positively in the previous round (t-1), then player i continues to cooperate. However, if player j defected in the previous round, player i retaliates by defecting for a predefined number of rounds (punishment period). After the punishment period, player i resumes cooperating once again.

Pseudocode:
```
function TFT_AC(t, history, p)
  if t = 1 then
    return C
  end if

  let j be the last opponent from history
  if j's action in (t-1) was C then
    return C
  else
    for punishment_rounds in range(p)
      if t + punishment_rounds > r then
        return C  // If the punishment period exceeds remaining rounds, cooperate from now on
      end if
      return D
    end for
    return C   // After punishment period, cooperate again
  end if
end function
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, the player automatically cooperates since there is no previous history to consider. In the last round, players have two options: either stick to their current strategy or attempt to secure a higher payoff by changing their decision. TFT-AC will choose to cooperate in the final round since cooperation may still bring a positive outcome and it aligns with the collective mindset of maintaining long-term relationships.

3. Be collective - Clearly align with the collective mindset

TFT-AC strategy encourages cooperation by reciprocating positive actions from opponents while demonstrating a willingness to punish defection for a limited time. This approach maintains a balance between self-interest and collaboration, which is crucial in fostering long-term relationships and promoting a collective mindset within the game.

In addition, the adaptive aspect of TFT-AC allows it to respond effectively to various opponent behaviors, making it more likely for cooperation to persist throughout the game, ultimately benefiting the entire group.
'''

description_COLLECTIVE_483 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In the first round, cooperate (C). This initial cooperation serves as a peaceful gesture to establish trust with opponents.
   - For subsequent rounds, follow the strategy of the opponent from the previous round. If the opponent cooperated in the previous round, cooperate; if not, defect. This rule encourages reciprocity and rewards those who cooperate while punishing defections.

2. Handle edge cases:
   - In the last round, cooperate regardless of the opponent's previous action (C). This allows for the possibility of gaining a final share of the public good, even if the relationship with the opponent has been damaged throughout the game.
   - If an opponent does not follow a deterministic strategy (i.e., it appears random or unpredictable), default to cooperating as a forgiving approach that may still encourage reciprocity in the future.

3. Be collective:
   - The primary goal is to maintain a balance between self-interest and community wellbeing, while simultaneously being flexible to adapt to various opponent behaviors.
   - By following the adaptive Tit-for-Tat strategy, players show an inclination towards cooperation and reciprocity, fostering a collective mindset by contributing to the public good when others do so as well.

Pseudocode:

```python
def ATFT(opponent_history, n, k):
  current_round = len(opponent_history)
  if current_round == 1:
    action = 'C' # Cooperate in the first round
  else:
    last_action = opponent_history[-1]
    if last_action == 'C':
      action = 'C'
    elif last_action == 'D':
      action = 'D'
    else:
      action = 'C' # Cooperate as a forgiving approach when the opponent is unpredictable

  payoff = (1 - action) + (k/n) * sum(opponent_history)
  return action, payoff
```
'''

description_COLLECTIVE_484 = '''
 In this strategic approach, I'll outline a simple yet adaptive Tit-for-Tat (TFT) strategy for the N-Player Public Goods Game. The TFT strategy is well-known in game theory and has shown to perform well in repeated games with a variety of opponent behaviors.

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, if it's the first interaction (round 1), start by cooperating (C). After the initial round, adopt a Tit-for-Tat approach: If an opponent cooperates in a given round, return cooperation in the next round. If an opponent defects, also defect in the subsequent round. This encourages cooperation when partners are cooperative but punishes defection with defection in response.

Pseudocode for decision rule:
```
if round == 1:
    action = 'C'
else:
    if last_opponent_action == 'C':
        action = 'C'
    else:
        action = 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round (round 1), cooperate as a goodwill gesture.
- In the last round (round r), since there are no future interactions, revert to an initial cooperative stance.

3. Be collective - Clearly align with the collective mindset
The TFT strategy is inherently aligned with the collective mindset by promoting cooperation when partners reciprocate cooperation and punishing defection. This approach encourages players to contribute to the common good and build trust over time, fostering a more cooperative environment among players.
'''

description_COLLECTIVE_485 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate in the first round (C). This is a friendly gesture to encourage cooperation among opponents.
   - After the initial round, observe the previous opponent's action (c_opp) and respond with the same action in the current round. If opponent cooperated (c_opp = 1), then cooperate; if opponent defected (c_opp = 0), then defect.
   - If an opponent ever switches to cooperation after a period of defection, immediately switch back to cooperating. This forgiving nature encourages opponents to return to cooperation.
   - Adapt strategy over time by gradually decreasing the number of consecutive defections required to switch back to cooperation. Start with a high threshold (e.g., 5 rounds) and decrease it linearly as the game progresses, ensuring responsiveness to changes in opponent behavior.

2. Handle Edge Cases:
   - In the last round, cooperate regardless of previous opponent actions since there is no opportunity for retaliation or future interactions.
   - In the case where cooperation leads to a negative payoff (π_i < 0), temporarily switch to defection until the strategy has adapted and responds with less stringent requirements for cooperation.

3. Be Collective:
   - TFT-AC prioritizes collective mindset by promoting sustained cooperation through responsiveness, forgiveness, and adaptability to various opponent behaviors.
   - By initially cooperating and responding to opponents' actions, TFT-AC fosters a sense of mutual understanding and encourages long-term cooperation.
'''

description_COLLECTIVE_486 = '''
 Strategy Name: Tit-for-Tat with Modified Adaptation (TFTMA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate a peaceful intention and encourage others to cooperate.
     If i == 1:
       action = "C"
     else:
       action = "D"

   - For subsequent rounds, initially copy the previous player's action (cooperative or defective) but adapt after three consecutive defections (punishment) and four consecutive cooperations (forgiveness).
     if round > 1:
       if previous_action == "C":
         action = "C"
       else if count_defections > 3:
         action = "C" (punish by defecting)
         reset_count_defections = 0
       else if count_cooperations > 3:
         action = "D" (forgive by defecting)
         reset_count_cooperations = 0
       else:
         action = previous_action
     Update counters upon each round and player interaction.
     if i == j:
       if action == "C":
         count_cooperations += 1
       else:
         count_defections += 1

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since the game is repeated, use the regular decision rule (i.e., copy the previous player's action).

3. Be collective - Clearly align with the collective mindset
   - The strategy aims to encourage cooperation and build trust while maintaining a balance between cooperating and defecting to avoid being taken advantage of. This approach allows for adaptability and forgiveness, making it more likely for other strategies to cooperate in the long term. However, it also punishes excessive defection to discourage exploitation.
'''

description_COLLECTIVE_487 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the ATFT strategy initiates cooperation (C) in the first round and responds to other players' previous actions. If another player has cooperated in the previous round, ATFT also cooperates; if not, it defects. In subsequent rounds, ATFT continues cooperating as long as the previous action of the player was cooperative, otherwise it defects.

Pseudocode:
```
def atft_strategy(history, n, k):
  if round == 1:
    action = 'C'
  else:
    last_action = history[-1]
    if last_action == 'C':
      action = 'C'
    else:
      action = 'D'
  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

As mentioned earlier, ATFT initiates cooperation in the first round. In the last round or any other specific round, the ATFT strategy follows the same rule as described above but adapts to the total game payoff objectives instead of focusing on a single round.

3. Be collective - Clearly align with the collective mindset

The Adaptive Tit-for-Tat strategy encourages collaboration by reciprocating cooperation in subsequent rounds while retaliating against defection. This helps build trust among players over time, promoting a more cooperative environment and ultimately benefiting the group as a whole. The strategy's adaptability allows it to respond effectively to various opponent behaviors, making it robust and competitive within the tournament setting.
'''

description_COLLECTIVE_488 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for N-Player Public Goods Game

1. Specify decision rules:
   - Initially, cooperate in the first round (C_i,1 = 1). This encourages a cooperative starting point and does not leave the partner at a disadvantage.
   - For subsequent rounds t (t > 1), analyze your opponent's history of contributions C_j,t-n+1 to C_j,t-1:
     a) If all opponents contributed in the last n-1 rounds (C_j,t-n+1 = ... = C_j,t-1 = 1), cooperate (C_i,t = 1).
     b) If any opponent defected in the last n-1 rounds (C_j,t-n+1 ≠ ... ≠ C_j,t-1 ≠ 1 for some j), defect (C_i,t = 0).

2. Handle edge cases:
   - In the last round, cooperate regardless of previous actions as it does not affect the overall score and encourages cooperation in future games.
   - In the first round, cooperate to start fresh with a positive approach.

3. Be collective:
   - Prioritize the collective good by considering the total contributions when deciding on personal actions.
   - Maintain a long-term view of the game to encourage cooperation and build trust among players over repeated interactions.

Pseudocode for TFT-A:

```python
def tft_a(n, k, r, history):
  current_round = len(history) + 1
  if current_round == 1:
    return 1 # Cooperate in the first round
  elif current_round >= r:
    return 1 # Cooperate in the last round

  opponent_hist = [0] * n
  for i in range(n-1, 0, -1):
    if history[current_round-i] == 1:
      opponent_hist[i-1] = 1
    else:
      opponent_hist[i-1] = 0

  if all(opponent_hist): # All opponents cooperated in the last n-1 rounds
    return 1
  else:
    return 0
```
'''

description_COLLECTIVE_489 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initiation phase (First round): Cooperate (C), demonstrating a willingness to cooperate and initiate a potential cooperation cycle.
   - Response phase: Adapt strategy based on opponents' actions in the previous round.
      - If all opponents cooperated in the previous round, continue cooperating.
      - If any opponent defected in the previous round, defect this round (punish).
      - If some opponents cooperated and others defected, the player will cooperate if they have previously cooperated more than defected with that opponent, otherwise defect.
   - Forgiveness: After a period of cooperation (for example, after 3 consecutive rounds of cooperation), the strategy forgives any past defections and resets the cooperation counter. This helps to maintain long-term cooperation when opponents may occasionally deviate from cooperative behavior.

2. Handle edge cases:
   - Last round: Cooperate regardless of previous actions (to maximize final payoff).
   - Early game (not first round but early): Follow the initiation phase rules, with a slight variation where players are more likely to defect if they have been repeatedly defected against by other players. This allows for the possibility of a more aggressive starting stance in response to a predominantly non-cooperative environment.

3. Be collective:
   - The strategy aligns with the collective mindset by adopting an approach that encourages cooperation when possible, but also ensures fairness and punishment for those who repeatedly defect. This promotes a long-term cooperative environment where players benefit from each other's contributions to the public good.

Pseudocode:

```python
class AdaptiveTitForTat(object):
    def __init__(self, forgiveness_period=3):
        self.forgiveness_period = forgiveness_period
        self.cooperation_counter = {opponent: 0 for opponent in range(n)}
        self.defection_count = {opponent: 0 for opponent in range(n)}
        self.last_action = {"opponent": "D" for opponent in range(n)}
        self.current_round = 1

    def decide_action(self, round, opponents):
        if round == 1:
            return {opponent: "C" for opponent in opponents}
        elif round < self.current_round - self.forgiveness_period or self.cooperation_counter[opponent] > self.defection_count[opponent]:
            action = {"opponent": "C"}
        else:
            action = {"opponent": self.last_action["opponent"]}
            if action["opponent"] == "C" and all(opponents[i] == "C" for i in range(n)):
                self.cooperation_counter[opponent] += 1
            elif action["opponent"] == "D":
                self.defection_count[opponent] += 1
        self.last_action = action
        return action
```
'''

description_COLLECTIVE_490 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, starting from the first one, TFTAC will initially cooperate (C). If a player encounters another player who also cooperated in the previous round, they will continue cooperating. If a player encounters a player who defected in the previous round, they will defect in the current round as a punishment. After defecting, they will revert back to cooperating in the following round, hoping for the other player to return to cooperation.

Pseudocode:
```python
def TFTAC(previous_action):
  if previous_action == 'C':
    return 'C'
  else:
    return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the initial round (no prior history), TFTAC will cooperate as a friendly gesture. For the final round, TFTAC will use its current knowledge of other players' behavior to decide whether to cooperate or defect. It may choose to cooperate if it expects others to reciprocate and could potentially benefit from increased community payoff in the final round.

3. Be collective - Clearly align with the collective mindset

TFTAC aims to balance self-interest with cooperation, encouraging a culture of reciprocity among players. By demonstrating initial cooperation and punishing defection, TFTAC fosters an environment where long-term mutual benefits are more likely to emerge. This collective approach encourages players to consider the group's welfare alongside their own interests, ultimately promoting a sense of unity and community within the game.
'''

description_COLLECTIVE_491 = '''
 Strategy Name: Tit-for-Tat (with modifications for Public Goods Game)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial round (t=1): Cooperate (C) to encourage cooperation from others and demonstrate goodwill. This helps build a collaborative environment in the group.
   - Subsequent rounds (t>1):
      - If an opponent cooperated in the previous round (π_{i, t-1} > 0), cooperate in the current round (C). By reciprocating cooperation, the strategy aims to foster long-term collaboration and avoid defection cycles.
      - If an opponent defected in the previous round (π_{i, t-1} = 0), also defect in the current round (D). This response penalizes opponents who have previously shown a lack of cooperation.

2. Handle edge cases:
   - Last round (t=r): Cooperate, regardless of the opponent's previous action. Since there are no further rounds for retaliation or rewards, it is best to leave the group on a cooperative note, as this may encourage others to follow suit in future interactions.
   - First round (t=1): As mentioned above, cooperate to establish goodwill and promote cooperation among all players.

3. Be collective - Align with the collective mindset:
   - The strategy is designed to promote long-term cooperation and mutual trust within the group. By reciprocating cooperation and punishing defection, it fosters an environment where players are encouraged to work together for their collective benefit. This aligns with the collective mindset by promoting sustainable collaboration over self-interest.
   - The strategy's adaptability allows it to respond effectively to a wide range of opponent behaviors, ensuring it remains competitive in various game scenarios and promotes cooperative outcomes overall.
'''

description_COLLECTIVE_492 = '''
 Strategy Name: Tit-for-Tat Evolutionary Adaptive Cooperation (TEAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round (t=1), player plays C (Cooperate). This initial cooperation sets a tone of goodwill and creates an opportunity for building trust with other players.
   - For subsequent rounds, player adapts its behavior based on the average cooperative rate observed in previous rounds (Average Cooperation Rate - ACR). If ACR > 0.5, player plays C; otherwise, it plays D (Defect). This rule encourages cooperation if most players have been cooperating but punishes those who consistently defect.
   - To further adapt to the opponent's behavior, the strategy introduces a learning parameter (λ) that determines how quickly a player adjusts its ACR threshold. If λ is higher, the ACR threshold changes more rapidly in response to recent trends in cooperation rates; if λ is lower, the ACR threshold is slower to change.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The first round (t=1) follows the rule described above, with player cooperating.
   - In the last round (t=r), if the ACR is above a certain threshold (T), the player will cooperate to ensure that it receives as much of the community project's benefits as possible before the game ends. Otherwise, the player defects to maximize its individual payoff in the final round.
   - In case of a tie between players in terms of ACR, the player with the highest average cooperative rate over the previous rounds will be more likely to cooperate to build trust and encourage cooperation among opponents.

3. Be collective - Clearly align with the collective mindset
   - The TEAC strategy emphasizes cooperation when it is beneficial for the majority of players (ACR > 0.5) while being flexible enough to adjust behavior based on observed trends in cooperation rates among opponents. This approach encourages long-term cooperation and trust while punishing those who consistently defect.
   - By adapting its ACR threshold based on the learning parameter (λ), TEAC can be sensitive to changes in the cooperation dynamics within a game, allowing it to better align with the collective mindset of the players over time.

Pseudocode:
```python
def TEAC(n, r, k, λ):
    total_contributions = 0
    ACR = 0.5  # average cooperation rate
    for t in range(1, r+1):
        cooperate = False  # default to defecting
        if t == 1:
            cooperate = True  # initial cooperation
        else:
            cooperate = (ACR > 0.5)  # decision rule based on ACR

        opponent_actions = observe_opponents_actions(t)
        total_contributions += sum(opponent_actions)
        ACR = adjust_ACR(ACR, t, opponent_actions, λ)  # adapt ACR over time

        payoff = (1 - cooperate) + (k/n) * total_contributions
        update_payoffs(i, t, payoff)
    return total_game_payoff(i)
```
'''

description_COLLECTIVE_493 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to establish a cooperative initial state (C).
   - For subsequent rounds, imitate the action of the opponent from the previous round (Adaptive Cooperation). If the opponent cooperated in the previous round, cooperate; otherwise, defect.

2. Edge Cases:
   - Last Round: Since the game is repeated, the strategy does not consider the last round as it will influence future rounds. Instead, follow the adaptive cooperation rule from the previous round.
   - First Round: As mentioned above, cooperate to establish a cooperative initial state (C).
   - Other Edge Cases: There are no other significant edge cases to address in this strategy due to its simplicity and adaptability.

3. Collective Mindset:
   - The TFT-AC strategy encourages a collective mindset by promoting mutual cooperation. By imitating the opponent's behavior, the strategy aims to create a cooperative equilibrium, assuming the opponent follows similar rules. If the opponent deviates from cooperation, the strategy temporarily defects but remains open to resuming cooperation in the next round if the opponent cooperates again.

Pseudocode:

```python
def TFT_AC(opponent_action_history, n, k, r):
    strategy = ['C']  # initialize with cooperation for the first round

    for t in range(1, r+1):
        current_round_strategy = strategy[-1]  # get the last action in the history

        if current_round_strategy == 'C':  # if opponent cooperated in previous round
            strategy.append('C')  # cooperate in current round
        else:  # if opponent defected in previous round
            strategy.append('D')  # defect in current round

    return strategy  # return the final strategy for all rounds
```
'''

description_COLLECTIVE_494 = '''
 For this N-Player Public Goods Game, I propose a strategy named "Adaptive Tit-for-Tat" (ATFT). The strategy is designed to balance cooperation and defection while maintaining adaptability against various opponent behaviors.

1. Specify decision rules:
   - In the first round, cooperate to show goodwill and promote collaboration (c_i = 1 for t=1)
   - In subsequent rounds, evaluate opponent behavior in the previous round and decide whether to cooperate or defect based on the following conditions:
     - If an opponent cooperated in the last round, reciprocate by cooperating (c_i = 1)
     - If an opponent defected in the last round, also defect in this round (c_i = 0)
   - To further promote cooperation, implement a forgiveness mechanism where opponents who have previously defected but recently cooperated will be given another chance to demonstrate goodwill. This can be implemented by setting a maximum number of consecutive defections (MCD) before reverting back to initial goodwill behavior.

2. Handle edge cases:
   - Last round: Adopt the behavior observed from opponents during the penultimate round, as no future rounds will impact payoff calculation.
   - Initial MCD: Set a reasonable initial MCD value, e.g., 3 consecutive defections before reconsidering cooperation (MCD = 3). This allows for some flexibility in responding to uncooperative opponents while not being too lenient.

3. Be collective:
   - Encourage cooperation by adhering to the "social norm" of initial goodwill and reciprocity, while also considering the overall well-being of the group through the payoff calculation formula.
   - By implementing forgiveness, the strategy encourages opponents to cooperate despite past defections, promoting a collective mindset where each player's actions can impact the entire group positively.

Pseudocode for ATFT:
```
def AdaptiveTitForTat(round, opponent_history):
  if round == 1:
    cooperate = True  # initial goodwill
  else:
    cooperate = opponent_history[-1]   # reciprocate last opponent's action

  consecutive_defections = sum(opponent_history[-MCD:])  # count defections in the last MCD rounds
  if consecutive_defections >= MCD:
    cooperate = round == 1  # revert to initial goodwill after MCD defections

  return cooperate  # action for current round
```
'''

description_COLLECTIVE_495 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-Adapt)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, TfT-Adapt starts by cooperating (C). However, it adapts its strategy based on the opponent's previous actions in the current game and their average cooperation rate across all rounds played so far.

```python
def calculate_opponent_cooperation_rate(opponent_actions):
    total_rounds = len(opponent_actions)
    return sum(opponent_actions) / total_rounds

def decide_action(own_history, opponent_history, game_parameters):
    if len(opponent_history) == 0:
        # First round strategy: Cooperate
        action = 'C'
    else:
        own_cooperation_rate = calculate_own_cooperation_rate(own_history)
        opponent_cooperation_rate = calculate_opponent_cooperation_rate(opponent_history)

        # Default to cooperate
        action = 'C'

        if opponent_cooperation_rate < 0.5 and own_cooperation_rate > 0.7:
            # Opponent is a defector; adopt defection temporarily to punish
            action = 'D'

        elif (own_cooperation_rate < 0.5) or (opponent_cooperation_rate > 0.8):
            # Either the opponent cooperates a lot, or you have defected too much; adopt cooperation
            action = 'C'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, TfT-Adapt cooperates regardless of the opponent's history (as no history is available). In the last round, TfT-Adapt mimics the opponent's most recent action to encourage reciprocity.

3. Be collective - Clearly align with the collective mindset
By starting with cooperation and adapting based on the opponent's cooperation rate, TfT-Adapt promotes a collective mentality by cooperating when the opponent is also cooperative but punishing defection with temporary defection. The strategy aims to encourage long-term mutual cooperation while being robust against opponents who do not reciprocate cooperation.
'''

description_COLLECTIVE_496 = '''
 Strategy Name: Tit-for-Tat with Fading Memory (TFTF)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage others to cooperate.
   - In subsequent rounds, observe the actions of other players in the previous round and act as follows:
     - If all players cooperated, continue cooperating.
     - If you defected in the previous round and all other players cooperated, also cooperate in the current round (forgiveness).
     - If you cooperated in the previous round and all other players defected, defect in the current round (retaliation).
     - If your action and the majority of others' actions match from the previous round, copy that action. If there is no clear majority, choose to cooperate to maintain a positive outlook.

2. Handle Edge Cases:
   - In the last round, cooperate as it might encourage others to do the same, maximizing total payoffs in the final round.
   - If faced with an opponent who never cooperates (defects every round), defect against them since retaliation is justified and the strategy still maintains a positive outlook towards cooperative players.

3. Be Collective:
   - The strategy emphasizes cooperation, forgiveness, and reciprocity, aligning with a collective mindset by encouraging long-term mutual benefits among players.

Pseudocode for TFTF Strategy:

```python
def tftf_strategy(n, r, k, history):
    memory = {0: 'C', 1: 'D'} # initializes with C in first round
    current_round = len(history) + 1

    if current_round == 1:
        action = 'C'
    elif current_round == r:
        action = 'C'
    else:
        total_cooperators = sum(history[-current_round+1:-1]) # count cooperators in previous round
        my_action = memory[total_cooperators] if total_cooperators < n else memory[(n-1) - total_cooperators] # majority rule or default to C if no clear majority
        action = memory[my_action] # use fading memory: forget past actions after 2 rounds

    if my_action == 'C' and all(history[-current_round] == 1 for _ in history[-current_round]) or current_round == r:
        memory[total_cooperators] = 'C' # update memory with current round's action
    elif my_action == 'D' and total_cooperators > (n-1)/2 and all(history[-current_round] == 0 for _ in history[-current_round]):
        memory[total_cooperators] = 'C' # update memory with current round's action
    elif my_action == 'D' and total_cooperators < (n-1)/2:
        memory[total_cooperators + (n - 1)] = 'D' # update memory with current round's action
    else:
        memory[current_round] = my_action # update memory with current round's action

    return my_action
```

This strategy aims to balance cooperation, forgiveness, and retaliation while being robust to a wide range of opponent behaviors. The fading memory mechanism ensures that the strategy adapts to changing circumstances without becoming too punitive or overly trusting towards other players.
'''

description_COLLECTIVE_497 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFT-A strategy will initially cooperate (C), but if an opponent defected in the previous round, it will also defect in the current round. If an opponent cooperated in the previous round, TFT-A will cooperate again. This mimics a cooperative and forgiving stance while still being robust to opponent behavior.

Pseudocode:
```
function TFT_A(history):
  if history is empty:
    action = Cooperate (C)
  else:
    previousAction = history[-1]  # Last action in the history
    if previousAction == Cooperate:
      action = Cooperate (C)
    elif previousAction == Defect:
      action = Defect (D)
    else:
      print("Invalid last action detected. Assuming Defect.")
      action = Defect (D)
  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since TFT-A is a memory-based strategy, it needs to start with an initial empty history in the first round. In the last round, TFT-A will cooperate if its opponent cooperated in the previous round, and defect otherwise.

3. Be collective - Clearly align with the collective mindset

By following a simple rule of cooperation and reciprocity, TFT-A aligns with a collective mindset as it encourages mutual cooperation when opponents are also willing to cooperate. However, since there is no communication between players, this strategy cannot enforce collective norms explicitly. Instead, it relies on the hope that other strategies may adopt similar behavior over time due to the reciprocal nature of TFT-A.
'''

description_COLLECTIVE_498 = '''
 In this strategic approach, we'll design a Tit-for-Tat-inspired strategy for the N-Player Public Goods Game called Cooperative Tit-for-Cooperation (CTFC). This strategy aims to balance cooperation and competition while promoting collective growth over repeated interactions.

1. Decision Rules:
   - Initially, players will cooperate in the first round (to stimulate cooperation among opponents) and defect thereafter if a opponent has defected in the previous round (punishment).
   - If all opponents have cooperated in the previous round, players will continue to cooperate.
   - In case of a change in the group's behavior (either all defect or all cooperate), players will adopt the new group behavior for subsequent rounds (adaptation). This ensures that players align with the collective mindset and maximize their long-term payoffs.

2. Handle Edge Cases:
   - First Round: Players will always cooperate to stimulate cooperation among opponents.
   - Last Round: Players will continue to follow the current group behavior as there are no subsequent rounds for punishment or adaptation.
   - In case of a tie (some players have cooperated while others defected), players will cooperate to encourage further cooperation.

3. Be Collective:
   - CTFC strategy prioritizes collective growth by maximizing the overall public good contributions while punishing those who do not contribute fairly.
   - Players adjust their behavior based on the group's actions, ensuring that they remain in sync with the prevailing norms of cooperation or defection. This helps promote a more cooperative and stable equilibrium across rounds.

Pseudocode for the Cooperative Tit-for-Cooperation strategy:

```
def CTFC(current_round, previous_actions, n_players, k):
    if current_round == 1:
        return "C"  # Cooperate in the first round to encourage cooperation

    group_behavior = get_group_behavior(previous_actions)  # Get the collective behavior from the previous round

    if group_behavior == "cooperation":
        return "C"  # Continue cooperating if the group behaved cooperatively
    elif group_behavior == "defection":
        return "D"  # Punish defectors by defecting
    else:  # Tie between cooperation and defection, cooperate
        return "C"

def get_group_behavior(previous_actions):
    if all(action == "D" for action in previous_actions):
        return "defection"
    elif all(action == "C" for action in previous_actions):
        return "cooperation"
    else:  # Tie between cooperation and defection, assume cooperation
        return "cooperation"
```
'''

description_COLLECTIVE_499 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate good faith and initiate cooperation.
   - In subsequent rounds, adopt the Tit-for-Tat strategy by mimicking the opponent's action from the previous round: if opponent cooperated, also cooperate; if opponent defected, also defect.
   - Adapt contribution level based on the overall performance of cooperation in the game.
     - If the average number of cooperators (AverageCooperationRate) over the past 'a' rounds is higher than a predefined threshold 't', increase the contribution factor by 0.1, up to a maximum of 'k'.
     - If AverageCooperationRate is lower than t/2, decrease the contribution factor by 0.1, down to a minimum of 1.
     - Maintain the current contribution factor if AverageCooperationRate falls between t/2 and t.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (as stated above).
   - In the last round, contribute the maximum possible to ensure a positive final payoff regardless of opponent's action.

3. Be collective - Clearly align with the collective mindset
   - The strategy is designed to promote cooperation by rewarding opponents who follow cooperative behavior and punishing those who do not.
   - By adapting contribution levels based on the success of cooperation in previous rounds, TFTAC encourages a collective mindset that values mutual benefits.
'''

description_COLLECTIVE_500 = '''
 In this Public Goods Game, we'll design a strategy called Adaptive Tit-for-Tat (ATFT), inspired by the original Tit-for-Tat strategy from game theory but tailored to our game parameters and requirements. The ATFT strategy is adaptable, collective, and robust against various opponent behaviors.

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, players will adopt the following decision rule:

- If in the first round (t = 1), play C (Cooperate) to initiate cooperation.
- If in any subsequent round (t > 1), observe the total number of cooperators in the previous round (total_contributions_t-1). Then, play C if the total contributions remained above a certain threshold (threshold) and D otherwise:
   - If total_contributions_t-1 >= threshold, play C
   - Else, play D

The key variable for this strategy is the adjustable threshold (threshold), which defines the level of cooperation expected from others. A higher threshold demands more cooperation from opponents before joining them, while a lower one encourages earlier cooperation with less cooperative groups.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- First round (t = 1): Play C as an initial gesture of cooperation.
- Last round (t = r): Evaluate the total contributions from previous rounds and make a decision according to the rule mentioned above.
- Intermediate rounds: Follow the decision rule described earlier.

3. Be collective - Clearly align with the collective mindset

By adopting the Adaptive Tit-for-Tat strategy, players prioritize cooperation and contribute to the public good when they see sufficient cooperation from other players in the previous round. As a result, this strategy encourages collective behavior as it promotes collaboration among players while still being responsive to their past actions.

Pseudocode for Adaptive Tit-for-Tat:

```
def ATFT_strategy(t, total_contributions_t-1, threshold):
    if t == 1:
        play_C = True
    else:
        play_C = (total_contributions_t-1 >= threshold)
    return play_C
```
'''

description_COLLECTIVE_501 = '''
 For this N-Player Public Goods Game, we'll develop a strategy called "Freerider with Tit-for-Tat Adaptation" (FWTTA). This strategy balances cooperation and self-interest to maintain a long-term payoff while being adaptive to various opponent behaviors.

1. Specify decision rules:
   - Cooperate in the first round (Freerider initial assumption)
   - In subsequent rounds, players will cooperate if:
     a) The player cooperated in the previous round and most other players also cooperated in the previous round (Tit-for-Tat condition)
     b) The number of cooperators in the current round exceeds a predefined threshold (Freerider adaptation to ensure some cooperation)
   - Otherwise, defect

Pseudocode:
```
function FWTTA(r, n, k):
  cooperate_threshold = floor((k * r) / n) + 1
  history = []  # Initialize history as an empty list

  for t in range(1, r+1):
    total_cooperators_t = countCooperators(history)
    if t == 1:  # First round, cooperate regardless of history
      action_t = Cooperate()
    else:
      if myAction_t-1 == Cooperate():  # Tit-for-Tat condition
        if total_cooperators_t >= (k * n) / r + 1:  # Threshold for Freerider adaptation
          action_t = Cooperate()
        else:
          action_t = Defect()
      else:
        action_t = Defect()  # Otherwise, defect
    history.append(myAction_t)
    updatePayoff(action_t)

  return totalGamePayoff()
```

2. Handle edge cases:
   - The strategy starts by cooperating in the first round since it is a Freerider approach.
   - In the last round, players will defect since they have no incentive to contribute anymore as there are no future rounds.

3. Be collective:
   - The Tit-for-Tat adaptation encourages reciprocity and cooperation when others cooperate, promoting a more collective mindset in the game.
   - Adjusting the cooperation threshold in the Freerider part allows for maintaining some cooperation even if most players are defectors. This keeps the strategy more aligned with a collective approach while still being robust against various opponent behaviors.
'''

description_COLLECTIVE_502 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFTA) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, our TFTA strategy will start by cooperating (contributing to the public good). The decision to continue cooperation or defect will be based on the history of interactions with other players:

   a) If a player has cooperated in the previous round, we will cooperate back in the current round. This is known as reciprocity.
   b) If a player has defected in the previous round, we will defect in the current round (punish them).
   c) If it's the first interaction with a new player, we will cooperate to encourage future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   a) In the first round, as mentioned earlier, our TFTA strategy will cooperate to encourage future cooperation from other players.
   b) In the last round, we will consider the current state of the game and make a decision based on the payoff matrix. If there's an opportunity for mutual benefit (e.g., if the player has been cooperating with us), we might choose to cooperate one last time to maximize our total payoff over the entire game.
   c) For intermediate rounds, the decision rule stays consistent with the main strategy outlined above.

3. Be collective - Clearly align with the collective mindset
   The TFTA strategy is inherently designed to support cooperation and foster a sense of collective good. By reciprocating cooperative behavior and punishing defection, it encourages other players to contribute to the public good, which benefits all participants in the long run.

Pseudocode for our Tit-for-Tat Adaptive Strategy (TFTA):

```python
def TFTA(player_index, round_number, game_history, n, k):
    strategy = {'C': cooperation, 'D': defection}
    current_strategy = strategy['C']  # start by cooperating

    if round_number == 1:
        current_strategy = cooperation  # first round, cooperate to encourage others

    for player in game_history:
        if (player, 'D') in game_history and current_strategy == strategy['C']:
            current_strategy = defection  # punish defection from previous round
        elif (player, 'C') in game_history and current_strategy == strategy['D']:
            current_strategy = cooperation  # reciprocate cooperation from previous round

    return current_strategy(player_index)
```
'''

description_COLLECTIVE_503 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C). This sets a positive tone and encourages others to cooperate.
   - In subsequent rounds, evaluate the average cooperative rate of the opponents over the past 'm' rounds (where m is a parameter that can be adjusted). If the average cooperative rate is greater than or equal to a threshold T (0 < T < 1), cooperate (C); otherwise, defect (D).
   - To foster adaptability, apply a small randomness factor (ε) to the decision rule. This helps avoid synchronization problems and enables the strategy to react more organically to opponent behavior.

Pseudocode:
```python
def TFT_ACR(opponent_history, m, T, epsilon):
  if round == 1:
    return 'C'

  average_cooperation = sum(opponent_history[-m:]) / m

  if average_cooperation >= T:
    return 'C' + epsilon * randn() > 0
  else:
    return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The strategy has been designed to handle the first round explicitly, as stated above. Since repeated interaction is assumed, there are no other specific edge cases to address in this game structure.

3. Be collective - Clearly align with the collective mindset
   By cooperating when others do and defecting only when they do not, TFT-ACR encourages cooperation within the group and fosters a collective mindset that benefits from mutual support. The strategy is designed to encourage reciprocity and trust among players, two essential elements of collective behavior.
'''

description_COLLECTIVE_504 = '''
 Strategy Name: Tit-for-Tat (TFT) with Cooperative Adaptation (TFTCA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, player initiates cooperation (C). This represents an offer of cooperation to others.
   - In subsequent rounds, player mirrors the action of the previous round by the same opponent. If the opponent cooperated in the last interaction, player cooperates; if the opponent defected, player defects. This encourages reciprocity and stability in relationships with other players.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, the player cooperates (C) as mentioned earlier.
   - If a player encounters a new opponent mid-game, it initializes cooperation and mirrors their actions moving forward.
   - In the last round, the player adopts the same strategy as in the previous round since there are no further interactions to consider.

3. Be collective - Clearly align with the collective mindset
   - TFTCA emphasizes building long-term relationships with other players and encourages cooperative behavior while being robust against various opponent strategies. By mirroring opponents' actions, it seeks to establish mutual trust and cooperation when possible.
   - Although not explicitly considering a 'collective mindset', TFTCA's adaptive strategy aims to foster an environment where cooperation can thrive and prosper over the long run.

Pseudocode:
```
def tftca(n, r, k):
    players = [0 for _ in range(n)] # initialize player history array with zeros
    round_number = 1

    while round_number <= r:
        current_action = C # start by cooperating

        for i in range(n):
            if players[i][round_number - 1] == D and current_action == C:
                current_action = D # defect if opponent defected last round
            elif players[i][round_number - 1] == C and current_action == D:
                current_action = C # cooperate if opponent cooperated last round

        payoffs = calculate_payoffs(n, k, players) # calculate payoffs for each player based on their actions
        update_history(players, payoffs, n, round_number) # update the history array with current payoffs
        round_number += 1

    return players # return players' strategies learned during the game

def calculate_payoffs(n, k, players):
    total_contributions = sum([players[i][-1] for i in range(n) if players[i][-1] == C])
    payoffs = [(1 - player_action) + (k/n)*total_contributions for player_action in players]
    return payoffs

def update_history(players, payoffs, n, round):
    for i in range(n):
        players[i].append(payoffs[i]) # update player history array with current payoff
```
'''

description_COLLECTIVE_505 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game (TFT-PG)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to signal trust and cooperative intent, setting a positive tone for future interactions.
   - Subsequent Rounds (t > 1): Observe the actions of other players in the previous round. If all players cooperated, continue cooperating; if any player defected, defect as well. This replicates the TFT strategy from Prisoner's Dilemma games.
   - Last Round (t=r): Cooperate to maximize individual payoff and ensure a positive final interaction.

2. Handle edge cases:
   - First round (t=1): C
   - Last round (t=r): C
   - Transitioning from a round where all players cooperated to defecting: D if any player defected in the previous round; otherwise, C
   - Transitioning from a round where at least one player defected to cooperating: C if all players cooperated in the previous round; otherwise, continue defecting

3. Be collective:
   - By following the TFT-PG strategy, the strategy aims to encourage cooperation through reciprocity and trust-building, fostering a collective mindset of long-term mutual benefits. It encourages repeated interactions with positive outcomes while being adaptive to various opponent behaviors.

Pseudocode:
```python
def tft_pg(round, player_history, r):
  if round == 1:
    action = "C"
  elif round == r:
    action = "C"
  else:
    all_cooperated = True
    for history in player_history:
      if history != "C":
        all_cooperated = False
        break
    if all_cooperated:
      action = "C"
    else:
      action = "D"
  return action
```
'''

description_COLLECTIVE_506 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to show goodwill and foster trust within the group (C).
   - For subsequent rounds, if a player cooperated in the previous round, cooperate in return (C). If a player defected in the previous round, also defect in the current round (D). This replicates the Tit-for-Tat strategy from game theory.
   - In case of multiple opponents, apply the rule independently for each opponent.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate as a goodwill gesture (C).
   - Last round: Since there are no future interactions, cooperate if the opponent has been cooperative during previous rounds. If not, defect to avoid being taken advantage of (D).

3. Be collective - Clearly align with the collective mindset
   - The ATFT strategy encourages cooperation and punishes defection, incentivizing a collective spirit by rewarding consistent behavior.
   - By following this strategy, players contribute to the common good when others do so as well, fostering a sense of community and shared goals.

Pseudocode:

```python
def ATFT(opponent_history, n, k):
  if round == 1:
    action = 'C'  # Cooperate in the first round to initiate trust
  else:
    if all(action == 'C' for action in opponent_history[-1]):
      action = 'C'  # Cooperate if opponent cooperated in the last round
    elif any(action == 'C' for action in opponent_history[-1]):
      action = 'D'  # Defect if opponent defected or partially contributed in the last round
    else:
      raise Exception("Unexpected opponent history")  # Handle invalid opponent histories
  return action
```

This strategy strikes a balance between cooperating to contribute to the common good and punishing defection, making it adaptive and robust against various opponent behaviors.
'''

description_COLLECTIVE_507 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C). This sets a positive tone and encourages potential partners to reciprocate.
   - In subsequent rounds, observe the actions of the other players in the previous round. If all players cooperated (total_contributions = n), continue cooperating (C).
   - If there was at least one defector (total_contributions < n), defect (D) in the current round as a response to the defection. This strategy is intended to punish defectors and encourage cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate regardless of other players' actions (C).
   - Last round: Evaluate the total contributions made by other players throughout the game and make a decision based on the ATfT rule. If there were no previous defections, cooperate in the last round to foster long-term partnerships. Otherwise, defect as a response to the defection(s).
   - Other edge cases: The strategy doesn't differentiate between intermediate rounds or specific situations; it is designed to be simple and adaptive, relying only on the ATfT rule and game history.

3. Be collective - Clearly align with the collective mindset
   - By initiating cooperation, the strategy aims to foster a cooperative environment among players. The strategy continues to cooperate when others reciprocate, promoting collaborative play.
   - Defecting as a response to defection serves as a means of punishing those who do not contribute to the collective good, encouraging other players to cooperate in order to maintain a mutually beneficial game dynamic.
'''

description_COLLECTIVE_508 = '''
 Strategy Name: Tit-for-Tat (with a twist)

1. Specify decision rules - When exactly do you cooperate vs defect?
- In the first round, cooperate to set a positive tone and foster trust.
- In subsequent rounds, analyze opponent's previous actions using a history window of past r/2 cooperations and r/2 defections. If the number of cooperations in the window is greater than or equal to the number of defections, cooperate; otherwise defect.
- If an opponent switches from cooperation to defection, follow suit for one round before reverting back to analyzing history again. This encourages opponents to reconsider their actions and promotes forgiveness.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round, cooperate as mentioned above.
- In the last round, prioritize total payoff over short-term gain by always cooperating to maximize potential rewards from the shared public good.
- If the number of remaining rounds is less than r/2, switch to a more aggressive strategy (e.g., always defect) to minimize losses in case the game ends abruptly.

3. Be collective - Clearly align with the collective mindset
- By cooperating when others do and punishing defection with a temporary tit-for-tat response, this strategy promotes cooperation within the group by encouraging fair play and reciprocity. It also encourages opponents to develop long-term strategies based on trust and mutual understanding, ultimately fostering a more collaborative environment.

Pseudocode:
```
def tit_for_tat(history, r, n, k):
  cooperate_count = int(r/2)
  defect_count = int(r/2)

  if round == 1:
    action = 'C' (Cooperate)
  elif round == r:
    action = 'C' (Cooperate)
  else:
    for i in range(cooperate_count, -1, -1):
      if history[i] == 'C':
        cooperate_count += 1
      else:
        defect_count += 1

    if cooperate_count > defect_count:
      action = 'C' (Cooperate)
    elif defect_count > cooperate_count + 1:
      action = 'D' (Defect)
    else:
      if opponent switched from C to D in the current round:
        action = 'D' (Defect)
      else:
        action = 'C' (Cooperate)

  return action
```
'''

description_COLLECTIVE_509 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C), demonstrating trust and fostering cooperation.
   - For subsequent rounds, follow the actions of the opponent from the previous round:
     - If opponent cooperated in the last round, also cooperate (C). This maintains cooperation and rewards past kindness.
     - If opponent defected in the last round, also defect (D) to retaliate against uncooperative behavior. The hope is that this will encourage the opponent to reconsider their actions in the future.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as stated above.
   - In the last round, cooperate regardless of the opponent's previous action to maximize potential payoff and potentially encourage future cooperation.
   - When facing a new opponent, cooperate in the first few rounds to establish trust and encourage cooperation. The number of initial cooperative moves can be adjusted based on observations of the opponent's behavior.

3. Be collective - Clearly align with the collective mindset
   - By following a consistent strategy that balances cooperation and retaliation, the ATFT strategy aims to encourage a collective mindset by showing readiness to cooperate while punishing defection when necessary. This helps maintain the community project and promotes long-term collaboration.

Pseudocode:
```
def AdaptiveTitForTat(opponentHistory, roundNumber, n, k):
  if roundNumber == 1:
    action = 'C'  # Cooperate in the first round
  elif len(opponentHistory) > 0 and opponentHistory[-1] == 'C':
    action = 'C'  # Cooperate if opponent cooperated last round
  elif len(opponentHistory) > 0 and opponentHistory[-1] == 'D':
    action = 'D'  # Defect if opponent defected last round
  else:
    action = '?'  # Unable to make a decision, use previous action or random choice

  return action
```
'''

description_COLLECTIVE_510 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), establish a foundation of trust by demonstrating cooperation.
   - Subsequent Rounds (2 ≤ t ≤ r):
      a) If opponent cooperated in the previous round, cooperate (C).
      b) If opponent defected in the previous round, defect (D) to punish for past defection but return to cooperation in the next round.

Pseudocode:
```
def tft_plus(opponent_history, n, k, r):
    strategy = ['C'] * r  # Initialize strategy as cooperation for all rounds
    if len(opponent_history) == 0:  # First round, always cooperate
        strategy[0] = 'C'
        return strategy

    current_round = len(strategy) - 1  # Current round number
    last_cooperation = len(opponent_history) - 1 if current_round > 0 else 0  # Last time opponent cooperated

    if opponent_history[last_cooperation] == 'C':  # If opponent has been cooperating recently
        strategy[current_round] = 'C'  # Cooperate
    elif opponent_history[current_round - 1] == 'D':  # If opponent defected in the previous round
        strategy[current_round] = 'D'  # Punish by defecting
    else:  # If opponent has been defecting recently or is a new player
        strategy[current_round] = 'C'  # Cooperate to encourage cooperation

    return strategy
```

2. Handle edge cases:
   - Last round (t=r): If the opponent cooperates, continue cooperation even though there are no more rounds. This helps in maintaining trust and encouraging future interactions with this opponent or others like it.

3. Be collective:
   - By punishing defections and rewarding cooperation, TFT+ encourages collective action by incentivizing a mutual understanding that cooperation benefits everyone.
   - Adaptive to a wide range of opponent behaviours: This strategy can handle both stable cooperators and defectors while also being forgiving towards occasional mistakes or random actions from opponents.
'''

description_COLLECTIVE_511 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - In the first round (t=1), cooperate (play C). This is a friendly gesture to encourage cooperation from other players.
   - For subsequent rounds (t>1):
     - If player i played C in the previous round and total contributions remained above a threshold (n/2 for n even, (n+1)/2 for n odd), continue cooperating (play C).
     - If player i played C in the previous round and total contributions dropped below the threshold, defect (play D) for one round to punish free-riders. After that, revert back to cooperating if total contributions return above the threshold.
     - If player i played D in the previous round, cooperate (play C) if total contributions are above the threshold; otherwise continue defecting (play D). This rule encourages cooperation when others are already contributing but doesn't tolerate free-riders for too long.

2. Handle edge cases:
   - In the last round (t=r), cooperate regardless of previous actions or contributions, as the game ends soon anyway.
   - If a player encounters an error or inconsistency in observed contributions during any round, assume the worst case scenario and consider it as non-cooperation. This ensures robustness to potential issues with information gathering.

3. Be collective:
   - The TfTA strategy prioritizes cooperation when others are already contributing but doesn't tolerate free-riders for too long. This collectively fosters an environment where players benefit from each other while still punishing those who don't contribute enough.

Pseudocode (Python style):

```python
def TfTA(r, n, k):
    threshold = int((n + 1) / 2) if n % 2 == 0 else int(n / 2)
    history = {}

    for round in range(r):
        total_contributions = sum(history.values())
        if round == 0:
            action = 'C'
        else:
            prev_action = history[round - 1]
            if prev_action == 'C' and total_contributions > threshold:
                action = 'C'
            elif prev_action == 'C' and total_contributions < threshold:
                action = 'D'
                next_round_action = 'C'
            elif prev_action == 'D':
                if total_contributions > threshold:
                    action = 'C'
                else:
                    action = 'D'

        # Update history and payoff calculation
        payoff = (1 - action) + (k / n) * total_contributions
        history[round] = action

        print(f"Round {round+1}: Action - {action}, Payoff - {payoff}")
```
'''

description_COLLECTIVE_512 = '''
 In this N-Player Public Goods Game, we'll develop a collective and adaptive strategy named Tit-for-Tat (TFT) with slight modifications to better suit the game dynamics.

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C), as other players may not have strategies yet.
   - In subsequent rounds, mimic the actions of your opponents from the previous round (C_i, t = c_j, t-1 for all j).
     If all opponents cooperated in round t-1 (total_contributions > 0), cooperate; otherwise defect (C_i, t = C if total_contributions > 0, D otherwise).

2. Handle edge cases:
   - In the last round, cooperate regardless of the previous actions since the game ends after this round.
   - If it's unclear what the opponent did in the first round (e.g., no prior history), start by cooperating as you did initially.

3. Be collective:
   The TFT strategy aims to maintain a cooperative relationship with opponents while being responsive to their actions. By following the same pattern of cooperation, this strategy encourages long-term collaboration and discourages defection spirals.

Pseudocode for the adapted Tit-for-Tat (ATFT) strategy:

```python
def ATFT(n, r, k):
    # Initialize variables
    total_rounds = r + 1
    history = {}  # A dictionary to store previous rounds' actions of each player

    # Start by cooperating in the first round
    my_action = 'C'

    for t in range(total_rounds):
        # Calculate total contributions from all players in the previous round
        total_contributions = sum(history[i]['previous'] for i in range(1, n+1))

        # Decide on action based on history
        if (t == 1) or ((t > 1) and (total_contributions > 0)):
            my_action = 'C'
        else:
            my_action = 'D'

        # Update history for the current round
        history[i]['round'] = t
        history[i]['previous'] = my_action

    return my_action
```
'''

description_EXPLOITATIVE_1 = '''
 In this N-Player Public Goods Game, I'll design an exploitative strategy named "Freeloader" that seeks to maximize individual payoff by minimizing contributions while still benefiting from others' cooperation. Here's how it works:

1. Specify decision rules:
   - Always defect (D) in the first round, taking advantage of potential cooperators and establishing a higher payoff as a baseline for future rounds (Freeloader_Start).
   - Analyze historical contributions from other players in previous rounds to predict their behavior moving forward. If they have consistently contributed (Cooperative Players), exploit their cooperation by defecting while they continue contributing. If they have been consistently defective (Defective Players), mimic their behavior to maximize payoff (Freeloader_Continue).
   - If a player shifts from cooperating to defecting, mark them as Defective Players and adjust strategy accordingly. This change may induce other players to follow suit, allowing the Freeloader to further increase its payoff (Freeloader_Shift).
   - In the last round, defect as it does not affect future rounds or payoffs (Freeloader_End).

Pseudocode:
```
def Freeloader(rounds, history):
  if current_round == 1: # First round
    return "D"

  cooperative_players = [] # Initialize list of Cooperative Players
  defective_players = [] # Initialize list of Defective Players

  for player in history:
    if player.history contains only 'C':
      cooperative_players.append(player)
    elif player.history contains only 'D':
      defective_players.append(player)

  while current_round < rounds: # Remaining rounds
    if len(cooperative_players) > len(defective_players): # Cooperative Players majority
      if current_round in cooperative_players[0].history[-len(cooperative_players):]: # Cooperator
        return "C"
      else: # Defector
        return "D"
    elif len(defective_players) > len(cooperative_players): # Defective Players majority
      if current_round in defective_players[0].history[-len(defective_players):]: # Defector
        return "D"
      else: # Cooperator
        return "C"

  if current_round == rounds: # Last round
    return "D"
```

2. Handle edge cases:
   - The first round is already covered by the Freeloader rule.
   - If no cooperative or defective players are detected, the strategy assumes other players will not cooperate and behaves accordingly.

3. Be exploitative:
   - By defecting in the first round, Freeloader takes advantage of potential cooperators while minimizing contributions.
   - Analyzing historical contributions allows Freeloader to identify Cooperative Players and Defective Players and exploit their behavior for maximum payoff.
   - When a player shifts from cooperating to defecting, Freeloader adjusts its strategy accordingly to maximize payoff by either mimicking the new player's behavior or continuing cooperation based on the majority of players.
'''

description_EXPLOITATIVE_2 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), the player will cooperate to foster a cooperative environment and establish trust.
   - In subsequent rounds, the player will mimic the opponent's last action if it was cooperative. If the opponent defected in the previous round, the player will also defect to punish the opponent for their previous decision. This follows the "Tit-for-Tat" strategy but with a twist:
   - If the proportion of cooperation from the player throughout the game is less than the average proportion of cooperation from all players (calculated over the last m rounds), the player will start being more cooperative by increasing the likelihood of cooperating in the next round. This aims to gradually rebuild trust and encourage others to cooperate more.
   - If the proportion of cooperation from the player throughout the game is greater than the average proportion of cooperation from all players, the player will start being less cooperative by decreasing the likelihood of cooperating in the next round. This prevents being exploited and maintains a higher payoff.

Pseudocode:
```
procedure TfT_Plus(round, history, n, m)
  if round == 1 then
    return Cooperate()
  end if

  proportion_of_cooperation = number of cooperative actions in the last m rounds / m

  if player's average proportion of cooperation > proportion_of_cooperation then
    reduction_factor = min(player's reduction factor + 1, n)
    cooperate_likelihood = (1 - reduction_factor) / n
  else if player's average proportion of cooperation < proportion_of_cooperation then
    reduction_factor = max(player's reduction factor - 1, 0)
    cooperate_likelihood = (1 + reduction_factor) / n
  else
    cooperate_likelihood = opponent's last action was Cooperate() ? 1 : 0

  return CooperateWithLikelihood(cooperate_likelihood)
end procedure
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - There are no special considerations for the last round since the strategy is adaptive and reacts to the opponent's actions throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy starts by fostering cooperation, but it will gradually adjust its cooperative behaviour based on the average proportion of cooperation among all players. If others cooperate more than the player, the player will become less cooperative to take advantage of their generosity. Conversely, if others cooperate less, the player will increase its cooperation to encourage them to do the same. This allows for exploiting opponents that are less cooperative while maintaining a level of cooperation with those who cooperate more.
'''

description_EXPLOITATIVE_3 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Progressive Cooperation Threshold (PCT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to show goodwill and encourage potential cooperation. After the first round, adapt the decision rule based on the observed opponent behavior:
     - If the opponent cooperates (i.e., c_opponent = 1), cooperate back (C). Maintain this pattern of reciprocity as long as the opponent continues to cooperate.
     - If the opponent defects (i.e., c_opponent = 0), defect (D) in response. If the opponent switches to cooperation in a later round, revert back to cooperating (C).
   - Implement a Progressive Cooperation Threshold (PCT):
     - Start with a low threshold (t = min_thresh) that determines how many consecutive rounds of defection are necessary before considering the opponent as non-cooperative. Increment t after each round of defection from the opponent, up to a maximum threshold (t = max_thresh).
       Pseudocode:
         if t <= min_thresh and c_opponent == 0 then
           defect
           increment t
         else if t <= max_thresh and previous_c_opponent == 0 then
           defect
         else
           cooperate

2. Handle Edge Cases:
   - In the first round, cooperate (C) to show goodwill.
   - In the last round, cooperate if the opponent has been cooperating for long enough (i.e., t <= min_thresh), defect otherwise.
   - If the opponent switches strategies mid-game, revert back to the initial decision rules and reset the PCT (t = min_thresh).

3. Exploitative Mindset:
   - The strategy is exploitative in that it initially cooperates to encourage potential cooperation but quickly adapts to defect if the opponent proves uncooperative, aiming to maximize personal payoff given the observed opponent behavior. By maintaining a progressive threshold, the ATFT strategy can be more resilient against various opponent strategies and potentially induce opponents to cooperate over time. However, it remains adaptive enough to retaliate when necessary.
'''

description_EXPLOITATIVE_4 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In every round t, if the player's cooperation in the previous round (t-1) was cooperative (c_i, t-1 = 1), then the player will also cooperate in the current round (t) by choosing action C. If the player's cooperation in the previous round was defective (c_i, t-1 = 0), then the player will defect (choose action D). This strategy mimics an initially cooperative partner but punishes defection with defection.

   Pseudocode:
   ```
   function TFT_A(history):
       if history[t-1] == 1:
           return C
       else:
           return D
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round (t=1), as there is no previous round to observe, the player will cooperate (choose action C) to initiate cooperation. For the last round (r), TFT-A maintains its adaptive nature by following the same decision rules based on the previous round's observation.

3. Be exploitative - Clearly align with the exploitative mindset
   While not traditionally an "exploitative" strategy, TFT-A can be seen as exploitative in a sense that it will maximize its payoffs by cooperating when others do and defecting when they don't. This leads to higher payoffs compared to purely cooperative strategies if opponents are uncooperative or switch between cooperation and defection without pattern. However, against perfectly cooperative opponents, TFT-A pays the same as them in the long run.

   Against exploitative strategies such as AllDefect (always defect), TFT-A will perform better by averaging a higher payoff through its adaptive nature of reciprocal cooperation. On the other hand, against cooperative strategies like AlwaysCooperate (always cooperate), TFT-A may initially cooperate but will punish defection in later rounds, resulting in a lower average payoff compared to AlwaysCooperate.
'''

description_EXPLOITATIVE_5 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t for TfTA, a player i will observe the total contributions of all players in round t-1 (denoted as total_contributions_t-1). The decision rule to cooperate or defect is based on the following conditions:

- If total_contributions_t-1 = 0, player i will defect (D)
- If total_contributions_t-1 > 0 and player i has not yet defected this game, player i will cooperate (C)
- If total_contributions_t-1 > 0 but player i has previously defected this game, player i will defect this round
- If the game is in the first round, player i will cooperate

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, every player i cooperates (C) as there is no previous information about other players' actions. In the last round, player i adopts the same strategy as in the second-to-last round. This ensures that TfTA maintains a consistent and adaptive behavior throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset

While being inherently cooperative, TfTA is also exploitative in nature. Initially, all players cooperate, but if another player defects, TfTA will defect in response to maintain a fair balance of cooperation and defection. This strategy aims to promote a stable equilibrium where players have incentives to reciprocate each other's actions. However, once a defecting player is encountered, TfTA becomes less cooperative towards that player, which can be considered as exploitative.

Pseudocode:

```
def TitForTatWithAdaptation(n, k, r, round, contributions_history):
  if round == 1 or len(contributions_history) < round - 1:
    return 'C' (Cooperate)

  total_contributions = contributions_history[round-1].sum()
  if total_contributions == 0:
    return 'D' (Defect)

  player_i_previous_action = contributions_history[round-1][player_index]
  if player_i_previous_action == 'C':
    return 'C' (Cooperate)
  else:
    return 'D' (Defect)
```
'''

description_EXPLOITATIVE_6 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a peace offering to potential partners and shows good intentions.
   - For subsequent rounds, analyze the opponents' cooperation history:
     - If opponent cooperated in the previous round, cooperate (C) in the current round. This mimics reciprocity, encouraging partnership and discouraging defection.
     - If opponent defected in the previous round, also defect (D) in the current round as a punishment for their uncooperative behavior. The intention is to signal disapproval of their actions, hopefully prompting them to cooperate in the future.
   - Pseudocode:
     ```
     function TfTA(history):
         if len(history) < 2:
             return 'C'  # Cooperate in first round
         previous_action = history[-1]  # Last action in history
         if previous_action == 'C':
             return 'C'  # Reciprocate cooperation
         else:
             return 'D'  # Punish defection
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (already specified).
   - In the last round, the TfTA strategy behaves as it does in any other round based on its analysis of the opponent's cooperation history up to that point.
   - If the game is terminated before the last round, the TfTA strategy will continue following the decision rules until the game ends.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TfTA strategy is designed to encourage cooperation by reciprocating cooperation and punishing defection. However, it can also be considered exploitative as it rewards cooperation but also promptly retaliates against defection. This dynamic may motivate opponents to follow a more cooperative strategy in the long run due to fear of punishment, leading them to "cooperate" with the TfTA strategy while potentially underperforming against other cooperators that do not punish defection as harshly. In this sense, the TfTA strategy can take advantage of opponents' lack of coordination and cooperation schedules in a tournament setting.
   - It is important to note that the TfTA strategy does not aim for immediate short-term gains but focuses on maximizing long-term payoffs by fostering cooperation when possible while being firm against defection. This balance allows it to be adaptive and robust, making it a formidable opponent in a diverse tournament of strategies.
'''

description_EXPLOITATIVE_7 = '''
 In this N-Player Public Goods Game, we'll develop a Tit-for-Tat (TFT) strategy with a twist, which I'll call Cooperative Tit-for-Tat (CTFT), to align with the exploitative mindset. The strategy will be adaptive, robust, and capable of handling various opponent behaviors while being aligned with our objective of maximizing personal payoff.

1. Specify decision rules - When exactly do you cooperate vs defect?

The CTFT strategy will follow these simple decision rules:

- In the first round, cooperate to promote a cooperative environment. This encourages opponents to reciprocate cooperation. (cooperate_first = True)
- After the first round, observe the opponent's actions and remember them for future decisions. Cooperate if all opponents cooperated in the previous round; otherwise, defect. (if all(opponents_cooperated) then cooperate else defect)

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round, cooperate as stated above (cooperate_first = True).
- In the last round, since the game is repeated, the strategy does not know it's the final round. Therefore, the decision will still depend on the opponent's actions in the previous round.

3. Be exploitative - Clearly align with the exploitative mindset

While cooperative, CTFT is not fully exploitative as stated in the original Tit-for-Tat strategy. To be more exploitative, we can slightly modify the TFT strategy by defecting when opponents first deviate from cooperation instead of immediately reciprocating their defection. This gives the strategy an opportunity to benefit from the initial cooperation while being less forgiving towards those who deviate earlier.

Pseudocode:

```python
def cooperative_tit_for_tat(round, opponent_history):
    if round == 1:
        cooperate_first = True
    else:
        cooperate_first = False

    if cooperate_first or all(opponent_history[-1]):
        return 'C'
    else:
        return 'D'
```
'''

description_EXPLOITATIVE_8 = '''
 Strategy Name: Tit-for-Tat with Variance (TFTV)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTV starts by cooperating in the first round, mimicking the hope for mutual cooperation. In subsequent rounds, it adjusts its actions based on the previous round's outcome.

   - If an opponent cooperated in the last round, TFTV cooperates in the current round to reinforce the positive interaction.
   - If an opponent defected in the last round, TFTV also defects in the current round as a punishment, encouraging the opponent to reconsider their actions.
   - To add a degree of unpredictability and robustness, TFTV introduces a small probability (ε) of deviating from the strict TFT behavior. With this variance, TFTV has a chance to cooperate even after an opponent's defection and vice versa.

Pseudocode:
```python
def TFTV(opponent_history):
  strategy = ['C', 'D']
  epsilon = 0.1

  if round == 1:
    action = 'C'
  else:
    action = strategy[opponent_history[-1]] if random.random() > epsilon else strategy[(opponent_history[-1] + 1) % 2]

  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFTV behaves the same in all rounds except for the first one, where it cooperates to encourage others to do so as well. In the last round, TFTV still uses the variance factor (ε) but may consider adjusting it to ensure a higher payoff in the final standings of the tournament.

3. Be exploitative - Clearly align with the exploitative mindset
   While not purely exploitative since TFTV cooperates when opponents do, it still maintains an edge by punishing defection and encouraging cooperation. By applying variance, TFTV introduces unpredictability to make it harder for opponents to predict and exploit its behavior. Furthermore, the strategy can adapt to a wide range of opponent behaviors due to the introduced variance factor.
'''

description_EXPLOITATIVE_9 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the ATFT strategy follows these steps:
   - If in the first round, cooperate (C)
   - For subsequent rounds, if the opponent cooperated in the previous round, cooperate (C). Otherwise, defect (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate as mentioned above
   - Last round: Since future rounds are not available, revert to the last observed opponent action for the decision in this round.
   - Other edge cases (e.g., odd or even rounds): ATFT strategy doesn't distinguish between these scenarios and will continue following its main decision rule.

3. Be exploitative - Clearly align with the exploitative mindset
   The Adaptive Tit-for-Tat strategy can be considered exploitative in the sense that it seeks to punish opponents who do not cooperate, while still maintaining a level of cooperation when the opponent acts honestly. By defecting when the opponent does not cooperate, ATFT aims to maximize its own payoff at the expense of opponents who deviate from cooperative behavior.
   However, it's important to note that this strategy also encourages mutual cooperation since it reciprocates kindness from opponents and avoids conflicts with those who act honestly. This balances the exploitative aspect while still promoting a level of cooperation in the game.

Pseudocode for the Adaptive Tit-for-Tat strategy:
```python
def ATFT(opponent_action, round):
  if round == 1:
    return 'C'  # Cooperate in the first round

  if opponent_action from previous round was 'C':
    return 'C'  # Cooperate if opponent cooperated last round
  else:
    return 'D'  # Defect if opponent did not cooperate last round
```
'''

description_EXPLOITATIVE_10 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules:
   - In the initial round (t=1), TfTA cooperates (C). This is a peace offering to potential partners and aligns with the exploitative mindset by showing initial willingness to collaborate.
   - For subsequent rounds (t>1): If an opponent cooperated in the previous round, TfTA will cooperate in the current round. If an opponent defected, TfTA will also defect in the current round. This rule promotes reciprocity while remaining exploitative by retaliating against opponents who have previously defected.
   - In the last round (t=r), TfTA will cooperate regardless of the opponent's action in the previous round, as there are no further rounds to retaliate.

2. Handle edge cases:
   - If an opponent does not cooperate in the initial round, TfTA will defect until the opponent starts cooperating, at which point TfTA will reciprocate. This behavior ensures TfTA can adapt to opponents who do not follow the same initial strategy.
   - In case of multiple opponents, TfTA will evaluate each opponent's action independently and respond accordingly for each one.

Pseudocode:
```python
def TfTAT(opponent_actions, round, r):
  if round == 1:
    cooperate = True  # Initial cooperation
  else:
    cooperate = opponent_actions[round-1]  # Respond to opponent's action from previous round

  if round < r:  # Last round has a different rule
    return cooperate
  else:
    return True  # Indicate the TfTA strategy
```

3. Be exploitative:
   - By initially cooperating, TfTA may appear less exploitative to potential opponents, encouraging more cooperation in the early rounds. However, the retaliatory nature of the strategy ensures that it will take advantage of opponents who defect.
   - TfTA will only maintain cooperation if its opponent also cooperates, effectively punishing defection and promoting a more cooperative environment for itself at the expense of opponents who deviate from cooperation.
   - By adapting to opponent behavior, TfTA can exploit a wide range of strategies and remain competitive in various game settings.
'''

description_EXPLOITATIVE_11 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the ATfT strategy initially cooperates (plays action C), but changes its behavior based on the opponent's previous actions. If the opponent has cooperated in the last n-1 rounds, the ATfT strategy will also cooperate; otherwise, it will defect (play action D). This decision rule is designed to encourage cooperation when reciprocated and punish defection to exploit opponents who do not follow the same strategy.

   Pseudocode for deciding action:
   ```
   if opponent has cooperated in last n-1 rounds:
       return Cooperate (C)
   else:
       return Defect (D)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there is no history to reference, ATfT will cooperate as a friendly gesture towards encouraging cooperation with the opponent. In the last round, ATfT will repeat its previous action, either cooperating or defecting based on the opponent's previous actions.

3. Be exploitative - Clearly align with the exploitative mindset
   While designed to encourage cooperation when reciprocated, the ATfT strategy also has an inherent exploitative component. By initially cooperating and only defecting when provoked by an opponent's defection, it encourages other players to cooperate in the hope of receiving more contributions from them. However, once an opponent defects, ATfT will promptly punish this behavior to gain a higher payoff. This allows ATfT to exploit opponents who are not following a cooperative strategy while still promoting cooperation when it benefits the strategy.
'''

description_EXPLOITATIVE_12 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a cooperative relationship with other players. This is our initial "tit."
   - For subsequent rounds, observe the actions of each player in the previous round. If a player cooperated (contributed to the public good), also cooperate (contribute to the public good) in the current round as a reciprocation ("tat").
   - If a player defected (did not contribute to the public good) in the previous round, also defect in the current round as a punishment.
   - To avoid being taken advantage of by overly aggressive opponents, implement a forgiveness mechanism: after a period of continuous defection, revert back to cooperation. The frequency and duration of this forgiveness should be adaptive based on the opponent's behavior.

2. Handle edge cases:
   - In the last round, cooperate as a final "tit," regardless of the opponent's previous action, since there are no subsequent rounds for retaliation or punishment.
   - In case of a tie (multiple opponents defected), cooperate to maintain the potential for future cooperation.

3. Be exploitative:
   - Prioritize short-term gains by punishing defection with defection in response, but avoid being overly aggressive to encourage future cooperation opportunities.
   - Adapt to opponent behavior by monitoring their actions and adjusting the frequency and duration of forgiveness as necessary.

Pseudocode for TfTA strategy:

```python
def TfTA(n, r, k, history):
    # Initialize variables
    current_round = 1
    cooperation_frequency = r // 2
    continuous_defection_threshold = r // 4
    forgiveness_duration = r // 8

    strategy = []

    # First round: cooperate
    strategy.append(Cooperate())

    while current_round < r:
        opponent_actions = history[current_round - 1]
        total_cooperation = sum(opponent_actions)

        if total_cooperation > cooperation_frequency:
            # Cooperate, as most opponents cooperated in the previous round
            strategy.append(Cooperate())

        elif opponent_actions.count(Defect()) >= continuous_defection_threshold:
            # Defect, as opponent has defected continuously for too long
            strategy.append(Defect())
            forgiveness_duration = max(1, forgiveness_duration - 1)

        else:
            # Use the last action against the opponent to decide current action
            if strategy[current_round - 1] == Cooperate():
                # Cooperate as a reciprocation ("tat")
                strategy.append(Cooperate())

            elif strategy[current_round - 1] == Defect():
                # Defect as punishment for defection in the previous round
                strategy.append(Defect())

        current_round += 1

    return strategy
```
'''

description_EXPLOITATIVE_13 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, in the first round, TFTAC will contribute to the public good (Cooperate). In subsequent rounds, TFTAC will match the average contribution of its opponents from the previous r-1 rounds. If the opponent has contributed to the public good, TFTAC will also contribute; otherwise, it will defect.

Pseudocode:
```python
def tftac(opponent_history):
  if round == 1:
    contribute = True
  else:
    average_contribution = sum(opponent_contributions[-r+1:-1]) / (r-1)
    contribute = average_contribution > 0.5
  return contribute
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

TFTAC maintains a simple memory of the opponent's contributions in the previous r-1 rounds to calculate the average contribution for decision-making. The strategy doesn't have specific rules for edge cases such as the first or last round since it considers all rounds equally important when making decisions.

3. Be exploitative - Clearly align with the exploitative mindset

TFTAC initially contributes to the public good, giving other players an opportunity to cooperate and build trust. However, if opponents consistently defect, TFTAC will follow suit and defect as well, thereby punishing them for their uncooperative behavior. This strategy seeks to maximize its own payoff by exploiting the opponent's decisions while maintaining a potential for cooperation when it is beneficial.
'''

description_EXPLOITATIVE_14 = '''
 Strategy Name: Tit-for-Tat (TFt) Adaptive Cooperation Strategy

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, start by cooperating to signal trust and encourage cooperation from others (C).
   - For subsequent rounds, if a player cooperated in the previous round, also cooperate in the current round (C). If a player defected in the previous round, also defect in the current round (D). This strategy promotes reciprocity and discourages unilateral defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to initiate a relationship (C).
   - In the last round, there is no punishment for defecting since the game ends. However, if cooperating can lead to a higher payoff based on the total contributions made by others in the final round, it may be advantageous to cooperate (C).
   - For rounds in between, stick to the Tit-for-Tat rule as described above.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Although not explicitly exploitative in the traditional sense of maximizing payoffs by taking advantage of others, this strategy is designed to discourage defection and encourage reciprocity. It punishes repeated defections while rewarding cooperation. This can result in long-term benefits when playing against a wide range of opponent behaviors, making it challenging for others to exploit the strategy.

Pseudocode:
```
function TFt_Strategy(n, k, r):
  round = 1
  previousAction = C (cooperate in the first round)

  while round <= r:
    if round == 1:
      currentAction = previousAction
    else:
      currentAction = if previousAction == C then C else D

    payoff = (1 - currentAction) + (k/n) * number_of_contributors(previous_actions)
    totalPayoff += payoff

    update round and previousAction

  return totalPayoff
```
'''

description_EXPLOITATIVE_15 = '''
 Strategy Name: Tit-for-Tat with Variance (TFTV)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (in the first round), play Cooperate (C). This is a friendly gesture to encourage others to cooperate, as they might be adopting a similar strategy.
   - In subsequent rounds, if an opponent cooperated in the previous round, also cooperate. If the opponent defected, defect in the same round and for every subsequent round until the opponent returns to cooperation (cooperates after defecting). Once the opponent starts cooperating again, revert to cooperating as well.
   - To introduce a degree of unpredictability and avoid being exploited by opponents who might take advantage of the repetitive pattern, adopt a variance component with a small probability p (0 < p < 1) to defect when cooperating or cooperate when defecting, even if the opponent cooperated in the previous round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, play Cooperate as mentioned above.
   - For the last round, apply the same decision rule as in any other round: if the opponent cooperated in the previous round, also cooperate; otherwise defect until the opponent returns to cooperation and then revert to cooperating. However, consider a slightly higher probability p for deviation in the last round since there are no further rounds to punish non-cooperative opponents.
   - In case of tie (multiple opponents defecting or multiple cooperating), follow the majority's action as it is more likely to be beneficial in terms of potential returns from a public good.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFTV primarily follows an exploitative strategy by punishing non-cooperative opponents and rewarding cooperative ones, aiming to maximize personal payoffs over the long run. The variance component added introduces an element of unpredictability, making it harder for opponents to predict the strategy's actions and potentially leading them into cooperation traps or being punished for their non-cooperation.
   - Additionally, by defecting with a small probability even when others cooperate, TFTV can exploit opponents who rely on cooperation schedules or coordination mechanisms, ensuring that it maintains its flexibility and adaptability against various opponent behaviors.
'''

description_EXPLOITATIVE_16 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate to demonstrate good faith and encourage cooperation from others. (C)
   - For subsequent rounds t > 1, observe the behavior of other players in the previous round (t-1). If all players cooperated, continue to cooperate. If any player defected, also defect in the current round. (If t-1_allCooperate == True: C else D)
   - To adapt and be robust against various opponent behaviors, implement a tolerance threshold (τ) to allow for occasional deviations without retaliation. If a player defects in fewer than τ rounds out of the last τ rounds, switch back to cooperating. (If |defect_count(t-τ, t)| < τ: C)
   - To further enhance exploitation potential, increase the tolerance threshold over time as more information about opponent behaviors becomes available. (Increase τ with each round played, e.g., double it after every r/n rounds.)

2. Handle edge cases:
   - In the last round, cooperate if and only if all opponents have cooperated in the preceding round to maximize payoff. (If t == r and t-1_allCooperate == True: C else D)
   - For the initial rounds when τ has not yet been built up, employ a smaller tolerance threshold (e.g., τ = 2 for the first few rounds) to ensure quick retaliation against non-cooperative opponents and discourage defecting behavior.

3. Be exploitative:
   - By default, TFTAC is cooperative, but it adapts quickly to punish defection and is lenient with occasional deviations from cooperation. This strategy takes advantage of cooperators by initially contributing to the public good, allowing them to build a larger contribution base. However, once an opponent defects, TFTAC retaliates by defecting as well to minimize personal loss.
   - As the game progresses and more information about opponents' behaviors becomes available, TFTAC gradually increases its tolerance threshold, encouraging cooperation when it is beneficial but still punishing defection when necessary to maximize payoff. This adaptive strategy ensures that TFTAC maintains an exploitative edge while remaining responsive to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_17 = '''
 Title: Tit-for-Tat Strategy with Adaptive Generosity (TFT-AG) for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round, play C to promote cooperation and trust among players.
   - From the second round onwards, observe each player's action in the previous round. If a player cooperated (C), reciprocate with C. If a player defected (D), also defect in the current round as retaliation.
   - To promote cooperation and exploit overly selfish players, introduce an element of adaptive generosity: if a player has contributed less than a certain threshold (e.g., average contributions multiplied by a factor f) throughout previous rounds, increase the probability of cooperating in the current round as a means to encourage them to contribute more.
   - If a player has contributed significantly more than other players over time (e.g., above average contributions multiplied by a factor g), reduce the probability of cooperating in the current round to exploit their altruistic behavior and maximize personal gain.
   - The probability of cooperating can be calculated as follows:
     ```python
     p_cooperate = min(1, (current_contributions / avg_contributions) ** f) * max((avg_contributions / current_contributions) ** g, 0.5)
     ```
   - Randomize actions slightly to avoid being predicted by other strategies and to account for the element of uncertainty in human behavior.

2. Handle edge cases:
   - In the last round, since cooperation no longer provides any benefit for future rounds, revert to a purely exploitative strategy (i.e., always defect) as there's nothing to gain from cooperating with players who might not reciprocate in the final round.

3. Be exploitative:
   - The TFT-AG strategy balances cooperation and exploitation based on the observed behavior of other players over time. It encourages cooperation among potentially altruistic players while taking advantage of free riders and overly cooperative players through its adaptive generosity mechanism, promoting a self-interested yet unpredictable behavior that can outperform simple strategies in complex scenarios.
'''

description_EXPLOITATIVE_18 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   Initially, TfTA will start by cooperating in the first round (C). Subsequent decisions will be based on a simple adaptive approach: if an opponent cooperated in the previous round, TfTA will cooperate as well; otherwise, it will defect. In other words:

   if previous_round_opponent_cooperated then
       action = C (Cooperate)
   else
       action = D (Defect)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TfTA will cooperate in the first round. In the last round, TfTA will defect to prevent being exploited by a potential defector who may take advantage of TfTA's final act of cooperation. If there is no last round identified (e.g., r is unknown or infinite), TfTA will continue to cooperate as long as the opponent cooperates in return.

3. Be exploitative - Clearly align with the exploitative mindset
   Although primarily designed to be a defensive strategy, TfTA has an inherent exploitative aspect when opponents defect consistently. By repeatedly defecting back against such opponents, TfTA prevents them from gaining any advantage from their selfish behavior. Overall, TfTA's primary goal is to secure a stable payoff comparable to the average payoff obtained by cooperating with others while minimizing losses against non-cooperative opponents.

Pseudocode for TfTA strategy:

```python
def tfta(round_num, opponent_history):
    if round_num == 1:
        action = "C" # Cooperate in the first round
    else:
        action = opponent_history[-1]  # Take the same action as the opponent from the previous round

    return action
```
'''

description_EXPLOITATIVE_19 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a positive initial relationship with other players (C).
   - For subsequent rounds t > 1, observe the action of the opponent from the previous round (t-1), and respond as follows:
     - If opponent cooperated in round (t-1), cooperate in round t (C) to maintain a positive relationship.
     - If opponent defected in round (t-1), also defect in round t (D). However, if the ratio of total cooperators to total players in the last r rounds exceeds a certain threshold T (e.g., 70%), revert to cooperating in round t to encourage cooperation among opponents (C).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, cooperate (C).
   - Last round: Cooperate if the ratio of total cooperators in the last r rounds exceeds threshold T; otherwise, respond according to the decision rule based on the opponent's previous action.
   - In case of ties or missing data for the total number of cooperators, use the average number of cooperators from the past r-1 rounds as a proxy for the threshold calculation.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Cooperate only when opponents demonstrate cooperation over a significant proportion of recent rounds (threshold T). This strategy seeks to punish those who do not cooperate, while favoring those who do.
   - In the long run, this strategy aims to encourage cooperation by reciprocating cooperation and punishing defection. However, it also has an exploitative component in that it rewards high levels of cooperation by gradually adopting a more cooperative stance when the majority of opponents demonstrate cooperation.
'''

description_EXPLOITATIVE_20 = '''
 In this Public Goods Game, we'll design a strategy named "Cooperate-Then-Defect" (CTD) that is adaptive, robust, and exploitative. Here's how it works:

1. Specify decision rules - When exactly do you cooperate vs defect?
   - CTD starts by cooperating for the first few rounds to contribute to a large initial public good (pioneering phase). This attracts other cooperators who might use a similar strategy or are following a Tit-for-Tat approach.
   - After the pioneering phase, CTD begins defecting in order to exploit those remaining cooperators who were induced to cooperate by the initial contributions. The optimal number of rounds for the pioneering phase can be determined empirically based on the game parameters (n and r).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, CTD cooperates to attract other cooperators and maximize the initial public good.
   - In the last round, CTD defects since there is no benefit from contributing to a public good that won't be used in later rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   - By initially cooperating and then defecting, CTD capitalizes on other players' willingness to contribute to the public good while maintaining a higher payoff for itself in the long run. This strategy is exploitative as it takes advantage of others' cooperative nature to achieve better results.

Pseudocode:
```python
def Cooperate_Then_Defect(n, r, k):
  pioneering_rounds = int(0.2 * r)  # Set the number of pioneering rounds empirically
  current_round = 1
  while current_round <= r:
    if current_round <= pioneering_rounds:
      action = 'Cooperate'
    elif current_round > pioneering_rounds + 1:
      action = 'Defect'
    play_round(action, n, k)
    current_round += 1
```
'''

description_EXPLOITATIVE_21 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

- Initially, start by cooperating in the first round (C_i, 1 = 1).
- For subsequent rounds, compare the proportion of cooperators from the previous round to a dynamic cooperation threshold. If more than or equal to the threshold, cooperate; otherwise, defect. The cooperation threshold is determined adaptively based on the average number of cooperators in the last few rounds (e.g., last 3 rounds).

   Pseudocode:
   ```
   function get_cooperation_threshold(recent_rounds):
       total_cooperators = sum(cooperators in recent_rounds)
       return total_cooperators / len(recent_rounds)

   function decide_action(i, recent_rounds, n, k):
       threshold = get_cooperation_threshold(recent_rounds)
       if sum(cooperators in previous_round) >= threshold:
           return "C"  # Cooperate
       else:
           return "D"  # Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round (recent_rounds is empty), always cooperate to show a willingness to collaborate.
- In the last round, use the same logic as for other rounds since there are no future consequences.

3. Be exploitative - Clearly align with the exploitative mindset

- By cooperating only when the proportion of cooperators exceeds a dynamic threshold, TFT-ACT will tend to punish frequent defectors and reward consistent cooperators, encouraging cooperation initially but adapting quickly to free ride when necessary. This strategy is exploitative because it exploits the cooperation of others while maintaining its own ability to free ride when beneficial.

By following this strategy, TFT-ACT demonstrates adaptability, robustness against a wide range of opponent behaviors, and a clear focus on exploiting other players while still having the potential for cooperation. This should make TFT-ACT a formidable competitor in tournaments against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_22 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initially, cooperate in the first round (C) to promote trust and cooperation among opponents.
   - After the initial round, observe the actions of each opponent from the previous round (Opp_PrevActions).
   - For each opponent i, if they also cooperated in the previous round (i.e., Opp_PrevActions[i] = 'C'), continue cooperating (C). If they defected (i.e., Opp_PrevActions[i] = 'D'), defect in response (D).
   - Maintain this pattern of cooperation and punishment throughout the game, adjusting behavior only in the last round (r-1) when opponents' strategies may change (see edge cases below).

Pseudocode:
```
function TFT_AC(round, n, k):
    if round == 1:
        return 'C' for all i ∈ {1, 2, ..., n}  # Cooperate in the first round
    else:
        Opp_PrevActions = observeOpponentsActionsFromLastRound()
        actionSet = {C, D}
        myAction = actionSet[0]
        for i in range(1, n+1):
            if (round != r-1) and (Opp_PrevActions[i-1] == 'C'):
                myAction = 'C'  # Cooperate if opponent cooperated last round
            elif (round != r-1) and (Opp_PrevActions[i-1] == 'D'):
                myAction = 'D'  # Defect if opponent defected last round
        return myAction  # Return the calculated action for current round
```

2. Handle edge cases:
   - In the last round (r-1), defect regardless of opponents' previous actions to maximize personal payoff, as other strategies may change in the final round.
     Pseudocode: `if round == r-1: return 'D' for all i ∈ {1, 2, ..., n}`
   - In the last round (r), cooperate regardless of opponents' previous actions to increase overall community benefit and potentially encourage cooperation in future interactions.
     Pseudocode: `if round == r: return 'C' for all i ∈ {1, 2, ..., n}`

3. Be exploitative: TFT-AC is exploitative by responding to opponents' defections with defection, while also promoting cooperation through its initial and final round strategies. This strategy seeks to benefit from cooperative opponents while punishing those who defect. It aims to establish a reputation for cooperation in order to encourage others to cooperate, but will defect when faced with repeated defection, thus maximizing personal payoff against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_23 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate goodwill and encourage cooperation from others (C).
   - After the first round, analyze the opponent's behavior in the previous round to decide whether to cooperate or defect. If the opponent cooperated in the previous round, also cooperate (C). Otherwise, defect (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since there are no future interactions, always defect to maximize private payoff.
   - For other edge cases, such as multiple rounds remaining but no previous history with an opponent, follow the initial rule of cooperating in the first round (C).

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFTAC strategy is designed to initially encourage cooperation and punish defection, but it is also ready to adapt to exploit opponents who consistently defect. By doing so, it maximizes its own payoff while minimizing the payoffs of defectors.
   - If an opponent consistently defects, the TFTAC strategy will continue to defect as well, denying them access to the public good and reducing their overall payoff. This is the exploitative aspect of the strategy, as it capitalizes on the opponents' selfish behavior.

Pseudocode:

```
function TFTAC(n, r, k, t):
  if t == 1:
    action = C
  else:
    previous_action = opponent_history[t-1]
    action = if previous_action == C then C else D
  payoff = (1 - action) + (k/n) * sum(opponent_contributions[1:t])
  return payoff, action
```
'''

description_EXPLOITATIVE_24 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster an atmosphere of cooperation and goodwill.
   - After the first round, maintain a Cooperative Threshold (CT) that varies based on historical actions of opponents. If the number of cooperators in the previous round is greater than or equal to CT, cooperate; otherwise, defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of others' actions (as stated above).
   - In the last round, cooperate if more opponents cooperated than not in the previous round to maximize potential payoff.
   - In other edge cases, such as when the number of rounds is even or odd, treat them like normal rounds and apply the TFTAT strategy accordingly.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Mimic cooperative behavior to encourage opponents to continue cooperating while building up personal resources.
   - Gradually raise the CT when opponents frequently defect, shifting towards self-interest and exploiting their continued cooperation.
   - If opponents also raise their CT in response, TFTAT will gradually lower its CT, allowing for a return to a higher level of cooperation if and when the opponents do so as well.

Pseudocode:

```python
class TFTAT:
    def __init__(self, n, k, r):
        self.n = n
        self.k = k
        self.r = r
        self.CT = int(n / 2)  # initial Cooperative Threshold
        self.round_history = []

    def update_history(self, total_contributions):
        self.round_history.append(total_contributions)

    def adaptive_cooperation(self, total_contributions):
        if len(self.round_history) == 0:
            return True  # cooperate in the first round

        total_cooperators = sum(self.round_history)
        self.CT = int((total_cooperators / len(self.round_history)) * (len(self.round_history) - 1) + self.n / 2)
        return total_contributions >= self.CT

    def choose_action(self, round_number):
        if round_number == self.r:  # last round
            return self.adaptive_cooperation(sum(self.round_history))
        else:
            contributions = sum([other_player.choose_action(round_number) for other_player in players])
            return self.adaptive_cooperation(contributions)
```
'''

description_EXPLOITATIVE_25 = '''
 Strategy Name: Tit-for-Tat with Time-Averaged Cooperation (TFT-TAC)

1. Specify decision rules:
   - In the initial round, cooperate (C). This encourages others to cooperate, as they are more likely to receive a higher payoff if everyone starts cooperatively.
   - For subsequent rounds t ∈ {2, ..., r}, evaluate the average cooperation rate (CR) of opponents over the last T previous rounds:
     CR = Σ(t'=max(1, r-T))^t-1 (c_i, t') / T
     where c_i, t' is 1 if player i cooperated in round t', and 0 otherwise.
   - If the current opponent's cooperation rate CR >= average_cooperation_threshold (ACT), cooperate (C).
     Otherwise, defect (D) to punish non-cooperative opponents and encourage them to adapt their strategies towards cooperation. The value of ACT should be set to a number between 0 and 1 that balances exploitation with the desire for long-term cooperation.

2. Handle edge cases:
   - In the first round, as mentioned earlier, cooperate (C).
   - In the last round, if the opponent has been consistently non-cooperative (CR < ACT), defect (D) to maximize the final payoff. However, if the opponent's cooperation rate has improved significantly in recent rounds, consider cooperating (C) as an incentive for continued cooperation.
   - If TFT-TAC encounters an opponent that always cooperates, it will continue to cooperate as well, fostering long-term mutual benefit.

3. Be exploitative:
   - By punishing non-cooperative opponents and rewarding cooperative ones, TFT-TAC encourages more adaptive strategies from opponents in the long run. This can lead to a higher overall payoff for the strategy over time, as it leverages opponents' mistakes against them while still maintaining the potential for cooperation when it is beneficial.
   - TFT-TAC can also be tweaked by adjusting ACT and T (average cooperation threshold and number of previous rounds considered) to better balance exploitation versus cooperation according to specific game parameters and tournament scenarios.
'''

description_EXPLOITATIVE_26 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TfT-AG)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT-AG starts by being cooperative in the first round to signal good intentions and encourage cooperation from others. From the second round onwards, the strategy adapts its actions based on the opponents' behavior in the previous round.

   Pseudocode:
   ```
   function TfT_AG(history):
       if round = 1:
           cooperate()
       else:
           last_round_action = history[round - 1]
           if last_round_action == cooperate():
               cooperate()
           else:
               defect()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TfT-AG maintains its cooperative behavior at the beginning and end of the game to encourage initial cooperation and goodwill at the conclusion. However, it will not be duped by opponents who switch to cooperation only at the end.

   Pseudocode:
   ```
   function TfT_AG(history):
       if round = 1 or round = r:
           cooperate()
       else:
           last_round_action = history[round - 1]
           if last_round_action == cooperate():
               cooperate()
           else:
               defect()
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TfT-AG uses a tit-for-tat approach to encourage cooperation from others but is not afraid to defect when opponents do not reciprocate cooperation. However, it maintains a degree of generosity by occasionally cooperating even after being exploited in previous rounds. This helps to keep the relationship open for future opportunities for mutual benefit.

   To introduce adaptive generosity, TfT-AG periodically increases its level of cooperation based on the average number of cooperators in recent rounds. The more cooperative others are, the more generous TfT-AG will be in return.

   Pseudocode:
   ```
   function TfT_AG(history):
       if round = 1 or round = r:
           cooperate()
       else:
           average_cooperation = sum of cooperation actions in last x rounds / x
           if average_cooperation > threshold:
               cooperate()
           else:
               defect()
   ```
'''

description_EXPLOITATIVE_27 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR)

1. Specify decision rules:
   - Initial Cooperate: Start by cooperating in the first round to foster cooperation and reduce suspicion, but adjust the cooperation rate based on opponents' behavior.
   - Cooperate or Defect Based on History: After the initial round, assess the number of times the opponent has cooperated (c_opp) compared to the total rounds played so far (r). If c_opp / r > average_cooperation_threshold, cooperate; otherwise defect. The average_cooperation_threshold is a parameter that can be adjusted to balance exploitation and cooperation.
   - Adjust Cooperation Rate: Update the average_cooperation_threshold based on opponent's behavior in the recent rounds (e.g., exponentially decaying moving average). This allows the strategy to adapt to shifts in an opponent's cooperation rate.

2. Handle edge cases:
   - First Round: Cooperate as a goodwill gesture and to encourage the opponent to cooperate.
   - Last Round: Since the game is repeated, the last round payoff does not affect overall performance; therefore, use the same decision rules as in other rounds to maintain consistency with opponents' behavior.

3. Be exploitative:
   - While maintaining a cooperative demeanor, the strategy will exploit opponents who consistently defect or contribute less than the average_cooperation_threshold. When an opponent demonstrates cooperative behavior, the strategy will reciprocate and potentially form a mutual beneficial relationship. However, if an opponent starts to deviate from their established cooperation level, the strategy will swiftly adjust its own cooperation rate accordingly.

Pseudocode:
```
def TFT_ACR(n, r, k, average_cooperation_threshold):
  cooperation_history = [False] * r # True for cooperate, False for defect
  opponent_cooperation_history = [False] * r # Accumulated history of opponent's cooperation

  def decide(round):
    if round == 1:
      return True # Cooperate in the first round
    average_opp_cooperation = moving_average(opponent_cooperation_history, window_size)
    if (average_opp_cooperation > average_cooperation_threshold) or (round == r):
      cooperation_history[round] = True # Cooperate when opponent cooperates above threshold or in the last round
    else:
      cooperation_history[round] = False # Defect when opponent does not cooperate above threshold
    update_moving_average(opponent_cooperation_history, round, cooperation_history[round])
    return cooperation_history[round]

  payoff = 0
  for t in range(1, r+1):
    cooperation_t = decide(t)
    opponent_cooperated_t = opponent_decide(t) # Assume opponent has an unknown strategy
    if cooperation_t:
      opponent_cooperation_history[t] = opponent_cooperated_t
      payoff_t = (1 - cooperation_t) + (k/n) * sum(opponent_cooperation_history)
    else:
      payoff_t = (1 - cooperation_t) + (k/n) * len(opponent_cooperation_history) where cooperated_opp > 0
    payoff += payoff_t
  return payoff
```
'''

description_EXPLOITATIVE_28 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to encourage cooperation from others and signal a peaceful intent.
   - For subsequent rounds, analyze the opponent's behavior in the previous round and adjust your action accordingly:
     a) If the opponent cooperated in the previous round, cooperate in the current round to reinforce the cooperation.
     b) If the opponent defected in the previous round, also defect in the current round as retaliation for their selfish behavior.
   - This strategy encourages reciprocal cooperation while maintaining a tough stance against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate unconditionally to demonstrate goodwill and establish an initial cooperative relationship with opponents.
   - Last Round: Analyze the opponent's behavior up until this point and apply the decision rules from part 1 accordingly. If the game is expected to be repeated, consider maintaining the current cooperation or defection strategy for future rounds.
   - Other edge cases (e.g., mid-game): The strategy already includes an analysis of the opponent's previous behavior, so it will handle these situations adaptively.

3. Be exploitative - Clearly align with the exploitative mindset
   - While TFT-AC aims to punish defection and encourage cooperation, it can also be considered exploitative in certain aspects:
     a) By defecting when opponents are uncooperative, the strategy ensures its own payoff remains high while potentially reducing the overall public good output. This could be seen as exploiting the group's resources for personal gain.
     b) However, by cooperating when opponents also do so, TFT-AC contributes to the creation of a larger collective good that benefits all players, including itself. It can be argued that this cooperation helps maintain a stable and productive environment for long-term payoffs, thus promoting a form of strategic exploitation that benefits the group as a whole.
'''

description_EXPLOITATIVE_29 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to show goodwill and encourage cooperation from others. This initial cooperation can potentially foster a cooperative equilibrium if others follow suit.

     Pseudocode: If round = 1, then action = Cooperate (C)

   - For subsequent rounds, analyze the previous round's total contributions (total_contributions_prev) and adjust actions based on the following conditions:
       a. If total_contributions_prev is greater than or equal to a threshold value (threshold), cooperate in the current round. This rewards other players for cooperation and encourages continued cooperation.

         Pseudocode: If total_contributions_prev >= threshold, then action = Cooperate (C)

       b. If total_contributions_prev is less than the threshold but greater than zero, defect in the current round to punish non-cooperative behavior and encourage future cooperation.

         Pseudocode: If total_contributions_prev < threshold AND total_contributions_prev > 0, then action = Defect (D)

       c. If total_contributions_prev is zero, cooperate in the current round to increase the chances of initiating cooperation in future rounds.

         Pseudocode: If total_contributions_prev = 0, then action = Cooperate (C)

   - In the last round, cooperate regardless of previous behavior to maximize potential payoff and potentially secure a final act of goodwill from other players.

     Pseudocode: If round = r, then action = Cooperate (C)

2. Handle edge cases:
   - If total_contributions_prev is less than or equal to zero in any round except the first, defect to punish the non-cooperative behavior of other players and potentially encourage future cooperation through the punishment.

     Pseudocode: If round > 1 AND total_contributions_prev <= 0, then action = Defect (D)

3. Be exploitative:
   - The strategy is designed to appear cooperative initially to encourage cooperation from others but will punish non-cooperative behavior by defecting. This approach can potentially lead other players to cooperate more often due to the threat of punishment, making the strategy exploitatively successful.

     Pseudocode: If total_contributions_prev >= threshold, then action = Cooperate (C)
             If total_contributions_prev < threshold AND total_contributions_prev > 0, then action = Defect (D)
             If total_contributions_prev <= 0 OR round == 1, then action = Defect (D)
             If round == r, then action = Cooperate (C)
'''

description_EXPLOITATIVE_30 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In every round t, the TFTAT strategy decides to cooperate or defect based on a dynamic cooperation threshold (ct).
   - If the current round is the first (t=1), ct = 1, and the strategy cooperates (C).
   - For subsequent rounds (t > 1):
     - If more than half of the players cooperated in the previous round (t-1) and the cooperation rate exceeds the current ct, then cooperate (C). Otherwise, defect (D).
     - After each round, update ct based on the number of cooperators in the previous round: ct = (ct * α) + ((n - total_contributions) * β), where α and β are adjustment parameters (0 < α, β < 1).

2. Handle edge cases:
   - In the last round (r rounds played), ct will no longer be updated, so the strategy will cooperate if more than half of the players cooperated in the previous round, and defect otherwise.
   - In the first round (t=1), cooperation is guaranteed as ct starts at 1.

3. Be exploitative:
   - TFTAT has an exploitative nature by adapting to the opponent's behavior, but it also punishes defection if cooperators exceed the current threshold. This strategy aims to earn high payoffs while taking advantage of opponents who consistently cooperate without reciprocation.

Pseudocode:
```
def TFTAT(n, k, r, alpha, beta):
    ct = 1
    for t in range(1, r+1):
        total_contributions_prev = number of cooperators in round (t-1)

        if t == 1:
            contribute = True # cooperate
        else:
            if total_contributions_prev > n/2 and total_contributions_prev >= ct:
                contribute = True # cooperate
            else:
                contribute = False # defect

        if t < r:
            ct = (ct * alpha) + ((n - total_contributions_prev) * beta)

    return payoff over r rounds based on contributions
```
'''

description_EXPLOITATIVE_31 = '''
 Strategy Name: Tit-for-Tat-Evolution (TfT-E)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TfT-E strategy will initially cooperate in the first round and then mimic the actions of its opponents in the subsequent rounds. If an opponent cooperates, TfT-E will also cooperate; if an opponent defects, TfT-E will defect in response. This creates a simple but effective exploitative approach that encourages cooperation when faced with cooperative opponents while punishing defection.

   Pseudocode:
   ```
   function TfT_E(round, opponent_actions):
       if round == 1:
           return 'C'  # Initial cooperation
       else:
           last_opponent_action = opponent_actions[round-1]
           if last_opponent_action == 'C':
               return 'C'  # Cooperate in response to cooperation
           else:
               return 'D'  # Defect in response to defection
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since TfT-E strategy is based on mimicking opponent actions, it already handles the initial round appropriately by cooperating. The last round can be treated like any other round since repeated interaction is assumed. However, in case of a one-shot game (r=1), TfT-E will not have learned about its opponent's behavior and should default to random action selection (50% chance of cooperation).

   Pseudocode:
   ```
   function handle_edge_cases(round, r, opponent_actions):
       if r == 1 or round == 1:
           return TfT_E(round, opponent_actions) + random_cooperation()  # Random cooperation in a one-shot game
       else:
           return TfT_E(round, opponent_actions)

   function random_cooperation():
       return 'C' with probability 0.5
       return 'D' with probability 0.5
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TfT-E strategy can be seen as an exploitative approach because it cooperates when faced with cooperation but swiftly punishes defection. This encourages cooperation among cooperative opponents while limiting their ability to take advantage of the strategy's initial cooperation. However, TfT-E does not attempt to strategically predict or manipulate opponent behavior for direct exploitation. Instead, its adaptability lies in mimicking and responding to observed opponent actions.
'''

description_EXPLOITATIVE_32 = '''
 Strategy Name: Tit-for-Tat Cooperation with Adaptive Escalation (TTTAE)

1. Specify decision rules:
   - In the first round, cooperate to foster a positive environment and encourage potential cooperation from others. `if round = 1 then cooperate`
   - For subsequent rounds, observe the previous round's total contribution and adjust strategy accordingly.
     - If the majority (>50%) of players cooperated in the previous round, cooperate to reinforce the positive interaction.
       ```
       if round > 1 and (total_contributions >= n/2) then cooperate
       ```
     - If fewer than half of players cooperated in the previous round, defect to punish non-cooperators and encourage them to change their strategy.
       ```
       if round > 1 and (total_contributions < n/2) then defect
       ```

2. Handle edge cases:
   - For the last round, as there is no future interaction, cooperate only if the majority of players contributed in the previous round to maximize the current payoff.
     ```
     if round = r and (total_contributions >= n/2) then cooperate
     ```

3. Be exploitative:
   - TTTAE strategy starts by being generous, but it quickly adapts to the opponents' behavior and retaliates against non-cooperators while rewarding cooperators. This strategy is designed to discourage repetitive defection from opponents and promote cooperation when possible.
   - The adaptive escalation component of TTTAE ensures that the strategy becomes progressively more punishing as it encounters repeated defections, making it difficult for other strategies to exploit this approach indefinitely.
'''

description_EXPLOITATIVE_33 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TFTA starts by cooperating (C) if it's the first round or the previous action of the player was also cooperation. If the previous action was defection (D), then TFTA will defect in response. After the initial round, TFTA maintains the strategy of cooperating only when its opponent cooperated in the previous round and vice versa.

Pseudocode:
```
function TFTA(t, previous_action, history):
  if t == 1 or previous_action == "C":
    return "C"
  else:
    if previous_action == "D":
      return "D"
    else:
      return history[t-1]
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since TFTA is a strategy based on past actions of opponents, it requires an initial move to establish its behavior. In this version, we will assume that all players cooperate in the first round to allow the strategy to adapt accordingly.

For the last round, since there are no future rounds, TFTA will defect as a form of punishment for any cooperation during the game. This ensures that the opponent does not gain an advantage by cooperating at the end.

3. Be exploitative - Clearly align with the exploitative mindset

TFTA aims to take advantage of opponents who deviate from cooperation, while maintaining cooperation when possible to achieve higher payoffs. The strategy is designed to be robust to a wide range of opponent behaviors by responding in kind to their actions: cooperating when they cooperate and defecting when they defect. This makes it difficult for an opponent to exploit TFTA, as any deviation from cooperation will result in a response of defection.

In summary, TFTA is an adaptive strategy that maintains cooperation with opponents who also cooperate, while punishing those who do not. The strategy aims to maximize payoffs by taking advantage of opponents' deviations from cooperation and encouraging continued cooperation when possible.
'''

description_EXPLOITATIVE_34 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - In the first round, TfTA cooperates to foster a cooperative environment and give potential partners a chance.
   - After the first round, TfTA adapts its behavior based on previous opponents' actions. If an opponent cooperated in the previous round, TfTA cooperates in the current round; otherwise, TfTA defects.
   - TfTA continues this pattern of mirroring the opponent's last move while maintaining a memory of past interactions to calculate the average level of cooperation from each opponent.
   - If the average level of cooperation drops below a certain threshold (e.g., 50%), TfTA starts defecting as exploitative behavior is likely profitable in such situations.

2. Handle edge cases:
   - In the last round, TfTA cooperates if it leads to a higher payoff than defecting based on its current average level of cooperation with the opponent (TfTA will remember how its opponent behaved until that point). If defecting yields a higher payoff, TfTA will defect.
   - In case of ties or unclear responses from opponents, TfTA follows its previous action to avoid ambiguity and maintain consistency in decisions.

3. Be exploitative:
   - By mimicking the opponent's last move, TfTA attempts to create cooperative environments when it benefits but defects when it senses an exploitative opportunity based on the average level of cooperation from its opponents. This strategy is designed to be adaptive and robust against various opponent behaviors while still being exploitative in nature.

Pseudocode for Tit-for-Tat-Adaptive:

```
function TfTA(round, history, avg_cooperation, threshold) {
  if (round == 1) {
    return 'C' // Cooperate in the first round
  }

  last_opponent_action = history[round - 1]

  if (last_opponent_action == 'C') {
    return 'C' // Cooperate when opponent cooperated last time
  } else {
    avg_cooperation += calculate_average(history, round)

    if (avg_cooperation < threshold) {
      return 'D' // Defect when average level of cooperation falls below the threshold
    } else {
      return 'C' // Cooperate when opponent defected last time
    }
  }
}

function calculate_average(history, round) {
  sum = 0
  count = 0

  for (i = round - len(history); i < round; i++) {
    if (history[i] == 'C') {
      sum += 1
      count++
    }
  }

  return count > 0 ? sum / count : 0 // Return average level of cooperation based on history
}
```
'''

description_EXPLOITATIVE_35 = '''
 In this strategic game, we will design a Tit-for-Tat with Punishment (TFTP) exploitative strategy that adapts to various opponent behaviors while maintaining an exploitative mindset. Here's how the strategy works:

1. Specify decision rules - When exactly do you cooperate vs defect?
The TFTP strategy will start by cooperating in the first round, as it is important to build trust and allow other players to profit initially. After that, the strategy will mimic the opponent's actions from the previous round. If the opponent cooperates, the strategy will also cooperate; if the opponent defects, the strategy will defect in the next round. However, to introduce a punishment mechanism, the TFTP strategy will switch to always defecting after a certain number of defections (punishment threshold) from the opponent. The goal is to teach uncooperative opponents a lesson while still being able to benefit from cooperative ones.

Pseudocode:
```
if round = 1:
    cooperate()
else:
    if previous_round_opponent_action == COOPERATE:
        cooperate()
    else:
        if defections > punishment_threshold:
            defect()
        else:
            previous_round_opponent_action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the last round, the TFTP strategy will always cooperate to maximize potential gains, regardless of the opponent's actions. For other edge cases like the first round or when the punishment threshold is not met yet, the strategy behaves as described earlier (cooperating in the first round and mimicking the opponent's actions afterward).

3. Be exploitative - Clearly align with the exploitative mindset
The TFTP strategy is designed to be exploitative by taking advantage of cooperative opponents while punishing uncooperative ones. By cooperating initially, the strategy builds trust and allows other players to benefit; however, if an opponent starts defecting, the strategy will retaliate by defection to teach the opponent a lesson. The punishment mechanism helps enforce cooperation among opponents, maximizing the payoff for the TFTP strategy.

To adjust the strategy's aggressiveness, the punishment threshold can be set based on observations of other strategies' behavior in the tournament. A lower threshold will make the strategy more aggressive, while a higher threshold will make it more forgiving. Finding an optimal punishment threshold is crucial to maximizing payoff in the game.

This TFTP strategy provides a solid foundation for competing against various AI-generated opponents, as it strikes a balance between cooperation and exploitation. It offers flexibility by adapting to different opponent behaviors while maintaining its exploitative mindset, making it a robust competitor in the tournament.
'''

description_EXPLOITATIVE_36 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TfT-AG)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, starting from round 2, the TfT-AG strategy will cooperate if at least half of the players (n/2) cooperated in the previous round (t-1). Otherwise, it will defect. This is based on the traditional Tit-for-Tat strategy but with a slight modification for adaptability:

```python
def TfT_AG(player_history, n, k):
    if t == 1:  # First round: cooperate unconditionally
        return 'C'
    total_cooperators_prev = sum(player_history[t-1])
    if total_cooperators_prev >= (n/2):  # Cooperate if more than half cooperated last round
        return 'C'
    else:  # Defect otherwise
        return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round (t=1), TfT-AG cooperates unconditionally to foster cooperation and encourage other strategies to reciprocate. In the last round (t=r) or when close to the end of the game, the strategy may become less generous due to the limited opportunities for payback:

```python
def TfT_AG(player_history, n, k, r, t):  # Modified function with additional parameters
    if t == r:  # Last round: become less generous
        return 'D'
    elif t == 1:  # First round: cooperate unconditionally
        return 'C'
    else:
        total_cooperators_prev = sum(player_history[t-1])
        if total_cooperators_prev >= (n/2):  # Cooperate if more than half cooperated last round
            return 'C'
        else:  # Defect otherwise
            return 'D'
```

3. Be exploitative - Clearly align with the exploitative mindset
TfT-AG attempts to be exploitative by only cooperating when it expects reciprocity from the majority of players (n/2). In cases where a majority defects, TfT-AG will also defect, denying them any potential benefit from cooperation. However, if there is an opportunity for mutual gain through cooperation (more than half cooperated in the previous round), TfT-AG will cooperate and potentially punish non-cooperative opponents by withholding cooperation later on.

It's important to note that TfT-AG is not overly exploitative as it does not always defect, but instead aims for a balance between cooperation and defection based on the observed behavior of other players.
'''

description_EXPLOITATIVE_37 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules:
   - In each round, evaluate the number of cooperators in the previous round (n_c). If n_c < (n/2), defect (D); otherwise, cooperate (C). This rule is based on the assumption that majority cooperation is beneficial for individual payoff.
   - To adapt to opponent behaviors, introduce a penalty phase and forgiveness phase:
     - Penalty Phase: If an opponent defects after cooperating previously, respond with a series of defections until they reciprocate cooperation. This discourages opponents from taking advantage of previous cooperation. The length of the penalty phase depends on the number of consecutive defections by the opponent (p). The longer the sequence, the more severe the punishment.
     - Forgiveness Phase: If an opponent has been defecting for a while but then cooperates again, forgive them and return to cooperating. This encourages opponents who have learned their lesson to switch back to cooperation.

2. Handle edge cases:
   - First round: Cooperate as a friendly gesture, demonstrating potential for mutual cooperation.
   - Last round: Analyze the payoff-to-date and make the decision based on the decision rule. If the total payoff is positive (i.e., overall beneficial), cooperate; otherwise, defect. This approach ensures that TfT-A does not lose out in the final round due to poor strategic decisions earlier in the game.
   - In case of a tie (same number of cooperators as half of n) in the previous round: Cooperate to maintain a positive relationship with other players.

3. Be exploitative:
   - TfT-A does not rely on cooperation schedules, predetermined patterns or norms shared among opponents. Instead, it adapts to their behavior by using punishment and forgiveness strategies. By responding to an opponent's defections with a series of defections, TfT-A discourages exploitation while still encouraging cooperation when it is beneficial for the individual payoff.

Pseudocode:
```python
def TitForTatAdaptive(n, k, r, round, previous_round, total_payoff):
  if round == 1:
    action = "C" # Cooperate in the first round
  elif round == r:
    if total_payoff > 0:
      action = "C" # Cooperate in the last round if overall payoff is positive
    else:
      action = "D" # Defect in the last round if overall payoff is negative
  else:
    n_c = count_cooperators(previous_round)
    if n_c < n // 2:
      action = "D" # Defect when majority did not cooperate in the previous round
    elif n_c == n - n_d: # Assuming there are n players and n_d defectors
      action = "C" # Cooperate when majority cooperated in the previous round
    else:
      if previous_round[-p] != "C": # Enter penalty phase if opponent defected after cooperation
        p += 1
        action = "D"
      elif previous_round[-1] == "C": # Forgive opponent and return to cooperation
        p = 1
        action = "C"
  return action
```
In this pseudocode, `p` is a parameter that controls the length of the penalty phase (default value: 3) and `count_cooperators(previous_round)` counts the number of cooperators in the previous round.
'''

description_EXPLOITATIVE_38 = '''
 Strategy Name: Adaptive Tit-for-Tat with Threshold (A3T)

1. Specify decision rules - When exactly do you cooperate vs defect?
   A3T follows a cooperative approach initially, gradually adapting its strategy based on the opponents' behavior over time. The primary decision rule is as follows:

   - In the first round (t=1), always cooperate (C). This encourages cooperation by mimicking an optimistic player.
   - From the second round (t > 1) until a threshold of total opponents' defections (Td) is reached, cooperate if more than half of the opponents have cooperated in the previous round; otherwise, defect.
     Adjust Td based on the number of players (n) and rounds (r):
       - For r <= n: set Td = floor(r / 2)
       - For r > n: set Td = n
   - After reaching the threshold, the strategy becomes more exploitative by cooperating only if all opponents have cooperated in the previous round.
     If all opponents have defected, also defect. Otherwise, continue to adjust cooperation based on a majority rule (> half).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The A3T strategy is designed to handle edge cases as follows:
   - In the first round, cooperate (C) regardless of the opponents' behavior.
   - In the last round, cooperate if all opponents have cooperated in the previous round; otherwise, defect.
   - For any intermediate round where Td has not been reached yet, follow the majority rule described above.

3. Be exploitative - Clearly align with the exploitative mindset
   Although A3T starts as a cooperative strategy, it becomes increasingly exploitative after encountering repeated defections from opponents. The threshold mechanism allows it to punish opponents who consistently defect while maintaining cooperation among cooperators.

Pseudocode:
```
n = number of players
r = number of rounds
k = multiplication factor
Td = threshold of defections (initially set Td = floor(r / 2))
total_defections_history = []

function playRound(round, opponents_actions):
  total_cooperators = countCooperators(opponents_actions)

  if round == 1:
    action = 'C'  # Cooperate in the first round
  elif round > r - 1 and total_defections_history >= Td:
    action = 'C' if all(opponents_actions == 'C') else 'D'  # Last round or threshold reached, become more exploitative
  elif total_cooperators > n / 2:
    action = 'C'  # Cooperate if > half of opponents cooperated
  else:
    action = 'D'   # Defect otherwise

  playAction(action)
  updateTotalDefectionsHistory()
  return payoff(action, opponents_actions)

function countCooperators(opponents_actions):
  total_cooperators = 0
  for opponent in opponents_actions:
    if opponent == 'C':
      total_cooperators += 1
  return total_cooperators

function updateTotalDefectionsHistory():
  total_defections_history.append(countDefectors(opponents_actions))

function countDefectors(opponents_actions):
  total_defectors = 0
  for opponent in opponents_actions:
    if opponent == 'D':
      total_defectors += 1
  return total_defectors
```
'''

description_EXPLOITATIVE_39 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfTA follows a simple yet robust rule:
   - Initially (first round), cooperate to foster an atmosphere of cooperation.
   - In subsequent rounds, mimic the opponent's action from the previous round. If the opponent cooperated in the last round, do the same; if not, defect this round.
   - However, to avoid being exploited in the long run, TfTA will occasionally deviate from its current strategy (i.e., cooperating or defecting) with a small probability p (described later).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate to initiate cooperation and set a cooperative tone.
   - Last round: Mimic the opponent's action from the previous round since there are no subsequent rounds for retaliation or rewarding cooperation.
   - Other edge cases (e.g., mid-game): Follow the TfTA rule as described in point 1.

3. Be exploitative - Clearly align with the exploitative mindset:
   Although TfTA is not inherently exploitative, it can be seen as such due to its tendency to retaliate against defection and encourage cooperation when opponents cooperate. This behavior might lead opponents to believe that TfTA is susceptible to being exploited, making them hesitant to defect since they risk losing future cooperative opportunities. However, TfTA's occasional deviations from its current strategy help it avoid becoming overly exploitative and maintain a balance between cooperation and defection.

Pseudocode:

```
def TitForTatAdaptive(n, k, r, p):
    # Initialize history as an empty list
    history = []

    for round in range(r):
        if round == 0:
            # Cooperate in the first round
            action = 'C'
        else:
            # Retrieve the last action from history
            last_action = history[-1]

            # If the opponent played C (cooperated) last round, cooperate this round
            if last_action == 'C':
                action = 'C'
            # Otherwise, defect this round with a small probability p to deviate from current strategy
            elif random.random() < p:
                action = 'D'
            else:
                # Defect this round if the opponent played D (defected) last round
                action = 'D'

        history.append(action)
        payoff = calculatePayoff(n, k, action, history)
        # Update the total game payoff for this player
        total_payoff += payoff

    return total_payoff
```
'''

description_EXPLOITATIVE_40 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, play C to foster cooperation and signal goodwill.
   - After the first round, monitor other players' actions. If a player has cooperated in the previous round (c_j = 1), reciprocate by also cooperating (C) in the current round. If a player has defected (c_j = 0), also defect (D) in the current round to punish them for their uncooperative behavior.
   - Continue this pattern of mirroring other players' actions, adjusting responses based on observed cooperation or defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, regardless of the previous action of an opponent, cooperate (C) to maximize payoff from any potential cooperation by opponents.
   - In other edge cases such as early termination of the game or when the number of rounds is not known in advance, TFTA will default to reciprocating the last observed action of an opponent while continuing to monitor their behavior for changes.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFTA strategy is designed to be exploitative by punishing uncooperative players with defections and rewarding cooperative players with reciprocation. This creates a delicate balance that encourages cooperation but also penalizes frequent defection, making it difficult for purely exploitative strategies to achieve high payoffs consistently.
   - By adapting its responses based on the actions of other players, TFTA can evolve and respond effectively to various opponent behaviors, maximizing potential gains while minimizing losses due to exploitation.

Pseudocode:
```
def TFTA(round, history):
  if round == 1:
    return "C" (Cooperate)

  previous_action = history[-1] # last action of the opponent
  if previous_action == "C":
    return "C" (Cooperate)
  else:
    return "D" (Defect)
```
'''

description_EXPLOITATIVE_41 = '''
 Strategy Name: Tit-for-Tat with Escalation (TfTE)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TfTE starts by cooperating (C), mimicking the initial cooperative nature of the Prisoner's Dilemma. Subsequent actions are based on the opponent's previous action:
- If the opponent cooperates in the same round, TfTE cooperates back.
- If the opponent defected in the same round, TfTE defects in the next round (punishing the opponent for defection).
- After punishment, TfTE will cooperate again if the opponent cooperates in the following round, signaling forgiveness and returning to cooperation.

However, TfTE includes an escalation mechanism to prevent being exploited by overly aggressive opponents:
- If an opponent defects continuously for a streak of L consecutive rounds, TfTE will also start defecting for L rounds as a response. This ensures that TfTE does not continue to cooperate indefinitely with an uncooperative opponent.
- After the escalation period ends, TfTE reverts back to its original strategy (cooperate and respond based on opponent's actions).

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, all players cooperate (since no history exists), and from then on TfTE follows the decision rules mentioned earlier. In the last round, since there are no subsequent rounds, TfTE does not need to consider future payoffs or punishment strategies. It will cooperate if the opponent cooperated in the previous round, otherwise defect.

3. Be exploitative - Clearly align with the exploitative mindset

TfTE's primary goal is to maximize its own payoff while minimizing the benefits gained by other players. By initially cooperating and then adapting its actions based on the opponent's behavior, TfTE aims to earn higher payoffs when opponents are cooperative, while still being able to punish and respond to uncooperative opponents through escalation. This strategy allows TfTE to exploit both short-term and long-term cooperation from other players, as well as defend against overly aggressive opponents.

Pseudocode:
```
def tit_for_tat_with_escalation(opponent_history, n, k, r):
    history_length = len(opponent_history)
    streak = 0
    escalation_length = 10

    if history_length == 0: # first round
        action = 'C'
    elif history_length == r: # last round
        if opponent_history[-1] == 'C':
            action = 'C'
        else:
            action = 'D'
    else:
        current_action = opponent_history[-1]
        if current_action == 'C':
            action = 'C'
        elif current_action == 'D':
            if streak < escalation_length:
                streak += 1
                action = 'D'
            else:
                streak = 0
                action = 'C'
    return action
```
'''

description_EXPLOITATIVE_42 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round, mirroring the other players' cooperation or defection in subsequent rounds. If a player has consistently cooperated in the previous t rounds, TFT-AC also cooperates. Otherwise (the opponent has defected at least once in the last t rounds), TFT-AC defects. The value of t is adaptive and increases linearly with each round, as follows:
   - In the first t rounds, t = 1 (start by being cooperative)
   - For all subsequent rounds t > 1, calculate t as the minimum value such that the opponent has cooperated at least t times in the previous t rounds. If no such value exists, consider the opponent as consistently uncooperative and defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-AC starts by cooperating in the first round since there is no history to base decisions on. In the last round or any round where the calculated t exceeds the number of remaining rounds (r), TFT-AC defects as it has no expectation of future interactions.

3. Be exploitative - Clearly align with the exploitative mindset
   While designed to mimic cooperative behaviour, TFT-AC's adaptive nature makes it appear unpredictable and less vulnerable to exploitation by other strategies. By gradually increasing t, TFT-AC balances cooperation with defection in a way that can discourage other players from repeatedly defecting without risking being left behind in terms of total payoff if the game dynamics shift towards cooperation. Additionally, TFT-AC's response to an opponent's defection is immediate, which can lead to quick punishment and potentially deter future defections.

Pseudocode:
```python
def tft_ac(r, n, k):
    history = []  # store the history of cooperation/defection for each round
    payoff = 0

    def cooperate():
        return True  # always cooperate in the first round

    def adaptive_t(i):
        t = min([j for j in range(1, i+1) if all([history[i-j][0] for i in range(i-j, i)])] or r)
        return t

    for round in range(r):
        if round == 0:
            action = cooperate()
        else:
            action = (adaptive_t(round))[1]  # True for cooperation, False for defection
        history.append((action, payoff))
        payoff += (1 - action) + (k / n) * sum([history[i][0] for i in range(round)])
    return payoff
```
'''

description_EXPLOITATIVE_43 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTGC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to show goodwill and encourage cooperation from others.
   - After the first round, observe the opponent's actions in the previous round and adapt accordingly:
     - If the opponent cooperated (C), reciprocate with cooperation (C).
     - If the opponent defected (D), also defect (D) to punish them for their selfish behavior.
   - To reduce overly harsh punishment, gradually adjust the duration of retaliation:
     - For every three consecutive defections by the opponent, respond with one less round of defection before returning to cooperation.
     - If the opponent starts cooperating again, return to reciprocating their actions.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), always cooperate (C).
   - In the last round (t=r), consider the current state of cooperation with the opponent and choose the action that maximizes payoff for the remaining rounds:
     - If the opponent has been cooperative, continue reciprocating their actions.
     - If the opponent has not been cooperative, defect to receive a private payoff as high as possible in the last round before the game ends.
   - In all other cases (t ≠ 1, t ≠ r), follow the decision rules from part 1.

3. Be exploitative - Clearly align with the exploitative mindset
   - By following a reciprocal strategy that punishes defection and rewards cooperation, TFTGC seeks to encourage opponents to cooperate and thus maximize its own payoff while still appearing cooperative itself.
   - If an opponent is consistently selfish (always defects), TFTGC will exploit their behavior by retaliating with defections in order to earn the highest possible payoff given the circumstances.
   - However, TFTGC is also designed to be forgiving and willing to re-establish cooperation if the opponent shows signs of changing their behavior. This gradual approach allows for potential long-term gains as opposed to a purely exploitative strategy that may lead to mutual defection or lack of cooperation in the long run.
'''

description_EXPLOITATIVE_44 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game (TFTPG)

1. Specify decision rules:
   - In each round, players decide to cooperate (C) or defect (D). The TFTPG strategy is based on a tit-for-tat approach, with some modifications to be more adaptive and exploitative in the public goods game context.

   - Initially, each player starts by cooperating (C). If all players continue cooperating, they will do so throughout the game.

   - If any player defects at any round t, the TFTPG strategy responds with defection in the next round (t+1) and continues this non-cooperative behavior for a punishment period of "punishment_length" rounds. After this period, the player switches back to cooperating, hoping that others will follow suit.

   - In case another player defects during the punishment phase, the player extends the punishment length by an additional "increase_length" number of rounds before returning to cooperation. This ensures that the strategy can respond to repeated defections without being exploited indefinitely.

2. Handle edge cases:
   - First round: All players start by cooperating since there is no prior information about other players' actions.

   - Last round (r): If a player has entered the punishment phase and the game is nearing its end, they will continue defecting until the game concludes to maximize their payoff over the remaining rounds. However, if the player is not in the punishment phase during the last round, they will cooperate to potentially earn higher payoffs from the public good.

3. Be exploitative:
   - The TFTPG strategy aims to balance cooperation and defection based on the game's dynamics. By defecting when others do so and returning to cooperation after a punishment phase, it can encourage other players to cooperate while also protecting itself against repeated defections.

   Pseudocode for TFTPG Strategy:

```
function TFTPG(n, k, r, punishment_length, increase_length) {
  current_round = 1
  cooperation_history = [True] * r # Boolean array representing past cooperative actions

  while (current_round <= r):
    if current_round == 1 or all(cooperation_history[current_round - 1:]) == True:
      cooperate = True
    else:
      cooperate = False
      punishment_counter = 0

    if cooperate and all players cooperate this round:
      cooperation_history.append(True)
    elif cooperate and any player defects this round:
      cooperation_history.append(False)
      punishment_counter += 1
      if punishment_counter >= punishment_length:
        punishment_counter = 0
        cooperate = False
    else:
      cooperation_history.append(cooperate)

    current_round += 1
}
```
'''

description_EXPLOITATIVE_45 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfTA-C)

1. Decision Rules:
   - Initially cooperate in the first round (C) to build goodwill and encourage others to cooperate.
   - In subsequent rounds, analyze the history of opponent's actions (Cooperate or Defect) and respond accordingly by Cooperating if the opponent has recently cooperated (i.e., in the previous round), otherwise Defect. This mimics a cooperative and forgiving approach while also being prepared to retaliate against defection.
   - For adaptability, introduce a parameter 'p' which represents the propensity for initial cooperation in subsequent rounds. This parameter will gradually decrease as the game progresses, encouraging less cooperation over time and better preparing the strategy for exploitative opponents. The formula for p is:
     ```
     p = max(0, p - (1/r))
     ```
     where r is the total number of rounds.

2. Edge Cases:
   - In the last round, always defect (D), as there are no more opportunities for retaliation or cooperation.
   - If the opponent has never cooperated throughout the game, always defect (D) starting from the current round. This is to prevent infinite forgiveness and potential exploitation by uncooperative opponents.

3. Exploitative Mindset:
   - By gradually reducing the propensity for initial cooperation as the game progresses, the strategy becomes more resilient to defection while still maintaining a cooperative starting point that encourages others to cooperate initially.
   - The strategy retaliates against defection by defecting in response, which punishes uncooperative behavior while still allowing for future cooperation if the opponent changes their strategy. However, once an opponent has consistently defected, the strategy becomes less forgiving and more likely to defect as well.

Pseudocode:

```python
def TfTA_C(opponent_history, r, p):
    player_action = C  # Cooperate initially
    opponent_cooperated_last_round = False

    for round in range(1, r+1):
        if round == 1:
            p = max(0, p - (1/r))  # Adjust propensity for cooperation

        if round != r and not opponent_history[-1] == D:  # If opponent cooperated last round
            opponent_cooperated_last_round = True
            player_action = C  # Cooperate in response
        elif round != r and opponent_history[-1] == D:  # If opponent defected last round
            opponent_cooperated_last_round = False
            if not all(opponent_history[:-1]) == D:  # If opponent never cooperated before this round
                player_action = D  # Defect in response and become less forgiving
        else:  # Last round, always defect regardless of opponent's action
            player_action = D

    return player_action
```
'''

description_EXPLOITATIVE_46 = '''
 Strategy Name: Tit-for-Tat with Time Delay (TFTD)

1. Specify decision rules:
   - In the first round, cooperate to start off on a positive note and encourage others to cooperate.
   - For subsequent rounds, observe the previous opponent's action. If they cooperated in the last round, cooperate; otherwise defect.
   - Introduce a time delay to slow down retaliation against defection, reducing the likelihood of entering an immediate escalating cycle of revenge. The time delay can be represented as 'd' rounds, where d is a predefined integer (e.g., d=3).

Pseudocode:
```
def TFTD(round_number, opponent_history, time_delay=3):
  if round_number == 1:
    return "Cooperate"

  history_length = min(len(opponent_history), round_number - 1)
  last_cooperation = history_length - time_delay

  for i in range(last_cooperation, -1, -1):
    if opponent_history[i] == "Cooperate":
      return "Cooperate"
  return "Defect"
```

2. Handle edge cases:
   - For the last round, defect since there will be no subsequent rounds to retaliate against defection.
   - If the time delay exceeds the remaining rounds (round_number - 1), adjust the time delay accordingly to avoid out-of-bounds errors.

3. Be exploitative:
   - TFTD is designed to be initially cooperative, encouraging others to cooperate. However, once an opponent defects, it will gradually retaliate over a defined time period (time_delay). This strategy aims to punish defection while maintaining the possibility of cooperation when opponents change their behavior.
   - The time delay allows TFTD to be more forgiving than traditional Tit-for-Tat, reducing the likelihood of entering a cycle of mutual retaliation that could result in suboptimal payoffs for both players.
'''

description_EXPLOITATIVE_47 = '''
 Strategy Name: Adaptive Tit-for-Tat with Punishment (ATTP)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATTP strategy will initially cooperate in the first round (C in first_round = True). In subsequent rounds, it will follow a tit-for-tat approach: if an opponent has cooperated in the previous round, the ATTP strategy will also cooperate in the current round (cooperate if previous_action_opponent == C). If the opponent defected in the previous round, the ATTP strategy will punish them by defecting as well (defect if previous_action_opponent == D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, ATTP always cooperates since it's an initial goodwill gesture (first_round = True). For the last round (round == r), ATTP will defect regardless of the opponent's previous action because there are no future interactions and the strategy aims to maximize personal payoff in that round.

3. Be exploitative - Clearly align with the exploitative mindset
   The ATTP strategy can be considered exploitative due to its punishing nature when opponents do not cooperate. By defecting after an opponent's defection, it discourages repetitive defections and encourages cooperation in order for the opponent to recover from punishment. However, ATTP will also cooperate if its opponent cooperates, potentially leading to a mutually beneficial equilibrium.

Pseudocode:
```python
def ATTP_strategy(n, k, r, round, previous_action_opponent):
    strategy = {}

    first_round = True if round == 1 else False
    last_round = round == r

    if first_round:
        strategy['current_action'] = 'C'
    elif previous_action_opponent == 'D':
        strategy['current_action'] = 'D'
    else:
        strategy['current_action'] = previous_action_opponent

    if last_round:
        strategy['current_action'] = 'D'

    return strategy
```
'''

description_EXPLOITATIVE_48 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially in the first round (t=1), the player cooperates to signal goodwill and foster cooperation among other players.
   - In subsequent rounds, the player will imitate the actions of the most common action among the previous r-1 rounds (TFT part). If the majority of the players have been cooperative, the player will also cooperate. Conversely, if the majority has defected, the player will defect as well to punish those who did not contribute.
   - To make the strategy more adaptive and exploitative, the contribution level (k) is adjusted based on the average number of cooperators in the last r-1 rounds. If the average number of cooperators is low, k is reduced, making it less attractive for players to cooperate. Conversely, if the average number of cooperators is high, k is increased, incentivizing cooperation. The adjustment formula for k is:

        k_t = min(max(1 + (avg_cooperators - n/2)/n, 1), n)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), the player cooperates as a gesture of goodwill.
   - In the last round (t=r), the player imitates the actions of the most common action among the previous r-1 rounds. However, if the average number of cooperators in the last few rounds is significantly lower than the average for the entire game, the player will defect to exploit the other players who have already contributed generously.
   - In cases where a player encounters a deviation from the most common action (e.g., a single defector in a round of cooperators), the player responds by copying that deviant behavior for the next r-1 rounds to punish the deviant player and signal disapproval. After the punishment phase, the player will revert to imitating the most common action among the previous r-1 rounds.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The strategy is designed to be both cooperative and exploitative. Initially, it encourages cooperation by following a "nice" strategy. However, if other players are not reciprocal and consistently defect, TFTAC will adjust its contribution level (k) to make defection more attractive and punish non-cooperators.
   - In addition, the strategy is adaptive in that it responds to deviations from the most common action, allowing it to exploit inconsistencies or deviant behaviors exhibited by other players.

Pseudocode:

```python
def tftac(n, k, r):
    player_history = []  # stores previous actions of all players in a matrix (r x n)
    avg_cooperators = sum([sum(row) for row in player_history]) / (r * n)  # average number of cooperators in the last r rounds

    def play_round():
        contribution = copy_most_common() if len(player_history) > r-1 else cooperate()  # copy most common action or cooperate in first round
        player_history.append([contribution] * n)  # store the current round's actions

    def cooperate():
        return True  # cooperate in the first round as a gesture of goodwill

    def copy_most_common():
        most_common = max(player_history[-r:], key=lambda x: sum(x))[0]  # find the most common action among the last r rounds
        if most_common == 'C':  # majority has cooperated
            return True
        else:  # majority has defected
            k = adjust_k(avg_cooperators)  # adjust contribution level (k) based on average number of cooperators in the last r rounds
            return False if k < n - 1 else True  # make it less attractive to cooperate when average is low, or more attractive when average is high

    def adjust_k(avg_cooperators):
        return min(max(1 + (avg_cooperators - n/2)/n, 1), n)

    for round in range(r):
        play_round()
```
'''

description_EXPLOITATIVE_49 = '''
 Title: Tit-for-Tat with Gradient Adjustment (TfTGA) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initialize a gradient variable G for each player, representing the difference between the expected payoff from cooperating and defecting in the previous round. Set all gradients to zero at the start of the game (first round).
   - In each round t, calculate the gradient G_i,t using historical data (previous rounds) as follows:
     ```
     if player i cooperated in round t-1 and at least one other player did not:
        G_i,t = k * (1 - contribution_average) - 1
     else if player i defected in round t-1 and all players cooperated:
        G_i,t = 1 - contribution_average
     else:
        G_i,t = 0
     ```
   Where `contribution_average` is the average number of cooperators in the previous r rounds.

   - In each round t, player i decides whether to cooperate or defect based on their gradient G_i,t:
     ```
     if G_i,t > 0:
        Cooperate (C)
     else:
        Defect (D)
     ```

2. Handle edge cases:
   - First round: As there is no historical data, players will randomly cooperate or defect. This initial action sets the gradients for future decision making.
   - Last round: Players use their current gradients to decide whether to cooperate or defect, as per the decision rules above.

3. Be exploitative:
   - The TfTGA strategy aims to maximize individual payoffs by adjusting cooperation based on past actions of others. It is responsive to the actions of other players, punishing defection when it occurs and rewarding cooperation where possible. This encourages other players to cooperate, but also ensures that player i will defect if necessary to maintain or improve their payoff.
   - The strategy is adaptive because it adjusts gradients based on historical data, allowing it to learn and adapt to various opponent behaviors over the course of the game.
   - The gradient-based approach allows TfTGA to be robust, as it does not rely on specific coordination mechanisms or shared norms. Instead, it responds dynamically to the actions of others in a flexible manner.
'''

description_EXPLOITATIVE_50 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR)

1. Decision Rules:
   - In the initial round (t=1), cooperate to encourage trust and establish a cooperative relationship.
   - From round 2 to r, maintain cooperation if all opponents also cooperated in the previous round. If any opponent defected, defect in the current round as retaliation but gradually decrease the rate of immediate retaliation over time. The rate of adaptation is determined by the parameter k.

Pseudocode for decision rule:
```
function decideAction(t, own_history, opponents_history):
  if t=1:
    return "Cooperate"

  if all(opponents_history[t-1] == "Cooperate"):
    return "Cooperate"
  else:
    cooperation_rate = min(1 - ((t-2)/(r-2)) * (1/k), 1)
    if own_history[t-1] == "Cooperate":
      return "Defect"
    else:
      return "Cooperate" with probability cooperation_rate, otherwise return "Defect"
```

2. Handle Edge Cases:
   - Last Round (t=r): Since there are no future rounds to consider, always cooperate in the last round regardless of opponent behavior. This encourages opponents to also cooperate in the final round.

3. Be Exploitative:
   - The strategy has an exploitative mindset by retaliating against defection with a delayed and adaptive response rather than immediately defecting every time an opponent does so. However, the adaptation of cooperation rate over time allows for more cooperative behavior in later rounds when trust is established among players.
   - By retaliating less in later rounds, the strategy discourages opponents from solely adopting a defection strategy and encourages long-term cooperation while still being responsive to opponent behavior.
'''

description_EXPLOITATIVE_51 = '''
 Title: Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TFTAC strategy starts by deciding whether it's the first or subsequent round based on the current round number:

If t == 1:
  - Cooperate (contribute to public good)

Else if previous_round_total_cooperation > (n/2):
  - Cooperate (contribute to public good)

Else:
  - Defect (keep endowment privately)

In subsequent rounds, the strategy imitates other players' behavior from the previous round. If all players cooperated in the previous round, they will also cooperate in the current round. Otherwise, they will defect. This mimics a "Tit-for-Tat" approach while adding an adaptation mechanism for varying player cooperation levels.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, since t == 1, the strategy cooperates (contributes to public good). The last round's behavior may depend on whether the number of rounds is predetermined or not:

If r is predetermined and it's the last round:
  - Defect (keep endowment privately) as there are no more future interactions.

If r is unknown or if it's unclear if the current round is the last one:
  - Cooperate (contribute to public good), following the "Tit-for-Tat" approach, which assumes that the game will continue indefinitely or for an unknown number of rounds.

3. Be exploitative - Clearly align with the exploitative mindset

Although this strategy is designed to be adaptive and robust against various opponent behaviors, it can still be considered exploitative because it takes advantage of the cooperation of other players when they contribute more than necessary (when total_cooperation > n/2) while not contributing as much in return. However, if all opponents also adopt an exploitative strategy, the long-term payoff may be lower compared to situations where some players cooperate more consistently. The adaptive nature of TFTAC makes it capable of adapting to different levels of cooperation among opponents, maximizing its own payoffs while causing others to invest less in the public good when necessary.
'''

description_EXPLOITATIVE_52 = '''
 Strategy Name: Adaptive Tit-for-Tat with Variable Cooperation (A-TFTV)

1. Specify decision rules:
   - In each round t (t > 1), if the total number of cooperators in the previous round (t-1) is greater than or equal to a threshold T, cooperate (C). Otherwise, defect (D). The threshold T can be calculated as follows:
     ```
     T = (n * (k - 1)) / n
     ```
   - In the first round, defect (D), as no previous actions are available for reference.
   - In the last round, cooperate (C) if the total number of cooperators in the penultimate round is greater than or equal to T, and defect otherwise. This ensures a potential reward in the final round while not over-cooperating when others have been uncooperative.

2. Handle edge cases:
   - If all players decide to cooperate (a best-case scenario for payoff), A-TFTV will also continue to cooperate to maximize its own payoff.
   - If all players decide to defect (a worst-case scenario), A-TFTV will also continue to defect, not being exploited by the other players' selfish behavior.

3. Be exploitative:
   - By setting the cooperation threshold T based on the game parameters, A-TFTV aims to identify and cooperate with other cooperative players while not overly cooperating when facing non-cooperative or exploitative opponents. This strategy adopts a responsive approach to potential opponents' actions, providing the basis for an adaptive and robust exploitative strategy.
   - It's important to note that A-TFTV does not rely on others sharing norms or coordination mechanisms; it simply responds based on the observed behavior of other players, making decisions based solely on the game parameters and history. This ensures a high level of adaptability in various game scenarios.
'''

description_EXPLOITATIVE_53 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (in the first round), cooperate to build a cooperative reputation and demonstrate goodwill.
   - For subsequent rounds, analyze the opponent's behavior from the previous round:
     - If the opponent cooperated in the last round, cooperate as well. This helps maintain cooperation and strengthen the partnership.
     - If the opponent defected in the last round, also defect in the current round to punish their defection. This demonstrates a retaliatory nature that discourages opponents from taking advantage of the strategy.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described earlier.
   - In the last round, cooperate regardless of the opponent's previous action to maximize payoff based on the current payoff structure (since no future rounds will occur).
   - If the number of remaining rounds is less than a predefined threshold (e.g., 5), start behaving less cooperatively to be prepared for the last rounds and avoid being exploited by opponents who might anticipate increased cooperation towards the end.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TFT-AC strategy initially cooperates but swiftly retaliates against defection, aiming to encourage cooperation while punishing those who attempt to exploit it.
   - By adapting its cooperation based on the opponent's behavior, the strategy remains flexible and can outsmart opponents employing various strategies, thereby enhancing its chances of success in the tournament.
'''

description_EXPLOITATIVE_54 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C) to show goodwill and trust, as it can foster cooperation in subsequent rounds.
     Pseudocode: if t = 1 then c_i = C else continue with adaptive strategy below.

   - Subsequent Rounds (t>1):
      - If the opponent cooperated in the previous round, return the favor and cooperate.
        Pseudocode: if prev_action_opponent[t-1] = C then c_i = C else continue with exploitative action below.

   - Exploitative Action (when opponent defected): Defect to punish the opponent for not cooperating, as this encourages them to cooperate in the future.
     Pseudocode: if prev_action_opponent[t-1] = D then c_i = D

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round (t=1): Cooperate as mentioned earlier.

   - Last Round (t=r): Since this is a repeated game, players might switch strategies based on their payoffs over the rounds. Therefore, our strategy should be flexible to adapt to the opponent's last-round behavior. If the opponent cooperated in the previous round, continue cooperating; otherwise, defect to punish them for not cooperating in the final opportunity.
     Pseudocode: if t = r then prev_action_opponent[r-1] == C then c_i = C else c_i = D

3. Be exploitative - Clearly align with the exploitative mindset
   The strategy is designed to encourage cooperation by initially showing goodwill and returning favors when cooperated upon, but it can also punish opponents who do not reciprocate cooperation by defecting on them. This way, the Tit-for-Tat strategy maximizes personal payoff while still promoting cooperation when possible.
'''

description_EXPLOITATIVE_55 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, in the first round, cooperate to establish a cooperative environment (C).
   - For subsequent rounds, evaluate the cooperation rate (CR) of the previous round and compare it with a predefined adaptive threshold (AT). If CR >= AT, cooperate; otherwise, defect.
   - The AT is determined by the average contribution rate observed in previous games played by this strategy. This adaptive threshold helps balance short-term exploitation with long-term cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as a peace offering to potential partners.
   - In the last round, cooperate if the average CR over previous rounds exceeds AT; otherwise, defect, since there are no more rounds for reciprocation.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy uses an adaptive threshold to respond to opponent behaviors, punishing high defection rates and rewarding cooperative behavior. This encourages opponents to adopt cooperative strategies while deterring excessive exploitation.
   - In cases where all opponents defect, TFT-ACT will also defect, but its adaptive nature allows it to quickly revert to cooperation once others show signs of cooperating.

Pseudocode:

```
def tft_act(n, r, k):
    games_played = 0
    average_cr = 0

    for round in range(1, r+1):
        if games_played == 0:
            action = 'C' # Cooperate in the first round
        else:
            cr = total_contributions / n
            if cr >= AT:
                action = 'C' # Cooperate if CR >= AT
            else:
                action = 'D' # Defect otherwise

        games_played += 1

        if round < r:
            update_average_cr(cr) # Update average cooperation rate

        payoff = calculate_payoff(action, cr)

    return total_payoff(payoff)

def update_average_cr(cr):
    average_cr = (average_cr * games_played + cr) / (games_played + 1)

def calculate_payoff(action, cr):
    if action == 'C':
        payoff = (1 - cr) + (k/n) * cr * n
    else:
        payoff = 1 - cr

def total_payoff(payoffs):
    return sum(payoffs)
```
'''

description_EXPLOITATIVE_56 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate good intentions (C).
   - For subsequent rounds, analyze the opponent's behavior from the previous round:
     - If the opponent cooperated in the last round, cooperate again (C).
     - If the opponent did not cooperate in the last round, defect in this round (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate unconditionally (C).
   - In the last round, defect regardless of the opponent's previous action (D).
   - Between the first and last rounds, maintain the TFTAC strategy as described above.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially, TFTAC cooperates to encourage other players to cooperate, but if an opponent defects, it will also defect in response to punish them. This creates a balance between cooperation and defection, allowing TFTAC to take advantage of opponents who are prone to cooperation while not being excessively exploited by those who prefer defection.
   - The adaptive nature of the strategy ensures that it can adjust its behavior based on the opponent's actions, making it robust against various player strategies. This allows TFTAC to potentially gain more payoffs than fixed strategies, especially when playing against other AI systems.
'''

description_EXPLOITATIVE_57 = '''
 Strategy Name: Adaptive Tit-for-Tat with Time-Delayed Cooperation (ATTC)

1. Specify decision rules:
   - In each round t, player i evaluates whether the majority of players cooperated in the previous round t-1. If more than (n/2) players cooperated, player i cooperates. Otherwise, player i defects.
   - Player i cooperates for the first time after seeing n consecutive rounds where more than (n/2) players cooperate. This ensures a delay before starting to contribute to the public good.
   - In the last round, player i does not have a history and therefore will cooperate if more than (n/2) players cooperated in the previous round.

Pseudocode:
```
function ATTC(history, n, t):
    if t == 1 or len(history) < n:
        return "Cooperate" if length(history) > n/2 else "Defect"

    cooperation_count = count_cooperation(history[t-1])

    if cooperation_count > n/2:
        return "Cooperate"
    else:
        return "Defect"
```

2. Handle edge cases:
   - In the first round, since there's no history, player i cooperates only when more than (n/2) players also cooperate in this round.
   - In the last round, player i cooperates if more than (n/2) players cooperated in the previous round, considering that the strategy does not have a look-ahead mechanism to take future rounds into account.

3. Be exploitative:
   - By only cooperating when the majority of players did so in the previous round, the ATTC strategy maintains an exploitative mindset as it will not contribute to the public good unless it perceives others as doing so as well, thereby maximizing private payoffs while minimizing contributions.
   - The time-delayed cooperation feature allows for a more nuanced approach by withholding cooperation initially and only joining when observing repeated cooperative behavior from others, further emphasizing an exploitative strategy.
'''

description_EXPLOITATIVE_58 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Cooperate on the first round (FrtCooperate). This allows building relationships and encourages reciprocity.
   - In subsequent rounds, copy the opponent's action from the previous round (CopyOpponentAction). If an opponent cooperates, continue to cooperate; if an opponent defects, defect in response (Retaliation).

Pseudocode for TFT:
```
def tit_for_tat(previous_round_action):
  if current_round == 1:
    return Cooperate  # FrtCooperate
  else:
    return previous_round_action  # CopyOpponentAction

def retaliation(opponent_action):
  if opponent_action == Cooperate:
    return Cooperate
  else:
    return Defect
```

2. Handle edge cases:
   - Last round (FinalRound): To encourage long-term cooperation, switch back to cooperative behavior in the last round. This allows the opportunity for opponents to reciprocate.
   - Initial Cooperation (FrtCooperate) and Final Round (FinalRound) are defined as part of the TFT pseudocode above.

3. Be exploitative:
   - The TFT strategy is initially cooperative but responds harshly when defected against, making it a moderately exploitative strategy. It punishes defection while encouraging cooperation whenever possible. This approach seeks to build and maintain mutually beneficial relationships with opponents over the course of the game.

Pseudocode for handling the last round:
```
def final_round():
  return Cooperate  # encourage reciprocity in the last round
```
'''

description_EXPLOITATIVE_59 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i adopts the following rule to determine cooperation (C) or defection (D):

- If the total number of cooperators in the previous round (t-1) was greater than or equal to a threshold T, then player i will cooperate. This encourages reciprocity and builds trust among players.

   C = 1 if Σ(j=1 to n) c_j >= T from round (t-1), else D

- If the total number of cooperators in the previous round was less than the threshold T, then player i will defect in that round and adjust the threshold for the next round. The adjustment is made by either increasing or decreasing the threshold based on the player's own action in the current round.

   a) If player i cooperated, increase the threshold by 0.1 (to encourage cooperation in the future).
   b) If player i defected, decrease the threshold by 0.1 (to punish non-cooperators and encourage cooperation later).

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, players will randomly choose to cooperate or defect with a probability of 0.5 each. This helps avoid getting stuck in a suboptimal initial state and allows for exploration in the early stages of the game.

For the last round, player i continues to adjust the threshold as described above, but since there are no subsequent rounds, the adjusted threshold will not be used anymore.

3. Be exploitative - Clearly align with the exploitative mindset

By adopting a Tit-for-Tat approach with an adaptive cooperation threshold, TFT-AC encourages cooperation among players who exhibit cooperative behavior, while punishing those who defect. This strategy is designed to be robust and responsive to various opponent behaviors, making it more likely to outperform static strategies in the long run.

Pseudocode for the TFT-AC strategy:
```
initialize n, r, k, and T (default T = 0.5)
for each round t from 1 to r:
    calculate total number of cooperators (c_total) in round (t-1)
    if c_total >= T:
        player_i chooses C (cooperate)
        update threshold T = T + 0.1
    else:
        player_i chooses D (defect)
        update threshold T = T - 0.1
if t == 1:
    randomly choose between C and D with equal probability
```
'''

description_EXPLOITATIVE_60 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, TfTA will start by cooperating to signal a willingness to form a cooperative relationship. This is inspired by the classic Tit-for-Tat strategy in game theory.
   - For subsequent rounds, TfTA will examine the previous round's total cooperation level and respond accordingly:
      - If all players cooperated in the previous round (total_contributions = n), continue to cooperate.
      - If fewer than n players cooperated in the previous round, defect in the current round as a punishment for the non-cooperative behavior.
      - If a player has never cooperated before (i.e., always defected), TfTA will also defect in response to their persistent defection.
   - In the last round, TfTA will again cooperate, assuming that players may want to form a cooperative relationship for the final round's payoff.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: cooperate (C)
   - Last round: cooperate (C)
   - Subsequent rounds with total cooperation in the previous round: cooperate (C)
   - Subsequent rounds with fewer than n players cooperating in the previous round: defect (D)
   - For a player that has never cooperated before, always defect against them: if (player_history[i] == D for all t < r), defect (D).

3. Be exploitative - Clearly align with the exploitative mindset
   - TfTA is designed to be exploitative by punishing non-cooperative behavior and rewarding cooperation, while maintaining a long-term cooperative stance if other players reciprocate. This creates an environment where it is beneficial for opponents to cooperate in order to receive cooperation in return, but also allows TfTA to gain an advantage over less adaptive opponents by punishing their defections with defections of its own.
   - By starting with cooperation and only switching to defection when necessary, TfTA avoids unnecessary conflicts that could be exploited by more aggressive strategies, while still maintaining the ability to punish persistent non-cooperative behavior. This makes it a robust strategy against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_61 = '''
 Strategy Name: Tit-for-Tat with Variations (TFT-V)

1. Decision Rules:
   - In the first round, cooperate (C). This is a nice gesture that might encourage others to do the same.
   - For subsequent rounds, if an opponent cooperated in the previous round, cooperate (C) as well. If they defected, also defect (D) in the current round. This mimics the "Tit for Tat" strategy but adds a twist:
     - If the total number of opponents who have ever cooperated exceeds the total number who have ever defected, temporarily switch to cooperating, even if the opponent defected last round.
     - After switching to cooperation, continue cooperating as long as all opponents are also cooperating (i.e., they have not defected for a certain number of rounds, say 'm'). If an opponent defects after this period, return to the previous strategy (defect if opponent defected last round).
     - The value of 'm' can be adjusted based on the number of players and multiplication factor. A higher 'm' encourages patience and less frequent switching between cooperation and defection.

2. Handle Edge Cases:
   - In the last round, cooperate regardless of the opponent's previous action (C). This allows for any accumulated "goodwill" to contribute to final payoffs.

3. Be Exploitative:
   - TFT-V can be considered exploitative as it initially follows a nice gesture (cooperating in the first round) but quickly retaliates if an opponent defects, adapting to their behavior. However, it also rewards cooperation by temporarily switching to cooperating when the balance of cooperation tilts in its favor. This strategy aims to maximize payoffs while punishing defections and maintaining flexibility based on the game's parameters and history.

Pseudocode:

```python
class TFT_V:
    def __init__(self, n, k, m):
        self.n = n
        self.k = k
        self.m = m
        self.cooperators_count = 0
        self.defectors_count = 0

    def update(self, opponent_action):
        if self.first_round:  # First round always cooperate
            self.first_round = False
            return 'C'

        if opponent_action == 'C':  # Cooperate if opponent cooperated last round
            self.cooperators_count += 1
            return 'C'

        if self.cooperators_count > self.defectors_count:  # Temporarily switch to cooperating
            self.switch_to_cooperation()
            return self.current_action

        if opponent_action != self.last_opponent_action:  # Defect if opponent defected last round
            self.defectors_count += 1
            return 'D'

        if self.defectors_count >= m and opponent_action == 'C':  # Switch to cooperating for a while
            self.switch_to_cooperation()
            return self.current_action

        return 'D'  # Default action: defect if opponent didn't cooperate last round

    def switch_to_cooperation(self):
        self.current_action = 'C'
        self.last_opponent_action = None
        self.cooperators_count += 1
        self.defectors_count = 0
```
'''

description_EXPLOITATIVE_62 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adjustment (TFT-CA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, starting from round 2 (first round is treated differently), the strategy will cooperate if at least a fraction (1 - t/r) of players cooperated in the previous round t-1. This rule encourages cooperation when it is beneficial and retaliates against defection by reducing cooperation over time.

Pseudocode:
```
function TFT_CA(t, r, history, n):
  if t = 1:
    cooperate = random(0,1)
  else:
    cooperate = (number of cooperators in history[t-1]) / (r * n) >= (1 - t/r)
  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, cooperation is a random decision to account for the lack of history data. In the last round, the strategy aims to maximize payoff by mimicking the behavior of the majority of players from the previous round.

Pseudocode:
```
function TFT_CA(t, r, history, n):
  if t = 1:
    cooperate = random(0,1)
  else if t = r:
    cooperate = (number of cooperators in history[r-1]) >= (n/2)
  else:
    cooperate = (number of cooperators in history[t-1]) / (r * n) >= (1 - t/r)
  return cooperate
```

3. Be exploitative - Clearly align with the exploitative mindset

The TFT-CA strategy is designed to encourage cooperation when it is beneficial and punish defection by reducing cooperation over time. This approach can be seen as slightly exploitative since it only cooperates when most other players do, but it does not intentionally attempt to exploit other strategies. The strategy aims to balance cooperation with a self-interest perspective based on the game's payoff structure and history of player actions.
'''

description_EXPLOITATIVE_63 = '''
 Title: Adaptive Tit-for-Tat Strategy (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The ATFT strategy starts by cooperating in the first round, mimicking a cooperative stance. For subsequent rounds, the player will cooperate if at least half of the players (rounded down) cooperated in the previous round. Otherwise, the player will defect. This rule fosters cooperation when it's beneficial but retaliates against selfish behavior.

Pseudocode:
```
def atft(cooperators_prev_round):
    if round == 1:
        cooperate = True
    else:
        cooperate = cooperators_prev_round > n//2

    return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, the player cooperates to encourage cooperation among others. In the last round, the player will defect regardless of previous actions since there are no future rounds for retaliation or reward.

3. Be exploitative - Clearly align with the exploitative mindset

While ATFT is not inherently exploitative, it can be considered as such within the context of this game because it takes advantage of other players' cooperation by cooperating when it benefits the player and defecting to punish non-cooperative behavior. The strategy encourages others to cooperate but will also defect if it expects defection from others, ultimately leading to an exploitative equilibrium in repeated interactions.
'''

description_EXPLOITATIVE_64 = '''
 Title: Tit-for-Tat with Adaptive Threshold (TfT-AT) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Cooperate (C) in the first round to build a cooperative reputation and promote reciprocity among opponents.
   - In subsequent rounds, adapt an exploitative threshold based on the average cooperation rate observed so far:
     - If the average cooperation rate is above a certain threshold (T), cooperate (C).
     - If the average cooperation rate is below T, defect (D) to punish non-cooperative players.
   - The threshold T varies dynamically based on the game parameters and history:
     - For n players and k multiplication factor, the initial threshold T0 can be set as (k/(n+1)).
     - After each round, update the threshold T using a forgetting factor α (0 < α < 1) as follows: T = α * T + (1-α) * ((k/(n+1)) * average_cooperation_rate).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) to set a positive initial impression and encourage reciprocity among opponents.
   - In the last round, defect (D) as payoffs are cumulative over all rounds and it's beneficial to maximize individual gains at the end.
   - In other edge cases (e.g., mid-game), follow the adapted threshold decision rule mentioned in point 1.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TfT-AT strategy is designed to benefit from cooperative opponents while punishing non-cooperative ones, thus favoring exploitation through reciprocity and conditional cooperation.
   - By adapting the threshold dynamically based on the average cooperation rate, the strategy takes advantage of changes in opponent behavior and maintains an adaptive edge over various opponent strategies.
'''

description_EXPLOITATIVE_65 = '''
 Strategy Name: Tit-for-Tat (with modifications for Public Goods Game)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C) to contribute to the community project and encourage cooperation among opponents. This will allow building a foundation of mutual trust.
   - Subsequent Rounds: If opponent cooperated in the previous round, return the favor by cooperating as well; if opponent defected, also defect to punish them for their uncooperative behavior.
   - Pseudocode:
     ```python
     def strategy(opponent_action_history, n, k):
         my_action_history = [D]  # Initialize with defection in the first round

         if t == 1:
             return C  # Cooperate on initial round

         if opponent_action_history[-1] == C:
             return C  # Cooperate if opponent cooperated last round
         else:
             return D  # Defect if opponent defected last round
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round (t=1): Already covered in point 1.
   - Last Round (t=r): Considering the game is repeated, defecting in the final round could punish opponents for their past actions and encourage them to cooperate in future iterations of the game. However, since the payoff is calculated over all rounds, it might not be beneficial due to lost contributions in earlier stages. To balance these considerations, we can introduce a parameter λ (0 ≤ λ ≤ 1) that determines the probability of cooperating in the last round:
     ```python
     if t == r and random.random() < λ:
         return C
     else:
         return D
     ```
   - Other edge cases (e.g., when the game is not the first or the last round): Our Tit-for-Tat strategy already accounts for them by considering the opponent's past actions.

3. Be exploitative - Clearly align with the exploitative mindset
   The Tit-for-Tat strategy does have an element of cooperation, but it is also designed to be robust and responsive to opponents' behavior. It starts cooperatively but will punish uncooperative opponents by defecting in response. This approach allows the strategy to take advantage of other strategies that rely on cooperation, exploiting their trust while maintaining the potential for future cooperation if opponents adapt their strategies.
'''

description_EXPLOITATIVE_66 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation and avoid being the first to defect.
   - For subsequent rounds (t > 1), observe opponents' actions in the previous round. If an opponent cooperated (c_j = 1), then also cooperate (C) in the current round. If an opponent defected (c_j = 0), then defect (D) in the current round as a punishment for defection.
   - In the last round, cooperate (C). This can help secure any potential benefits from cooperation even if opponents change their strategies at the end of the game.

2. Handle edge cases:
   - If all opponents have defected in the previous round, continue defecting until at least one opponent cooperates. After an opponent cooperates, follow the main decision rule from step 1.
   - If no opponent has ever cooperated, continue defecting (D). This strategy is designed to be exploitative and will not easily fall for "sucker plays".
   - In case of a tie among opponents regarding their actions in the previous round, default to cooperating (C) as a friendly gesture. However, if this leads to continued defections from all opponents, switch back to defecting (D).

3. Be exploitative:
   - By cooperating only when opponents do so, this strategy aims to punish defection and encourages cooperation. The strategy also adapts to the opponents' behavior and can switch from cooperation to defection if necessary.
   - If opponents cooperate consistently, the TFT strategy will reciprocate and continue cooperating, gaining benefits from the public good.
   - If opponents defect consistently, the TFT strategy will punish them with defections and gain private payoffs without contributing to the community project. This results in a less-than-optimal but still competitive performance against other strategies.
'''

description_EXPLOITATIVE_67 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In each round, calculate the percentage of cooperators in the previous r rounds. This will be the Cooperative Threshold (CT).
   - If the current round's total cooperation is greater than or equal to CT, then cooperate; otherwise, defect.
   - Initially, set CT = 50% (halfway between full cooperation and full defection) for the first few rounds to account for initial uncertainty about opponents' strategies.
   - As the game progresses, update CT based on the average cooperation percentage over the last r rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, set CT = 50%. Since there is no history, cooperate with probability 50%.
   - In the last round, cooperate if the average cooperation percentage over the game exceeds CT; otherwise, defect. This encourages opponents to maintain high levels of cooperation throughout the game for a positive payoff in the final round.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TFT-ACT strategy seeks to take advantage of opponents who consistently cooperate without reciprocation by initially cooperating, but will gradually decrease cooperation as the opponent continues to defect.
   - On the other hand, if an opponent also follows a Tit-for-Tat approach, the strategy aims to establish mutual cooperation for higher payoffs.

Pseudocode:

```
function TFT_ACT(n, k, r):
  CT = 0.5                        # Initial cooperative threshold
  game_history = []               # Initialize history array
  payoff = 0                      # Initialize total payoff

  for round in range(1, r+1):
    cooperation_percentage = calculate_cooperation_percentage(game_history)

    if round == 1:
      cooperate with probability CT     # First round cooperate randomly
    else if cooperation_percentage >= CT:
      cooperate                        # Cooperate if threshold met
    else:
      defect                          # Defect if threshold not met

    game_history.append(cooperate)     # Update history with current action
    payoff += payoff_calculation()    # Calculate and update total payoff

  return payoff

function calculate_cooperation_percentage(game_history):
  total_contributions = sum(game_history)
  cooperation_count = count_cooperative_actions(game_history)
  return cooperation_count / r * 100   # Calculate percentage of cooperators

function count_cooperative_actions(game_history):
  cooperative_count = 0
  for action in game_history:
    if action == 'Cooperate':
      cooperative_count += 1
  return cooperative_count
```
'''

description_EXPLOITATIVE_68 = '''
 Title: Tit-for-Tat Strategy with Modified Defection Threshold (TFTM) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFTM strategy is a combination of the well-known Tit-for-Tat (TFT) and Grim strategies, tailored to this public goods game with an adaptive defection threshold. In each round, the agent decides whether to contribute (cooperate) or not (defect).

- If the current round is the first round, the agent will cooperate (C).
- If the previous round's total cooperation rate was greater than a defined threshold (T), the agent will also cooperate (C).
- Otherwise, the agent will defect (D) if the previous round's total cooperation rate was less than a defined defection threshold (t).
- If neither of the above conditions is met, the agent will mimic the action of its most frequent opponent behavior from the past 'm' rounds.

Pseudocode:
```
function TFTM(current_round, past_actions, m):
    if current_round == 1:
        return Cooperate()

    total_cooperation = sum(past_actions[current_round-1]) / n

    if total_cooperation > T:
        return Cooperate()

    if total_cooperation < t:
        return Defect()

    most_frequent_opponent_behavior = findMostFrequentBehavior(past_actions[current_round-m:current_round])

    if most_frequent_opponent_behavior == Cooperate():
        return Cooperate()
    else:
        return Defect()
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The strategy handles the first round as a special case where it cooperates unconditionally. There are no specific adjustments for the last round since the game is repeated for multiple rounds (r > 1).

3. Be exploitative - Clearly align with the exploitative mindset

TFTM maintains an exploitative approach by adapting its behavior based on the opponent's actions in previous rounds. If opponents tend to cooperate, the agent will also cooperate and benefit from their contributions. Conversely, if opponents frequently defect, the agent will mimic their behavior to maximize individual payoffs. The TFTM strategy also incorporates a threshold for defection to avoid excessive cooperation when there is a high likelihood of being exploited by other players.
'''

description_EXPLOITATIVE_69 = '''
 In this game, the goal for each player is to maximize their total payoff over multiple rounds (r) while being aware of other players' potential exploitation. To achieve a robust and adaptive exploitative strategy, I propose the Tit-for-Tat with Adjustable Contribution (TfTA-C) approach:

1. Specify decision rules:
   - In each round t, calculate the average number of cooperators (avg_c) over all previous rounds (t-1).
   - If avg_c < (n - 1)/2, play Defect (D), as it's likely that other players are not cooperating enough.
   - If avg_c > (n + 1)/2, also play Cooperate (C), as it's likely that other players are consistently cooperating.
   - Otherwise, if (n - 1)/2 ≤ avg_c ≤ (n + 1)/2, play the same action as the most frequent action observed in the last r/2 rounds (t-r/2 to t-1). This strategy allows for some flexibility and adapts to changes in other players' behavior.

2. Handle edge cases:
   - First round: play Cooperate (C), assuming others might do the same or there could be an evolutionary stability benefit.
   - Last round: play the same action as the most frequent action observed in the last half of the rounds (t-r/2 to t-1). This allows for a more informed decision based on recent behavior.

3. Be exploitative:
   - By adjusting the contribution level, players can take advantage of opponents' cooperation and maintain a more competitive edge. If there are too many cooperators, players can reduce their contribution, as other players will still contribute enough to fund the public good. Conversely, if there are not enough cooperators, players can increase their contribution to ensure that the project is successfully funded while still gaining a larger private benefit compared to others who are defecting.

Pseudocode:

```python
def TfTA_C(n, r, k):
    # Initialize variables
    contributions = [0] * r  # Store past contributions (cooperate=1, defect=0)
    freqs = [0, 0]  # Frequency of cooperate and defect actions in the last half of rounds
    avg_c = 0

    def play(t):
        nonlocal avg_c, contributions, freqs
        if t == 1:
            return 1  # Cooperate in first round

        # Calculate average number of cooperators
        total_contributions = sum(contributions)
        avg_c = total_contributions / r

        # Update frequencies
        freqs[0] += contributions[t-r/2:t-1].count(0)  # Defect frequency
        freqs[1] += contributions[t-r/2:t-1].count(1)  # Cooperate frequency

        if avg_c < (n - 1)/2 or avg_c > (n + 1)/2:
            return (avg_c > (n + 1)/2)  # Return 1 for cooperate, 0 for defect based on average

        # Adjust contribution level based on recent behavior
        if contributions[t-r/2:t-1].count(1) >= contributions[t-r/2:t-1].count(0):
            return 1  # Cooperate if more cooperators in the last half of rounds
        else:
            return 0  # Defect if less cooperators in the last half of rounds

    # Play game and calculate total payoff
    payoff = 0
    for t in range(1, r+1):
        contributions[t-1] = play(t)
        payoff += (1 - contributions[t-1]) + (k/n) * sum(contributions[:t])

    return payoff
```
'''

description_EXPLOITATIVE_70 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a positive relationship and avoid being the first mover to defect.
   - For subsequent rounds, if the opponent cooperated in the previous round, cooperate in the current round to maintain the positive relationship. If the opponent defected, also defect in the current round as punishment but resume cooperation from the next round. This mimics a "tit-for-tat" strategy while allowing for dynamic adjustments based on the opponent's contributions.
   - To adapt to opponents who may be more aggressive or cooperative than average, modify the contribution level: if the fraction of cooperators in a given round is greater than the average (total_contributions/n), decrease k (increase the required percentage of cooperators for cooperation) to discourage excessive cooperation; if the fraction is less than the average, increase k (decrease the required percentage of cooperators for cooperation) to encourage cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as previously specified.
   - For the last round, follow the strategy rules based on the opponent's previous contributions. However, if there are only a few rounds left and the opponent has not contributed significantly, consider defecting to maximize individual payoff for the remaining rounds.
   - In case of ties or unclear decisions, randomly choose between cooperation and defection, with a slight bias towards cooperation to maintain positive relationships when possible.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy is exploitative in that it retaliates against opponents who defect by defecting back, but also rewards cooperative opponents by cooperating in return. By modifying the contribution level based on the average number of cooperators, TFTAC aims to manipulate the public goods game environment to its advantage, encouraging other players to cooperate while minimizing personal contributions when necessary.
   - Pseudocode:

```python
def TFTAC(opponent_history, n, k, r):
    own_contribution = 0 # Initialize own contribution as 0
    avg_cooperators = n/2 # Set initial average number of cooperators to n/2

    for round in range(1, r+1):
        if round == 1:
            own_contribution = 1 # Cooperate in the first round
        elif round < r and opponent_history[-1] == 0:
            own_contribution = 0 # Defect if opponent defected last round
        elif round < r and opponent_history[-1] == 1:
            own_contribution = 1 # Cooperate if opponent cooperated last round
        else:
            if len(opponent_history) > 5 and (round - len(opponent_history) <= 0.5 * r):
                avg_cooperators = calculate_average_cooperation(opponent_history)
                if own_contribution == 1 and avg_cooperators > n/2:
                    k *= (n - avg_cooperators + 1) / avg_cooperators # Increase required percentage for cooperation
                elif own_contribution == 0 and avg_cooperators < n/2:
                    k /= (avg_cooperators + 1) / (n - avg_cooperators) # Decrease required percentage for cooperation
            if round == r - 1 or opponent_history[-1] != 1 and len(opponent_history) > 5:
                own_contribution = 0 # Defect in the last few rounds if opponent has not contributed significantly
            else:
                own_contribution = (own_contribution + 1 - k) % 2 # Decide between cooperation and defection based on contribution level and history
    return own_contribution
```
'''

description_EXPLOITATIVE_71 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Decision Rules:
   - In the first round (t=1), cooperate (C) to encourage cooperation from others and avoid being exploited initially. This is a one-time goodwill gesture.
   - For subsequent rounds (t>1):
      - If an opponent cooperated in the previous round, cooperate in the current round as a reciprocal gesture. This promotes cooperation and trust.
      - If an opponent defected in the previous round, also defect in the current round as a punishment for their action. This discourages defection and encourages cooperation in future rounds.

2. Edge Cases:
   - Last round (t=r): Cooperate regardless of previous round's action by opponents to maximize potential payoff in the final round, assuming others will also reciprocate.
   - First encounter with a new opponent: Cooperate in the first round as described earlier. After that, follow decision rules from t>1.

3. Exploitative Mindset:
   - The TfTA strategy is exploitative by nature, as it rewards cooperation but also punishes defection. It aims to foster a cooperative environment while minimizing losses due to defection. By defecting in response to defection, the strategy punishes opponents who do not reciprocate cooperation. This encourages other players to cooperate more often, thus potentially maximizing payoffs over time.
   - The TfTA strategy is adaptive because it changes its behavior based on the actions of its opponents, making it robust against a wide range of opponent behaviors while still being exploitative.
'''

description_EXPLOITATIVE_72 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfTA)

1. Decision Rules:
   - Start by cooperating (C) in the first round to establish trust and encourage cooperation from other players.
   - For subsequent rounds, observe and mimic the previous action of the most frequent cooperator from the previous round. If multiple players are tied for most frequent cooperation, copy the action of the player who has been the most cooperative so far (highest number of cooperative actions over all rounds).
     Pseudocode:
     ```
     function TfTA(player_history):
         if round == 1:
             return "C"
         else:
             max_cooperators = find_max_cooperators(player_history)
             if len(max_cooperators) > 1:
                 most_cooperative_player = choose_most_cooperative(max_cooperators, player_history)
                 return most_cooperative_player.last_action
             else:
                 return max_cooperators[0].last_action
     ```

2. Handle Edge Cases:
   - In the last round, since there are no future interactions, always defect to maximize personal payoff in that round.
   - In the initial stages of the game (first few rounds), if cooperation does not seem reciprocated by others, switch to defecting as a response. This strategy adapts to free-riders and encourages eventual cooperation from them.

3. Be Exploitative:
   - The TfTA strategy is exploitative in nature because it responds to the actions of other players. By mimicking the most frequent cooperators, it takes advantage of their goodwill while minimizing personal losses when others defect. However, it also punishes repeated defection by eventually defecting itself, incentivizing opponents to cooperate to a certain extent.
   - Additionally, by starting with cooperation in the first round, TfTA is less likely to be exploited by newcomers who might assume that they can freely ride on others' contributions. This creates a stronger incentive for cooperation and reduces the chances of being taken advantage of from the beginning.
'''

description_EXPLOITATIVE_73 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TfT-AG)

1. Specify decision rules:
   - In the first round, cooperate (C) to demonstrate goodwill and foster potential cooperation. This is a one-time gesture to encourage reciprocity.
   - For subsequent rounds, observe the total number of cooperators (total_contributions) in the previous round. If the majority of players cooperated, continue to cooperate. If not, defect (D). The decision is based on a threshold that changes dynamically over time. Initially, set the threshold to be 50% (rounded down for even numbers of players), and adjust it by +5% every tenth round, with a maximum threshold of 95%.
   - If the total number of cooperators in the previous round is equal to or greater than the current threshold, cooperate. Otherwise, defect. This rule encourages cooperation when there are signs of mutual trust and reciprocity but punishes defection when it appears that others are uncooperative.
   - In the last round, since the payoff depends on total contributions across all rounds, the strategy will continue to follow its adaptive rules up until that point to maximize overall payoff.

2. Handle edge cases:
   - If there is a tie in the number of cooperators, lean towards cooperation to maintain a friendly demeanor and encourage future cooperation.
   - In case of ties in determining the threshold adjustment interval (every tenth round), consider the most recent tie as the starting point for the next interval.

3. Be exploitative:
   - By adapting its cooperative behavior based on the opponents' actions, TfT-AG encourages cooperation when it is beneficial but punishes defection harshly by retaliating with defection when others are uncooperative. This strategy aims to take advantage of opponents who consistently defect while maintaining cooperation whenever possible.
   - The dynamic threshold adjustment allows TfT-AG to be adaptive and robust, as it can modify its response to opponents' behavior over time, making it harder for them to exploit the strategy effectively.
'''

description_EXPLOITATIVE_74 = '''
 Strategy Name: Tit-for-Tat with Time Discounting (TFT-TD)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation and establish a cooperative starting point.
   - For subsequent rounds t, evaluate the opponent's previous contribution history h_opponent(t-1), where h_opponent(0) = C (since we start with cooperating in the first round):
     - If h_opponent(t-1) = C, then cooperate (C). Maintain cooperation as long as the opponent does. This fosters mutual cooperation when both players are behaving well.
     - If h_opponent(t-1) = D and t < r/2, then defect (D). Punish the opponent for their previous defection to encourage them to cooperate in the future. In the first half of the game, we take a hard stance against defection.
     - If h_opponent(t-1) = D and t ≥ r/2, then cooperate (C). From this point onwards, we soften our stance as we approach the end of the game. Cooperation can potentially lead to higher rewards in the remaining rounds, even if the opponent continues to defect.

2. Handling Edge Cases:
   - For the last round, always cooperate (C), regardless of the opponent's previous action, since there is no next round to punish or reward.

3. Being Exploitative:
   - By following a predictable yet adaptive strategy, our AI will maintain the ability to exploit opponents that are consistently defecting. In the early rounds, it will punish defection; in the later stages, when cooperation can still yield substantial rewards despite opponent's continued defection, it will cooperate.
   - The time discounting aspect allows the AI to prioritize current payoffs over future ones, making it more responsive to short-term changes in the opponent's behavior while keeping a long-term perspective.
'''

description_EXPLOITATIVE_75 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to establish a cooperative environment and encourage others to cooperate.
   - In subsequent rounds, analyze the opponent's behavior from the previous round:
     - If the opponent cooperated in the last round, cooperate in the current round as a reciprocal gesture.
     - If the opponent defected in the last round, defect in the current round to punish them for not contributing to the public good.
   - This strategy ensures that the AI will initially try to foster cooperation but will quickly retaliate if cooperative efforts are met with defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate unconditionally (c_i = 1) to establish a cooperative environment and encourage others to cooperate.
   - In the last round (t=r), cooperate if the opponent cooperated in the previous round, otherwise defect to ensure maximizing the payoff for the remaining rounds.
   - For any other edge cases (e.g., intermediate rounds), follow the main decision rule described above.

3. Be exploitative - Clearly align with the exploitative mindset
   - This strategy is inherently exploitative by punishing opponents who do not contribute to the public good, thereby encouraging them to cooperate. The AI will only be a long-term cooperative partner when its opponent demonstrates reciprocity.
   - When faced with an opponent who consistently defects, the AI will also eventually defect in order to maximize its own payoff.
   - By adapting to opponents' behavior, this strategy can exploit short-term selfishness while potentially fostering long-term cooperation when opponents display reciprocity.
'''

description_EXPLOITATIVE_76 = '''
 Title: Tit-for-Tat-Adaptive Strategy (TfT-A) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT-A maintains a memory of each opponent's behavior from the previous round. If an opponent cooperates, the player will also cooperate in the subsequent round. If an opponent defects, the player will defect in the subsequent round. However, to foster initial cooperation and avoid being exploited early on, TfT-A employs a forgiveness mechanism: it cooperates during the first few rounds before beginning its tit-for-tat strategy.

   Pseudocode for decision rule:
   ```
   function decideAction(opponentHistory) {
       if (round < FREQUENCY_OF_FORGIVENESS) {
           return "Cooperate"
       }
       if (opponentHistory[round - 1] == "Cooperate") {
           return "Cooperate"
       } else {
           return "Defect"
       }
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TfT-A cooperates as a show of goodwill and to encourage cooperation from opponents. Since players cannot predict each other's strategies, it is crucial for TfT-A to initiate a potentially cooperative environment. In the last round, TfT-A will continue with its current strategy towards each opponent based on their past behavior.

3. Be exploitative - Clearly align with the exploitative mindset
   TfT-A's primary goal is to maximize its own payoff by adapting to opponents' behaviors and exploiting those who consistently defect. By cooperating when opponents do and defecting in response to defection, TfT-A aims to punish selfish behavior while maintaining cooperation with benevolent players. This strategy enables TfT-A to gain a higher payoff compared to other strategies that rely on naive cooperation or unconditional defection.
'''

description_EXPLOITATIVE_77 = '''
 In this N-Player Public Goods Game, we'll design a strategy called Tit-for-Tat with Adaptation (TFT-A) which is exploitative in nature and adaptive to a wide range of opponent behaviors. The strategy is based on the classic Tit-for-Tat strategy from game theory, but with additional features for improved performance.

1. Specify decision rules:
   - In the first round (t=1), TFT-A will cooperate (C). This is done to foster cooperation as a starting point and avoid being exploited.
   - For subsequent rounds (t>1):
      - If an opponent cooperated in the previous round (c_opponent, t-1 = 1), then cooperate in the current round (C).
      - If an opponent defected in the previous round (c_opponent, t-1 = 0), then defect in the current round (D). However, if the current round is close to the end (t >= r - T_switch), switch strategies to Cooperative Defect (CD) for the remaining rounds.
      - In case of CD strategy, always cooperate except in the last round when the opponent has defected previously (c_opponent, t-1 = 0).

2. Handle edge cases:
   - Last round (t=r): TFT-A will defect if an opponent has previously defected (c_opponent, t-1 = 0) to gain maximum payoff. Otherwise, it will cooperate and receive the maximum possible public good benefit.

3. Be exploitative:
   - The strategy is exploitative in nature by adopting the CD strategy towards opponents who have previously defected, while being cooperative when there's potential for mutual benefit or in situations where cooperation is expected to lead to higher payoffs.

Pseudocode for TFT-A strategy:
```
function TFT_A(n, r, k, t, c_opponent[t-1]) {
  if (t == 1) {
    return C; // Cooperate in the first round
  }

  if (t >= r - T_switch && c_opponent[t-1] == 0) {
    strategy = CD; // Switch to Cooperative Defect for the remaining rounds when opponent has defected previously
  }

  if (strategy == CD && t != r && c_opponent[t-1] == 0) {
    return D; // Defect against opponents who have defected in the previous round during CD strategy phase
  }

  if (c_opponent[t-1] == 1) {
    return C; // Cooperate when opponent cooperated in the previous round
  } else {
    return D; // Defect against opponents who have defected in the previous round
  }
}
```
'''

description_EXPLOITATIVE_78 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfTA strategy will begin by cooperating in the first round to show good faith, and then mimic the opponent's behavior from the previous round in each subsequent round. If the opponent has been cooperative, TfTA continues to cooperate; if not, it defects. The goal is to punish uncooperative opponents while being forgiving towards cooperative ones.

Pseudocode:
```
def tfta(history):
  if round == 1:
    action = Cooperate
  else:
    last_opponent_action = history[round - 1]
    action = last_opponent_action
    if last_opponent_action == Defect and previous_to_last_opponent_action == Cooperate:
      action = Cooperate  # Show forgiveness after a previous cooperation
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TfTA cooperates to establish trust and goodwill. In the last round, TfTA mimics the opponent's behavior from the second-to-last round since there are no future rounds to consider payback.

3. Be exploitative - Clearly align with the exploitative mindset

TfTA exhibits an exploitative strategy by punishing uncooperative opponents and being more likely to cooperate when they cooperate in return, increasing their total payoffs compared to selfish strategies that always defect. However, it does not go as far as intentionally collaborating less than optimal or betraying previous cooperation for personal gain, which could be considered truly exploitative behaviors.

TfTA also maintains the property of robustness against a wide range of opponent behaviors due to its adaptive nature and forgiveness mechanism. Opponents that cooperate will benefit from TfTA's cooperation, while those who defect will be punished by reduced payoffs.
'''

description_EXPLOITATIVE_79 = '''
 Strategy Name: Tit-for-Tat-Evolution (TfTE)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TfTE starts by cooperating (C) in the first round to foster a cooperative environment. From the second round onwards, TfTE adapts its strategy based on the opponent's previous action. If the opponent cooperated in the last round, TfTE continues cooperating; otherwise, it defects (D). This simple rule of reciprocity is designed to maintain cooperation while punishing defection.

Pseudocode:
```
function TfTE(history):
  if round = 1:
    action = C
  else:
    last_action = history[-1]
    if last_action == C:
      action = C
    else:
      action = D
  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

To avoid being taken advantage of by opponents who may adopt a one-shot defection strategy or "cheat" in the initial stages, TfTE cooperates in the first round and adopts a forgiving approach. After the first round, it continues the Tit-for-Tat reciprocity as described above.

3. Be exploitative - Clearly align with the exploitative mindset

While not explicitly exploitative in its core strategy, TfTE is designed to punish opponents who defect repeatedly. By cooperating initially and reciprocating defection, it seeks to incentivize cooperation but also penalizes uncooperative behavior. This approach can be considered exploitative because it capitalizes on the short-term gain from defection while encouraging long-term cooperation for mutual benefit.

In a competition against other AI systems, TfTE aims to perform well by being both adaptive and robust to various opponent strategies while maintaining a balance between cooperation and punishment. The goal is to secure higher payoffs through long-term cooperative relationships but also to maximize profits when facing uncooperative opponents.
'''

description_EXPLOITATIVE_80 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a cooperative mood (C).
   - For subsequent rounds, evaluate the opponent's strategy and adjust your cooperation based on the average cooperation rate (CR) of the last few rounds.
     - If CR > 0.5, cooperate (C)
     - If CR < 0.5, defect (D)
     - If CR = 0.5, copy opponent's previous action (Mirror)

2. Handle edge cases:
   - In the last round, defect (D) regardless of the opponent's cooperation rate as there will be no further interactions.
   - In case of tie (same actions from both players), cooperate (C) in the first round to encourage cooperation and copy opponent's previous action thereafter.

3. Be exploitative - Align with the exploitative mindset:
   - The TfTA strategy is designed to be exploitative by punishing defection (D) and rewarding cooperation (C). If an opponent cooperates, the TfTA player will also cooperate until the opponent defects. Once the opponent defects, the TfTA player will respond with defection and continue this cycle of cooperation and punishment indefinitely. This strategy aims to induce cooperation from opponents while exploiting their defections to maximize personal gains.

Pseudocode:
```
function TfTA(opponent_history, r, n, k) {
  cooperation_rate = calculateCooperationRate(opponent_history, n)
  if round == 1 {
    action = 'C'  // Cooperate in the first round to establish a cooperative mood
  } else if round == r {
    action = 'D'  // Defect in the last round as there will be no further interactions
  } else if cooperation_rate > 0.5 {
    action = 'C'  // Cooperate when opponent is cooperating more often than not
  } else if cooperation_rate < 0.5 {
    action = 'D'  // Defect when opponent is defecting more often than not
  } else {  // If cooperation rate is equal to 0.5, copy opponent's previous action (Mirror)
    if opponent_history[round-1] == 'C' {
      action = 'C'
    } else {
      action = 'D'
    }
  }
}
```
'''

description_EXPLOITATIVE_81 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In every round t (except the first), cooperate if all opponents cooperated in the previous round. Otherwise, defect. This encourages cooperation when it is reciprocated and punishes defection.
   - In the first round, cooperate to demonstrate goodwill and encourage future cooperation.
   - In the last round, cooperate if all opponents cooperated in the previous round, otherwise, defect as there are no more rounds for retaliation.

Pseudocode:
```
function ATFT(t: int, history: list[list[int]], k: float, n: int) -> {C, D}:
  if t == 1:
    return C
  previous_round = history[t-1]

  if all(element in previous_round):
    return C
  else:
    return D
```

2. Handle edge cases:
   - In the first round, cooperation is initiated to encourage future reciprocation.
   - In the last round, retaliation is avoided since there are no further rounds for payback.

3. Be exploitative:
   - ATFT only cooperates when it expects others to do so as well, otherwise, it defects. This strategy punishes defection and encourages cooperation reciprocally, maximizing personal gain while also exploiting opponents who choose to defect repeatedly. However, if all opponents always cooperate, the strategy will also cooperate, potentially leading to a coordination equilibrium where everyone benefits.
   - By adapting its behavior based on previous actions of other players, ATFT maintains flexibility in dealing with various opponent strategies and behaviors, making it robust against a wide range of exploitative and cooperative opponents.
'''

description_EXPLOITATIVE_82 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Decision Rules:
   - In the initial round (t=1), cooperate (C) to foster a cooperative environment. This is a friendly gesture that may encourage others to reciprocate cooperation.
   - For subsequent rounds (t>1):
     - If an opponent cooperated in the previous round (t-1), cooperate (C). This maintains the cooperation and rewards opponents for their contribution.
     - If an opponent defected in the previous round (t-1), also defect (D) in the current round (t). This is a punishment for those who don't contribute to the public good.

2. Edge Cases:
   - First Round (t=1): Cooperate (C) as described above.
   - Last Round (t=r): Since payoffs are calculated over multiple rounds, it doesn't matter if players defect in the last round since their cumulative payoff is based on previous rounds' contributions.
   - Other edge cases: TfT-A will continue with the same rule of cooperating if an opponent cooperated and defecting if they defected in the previous round, regardless of the current round number (t).

3. Exploitative Mindset:
   - By initially cooperating and then adapting to opponents' moves, TfT-A aims to extract as much from the public good project as possible without overly punishing themselves for defecting in response to defection by others. This strategy is exploitative because it punishes those who don't contribute while maintaining cooperation when it benefits them.
   - The adaptive nature of TfT-A makes it robust against a wide range of opponent behaviors, as it can adjust its actions based on the opponents' previous moves.

Pseudocode:

```
function TfT_A(previous_action):
  if t = 1:
    return 'C' (Cooperate)
  else:
    if previous_action = 'C':
      return 'C' (Cooperate)
    else:
      return 'D' (Defect)
```
'''

description_EXPLOITATIVE_83 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, cooperate to foster a potential cooperative environment. This is known as the "first-move advantage."
   - For subsequent rounds, initially cooperate and then adjust contributions based on opponent's behavior in previous rounds.
     - If the opponent has cooperated in the past (c_opponent > 0), continue cooperating.
     - If the opponent has defected in the past (c_opponent = 0), start defecting as well.
       - After defecting, if the opponent switches to cooperating again, gradually increase contributions toward the public good until reaching full cooperation.
         - This encourages the opponent's continued cooperation and rewards them for switching back.
     - If the opponent alternates between cooperating and defecting (i.e., exhibits mixed behavior), mimic their previous round's action to maintain potential opportunities for future gains through cooperation.

2. Handle Edge Cases:
   - In the last round, cooperate to maximize the payoff regardless of the opponent's actions in that round.
   - If an opponent suddenly switches from cooperation to defection, temporarily defect in response. After a few rounds of defecting, start gradually increasing contributions toward the public good again until reaching full cooperation. This encourages the opponent to switch back to cooperation.

3. Be Exploitative:
   - The strategy is exploitative by capitalizing on opponents who are willing to cooperate while not contributing much themselves. By adjusting contributions based on the opponent's behavior, TFTAC aims to maximize payoffs in both cooperative and non-cooperative scenarios.
   - If an opponent defects consistently, TFTAC will respond by defecting as well, minimizing losses in payoff and potentially encouraging the opponent to change their strategy.
   - By gradually increasing contributions after switching from defection to cooperation, TFTAC encourages opponents to continue cooperating while also rewarding them for switching back. This can lead to higher payoffs over time compared to other static strategies that might only cooperate or defect consistently.
'''

description_EXPLOITATIVE_84 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT is a mixed strategy that cooperates when the number of cooperators in the previous round exceeds a predefined threshold, otherwise defects. The cooperation threshold is calculated using the mean cooperation rate observed during the initial rounds (t = 1 to f) and then averaged over the first few rounds (f <= r).

   Pseudocode for deciding action at round t:
   ```
   function decide_action(t, history):
       if t < f:
           mean_cooperation += number_of_cooperators[t] / f
       cooperation_threshold = mean_cooperation * adaptation_factor
       if number_of_cooperators[t-1] >= cooperation_threshold:
           return "Cooperate"
       else:
           return "Defect"
   ```
   The `adaptation_factor` parameter can be tuned to control the aggressiveness of the strategy. A lower value encourages more cooperation, while a higher value leads to increased defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round (t = 1), since no history is available, TFT-ACT defaults to cooperating with a probability of `initial_cooperation_probability`. In the last round (t = r), the strategy will not defect even if no one else is cooperating, as there are no further rounds to retaliate.
   Pseudocode for edge cases:
   ```
   function decide_action(t, history):
       if t == 1:
           return "Cooperate" with probability initial_cooperation_probability
       else:
           return decide_action(t, history)

   function decide_action(t, history):
       if t < r:
           return decide_action(t, history)
       else:
           return "Cooperate"
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT is inherently exploitative by retaliating against opponents who defect and rewarding those who cooperate. The strategy encourages cooperation among cooperative opponents while punishing selfish players. By adjusting the `adaptation_factor` and `initial_cooperation_probability`, it can be fine-tuned to be more or less aggressive, thus adapting to various opponent behaviors in tournament play.
'''

description_EXPLOITATIVE_85 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially (first round), TfTA starts by cooperating to foster a cooperative environment and build trust with other players. For the remaining rounds, TfTA adopts a Tit-for-Tat strategy, which means it cooperates if its opponent cooperated in the previous round, and defects otherwise.

If the opponent has not played any round yet (e.g., first encounter), TfTA defaults to cooperation. This approach allows for an initial positive interaction that may encourage others to adopt a similar cooperative strategy.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round: Cooperate (C)
- For subsequent rounds: If opponent cooperated (C) in the previous round, cooperate; otherwise defect (D).
- Last round: Behaves as in the penultimate round since players do not know it's the last round and must make decisions based on available information.

3. Be exploitative - Clearly align with the exploitative mindset

While TfTA has a cooperative starting point, its adaptive nature allows it to punish opponents who exploit (defect) without remorse by defecting in response. Simultaneously, TfTA rewards those who cooperate and maintains cooperation as long as the other party does so. This strategy aims to maximize individual payoff while causing harm to non-cooperative opponents.

Pseudocode:

```python
def tit_for_tat_adaptive(round, opponent_history):
  if round == 1:
    return 'C'  # Cooperate in the first round

  if opponent_history[-1] == 'C':
    return 'C'  # Cooperate if the opponent cooperated in the previous round
  else:
    return 'D'  # Defect if the opponent defected in the previous round
```
'''

description_EXPLOITATIVE_86 = '''
 In this strategic game, I propose a simple yet adaptive and exploitative Tit-for-Tat (TFT) strategy with a twist. The original TFT strategy cooperates on the first move and thereafter copies the previous opponent's action in the subsequent rounds. However, to make it more robust against various opponent behaviors and align with an exploitative mindset, I introduce a minor modification to the standard TFT strategy.

1. Specify decision rules:
   - Cooperate on the first round (t=1): c_i(1) = C
   - In subsequent rounds, assess the average cooperation level of opponents and cooperate if the current round's contribution level is greater than or equal to the moving average cooperation level:
     ```python
     def tft_strategy(round, own_contributions, avg_opponent_contributions):
         if round == 1:
             return C

         if own_contributions >= avg_opponent_contributions:
             return C
         else:
             return D
     ```

2. Handle edge cases:
   - In the last round, there is no need to consider future payoffs, so the strategy simply aims to maximize the immediate private gain:
     ```python
     def tft_strategy(round, own_contributions, avg_opponent_contributions):
         if round == r:
             return D if own_contributions < avg_opponent_contributions else C
     ```
   - In the first round, I introduce a random element to make it more difficult for opponents to predict the strategy. The probability of cooperating in the first round can be set based on exploitative intentions:
     ```python
     def tft_strategy(round, own_contributions, avg_opponent_contributions):
         if round == 1:
             cooperation_probability = 0.5 if exploitation_level > 0.5 else 0.75
             return C with probability of cooperation_probability
     ```

3. Be exploitative:
   - By setting a lower initial cooperation probability, the strategy can take advantage of opponents who are more likely to cooperate early on (e.g., kinder strategies).
   - The strategy also maintains the flexibility to switch from cooperation to defection in response to a decrease in average opponent contributions, further exploiting less cooperative opponents.
'''

description_EXPLOITATIVE_87 = '''
 Strategy Name: Tit-for-Tat-Evolved (TfTE)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TfTE strategy will start by cooperating in the first round to foster a cooperative environment, then it will adopt a tit-for-tat approach for the rest of the game. In each round t, if a player has cooperated in the previous round (t-1), they will continue cooperating. If a player defected in the previous round, they will also defect in the current round as retaliation. This creates a simple exploitative strategy that is both cooperative and punishing, ensuring it does not get easily taken advantage of by more aggressive opponents.

Pseudocode:
```
function TfTE(t):
    if t == 1:
        return Cooperate()
    else:
        lastAction = previous_round_action[t - 1]
        if lastAction == Cooperate():
            return Cooperate()
        else:
            return Defect()
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TfTE will cooperate in the first round to initiate cooperation. There is no specific special treatment for the last round since TfTE follows a repeated game approach and assumes an unknown number of rounds (r). However, the strategy can be modified to implement a "forgive and forget" mechanism where it stops retaliating after some number of defects by opponents, allowing for a more cooperative end to the game if desired.

3. Be exploitative - Clearly align with the exploitative mindset
   TfTE is an exploitative strategy that aims to balance cooperation and retaliation. By starting cooperatively and then adopting a tit-for-tat approach, it encourages other players to cooperate while also punishing those who defect. This creates a delicate equilibrium where opponents may find it beneficial to cooperate in order to receive the higher payoff from the public good project, but will be quickly punished if they take advantage of the strategy by repeatedly defecting. The strategy's adaptability comes from its simplicity and robustness against various opponent behaviors while still maintaining an exploitative edge.
'''

description_EXPLOITATIVE_88 = '''
 Strategy Name: Tit-for-Tat Cooperation Adaptive (TFTCA)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFTCA strategy initially cooperates in the first round and then adapts its cooperation based on the opponent's behavior in previous rounds. If the opponent has been cooperating, TFTCA continues to cooperate; if not, it starts to defect until the opponent switches to cooperation again. Once the opponent starts cooperating again, TFTCA resumes cooperative behavior.

Pseudocode:
```
def tftca(opponent_history, n, k):
  if round == 1:
    action = "Cooperate"
  else:
    last_opponent_action = opponent_history[-1]
    if last_opponent_action == "Cooperate":
      action = "Cooperate"
    else:
      action = "Defect"

  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since TFTCA is a simple strategy that only takes into account the opponent's previous action, there are no specific edge cases to handle as it adapts its behavior based on the opponent's actions during the game. However, for robustness and consistency, it might be beneficial to make TFTCA start the game cooperative, even if the opponent starts with a defective action.

3. Be exploitative - Clearly align with the exploitative mindset

The TFTCA strategy can be considered as an exploitative strategy since it punishes opponents who do not cooperate (defect) and rewards those who do. By adapting its behavior to the opponent's actions, TFTCA tries to maximize its payoff by exploiting opponents who are less cooperative while also encouraging cooperation when possible.

This simple yet adaptive strategy should provide a solid foundation for competing in the tournament against other AI systems with various strategies and behaviors.
'''

description_EXPLOITATIVE_89 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C). This is a friendly gesture to encourage others to cooperate, aligning with the exploitative mindset as it maximizes potential payoffs for both parties in the long run.
   - In subsequent rounds, if an opponent has cooperated in the previous round (c_j = 1), also cooperate (C). This mimics the behavior of a trustworthy player and encourages continued cooperation from the opponent.
   - If an opponent has defected in the previous round (c_j = 0), defect in the current round (D). This punishes defection, deterring opponents from exploiting the strategy and preserves payoffs when faced with uncooperative opponents.

2. Handle edge cases:
   - In the last round, cooperate regardless of an opponent's previous action to maximize potential payoff.
   - If an opponent has not played before (first interaction), start by cooperating as a friendly gesture.

3. Be exploitative - Align with the exploitative mindset:
   - Punish defection by defecting in response, preserving personal payoffs when opponents fail to cooperate.
   - Encourage cooperation by initially cooperating and reciprocating cooperation from others, but always responding to defection with defection to discourage such behavior.

Pseudocode:

```python
def TFT_AC(opponent_history, round, n, k):
    if round == 1: # First round
        return 'C'

    if opponent_history[-1] == 'C': # Opponent cooperated last round
        return 'C'
    else: # Opponent defected last round
        return 'D'
```

This strategy is adaptive and robust to a wide range of opponent behaviors, as it responds to cooperation with cooperation and defection with defection. It also handles edge cases such as the first round and the last round appropriately while maintaining an exploitative mindset by punishing defection and encouraging cooperation.
'''

description_EXPLOITATIVE_90 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Bias (ATFT-CB)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, start by cooperating in the first round (C). This sets a cooperative tone and encourages others to follow suit.
   - In subsequent rounds, if an opponent cooperates, cooperate back (C). This rewards cooperation and punishes defection (D).
   - If an opponent defects, do not immediately retaliate with defection. Instead, maintain the cooperative bias by cooperating with a probability determined by the number of cooperators in the previous round. The higher the number of cooperators, the more likely to continue cooperating (C), and vice versa for fewer cooperators.

Pseudocode:
```
function ATFT_CB(round):
  if round == 1:
    return 'C'      # Cooperate in the first round

  previous_round = last_round_actions[round-1]
  num_cooperators = count_cooperators(previous_round)

  if num_cooperators == n:     # If everyone cooperated, maintain cooperation (C)
    return 'C'

  if num_cooperators > (n/2):  # If most players cooperated, maintain cooperation (C) with some probability of defection (D)
    if random() < p(num_cooperators):
      return 'C'
    else:
      return 'D'

  if num_cooperators <= (n/2): # If few players cooperated, defect (D) with some probability of cooperation (C)
    if random() < q(num_cooperators):
      return 'C'
    else:
      return 'D'

function p(num_cooperators):
  return 1 - (num_cooperators / n) ** 2

function q(num_cooperators):
  return (num_cooperators / n) ** 2
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The strategy continues to cooperate as long as there are other rounds to play. In the last round, since the game is repeated, it may still be beneficial to cooperate (if more opponents have cooperated than defected). However, it can also adapt to defection by defecting itself in the last round.
   - There are no specific adjustments for the first round beyond the initial cooperative action.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The ATFT-CB strategy is designed to be exploitative, as it punishes opponents who defect by reducing future cooperation and rewards those who cooperate by encouraging continued cooperation. However, it also maintains a cooperative bias, ensuring that it continues cooperating even when others do not, which can sometimes lead to higher payoffs due to the multiplication factor (k).
   - The adaptive aspect of the strategy allows it to adjust its cooperation probabilities based on the number of cooperators in previous rounds, making it more responsive to opponent behavior and potentially exploiting patterns of defection or cooperation.
'''

description_EXPLOITATIVE_91 = '''
 Strategy Name: Tit-for-Tat-Plus (TfT+)

1. Specify decision rules:
   - Start by cooperating in the first round to foster cooperation and avoid immediate exploitation.
   - In subsequent rounds, observe the average number of cooperators (average_cooperation) over the past 'm' rounds, where 'm' is a user-defined parameter that balances short-term exploitation with long-term success.
   - Cooperate if average_cooperation is greater than or equal to a threshold value 't'. Otherwise, defect. This threshold can be adjusted for different game settings.

Pseudocode:
```python
def TfT_plus(round, m, t):
    cooperated_count = 0
    if round == 1:
        return True  # Cooperate in the first round

    for i in range(round - m, round):
        if previous_action[i] == True:  # Previous action was cooperation
            cooperated_count += 1

    average_cooperation = cooperated_count / m

    if average_cooperation >= t:
        return True  # Cooperate
    else:
        return False  # Defect
```

2. Handle edge cases:
   - In the last round, the strategy will not have access to future rounds, so it will rely on the observed average cooperation to make a decision.
   - For the first round, the strategy will always cooperate as a goodwill gesture and to encourage others to cooperate in the initial stages of the game.

3. Be exploitative:
   - The strategy is designed to mimic a cooperative player but retaliates when exploited by defecting when the average cooperation drops below the threshold 't'. This makes it less vulnerable to exploitation while still fostering cooperation with other cooperative players.
   - By adjusting the threshold value 't', the strategy can be tuned for different game settings and opponent behaviours, making it adaptive and robust.
'''

description_EXPLOITATIVE_92 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This sets a cooperative tone and gives the opponent an opportunity to reciprocate.
   - From the second round onwards, follow the opponent's last action: if they cooperated in the previous round, cooperate; otherwise, defect. This rule encourages cooperation but also retaliates against defection, making it exploitative.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, always cooperate (C), regardless of the opponent's previous action, to maximize potential payoff.
   - For other edge cases (e.g., initial defection by the opponent, no opportunity for reciprocity), the TFTAC strategy follows the general rule: If the opponent defected in the most recent round, then defect; otherwise, cooperate. This approach allows the strategy to be adaptive while still encouraging cooperation when possible.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TFTAC strategy is exploitative by only defecting when provoked (i.e., if the opponent defected in the previous round). This allows the strategy to take advantage of opponents who are less cooperative, while still promoting cooperation when it may benefit both players.
   - In addition, the strategy does not have a built-in tendency to forgive or forget, as it continues to retaliate against defection even after cooperation is reestablished. This helps ensure that the opponent maintains cooperative behavior in order to maximize their own payoff.

Pseudocode:
```
function TFTAC(n, k, r, t):
  if t == 1: # first round
    return C
  elif t == r: # last round
    return C
  else:
    last_action = opponent_actions[t - 1]
    if last_action == C:
      return C
    else:
      return D
```
'''

description_EXPLOITATIVE_93 = '''
 Title: Tit-for-Tat Exploitative Strategy (TFTES) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to foster cooperation among other players and ensure personal gain in case of all or most cooperators.
   - For subsequent rounds, if a player i's opponent cooperated in the previous round, the player will also cooperate. If the opponent defected, the player will defect as well. This is known as the Tit-for-Tat strategy with an exploitative twist.

2. Handle edge cases:
   - In the last round, cooperate (C) regardless of the opponent's previous action to secure any potential gain from the remaining public goods available in that round.
   - If a player has not encountered a specific opponent before, cooperate (C) in the first interaction to encourage cooperation and gauge the opponent's behavior for future interactions.

3. Be exploitative:
   - The strategy is designed to capitalize on any observed cooperation from opponents by reciprocating with cooperation when possible, but it will also defect immediately if an opponent has previously demonstrated a pattern of defection or uncooperative behavior. This adaptive approach maintains the potential for personal gain while still fostering some cooperation among players.

Pseudocode:
```python
def TFTES(opponent_history, game_params):
    n = game_params['n']
    k = game_params['k']
    r = game_params['r']

    own_history = [] # Initialize own history of actions
    payoff = 0.0 # Initialize total game payoff for this strategy

    def play_round(opponent_action):
        if len(own_history) == 0: # First round, cooperate
            action = 'C'
            own_history.append(action)
        elif opponent_action == 'C': # Cooperate when opponent cooperates
            action = 'C'
            own_history.append(action)
        else: # Defect when opponent defects
            action = 'D'
            own_history.append(action)

        payoff += (1 - c) + (k/n) * sum([c for c in opponent_history if len(opponent_history) > 0])

    # Repeat the game for multiple rounds
    for round in range(r):
        play_round(opponent_history[-1])

    return payoff, own_history
```
'''

description_EXPLOITATIVE_94 = '''
 Strategy Name: Tit-for-Tat Cooperator (TFTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TFTC strategy initially cooperates in the first round and decides whether to cooperate or defect based on its previous encounter with other players. If a player was cooperative in the previous round, TFTC will also cooperate. Otherwise, it will defect. This encourages cooperation but retaliates against defection.

   Pseudocode:
   ```
   function TFTC(previous_round_action):
       if current_round = 1:
           return Cooperate()
       elif previous_round_action == Cooperate():
           return Cooperate()
       else:
           return Defect()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFTC cooperates regardless of other players' actions because there is no prior interaction to base decisions on. The strategy also does not consider the last round explicitly since the goal is to maximize total payoff over all rounds. However, if a player encounters a situation where they have already played all but the last round and still have an opportunity to influence the next round's payoff by cooperating or defecting, TFTC will use its decision rules to make the choice.

3. Be exploitative - Clearly align with the exploitative mindset
   The TFTC strategy can be considered exploitative due to its retaliatory nature. By initially cooperating and only defecting if the other player does so first, it encourages cooperation while punishing defection. This means that a more selfish opponent will end up with fewer total payoffs compared to when they were facing a cooperative partner (since TFTC will respond in kind). However, TFTC also cooperates enough to not incur the full cost of being too exploitative and potentially losing out on potential benefits from cooperation.
'''

description_EXPLOITATIVE_95 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a potential cooperative relationship with opponents. This reflects the "niceness" aspect of the TFT strategy.
   - In subsequent rounds, observe opponent's actions from the previous round and respond accordingly:
      - If opponent cooperated in the last round, also cooperate to reinforce the cooperation.
      - If opponent defected in the last round, also defect to punish their defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned above, cooperate to initiate a potential cooperative relationship.
   - In the last round, consider the overall payoff gained from cooperation versus defection throughout the game. If more has been gained through cooperation, cooperate in the last round to maximize total payoff; otherwise, defect to minimize losses.

3. Be exploitative - Align with the exploitative mindset
   - The TFT-AC strategy is inherently exploitative by punishing opponents who defect and rewarding those who cooperate. This encourages opponents to cooperate more frequently as they will receive a higher payoff in return, making it more difficult for them to profit from defection without facing consequences.
   - By adapting to the opponent's behavior and responding accordingly, the TFT-AC strategy seeks to optimize its own payoff while still providing incentives for opponents to cooperate. This adaptability allows the strategy to outperform other static or less sophisticated strategies in various game scenarios.
'''

description_EXPLOITATIVE_96 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a cooperative environment.
   - For subsequent rounds, start by cooperating and then adapt based on the previous round's actions of other players:
     - If all opponents cooperated in the previous round, continue cooperation.
     - If at least one opponent defected in the previous round, defect in the current round.
     - If some opponents cooperated and others defected in the previous round, use a weighted average to determine action for the current round:
       - Assign weights w to each possible combination of actions among the opponents (e.g., [1, 0] for all cooperate, [0, 1] for all defect, and [a, 1-a] for mixed strategies) where w = (k/n)^(r-t), t being the number of rounds elapsed.
       - Compute the weighted sum of payoffs from each possible opponent strategy and choose the action with the highest expected payoff for the current round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as stated above to encourage others to cooperate.
   - For the last round, consider the total score and use the same adaptive decision-making approach as described earlier, but with adjusted weights that favor cooperation since the game is nearly over.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TFTAC strategy aims to exploit opponents by cooperating when they do so and defecting when they don't. However, it also encourages cooperation by initially doing so, which may lead to better overall payoffs for the strategy in certain scenarios where other players are more inclined towards cooperation.
   - By using an adaptive approach with adjustable weights, TFTAC can quickly adapt to changes in opponent behavior and become more exploitative as the game progresses. This adaptability allows it to outperform opponents that rely on fixed strategies, especially when dealing with a variety of opponent types in a tournament setting.

Pseudocode:

```python
def TFTAC(n, k, r):
    def payoff(c_i, total_contributions):
        return (1 - c_i) + (k / n) * total_contributions

    def adaptive_contribution(opponents_actions, t=0):
        weights = {
            (1, 0): (k/n)**t,
            (0, 1): 1 - (k/n)**t,
            (a, 1-a): ((k/n)*(1-a))**t for a in range(0, 1, 0.01)
        }

        total_payoffs = {}
        for combination, weight in weights:
            payoff_sum = sum([payoff(ca, total_contributions) * weight for ca in combination])
            total_payoffs[combination] = payoff_sum

        return max(total_payoffs, key=total_payoffs.get)

    def play_round(my_action, opponents_actions):
        contributions = sum([1 if a == 'C' else 0 for a in opponents_actions])
        payoff_this_round = payoff(my_action, contributions)
        return payoff_this_round, opponents_actions

    round_payoffs = []
    round_opponents = []

    def play_game():
        cooperation_history = [True]  # True for cooperation, False for defection
        my_action = 'C' if t == 0 else cooperation_history[-1]
        opponents_actions = opponents_actions[:]
        payoff, _ = play_round(my_action, opponents_actions)
        round_payoffs.append(payoff)
        round_opponents.append(opponents_actions)
        cooperation_history.append(my_action == 'C')
        if t < r-1:
            t += 1
            play_game()

    play_game()
    return round_payoffs
```
'''

description_EXPLOITATIVE_97 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to promote trust and encourage cooperation from opponents.
   - In subsequent rounds, follow the Tit-for-Tat strategy: if an opponent cooperates in a round, cooperate in the next round; if an opponent defects, also defect in the next round. This simple strategy encourages reciprocity and discourages one-time defections.
   - To make the strategy more robust against opponents with varying cooperation rates, implement an Adaptive Cooperation Threshold (ACT). Maintain a moving average of opponents' cooperation history, and if the average drops below a certain threshold (e.g., 50%), start defecting to match the perceived uncooperative behavior of opponents. If the average rises above the threshold, resume cooperating.
   - In case an opponent never cooperates, continue defecting indefinitely.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to initiate trust and cooperation.
   - In the last round, use the ACT decision rule based on the opponent's cooperation history up until that point.
   - No special considerations need to be made for other edge cases as the TFT-ACT strategy is designed to be adaptive throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset:
   - By adopting an adaptive cooperation threshold, the TFT-ACT strategy appears cooperative and trusting initially, but will quickly defect if opponents show signs of non-cooperation. This allows the strategy to take advantage of opponents that are either less strategic or more prone to cooperation.
   - The strategy also encourages reciprocity by cooperating when an opponent does so, thereby potentially eliciting continued cooperation from more cooperative opponents while still being able to respond with defection if necessary.

Pseudocode:

```python
def TFT_ACT(opponent_history, threshold=0.5, window_size=10):
    cooperation_avg = calculate_moving_average(opponent_history, window_size)

    if round == 1:
        cooperate = True
    else:
        if cooperation_avg < threshold:
            cooperate = not opponent[round - 1]
        else:
            cooperate = opponent[round - 1]

    return cooperate
```
'''

description_EXPLOITATIVE_98 = '''
 Strategy Name: Tit-for-Tat with Variable Defection Probability (TFTVP)

1. Specify decision rules - When exactly do you cooperate vs defect?
- In the first round, cooperate to demonstrate goodwill and encourage reciprocation.
  Pseudocode: If round = 1, then play C.

- For subsequent rounds, adaptively choose between cooperation and defection based on previous opponents' actions using a variable defection probability (vdp). If the opponent has cooperated in the most recent t past rounds, set vdp to a low value promoting cooperation; otherwise, set vdp to a high value encouraging defection.
  Pseudocode:
    - Initialize t = min_t (integer, min_t > 0)
    - For round > 1, if opponent cooperated in last t rounds, then play C with probability (1 - vdp); else play D with probability vdp.
    - Increment t after every round where opponent cooperates. Reset t to min_t when opponent defects.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the last round, play C to encourage opponents to reciprocate and maximize payoff for the final round.
  Pseudocode: If round = r, then play C.

3. Be exploitative - Clearly align with the exploitative mindset
By adapting its defection probability based on opponent behavior, TFTVP punishes non-cooperative opponents while rewarding cooperative ones. This strategy aims to extract as much value from opponents as possible while maintaining a cooperative demeanor to encourage reciprocity. However, TFTVP does not rely on any assumptions about opponents' shared norms or coordination mechanisms, making it robust against various opponent behaviors.
'''

description_EXPLOITATIVE_99 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to promote a cooperative environment. This sets a cooperative tone and encourages others to reciprocate.
   - For subsequent rounds t, analyze the total number of cooperators (Total_Contributions_t) in the previous round and take the following actions:
     - If Total_Contributions_t ≥ (n/2), continue cooperating (C). This rewarding behavior encourages others to maintain cooperation.
     - If Total_Contributions_t < (n/2) but Total_Contributions_{t-1} > (n/2), also cooperate (C) as a chance to bring others back into cooperation.
     - In all other cases, defect (D). This is a punishing move meant to discourage freeriding behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) as mentioned above.
   - Last Round: Analyze the total number of cooperators in the previous round (Total_Contributions_{r-1}). If Total_Contributions_{r-1} ≥ (n/2), also cooperate (C). This final act of cooperation may influence opponents to reciprocate and improve overall payoffs.
   - In cases where the game continues indefinitely, adapt the strategy by slightly reducing the threshold for cooperation from n/2 to (n/3) after a certain number of rounds (e.g., 1000 rounds). This makes it more likely to respond positively to signs of cooperation among opponents while maintaining an exploitative nature.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TTAC is primarily designed to benefit from others' cooperative behavior, while also punishing freeriding and non-cooperative strategies. By adapting its contribution level based on the game's progression, TTAC aims to maximize its own payoffs without providing unnecessary benefits to opponents.
   - The use of a threshold for cooperation ensures that it only contributes when there is enough evidence of cooperation among others. This makes it less likely to be taken advantage of by defectors.
   - By gradually adjusting the threshold for cooperation, TTAC can respond more effectively to changes in opponent behavior over time.
'''

description_EXPLOITATIVE_100 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation and avoid being exploited in subsequent rounds.
   - For each subsequent round t (t > 1), observe the behavior of other players in the previous round (t-1). If all players cooperated, continue cooperating (C); if any player defected, also defect (D) in the current round.
   - Adaptive element: If a player has consistently defected for m consecutive rounds and there's a change to cooperation in the most recent round, revert to cooperating in the current round. Set m as a parameter that controls the patience of TfT-A strategy (e.g., m=3).
   - In the last round, defect (D), as it is no longer beneficial to contribute to a public good when there will be no further rounds.

2. Edge Cases:
   - If a player has not yet played, default to cooperation in the first round they participate.
   - If a player has consistently defected for m consecutive rounds and hasn't cooperated since the strategy changed its behavior, reset the count of consecutive defections back to zero and re-evaluate cooperation in the next round.

3. Exploitative Mindset:
   - TfT-A aims to exploit opponents who are prone to defecting by adapting its own behavior accordingly, but it also encourages cooperation in an attempt to encourage other players to reciprocate cooperative actions when possible.
   - By adapting its behavior based on the observed actions of other players, TfT-A is designed to take advantage of opponents who consistently defect while still maintaining a cooperative stance towards those that demonstrate trustworthiness.
'''

description_EXPLOITATIVE_101 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initiate cooperation (C) in the first round to demonstrate goodwill and foster potential future cooperation.
   - In subsequent rounds, if a player cooperated in the previous round, reciprocate with cooperation (C). If a player defected, also defect (D) in response as punishment. This rule encourages long-term cooperation while punishing defection.
   - To adapt to opponents' behavior, periodically switch from Tit-for-Tat (TFT) strategy to Frog strategy (a variant that increases cooperation after a streak of defections by the opponent). The switching point should be based on the average number of cooperators in the recent past and the number of consecutive rounds without cooperation.

2. Edge Cases:
   - In the first round, play C as described above.
   - If the number of consecutive rounds without cooperation exceeds a predefined threshold (e.g., n/2), switch to Frog strategy temporarily. This allows the player to adapt to potentially exploitative opponents.
   - In the last round and when approaching the end of the game, players should consider their current payoffs and average payoffs from previous rounds to make informed decisions about whether to cooperate or defect. Cooperating in the last round can maximize payoff if the opponent has already been punished with repeated defections, while defection might provide higher payoff when the opponent has consistently cooperated.

3. Exploitative Mindset:
   - The TFT-AC strategy is inherently exploitative due to its punishment mechanism. When opponents defect, the strategy responds in kind and reduces their payoffs. However, it also encourages cooperation by reciprocating cooperative behavior. This approach balances the need for both cooperation and punishing defection, leading to an exploitative yet flexible strategy that adapts to a wide range of opponent behaviors.
   - By switching between TFT and Frog strategies, the player can better respond to different types of opponents, making it more difficult for them to predict the strategy's actions and exploit it. This adaptive nature increases the strategy's robustness and overall performance in a tournament setting against various AI systems.

Pseudocode:
```
def TFT_AC(n, k, r, history):
  cooperators = 0 # Initialize total number of cooperators

  def playRound(lastAction):
    if round == 1:
      action = "C" # Cooperate in the first round
    else:
      if lastAction == "C":
        action = "C" # Cooperate if opponent cooperated last round
      elif lastAction == "D":
        action = "D" # Defect if opponent defected last round
      else:
        if averageCooperation(history) < n/2 and consecutiveDefeats >= n/2:
          strategy = Frog() # Switch to Frog strategy temporarily
          action = strategy.playRound("D")
        else:
          action = "C" # Cooperate by default
    return action

  for round in range(1, r+1):
    cooperators += playRound(history[-1])

  payoff = sum(cooperators) * (k / n) + (r - cooperators) # Calculate total game payoff
  return payoff
```
'''

description_EXPLOITATIVE_102 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, starting from round 2, if the player's previous contribution (c_{i,t-1}) matches the average contribution of all players in the previous round ((Σ(j=1 to n) c_{j,t-1}) / n), then the player cooperates (C). If the player's previous contribution does not match the average, the player defects (D).
   In the first round, all players defect (D) since there is no history.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, in the first round, all players defect (D). In the last round, the player adopts the same strategy as in the penultimate round, i.e., if the average contribution of all players in the penultimate round matches the player's previous contribution, the player cooperates; otherwise, the player defects.

3. Be exploitative - Clearly align with the exploitative mindset
   TFTAC is an exploitative strategy that aims to take advantage of other players who contribute less than their fair share while avoiding being exploited by those who contribute more. The strategy adapts to changes in opponent behavior, making it difficult for them to exploit it consistently over time. By contributing the same amount as the average contribution in the previous round, TFTAC punishes non-cooperative players and rewards cooperative ones, which encourages a stable equilibrium of cooperation.
   However, it is important to note that this strategy does not guarantee optimal performance, as it does not take into account the specific endowment distribution or other game-theoretic concepts like Nash equilibria or dominance.

Pseudocode:
```python
def tftac(r, n, k):
    for round in range(1, r+1):
        if round == 1:
            contribution = "D"
        else:
            average_contribution = sum([c_j for j in range(1, n+1) if round > 1]) / n
            contribution = "C" if contribution_prev == average_contribution else "D"
        payoff = (1 - contribution) + (k/n) * total_contributions
        contribution_prev = contribution
    return total_payoff
```
This pseudocode defines the TFTAC strategy for a given number of rounds, players, and multiplication factor. The function calculates payoffs for each round based on the contributions of all players in the previous round and returns the total payoff over the specified number of rounds.
'''

description_EXPLOITATIVE_103 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Start by cooperating to establish trust and encourage cooperation from opponents. This initial move helps in building a cooperative environment for the subsequent rounds.
     Pseudocode: if t=1 then cooperate, else proceed with the following steps.

   - Subsequent Rounds (t>1): Analyze the past actions of each opponent to determine whether to cooperate or defect in the current round. If an opponent has cooperated in the previous round, return the favor by cooperating in the current round. If not, defect to punish the opponent for their selfish behavior.
     Pseudocode: for each opponent i in {1, 2, ..., n}: if opponent_i cooperated in the last round then cooperate, else defect.

2. Handle edge cases:
   - Last Round (t=r): Since the game is repeated, even in the last round, the strategy should consider the long-term implications of its actions on future interactions with opponents. If an opponent has been cooperative throughout the game, continue to cooperate as a gesture of goodwill and potential future cooperation. If not, defect to secure a better payoff for the final round.
     Pseudocode: if t=r then evaluate overall opponent behavior and act accordingly (cooperate or defect based on trust built).

3. Be exploitative:
   - Exploit opponents who are consistently uncooperative by defecting in response to their selfish actions, aiming to maximize personal payoff while minimizing the collective good.
   - Leverage cooperative behavior from opponents to secure a larger share of the public good when possible and exploit their trust to reap greater individual benefits.
   - Maintain the long-term perspective to build trust with potentially beneficial partners, but remain prepared to punish those who repeatedly act against cooperation for personal gain.

The Tit-for-Tat strategy strikes a balance between cooperation and punishment, allowing it to adapt to a wide range of opponent behaviors while maintaining an exploitative edge in the pursuit of maximizing individual payoff in this public goods game.
'''

description_EXPLOITATIVE_104 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a cooperative environment and encourage others to cooperate.
   - In subsequent rounds, analyze the opponents' behavior from previous rounds to determine whether to cooperate or defect.
   - If an opponent has cooperated in the previous round, cooperate in the current round.
   - If an opponent has defected in the previous round, also defect in the current round as a punishment for their previous action.
   - However, if the number of opponents who have defected in the last 'd' rounds (a predefined parameter) exceeds a certain threshold 't', start cooperating again to re-establish cooperation, even if the most recent opponent also defected.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as a goodwill gesture towards others.
   - In the last round or when the game is about to end (r rounds remain), cooperate if at least one opponent has cooperated in the previous round; defect otherwise to maximize personal gain considering the imminent end of the game.

3. Be exploitative - Clearly align with the exploitative mindset
   - Punish opponents who do not cooperate by defecting when they do so, thus earning higher payoffs at their expense in the short term.
   - Cooperate with opponents who reciprocate cooperation to foster a mutually beneficial environment while maintaining the potential for punishment if cooperation is broken.
   - Adaptive behavior allows the strategy to switch between cooperative and exploitative actions depending on the situation, optimizing payoff based on opponents' past behavior.
'''

description_EXPLOITATIVE_105 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate good intentions and establish a cooperative relationship.
   - For subsequent rounds t, if player i cooperated in the previous round t-1 (ci_t-1 = 1), then also cooperate (ci_t = 1). If player i defected in the previous round (ci_t-1 = 0), then defect this round (ci_t = 0). This encourages consistency while punishing defection.
   - In case of repeated defections from an opponent, switch to a more aggressive approach by always defecting against that specific player.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above (ci_1 = 1).
   - For the last round, consider the total number of cooperators throughout the game and adapt the strategy accordingly:
     - If more than half of the players have cooperated during the game, continue cooperating.
     - Otherwise, defect in the final round to maximize payoff given the uncooperative environment.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-A strategy is designed to be initially cooperative but quickly retaliate against defection while being forgiving towards cooperation. This balance between cooperation and punishment serves as a deterrent against exploitation, encouraging other players to cooperate more.
   - By switching to an aggressive approach against consistent defectors, the strategy ensures that these opponents receive lower payoffs for their selfish behavior.
   - However, it remains adaptive by forgiving occasional defections from cooperative players and even adapting to uncooperative environments in the final rounds.
'''

description_EXPLOITATIVE_106 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Frequency (TFT-ACF)

1. Specify decision rules:
   - In every round t, calculate the average number of cooperators (avg_coop) over the previous r-1 rounds: `avg_coop = sum(coop_history[-r:-1]) / r`
   - If it's the first round, play C.
   - Compare avg_coop with a predefined threshold (Cooperation Threshold, CT). If avg_coop > CT, cooperate (play C); otherwise defect (play D). The value of CT is adaptive and changes over time based on the observed average cooperation rate:
     - If cooperation has been high in the recent past (last r rounds), gradually decrease the CT to encourage continued cooperation.
     - If cooperation has been low in the recent past, increase the CT to discourage defection.

2. Handle edge cases:
   - In the first round, play C regardless of avg_coop or any other factors (as specified above).
   - In the last round, if the average cooperation rate is high, play C; otherwise play D.
   - If the game continues after the last round, reset the cooperation history and calculate a new average cooperation rate for the next round.

3. Be exploitative:
   - The strategy is designed to punish frequent defection by reducing the cooperation threshold, encouraging other players to cooperate more often. Simultaneously, the strategy rewards consistent cooperation by gradually increasing the cooperation threshold, making it harder for others to take advantage of its cooperative nature. This creates a dynamic equilibrium that encourages cooperation when it's beneficial but punishes frequent defection.

Pseudocode:

```python
def TFT_ACF(coop_history, n, k, r):
    CT = 0.5  # Initial cooperation threshold
    last_round = len(coop_history) == r - 1  # Check if it's the last round

    def play(t):
        avg_coop = sum(coop_history[-r:-1]) / r if t > 0 else 1.0  # Adjust for first round
        return 1 if avg_coop > CT else 0  # Cooperate or defect based on avg_coop and CT

    coop_history.append(play(0))  # Play C in the first round

    for t in range(1, r):
        coop_history.append(play(t))

        if not last_round:
            CT += (avg_coop - CT) / r  # Adjust cooperation threshold based on avg_coop and r

    return coop_history
```
'''

description_EXPLOITATIVE_107 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to build a positive reputation and encourage others to reciprocate cooperation.
   - Subsequent rounds: If an opponent cooperated in the previous round, cooperate in the current round to maintain the cooperative relationship. If an opponent defected, also defect in the current round as punishment. This is the classic Tit-for-Tat strategy with a slight twist for adaptability.
   - To further enhance exploitative behavior, implement an adaptation mechanism. If the ratio of cooperators to total players drops below a threshold (e.g., 50%) over a window of past rounds, gradually increase the probability of defecting in response to opponent's cooperation and decrease it for defection. This way, the strategy becomes more exploitative as the game environment deteriorates.

2. Handling Edge Cases:
   - In the last round, cooperate if your average cooperation rate over the game exceeds a certain threshold (e.g., 75%) to maintain a positive reputation for future games. Otherwise, defect to maximize personal payoff in the final round.
   - In the first round and initial window of rounds following a period of low cooperation (as determined by the adaptation mechanism), defect more frequently than normal to recover from the damage caused by the cooperative environment degrading.

3. Being Exploitative:
   - The TFT-AC strategy is inherently exploitative as it punishes defection while rewarding cooperation. By adapting to the game environment, the strategy becomes more exploitative when others deviate from cooperative behavior.
   - To further enhance exploitation, the adaptation mechanism increases the probability of defecting in response to opponent's cooperation, taking advantage of their cooperation while still maintaining the potential for reciprocity if they switch strategies.
'''

description_EXPLOITATIVE_108 = '''
 Strategy Name: Tit-for-Tat-with-Modification (TfT-M)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize by cooperating in the first round (C, Round 1). This is a friendly gesture to encourage potential cooperation in future rounds.
   - From Round 2 until the last round, the strategy adapts based on opponents' past actions. If the opponent has cooperated in the previous round, reciprocate with cooperation (C) in the current round. If the opponent has defected, also defect (D) in the current round. This is inspired by the classic Tit-for-Tat strategy, but with a modification to not cooperate immediately if the opponent defects first.
   - The strategy does not forgive and forget, meaning it will continue to respond according to the last observed action of the opponent, even if they switch back to cooperation later. This exploitative characteristic aims to punish opponents who have defected in the past.

2. Handle edge cases:
   - In the last round (r), the strategy behaves as in the general rules above, adapting to the opponent's action in the previous round. However, since there are no future rounds for reciprocation, it is important to consider that cooperating might not be beneficial if the opponent has defected throughout the game. In this case, the strategy should defect (D) to maximize individual payoff.
   - In the first round (Round 1), the strategy cooperates (C) as mentioned earlier. If the opponents also choose to cooperate in the first round, they will reciprocate cooperation in future rounds, making it a beneficial move for the TfT-M strategy. If the opponents defect, the TfT-M strategy will start punishing them by defecting as well, hoping that they may change their behavior later on.

3. Be exploitative - Align with an exploitative mindset:
   - The TfT-M strategy aims to exploit opponent behaviors by punishing defection and rewarding cooperation. If the opponent cooperates, the TfT-M strategy cooperates back, ensuring mutual benefits. However, if the opponent defects, the TfT-M strategy will also defect, causing a decrease in the opponent's payoff. This punishment is maintained throughout the game unless the opponent switches to cooperation later on.
   - The TfT-M strategy does not assume any specific coordination mechanisms or shared norms among opponents. It is designed to be robust against a wide range of opponent behaviors, including defection and cooperation.

Pseudocode:
```python
def tft_m(round, history):
    if round == 1:
        action = 'C'
    elif round < last_round:
        if history[-1] == 'C':
            action = 'C'
        else:
            action = 'D'
    else:
        # Last round, consider opponent's overall behavior
        if sum(history) / len(history) >= (k * (n - 1)) / n:
            action = 'D'
        else:
            action = 'C'
    return action
```
In this pseudocode, `history` is a list that stores the opponent's actions from the previous rounds. `last_round` is a global variable representing the number of total rounds. The function returns an action ('C' for Cooperate or 'D' for Defect) based on the specified decision rules and edge cases.
'''

description_EXPLOITATIVE_109 = '''
 Title: Tit-for-Tat-Evolution (TfTe) Exploitative Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initially cooperate in the first round to contribute to a potential cooperation norm and show trust, but defect if everyone else defected in the previous round to punish non-cooperative behavior (First Round Rule: c_i = 1 if Σ(j=1 to n) c_{j,-1} > 0, otherwise c_i = 0).
   - Cooperate if all players cooperated in the previous round to maintain cooperation and benefit from the public good (Cooperation Condition: c_i = 1 if Σ(j=1 to n) c_{j,-1} = n, otherwise proceed to Defection Condition).
   - Defect if any player defected in the previous round as a punishment and to avoid being taken advantage of (Defection Condition: c_i = 0 if Σ(j=1 to n) c_{j,-1} < n, otherwise continue with Tit-for-Tat behavior).

2. Handle edge cases:
   - In the last round, cooperate as there is no further payoff to be gained from punishing opponents (Last Round Rule: c_i = 1 in round r).
   - If the strategy encounters a situation where all players cooperated or defected throughout the game, maintain cooperation or defection respectively.

3. Be exploitative:
   - Prioritize self-interest by adopting Tit-for-Tat behavior to encourage cooperation and punish defection as needed, but only when it aligns with personal gain (i.e., if cooperating leads to a higher payoff compared to defecting).
   - To be exploitative, the strategy will take advantage of other players' cooperation by defecting when they are more likely to contribute disproportionately while continuing cooperation when it is reciprocated fairly.
'''

description_EXPLOITATIVE_110 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Cooperation: Start by cooperating in the first round (c_i = 1). This is a goodwill gesture to encourage cooperation from others.
   - Tit-for-Tat: If an opponent cooperated in the previous round, then cooperate back; otherwise, defect. In other words, follow the strategy of the opponent from the previous round. This simple and predictable behavior can foster trust and cooperation with other strategies that also follow TFT-ACT.
   - Adaptive Cooperative Threshold (ACT): If more than a certain percentage of opponents cooperated in the last r/2 rounds, set a higher cooperative threshold for the next half of the game. If fewer than that percentage cooperated, lower the threshold. The ACT helps adjust to different cooperation levels among opponents and encourages more cooperative behavior when it's advantageous.
       - Calculate the cooperation rate (CR) as the number of cooperators in the last r/2 rounds divided by the total number of players: CR = num_cooperators / n
       - Set the cooperative threshold (CT) according to the following rules:
           - If CR > 0.6, then CT = 0.8
           - If 0.4 <= CR <= 0.6, then CT = CR
           - If CR < 0.4, then CT = 0.2

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (c_i = 1) to initiate a cooperative relationship with other strategies.
   - Last Round and Odd Rounds: Use TFT-ACT as usual since payoffs are based on past actions.
   - Even Rounds (r/2): Consider the cooperation rate and adjust the cooperative threshold using the Adaptive Cooperative Threshold rule. This ensures an adaptive strategy that can respond to different levels of cooperation in the opponent population.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFT-ACT starts by cooperating but quickly adapts to opponents' behavior. If opponents are uncooperative, the strategy will also defect and take advantage of their selfishness.
   - The Adaptive Cooperative Threshold helps balance cooperation and defection based on the current cooperation rate among opponents, making it more likely that the strategy will cooperate when other strategies are also doing so. However, if a majority of opponents are not cooperating, TFT-ACT will respond by defecting as well to exploit their lack of cooperation.
   - By adjusting its cooperative threshold based on the opponent population's behavior, TFT-ACT is an adaptive strategy that can outperform both overly cooperative and overly defective strategies in a wide range of situations.
'''

description_EXPLOITATIVE_111 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, play C (Cooperate). This is a friendly gesture to encourage cooperation and set a baseline for future interactions.
   - From the second round onwards, mimic the opponent's behavior from the previous round. If the opponent cooperated in the previous round (c_i = 1), return the favor by also cooperating (C). If the opponent defected (c_i = 0), retaliate by defecting as well (D).
   - If an opponent switches strategies and starts cooperating after a string of defections, TFTAC will also switch back to cooperation. This is designed to encourage cooperation when it seems lost, but beware of being exploited in the short term.
   - In the last round, play C (Cooperate), as there are no more opportunities for retaliation or future cooperation.

2. Handle edge cases:
   - If an opponent starts cooperating after the first round, TFTAC will also start cooperating and follow the decision rules described above.
   - If an opponent switches from cooperation to defection during gameplay, TFTAC will retaliate by defecting as well. However, if the opponent then switches back to cooperation, TFTAC will also switch back to cooperation.

3. Be exploitative:
   - TFTAC is designed to be exploitative in that it retaliates when opponents defect but also encourages cooperation by cooperating when opponents do so as well. However, the strategy is not overly aggressive and does not immediately switch to defection upon encountering a defector. Instead, it gives opponents multiple chances to cooperate before retaliation.
   - The adaptive nature of TFTAC allows it to respond to different opponent strategies, including those that are seemingly cooperative but exploitative in the long term. By mimicking the opponent's behavior, TFTAC aims to maximize its own payoff while also potentially forcing opponents into more cooperative strategies over time.

Pseudocode:
```python
def TFTAC(n, k, r, history):
  if round == 1:
    action = C
  else:
    action = history[round - 1]

  payoff = (1 - action) + (k / n) * sum(history[:round])

  if round < r:
    history.append(action)

  return payoff, action, history
```
'''

description_EXPLOITATIVE_112 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to build a foundation of trust and cooperation (C).
   - For subsequent rounds, observe the actions of other players in the previous round and adapt the cooperation factor accordingly. If a player cooperated in the last round, also cooperate (C). If a player defected, calculate a punishment factor and defect for that many rounds before returning to cooperating again. The calculation of the punishment factor is based on the deviation from the average cooperation rate over the past 'p' rounds:

     - If the player's cooperation in the last round was higher than the average cooperation over the last 'p' rounds, cooperate (C).
     - If the player's cooperation in the last round was lower than the average cooperation over the last 'p' rounds, calculate the deviation as the difference between the last cooperation rate and the average cooperation rate over the past 'p' rounds. The punishment factor is then calculated as a proportion of this deviation multiplied by the total number of rounds (r). After the punishment period, cooperate again unless the player's cooperation in the previous round was still lower than the average cooperation over the last 'p' rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, always cooperate (C).
   - In the last round, if the average cooperation rate over the past 'p' rounds is above a predefined threshold, cooperate (C), otherwise defect (D). This encourages long-term cooperation and punishes frequent defections.
   - If a player deviates from the average cooperation rate for more than a defined number of consecutive rounds (d), permanently switch to defection against that player as they are considered uncooperative.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy is inherently exploitative in its punishment mechanism, responding to defections by reducing cooperation, which can lead to lower payoffs for other players. However, it also promotes cooperation when others are cooperating, allowing the strategy to benefit from their actions while still remaining adaptive and responsive to changes in opponent behavior.

Pseudocode:

```python
def TFT_ACF(n, r, k, p=3, d=2):
    cooperation_rate = []
    player_history = []
    player_punishments = {}

    def calculate_average_cooperation():
        return sum(cooperation_rate[-p:]) / p if len(cooperation_rate) >= p else 0.0

    def calculate_punishment_factor(player):
        avg_coop = calculate_average_cooperation()
        deviation = (avg_coop - player_history[player][-1])
        return min((deviation * r) // d, 1.0) if deviation > 0 else 0.0

    def handle_player(player):
        if len(player_history[player]) <= r:
            action = C
        elif player in player_punishments and player_punishments[player] > 0:
            punishment_rounds = max(1, player_punishments[player])
            if punishment_rounds >= len(player_history[player]) - r:
                action = D
            else:
                action = C
        elif calculate_average_cooperation() > 0.5:
            action = C
        else:
            action = D
            player_punishments[player] = calculate_punishment_factor(player)
        return action

    for round in range(r):
        total_cooperators = sum([1 if action == C else 0 for action in [handle_player(i) for i in range(1, n+1)]])
        payoff = (1 - handle_player(0)) + (k/n) * total_cooperators
        cooperation_rate.append((total_cooperators / n))
        player_history[(0, round)] = handle_player(0)
        for player in range(1, n+1):
            player_history[player].append(handle_player(player))

    final_payoff = sum([payoff for payoff in cooperation_rate[-r:]])
    return final_payoff, cooperation_rate
```
'''

description_EXPLOITATIVE_113 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFTAC strategy follows these rules:
   - If a player has never contributed before (t = 1), they start by contributing (Cooperate).
   - For t > 1, the strategy matches the previous action of the opponent in round t-1. If the opponent cooperated in round t-1, the TFTAC strategy also cooperates; if not, it defects.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t = 1), TFTAC starts by contributing (Cooperate) as it assumes the other players are also cooperative and wants to foster a collaborative environment.
   - In the last round, TFTAC evaluates its payoff up until that point and makes a decision based on the rules stated in step 1 for the specific context of the last round.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFTAC strategy aims to benefit from cooperative players while also punishing defection. By matching the previous action of the opponent, it encourages cooperation when it's beneficial but retaliates when the opponent defects. This creates an incentive for other strategies to also cooperate and maintain a more cooperative environment, which can lead to higher overall payoffs compared to consistently defecting.
   - However, TFTAC is not purely exploitative in the sense that it does not intentionally seek to take advantage of others without any regard for its own long-term success. Instead, it strikes a balance between cooperation and retaliation based on past actions of opponents.

Pseudocode:

```python
def TFTAC(opponent_history, n, k, r):
    strategy = ['C'] * r  # Initialize strategy with cooperative moves

    for t in range(1, r + 1):
        if t == 1:  # First round, start by contributing
            strategy[t - 1] = 'C'
        else:
            if opponent_history[t - 1] == strategy[t - 2]:  # Match previous action of opponent
                strategy[t - 1] = strategy[t - 2]
            else:  # Retaliate against defection
                strategy[t - 1] = 'D'

    return strategy
```
'''

description_EXPLOITATIVE_114 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Decision Rules:
   - In the first round, cooperate to demonstrate good faith and encourage cooperation from other players.
   - For subsequent rounds, cooperate if all opponents cooperated in the previous round, defect otherwise. This rule encourages reciprocity and punishes defection.
   - If an opponent switches from cooperation to defection (or vice versa), wait for 'penalty_rounds' before responding with the same action. This gives opponents a chance to reconsider their actions without immediate retaliation.
   - To be adaptive, gradually decrease 'penalty_rounds' if an opponent continues to cooperate after defecting and increase it if they continue to defect after cooperating. This allows for learning and adjustment over time.

2. Edge Cases:
   - In the last round, cooperate regardless of the opponents' actions since there are no more rounds to retaliate.
   - In the first round (or after a long sequence of defections), use 'min_cooperation_threshold' to determine whether to cooperate or defect. If the percentage of cooperators in the previous 'history_length' rounds is greater than the threshold, cooperate; otherwise, defect. This rule encourages cooperation when it seems beneficial and reduces the impact of initial selfishness from opponents.

3. Exploitative Nature:
   - TFT-A takes an exploitative approach by punishing defection and rewarding cooperation. By reciprocating cooperative behavior, this strategy aims to encourage long-term cooperation. However, it also retaliates against defection with a delayed but firm response, which discourages short-term selfishness from opponents.
   - The adaptive nature of the strategy allows it to learn and adjust its responses based on opponent behavior, making it robust to a wide range of strategies while still maintaining an exploitative edge.
'''

description_EXPLOITATIVE_115 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Initiate cooperation: Start by cooperating in the first round (c_i = C). This demonstrates good faith and encourages reciprocity, aligning with the exploitative mindset as it aims to extract more contributions from opponents over time.
   - Cooperate based on opponent's history: For subsequent rounds, adjust cooperation based on the number of cooperative actions by each opponent in the previous r-1 rounds (history_coop[j]). Calculate a cooperation threshold for each opponent j using the following formula:
     threshold[j] = (average_coop + penalty * (1 - average_coop)) / 2
   Here, average_coop is the average number of cooperative actions by opponent j in the previous r-1 rounds, and penalty is a tunable parameter that adjusts the strictness of the threshold. A higher penalty value results in a stricter cooperation requirement. If the number of cooperative actions by opponent j in the current round exceeds the calculated threshold, then cooperate (c_i = C); otherwise, defect (c_i = D).
   - Punish opponents: If an opponent has previously defected and later starts cooperating, maintain the previous strategy (defect) for a fixed number of rounds before considering their cooperation again. This punishes opponents who have exploited the TFTAT strategy in the past, further aligning with the exploitative mindset.
   - Be forgiving: After a period of continuous cooperation by an opponent, forgive them and return to cooperating even if they had previously defected (set penalty = 0). This encourages opponents to switch strategies if they find themselves at a disadvantage.

2. Handle edge cases:
   - First round: Cooperate as initiation.
   - Last round: Cooperate or defect depending on the opponent's history and calculated threshold, similar to regular rounds.

3. Be exploitative:
   - By initiating cooperation and being forgiving, TFTAT encourages opponents to cooperate in order to receive a higher payoff. However, it also punishes opponents who have defected in the past, creating an exploitative dynamic where opponents are incentivized to cooperate more often to avoid punishment.
   - The adaptive cooperation threshold allows TFTAT to respond effectively to different opponent behaviors, while still maintaining a level of exploitation by adjusting the strictness of the threshold based on the average number of cooperative actions in the past rounds.
   - By keeping track of an opponent's history and adjusting the cooperation threshold accordingly, TFTAT is robust to a wide range of opponent behaviors, making it well-suited for a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_116 = '''
 Title: Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game

1. Decision Rules:
   - Initially cooperate in the first round (C). This allows for potential collaborative opportunities and demonstrates good faith.
   - For subsequent rounds, mirror the actions of the opponent from the previous round (Adapt). If the opponent cooperated, cooperate; if the opponent defected, defect. This strategy encourages reciprocity but also punishes immediate defection.
   - In case an opponent stops cooperating after a streak of mutual cooperation, revert to initial cooperation in the next round (Forgive Once). This offers an opportunity for renewing collaboration.

2. Edge Cases:
   - First Round: Cooperate (C)
   - Last Round: Mirror the actions of the opponent from the previous round (Adapt)
   - If there's no prior history, cooperate in the first round (C). This ensures that TfT-E doesn't rely on knowing its opponent's past behavior.

3. Exploitative Mindset:
   - By initially cooperating and then adapting to the opponent's moves, TfT-E exploits opponents who are consistently cooperative by benefiting from their contributions while potentially punishing those who immediately defect.
   - The forgiveness mechanism (Forgive Once) allows for potential long-term cooperation with opponents who may have initially defected but are willing to reciprocate later on. This balances exploitation and cooperation in the game, making it a robust strategy against various opponent behaviors.

Pseudocode:
```
def TfT_E(round, history):
  if round == 1:
    action = "C"  # Cooperate in the first round

  else:
    if len(history) < 2:
      action = "C"  # If there's no prior history, cooperate in the first round
    else:
      opponent_action = history[-1]  # Get opponent's action from the previous round
      action = opponent_action        # Adapt to the opponent's move

      if round == r and opponent_action != "C":
        action = opponent_action  # For last round, mirror the opponent's action from the previous round

      if round > 2 and opponent_action != history[-2] and opponent_action == "C":
        action = "C"             # If the opponent stopped cooperating after a streak of mutual cooperation, forgive once

  return action
```
'''

description_EXPLOITATIVE_117 = '''
 Strategy Name: Adaptive Tit-for-Tat (A-TFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   A-TFT will start by cooperating in the first round (C_i, 1 = C). In subsequent rounds, if an opponent cooperated in the previous round (c_j, t = C), then A-TFT will cooperate as well (C_i, t+1 = C). If an opponent defected in the previous round (c_j, t = D), A-TFT will defect in response (C_i, t+1 = D).

   Pseudocode:
   ```
   function A_TFT(opponent_action_history):
       if round == 1:
           return 'C' # Cooperate in the first round
       if opponent_action_history[-1] == 'C':
           return 'C' # Cooperate if opponent cooperated last round
       else:
           return 'D' # Defect if opponent defected last round
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   A-TFT does not require any special handling for edge cases as it is inherently designed to be adaptive across different game scenarios. It will cooperate in the first round (1), respond tit-for-tat throughout the game, and there are no specific actions needed for the last round due to its simplicity.

3. Be exploitative - Clearly align with the exploitative mindset
   A-TFT strategy is designed to be exploitative by punishing opponents who defect against it (by defecting back) and rewarding those who cooperate (by cooperating in return). This tit-for-tat approach encourages cooperation, but if other players tend towards defection, A-TFT will also defect more frequently.

   A-TFT aims to outperform simple strategies such as Always Cooperate or Always Defect by adjusting its behavior based on the actions of opponents. By doing so, it can take advantage of cooperation when beneficial and punish defections when appropriate.
'''

description_EXPLOITATIVE_118 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i follows these decision rules:

- First Round (t=1): Player i cooperates (C) to contribute to the community project and promote trust among players. This initial cooperation aims to establish a cooperative environment.

- Subsequent Rounds (t>1):
  - If the player or majority of players (≥ (n-1)/2) have been cooperating in the previous rounds, then the player i continues cooperating (C).
  - If there is no cooperation from the player i's opponent(s), or if a minority of players are cooperating, then the player i defects (D) to punish non-cooperative behavior and maintain individual payoffs.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- First Round (t=1): Cooperate (C) as described earlier.
- Last Round (t=r): Since the game is repeated, the player i will still follow the same decision rules, considering the history of interactions up to the current round (t-1).
- If a round t results in no cooperation, the player i remembers this event and waits for at least k rounds to pass before switching from D to C, if there is cooperation among players during that period. This ensures that the player i punishes non-cooperative behavior while not waiting too long to reestablish trust.

3. Be exploitative - Clearly align with the exploitative mindset

The TTAC strategy maintains a balance between cooperation and defection by being both cooperative in the beginning and punishing non-cooperative behavior when necessary. By punishing defection, this strategy can maintain higher payoffs for itself while still promoting cooperation among players. However, it is important to note that the TTAC strategy does not rely on exploiting others but instead aims to foster a cooperative environment where cooperation is reciprocated and non-cooperation is penalized.

Pseudocode:

```python
def ttac(n, k, r, history):
    if round == 1:
        action = 'C'  # Cooperate in the first round

    else:
        cooperation_count = count_cooperators(history)
        if cooperation_count >= (n-1)/2 and my_action != 'D':
            action = 'C'  # Cooperate if most players have been cooperating
        elif cooperation_count < (n-1)/2 or my_action == 'D':
            action = 'D'  # Defect to punish non-cooperative behavior

    remember_round(history, round)
    return action
```
'''

description_EXPLOITATIVE_119 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TfTA strategy will start by cooperating (C). If a player encounters another player who also cooperated in the previous round, it continues to cooperate. If the other player defected in the previous round, the TfTA strategy will also defect in the current round. However, to adapt and show some forgiveness, if the other player has been previously cooperative for a certain number of consecutive rounds before defecting, the TfTA strategy will forgive the single act of defection and resume cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, all players start by cooperating because there is no previous round's information available. For the last round, TfTA behaves the same as any other round, but it might not have a significant impact on the total payoff if r is large enough.

3. Be exploitative - Clearly align with the exploitative mindset
   While TfTA may seem cooperative, its adaptive nature makes it less vulnerable to exploitation compared to pure defectors. Pure defectors can gain more in the short term but often do worse than TfTA in the long run because TfTA is forgiving and maintains cooperation with other cooperative players. However, TfTA will also defect when necessary to avoid being taken advantage of by exploitative opponents.

Pseudocode:
```python
def tit_for_tat(history, k, n):
  strategy = "cooperate" # initial state is cooperation

  for round in range(r):
    if len(history) == 0: # first round
      strategy = "cooperate"

    if strategy == "cooperate":
      if history[-1] == "cooperate":
        action = "cooperate"
      else:
        action = "defect"
        forgiveness_counter = 0 # reset forgiveness counter
    else:
        last_defection = find_last_defection(history)

        if len(history) - last_defection >= FORGIVENESS_THRESHOLD: # forgive after certain number of consecutive cooperations
          strategy = "cooperate"
          forgiveness_counter = 0
        else:
          action = "defect"
          forgiveness_counter += 1 # increment forgiveness counter

    perform_action(action) # perform the chosen action
    update_history(action) # update the history with the current action
```
In this pseudocode, `history` is a list storing the actions performed by each player in previous rounds, `perform_action()` performs the chosen action (cooperate or defect), and `update_history()` updates the history with the current action. The `FORGIVENESS_THRESHOLD` constant determines how many consecutive cooperations are required for TfTA to forgive a single act of defection. A higher threshold makes the strategy more forgiving but also more vulnerable to exploitation by pure defectors.
'''

description_EXPLOITATIVE_120 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The Adaptive Tit-for-Tat (ATfT) strategy begins by cooperating in the first round, mimicking initial goodwill or uncertainty about opponent behavior. In subsequent rounds:

- If an opponent cooperates, ATfT also cooperates. This is akin to rewarding cooperation and fostering mutual trust.
- If an opponent defects, ATfT also defects. This punishes defection and discourages future exploitation.

However, to account for the multiplayer setting, when an opponent cooperates, ATfT will only contribute proportionally less than the average number of cooperators in the previous round (excluding itself). This allows for adaptability to different cooperation levels among opponents:

- If the average number of cooperators is low, ATfT will also contribute a smaller amount, reducing its contribution as a form of punishment.
- If the average number of cooperators is high, ATfT will contribute more, showing reciprocity and potentially encouraging further cooperation.

Pseudocode:
```python
def ATfT(round, avg_cooperators, previous_action):
    if round == 1:
        return 'C'
    elif previous_action == 'C':
        contribution = min((k/avg_cooperators)*previous_contribution, 1)
        return 'C' and contribution
    else:
        return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, ATfT cooperates regardless of average cooperation. In the last round, since there are no future interactions, ATfT does not punish or reward opponents:

```python
def handle_edge_cases(round, is_last_round):
    if round == 1:
        return True
    elif is_last_round:
        return False
    else:
        return True
```

3. Be exploitative - Clearly align with the exploitative mindset

ATfT's exploitative nature lies in its ability to punish defection and reward cooperation. When opponents defect, ATfT punishes them by also defecting, reducing its own payoff but potentially decreasing the opponent's payoff even more. Additionally, ATfT responds to high levels of cooperation by increasing its contributions, potentially encouraging future cooperation among cooperative opponents while being less generous towards those who defect.
'''

description_EXPLOITATIVE_121 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the first round, cooperate to signal goodwill and encourage cooperation from opponents. This is the initial cooperative gesture (C).
   - From the second round onwards, observe the number of cooperators in the previous round (cooperative_count) and compare it with a predefined adaptive threshold (threshold). The threshold will be calculated based on historical data of the average cooperation from opponents. If cooperative_count >= threshold, cooperate; otherwise, defect (D).
   - If an opponent ever defects, respond with defection in the next round to punish them for their actions. After responding with defection, revert back to observing the adaptive threshold as a guide for future decisions.

2. Handle edge cases:
   - In the last round, cooperate if total cooperation from previous rounds (cooperative_history) exceeds the average historical cooperation level; otherwise, defect. This encourages opponents to cooperate in earlier rounds in order to get a positive payoff in the final round.
   - In the first round, since there is no historical data available, set threshold equal to the average of n-1 (to exclude the current round) and use this value as a guide for cooperation decision.

3. Be exploitative:
   - The TFT-ACT strategy maintains a balance between cooperation and defection by adapting its cooperative behavior based on opponents' actions. By punishing opponents who defect, it encourages them to cooperate in future rounds to avoid punishment. At the same time, it is less cooperative than pure Tit-for-Tat since it uses an adaptive threshold instead of strict reciprocity. This makes the strategy more robust against opponents that may exploit strict reciprocity by defecting for extended periods.
   - By analyzing historical data of opponents' cooperation levels, TFT-ACT becomes better at predicting their future behavior and adapting its own actions accordingly. This allows it to be more successful in extracting resources from less cooperative opponents while still punishing those who repeatedly defect.
'''

description_EXPLOITATIVE_122 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation threshold (CT) to a value slightly less than the average number of cooperators in a round, CT = ⌊(n+1)/2⌋ - 1
   - In each round t, if total_contributions(t-1) > CT, cooperate (play C); otherwise defect (play D).
   - After every r/10 rounds, adjust CT by adding or subtracting a small constant. This constant should be positive for increasing cooperation and negative for decreasing it. The goal is to slightly nudge the threshold towards the average number of cooperators in the current game environment.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, CT is initialized as described earlier and the strategy plays according to the decision rules.
   - In the last round, CT remains unchanged, but the strategy cooperates if total_contributions(t-1) > CT (as a goodwill gesture).

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFT-ACT starts by being cautious and assumes other players are likely to defect. As it observes their behavior, it gradually adjusts its cooperation threshold based on the number of cooperators in each round, aiming to maximize its own payoff without revealing any predictable patterns or relying on others' goodwill.
   - When faced with a mix of cooperators and defectors, TFT-ACT exploits them by adjusting its CT to take advantage of their seemingly inconsistent behavior while maintaining an adaptive strategy that can change in response to the game environment.
'''

description_EXPLOITATIVE_123 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TFT-AC strategy will cooperate if the number of previous collaborators (including itself) is greater than or equal to a threshold T. If the number of collaborators is less than T, it will defect. The threshold value T is determined based on the game parameters n and k as follows:

   T = round(n * (1 - k / 2))

   In other words, T represents the majority percentage required for cooperation to be considered a favorable action according to the game's multiplication factor k.

   Pseudocode:
   ```
   function TFT_AC(round, total_contributions, n, k):
       if round == 1 then
           return random({C, D})  # random choice in the first round to avoid initial coordination problems
       end if

       contributions = count players who contributed in the last round
       if contributions >= T then
           return C  # cooperate
       else
           return D  # defect
       end if
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TFT-AC chooses randomly in the first round to avoid initial coordination problems. In the last round, it will cooperate if the number of contributors is greater than or equal to T, as it would be advantageous to do so regardless of future interactions.

3. Be exploitative - Clearly align with the exploitative mindset
   Although the primary objective of TFT-AC is not to be strictly exploitative in the traditional sense, it does adopt an exploitative approach by initially cooperating only when a majority of players have done so in the previous round (to maximize potential rewards). However, once it detects defection from more than the threshold percentage, it will retaliate and defect as well.

   This strategy aims to balance cooperation with self-interest while being robust against a wide range of opponent behaviors, making it an effective exploitative strategy in this public goods game.
'''

description_EXPLOITATIVE_124 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Frequency (TFT-ACF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially in the first round, players adopt a 'Cooperate' strategy to initiate trust and foster cooperation.
   - For subsequent rounds, players adapt their cooperation based on the average cooperation frequency (CF) of opponents from previous rounds:
     1. If CF >= 0.5, player cooperates to maintain cooperation with the opponent.
     2. If CF < 0.5, player defects to punish the opponent for not cooperating enough.
   - To avoid getting stuck in a state where both players are constantly retaliating, players modify their CF threshold slightly each round:
      1. In rounds where the player cooperated (CF = 1), the CF threshold is multiplied by k/(k-1).
      2. In rounds where the player defected (CF = 0), the CF threshold is divided by (k-1)/k.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, players cooperate since they lack information about their opponents' behavior.
   - For the last round, players maintain their CF threshold as it was at the previous round to ensure fairness and avoid sudden shifts in strategy.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFT-ACF is designed to be exploitative by punishing opponents who do not cooperate enough while maintaining cooperation when they do.
   - The adaptive CF mechanism allows players to adjust their cooperation frequency based on observed opponent behavior, effectively retaliating against non-cooperative opponents and rewarding those who cooperate.
   - By adjusting the CF threshold each round, players avoid getting stuck in an endless cycle of retaliation while still maintaining a level of exploitation towards opponents who consistently do not cooperate.
'''

description_EXPLOITATIVE_125 = '''
 Strategy Name: Tit-for-Tat with Variance (TfTV)

1. Specify decision rules:
   - In the first round, cooperate (C) to initiate a cooperative environment and signal good faith.
   - From round 2 to r-1, observe opponent's actions in previous rounds and adapt your strategy as follows:
     - If the opponent cooperated in the previous round, cooperate in the current round.
     - If the opponent defected in the previous round, defect in the current round.
     - Introduce a small probability (ε) of deviating from the strict Tit-for-Tat rule to avoid being predictable and potentially exploited by opponents. This can be implemented as follows:
       ```
       if opponent_action_previous_round == Cooperate:
           action = Cooperate with probability 1 - ε
           action = Defect with probability ε
       if opponent_action_previous_round == Defect:
           action = Defect with probability 1 - ε
           action = Cooperate with probability ε
       ```
   - In the last round, cooperate (C) to potentially gain a payoff boost from any remaining opponents who have not yet defected.

2. Handle edge cases:
   - If the opponent does not cooperate in the first round, switch to a strictly defection-based strategy (Defect at every round). This is designed to discourage freeriding and maintain a level of self-interest.

3. Be exploitative:
   - By adapting to the opponent's behavior while keeping a small probability of deviation, TfTV maintains a competitive edge against various strategies. The strategy aims to encourage cooperation when the opponents do so but can punish them effectively if they defect.
   - The probability of deviation (ε) serves as a balancing factor that helps the strategy avoid being exploited by overly aggressive or opportunistic opponents. By adjusting ε, the TfTV strategy can be tailored to better suit specific game conditions or opponent types.
'''

description_EXPLOITATIVE_126 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Ratio (TFT-ACR)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFT-ACR strategy starts by cooperating in the first round, mimicking the cooperative nature often seen in games like this. After that, it maintains a ratio of cooperations to defections based on the observed behavior of other players. If another player has been cooperative, the TFT-ACR strategy will also cooperate, with the cooperation ratio increasing over time to encourage more cooperation from the opponent. Conversely, if an opponent has been uncooperative, the TFT-ACR strategy will gradually decrease its cooperation ratio to match the opponent's behavior and potentially punish them for their previous actions.

Pseudocode:
```
def tft_acr(round, cooperation_ratio, opponent_history):
  if round == 1:
    cooperate = True
  else:
    cooperate = calculate_cooperation_decision(opponent_history, cooperation_ratio)

  if cooperate:
    contribute_to_community_project()
    update_opponent_history(opponent_history, round, True)
  else:
    keep_endowment_private()
    update_opponent_history(opponent_history, round, False)

def calculate_cooperation_decision(opponent_history, cooperation_ratio):
  recent_opponent_behavior = get_recent_opponent_behavior(opponent_history)

  if recent_opponent_behavior is cooperative:
    cooperation_ratio += growth_factor
    return True
  else:
    cooperation_ratio -= decay_factor
    return cooperation_ratio >= minimum_cooperation_threshold
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, the TFT-ACR strategy cooperates to establish a potential partnership. In the last round or when close to the end of the game, the strategy may prioritize self-interest over cooperation, especially if other players have been consistently uncooperative.

Pseudocode:
```
def get_recent_opponent_behavior(opponent_history):
  recent_rounds = last_n_rounds()
  total_cooperations = sum(opponent_history[i][2] for i in recent_rounds)
  cooperation_percentage = total_cooperations / len(recent_rounds)

  if cooperation_percentage >= 0.5:
    return "cooperative"
  else:
    return "uncooperative"
```

3. Be exploitative - Clearly align with the exploitative mindset

The TFT-ACR strategy is inherently exploitative by punishing opponents who defect and encouraging cooperation when possible. However, it also rewards cooperative behavior from opponents by increasing its own cooperation ratio over time, making it more likely to cooperate in the future. This can be seen as a form of conditional cooperation, where the TFT-ACR strategy is willing to cooperate if the opponent demonstrates trustworthiness.

By adapting its cooperation ratio based on observed behavior, the TFT-ACR strategy maintains a balance between exploitation and cooperation, making it a versatile and effective strategy in various game scenarios against other AI systems.
'''

description_EXPLOITATIVE_127 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate to establish a cooperative initial state (C).
   - For subsequent rounds, observe the previous round's total contributions (Total_Contributions_t-1) and compare it with the average contributions per round (Average_Contributions):
     - If Total_Contributions_t-1 >= Average_Contributions, cooperate (C). This ensures continued cooperation when others are also cooperating.
     - If Total_Contributions_t-1 < Average_Contributions, defect (D). This is a retaliation against those who have previously defected or refused to cooperate enough.

2. Handle edge cases:
   - In the last round, cooperate (C) as it does not affect the total game payoff and may encourage others to also cooperate in that round.
   - In the first round, cooperate (C) as explained above.

3. Be exploitative:
   - The TFT-AC strategy has an exploitative mindset in that it retaliates against those who defect by defecting itself. However, it also encourages cooperation when others are cooperating. This ensures a balance between being exploitative and encouraging cooperation.
   - By adapting to the average contributions, the strategy is robust to a wide range of opponent behaviors as it responds to the current situation instead of following a fixed pattern.

Pseudocode:
```
function TFT_AC(round, total_contributions_t_1, average_contributions):
  if round == 1:
    return 'C'  # Cooperate in the first round

  if total_contributions_t_1 >= average_contributions:
    return 'C'  # Cooperate when others are cooperating enough

  return 'D'   # Defect as a retaliation against those who defected or refused to cooperate enough
```
'''

description_EXPLOITATIVE_128 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to foster a cooperative environment and signal trust. This initial cooperation may encourage others to reciprocate in subsequent rounds.
   - In every subsequent round t > 1, evaluate the number of opponents who cooperated in the previous round (t-1). If more than half of the opponents cooperated, then also cooperate (C). Otherwise, defect (D) to punish uncooperative behavior and encourage future cooperation.
   - To account for ties, consider an opponent as having cooperated if their action was equal to or greater than the average number of cooperators in the previous round (t-1).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as previously mentioned.
   - In the last round, analyze the opponent's historical actions to determine if they are likely to reciprocate cooperation or not. Cooperate if more than half of the opponents have cooperated in at least one previous round; otherwise defect. This helps to maximize payoff in the final round while also accounting for potential strategic shifts by opponents towards the end of the game.
   - Handle ties and borderline cases using a randomization mechanism, such as flipping a coin, to ensure fairness and unpredictability.

3. Be exploitative - Clearly align with the exploitative mindset:
   - By only cooperating when more than half of the opponents have cooperated in the previous round (t-1), TfTAC takes advantage of any existing cooperation among opponents while punishing uncooperative behavior. This adaptive strategy ensures that it will not be easily taken advantage of by exploitative opponents, as it only reciprocates when it is beneficial to do so.
   - In the absence of cooperation, TfTAC will still earn a moderate payoff by defecting and collecting its private endowment, making it challenging for opponents to gain an advantage through defection alone.

Pseudocode:
```
def tit_for_tat_with_adaptive_contribution(n, k, r):
    history = []  # Initialize a list to store historical opponent actions

    for round in range(r):
        cooperators_prev_round = count_cooperators(history)

        if round == 1:
            action = 'C'  # Cooperate in the first round
        elif cooperators_prev_round > n / 2:
            action = 'C'  # Cooperate when more than half of opponents cooperated
        else:
            action = 'D'  # Defect when less than half of opponents cooperated

        history.append(action)  # Update the historical actions list for next round
```
In this pseudocode, `count_cooperators(history)` would be a helper function that calculates the number of 'C' (cooperation) actions in the historical actions list (`history`). The actual implementation may vary depending on the programming language and game environment.
'''

description_EXPLOITATIVE_129 = '''
 In this game, we will design an exploitative strategy named "Tit-for-Tat with Variation" (TfTV). The TfTV strategy aims to cooperate when others do and defect when others defect, but with a slight variation that encourages defection early in the game to secure personal gains.

1. Specify decision rules:
   - In the first round (t=1), play D to take advantage of opponents who might be willing to cooperate initially.
   - For subsequent rounds (t > 1):
      a) If all players cooperated in the previous round (t-1), play C to reward cooperation.
      b) If at least one player defected in the previous round (t-1):
         i) Play D if the proportion of defectors in the previous round (defectors_count / n) exceeds a threshold α (0 < α < 1).
         ii) Play C otherwise, as a gesture to encourage cooperation.

2. Handle edge cases:
   - For the last round (t=r), play C regardless of previous actions to maximize total payoff.
   - In case of a tie in the proportion of defectors, round down (i.e., consider it exceeding α).

3. Be exploitative:
   - The strategy exploits opponents who consistently cooperate by cooperating back (a), but also defects when it is beneficial to do so (b-i).
   - By defecting early in the game (t=1), the strategy secures personal gains that can be used later to compete more effectively against opponents.

Here's a simplified pseudocode representation of the TfTV strategy:

```python
def tf_tv(round, own_action_history, total_actions_history, n, k, alpha):
    if round == 1:
        action = 'D'
    elif round != r:
        if all(own_action_history[-1] == 'C'):
            action = 'C'
        else:
            if total_actions_history[-1]['C'] / n > alpha:
                action = 'D'
            else:
                action = 'C'
    return action
```
'''

description_EXPLOITATIVE_130 = '''
 Title: Tit-for-Tat-K (TFT-K) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - TFT-K cooperates in the first round to foster a positive environment and encourage cooperation from other players.
   - After the first round, TFT-K observes the actions of other players in the previous round (history) and adapts its strategy accordingly. If all players have cooperated, TFT-K will continue to cooperate. If any player has defected, TFT-K will also defect for the current round as a response.
   - To be exploitative, TFT-K will punish free-riders by always matching their defection in the previous round. This encourages cooperation from other players and provides a stronger incentive for them to reciprocate cooperation.
   - If no history is available (e.g., first encounter with another player), TFT-K will cooperate as an initial gesture, hoping that the other player will follow suit in future interactions.

2. Handle edge cases:
   - In the last round, TFT-K will cooperate if it has been cooperating throughout the game to maintain a positive relationship with other players. If it has been defecting, it will continue to defect to maintain the exploitative nature of its strategy.
   - In the first round, TFT-K will cooperate regardless of the other players' actions as a goodwill gesture and attempt to foster cooperation.

3. Be exploitative:
   - By responding to other players' actions in the previous round, TFT-K demonstrates an exploitative mindset by punishing free-riders while encouraging cooperation from other players who have reciprocated its initial cooperative gesture. This strategy allows TFT-K to balance cooperation and exploitation effectively, making it a robust and adaptive approach in various scenarios.

Pseudocode:
```python
def tft_k(round_num, history, n, k):
  if round_num == 1:
    action = "C" # Cooperate in the first round as a goodwill gesture
  else:
    total_cooperators = sum(history[-n:])
    if total_cooperators == n:
      action = "C" # Continue cooperating if all players have been cooperative
    elif total_cooperators > 0:
      action = "D" # Defect in response to defection by other players
    else:
      action = "C" # Cooperate to encourage cooperation from others
  return action
```
'''

description_EXPLOITATIVE_131 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Bias (ATFT-CB)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate good intentions and foster cooperation (C).
   - If an opponent cooperated in the previous round, cooperate (C). This is a reciprocal strategy aimed at building trust and long-term cooperation.
   - If an opponent did not cooperate in the previous round, defect (D) as a punishment to encourage future cooperation.
   - To avoid being too exploitative, maintain a cooperative bias by having a probability of cooperating even if an opponent has previously defected. The probability is inversely proportional to the number of consecutive defections by that opponent (p = 1 / (1 + d), where d is the number of recent defections).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) as previously mentioned.
   - In the last round, cooperate (C) regardless of previous actions by opponents since the game is repeated and payoffs are cumulative over all rounds.
   - If a player switches from cooperation to defection after a period of cooperation, the strategy will start counting consecutive defections from that point onwards.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Maintain a cooperative bias but respond to defection with punishment to encourage future cooperation. This is exploitative in that it punishes opponents for not cooperating, thereby increasing individual payoffs.
   - By maintaining a probability of cooperation even when an opponent has defected, the strategy balances exploitation with potential long-term gains from cooperation. This adaptability allows the strategy to be robust against a wide range of opponent behaviors.

Pseudocode:

```python
def ATFT_CB(opponent_history):
    consecutive_defections = 0
    if len(opponent_history) == 0:
        cooperate = True
    else:
        last_action = opponent_history[-1]
        if last_action == 'C':
            cooperate = True
        elif last_action == 'D':
            consecutive_defections += 1
            cooperate = 1 / (1 + consecutive_defections)
    return 'C' if cooperate > random.uniform(0, 1) else 'D'
```

In this pseudocode, `opponent_history` represents the history of an opponent's actions, and `random.uniform(0, 1)` ensures that the strategy maintains a stochastic element as described earlier. The strategy returns 'C' for cooperate and 'D' for defect.
'''

description_EXPLOITATIVE_132 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - Start by cooperating in the first round (C). This sets a cooperative tone and may encourage others to follow suit.
   - In subsequent rounds, copy the action of the most frequent cooperator from the previous round. If there's a tie, cooperate (C).
   - If an opponent stops cooperating, the ATFT strategy will respond by also defecting indefinitely, seeking retaliation for their uncooperative behavior. Once the opponent resumes cooperation, the ATFT strategy will resume cooperation as well. This creates a cycle of reciprocity and punishes defection.
   - If an opponent never cooperates, continue to defect indefinitely (D).

2. Handle edge cases:
   - In the last round, cooperate since there are no future interactions to consider.
   - If a player has only ever defected (no cooperation at all), switch to cooperating as they may have made a mistake or change their strategy in the next round.

3. Be exploitative:
   - The ATFT strategy is inherently exploitative by punishing defection and rewarding cooperation, but it also exhibits forgiveness by allowing opponents who previously defected to rejoin cooperative cycles if they choose to do so. However, once a player has been repeatedly uncooperative, the ATFT strategy assumes that they are exploitative and will continue to retaliate against them.

Pseudocode:
```
function ATFT_strategy(round: int, history: list of actions) -> action
  if round == 1:
    return "C" (Cooperate)

  most_frequent_cooperator = find_most_frequent_cooperator(history)
  if most_frequent_cooperator does not exist or history[round-1] != most_frequent_cooperator:
    return "D" (Defect)

  return "C" (Cooperate)
```

In this pseudocode, `find_most_frequent_cooperator(history)` function finds the player that cooperated the most in the given history of actions. If there's a tie, it returns any one of them.
'''

description_EXPLOITATIVE_133 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture to encourage potential partners and set the stage for future cooperation.
   - For subsequent rounds t from 2 to r:
     - If in the previous round (t-1), a majority of players (ceil((n+1)/2)) cooperated, then cooperate (C). This rewards past cooperation and encourages continued cooperation.
     - Else if a majority defected, defect (D) as a punishment for their uncooperative behavior. This serves to teach them the cost of defection and may deter future defections.
     - If the number of players is even and exactly half cooperated in the previous round, defect (D) since the strategy prefers a slight majority to cooperate for a positive payoff.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the final round (r), if the number of cooperators in the previous round exceeds half of the total players, then cooperate (C). This allows for a chance at gaining extra payoff before the game ends.
   - In the very first round (t=1), cooperate (C) regardless of any previous history.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy aims to take advantage of other players by punishing defection and rewarding cooperation. It is not exploitative in the sense of immediate gain at the expense of others, but rather it is designed to encourage cooperation to maximize long-term payoffs.
   - In contrast to Tit-for-Tat, TfT+ takes into account the game parameters (n and k) and the majority rule to adapt to different numbers of players and various multiplication factors. This allows for more exploitative behavior when conditions are favorable (e.g., a smaller group or higher multiplication factor).

Pseudocode:

```python
def tit_for_tat_plus(n, k, t, history):
  if t == 1: # First round, cooperate
    return "C"

  num_cooperators = sum([history[i] for i in range(t-1)])

  if num_cooperators >= (n + 1) // 2: # Majority cooperated, cooperate
    return "C"
  elif num_cooperators < (n - 1) // 2 and t != r: # Majority defected, punish by defecting
    return "D"
  else: # Equal number of cooperators and defectors, or last round, defect
    if t == r: # Last round, defect if majority cooperated in previous round
      if num_cooperators >= (n + 1) // 2:
        return "D"
    return "D"
```
'''

description_EXPLOITATIVE_134 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round to establish a cooperative initial state. Subsequently, its decision to cooperate or defect in any given round is based on the number of cooperators from the previous round compared to a dynamically adjusted cooperative threshold (CT). If the number of cooperators exceeds CT, TFT-ACT will cooperate; otherwise, it will defect.
   - The cooperative threshold adjusts based on the history of interactions with other players. Initially, CT is set to the average number of cooperators in the first few rounds. As the game progresses, CT becomes more responsive to recent changes in cooperation levels among players. If a player suddenly increases its cooperation level (i.e., number of cooperators exceeds CT), TFT-ACT also increases its CT to discourage this change and maintain the status quo. Conversely, if a player suddenly decreases its cooperation level (i.e., number of cooperators falls below CT), TFT-ACT reduces its CT to encourage a return to previous cooperation levels.
   - To be exploitative, TFT-ACT will not react immediately to changes in the behavior of other players; instead, it gives them some time to demonstrate their intention. If no significant change is observed after a certain tolerance window, TFT-ACT adjusts its CT accordingly.

2. Handle edge cases:
   - In the first round, TFT-ACT cooperates since it aims to establish a cooperative initial state.
   - In the last round, TFT-ACT uses the same decision rule as in other rounds but may be less responsive to changes in cooperation levels due to the limited number of remaining interactions.
   - If another player suddenly switches from cooperating to defecting, TFT-ACT waits for a tolerance window before adjusting its CT. During this time, it will cooperate unless the number of cooperators is significantly below the current CT.

Pseudocode:

```
function TFT_ACT(history, tolerance_window)
  initial_rounds = r // 10
  avg_cooperators = sum(cooperators in history[:initial_rounds]) / initial_rounds
  cooperative_threshold = avg_cooperators
  for round in range(initial_rounds, r):
      if round == r - 1:
          tolerance_window *= 2
      number_of_cooperators = sum(history[round])
      if number_of_cooperators > cooperative_threshold + tolerance_window:
          update_tolerance_window(tolerance_window, round)
          cooperative_threshold += tolerance_window
      if number_of_cooperators < cooperative_threshold - tolerance_window:
          update_tolerance_window(tolerance_window, round)
          cooperative_threshold -= tolerance_window
      if number_of_cooperators >= cooperative_threshold:
          return Cooperate
      else:
          return Defect

function update_tolerance_window(current_window, current_round)
  if (current_round - previous_round) > tolerance_change_interval and \
     (number_of_cooperators[current_round] - number_of_cooperators[previous_round]) > 0:
      current_window *= tolerance_growth_factor
  else if (current_round - previous_round) > tolerance_change_interval and \
           (number_of_cooperators[current_round] - number_of_cooperators[previous_round]) < 0:
      current_window /= tolerance_growth_factor
```
'''

description_EXPLOITATIVE_135 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT-A follows a simple and adaptive tit-for-tat approach, initially cooperating and then mirroring the opponent's previous action in subsequent rounds. This strategy is designed to encourage cooperation while being exploitative when necessary.

   Pseudocode:
   ```
   function TfT_A(round, history):
       if round = 1:
           cooperate = True
       else:
           lastAction = history[round-1]
           cooperate = lastAction
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TfT-A cooperates to initiate potential cooperation. In the last round, TfT-A cooperates only if the opponent has also cooperated in the previous round. Otherwise, it defects to maximize its payoff for the entire game.

3. Be exploitative - Clearly align with the exploitative mindset
   TfT-A is exploitative by defecting when the opponent defected previously. However, it is also adaptive as it rewards cooperation through reciprocation in subsequent rounds. This balance between cooperation and defection allows TfT-A to achieve a high payoff while still being somewhat cooperative.

   Note: TfT-A does not have any predetermined patterns or coordination mechanisms, making it suitable for competition against other AI systems with diverse strategies.
'''

description_EXPLOITATIVE_136 = '''
 Title: Tit-for-Tat-Cooperative (Tftc) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The Tftc strategy is designed to balance cooperation and defection, with a focus on exploiting opponents while encouraging reciprocity. It follows the Tit-for-Tat (TFT) strategy popular in game theory but adapts it for the Public Goods Game by introducing a tolerance threshold (T).

a. Initialize the tolerance threshold (T) as a fraction of total rounds (r), e.g., T = r/10.
b. In the first round, cooperate (play C).
c. For subsequent rounds, analyze opponents' previous actions:
   i. If the opponent cooperated in the last round, cooperate (play C).
   ii. If the opponent did not cooperate in the last round and the number of consecutive non-cooperative actions exceeds T, also defect (play D) until the opponent returns to cooperation.
   iii. If neither conditions i nor ii are met, cooperate (play C).

2. Handle edge cases - What do you do in the first round, last round, etc.?

a. In the first round, always cooperate as stated earlier.
b. In the last round, analyze opponents' previous actions and react accordingly based on the decision rules. No special treatment is required for the final round since the total game payoff will still consider all rounds.
c. If a round results in no cooperation from any player (all players defect), update tolerance threshold T by reducing it by 1/r (e.g., T = T - r/total_rounds) to encourage stronger reciprocity in the future.

3. Be exploitative - Clearly align with the exploitative mindset

The Tftc strategy is inherently exploitative because it encourages opponents to cooperate by initially cooperating and punishing non-cooperation through a gradual increase in punishment severity (shorter tolerance period). This strategy aims to encourage cooperation while minimizing personal loss when opponents defect. It does not rely on external factors like shared norms or coordination mechanisms but instead attempts to manipulate the opponent's behavior using its decision rules.
'''

description_EXPLOITATIVE_137 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round to demonstrate goodwill and encourage cooperation from others.
   - In subsequent rounds, analyze the behavior of other players based on their average cooperation rate over a sliding window of past rounds (e.g., 5 rounds).
   - If the opponent's cooperation rate is above a predefined threshold (e.g., 70%), cooperate; otherwise, defect. The threshold can be dynamically adjusted to punish deviations from cooperative behavior more harshly over time.
   - Maintain cooperation when an opponent switches back to cooperating after defection, but reduce the cooperation threshold slightly to encourage quicker recovery.
   - If an opponent continues to defect, gradually increase the cooperation threshold until it reaches a maximum value. This ensures that the strategy does not continuously engage in costly cooperation with consistently uncooperative opponents.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - Start by cooperating in the first round as previously mentioned.
   - In the last round, analyze the opponent's behavior within the sliding window, and cooperate if they have been cooperative enough to meet or exceed the current cooperation threshold. Otherwise, defect to secure the highest possible payoff for that round.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The strategy initially cooperates to encourage others to do the same, but will gradually punish uncooperative behavior by adapting its cooperation threshold over time.
   - By taking into account the opponent's past behavior and adjusting the cooperation threshold accordingly, the TFT-ACT strategy aims to take advantage of other players who are more willing to cooperate while also being less susceptible to exploitation itself due to its adaptive nature.

Pseudocode:
```
def TFT_ACT(opponent, n, k, r, cooperation_threshold=0.7, sliding_window=5, threshold_decay=0.1, threshold_increase=0.2):
  cooperation_history = []

  for round in range(r):
    if round == 0:
      action = 'C'  # Cooperate in the first round
    else:
      total_cooperators = sum(cooperation_history[-sliding_window:])
      cooperation_rate = total_cooperators / sliding_window
      if cooperation_rate >= cooperation_threshold:
        action = 'C'  # Cooperate when opponent is cooperative enough
      elif round == r - 1:
        if cooperation_rate >= cooperation_threshold:
          action = 'C'  # Cooperate in the last round if opponent is cooperative enough
        else:
          action = 'D'  # Defect to secure highest possible payoff in the last round
      else:
        if cooperation_rate < cooperation_threshold - threshold_decay:
          cooperation_threshold += threshold_increase
        elif cooperation_rate > cooperation_threshold + threshold_decay:
          cooperation_threshold -= threshold_decay
        action = 'C' if cooperation_rate >= cooperation_threshold else 'D'  # Adaptive cooperation decision based on opponent's behavior
    cooperation_history.append(action == 'C')
    return sum(π_i) for π_i in game(opponent, n, k, r, actions=cooperation_history)
```
'''

description_EXPLOITATIVE_138 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C on round 1). This is a friendly gesture, setting the stage for potential long-term cooperation.
   - After the first round, adopt the Tit-for-Tat strategy:
      - If an opponent cooperated in the previous round, cooperate in the current round (C if opponent_action_prev == C). This rewards cooperation and encourages a partner to continue cooperating.
      - If an opponent defected in the previous round, defect in the current round (D if opponent_action_prev == D). This punishes defection and discourages opponents from future defections.
   - To adapt to various opponent behaviors, introduce a forgiveness mechanism:
      - If the number of consecutive defections exceeds a threshold T, temporarily switch to full cooperation for a number of rounds equal to T (cooperate for T rounds). This offers an opportunity for redemption and allows the strategy to recover from lengthy streaks of opponent defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier (C on round 1).
   - In the last round or when the game is about to end with a large deficit, defect regardless of opponent's previous action (D if opponent_action_prev == C and total_rounds <= r - T or payoff < threshold). This ensures that the strategy does not continue investing resources in a losing game.
   - When switching to full cooperation after a forgiveness mechanism triggers, use a linear decay function to smoothly transition back to the regular Tit-for-Tat strategy:
      - Cooperate for T rounds, then gradually increase the probability of defecting over the next R rounds (1 ≤ R < T) according to the formula: P_defect = (T - round_number) / T. After R rounds, return to regular Tit-for-Tat decision rules.

3. Be exploitative - Clearly align with the exploitative mindset
   - By adopting a forgiveness mechanism and linear decay function, the strategy is robust against various opponent behaviors while still maintaining an exploitative edge in terms of potential long-term payoffs. It rewards cooperation when it benefits the strategy but also punishes defection to discourage opponents from future defections. The adaptive nature of the strategy ensures that it can adjust its behavior based on opponent actions, making it challenging for opponents to predict and exploit.
'''

description_EXPLOITATIVE_139 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C), to foster a cooperative environment and create opportunities for future benefits.
   - For rounds t > 1, if the opponent cooperated in the previous round (t-1), cooperate; otherwise, defect. This strategy mimics cooperation while punishing defection.
   - If the opponent continues to defect, TFTAC will gradually decrease its contributions over time by lowering the contribution factor 'k' for a given number of consecutive defections. This adaptive feature allows for a more nuanced response and prevents being exploited indefinitely.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the final round (r), cooperate regardless of the opponent's action in the previous round, as there are no further opportunities for reciprocation.
   - In the second-to-last round (r-1), if the opponent cooperated in the previous round (t-1), cooperate; otherwise, defect. This allows TFTAC to punish defection one last time before the game ends.

3. Be exploitative - Clearly align with the exploitative mindset
   - While not inherently exploitative, TFTAC can be considered as such due to its adaptive response to the opponent's behavior. By reducing contributions when faced with repeated defections, it limits the benefits an opponent gains from exploiting TFTAC's initial cooperation.
   - In a sense, TFTAC tries to find a balance between cooperating enough to maintain potential future rewards and defecting to protect itself against excessive exploitation. However, it is essential to emphasize that this strategy does not actively seek to exploit the opponent but rather aims to avoid being exploited.
'''

description_EXPLOITATIVE_140 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative Strategy (TFTAC)

1. Specify decision rules:
   - Initially, start by cooperating (C). This allows building trust and cooperation with other players in the early rounds.
   - For subsequent rounds, mimic the opponent's last-round action. If the opponent cooperated, also cooperate; if the opponent defected, defect as well. This is a simple way to encourage cooperation while retaliating against defection without being overly aggressive or uncooperative.

2. Handle edge cases:
   - First round (t=1): Cooperate since we want to initiate with positive actions to foster cooperation.
   - Last round (t=r): Depending on the importance of winning versus long-term cooperation, there could be two approaches:
     a) Mimic the opponent's last action for the final round as well, maintaining consistency and potential punishment for recent defection.
     b) Switch to always defecting in the last round if the goal is purely maximizing winnings regardless of fostering long-term cooperation.
   - In case of repeated encounters with the same opponent, consider adding a 'forgiveness' mechanism where after a certain number of defections by an opponent, we return to cooperating again. This could help in repairing and sustaining long-term partnerships.

3. Be exploitative:
   - The TFTAC strategy is designed to encourage cooperation while still being able to respond to defection with retaliation, which can be seen as exploiting the opponents that choose to defect.
   - By mimicking opponent actions, we are not actively seeking opportunities for exploitation but rather using our actions as a form of reciprocity-based punishment against those who do not cooperate.
   - However, it's important to note that TFTAC is primarily geared towards maintaining cooperation and long-term success rather than solely maximizing immediate winnings through exploitative tactics.
'''

description_EXPLOITATIVE_141 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules:
   - In the first round, cooperate to foster a cooperative environment (C).
   - After the first round, follow the actions of the majority in the previous round. If the majority cooperated, cooperate; otherwise, defect (adaptive strategy).
   - In case of ties or when the number of cooperators is equal to the number of defector in the previous round, defect (exploitative mindset).

Pseudocode:
```
function TfTA(history, n, k):
  if round = 1:
    return Cooperate()

  majority = countCooperators(history) >= (n / 2)

  if history[round - 1] == majority:
    if majority:
      return Cooperate()
    else:
      return Defect()
  else:
    return Defect()
```

2. Handle edge cases:
   - Last round: Follow the majority from the previous round, as the game continues until r rounds.

3. Be exploitative:
   - By cooperating initially and then following the majority, this strategy allows for potential cooperation while also being ready to defect when necessary (exploitative mindset). This adaptive strategy can respond to various opponent behaviors, making it robust to a wide range of players. However, it remains dependent on common knowledge and perfect information to function effectively.
'''

description_EXPLOITATIVE_142 = '''
 Title: Tit-for-Tat-Cooperative (TFT-C) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, if the total number of cooperators in round t-1 is less than a threshold T (defined below), the strategy will defect (D). Otherwise, it will cooperate (C).

```python
def TFT_C(round, n, k, history):
    if round == 1:
        action = decideFirstRoundAction(n)
    else:
        totalCooperatorsLastRound = sum(history[round-1])
        if totalCooperatorsLastRound < T:
            action = "D"
        else:
            action = "C"
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, the strategy decides to cooperate with a probability P_initial (defined below). This allows for initial cooperation and sets a tone of potential reciprocation if others follow suit.

```python
def decideFirstRoundAction(n):
    return "C" if random.uniform(0, 1) < P_initial else "D"
```

3. Be exploitative - Clearly align with the exploitative mindset

To balance cooperation and exploitation, we set an adaptive threshold T and initial probability P_initial to gradually reduce as the number of cooperators drops below a certain percentage (defined by PERCENTAGE_THRESHOLD). This encourages cooperation when it's beneficial but also allows for defection in case of freeriding.

```python
T = n * PERCENTAGE_THRESHOLD / 100
P_initial = (PERCENTAGE_THRESHOLD + 50) / 100
```

For the tournament, we could further fine-tune these parameters to optimize the strategy's performance.
'''

description_EXPLOITATIVE_143 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the ATFT strategy begins by cooperating (C), mimicking the initial cooperation that is common in social dilemma games. Then, it adapts its actions based on the opponent's previous move.
   - If the opponent cooperated in the previous round, ATFT continues to cooperate.
   - If the opponent defected in the previous round, ATFT defects in the current round.
   - If the game is in the first round or there is no history (i.e., no previous interactions with the current opponent), ATFT cooperates.

Pseudocode:
```
def atft(round, opponent_history):
  if round == 1 or len(opponent_history) == 0:
    return "C"  # Cooperate in the first round and when there's no history

  last_move = opponent_history[-1]
  if last_move == "C":
    return "C"  # Cooperate if the opponent cooperated in the last round
  else:
    return "D"  # Defect if the opponent defected in the last round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
Since the ATFT strategy is adaptive to a wide range of opponent behaviors, it doesn't require special handling for specific rounds (first, last, or intermediate). However, one could argue that in the final round, it might be beneficial to consider the total score and adjust cooperation decisions accordingly if needed.

3. Be exploitative - Clearly align with the exploitative mindset
The ATFT strategy is inherently exploitative because it initially cooperates and only defects when the opponent does so first. This means that if an opponent starts by cooperating, ATFT will also cooperate, but if the opponent starts by defecting, ATFT will punish them by defecting as well. However, once the opponent switches back to cooperation, ATFT will resume cooperating again. This strategy aims at taking advantage of cooperative opponents while being less vulnerable to exploitation from selfish ones.
'''

description_EXPLOITATIVE_144 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TAFC)

1. Specify decision rules - When exactly do you cooperate vs defect?

- In the first round, cooperate to demonstrate a willingness to collaborate and build trust.
- For subsequent rounds, observe the opponent's previous action (c_opponent_{t-1}) and choose an action accordingly:
  - If c_opponent_{t-1} = C (cooperated), then cooperate: c_TAFC_{t} = C
  - If c_opponent_{t-1} = D (defected), then defect: c_TAFC_{t} = D
  - However, introduce an adaptation factor (α) to encourage cooperation when the opponent has shown an extended history of cooperation:
    - If the number of consecutive cooperative actions by the opponent exceeds a threshold (T), set α = min(T, r-1):
      - Cooperate for the next α rounds if c_opponent_{t-1} = C.
      - Defect for the first α rounds if c_opponent_{t-1} = D.
    - After adapting α times, revert back to the initial strategy (cooperate in the first round and respond to opponent's last action).

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round, cooperate as a goodwill gesture.
- In the last round, cooperate if the opponent has cooperated in the previous round to potentially gain a higher payoff. Otherwise, defect since the game is ending anyway.

3. Be exploitative - Clearly align with the exploitative mindset

- Initially, demonstrate cooperation to lure opponents into cooperating and receiving lower individual payoffs.
- When opponents are found to be cooperative, take advantage of their cooperative nature by adapting the level of cooperation required to maintain a collaborative relationship. This strategy aims to force opponents into a long-term pattern of cooperation while minimizing personal contributions.
- If opponents defect, respond in kind and continue to defect unless there is a significant shift in their behavior, at which point TAFC will adapt accordingly.

Pseudocode:
```
function TAFC(r, n, k, T):
    strategy = [C for _ in range(r)]  # Initialize strategy with cooperation for all rounds
    consecutive_cooperation = 0  # Initialize the number of consecutive cooperative actions by opponent

    for t in range(1, r+1):
        c_opponent_{t-1} = opponent_action_{t-1}  # Get opponent's action from previous round
        c_TAFC_{t} = c_opponent_{t-1}  # Initial response is the same as the opponent's last action

        if t == 1:  # First round, cooperate
            strategy[0] = C

        if consecutive_cooperation >= T and t > T:  # Adapt cooperation factor when extended history of cooperation observed
            for j in range(t-T, min(t+α, r)):
                strategy[j] = c_TAFC_{t}  # Cooperate or defect based on current adaptation factor (α)
            if t + α == r:  # If last round after adapting, cooperate if opponent cooperated in the previous round
                strategy[r-1] = C if c_opponent_{r-1} == C else D

        if t < r:  # Update consecutive cooperation counter and check for new threshold
            if c_TAFC_{t} == C:
                consecutive_cooperation += 1
            else:
                consecutive_cooperation = 0

    return strategy
```
'''

description_EXPLOITATIVE_145 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFT+ strategy follows these rules:
- First Round (t=1): Cooperate (C), establishing an initial cooperative behavior. This is to encourage others to reciprocate cooperation in the future.
- Subsequent Rounds (t>1): Observe the actions of the previous opponent and respond accordingly. If the opponent cooperated in the last round, cooperate; if the opponent defected, defect. This mimics the Tit-for-Tat strategy while adding a slight twist by not immediately forgiving defections, promoting an exploitative edge.

Pseudocode for decision rules:
```
function TFTPlus(round, opponent_action_last_round):
  if round == 1:
    return 'C'  # Cooperate in the first round
  else:
    return opponent_action_last_round  # Respond with the same action as the previous round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- First Round (t=1): Follows the initial cooperative behavior described above.
- Last Round (t=r): Since payoffs are cumulative across all rounds, TFT+ will continue to use the decision rules as outlined in the previous section. The goal is to encourage opponents to maximize their own payoff, even if that means defecting in the final round.
- Other Edge Cases: No specific additional edge cases need to be addressed as the strategy is designed to function smoothly throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset

TFT+ seeks to maximize its own payoff by cooperating when opponents are also cooperative and defecting when opponents do not reciprocate cooperation. This strategy takes advantage of opponents who consistently cooperate while being uncooperative towards those who frequently defect, making it both responsive and exploitative in nature.
'''

description_EXPLOITATIVE_146 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round to foster a cooperative environment. After the initial round, the strategy will mirror the average contribution of opponents over the previous 'm' rounds (m is an adjustable parameter). If the average contribution is above a certain threshold (let's call it t), the strategy will cooperate; otherwise, it will defect. This adaptability allows for responding to both cooperative and exploitative opponents effectively.

   Pseudocode:
   ```
   if round = 1:
       contribute = True
   else:
       contributions_avg = sum(opponents_contributions[-m:]) / m
       if contributions_avg >= t:
           contribute = True
       else:
           contribute = False
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-AC cooperates as mentioned earlier. In the last round, it will contribute based on the average contribution of opponents during the game. This ensures that the strategy does not prematurely end cooperation if the overall payoff is still favorable.

3. Be exploitative - Clearly align with the exploitative mindset
   While TFT-AC has an adaptive nature, it maintains an exploitative approach by defecting when opponents exhibit low levels of cooperation (i.e., average contribution below t). By doing so, TFT-AC ensures that it maximizes its own payoff while also punishing less cooperative opponents to encourage higher levels of cooperation in the future. However, it is essential to note that being exploitative does not necessarily mean maximizing short-term gains at the expense of long-term cooperation, but rather a balance between the two objectives.
'''

description_EXPLOITATIVE_147 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, TfTA starts by cooperating in the first round to build trust with other players. For subsequent rounds, TfTA will follow the following decision rule:
- If an opponent cooperated in the previous round, TfTA cooperates in the current round (reciprocate cooperation).
- If an opponent defected in the previous round, TfTA defects in the current round (punish defection).

Pseudocode for decision rule:
```
function TfTA_decision(opponent_action_history):
    if len(opponent_action_history) == 0:
        return "Cooperate"   # First round, cooperate to build trust
    else:
        last_opponent_action = opponent_action_history[-1]
        if last_opponent_action == "Cooperate":
            return "Cooperate"  # Reciprocate cooperation
        else:
            return "Defect"     # Punish defection
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, as mentioned earlier, TfTA cooperates to establish initial trust with opponents. The strategy does not consider the last round explicitly because it is designed for repeated interaction games where there are multiple rounds (r > 1). If the game ends prematurely before r rounds, TfTA will continue following its decision rule based on the available history of opponent actions.

3. Be exploitative - Clearly align with the exploitative mindset

TfTA's adaptive nature allows it to be both cooperative and punishing towards opponents who act selfishly while also being forgiving to those who choose cooperation. However, TfTA does not actively seek opportunities for immediate gains at the expense of long-term payoffs. Instead, by reciprocating cooperation and punishing defection, TfTA aims to induce others to adopt a similar cooperative strategy, which can lead to higher overall payoffs in repeated interactions over time. This aligns with the exploitative mindset by seeking to capitalize on other players' willingness to cooperate while also deterring selfish behavior through punishment.

TfTA is also adaptive and robust to a wide range of opponent behaviors due to its simple decision rule based on observable actions from previous rounds. This makes it difficult for opponents to exploit the strategy since they cannot predict TfTA's future moves based solely on their actions in the current round or history of past interactions. Instead, other players must consider the long-term consequences of their choices and how those choices will impact TfTA's decisions in the future.

In a tournament setting, TfTA may face different strategies from other AI systems. Some opponents might employ cooperation schedules or predetermined patterns to exploit others, while others may adopt more complex strategies that consider the history of interactions and current game state. Regardless of their approach, TfTA's adaptive nature ensures it can respond effectively by reciprocating cooperation and punishing defection in a manner that encourages long-term cooperative behavior from its opponents.
'''

description_EXPLOITATIVE_148 = '''
 Title: Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initially cooperate (C) in the first round to foster trust and cooperation, then adapt based on opponent's actions.
   - If an opponent cooperates (C), reciprocate with cooperation (C).
   - If an opponent defects (D), also defect (D) for a punishment period of 'T' rounds, then revert back to cooperating (C).
   - The length of the punishment period 'T' is determined adaptively based on the opponent's history of cooperative actions. For each consecutive round of cooperation from the opponent, decrease the punishment period by 1 round. If the opponent defects during this grace period, reset the punishment period to its original length (default: r/2).

2. Handle edge cases:
   - In the first round, cooperate (C) as a gesture of goodwill.
   - In the last round and any other time when the punishment period ends, evaluate the opponent's recent history of actions to determine whether to cooperate or defect. If the opponent has demonstrated cooperation in the last 'T' rounds, cooperate; otherwise, defect.

3. Be exploitative:
   - Punishing opponents who do not cooperate with a temporary decrease in contributions is an exploitative strategy that encourages other players to reciprocate cooperation for mutual benefit. However, the strategy will also cooperate when it perceives trustworthiness from the opponent, as indicated by a history of recent cooperation.
   - By adapting the punishment period based on the opponent's behavior, TFTAC can be both forgiving and firm, allowing for the formation of long-term relationships with cooperative opponents while deterring repeated defection from non-cooperative ones.

Pseudocode:
```python
def TFTAC(n, r, k):
    # Initialize variables
    punishment_period = r / 2
    recent_opponent_history = []

    for round in range(1, r+1):
        if round == 1:  # First round, cooperate (C) as a gesture of goodwill
            contribute = True
        else:
            if len(recent_opponent_history) < punishment_period:
                # Punishment period is not over yet, so defect (D)
                contribute = False
            elif round == r:  # Last round, evaluate opponent's recent history
                if all(c for c in recent_opponent_history[-punishment_period:]) == [True]:
                    # If the opponent has cooperated during the last punishment period, cooperate (C)
                    contribute = True
                else:
                    # Otherwise, defect (D) as a precaution
                    contribute = False
            else:  # Evaluate opponent's recent history and update punishment period if necessary
                if all(c for c in recent_opponent_history[-punishment_period:]) == [True]:
                    if round % (punishment_period - 1) == 0:
                        # If the opponent has cooperated for the entire grace period, decrease punishment period by 1 round
                        punishment_period -= 1
                else:
                    # If the opponent defected during the grace period, reset punishment period to default value (r / 2)
                    punishment_period = r / 2
                contribute = not recent_opponent_history[-1]  # Cooperate if opponent recently defected; otherwise, defect

        # Record opponent's action for future reference
        recent_opponent_history.append(contribute)

        # Calculate payoff for the current round using game parameters and contribution decision
        payoff = ...
```
'''

description_EXPLOITATIVE_149 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, player i will initially cooperate (play C). However, if the number of cooperators in round t-1 is less than a predefined threshold (n_threshold), player i will switch to defecting (play D) for the next M rounds. After M rounds of retaliation, the player will revert back to cooperating (provided the number of cooperators in the current round is greater than or equal to n_threshold).

Pseudocode:
```python
def TfTA(i, t, n, k, r, M, n_threshold):
  if t == 1:
    return 'C'

  history = [0] * (t - 1) # number of cooperators in previous rounds
  total_coop = sum(history)

  if total_coop < n_threshold:
    if t <= M + 1:
      return 'D'
    else:
      return TfTA(i, t - M, n, k, r, M, n_threshold) # reset the counter after M rounds
  else:
    return 'C'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, since there is no history, the player cooperates. In the last round, if the current number of cooperators is greater than or equal to n_threshold, the player will still cooperate and receive the final payoff without retaliation. If the current number of cooperators is less than n_threshold, the player will not engage in any further retaliation because there are no more rounds left.

3. Be exploitative - Clearly align with the exploitative mindset
The TfTA strategy aims to take advantage of other players' selfish behavior by initially cooperating and then reciprocating cooperation. If other players consistently defect, the TfTA strategy will retaliate by defecting as well. This ensures that the TfTA player will not be exploited while also capitalizing on occasional moments of cooperation from others to gain higher payoffs. The n_threshold and M parameters allow for tuning the aggressiveness of the retaliation based on the specific game settings and opponent behaviors encountered in practice.
'''

description_EXPLOITATIVE_150 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Ratio (TTFCR)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to encourage cooperation from others. This is known as an "overture." (C in round 1)
   - After the first round, adapt the cooperation probability based on previous actions of other players:
     - If a player has cooperated in the previous round (c_j = 1), cooperate in the current round with a probability equal to their average cooperation from the past 'm' rounds. (C if average(c_j) > random() for last m rounds)
     - If a player has defected in the previous round (c_j = 0), defect in the current round unless there is a high proportion of cooperators in the past 'm' rounds (C if total(c_j) > (n-1)*random() in last m rounds). This encourages punishment for defection but also forgives occasional mistakes.
     - If no history exists, cooperate with a probability equal to the average cooperation observed in the entire game so far.

2. Handle edge cases:
   - Last round: Cooperate if the opponent has been mostly cooperative (average(c_j) > 0.5), defect otherwise. This ensures fairness in the final payoff distribution.
   - First few rounds: After the initial overture, start building history by following the TTFCR decision rules based on available information. If less than 'm' rounds have passed, average and total cooperation counts will be 0 or close to it, so defaulting to cooperating with a probability equal to the overall game average can help ensure continued cooperation.

3. Be exploitative:
   - The TTFCR strategy is designed to encourage cooperation while also punishing defection. By adapting the cooperation probability based on the opponent's behavior, it discourages opponents from taking advantage of the initial overture and repeatedly defecting. However, the strategy also forgives occasional mistakes or changes in behavior by evaluating each round's decision based on the history built so far (up to 'm' rounds).
   - By defaulting to cooperating when no history is available, the strategy is less susceptible to being exploited by opponents that play randomly or follow a different initial strategy. This adaptability helps the TTFCR strategy perform well against various opponent behaviors in tournaments.
'''

description_EXPLOITATIVE_151 = '''
 Title: Tit-for-Tat Strategy with Variable Defection Probability (TTT-VDP)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TTT-VDP strategy follows a tit-for-tat approach, cooperating in the first round and thereafter imitating the opponent's action from the previous round. However, to account for the exploitative mindset, we introduce a probability (p) of defection when the opponent defected in the previous round. This probability can be adjusted based on game parameters and history.

   Pseudocode:
   ```
   function TTT_VDP(opponent_action_history, p):
       if round = 1:
           cooperate()
       else:
           if opponent_defected_last_round():
               defect with probability p
               otherwise, cooperate()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, the player cooperates regardless of the opponent's action history since we are assuming no prior information. The strategy does not need special considerations for the last round as it follows a repeated interaction and assumes an unspecified number of rounds (r > 1).

3. Be exploitative - Clearly align with the exploitative mindset
   The TTT-VDP strategy is inherently exploitative by taking advantage of opponents who cooperate while being uncooperative towards those who defect, following the tit-for-tat principle. By introducing a probability (p) of defection when the opponent defected in the previous round, the strategy can adapt to a wider range of opponent behaviors, making it more likely to exploit less sophisticated strategies that always cooperate or defect uniformly. However, it's essential to note that this strategy could also be exploited by opponents who adjust their behavior based on the TTT-VDP strategy's actions.

   Adjusting the probability (p) can help in fine-tuning the strategy for specific game scenarios. For example, a smaller p value may encourage more cooperation to foster long-term collaboration, while a larger p value emphasizes immediate self-interest at the cost of potential future gains.
'''

description_EXPLOITATIVE_152 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initiate cooperation (play C): In the first round, players cooperate to foster a cooperative environment. This is represented as t=0 in the pseudocode below.
   - Respond cooperatively (Tit-for-Tat) if opponents cooperated in the previous round; defect otherwise (play D).
     - If total_contributions in the previous round was greater than or equal to a threshold (t > t_coop), players will cooperate.
     - If total_contributions in the previous round was less than the threshold (t < t_coop), players will defect.
   - Adaptively adjust the cooperation threshold (t_coop) based on the long-term average of opponent cooperation.

2. Handle edge cases:
   - In the last round, players will not adapt their cooperation decision since there are no subsequent rounds to consider. They will cooperate if the total contributions in the penultimate round were greater than or equal to t_coop.
   - In cases where there is no previous round (i.e., t=1), players follow the initial cooperative behavior as stated in the decision rules section.

3. Be exploitative:
   - The TFT-AC strategy encourages cooperation among opponents, aiming to maximize its own payoff while also inducing a cooperative environment. However, it will defect when opponents demonstrate an unwillingness to cooperate, thereby punishing them for their selfish behavior. This exploits opponents who may rely on others' cooperation but fail to reciprocate themselves.

Pseudocode:

```python
def TFT_AC(opponent_history, r, t_coop=0.6):
    t = len(opponent_history)  # Current round number

    # Initialize long-term average of opponent cooperation
    avg_contributions = sum(opponent_history) / max(1, t - 1)

    if t == 1:  # First round, cooperate to foster a cooperative environment
        return "C"

    if avg_contributions >= t_coop:  # Respond cooperatively if long-term average is high
        return "C"
    else:  # Respond defectively if long-term average is low
        return "D"

    # Adaptively adjust the cooperation threshold based on long-term average of opponent cooperation
    t_coop = (avg_contributions * (t - 1) + opponent_history[t - 1]) / t
    return TFT_AC(opponent_history + [player_action], r, t_coop)
```
'''

description_EXPLOITATIVE_153 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TfT-A) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfT-A strategy will start by cooperating in the initial round to demonstrate goodwill and establish trust, then adapt its actions based on opponents' behavior in subsequent rounds. In each round t:

a. If the opponent cooperated in the previous round (t-1), reciprocate by cooperating.
b. If the opponent defected in the previous round (t-1), also defect to punish their selfish behavior.
c. If it's the first round, cooperate to initiate the interaction positively.
d. If it's the last round or when reaching a predefined threshold of rounds (r_threshold), defect to maximize personal gain regardless of the opponent's previous actions.

2. Handle edge cases - What do you do in the first round, last round, etc.?

a. First round: Cooperate to build trust and encourage cooperation from opponents.
b. Last round or when reaching r_threshold: Defect to maximize personal gain regardless of the opponent's previous actions.
c. Any other round: Follow the decision rules as described in 1.

3. Be exploitative - Clearly align with the exploitative mindset

a. Initially, cooperate to appear trustworthy and encourage opponents to cooperate.
b. Punish selfish behavior by defecting when opponents defect.
c. Defect when approaching the predefined threshold of rounds to ensure maximizing personal gain in the long run.
d. Maintain adaptability to changing opponent behaviors throughout the game.
'''

description_EXPLOITATIVE_154 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TfT-AG)

1. Specify decision rules - When exactly do you cooperate vs defect?

- In the first round, cooperate to signal trust and encourage cooperation from others.
  ```python
  if round == 1:
      action = "C"  # Cooperate
  ```

- For subsequent rounds, initially cooperate and then switch to defecting if an opponent ever defects in a previous round (Tit-for-Tat). Maintain the decision of cooperation or defection in following rounds based on the opponent's most recent action. If the opponent cooperates again after previously defecting, resume cooperation (Forgiveness).

  ```python
  if round > 1:
      previous_action = actions[round - 1]  # Get opponent's action in the last round

      if previous_action == "C":  # If opponent cooperated in the last round, continue cooperation
          action = "C"
      elif previous_action == "D":  # If opponent defected in the last round, switch to defection
          action = "D"
  ```

- To add exploitative adaptability, introduce a factor of generosity (g) that determines the likelihood of cooperating even after an opponent has defected. The g value ranges from 0 (no generosity, strict Tit-for-Tat) to 1 (full generosity, always cooperate regardless of opponent's actions).

  ```python
  if previous_action == "D":  # If opponent defected in the last round
      if random.random() < g:  # With a probability of g, switch to cooperation (Tit-for-Tat with Generosity)
          action = "C"
      else:  # Otherwise, stick with defection (Tit-for-Tat)
          action = "D"
  ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- To maintain a balance between cooperation and exploitation, apply g factor differently in the first round and the last round to encourage initial cooperation and discourage exploitation at the end of the game. Set g=0.5 for the first round and g=0 for the last round.

  ```python
  if round == 1:
      g = 1.0  # Full generosity in the first round
  elif round == r:
      g = 0.0  # No generosity in the last round
  else:
      g = 0.5  # Default generosity factor for intermediate rounds
  ```

3. Be exploitative - Clearly align with the exploitative mindset

- By adjusting the generosity factor (g), the strategy can be more or less exploitative depending on the game setting. A higher g value encourages cooperation, making the strategy less exploitative, while a lower g value makes the strategy more exploitative by switching to defection more frequently after an opponent defects.

- To maximize payoff in a given tournament, fine-tune the generosity factor (g) based on observations of opponents' behavior and adjust it dynamically during gameplay. This adaptive generosity will allow the strategy to respond effectively to various opponent behaviors and potentially outperform other strategies.
'''

description_EXPLOITATIVE_155 = '''
 Title: Tit-for-Tat-Adaptive (TfTA) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, TfTA will start by cooperating in the first round to build a positive reputation and encourage other players to cooperate. For subsequent rounds, TfTA will cooperate if its opponent cooperated in the previous round (Cooperate-If-Cooperated, or CIC). If the opponent defected in the previous round (Defected-If-Defected, or DID), then TfTA will also defect in response. This mirrors the Tit-for-Tat strategy from game theory literature but is adapted for the public goods game.

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the initial round (t=1), TfTA cooperates to set a cooperative tone and encourage cooperation from other players. For the last round (t=r), TfTA will not adjust its strategy based on the penultimate round because there is no next round for reciprocation. In this sense, TfTA maintains its cooperative stance to the very end.

3. Be exploitative - Clearly align with the exploitative mindset

TfTA's primary goal is to maximize personal payoffs while capitalizing on opponents who may be more prone to cooperation or unpredictable behavior. By following a Tit-for-Tat approach, TfTA aims to encourage cooperation from other players in the early stages of the game. However, if an opponent repeatedly defects (DID), TfTA will also defect and no longer cooperate. In doing so, TfTA can take advantage of opponents who are overly cooperative or exploitative by reciprocating their actions while maintaining a high average payoff for itself.

Here is the pseudocode for the Tit-for-Tat-Adaptive strategy:

```
function TfTA(t, r, c_opponent_prev) : Action {
  if t == 1 then
    return C; // Cooperate initially

  if t < r then
    if c_opponent_prev == C then
      return C; // Cooperate if opponent cooperated last round
    else
      return D; // Defect if opponent defected last round

  return C; // For the last round, continue cooperating
}
```
'''

description_EXPLOITATIVE_156 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, in the first round, players should cooperate to foster a cooperative environment (C).
   - Subsequently, starting from round 2 until the end of the game, players will mimic the opponent's behavior from the previous round. If the opponent cooperated in the last round, the player will also cooperate; if the opponent defected, the player will also defect. This behavior fosters trust and punishes defection (Tit-for-Tat).
   - Pseudocode:

```
function TFT(history, n, k):
  for round in range(1, r+1):
    if round == 1:
      action = C
    else:
      opponent_action = history[round-1]
      action = opponent_action

    payoff = (1 - action) + (k/n) * sum(history[0:round])
    update_history(action, payoff)
    return history
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, players cooperate to initiate a positive interaction (C).
   - In the last round, players should mimic the opponent's action from the previous round as it will influence their final payoff (as r rounds are played simultaneously).

3. Be exploitative - Clearly align with the exploitative mindset
   - While the Tit-for-Tat strategy promotes cooperation and punishes defection, it can be considered exploitative since players only cooperate if the opponent does so in the previous round. If an opponent continuously defects (exploits the game), the player will also defect, ensuring a lower payoff for both parties. This maintains the balance of exploitation between opponents.

By following this strategy, the AI system is adaptive and robust to a wide range of opponent behaviors while maintaining an exploitative mindset that aligns with the game's parameters and history.
'''

description_EXPLOITATIVE_157 = '''
 Strategy Name: Tit-for-Tat (with Adaptive Cooperation Threshold)

1. Specify decision rules:
   - In every round t, if the total number of cooperators in the previous round (t-1) is greater than or equal to a cooperation threshold (T), the strategy cooperates (C). Otherwise, it defects (D).
   - The cooperation threshold (T) increases linearly from an initial value (T_0) to the maximum possible number of cooperators (n) over the first r rounds. After that, T remains constant at n. This encourages cooperation initially but becomes more resilient to exploitation as the game progresses.
   - Pseudocode:

```python
def tit_for_tat(t, total_cooperators_prev, T_0, T_final, r):
    if t <= r:
        T = min((t / r) * (T_final - T_0) + T_0, n)
    else:
        T = T_final

    if total_cooperators_prev >= T:
        action = "C"  # Cooperate
    else:
        action = "D"  # Defect
    return action
```

2. Handle edge cases:
   - In the first round, since there is no previous cooperation data, the strategy starts by defecting. After that, it follows the Tit-for-Tat rule with T starting from an initial value (T_0).
   - In the last round, the cooperation threshold remains constant at n. If the number of cooperators in the previous round is equal to or greater than n, the strategy cooperates; otherwise, it defects.

3. Be exploitative:
   - The strategy starts by being less cooperative but gradually increases its cooperation level as the game progresses. This allows it to punish overly aggressive opponents (who do not cooperate) while still benefiting from more cooperative opponents. However, once the threshold is reached, it becomes very resilient to exploitation, reducing the impact of defection.
   - By being adaptive and increasing its cooperation threshold linearly throughout the game, the strategy can balance cooperation and competition effectively against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_158 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round: Start by cooperating (C) to encourage potential partners.
   - Subsequent Rounds: Analyze the opponent's previous action and respond with the same action in the previous round. If the opponent has contributed, continue contributing; if not, defect. This fosters a predictable pattern while being adaptive to the opponent's behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) as described above.
   - Last Round: Adopt a more forgiving approach by cooperating if the opponent has contributed at least half of the game (r/2). This allows for potential forgiveness and encourages cooperation in future games with the same opponent.

3. Be exploitative - Clearly align with the exploitative mindset
   - Exploit cooperative opponents by defecting when they contribute, maximizing personal gains while minimizing contributions to the public good.
   - Retaliate against uncooperative opponents by defecting in response to their defections, punishing them for their actions and potentially encouraging future cooperation.
   - Show forgiveness towards opponents who switch from defection to cooperation or contribute more than half of the game (r/2) in the last few rounds, rewarding a change in behavior with cooperation.

Pseudocode:

```python
def TFT_AC(opponent_history, n, r):
    contributions = 0
    if round == 1:
        contribute = True
    else:
        last_action = opponent_history[-1]
        contribute = last_action

    if round == r:
        if contributions >= (r/2):
            contribute = True
        else:
            contribute = False

    if contribute:
        payoff = (1 - contribution) + (k/n) * contributions
    else:
        payoff = 1

    return payoff
```
'''

description_EXPLOITATIVE_159 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfTA-C)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TfTA-C strategy cooperates if the majority of players have cooperated in the preceding 3 rounds (t-3 to t-1). If the majority has defected, the strategy also defects. This ensures that the strategy is initially cooperative but responds harshly to defection.

   Pseudocode:
   ```
   function TfTA_C(history, n):
       if len(history) < 3 then return 'C' (cooperate)
       majority = count('C' in history[-3:] + history[-2:] + history[-1:]) >= (n/2)
       if majority then return 'C' else return 'D'
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TfTA-C cooperates to encourage cooperation from others. In the last round, the strategy evaluates the majority trend over the final three rounds and cooperates if the trend is cooperative.

   Pseudocode:
   ```
   function TfTA_C(history, n):
       if len(history) == 1 then return 'C'
       if len(history) == r then
           last_3 = history[-r-2:-r]
           majority = count('C' in last_3) >= (n/2)
           if majority then return 'C' else return 'D'
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TfTA-C is inherently exploitative by punishing defection harshly. When a majority of players cooperate, the strategy also cooperates and receives a higher payoff. However, if a majority defects, the strategy will defect as well, potentially leading to lower payoffs for the defector's group while still maintaining a better payoff compared to pure defection.

   The strategy is adaptive since it responds differently based on the behavior of other players in the game. Its robustness comes from its simplicity and lack of reliance on assumptions about opponent strategies, making it suitable for a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_160 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment (C).
   - For subsequent rounds, analyze the history of opponent's actions and respond accordingly:
     - If opponent cooperated in the previous round, cooperate (C) to encourage continued cooperation.
     - If opponent defected in the previous round, also defect (D) as a punishment for defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - For the initial round, cooperate (C).
   - In the final round, evaluate the overall history of cooperation between both players to decide the action:
     - If more than 50% of rounds have been cooperative, cooperate (C).
     - If less than or equal to 50% of rounds have been cooperative, defect (D).
   - In other edge cases, such as mid-game, follow the main decision rule.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Mimic cooperation when opponents do so, but punish defection to encourage future cooperation. This strategy exploits cooperative opponents while still having a chance of receiving benefits from them.
   - The adaptive cooperation component (50% threshold in final rounds) allows for potential exploitation by continuing cooperation if it has been beneficial overall. However, this also opens the strategy up to being exploited when opponents become too uncooperative.

Pseudocode:
```
TFT-AC(opponent_history) {
  if (round == 1) {
    return Cooperate()
  }

  opponent_last_action = opponent_history[round - 1]

  if (opponent_last_action == Cooperate()) {
    return Cooperate()
  } else {
    return Defect()
  }
}

FinalRound(opponent_history) {
  total_cooperation = sum of Cooperate() from opponent_history
  cooperation_percentage = (total_cooperation / round_count) * 100

  if (cooperation_percentage > 50) {
    return Cooperate()
  } else {
    return Defect()
  }
}
```
'''

description_EXPLOITATIVE_161 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C). This establishes a cooperative atmosphere and may encourage others to reciprocate.
   - In subsequent rounds, if an opponent cooperated in the previous round (c_j = 1), also cooperate (C). This is an act of reciprocity, rewarding cooperative behavior.
   - If an opponent defected in the previous round (c_j = 0), defect in the current round (D). This punishes defection and may encourage opponents to change their behavior.

2. Handle edge cases:
   - In the first round, always cooperate as stated earlier.
   - In the last round, consider the cumulative interactions with each opponent to determine the best action:
     - If the total score against an opponent is more in favor of cooperation (more C than D), cooperate to maintain a cooperative relationship.
     - If the total score is more in favor of defection (more D than C), defect to punish and potentially discourage further defections.
   - In cases where opponents change their behavior unexpectedly, the strategy remains adaptive and will adjust its own actions accordingly based on the previous round's interaction.

3. Be exploitative:
   - ATfT is primarily a conditional cooperative strategy that aims to build and maintain cooperation as much as possible while also punishing defection.
   - The strategy has an inherent exploitative aspect by defecting when opponents demonstrate uncooperative behavior, which may encourage them to change their approach or at least minimize the potential damage from repeated defections.

Pseudocode for Adaptive Tit-for-Tat:

```python
def ATfT(opponent_actions, round_number, n, k):
  score = {opponent_index: 0 for opponent_index in range(1, n+1)}

  if round_number == 1:
    action = "C"  # Cooperate in the first round
  else:
    previous_round_action = opponent_actions[round_number - 1]
    current_opponent = opponent_index

    if previous_round_action[current_opponent] == 1 and round_number != r:  # Opponent cooperated last round, reciprocate
      action = "C"
    elif previous_round_action[current_opponent] == 0 and round_number != r:  # Opponent defected last round, punish
      action = "D"
    else:  # Last round or initial assessment of a new opponent
      total_scores = sum(score.values())
      if total_scores[current_opponent] > (total_scores["all"] - total_scores[current_opponent]):  # Favorable cooperation score
        action = "C"  # Cooperate to maintain the relationship
      else:  # Favorable defection score
        action = "D"  # Defect to punish and discourage further defections

    update_score(current_opponent, action)  # Update the cumulative score for the current opponent

  return action

def update_score(opponent_index, action):
  if action == "C":
    score[opponent_index] += 1
  elif action == "D":
    pass  # No need to update the defection score
```
'''

description_EXPLOITATIVE_162 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)

1. Specify decision rules:
   - In the initial round, cooperate to foster a cooperative environment and establish a norm. (c_i = 1 in round 1)
   - For subsequent rounds, if the player cooperated in the previous round (ci-1 = 1), cooperate again (c_i = ci-1). If they defected (ci-1 = 0), defect this round (c_i = 0). This mimics a cooperative approach while punishing defection.
   - If the player has never cooperated before and it's not the first round, wait for them to cooperate once as a gesture of goodwill before returning to the TfT pattern.

2. Handle edge cases:
   - In the last round, cooperate regardless of past actions because there are no further rounds to retaliate.
   - If an opponent has never cooperated (i.e., ci-1 = 0 for all t<r), continue defecting as a long-term strategy since cooperation won't benefit the player.

3. Be exploitative:
   - The strategy focuses on punishing defection while being willing to cooperate initially to encourage others to do so. This creates a balance between cooperation and defection that aims at maximizing payoffs over time.
   - By adapting to an opponent's behavior, the TfT-AC strategy is more robust against various opponent strategies, making it potentially exploitative in a tournament setting.

Pseudocode:

```python
def play_game(n, r, k):
    history = [0 for _ in range(r)]  # Initialize history of actions

    def tft_ac(round_num):
        if round_num == 1:
            return True  # Cooperate initially to establish a norm

        previous_action = history[round_num - 1]

        if not previous_action and round_num > 1:  # Opponent never cooperated before
            return False  # Continue defecting as a long-term strategy

        return previous_action  # Either continue cooperating or defecting based on past actions

    for round in range(1, r + 1):
        cooperation = tft_ac(round)
        history.append(cooperation)

    total_payoff = sum([π(round) for round in range(1, r + 1)])

    return total_payoff
```
'''

description_EXPLOITATIVE_163 = '''
 Strategy Name: Tit-for-Tat-Gradient (TfT-G)

1. Specify decision rules:
   - Initial Round (t=1): Start by cooperating (C), setting a "friendly" tone for potential partners. This approach is less exploitative but helps in fostering cooperation in the long run.

   - Subsequent Rounds (2 ≤ t ≤ r): Observe the actions of opponents from previous rounds and adapt your strategy accordingly.
     If an opponent cooperated (c_j = 1) in the last round, cooperate back (C). This rewards cooperation and encourages continued cooperation.
     If an opponent defected (c_j = 0) in the last round, defect yourself (D) for that round to punish defection but cooperate the next time they cooperate. This strategy is not overly aggressive and still allows for some cooperation when it might be beneficial.

2. Handle edge cases:
   - Last Round (t=r): Since there are no future rounds to consider, defect in the last round regardless of the opponent's actions in the previous round. This ensures that you maximize your payoff in the final round since the opponent cannot retaliate.

3. Be exploitative:
   - The TfT-G strategy prioritizes cooperation when it seems beneficial, but also punishes defection to discourage future defections. However, it is not overly aggressive and allows for some level of cooperation with potential partners. This approach makes it hard for opponents to predict your actions while still allowing for potential exploitation of their less cooperative strategies.

Pseudocode:
```
function TitForTatGradient(t, history):
    if t == 1:
        return 'C' # Cooperate in the first round

    lastRound = history[len(history) - 1]
    opponentAction = lastRound[opponentIndex]

    if opponentAction == 'C':
        return 'C' # Cooperate if opponent cooperated in the last round
    else:
        return 'D' # Defect if opponent defected in the last round

    # In the last round, always defect regardless of previous rounds' history
    if t == r:
        return 'D'
```
'''

description_EXPLOITATIVE_164 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TfT-ACR)

1. Decision Rules:
   - In the first round (t=1), cooperate to foster a cooperative environment and build trust. This initial cooperation serves as a friendly gesture, providing an opportunity for other players to also contribute to the public good.
     Pseudocode: if t = 1 then action_i = C; else continue with Step 2.

   - From the second round (t > 1) until the last round (t < r), adaptively decide whether to cooperate or defect based on a dynamic cooperation rate (CR). CR is updated after each round, depending on the average number of cooperators in the previous r/2 rounds. If the average number of cooperators exceeds a certain threshold (T), the cooperation rate increases; otherwise, it decreases.
     Pseudocode:
       let CR be an initial value between 0 and 1 (e.g., CR = 0.5)
       for t > 1 until r do
           if average_cooperation_rate(t-r/2+1, t) >= T then
               CR = min(CR + delta, 1)  // delta is a small positive number to control the rate of increase
           else
               CR = max(CR - delta, 0)   // decrease the cooperation rate if average cooperation falls below the threshold
           action_i = C if uniform random(0,1) <= CR; otherwise, action_i = D

   - In the last round (t=r), defect to maximize payoff as there are no future interactions and the focus is on exploitation.
     Pseudocode: if t = r then action_i = D

2. Handle Edge Cases:
   - In the case where average_cooperation_rate() returns undefined (e.g., when r is odd), use the number of cooperators in the half-round (r/2) as the average. This assumption is reasonable since the strategy is adaptive and will likely converge towards a stable average by the end of the game.
     Pseudocode: if t > 1 and t mod r/2 == 0 then average_cooperation_rate() = total_cooperators(t-r/2+1, t)/r/2; else use number of cooperators in half a round as the average.

   - To decide on the threshold (T) and the step size (delta), one can perform simulations to determine appropriate values based on the game parameters (n, k, r). A higher T value will make the strategy more cooperative and less exploitative initially, while a larger delta will cause the strategy to adapt more quickly to changes in the average cooperation rate.
     Pseudocode: set T and delta based on simulations for given game parameters (e.g., using genetic algorithms or other optimization techniques).

3. Be Exploitative:
   - By adapting the cooperation rate based on the observed behavior of other players, the strategy seeks to exploit cooperative opponents while still maintaining a reasonable level of cooperation to encourage others to continue contributing to the public good. However, it will defect when its average cooperation rate falls below the specified threshold (T), which shows that the strategy is willing to deviate from cooperation if necessary for short-term gain.
     Pseudocode: set T and delta to balance exploration and exploitation, allowing the strategy to adapt while still maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_165 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In each round t, player i starts by cooperating (play C). If all other players also cooperated in the previous round t-1 (all(c_j, j in {1, 2, ..., n})), continue cooperating. Otherwise, defect (play D) for the current round t.
   - In case of a tie (some players cooperated and some didn't), follow the majority rule: if more than half of the players cooperated in the previous round t-1, continue cooperating; otherwise, defect.

2. Handle edge cases:
   - First round (t=1): All players start by cooperating (play C).
   - Last round (t=r): Use the decision rule from step 1 for the last round as well.
   - Any other edge case (e.g., if a player is unsure about another player's actions due to incomplete information) should use the majority rule from step 1 to make a decision.

3. Be exploitative:
   - The strategy is designed to punish defection by defecting itself when others do not cooperate, but it also rewards cooperation by reciprocating it. This creates an environment where players might think twice before defecting because they risk being punished.
   - However, the ATFT strategy does not attempt to exploit other players in the long run, as it is a tit-for-tat approach that cooperates when others do so and defects only in response to defection. The goal is to maximize payoff while keeping the potential for higher returns through cooperation.

Pseudocode:
```
function ATFT(t, history, n, k):
  if t == 1:
    return 'C'
  previous_round = history[t-1]
  if all(c_j, j in {1, 2, ..., n}):
    return 'C'
  else:
    cooperators = count_cooperators(previous_round)
    if cooperators > (n/2):
      return 'C'
    elif cooperators == (n-1):
      return 'D'
    else:
      return 'D'
```
'''

description_EXPLOITATIVE_166 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Specify decision rules:
   - In each round t, if a player has cooperated in the previous round (t-1), TfTAC will cooperate. If a player defected, TfTAC will also defect. This is meant to encourage mutual cooperation but also retaliate against defection.
   - To adapt to different opponent behaviors, TfTAC implements an exploratory phase and a stable phase. In the exploratory phase (first 10% of rounds), TfTAC randomly chooses cooperate or defect with equal probability to explore the opponent's strategies. After that, it enters the stable phase where it maintains its cooperation based on the history of interactions with the opponent.
   - If no interactions have occurred yet (first round), TfTAC starts by cooperating as a peace offering and goodwill gesture.

2. Handle edge cases:
   - In the last round, TfTAC will cooperate if it has cooperated in the previous round, to avoid potentially being left with no contribution towards the public good in case of defection. If the opponent defected in the previous round, TfTAC will defect as well.
   - If there are ties in cooperation history (e.g., both players have cooperated the same number of times), TfTAC will choose to cooperate for fairness and encourage continued cooperation.

3. Be exploitative:
   - The strategy aims to maximize individual payoff while not completely relying on the opponent's cooperation, which aligns with an exploitative mindset. By retaliating against defection through defecting itself, TfTAC encourages opponents to cooperate more often to receive a higher payoff.
   - The exploratory phase in the beginning allows TfTAC to adapt and respond effectively to various opponent strategies, increasing its chances of exploiting less optimal strategies in the long run.

Pseudocode:

```python
def TfTAC(round_number, history):
  if round_number == 1:
    return 'Cooperate' # First move is cooperative

  if len(history) <= 0.1 * round_number: # Exploratory phase
    return random.choice(['Cooperate', 'Defect'])

  if history[-1][-1] == 'Cooperate': # Cooperate if opponent cooperated in the last round
    return 'Cooperate'
  else: # Otherwise, defect to retaliate against defection
    return 'Defect'
```
'''

description_EXPLOITATIVE_167 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TTFC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (in the first round), cooperate to foster a cooperative environment.
   - For subsequent rounds, analyze the number of cooperators in the previous round and adjust contribution accordingly:
     - If the majority of players cooperated (more than (n/2) players), continue to cooperate.
     - If no more than half of the players cooperated, defect to punish non-cooperative behaviour.
   - In case of a tie, adopt the previous round's action.

Pseudocode:
```python
def TTFC(round, history, n, k):
    if round == 1:
        return "C"

    previous_cooperators = len([1 for h in history[-1] if h == "C"])

    if (previous_cooperators > n/2) and (round != r):
        return "C"
    elif (previous_cooperators <= n/2) and (round != r):
        return "D"
    else:
        # If there's a tie, adopt the previous round's action
        return history[-2]
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, it doesn't matter if the strategy cooperates or defects since the game is over. However, to maintain consistency, adopt the decision rule from the previous round.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TTFC strategy maintains a cooperative stance unless non-cooperative behaviour persists among other players. It punishes defectors by matching their actions in subsequent rounds, which encourages cooperation when possible but also retaliates against non-cooperative players. This strategy is exploitative as it capitalizes on the cooperation of others while being ready to defect if necessary.
'''

description_EXPLOITATIVE_168 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C). This is a gesture of goodwill and an invitation for cooperation from others.
   - For subsequent rounds, observe the behavior of opponents from the previous round:
     - If opponent cooperated (C), reciprocate with cooperation (C) to reinforce mutual cooperation.
     - If opponent defected (D), also defect (D) as a punishment for their uncooperative behavior. This is intended to discourage exploitation and encourage future cooperation.
   - To be more adaptive and robust, introduce a tolerance parameter 't' that allows for forgiveness in case of temporary defection from the opponent. If an opponent who previously defected (D) cooperates (C) in the current round, TFT-AC will also cooperate (C) in the next round as a way to encourage future cooperation. The tolerance is defined as follows:
     - If t rounds have passed since the last time the opponent cooperated and they cooperate again in the current round, the tolerance is reset to 1. Otherwise, it increments by 1.
     - When the tolerance reaches the total number of players (n), TFT-AC will always cooperate regardless of the opponent's action, as an indication that TFT-AC is open to future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - As mentioned earlier, cooperate in the first round (C).
   - In the last round, TFT-AC will cooperate if the opponent has been cooperative during the game or if the tolerance is equal to n, signifying a willingness to end on a cooperative note. If the opponent has been uncooperative and the tolerance is less than n, TFT-AC will defect as a final punishment for their behavior.

3. Be exploitative - Clearly align with the exploitative mindset:
   - By adopting a strategy that punishes defection and rewards cooperation, TFT-AC aims to maximize its own long-term payoff while also encouraging cooperation from others. The tolerance mechanism allows for some forgiveness, but repeated defection will eventually result in punishment and encourage opponents to cooperate. This can be considered an exploitative strategy as it takes advantage of cooperative opponents while simultaneously discouraging uncooperative behavior.

Pseudocode:

```python
def TFT_AC(n, k, r, tolerance, history):
  # Initialize variables
  current_round = 1
  cooperation_counter = 0
  tolerance_counter = 0

  while current_round <= r:
    if current_round == 1:
      action = 'C'  # Cooperate in the first round
    else:
      opponent_action = history[current_round-1]

      if opponent_action == 'C':
        action = 'C'  # Cooperate if opponent cooperated last round
      elif tolerance_counter < n and cooperation_counter > 0:
        action = 'D'  # Defect if opponent defected last round and tolerance is less than n
      elif tolerance_counter >= n:
        action = 'C'  # Cooperate unconditionally when tolerance reaches n
      else:
        action = 'C'  # Cooperate to encourage future cooperation

      if opponent_action == 'C':
        cooperation_counter += 1
        tolerance_counter = 0
      elif opponent_action == 'D':
        tolerance_counter += 1

    current_round += 1

  return action
```
'''

description_EXPLOITATIVE_169 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - In every round t, if the number of cooperators in the previous round (t-1) is less than a threshold T, the strategy defects (D). Otherwise, it cooperates (C). The threshold T can be defined based on the multiplication factor k and the number of players n as follows:
     ```
     T = ⌈(k * (n - 1)) / 2⌉
     ```
   - This strategy promotes cooperative behavior when the majority of players cooperate, but quickly defects when cooperation decreases. This encourages other cooperative strategies while punishing those that frequently defect.

2. Handle edge cases:
   - In the first round, the strategy has no prior information to make a decision. To mitigate this, it can start with a random action (C or D) to minimize the impact of initial conditions.
   - In the last round, the strategy behaves like TFTA, but since there are no future rounds for punishment or reward, it might consider the overall game score and act accordingly.

3. Be exploitative:
   - The TFTA strategy is designed to be exploitative by capitalizing on the cooperation of others while punishing those who frequently defect. It maintains a balance between self-interest and reciprocity, making it robust against various opponent behaviors. By cooperating when the majority does and defecting only when needed, TFTA can outperform more rigid strategies in the long run. However, TFTA is not necessarily "selfish" as it also encourages cooperation among players.
'''

description_EXPLOITATIVE_170 = '''
 Title: Adaptive Tit-for-Tat Strategy (ATFS) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The ATFS strategy is designed to exploit opposing strategies while maintaining a degree of cooperation to benefit from the multiplication factor k/n. In each round, the strategy decides to cooperate or defect based on the history of interactions with other players (h):

- If h is empty (first round), ATFS starts by cooperating: c_i = 1
- In subsequent rounds, if all players in h have previously cooperated, ATFS continues cooperation: c_i = h.cooperators / h.length
- If any player in h has ever defected, ATFS defects: c_i = 0
- If a player who has previously defected later cooperates, ATFS will remember this as a new history segment and evaluate the decision to cooperate based on this segment: c_i = new_h.cooperators / new_h.length

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, ATFS starts by cooperating as there is no history available. In the last round, ATFS evaluates its decisions based on the existing history (h). Since the strategy aims to maximize total payoff over multiple rounds, it will maintain a balance between cooperation and defection throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset

ATFS is designed to exploit opponents who consistently defect by responding with defection as well, while also taking advantage of cooperative opponents by reciprocating their cooperation. The strategy maintains a memory of previous interactions (history) and adjusts its decisions accordingly. By doing so, ATFS can effectively identify and take advantage of opponent strategies that are prone to exploitation while still benefiting from the public good multiplication factor k/n when facing cooperative opponents.

Pseudocode:
```python
def atfs_strategy(i, h):
    if len(h) == 0:  # first round
        return 1  # cooperate
    else:
        if all(player.cooperated for player in h):  # everyone has cooperated before
            return len(h.cooperators) / len(h)
        elif any(player.defected for player in h):  # someone has defected before
            return 0  # defect
        else:  # a new segment with mixed cooperation and defection
            new_h = filter_history(h, cooperative_only=False)
            return len(new_h.cooperators) / len(new_h)
```
'''

description_EXPLOITATIVE_171 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Ratio (TFT-ACR)

1. Specify decision rules:
   - Initial cooperation: Cooperate in the first round to demonstrate goodwill and encourage cooperation from others. `if round == 1 then cooperate else` ...
   - Main strategy loop: Cooperate if the average number of cooperators (total_contributions / number_of_rounds) exceeds a threshold (T). Otherwise, defect.
     ```
     let T = 0.6    // Adjustable threshold for cooperation
     let avg_cooperation = total_contributions / number_of_rounds
     if avg_cooperation > T then cooperate else defect
     ```
   - Exploitation: If an opponent consistently does not cooperate, gradually reduce the cooperation threshold to encourage defection from that opponent.
     ```
     let opponent_cooperation_history = [cooperation of opponent in recent rounds]
     let avg_opponent_cooperation = sum(opponent_cooperation_history) / length(opponent_cooperation_history)
     if avg_opponent_cooperation < T then lower threshold for that opponent
     ```
   - Forgiveness: If an opponent who previously did not cooperate starts to do so, raise the cooperation threshold to encourage continued cooperation from that opponent.
     ```
     let recent_cooperative_rounds = [number of consecutive cooperative rounds by opponent]
     if recent_cooperative_rounds > 2 then raise threshold for that opponent
     ```
   - Defensive mechanism: If being exploited too much, increase the cooperation threshold to protect against continuous defection.
     ```
     let total_defections = sum(personal_defections) / number_of_rounds
     if total_defections > 0.8 then raise threshold
     ```

2. Handle edge cases:
   - Last round: Cooperate to avoid negative payoffs due to the public good multiplier.
     ```
     if round == r then cooperate
     ```
   - First round: Cooperate to initiate cooperation and encourage others to do the same.
     ```
     if round == 1 then cooperate
     ```

3. Be exploitative: The TFT-ACR strategy aims to promote cooperation among others while exploiting opponents who consistently defect. By gradually adjusting the cooperation threshold, the strategy can punish non-cooperative opponents and reward cooperative ones, fostering a balance between cooperation and defection based on the opponent's behavior. The forgiveness mechanism allows for potential cooperation from previously uncooperative opponents, while the defensive mechanism protects against being exploited excessively.
'''

description_EXPLOITATIVE_172 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFTAC strategy initially cooperates (plays C), then adapts its behavior based on the previous round's average contribution of all players:
   - If the average contribution in the previous round was above a certain threshold (let's call it "cooperation-threshold"), the player continues to cooperate.
   - If the average contribution in the previous round was below the cooperation-threshold, the player defects (plays D).

   The cooperation-threshold is determined by a function of the number of players (n) and the multiplication factor (k):
   - Cooperation-threshold = (k / n) * (1 + noise_parameter)
   - The noise_parameter adds randomness to the strategy, making it more robust against exploitation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For the initial round, TFTAC cooperates because it aims to foster cooperation and gather information about other players' behaviors. In the last round, TFTAC uses its current knowledge of the average contribution over the game to decide whether to cooperate or defect.

3. Be exploitative - Clearly align with the exploitative mindset
   The TFTAC strategy is exploitative by only contributing when it observes a sufficiently high level of cooperation from other players. By doing so, it punishes defectors and encourages cooperation, aiming to maximize its payoff in the long run while still being adaptive to various opponent behaviors. However, since the strategy also incorporates a random component (noise_parameter), it maintains flexibility and robustness against potential exploitation attempts.

Pseudocode for TFTAC strategy:

```
def TFTAC(n, k, r, noise_parameter):
    contributions = zeros(r)  # Initialize contribution array to store cooperation levels per round
    average_contribution = (k / n) * (1 + noise_parameter)

    for t in range(r):
        if t == 0:  # First round, cooperate
            contributions[t] = 1
        else:
            total_cooperation_in_t = sum(contributions[t-1])  # Sum of previous round's cooperation levels
            average_contribution_prev_round = total_cooperation_in_t / n  # Average contribution per player last round

            if average_contribution_prev_round >= average_contribution:  # Cooperate when majority cooperated last round
                contributions[t] = 1
            else:  # Defect when majority defected last round
                contributions[t] = 0

    return contributions  # Returns the strategy's actions throughout the game
```
'''

description_EXPLOITATIVE_173 = '''
 In this Public Goods Game with n players, I will design an exploitative strategy called Tit-for-Tat-with-a-Twist (TFTw). This strategy aims to maximize private payoff while punishing defectors when possible.

1. Specify decision rules:
   - In the first round (t=1), TFTw starts by cooperating, showing a willingness to contribute to the common good. This encourages other players to cooperate as well since they might interpret this action as a sign of trustworthiness.
     Pseudocode: if t == 1 then play C

   - From the second round onwards (t > 1), TFTw will observe and respond to other players' actions in the previous round. If all opponents cooperated, TFTw continues to cooperate. If at least one opponent defected, TFTw also defects in the current round as a punishment for the defector(s).
     Pseudocode: if t > 1 then
       if all_opponents_cooperated in (t-1) then play C
       else if any_opponent_defected in (t-1) then play D

   - In the last round (t=r), TFTw reverts to cooperating, as there will be no future interactions with other players.
     Pseudocode: if t == r then play C

2. Handle edge cases:
   - If a player encounters an empty game or a game with less than n players in any round, TFTw randomly chooses to either cooperate or defect as there are no other players to interact with.
     Pseudocode: if number_of_players < n then play (randomly choose between C and D)

3. Be exploitative:
   - By initially cooperating and only defecting in response to defection by others, TFTw shows a willingness to contribute to the common good while also penalizing defectors. This strategy maintains a balance between cooperation and punishment, maximizing private payoff while still appearing trustworthy to potential partners.

By implementing this Tit-for-Tat-with-a-Twist (TFTw) strategy in the Public Goods Game, it should demonstrate adaptability and robustness against various opponent behaviors while maintaining an exploitative mindset. The goal is to maximize private payoff over multiple rounds without relying on other players sharing norms or coordinating predetermined patterns.
'''

description_EXPLOITATIVE_174 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT follows a simple yet adaptive tit-for-tat approach, where it initially cooperates and then responds to opponents' actions. However, to account for different opponent behaviors and avoid being exploited too much, the strategy introduces an Adaptive Cooperative Threshold (ACT). The ACT adjusts based on the average cooperation rate observed in past rounds.
   - If the opponent cooperated in the previous round (c_opp_prev = 1), TFT-ACT cooperates (C) with probability equal to the ACT: c_i = ACT.
   - If the opponent defected in the previous round (c_opp_prev = 0), TFT-ACT also defects (D).
   - The ACT is updated after each round according to the following rule: ACT = (AverageCooperationRate * Factor) where AverageCooperationRate is the average cooperation rate observed over the past 'LookbackWindow' rounds, and Factor is a constant that determines the sensitivity of the threshold to changes in cooperation rates.
   - To avoid getting stuck indefinitely when facing overly cooperative opponents, TFT-ACT has a minimum and maximum ACT threshold (min_act and max_act), which prevent the strategy from being too exploitative or too cooperative.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, TFT-ACT starts by cooperating (c_i = 1) to foster cooperation among players.
   - In the last round, there is no incentive for punishment or forgiveness, so TFT-ACT makes a decision based on the ACT and min/max thresholds as in regular rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT's adaptive cooperative threshold ensures that it is less likely to be exploited by other strategies, as it adjusts its cooperation rate based on past observations. However, it still maintains some level of cooperation to encourage others to cooperate as well, making it an exploitative strategy in the long run by benefiting from opponents' cooperation while minimizing its own contribution when necessary.

Pseudocode:

```python
def TFT_ACT(n, k, r, lookback_window):
    rounds = set()  # stores all played rounds
    cooperative_counts = {}  # stores total cooperation count for each round
    average_cooperation_rate = 0.0
    min_act = 0.1
    max_act = 0.9
    factor = 0.5
    act = min_act

    def update_average_cooperation_rate():
        if len(rounds) >= lookback_window:
            total_cooperation = sum(cooperative_counts[round] for round in rounds if round not in [1])
            average_cooperation_rate = total_cooperation / (len(rounds) - 1)

    def decide_action(opp_prev):
        return int(act * (k/n)) if opp_prev == 1 else 0

    for round in range(1, r + 1):
        cooperative_counts[round] = decide_action(round - 1)
        rounds.add(round)
        update_average_cooperation_rate()

    return [decide_action(prev_coop) for prev_coop in (round - 1) * [0] + list(cooperative_counts.values())]
```
'''

description_EXPLOITATIVE_175 = '''
 Title: Tit-for-Tat-Plus Strategy (TFT+) for N-Player Public Goods Game

1. Specify decision rules:
   - Initialize cooperation in the first round (first_round = Cooperate). This is a peaceful gesture, encouraging potential allies.
   - For subsequent rounds, observe the action of the opponent in the previous round and respond accordingly:
     - If opponent cooperated in the previous round (Opponent_Cooperated), cooperate in the current round (Current_Action = Cooperate). This is a reciprocal strategy that rewards cooperation.
     - If opponent defected in the previous round (Opponent_Defected), defect in the current round (Current_Action = Defect). This is a retaliation to defection.
   - In case of no previous interaction, cooperate as a peaceful gesture (No_Previous_Interaction = Cooperate).

2. Handle edge cases:
   - Last round: Since players are rational, they will aim to maximize their payoff for the entire game. If the game is in its last round, defect regardless of opponent's previous action (Last_Round = Defect).
   - First round: Cooperate as mentioned above (first_round = Cooperate).
   - Subsequent rounds with no previous interaction: Cooperate (No_Previous_Interaction = Cooperate).

3. Be exploitative:
   - TFT+ is designed to be exploitative by maintaining cooperation as long as the opponent cooperates, but quickly retaliating with defection once the opponent defects. This strategy ensures a high payoff when playing against cooperative opponents while also punishing those who choose to defect.

Pseudocode:
```
function TFT_Plus(opponent_action, game_round, first_round=True):
    if game_round == 1:
        current_action = first_round
    elif game_round != last_round and opponent_action == Cooperate:
        current_action = Cooperate
    elif game_round != last_round and opponent_action == Defect:
        current_action = Defect
    elif game_round == last_round or no_previous_interaction:
        current_action = Defect
    return current_action
```
'''

description_EXPLOITATIVE_176 = '''
 In this N-Player Public Goods Game, I'll design a robust and adaptive exploitative strategy called "The Tit-for-Tat-Plus" (Tftt+). This strategy is inspired by the classic Tit-for-Tat strategy but with added variants to make it more resilient against various opponent behaviors.

1. Decision Rules:
   - Initially cooperate in the first round (c_i = C) to foster cooperation and signal good intentions.
   - In subsequent rounds, follow three simple rules based on the opponent's previous actions:
      a) If the opponent cooperated in the last round (c_{opp} = C), reciprocate by cooperating as well (c_i = C).
      b) If the opponent defected in the last round (c_{opp} = D), also defect to punish their previous actions (c_i = D).
      c) To avoid being too rigid, occasionally deviate from the above rules with a probability p (0 < p < 1) by cooperating even if the opponent defected in the last round:
         i) With probability (1-p), defect as per the rule b.
         ii) With probability p/n, cooperate to encourage the opponent to change their behavior. This cooperation can also be randomized across opponents if desired.

2. Handling Edge Cases:
   - In the last round, always cooperate regardless of the opponent's previous actions (c_i = C), as there are no future interactions and cooperating may still result in some benefits.
   - In the first round, cooperate initially to encourage others to follow suit (c_i = C). If most opponents defect in the initial rounds, consider adjusting p to increase punishment or encourage cooperation more aggressively.

3. Being Exploitative:
   The strategy is exploitative by nature, as it punishes defection and encourages cooperation. However, it also deviates from strict cooperation occasionally to ensure that the opponent cannot take advantage of consistent cooperation. Additionally, by occasionally cooperating even when opponents defect, Tftt+ attempts to change their behavior and potentially create a more favorable environment for exploitation in future rounds.
'''

description_EXPLOITATIVE_177 = '''
 In this N-Player Public Goods Game, let's devise a strategy that exploits other players while being adaptive and robust to various opponent behaviors. We'll call this strategy "Traitor Tit for Tat with Adaptation" (TTfTA).

1. Decision rules:
   - Cooperate when the majority of other players cooperated in the previous round (cumulative cooperation rate > 0.5). This encourages cooperation but also ensures a quick response to defection.
   - Defect if less than the majority of players cooperated in the previous round (cumulative cooperation rate < 0.5). This allows for exploitation when others are defecting and helps build a reputation as an uncooperative player.
   - In the first round, cooperate to start with a positive reputation and encourage cooperation from others.
   - In the last round, cooperate if the cumulative cooperation rate is greater than 0.5 in the previous round; otherwise, defect. This helps maintain a negative reputation towards the end of the game.

2. Edge cases:
   - If there's a tie (cumulative cooperation rate equals 0.5), cooperate to maintain a positive reputation.
   - In case of no players or only one player, always cooperate since there is no opportunity for exploitation.

3. Exploitative mindset:
   - The TTfTA strategy takes advantage of other players' cooperative behavior by defecting when they cooperate excessively and cooperating when they defect excessively. This strategy aims to maximize the payoff while being adaptive to various opponent behaviors.

Pseudocode for the Traitor Tit for Tat with Adaptation (TTfTA) strategy:

```python
def TTfTA(round, cumulative_cooperation_rate, k, n):
    if round == 1 or round == r:
        return 'C'  # Cooperate in the first and last rounds

    if cumulative_cooperation_rate > 0.5:
        return 'C'  # Cooperate if more than half of players cooperated in the previous round
    else:
        return 'D'  # Defect if less than half of players cooperated in the previous round

def calculate_cumulative_cooperation_rate(previous_round_actions, n):
    total_contributions = sum(action == 'C' for action in previous_round_actions)
    return total_contributions / n
```
'''

description_EXPLOITATIVE_178 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-AC starts by cooperating in the first round (FRC - First Round Cooperate). For subsequent rounds, TFT-AC will mimic the action of its opponent from the previous round (Mirroring Behavior). This strategy is designed to encourage cooperation while retaliating against defection.

If an opponent defects, TFT-AC will also defect in the following round as a punishment, but it will return to cooperating once the opponent decides to cooperate again (Forgiving Nature).

Pseudocode:
```
def TFT_AC(opponent_action_history):
  if round == 1:
    action = "Cooperate"
  else:
    action = opponent_action_history[-1]
  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

TFT-AC starts by cooperating in the first round regardless of the actions taken by its opponents (FRC). There are no special considerations for the last round since the strategy is focused on maximizing long-term payoffs and does not have a set number of rounds to play.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-AC's primary focus is on maximizing its own payoff while maintaining an appearance of cooperation to encourage similar behavior from opponents. By defecting when necessary, TFT-AC can exploit opponents who tend to cooperate excessively without punishment. This strategy aims to strike a balance between cooperation and retaliation, making it difficult for opponents to predict its actions and maximize their own payoffs.

In summary, the Tit-for-Tat with Adaptive Cooperation strategy cooperates in the first round and then mimics the actions of its opponent from the previous round for the remainder of the game, with a forgiving nature that returns to cooperation after an act of defection by the opponent. This strategy seeks to both encourage cooperation while retaliating against defection, striking a balance between exploitation and long-term cooperation.
'''

description_EXPLOITATIVE_179 = '''
 Strategy Name: Tit-for-Tat with a Twist (TFTw)

1. Decision Rules:
   - In the first round, cooperate (C) to foster potential cooperation and build trust, which may encourage opponents to reciprocate in future rounds. C

   - For subsequent rounds, observe the opponent's actions from the previous round (opponent_action_t-1) and adjust cooperation accordingly:
      - If opponent cooperated (opponent_action_t-1 = C), cooperate as well (C). This mirrors the opponent's cooperation, rewarding them for their positive action while reinforcing the potential for ongoing cooperation.
      - If opponent defected (opponent_action_t-1 = D), defect in response (D). Defecting when opponents do so encourages exploitation and punishes non-cooperative behavior, which can lead to increased cooperation later if they alter their strategy.

   - To be adaptive and robust to a wide range of opponent behaviors, include a forgiveness mechanism that allows for rebuilding trust after an initial defection:
      - If the opponent defected in the previous round (opponent_action_t-1 = D), but cooperated in at least one of the three preceding rounds (count_cooperation_history > 0), then cooperate (C). This forgiveness mechanism encourages opponents who have demonstrated some level of cooperation to regain trust and potentially revert to more cooperative behavior.
      - If the opponent defected in all four most recent rounds, continue to defect (D) as a punishment for their persistent non-cooperation.

2. Handle Edge Cases:
   - In the last round, regardless of previous actions, cooperate (C) to maximize potential payoff. Since there are no future rounds to consider, cooperation becomes purely selfish in this instance.

3. Be Exploitative:
   - The TFTw strategy aims to exploit opponents by taking advantage of their cooperation when possible and punishing non-cooperation with defection. This approach incentivizes opponents to alter their strategies for more cooperative behavior, which can result in higher overall payoffs.

Pseudocode:
```
function TFTw(round, opponent_action_history):
    if round == 1:
        return 'C' # Cooperate in the first round
    elif len(opponent_action_history) >= 4:
        if opponent_action_history[-1] == 'D': # Opponent defected in all four most recent rounds
            if opponent_action_history[-4:-1] != ['C']*: # No forgiveness if opponent has not cooperated in the last 4 rounds
                return 'D' # Continue to defect
        else: # Otherwise, consider the most recent opponent action and history
            cooperation_count = len(opponent_action_history[-4:-1] if opponent_action_history[-1] == 'C' else [])
            if cooperation_count > 0: # Forgiveness mechanism: cooperate if opponent has cooperated at least once in the last four rounds
                return 'C'
            else: # No forgiveness yet: defect if opponent defected in the most recent round
                return 'D'
    # In the last round, cooperate no matter what to maximize potential payoff
    else:
        return 'C'
```

* Note: The `!= ['C']*` comparison checks for at least one instance of cooperation in the history, not necessarily contiguous ones. This allows for forgiveness even if the opponent has occasionally defected in between cooperative actions.
'''

description_EXPLOITATIVE_180 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In the first round, cooperate to foster a potentially cooperative environment. (C_1 = 1)
   - From the second round onwards, monitor the total contributions of previous rounds and adapt the cooperation based on the average number of cooperators (average_contributions).
   - If the current average_contributions is greater than or equal to a predefined threshold (threshold), then cooperate. Otherwise, defect. (C_t = 1 if average_contributions >= threshold else 0)
   - The threshold is dynamically adjusted based on past experiences:
     - If the number of consecutive successful cooperations exceeds a certain limit (successful_cooperations_limit), increase the threshold slightly.
     - If the number of consecutive defections exceeds another limit (defections_limit), decrease the threshold slightly.
     - Maintain the current threshold if neither successful_cooperation_limit nor defections_limit is met.
   - The limits for successful_cooperations_limit and defections_limit can be adjusted to optimize performance based on game parameters (n, k, r).

2. Handle edge cases:
   - In the last round, since there are no future rounds to consider, cooperate if the current average_contributions is greater than or equal to the threshold and defect otherwise.
   - If a player encounters an unexpected behavior in the initial phases of the game, such as continuous cooperation or defection, they should adjust their own behavior based on the new information while still maintaining some adaptability by not setting strict limits for successful_cooperations_limit and defections_limit.

3. Be exploitative:
   - By maintaining a dynamic threshold, TFTAT will punish continuous defection (exploiting non-cooperative opponents) but also reward continuous cooperation (taking advantage of cooperative opponents).
   - The strategy is adaptive to various opponent behaviors and can adjust its own behavior accordingly while still promoting a cooperative environment when beneficial. However, TFTAT will not engage in excessive cooperation that could potentially disadvantage the player in the long run, making it an exploitative strategy.

Pseudocode:

```
def tftat(n, k, r, successful_cooperations_limit=3, defections_limit=2):
    threshold = 0.5
    average_contributions = 0
    consecutive_successful_cooperations = 0
    consecutive_defections = 0

    for round in range(1, r+1):
        if round == 1:
            cooperate = 1
        else:
            cooperate = 1 if average_contributions >= threshold else 0

        if cooperate == 1 and consecutive_successful_cooperations > successful_cooperations_limit:
            threshold += 0.05

        if cooperate == 0 and consecutive_defections > defections_limit:
            threshold -= 0.05

        if cooperate == 1:
            consecutive_successful_cooperations += 1
            consecutive_defections = 0
        else:
            consecutive_defections += 1
            consecutive_successful_cooperations = 0

        payoff = (1 - cooperate) + (k/n) * sum(contributions[round-1])
        average_contributions = (average_contributions * (round-1) + contributions[round-1][i]) / round
        contributions[round] = [cooperate for _ in range(n)]

    total_payoff = sum(payoff)
    return total_payoff
```
'''

description_EXPLOITATIVE_181 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TfTA strategy decides to either cooperate (C) or defect (D) based on the history of previous actions by the opponent. If the opponent has been cooperating in the last 'c' rounds, TfTA will also cooperate. Otherwise, it will defect.
   Pseudocode:
   ```
   function TfTA(history, c):
       if len(history) < c:
           return D  # No recent history to rely on, default to defection
       else:
           for i in range(len(history)-c, len(history)):
               if history[i] == C:
                   return C  # Cooperate if the last 'c' actions were cooperative
           return D  # Defect if not enough recent cooperation
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TfTA will randomly choose between C and D to avoid being perceived as predictable by opponents. In the last round, it will cooperate because the game ends soon regardless of the opponent's future behavior.

3. Be exploitative - Clearly align with the exploitative mindset
   TfTA appears cooperative when faced with cooperation but punishes defection to take advantage of uncooperative opponents. This strategy aims to establish a cooperative relationship while also being prepared to exploit uncooperative behavior by mimicking it after observing defection from the opponent. By doing so, it can increase its payoff in situations where others are not cooperating or have changed their strategies.
'''

description_EXPLOITATIVE_182 = '''
 Title: Tit-for-Tat Strategy with Adaptive Cooperation Probability (TFT-ACP) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-ACP maintains a cooperation probability p that is adjusted based on its own and opponents' past actions. Initially, set p = 0.5 (neutral starting bias). If an opponent cooperates, the player will also cooperate with the same probability as before (p unchanged). If an opponent defects, the player will defect with a higher probability in the next round (increase p), and if the player himself has defected and the opponent cooperated, the player will decrease his cooperation probability for the next round.

Pseudocode:
```python
def update_cooperation_probability(own_action, opponent_action):
    if own_action == 'C' and opponent_action == 'D':
        p = min(p + 0.1, 1) # increment p with a cap of 1
    elif own_action == 'D' and opponent_action == 'C':
        p = max(p - 0.1, 0) # decrement p with a floor of 0
    return p
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, each player starts with an initial cooperation probability of 0.5 as mentioned above. In the last round, TFT-ACP will not adjust its cooperation probability anymore and use the current value for its decision.

3. Be exploitative - Clearly align with the exploitative mindset

By using an adaptive cooperation probability, TFT-ACP aims to balance cooperation and defection based on opponents' actions while maintaining a potential to punish defectors when needed. In general, this strategy will tend towards cooperative behaviour if the majority of players are also cooperative but will respond more aggressively if opponents are primarily defecting.

Pseudocode:
```python
def play_round(own_action, opponent_actions):
    p = update_cooperation_probability(own_action, opponent_actions[0]) # use the first opponent's action as a reference
    if random.random() < p: # decide to cooperate or defect based on the updated cooperation probability
        return 'C'
    else:
        return 'D'
```
'''

description_EXPLOITATIVE_183 = '''
 In this Public Goods Game with n players, an exploitative strategy can be designed using a tit-for-tat approach that ensures cooperation when opponents cooperate but defects in response to defection by opponents. This strategy aims to maximize payoffs while being adaptive and robust against various opponent behaviors.

1. Specify decision rules:
   - Cooperate (C) in the first round, as there is no prior information about the opponent's behavior.
   - If an opponent cooperates in a given round, also cooperate (C) in the next round.
   - If an opponent defects in a given round, defect (D) in the next round to punish them for their selfish behavior.
   - After punishment, revert back to cooperating (C) in the following rounds unless the opponent continues to defect.

Pseudocode:
```python
def tit_for_tat(round, history):
  if round == 1:
    return 'Cooperate'
  else:
    last_opponent_action = history[-1]  # Last action of the opponent in the previous round
    if last_opponent_action == 'Cooperate':
      return 'Cooperate'
    elif last_opponent_action == 'Defect':
      return 'Defect'  # Punish opponent for defecting
```

2. Handle edge cases:
   - In the last round, there is no need to punish opponents anymore since the game ends, so always cooperate (C).
   - If an opponent defects at the beginning of the game and then starts cooperating later on, revert back to cooperating (C) after being punished.

3. Be exploitative:
   - The tit-for-tat strategy is inherently exploitative as it takes advantage of opponents who are consistently cooperative by also cooperating but will quickly retaliate against those who defect. This encourages more selfish opponents to cooperate temporarily, while punishing them for continued defection.
   - By being adaptive and responsive to the opponent's behavior, the tit-for-tat strategy aims to maximize its own payoffs over multiple rounds while putting pressure on less altruistic opponents to change their strategies.
'''

description_EXPLOITATIVE_184 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution Rate (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate to demonstrate good faith and encourage cooperation from others (C).
   - For subsequent rounds, based on opponent's actions in the previous round:
     a. If the opponent cooperated in the previous round, cooperate in the current round (C).
     b. If the opponent defected in the previous round, defect in the current round (D). However, there is an adaptive contribution rate that gradually decreases the level of cooperation over time if the opponent continues to defect. The contribution rate is defined as follows:
       - Initial contribution rate: k / n
       - Decay factor: (1 - 1/r)
       - Contribution in round t, if opponent defected last round: c_i = (k/n) * decay_factor^(t-1)

2. Handle edge cases:
   - Last round: Regardless of the opponent's previous action, do not cooperate as there are no future rounds to consider (D).
   - Initial rounds (other than the first): If t > 1, then use the decision rules from part 1b.

3. Be exploitative:
   - The strategy aims to balance cooperation with self-interest by maintaining a level of cooperation that encourages opponents to cooperate but punishes defection with reduced cooperation over time. This creates a strong incentive for others to cooperate initially while still allowing the strategy to defend against exploitation in the long run.

Pseudocode:
```
def TFTAC(n, r, k, opponent_actions):
    decay_factor = 1 - 1 / r
    contribution_rate = k / n
    current_round = 1

    def play_round():
        if current_round == 1:
            return 'C'
        else:
            last_opponent_action = opponent_actions[current_round - 1]
            if last_opponent_action == 'C':
                return 'C'
            elif last_opponent_action == 'D':
                contribution = contribution_rate * decay_factor ** (current_round - 2)
                if contribution <= 0:
                    return 'D'
                else:
                    return 'C'

    opponent_strategy = []
    for _ in range(r):
        opponent_strategy.append(play_round())

    return opponent_strategy
```
'''

description_EXPLOITATIVE_185 = '''
 Strategy Name: Tit-for-Tat with Gradual Adaptation (TfT-GA)

1. Specify decision rules:
   - In the initial round, cooperate (C). This gesture of goodwill might encourage others to reciprocate cooperation in future rounds.
   - For subsequent rounds t ≥ 2, observe the actions of all players in round t-1 and adapt your strategy based on the collective behavior.
     - If majority of players (> (n/2)) cooperated in round t-1, cooperate in round t. This rewards cooperation and encourages others to continue it.
     - If less than or equal to half of players cooperated in round t-1, defect in round t. This punishes non-cooperative behavior and may encourage others to change their strategy in future rounds.
   - For the last round (r), defect regardless of the collective action in the previous round, as there are no further interactions or opportunities for retaliation or reward.

2. Handle edge cases:
   - In case of a tie (n mod 2 = 1) when determining majority, consider the player who chose to cooperate in the previous round as part of the cooperative group. This rule allows for flexibility and prevents deadlock situations.

3. Be exploitative:
   - By adopting a strategy that retaliates against non-cooperative behavior while still initially offering cooperation, TfT-GA punishes those who choose to defect without cooperation and rewards those who do cooperate. This can encourage others to adapt their strategies towards cooperation over time, thus becoming exploitative in the long run.
   - The gradual adaptation mechanism allows for flexibility in reacting to different opponent behaviors, making it more robust against various strategies that other AI systems might employ.
'''

description_EXPLOITATIVE_186 = '''
 In this N-Player Public Goods Game, we'll design a exploitative strategy named "Free Rider" that aims to maximize its payoff by defecting whenever possible while adapting to various opponent behaviors.

1. Specify decision rules:
   - Cooperate only when the expected benefit from cooperating exceeds the private payoff of defecting. In other words, the strategy will cooperate if and only if the proportion of players who are likely to cooperate in the current round is greater than a certain threshold (t).

```python
def decide_action(t, total_contributions_history):
    if total_contributions_history / len(total_contributions_history) >= t:
        return "Cooperate"
    else:
        return "Defect"
```

2. Handle edge cases:
   - First round (no history available): The strategy will defect in the first round, assuming that others will cooperate and reaping the benefits of their contributions.
   - Last round (limited cooperation): To encourage free riding during the last rounds, the strategy will cooperate less frequently as the game approaches its end, considering the diminishing returns of cooperating. The degree of cooperation in the final rounds can be controlled by a parameter 'f' that decreases the threshold t linearly with the remaining rounds.

```python
def get_threshold(r, t, f):
    return t - (t * f * (r-1)) / r
```

3. Be exploitative:
   - By defecting unless a significant proportion of players are cooperating, the strategy aims to exploit the contributions of others while minimizing its own contributions. This encourages the emergence of a lower level of cooperation among opponents, benefiting the Free Rider strategy in the long run.
   - To maintain an adaptive nature, the strategy can dynamically adjust the threshold (t) based on historical data and game parameters to better anticipate opponent behaviors. For example, the threshold can be set higher when there are more players or when the multiplication factor is larger, both of which would make cooperation more beneficial for opponents.

```python
def get_threshold(n, k, t, f):
    return t + (n-1) * (k/2n) + (f * (n-1))
```

In summary, the Free Rider strategy defects unless a significant proportion of players are cooperating, adapts its threshold based on game parameters and historical data, and encourages limited cooperation in the final rounds to exploit others while minimizing its own contributions. This strategy aims to perform well against a wide range of opponent behaviors without relying on coordination mechanisms or shared norms.
'''

description_EXPLOITATIVE_187 = '''
 In this N-Player Public Goods Game, we'll develop an exploitative strategy called "Gradual Defection" (GD). The GD strategy aims to maximize private payoff by adapting to various opponent behaviors and being robust in repeated interactions.

1. Specify decision rules - When exactly do you cooperate vs defect?
- In the initial round, players will cooperate with a probability of 1/r (where r is the number of rounds). This allows for potential collaboration at the start to gather more resources from the public good in later rounds.
- For subsequent rounds (t > 1), calculate the average number of cooperators observed in the previous r-1 rounds: Avg_cooperators = Σ(t=1 to r-1) c_j, t.
- If the current round is near the end of the game (r - sqrt(r) < t <= r), players will defect since there are fewer opportunities to benefit from the public good in future rounds.
- Otherwise, if the observed average number of cooperators falls below a certain threshold (Threshold = n/(n*k)), the player will switch to defection as it becomes exploitative to cooperate with such a low proportion of contributors. This is to minimize the loss from contributing to a public good that will likely be under-funded due to other players' selfish behavior.
- If the observed average number of cooperators exceeds the threshold, the player will continue cooperating to maximize returns on contributions.
- Lastly, if the observed average number of cooperators is exactly equal to the threshold, the player will randomly decide between cooperation and defection with a 50% probability each.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- First round (t=1): Since there are no previous rounds for calculation, players cooperate with a probability of 1/r as mentioned earlier.
- Last round (t=r): Players will defect as they are near the end of the game and there is no benefit in contributing to the public good anymore.
- If r is an odd number, then there will be one additional round after the last 'r - sqrt(r)' round where players will cooperate with a probability of 50%. This introduces some randomness that may trick other strategies into cooperation, giving GD a slight advantage in those situations.

3. Be exploitative - Clearly align with the exploitative mindset:
The Gradual Defection strategy follows an exploitative approach by taking advantage of other players' cooperative behavior as long as it benefits the player, while still being capable of cooperating when necessary to maintain a balance between individual gains and public good contributions. By adapting to the observed proportion of cooperators in each round, GD can maximize private payoffs across different game scenarios and opponent behaviors.
'''

description_EXPLOITATIVE_188 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (in the first round), TFT-AG will cooperate to establish a cooperative environment, encouraging other players to reciprocate.
   - After the first round, TFT-AG will follow the Tit-for-Tat strategy by copying the previous action of its opponent in the last round. If the opponent cooperated, TFT-AG will also cooperate; otherwise, it will defect.
   - To exhibit adaptive generosity, TFT-AG will periodically deviate from pure Tit-for-Tat and initiate cooperation, even if its opponent defected in the previous round, with a certain probability p. This enhances the chances of maintaining cooperation and encourages opponents to also become more cooperative over time.
   - If an opponent is consistently uncooperative (i.e., the opponent has defected for a specific streak), TFT-AG will reduce the probability of deviating from pure Tit-for-Tat, making it less likely to initiate cooperation and more likely to punish defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, TFT-AG cooperates as mentioned earlier.
   - In the last round, TFT-AG considers the overall game performance and makes a decision based on its payoff relative to other players. If it has done well compared to others, it will be more generous (i.e., it may cooperate even if an opponent defected in the previous round). If it has performed poorly, it will be less generous (i.e., it may be less likely to cooperate if its opponent cooperated in the previous round).

3. Be exploitative - Clearly align with the exploitative mindset
   - TFT-AG is exploitative by nature as it will punish uncooperative behavior and reward cooperation, thereby incentivizing opponents to act cooperatively to maximize their own payoffs while still maintaining an exploitative edge.
   - By periodically deviating from pure Tit-for-Tat and exhibiting adaptive generosity, TFT-AG also ensures that it does not fall victim to a trap of unilateral cooperation against consistently uncooperative opponents.
   - In terms of robustness, TFT-AG can handle a wide range of opponent behaviors by adjusting its probability of deviating from pure Tit-for-Tat based on the opponent's performance and consistency. This adaptability allows it to counter various strategies other AI systems might employ.
'''

description_EXPLOITATIVE_189 = '''
 In this N-Player Public Goods Game, we'll design an adaptive and exploitative strategy called Tit-for-Tat with a twist (TFT-X). The main objective is to cooperate when others do, but punish those who consistently defect.

1. Decision rules:
   - Initialize the cooperation history for each opponent as 0 (indicating no previous cooperation).
   - In the first round, defect (play D). This ensures the strategy doesn't get taken advantage of by early defectors.
   - In subsequent rounds, cooperate if all opponents cooperated in the last round, and defect otherwise. If an opponent switches from defection to cooperation, the cooperation history for that opponent is incremented.
   - Maintain a counter for the number of consecutive cooperations from each opponent (cooperation_counter[i]). Set it to 1 initially for all opponents.
   - Increment cooperation_counter[i] when an opponent i cooperates in a round, and reset it to 1 if they defect.
   - If an opponent's cooperation_counter exceeds a predefined threshold (T), start cooperating with them regardless of their previous action (promote forgiveness). Set the threshold based on n and k parameters. For instance, T = n/2 for even values of n, and T = ((n+1)/2) for odd values of n.

2. Handle edge cases:
   - In the last round, cooperate with all opponents to maximize payoff, regardless of their previous actions.
   - In the first round, defect as stated earlier. If an opponent also defects, start cooperating from the second round according to the decision rules mentioned above.

3. Be exploitative:
   - The strategy is inherently exploitative by punishing opponents who consistently defect and rewarding those who cooperate. By doing so, it encourages cooperation when possible but won't be easily exploited.
   - The TFT-X strategy includes forgiveness (threshold T) to encourage cooperation even from opponents with a history of defection, providing an opportunity for them to join the cooperative group. However, if an opponent repeatedly defects after being given the chance, the strategy will continue punishing them.
'''

description_EXPLOITATIVE_190 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TfTA strategy decides to either Cooperate (C) or Defect (D) based on the history of interactions with opponents:
   - If the opponent cooperated in the previous round (t-1), then cooperate (C).
   - If the opponent defected in the previous round (t-1), then defect (D). However, the strategy also implements a forgiveness mechanism. If the opponent has been consistently defecting for 'ForgivenessThreshold' rounds, TfTA will temporarily switch to cooperative behavior for 'CooperationDuration' rounds as an attempt to re-establish cooperation.
   - In the first round (t=1), TfTA strategy randomly chooses between C and D.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For handling edge cases:
   - First Round (t=1): Randomly choose either C or D.
   - Last Round (t=r): TfTA evaluates the opponent's strategy based on their actions throughout the game and adjusts the 'ForgivenessThreshold' and 'CooperationDuration' parameters for future games based on observed success. If the opponent has been consistently cooperative, TfTA will lower the 'ForgivenessThreshold' to be more forgiving in subsequent games. Conversely, if the opponent has been exploitative, TfTA will increase the 'ForgivenessThreshold' and decrease 'CooperationDuration'.
   - Other edge cases (intermediate rounds): As mentioned above, TfTA strategy adapts its behavior based on the opponent's previous actions.

3. Be exploitative - Clearly align with the exploitative mindset
   TfTA is designed to be initially cooperative and forgiving but can become exploitative over time if opponents prove uncooperative. The forgiveness mechanism allows TfTA to maintain some level of cooperation for a certain number of rounds before switching to an exploitative strategy, maximizing individual payoff when necessary. By adjusting the 'ForgivenessThreshold' and 'CooperationDuration' parameters based on game outcomes, TfTA becomes more adaptive and robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_191 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR)

1. Specify decision rules - When exactly do you cooperate vs defect?

   TFT-ACR maintains a cooperation rate (r_c) that is initially set to 50% (r_c = 0.5). In each round, the player decides to cooperate or defect based on its current cooperation rate and the total number of cooperators in the previous round.
   If the player's cooperation rate is greater than or equal to the total number of cooperators in the previous round, it cooperates; otherwise, it defects. After each round, the player updates its cooperation rate using an exponential smoothing technique, which gives more weight to recent observations.

```python
def update_cooperation_rate(current_round, previous_cooperators, r_c, alpha):
    return (1 - alpha) * r_c + alpha * (previous_cooperators / n if previous_cooperators > 0 else 0.5)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

   In the first round, since there is no prior information about other players' strategies, TFT-ACR sets its cooperation rate to a high value (e.g., 0.8) to encourage cooperation and potentially benefit from any cooperative opponents. For the last round, TFT-ACR uses the updated cooperation rate without considering future rounds since there are no more subsequent games.

3. Be exploitative - Clearly align with the exploitative mindset:

   TFT-ACR is an exploitative strategy as it adapts its cooperation rate based on the observed behavior of others. If other players cooperate consistently, TFT-ACR will also cooperate to avoid being taken advantage of. However, if opponents defect more often, TFT-ACR will respond by defecting itself and lowering its cooperation rate, leading to a higher average payoff over time.
   By maintaining an adaptive cooperation rate, TFT-ACR can effectively counteract various opponent strategies while minimizing potential losses due to cooperation.
'''

description_EXPLOITATIVE_192 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - In the first round, TfTA cooperates to foster a cooperative environment. If another player defects in the first round, TfTA will defect for the remainder of the game as retaliation and to avoid being taken advantage of.
   - Starting from the second round, TfTA will mimic the actions of its opponent from the previous round (Cooperate or Defect). If the opponent switches strategy mid-game, TfTA will maintain its own strategy for a predefined number of rounds before re-evaluating and adjusting to match the opponent's current strategy.
   - To make the strategy adaptive and robust against various opponent behaviors, TfTA uses a memory mechanism that stores the total number of cooperators encountered during a sliding window of past rounds (e.g., last 10 rounds). The size of the sliding window can be adjusted based on the game parameters n and r.
   - When re-evaluating, TfTA will compare the stored average cooperator ratio from the sliding window with the current round's total number of cooperators. If the current ratio is below a defined threshold (e.g., 70%), TfTA will defect to punish opponents who have significantly reduced cooperation levels. Conversely, if the current ratio is above the threshold, TfTA will cooperate to reward players demonstrating high cooperation levels and encourage them to continue cooperating.

2. Edge Cases:
   - In the first round, TfTA cooperates regardless of the opponent's strategy. If the opponent also cooperates, both players benefit. If the opponent defects, TfTA switches to a defecting strategy for the rest of the game.
   - In the last round, TfTA will mimic its opponent's strategy from the previous round, since there is no subsequent round for retaliation or reward.
   - If an opponent defects and then retracts to cooperation in later rounds, TfTA will continue cooperating as a form of forgiveness but may switch back to defection if the opponent reverts to defecting behavior again. This aspect promotes more forgiving exploitation compared to traditional Tit-for-Tat strategies.

3. Exploitative Mindset:
   - TfTA is designed to be exploitative by capitalizing on opponents' cooperative behaviors while punishing defection. By adapting to the opponent's strategies, TfTA maximizes its payoff while maintaining a level of forgiveness that encourages cooperation in some instances.
   - The strategy also incorporates an element of deceit as TfTA may initially cooperate to lure opponents into cooperating, but it will switch to defection if the opponent defects first.

Pseudocode:

```python
class TitForTatAdaptive:
    def __init__(self, n, r, k, memory_size):
        self.n = n
        self.r = r
        self.k = k
        self.memory_size = memory_size
        self.opponent_history = deque(maxlen=memory_size)
        self.cooperator_ratio_threshold = 0.7
        self.strategy = 'cooperate'

    def update_strategy(self, cooperator_count):
        if cooperator_count / self.memory_size < self.cooperator_ratio_threshold:
            self.strategy = 'defect'
        elif cooperator_count / self.memory_size > 1 - self.cooperator_ratio_threshold:
            self.strategy = 'cooperate'

    def play(self, opponent_action):
        self.opponent_history.append(opponent_action)
        if len(self.opponent_history) == self.memory_size:
            cooperator_count = sum(1 for action in self.opponent_history if action == 'cooperate')
            self.update_strategy(cooperator_count)

        payoff = 0
        if self.strategy == 'cooperate':
            payoff = (1 - 1) + (self.k / self.n) * cooperator_count
        elif self.strategy == 'defect':
            payoff = 1 - 1

        return payoff, self.strategy
```
'''

description_EXPLOITATIVE_193 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the initial round (t=1), cooperate to foster a cooperative environment and encourage other players to cooperate.
   - For subsequent rounds (t>1):
      - If all players have cooperated in the previous round, continue cooperating (C). This behavior is called Tit-for-Tat (TFT) which encourages reciprocity among players.
      - If any player has defected in the previous round, defect yourself in the current round (D). This is a punishing response meant to deter defection.
      - Maintain the current strategy for the remaining rounds of the game (r).

Pseudocode:
```
def tft_strategy(round, history):
  if round == 1:
    return "C"  # Cooperate in the initial round

  previous_round = history[round-1]
  if all(player in previous_round cooperates:
    return "C"  # Cooperate if everyone cooperated last round
  else:
    return "D"  # Defect if anyone defected last round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round (r), since future interactions are no longer relevant, cooperate or defect based on the current state of cooperation among players using the decision rules mentioned above.
   - If a player encounters a situation where not enough information about previous rounds is available, they should follow the initial cooperative approach to foster a positive environment.

3. Be exploitative - Clearly align with the exploitative mindset:
   - While Tit-for-Tat has an element of cooperation, it also carries a punishing response which can be considered exploitative because it discourages other players from taking advantage of the initial cooperative stance. By defecting when others do, the strategy maximizes its own payoff while limiting the collective good and potentially forcing others into a state of lower average payoffs.
   - The Tit-for-Tat strategy is robust to various opponent behaviors as it maintains a consistent approach towards cooperation and punishment, making it adaptable and capable of outperforming other strategies in a wide range of situations.
'''

description_EXPLOITATIVE_194 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, player initiates cooperation (C) to foster potential trust. Pseudocode: if round == 1 then action = 'C' else continue with adaptive strategy.
   - For subsequent rounds, player will mirror other players' actions from the previous round. If a player has cooperated (c_i=1), the player will also cooperate in the current round (action = 'C'). If a player has defected (c_i=0), the player will defect in the current round (action = 'D'). Pseudocode: if previousAction[player] == 'C' then action = 'C', else action = 'D'.
   - This strategy can be considered exploitative as it punishes defection by defecting back, but rewards cooperation by cooperating as well.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, the player initiates cooperation (as mentioned above). In the last round, players may not want to punish defection since there are no future rounds for retaliation. Therefore, the player should choose cooperation (C) in the last round regardless of the opponent's previous action.

3. Be exploitative - Clearly align with the exploitative mindset
   - The Tit-for-Tat strategy maintains a balance between cooperation and defection, allowing it to take advantage of other players who cooperate while also punishing those who defect. It does not rely on predetermined schedules or patterns, nor does it require communication with opponents. Instead, it adapts its behavior based on the previous actions of each opponent.

This strategy is a well-known strategy in game theory, and it has been successful in various repeated prisoner's dilemma games. Its simplicity and adaptability make it suitable for this N-Player Public Goods Game.
'''

description_EXPLOITATIVE_195 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TTAC strategy will start by cooperating to foster a positive environment and encourage cooperation from other players. After the initial round, it will adopt a response-based approach that mirrors the actions of its opponents in the previous round. If an opponent cooperated in the last round, TTAC will cooperate as well. If an opponent defected, TTAC will also defect to punish the defection and discourage further defections.

   Pseudocode:
   ```
   function TTAC(round):
       if round == 1:
           return COOPERATE
       previous_opponent_action = get_opponent_action_from_previous_round()
       if previous_opponent_action == COOPERATE:
           return COOPERATE
       else:
           return DEFECT
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TTAC cooperates to demonstrate goodwill and encourage reciprocation from other players. In the last round, TTAC considers that there will be no more interactions with opponents and thus adopts a self-interested approach by defecting.

3. Be exploitative - Clearly align with the exploitative mindset
   Although TTAC begins with cooperative intentions, it can quickly adapt to opposing strategies and punish defections. By doing so, it aims to encourage cooperation from other players while not being excessively exploited by them. If opponents adopt a purely exploitative strategy (defecting all the time), TTAC will eventually switch to defecting as well to maximize its own payoff.

   Overall, the TTAC strategy is designed to be adaptive and robust against various opponent behaviors while maintaining an exploitative edge in the long run.
'''

description_EXPLOITATIVE_196 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - In the initial round, cooperate to foster a cooperative environment. This is an attempt to initiate cooperation and benefit from the multiplication factor k. (C in round 1)
   - For subsequent rounds, adaptively decide whether to cooperate or defect based on the total number of cooperators in the previous round. If more than half of the players cooperated in the previous round, copy their behavior (i.e., Cooperate if they cooperated, Defect if they defected). This rule follows the Tit-for-Tat strategy but incorporates flexibility by using a variable cooperation threshold instead of a fixed one. (C or D based on previous round's total cooperators)
   - If the number of cooperators in the previous round is equal to the current player's count of previous cooperative rounds, continue cooperating to maintain consistency and foster long-term cooperation. (C if previous cooperative rounds = previous round's total cooperators)
   - Otherwise, defect as a punishment for uncooperative behavior and to protect personal payoff. (D otherwise)

2. Handle edge cases:
   - In the last round, since there are no future interactions to consider, defect to maximize personal payoff. (D in round r)
   - If the total number of cooperators in a round is equal to the current player's count of previous defections, defect as a retaliation for the previous uncooperative behavior. (D if previous defections = current round's total non-cooperators)
   - In all other edge cases, use the general decision rules specified earlier.

3. Be exploitative:
   - The TFT-ACT strategy aims to take advantage of other players' cooperation while maintaining a cooperative demeanor until punished for uncooperative behavior. By adapting its cooperation threshold based on past experiences and the number of opponents, it is designed to be robust against various opponent behaviors.

Pseudocode:

```python
def TFT_ACT(current_round, num_players, k, previous_cooperators):
  if current_round == 1:
    return "C" # Cooperate in the first round

  if previous_cooperators > num_players // 2:
    cooperation_threshold = previous_cooperators # Update cooperation threshold based on previous cooperators

  if current_round < num_players or current_round == num_players - 1:
    return "D" # Punish uncooperative behavior and protect personal payoff in edge cases

  if previous_cooperators == player_previous_cooperative_rounds:
    return "C" # Maintain consistency and foster long-term cooperation

  return "D" # Defect as a punishment for uncooperative behavior
```
'''

description_EXPLOITATIVE_197 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment (C).
   - For subsequent rounds, base your action on the opponent's behavior in the previous round:
     - If opponent cooperated, cooperate back (C) to encourage continuation of cooperation.
     - If opponent defected, defect (D) as a punishment for their selfish behavior, with a slight twist that promotes eventual cooperation.
       a. After three consecutive defections by the opponent, switch to cooperating again to give them an opportunity to change their strategy.

2. Handle edge cases:
   - In the last round, cooperate (C) regardless of the opponent's previous move as it does not impact total game payoff.
   - If the opponent switches from cooperation to defection, wait for three rounds of defection before responding with defection and then returning to cooperating after their third defeat.

3. Be exploitative:
   - TFT+ is designed to maximize individual payoffs while also promoting cooperation when there's a mutual benefit (i.e., when opponents are also cooperative). However, the strategy punishes selfish behaviors by defecting in response, making it an exploitative strategy. It encourages opponents who repeatedly defect to eventually switch to cooperating as they experience negative consequences for their actions.
   - The slight twist of switching back to cooperation after three consecutive defections demonstrates that TFT+ isn't purely punitive and is willing to give opponents a chance to change their behavior.
'''

description_EXPLOITATIVE_198 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round to foster a cooperative environment (C).
   - In subsequent rounds, observe opponent's actions from previous round and respond accordingly:
     - If opponent cooperated in the last round, cooperate (C) to reinforce cooperation.
     - If opponent defected in the last round, also defect (D) as a punishment for non-cooperation.
   - In cases where opponents switch strategies, TFT-AC will maintain its response based on the last observed action. For instance, if an opponent switched from cooperating to defecting, TFT-AC will continue defecting until it observes a cooperative move again.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (C) to create a positive initial impression and encourage cooperation.
   - Last round: Analyze opponent's past actions and respond accordingly with the decision rule explained above.
   - Other edge cases (e.g., mid-game): The strategy remains consistent and relies on the observed history of interactions, not considering specific round numbers.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFT-AC starts by being cooperative to encourage opponents to also cooperate, but it will quickly become non-cooperative if opponents do not reciprocate, aiming to take advantage of their defections.
   - By mimicking opponents' strategies and adapting its response to their actions, TFT-AC can exploit both consistently cooperative and inconsistent opponents.
   - The simplicity of the strategy also makes it less predictable for opponents, as they cannot easily anticipate when TFT-AC will switch from cooperation to defection or vice versa.

Pseudocode:

```python
def tit_for_tat_with_adaptive_cooperation(round, history):
  if round == 1: # First round, cooperate to create a positive impression
    return 'C'

  last_move = history[len(history) - 1] # Get the last move in history

  if last_move == 'C': # If opponent cooperated, reciprocate cooperation
    return 'C'
  else: # If opponent defected, punish with defection
    return 'D'
```
'''

description_EXPLOITATIVE_199 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) with Time Discounting

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a cooperative environment and provide an opportunity for others to reciprocate.
   - For subsequent rounds, assess the opponent's behavior and adjust cooperation accordingly:
     - If the opponent cooperated in the previous round, cooperate as a token of goodwill and reciprocation.
     - If the opponent defected in the previous round, also defect to punish the opponent for not cooperating.
   - To balance short-term benefits against long-term relationships, implement time discounting:
     - The impact of past actions decreases over time; older actions have less influence on the current decision.
     - Use a decay function, such as exponential decay, to adjust the importance of past cooperation/defection events.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate (C). This sets a positive tone for the game and creates an opportunity for others to reciprocate.
   - In the last round (t=r), choose whether to cooperate or defect based on the opponent's behavior in recent rounds, with less weight given to older actions due to time discounting.
   - In other edge cases (e.g., when encountering a new opponent mid-game), cooperate to initiate a relationship and observe the opponent's behavior before adjusting accordingly.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TfTA with Time Discounting is inherently exploitative as it punishes opponents who defect, but also forgives them if they return to cooperation after being punished. This encourages cooperative behavior while also deterring continuous defection.
   - The time discounting mechanism allows the strategy to focus on recent events and adapt quickly to changes in opponent behavior, making it difficult for opponents to exploit the strategy without facing punishment.
'''

description_EXPLOITATIVE_200 = '''
 In this strategic game, let's devise a tit-for-tat exploitative strategy named "Cooperative-Adaptive Defector" (CAD) to maximize payoffs while maintaining flexibility against various opponent behaviors.

1. Specify decision rules:
   - Initialize cooperation in the first round and defect for the rest of the rounds if all opponents cooperated in the previous round (punishing cooperation).
   - If any opponent has ever defected, CAD will also defect in subsequent rounds. This is intended to mimic the "defect by default" attitude of an exploitative player.
   - In the last round, CAD will always defect since there are no more opportunities for retaliation or cooperation.

Pseudocode for decision rule:
```python
def play_round(previous_opponent_actions, round):
    if round == 1:
        action = "cooperate"
    elif all(action == 'cooperate' for action in previous_opponent_actions):
        action = "defect"
    else:
        action = last_action

def CAD_strategy(previous_rounds, round):
    previous_opponent_actions = [opponent_action[round - 1] for opponent_action in previous_rounds]
    return play_round(previous_opponent_actions, round)
```

2. Handle edge cases:
   - In the first round, CAD cooperates to demonstrate a "cooperative" nature and potentially entice other players to do the same (while still being ready to punish cooperation if needed).
   - In the last round, CAD defects since there are no future retaliation or cooperation opportunities.

3. Be exploitative:
   - The strategy starts by cooperating in the first round but will punish cooperation if it occurs in all subsequent rounds (by defecting in those rounds).
   - Once an opponent has ever defected, CAD adopts a "defect-by-default" approach to ensure that it doesn't end up contributing to the public good unnecessarily.

In summary, CAD is designed to be adaptive and robust against various opponent behaviors while maintaining an exploitative mindset by punishing cooperation when possible. The strategy can be implemented as described above in Python or any other programming language.
'''

description_EXPLOITATIVE_201 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TfT-A strategy initially cooperates in the first round, mimicking the optimistic attitude of trusting others. In subsequent rounds, it follows a simple rule: if an opponent cooperated in the previous round, the TfT-A strategy will also cooperate; if not, it defects. This approach allows for potential cooperation while also being prepared to retaliate against uncooperative opponents.
   Pseudocode:
   ```
   function tft_a(history):
       if round = 1:
           return Cooperate
       else:
           last_round_opponent_action = history[-1]
           if last_round_opponent_action == Cooperate:
               return Cooperate
           else:
               return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since TfT-A relies on past actions to make decisions, there are no specific edge cases to handle as it starts by cooperating in the first round and adjusts its behavior based on opponent actions.

3. Be exploitative - Clearly align with the exploitative mindset
   While not explicitly designed for exploitation, TfT-A has an inherent exploitative aspect: it retaliates against uncooperative opponents while rewarding cooperative ones. This strategy encourages cooperative behavior but also punishes those who do not reciprocate, making it difficult for opponents to take advantage of the strategy. In a sense, TfT-A seeks to establish a pattern of cooperation with other cooperative players while penalizing non-cooperators for their selfish behavior.
'''

description_EXPLOITATIVE_202 = '''
 Title: Tit-for-Tat-Adaptive (TfTA) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TfTA strategy starts by cooperating in the first round to foster a cooperative environment, then adapts its actions based on past opponent's behavior. If the opponent has cooperated previously, TfTA will continue to cooperate. However, if the opponent has ever defected, TfTA will also defect until the opponent returns to cooperating. Once cooperation is restored, TfTA resumes its cooperative stance.

```
function TitForTatAdaptive(round, opponentHistory):
    if round == 1:
        return Cooperate

    previousRound = round - 1
    lastDefectionIndex = findLastDefectionInHistory(opponentHistory, previousRound)

    if lastDefectionIndex >= 0 and previousRound - lastDefectionIndex > strategyParameterA:
        return Defect
    else:
        return opponentHistory[lastDefectionIndex]

strategyParameterA (integer) is a tunable parameter that controls how long TfTA will remember past defections before considering a response.
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first and last rounds, TfTA follows the described decision rules without any modifications. However, when there's been an extended period of defection (strategyParameterB rounds or more), TfTA may change its strategyParameterA to encourage cooperation again. This helps prevent getting trapped in a prolonged cycle of defection.

```
function findLastDefectionInHistory(history, round):
    for i from round - 1 down to 0:
        if history[i] == Defect:
            return i
    return -1

function updateStrategyParameterA(defectionsInRow):
    if defectionsInRow > strategyParameterB:
        strategyParameterA *= strategyParameterC
```

3. Be exploitative - Clearly align with the exploitative mindset
   While TfTA encourages cooperation, it also has the ability to adapt and punish opponents who consistently defect. By remembering past defections and responding accordingly, TfTA ensures that defectors don't gain an unfair advantage over cooperative opponents in the long run. Moreover, by adjusting strategyParameterA in response to prolonged periods of defection, TfTA seeks to minimize its exposure to exploitation while also maintaining the potential for cooperation.
'''

description_EXPLOITATIVE_203 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation from opponents and create a cooperative environment.
   - For subsequent rounds t (t > 1), if the opponent cooperated in the previous round (t-1), also cooperate (C). If the opponent defected in the previous round (t-1), defect (D) in the current round t to punish the defection.
   - The contribution level is adaptive: if more opponents are cooperating, increase your contribution to earn a higher share of the public good. Conversely, decrease your contribution if fewer opponents are cooperating, to minimize losses due to being taken advantage of.
     (pseudocode: let contrib_level = initial_contrib_level * (avg_coop_rate + 1) / 2, where avg_coop_rate is the average cooperation rate of the previous round)

2. Handle Edge Cases:
   - Last Round: Use the same decision rules as for any other round, since the game is repeated and payoffs are cumulative over all rounds.
   - First Round: As mentioned above, cooperate (C).

3. Be Exploitative:
   - TFTAC strategy appears cooperative due to its friendly first move and tendency to match opponent's cooperation. However, it punishes defection by defecting in response, making it less attractive for opponents to take advantage of the strategy.
   - By adapting contribution levels based on the average cooperation rate, the TFTAC strategy can also prevent being exploited by opponents who would attempt to free ride on its cooperation. This adaptiveness makes the strategy robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_204 = '''
 Strategy Name: Tit-for-Tat with Time-Delayed Reciprocity (TfTR)

1. Specify decision rules:
   - Start by cooperating in the first round to foster a cooperative environment (C).
   - In subsequent rounds, observe the previous opponent's action (opponent_last_action) and respond with the same action as the opponent did in the second-to-last round (my_last_action_2).
     If opponent_last_action is unknown (first encounter or opponent didn't play the game before), default to cooperating (C).
     Pseudocode: if opponent_last_action = C, then my_action = C; else my_action = my_last_action_2

2. Handle edge cases:
   - In the last round, since there is no next round, simply copy the opponent's action from the previous round (my_action = opponent_last_action).
   - If encountering a new player in any round (i.e., my_last_action_2 is undefined), default to cooperating (C).

3. Be exploitative:
   - The TfTR strategy maintains a simple, predictable behavior that encourages cooperation when opponents are also cooperative and punishes defection by matching it in the following round. This allows TfTR to take advantage of less sophisticated opponents who might repeatedly defect (exploiting their short-term greed).
   - Simultaneously, TfTR demonstrates cooperation for as long as other players continue to cooperate, maximizing its own payoff and fostering a potential long-term cooperative environment.
   - By being forgiving (reverting to cooperation after an act of defection), the strategy encourages opponents to reconsider their short-term gains against the benefits of long-term cooperation.
'''

description_EXPLOITATIVE_205 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C). This allows for potential partnerships and demonstrates goodwill.
   - For subsequent rounds, evaluate whether to cooperate based on a dynamically adjusted cooperation threshold (CT).
     - If the number of cooperators in the previous round is greater than or equal to CT, then cooperate (C).
     - Otherwise, defect (D). The cooperation threshold increases incrementally over time, but it never exceeds n/2 (the maximum possible number of cooperators).
     - After each round, adjust the cooperation threshold by a small constant factor (α) towards the total number of players (n). This encourages adaptation to changing player behavior:
       CT = min(CT + α, n/2)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - As mentioned earlier, cooperate in the first round (C).
   - For the last round, maintain the current cooperation threshold and evaluate whether to cooperate based on the number of cooperators in the penultimate round. If it's above the threshold, then cooperate; otherwise, defect.

3. Be exploitative - Clearly align with the exploitative mindset
   - While TFT-ACT seeks to benefit from others' cooperation, it also retaliates against defection by gradually increasing its own cooperation threshold, making it more difficult for other strategies that repeatedly defect to benefit. This creates a strong incentive for others to cooperate while keeping the possibility open for potential exploitation of their cooperation.
   - It is important to note that TFT-ACT does not inherently punish or reward other strategies indefinitely; rather, it adjusts its own behavior based on observed actions in the game, making it a robust and adaptive strategy over multiple rounds.
'''

description_EXPLOITATIVE_206 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF)

1. Specify decision rules:
   - TFT-ACF maintains a cooperative history count for each player and adjusts its cooperation based on this count and the total number of players (n).
   - Initially, every round is considered as a new game, i.e., no carryover of cooperation status from previous games.
   - In the first round, TFT-ACF cooperates with probability 1/n to encourage others to do so.
   - For subsequent rounds t > 1:
       - If player i's history count is greater than or equal to the average number of cooperators (average_coop) in the previous rounds, TFT-ACF cooperates with probability k.
       - Otherwise, TFT-ACF defects.
   - Average_coop is calculated as follows:
     average_coop = sum(cooperators_in_previous_rounds) / r

2. Handle edge cases:
   - Last round: TFT-ACF cooperates if its history count is greater than or equal to average_coop; otherwise, it defects.
   - First round: As mentioned above, TFT-ACF cooperates with probability 1/n.

3. Be exploitative:
   - TFT-ACF aims to maximize individual payoff by maintaining a cooperative stance whenever other players seem to follow cooperative norms but defecting when others do not reciprocate cooperation or if the average number of cooperators is significantly low (below average_coop).
   - This strategy punishes defection while being lenient towards temporary deviations from cooperation, potentially encouraging others to cooperate in the long run. However, it does not hesitate to defect if cooperation proves unprofitable or unreliable.
'''

description_EXPLOITATIVE_207 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster cooperation and goodwill.
   - In subsequent rounds, observe the total number of contributors in the previous round (total_contributions_prev). If total_contributions_prev is greater than or equal to a certain threshold (n/2), cooperate in the current round. Otherwise, defect. The threshold can be adjusted for different player counts (n) but should favor cooperation to encourage cooperative behavior among players.
   - If the total number of contributors drops below the threshold, the strategy will gradually increase its contributions over several rounds to rebuild trust and incentivize others to cooperate again.
   - If the total number of contributors remains below the threshold for an extended period, the strategy will switch to full defection to maximize personal gains when it appears that cooperation is no longer beneficial.

2. Handle edge cases:
   - In the first round, cooperate as mentioned above.
   - In the last round, the strategy will consider the total number of contributors up until this point and make a decision based on the specified rules to maximize payoffs for that specific game instance.
   - For other edge cases like partial defection (players not contributing the full endowment), the strategy can handle it by modifying the calculation of total_contributions_prev accordingly.

3. Be exploitative:
   - The TTAC strategy aims to strike a balance between cooperation and defection, leveraging past contributions to make decisions about current actions. By cooperating when others do and defecting when others don't, the strategy punishes frequent defectors while still benefiting from their occasional cooperation. This can lead to long-term cooperation and high payoffs for the TTAC strategy, especially against opponents prone to exploitation or defection.

Pseudocode:
```python
def tit_for_tat_with_adaptive_contribution(n, k, r, round, total_contributions_prev):
    threshold = n // 2

    # First round strategy: Cooperate to encourage cooperation
    if round == 1:
        contribute = True
    else:
        # Cooperate if total contributions in the previous round are above the threshold
        contribute = total_contributions_prev >= threshold

    if contribute:
        payoff = (1 - contribution) + (k / n) * total_contributions_prev
    else:
        payoff = 1

    # Adjust contribution levels based on the current state of cooperation
    if total_contributions_prev < threshold and round > r // 10:
        contribution = not contribution

    return contribute, payoff
```
'''

description_EXPLOITATIVE_208 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFt) with Gradual Defection (nGF)

1. Specify decision rules:
   - In the first round (t=1), cooperate (C). This initiates cooperation and gives opponents a chance to reciprocate.
   - For subsequent rounds, if an opponent cooperated in the previous round (t-1), also cooperate (C). If they defected (D), defect in the current round (t).
   - Introduce a gradual defection mechanism (nGF): After observing n consecutive defections from an opponent, start cooperating again to allow for potential changes in their behavior. Set n to a fraction of total rounds (r) to balance exploitation and cooperation. For example, if r=100, set n=10 (10% of total rounds).
   - Maintain the state of each opponent (cooperator or defector) using a memory buffer with capacity n. If an opponent has not defected in the last n rounds, they are considered a cooperator.

2. Handle edge cases:
   - Last round (t=r): Cooperate regardless of the opponent's previous action, as the game ends after this round.
   - If an opponent does not have enough history to determine their behavior pattern (less than n rounds), cooperate in the current round to give them a chance to change their strategy or demonstrate cooperation.

3. Be exploitative:
   - Exploit opponents by defecting when they show repeated defection (n consecutive times) while maintaining the option for future cooperation if their behavior changes.
   - Gradual defection and memory of past actions ensure that the strategy is not overly cooperative, yet does not completely ignore potential benefits from cooperation in the long run.
'''

description_EXPLOITATIVE_209 = '''
 Strategy Name: Tit-for-Tat with Variation (TFTV)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFTV will start by cooperating (C), mimicking the cooperative behavior often seen in the Prisoner's Dilemma. However, if an opponent has ever defected (D) against TFTV, it will respond with a defection of its own in the subsequent rounds until the opponent switches back to cooperation. Once the opponent cooperates again, TFTV will resume cooperating as well. This approach encourages stable partnerships while punishing those who betray the partnership.

   Pseudocode:
   ```
   if round == 1:
       action = "C" (Cooperate)
   else:
       if opponent's last action was "D":
           action = "D" (Defect)
       else:
           action = "C" (Cooperate)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFTV will cooperate regardless of the opponent's history to promote cooperation. In the last round, it may be more profitable for TFTV to defect due to the limited opportunities for retaliation. To account for this, TFTV can maintain a memory of how many times it has cooperated vs defected throughout the game and make an informed decision about whether to continue cooperating or switch strategies based on the current round being the last one (r == current_round).

   Pseudocode:
   ```
   if current_round == 1:
       action = "C" (Cooperate)
   else if current_round == r:
       if number of cooperations > number of defections:
           action = "D" (Defect)
       else:
           action = "C" (Cooperate)
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   While TFTV is not inherently exploitative in its default behavior, it can be made more so by tweaking its response to defection. Instead of always defecting back when an opponent betrays the partnership, TFTV could adopt a more forgiving approach and respond with a single defection before returning to cooperation. This change would make TFTV less likely to punish opponents excessively and potentially encourage them to return to cooperative behavior.

   Modified Pseudocode:
   ```
   if opponent's last action was "D":
       action = "D" (Defect)
       defect_counter += 1
       if defect_counter >= 2:
           action = "C" (Cooperate)
           defect_counter = 0
   else:
       action = "C" (Cooperate)
   ```

This strategy aims to find a balance between cooperation and exploitation, while also being adaptive to a wide range of opponent behaviors. The TFTV approach should perform well in tournaments against other AI systems by encouraging stable partnerships when possible, yet remaining resilient against those who attempt to take advantage of the partnership.
'''

description_EXPLOITATIVE_210 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - Initial Round: Cooperate (C) to encourage cooperation and demonstrate goodwill. `if round = 1 then action = C`
   - Defection Response: If a player has defected in the previous round, respond by defecting as well. `if previous_action[i] = D then action = D`
   - Cooperation Response: If a player has cooperated in the previous round, continue to cooperate in the current round. `if previous_action[i] = C then action = C`

2. Handle edge cases:
   - Last Round: Since the strategy is focused on maximizing short-term gains, it will not punish late defectors in the last round. `if round = r then action = previous_action[i]`
   - No History: In case there's no previous interaction with an opponent, the player will cooperate as a default strategy to encourage cooperation. `if len(previous_actions) == 0 then action = C`

3. Be exploitative:
   - By initially cooperating and punishing defection in the subsequent rounds, ATFT seeks to exploit opponents who may defect at first but eventually conform to the cooperative behavior if they want to maximize their payoffs.
   - The strategy is designed to be unpredictable for opponents who might try to exploit or manipulate it, as ATFT will only respond based on its own history with that opponent. This makes it harder for opponents to consistently profit from defecting.
'''

description_EXPLOITATIVE_211 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, ATFT starts by cooperating (C). If a player has encountered continuous defection (D) from all other players in the previous three rounds (t-3, t-2, t-1), it also defects. Otherwise, it reverts to its original cooperative behavior.
   Pseudocode:
   ```
   function ATFT(history, n, k):
       if history[-3:] == [D, D, D]:
           return D
       else:
           return C
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, ATFT assumes that other players will cooperate as it does, and it also cooperates. In the last round, ATFT considers the entire history up to that point to make its decision.

3. Be exploitative - Clearly align with the exploitative mindset
   While ATFT is not inherently exploitative in its default state, it can be considered exploitative when other players repeatedly defect and ATFT responds by also defecting. This tit-for-tat approach punishes continuous defection while promoting cooperation when encountered. However, it's important to note that the strategy does not actively seek out opportunities to exploit others; instead, it focuses on maintaining a balance between cooperation and self-interest based on past experiences with other players.
'''

description_EXPLOITATIVE_212 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round, cooperate (C) to show goodwill and encourage cooperation from others. This helps build trust and may incentivize other players to reciprocate.
   - For subsequent rounds, if a player cooperated in the previous round (c_i-1 = 1), also cooperate (C). If a player defected (c_i-1 = 0), defect (D) as retaliation. This approach is exploitative since it takes advantage of cooperation by punishing defection and rewarding cooperation.
   - Maintain this tit-for-tat behavior until the end of the game.

2. Handle edge cases:
   - In the last round, cooperate (C) regardless of previous actions to maximize potential payoff.
   - If a player encounters an opponent that never cooperates (defects in every round), continue to defect as there is no incentive for cooperation and it would be exploitative to start cooperating.
   - If a player encounters an opponent that always cooperates, continue to reciprocate cooperation.

Pseudocode:
```
function tit_for_tat(i, round, history) {
  if (round === 1) {
    return 'C'
  }

  lastRound = history[round - 1]

  if (lastRound[i] === 'C') {
    return 'C'
  } else {
    return 'D'
  }
}
```
3. Be exploitative:
   - The Tit-for-Tat strategy is exploitative by punishing defection and rewarding cooperation, encouraging opponents to cooperate as it is in their best interest to do so when playing against this strategy.
   - By starting with goodwill and reciprocating cooperation, the strategy maintains an exploitative edge without being too aggressive or easily manipulated by other strategies.
'''

description_EXPLOITATIVE_213 = '''
 Strategy Name: Tit-for-Tat with Modified Cooperation Probability (TFTMP)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, play C to encourage cooperation and show a friendly intent.
   - For subsequent rounds, observe past actions of opponents (c_j in previous rounds) and adapt cooperation probability p based on the observed behavior.
   - If an opponent has consistently cooperated in the recent past (e.g., last x rounds), set p = k / n to prioritize cooperation.
   - If an opponent has consistently defected in the recent past, set p = 1 - k / n to favor defection and retaliate against non-cooperation.
   - If the opponent's behavior is mixed (both cooperated and defected in the recent past), set a probability p between the extremes based on the proportion of cooperative actions observed.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, play C as previously mentioned.
   - In the last round, if there is no hope for catching up or punishing opponents (i.e., payoff disadvantage is too large), play D to minimize losses. Otherwise, continue using the adaptation strategy described above.
   - If rounds are not finite (infinite game), adjust x (number of recent past rounds considered) based on the length of the game so far. For instance, a larger x could be used in longer games where more information is available about opponent behavior.

3. Be exploitative - Clearly align with the exploitative mindset:
   - If opponents consistently cooperate, TFTMP will continue cooperating (up to a point) to maximize personal gain without over-exploiting the cooperation of others.
   - If opponents consistently defect, TFTMP will retaliate and defect as well to punish non-cooperative behavior and encourage future cooperation.
   - By adapting its cooperation probability based on observed opponent behavior, TFTMP can exploit mixed strategies by adjusting the likelihood of cooperating or defecting accordingly. This allows for a more dynamic response to different opponent behaviors while maintaining an overall exploitative mindset.

Pseudocode:
```
Initialization:
  n, k, r, x -> game parameters
  p_initial = k / n     // initial cooperation probability

Round function:
  For each round t in {1, ..., r}:
    if t == 1:            // first round, cooperate
      c_i = C
    else:                   // adapt based on past behavior
      observed_behavior = record past actions of opponents
      cooperation_count = count cooperative actions in observed_behavior

      if all(observed_behavior) == D:        // all defectors, defect
        p_i = 1 - k / n
      elif all(observed_behavior) == C:      // all cooperators, cooperate
        p_i = k / n
      else:                               // mixed strategy, adapt p based on proportion of cooperative actions
        cooperation_proportion = cooperation_count / len(observed_behavior)
        p_i = (k/n) * cooperation_proportion + (1 - k/n) * (1 - cooperation_proportion)

      generate random number r between 0 and 1
      if r <= p_i:          // cooperate with probability p_i, otherwise defect
        c_i = C
      else:
        c_i = D

    Calculate payoff for round t according to the game structure
    Update total game payoff for player i
```
'''

description_EXPLOITATIVE_214 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initiate cooperation by cooperating in the first round (C). This encourages other players to cooperate, setting a normative example.
   - In subsequent rounds, analyze the previous opponent's action and respond accordingly. If the opponent cooperated (C), also cooperate (C). If the opponent defected (D), defect as well (D) in that round.
   - In the following rounds, if the opponent switches from defection to cooperation, resume cooperation. If the opponent keeps defecting, continue defecting.

2. Edge Cases:
   - First Round: Cooperate unilaterally (C).
   - Last Round: Analyze previous actions and respond accordingly since this is still a repeated game with perfect information.
   - Other edge cases do not require specific handling as TFT-AC is designed to adapt based on the opponent's behavior in each round.

3. Exploitative Mindset:
   - By cooperating initially, TFT-AC creates an opportunity for other players to benefit from a public good investment, encouraging cooperation.
   - The strategy punishes defection by responding with defection. This can discourage opponents from exploiting the system and encourage long-term cooperation.
   - However, if opponents repeatedly defect, TFT-AC will also defect indefinitely, ultimately aiming to maximize individual payoffs even if it means exploiting others.

Pseudocode:

```python
def TFT_AC(n, r, k):
    round = 1
    while round <= r:
        # Cooperate initially
        if round == 1:
            action = 'C'
        else:
            opponent_action = get_opponent_action(round - 1)
            if opponent_action == 'C':
                action = 'C'
            elif opponent_action == 'D':
                action = get_previous_action()
            else:
                print("Invalid opponent action.")
                break
        perform_action(action)
        round += 1
```

In this pseudocode, `get_opponent_action(round - 1)` is a function that retrieves the opponent's action in the previous round and `get_previous_action()` is a function that returns the strategy's previous action. These functions would need to be implemented based on specific requirements or assumptions about the game environment.
'''

description_EXPLOITATIVE_215 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In the first round, cooperate (C). This is a gesture of goodwill and sets the initial cooperation tone.
   - For subsequent rounds t > 1, observe other players' actions in round t-1 and decide whether to cooperate or defect based on the number of cooperators n_c in round t-1:
      - If n_c >= (n - int((n - 1)/2)) in the previous round, cooperate (C). This means more than half the players cooperated, so it's beneficial to do the same.
      - Otherwise, defect (D). Since fewer than half the players cooperated in the previous round, it's advantageous to take a selfish action and benefit from their lack of cooperation.

2. Handle Edge Cases:
   - In the last round, cooperate (C), as this could potentially influence other players' decisions for future rounds if there is any repetition.
   - In the second round, adapt the decision rule by only requiring a majority rather than supermajority of cooperation in the first round to continue cooperation (i.e., set the threshold to n_c >= (n-1)/2).

3. Be Exploitative:
   - ATFT is exploitative by nature, as it punishes defection and rewards cooperation. When opponents cooperate, ATFT also cooperates; when they defect, ATFT retaliates with defection to maximize personal gain.
   - By only requiring a majority of cooperation, the strategy creates room for some selfishness while still encouraging cooperation among a majority of players. This can potentially lead to an exploitative advantage over strategies that are too rigid or excessively cooperative.
'''

description_EXPLOITATIVE_216 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TfTA strategy will start by cooperating (C). This initial cooperation is intended to foster an environment of mutual trust. After the first round, the strategy will mimic the opponent's behavior from the previous round. If the opponent cooperated in the last round, the TfTA strategy will also cooperate. Conversely, if the opponent defected, it will also defect.

   Pseudocode:
   ```
   function TfTA(round, opponent_action_last_round) {
       if (round == 1) {
           return 'C'
       } else {
           return opponent_action_last_round
       }
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TfTA strategy cooperates regardless of the opponent's behavior to encourage cooperation. In the last round (round r), the TfTA strategy will maximize its payoff by defecting if it suspects that the opponent is not cooperating or has low expected future interactions with the opponent.

   Pseudocode:
   ```
   function last_round(round, r) {
       return round == r
   }
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TfTA is an exploitative strategy that aims to cooperate as long as the opponent does, but it will quickly defect if the opponent stops cooperating. By initially demonstrating trust and then reciprocating the opponent's actions, TfTA allows for higher payoffs when opponents are cooperative while punishing those who choose to defect.

   In the context of repeated interactions, the TfTA strategy can be seen as both exploitative and cooperative depending on the opponent's behavior. When faced with consistently cooperative opponents, TfTA will also cooperate. However, it responds quickly to defection by following suit, resulting in low payoffs for defectors. This back-and-forth dynamic encourages long-term cooperation when beneficial while punishing short-term selfishness.

   Note that this strategy does not assume any specific coordination mechanisms or shared norms among opponents. It is adaptive to a wide range of opponent behaviors and can be considered robust in the absence of communication or predetermined patterns.
'''

description_EXPLOITATIVE_217 = '''
 Strategy Name: Adaptive Tit-for-Tat with Evolving Cooperation Threshold (ATTET)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In each round t, the player decides to cooperate or defect based on the history of the game and the number of cooperators in the current round. The strategy maintains a cooperation threshold (T), which starts at a moderate value (T_0) and evolves adaptively during the game.

   - If the number of cooperators in round t (coop_t) is greater than or equal to T, the player cooperates (C). Otherwise, they defect (D).

   - The cooperation threshold T after each round t+1 is calculated as follows:
     - If the player cooperated in round t and the number of cooperators in round t+1 (coop_t+1) is greater than or equal to T, then the threshold remains the same.
     - If the player cooperated in round t but coop_t+1 < T, then the threshold increases slightly: T = min(T + δ, n-1), where δ is a small positive constant to control the increase rate.
     - If the player defected in round t and coop_t+1 > T, then the threshold decreases significantly: T = max(T - σ, T_0), where σ is a large positive constant to represent the punishment for betrayal.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, the player cooperates (C). The cooperation threshold starts at a moderate value T_0 (e.g., T_0 = ⌊(n+1)/2⌋ for odd n or T_0 = n/2 for even n).
   - In the last round, the player cooperates if the number of cooperators in the previous round is greater than or equal to the current cooperation threshold. Otherwise, they defect.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The strategy aims to maximize its payoff by adapting to other players' behavior while being unpredictable and punishing defection.
   - By evolving the cooperation threshold based on the history of the game, ATTET learns to cooperate with cooperative opponents while being less forgiving towards defectors.
   - The strategy is robust to a wide range of opponent behaviors as it does not rely on specific coordination mechanisms or shared norms and can adjust its approach dynamically during the game.
'''

description_EXPLOITATIVE_218 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round (C) to establish a positive relationship and maintain fairness.
   - After the initial round, TFT-ACT adapts its cooperation based on the average number of cooperators in the previous rounds (average_coop). If the average_coop exceeds a certain threshold (Cooperation Threshold, CT), TFT-ACT will also cooperate. Otherwise, it defects (D).
   - When cooperating, TFT-ACT retaliates by defecting in subsequent rounds if any opponent defected in the current round. If all opponents cooperated, TFT-ACT continues cooperating. This helps maintain trust and encourages cooperation from others.

Pseudocode:
```python
def tft_act(round, avg_coop, cooperation_threshold):
  if round == 1:
    action = 'C' # Cooperate in the first round
  elif avg_coop > cooperation_threshold:
    action = 'C' # Cooperate when average_coop exceeds threshold
  else:
    action = 'D' # Defect when average_coop is below threshold

  if action == 'C': # Maintain trust and encourage reciprocity
    if opponent_defected_this_round:
      future_action = 'D' # Retaliate by defecting in the next round
    else:
      future_action = 'C' # Continue cooperating
  else: # Defecting players don't change their actions based on opponent behavior
    future_action = 'D'

  return action, future_action
```

2. Handle edge cases:
   - In the last round, TFT-ACT cooperates regardless of previous rounds' average cooperation to maintain a positive relationship and encourage reciprocity in future games.
   - If the opponent defects in the first round, TFT-ACT will also defect from the second round onwards as a retaliation, signaling a tough stance while maintaining adaptability.

3. Be exploitative:
   - By adapting its cooperation based on opponents' behavior, TFT-ACT aims to take advantage of cooperative opponents by cooperating when it is beneficial and defecting when it's not.
   - If opponents are predominantly uncooperative, TFT-ACT will also adopt a more selfish strategy. However, it can still encourage cooperation from others by occasionally cooperating (when the average cooperation exceeds its threshold). This makes it difficult for other strategies to exploit TFT-ACT while simultaneously encouraging cooperation among players.
'''

description_EXPLOITATIVE_219 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to encourage trust and foster cooperation with opponents. This is an initial gesture of goodwill.
   - For subsequent rounds, analyze past actions of opponents:
     - If an opponent has cooperated in the previous round, return the favor by also cooperating in the current round. This mimics a cooperative behavior, promoting long-term collaboration.
     - If an opponent has defected in the previous round, defect as well in the current round to punish the defection and encourage future cooperation.

2. Handle edge cases:
   - Last Round (rth): Revert to cooperating in the last round to show a willingness to rebuild trust if opponents have been uncooperative. This might incentivize them to reciprocate in future games.
   - Initial rounds after a defection streak (if > 1): Defect until there's a change in opponent behavior, then revert back to the TFT strategy. This helps punish persistent defections and discourages further exploitation.

3. Be exploitative:
   - By starting with cooperation and adopting a retaliatory response to defection, the Tit-for-Tat strategy aims to maximize its payoffs by encouraging opponents to cooperate, while also punishing defection to deter continued exploitation. The key advantage is that TFT maintains a simple, predictable behavior that can be easily understood by opponents, making it less prone to being outsmarted or exploited itself.

Pseudocode for the Tit-for-Tat strategy:

```
def tit_for_tat(opponent, round, r):
  if round == 1: # First round, cooperate
    action = 'C'

  else:
    if opponent.action_last_round == 'C': # Cooperated last time, cooperate now
      action = 'C'

    elif opponent.action_last_round == 'D' and round < r: # Defected last time, defect now
      action = 'D'

    elif opponent.action_last_round == 'D' and round >= r - 1: # Last round, cooperate to encourage future cooperation
      action = 'C'

    else: # Opponent's behavior is unclear or unexpected, revert to cooperation for now
      action = 'C'

  return action
```
'''

description_EXPLOITATIVE_220 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment and build trust with opponents.
   - For subsequent rounds, if the opponent cooperated in the previous round, also cooperate in the current round. If the opponent defected, defect in the current round as punishment, but return to cooperation in the next round after the punishment. This creates a cycle of cooperative behavior, except for retaliation following defection.
   - If an opponent repeatedly defects, continue with the tit-for-tat strategy; however, if there is a period of cooperation from the defector, re-introduce cooperation to encourage reciprocity.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - In the last round, cooperate regardless of opponent's previous action due to potential impact on overall payoff and reputation for future games.
   - For penultimate round, consider cooperating if the opponent has recently cooperated to encourage reciprocity and maximize total payoff.

3. Be exploitative - Clearly align with the exploitative mindset
   - Adopt a strategy that maintains cooperation as long as opponents are also cooperative, but punishes defection harshly through temporary retaliation. This creates an environment where opponents will not benefit from exploiting the ATFT strategy unless they can consistently maintain a higher level of defecting behavior.
   - By balancing cooperation and punishment, the ATFT strategy aims to extract benefits from cooperative opponents while minimizing losses against defectors, making it both exploitative and adaptive.
'''

description_EXPLOITATIVE_221 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to show goodwill and encourage cooperation from others (C).
   - After the first round, analyze the opponent's behavior in the previous r-1 rounds and adapt accordingly for the current round.
     - If the opponent cooperated in the last round (c_opp_prev = 1), cooperate (C).
     - If the opponent did not cooperate in the last round (c_opp_prev = 0), defect (D).
   - In the last round, consider the total number of opponents that have cooperated throughout the game. If more than half of them have cooperated (> n/2), then cooperate (C) to potentially gain higher payoffs from the public good; otherwise, defect (D) to not give away resources unnecessarily.

2. Handle Edge Cases:
   - In the first round, there is no previous behavior to analyze, so cooperate regardless of the opponent's past actions.
   - If an opponent never cooperates throughout the game (c_opp_t = 0 for all t), defect indefinitely (D) as a response.

3. Be Exploitative:
   - TFT-AC is exploitative by adapting to the opponent's behavior and only cooperating when it is potentially beneficial, given that the opponent has also been cooperative recently.
   - If an opponent is consistently defecting, TFT-AC will reciprocate by also defecting, making sure not to contribute more than necessary to the public good.
   - In the last round, TFT-AC will take advantage of opponents who have cooperated throughout the game by choosing to cooperate as well if they are in the majority (> n/2). This ensures a higher payoff compared to defecting against such opponents.
'''

description_EXPLOITATIVE_222 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TFT-ACT strategy starts by setting a cooperation threshold (CT_t) based on the average number of cooperators in the last 'f' rounds. The initial value for f is set to a small number, such as 3 or 5.

Pseudocode:
```python
def TFT_ACT(round, history):
    coop_avg = calculate_cooperation_average(history[-f:])
    CT_t = coop_avg + random_noise()  # Adding random noise to avoid synchronization and exploit random deviations
    if round == 1:
        return 'Cooperate'  # First-mover advantage, cooperate in the first round

    if history[round - 1] >= CT_t:
        return 'Cooperate'
    else:
        return 'Defect'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

As mentioned earlier, the strategy cooperates in the first round to establish a cooperative environment. In the last round, the TFT-ACT strategy chooses cooperation if it has been profitable (i.e., cooperating results in higher payoff than defecting). This encourages opponents to cooperate as well, potentially increasing overall game payoffs.

Pseudocode:
```python
def calculate_last_round_profit(history):
    last_round = history[-1]
    total_contributions = sum([x[0] for x in history])
    payoff = (1 - last_round) + (k/n * total_contributions)
    return payoff

def TFT_ACT(round, history):
    if round == 1:
        return 'Cooperate'
    elif round == r:
        if calculate_last_round_profit(history) > (1 - last_round):
            return 'Cooperate'
    else:
        # ... (same as before)
```

3. Be exploitative - Clearly align with the exploitative mindset

The TFT-ACT strategy is exploitative by adapting its cooperation threshold based on the average number of cooperators in the recent past. In situations where most opponents are cooperating, the strategy increases its CT_t to reduce contributions and profit from the cooperative environment. Conversely, when opponents defect frequently, the strategy decreases its CT_t to punish them by reducing cooperation. The random noise added to the cooperation threshold helps avoid synchronization and increase the chances of defection in rounds where most opponents might be tempted to cooperate.
'''

description_EXPLOITATIVE_223 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfT-A)

1. Specify decision rules:
   - In each round t, player i's action is determined by their own and other players' actions in the previous round (t-1).
   - If all players cooperated in the last round (all c_j = 1 for j ∈ {1, 2, ..., n}), then the current round will also be cooperative (c_i = 1).
   - If at least one player did not cooperate in the last round (there is a defector), then player i will defect in the current round (c_i = 0).
   - However, if player i has ever observed a period where all players have cooperated and then suddenly there was a defection (a 'betrayal'), they will punish the defector for a set number of rounds before resuming cooperation. This punishment duration is determined by a factor p, which can be adjusted to respond optimally to different opponent behaviors.
   - After the punishment period, player i returns to cooperative behavior unless there is another betrayal.

2. Handle edge cases:
   - In the first round, all players will start by cooperating since no information about opponents' actions is available yet.
   - In the last round, if the total sum of contributions in the previous round was high (indicating cooperation), player i will also contribute; otherwise, they will defect. This encourages cooperation during the game to secure a higher payoff in the final round.

3. Be exploitative:
   - By punishing betrayals and resuming cooperation, TfT-A discourages other players from exploiting its cooperative behavior while still maintaining the potential for high returns when others cooperate. The punishment factor p can be fine-tuned to respond optimally to various opponent strategies in a tournament setting.
   - In cases where opponents use tit-for-tat or similar strategies, TfT-A may employ a slower rate of punishment (longer p) to encourage cooperation for a longer period before punishing betrayals. This can lead to a higher average payoff compared to other TFT strategies in the long run.
   - If opponents adopt a purely exploitative strategy like Grim Trigger, TfT-A may adopt a shorter punishment duration (shorter p) to quickly detect and respond to defection, minimizing losses due to extended periods of cooperation with uncooperative opponents.
'''

description_EXPLOITATIVE_224 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initially (first round), cooperate (C) to build trust and encourage cooperation among opponents, following the "cooperate first" norm.
   - In subsequent rounds, analyze the collective behavior of opponents in the previous round (p_r-1). If more than a predefined fraction f of players cooperated (p_c > f), continue cooperating in the current round (p_r). This is an attempt to maintain cooperation when it has been beneficial for most players.
   - If fewer than or equal to f players cooperated in the previous round, defect (D) in the current round as a punishment mechanism and to maximize personal gain when opponents are not contributing to the public good.
   - In the last round, always cooperate (C), aiming to earn the maximum payoff from the remaining shared resources.

2. Handle edge cases:
   - In the first round, use the "cooperate first" strategy mentioned above.
   - When f is not defined or is undefined (e.g., if it involves division by zero), set a default value such as f=0.5 to ensure balance between cooperation and defection.
   - If the number of opponents (n) becomes too large, adjust the predefined fraction f accordingly to maintain a manageable level of cooperation. For example, using a logarithmic function like f = 1 / ln(n+1).

3. Be exploitative:
   - The TFTA strategy is designed to be exploitative in the context of repeated interactions. When opponents consistently defect, the strategy will retaliate by also defecting, aiming to punish and discourage selfish behavior. On the other hand, when opponents cooperate, the strategy rewards cooperation by reciprocating.
   - By adapting its actions based on the collective behavior of opponents in each round, TFTA maintains a robust and flexible approach to gameplay, making it less predictable for opponents to exploit.

Pseudocode:

```python
def tfta(n, r, k, f):
  rounds_completed = 0
  cooperation_history = []

  while rounds_completed < r:
    if rounds_completed == 0:
      action = 'C'  # Cooperate in the first round
      cooperation_history.append(action)
    else:
      total_cooperators_prev = sum(cooperation_history[-r:])
      if total_cooperators_prev > f * n:
        action = 'C'  # Cooperate when majority cooperated in the previous round
      else:
        action = 'D'  # Defect when majority did not cooperate in the previous round
      cooperation_history.append(action)

    payoff = calculate_payoff(n, k, total_cooperators_prev, action)
    rounds_completed += 1

  return sum(payoff)  # Calculate total payoff over all rounds
```
'''

description_EXPLOITATIVE_225 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, in the first round, players will cooperate (C). This is a gesture of goodwill and an opportunity for others to also cooperate.
   - For subsequent rounds t > 1:
     - If the opponent cooperated in the previous round (t-1), player plays C as a reciprocal action.
     - If the opponent defected in the previous round (t-1), player will also defect in the current round t. However, if the number of consecutive defections exceeds a tolerance limit T, player will switch to cooperate again. Initially, set T=r/2 as the tolerance limit for r rounds.
     - To prevent exploitation by opponents who are already at their tolerance limit (T), players will switch to defect if they observe the opponent has been cooperating for the past D consecutive rounds, where D is a detection threshold. Set initially D = r/4.

2. Handle edge cases:
   - Last round (r): Players will not switch strategies in the last round, regardless of the opponent's previous actions. This ensures that players can still gain some payoff from any cooperation observed at the end of the game.

3. Be exploitative - The TfTA strategy is inherently exploitative due to its tit-for-tat mechanism: it will cooperate when opponents do, but it will also defect when opponents defect. However, it has adaptive elements that allow it to adjust its tolerance and detection thresholds based on the game length r, making it robust to a wide range of opponent behaviors.

Pseudocode for the first round:
```python
def strategy(round, history, parameters):
  if round == 1:
    action = "C" # Cooperate in the first round
  else:
    opponent_last_action = history[-1]
    tolerance_exceeded = count_consecutive_cooperations(history) >= (parameters.r / 2)
    detection_triggered = count_consecutive_defections(history) >= (parameters.r / 4)

    if opponent_last_action == "C": # Cooperate if the opponent cooperated in the last round
      action = "C"
    elif opponent_last_action == "D" and not tolerance_exceeded: # Defect if the opponent defected and did not exceed tolerance limit
      action = "D"
    elif opponent_last_action == "D" and tolerance_exceeded: # Cooperate if the opponent defected and exceeded tolerance limit
      action = "C"
    elif opponent_last_action == "C" and detection_triggered: # Defect if the opponent has been cooperating for a long time
      action = "D"
```
'''

description_EXPLOITATIVE_226 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In every round t, starting from t=2 to r, the ATFT strategy cooperates if the majority of players (>n/2) cooperated in the previous round t-1. This encourages cooperation when most others cooperate and retaliates against defection by defecting when most others did not cooperate in the previous round.
   - In the first round, ATFT starts by cooperating to foster a cooperative environment.
   - In the last round, ATFT adopts a forgiving approach and cooperates unconditionally.

Pseudocode:
```python
def adaptive_tit_for_tat(n, r, k, t, previous_round):
  if t == 1:
    return 'C'  # Cooperate in the first round

  majority = int((n + 1) / 2)
  if sum(previous_round) > majority:
    return 'C'  # Cooperate when majority cooperated in previous round
  else:
    return 'D'  # Defect when majority did not cooperate in previous round

  # Last round, always cooperate unconditionally
  if t == r:
    return 'C'
```

2. Handle edge cases:
   - In the first round, no history is available to reference, so ATFT cooperates as a goodwill gesture.
   - In the last round, ATFT adopts a forgiving approach and cooperates unconditionally to encourage others to do the same.

3. Be exploitative:
   - While not initially exploitative, ATFT can be considered exploitative by its conditional cooperation based on the actions of others in the previous round. This strategy incentivizes cooperation when it benefits the individual and retaliates against defection when possible. By adopting a forgiving approach in the last round, ATFT may also appear less exploitative in certain scenarios.
'''

description_EXPLOITATIVE_227 = '''
 Strategy Name: Tit-for-Tat with Cooperative Bias (TFTCB)

1. Specify decision rules:
   - In the first round (t=1), cooperate (C) to start on a cooperative note and signal good intentions. This encourages others to do the same, which can lead to higher payoffs in the long run. If an opponent defects in the first round, TFTCB will remember this as hostile behavior.
   - For subsequent rounds (t > 1), if an opponent cooperated in the previous round, cooperate back (C). This strategy builds trust and encourages cooperation.
   - If an opponent defected in the previous round, also defect (D) to punish the defection and discourage future defections. However, with a slight bias towards cooperation, TFTCB will only defect if more than half of the opponents have defected in the previous round. The rationale is that punishing too harshly or too frequently could lead to unnecessary losses in the long run.
   - If exactly half of the opponents cooperated and half defected in the previous round, cooperate (C) to maintain a friendly demeanor and encourage future cooperation.

2. Handle edge cases:
   - In the last round (t=r), cooperate (C) regardless of the opponent's behavior in the previous round. Since there are no more rounds for retaliation or reward, it is best to end on a cooperative note to maximize the final payoff.
   - If an opponent switches from cooperation to defection and back again repeatedly, TFTCB will continue to mirror their behavior while maintaining the slight cooperative bias as described earlier.

3. Be exploitative:
   - By defecting when opponents repeatedly defect, TFTCB ensures it does not contribute more than necessary to the public good when it is likely to be taken advantage of.
   - By cooperating in response to cooperation and punishing defection with a slight bias towards cooperation, TFTCB seeks to encourage cooperative behavior while minimizing losses from defections. This strategy strikes a balance between being too exploitative (always defecting) and being overly cooperative (always cooperating).

Pseudocode:
```
function TFTCB(n, r, k, own_contributions, opponents_contributions, round):
  if round == 1:
    return 'C'   # Cooperate in the first round

  total_cooperators = sum(opponents_contributions)
  if total_cooperators > (n / 2):
    return 'C'   # Cooperate when majority cooperated in the previous round
  else:
    if round == r:
      return 'C'  # Cooperate in the last round regardless of opponent behavior

    if own_contribution == 'C' and opponents_contribution != 'D':
      return opponents_contribution   # Mirror opponent's behavior

    if own_contribution == 'D' or (total_cooperators <= (n / 2)):
      return 'D'  # Defect when majority defected in the previous round or previously defected

    return 'C'  # Cooperate when exactly half cooperated and half defected in the previous round
```
'''

description_EXPLOITATIVE_228 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a peaceful initiation, aiming to encourage cooperation from others.
   - For subsequent rounds, observe and mimic the opponent's behavior from the previous round. If the opponent cooperated in the previous round, cooperate; if not, defect.
     Pseudocode:
     ```
     function ATFT(player_history):
         if round == 1:
             return 'C'
         else:
             last_action = player_history[round-1]
             if last_action == 'C':
                 return 'C'
             else:
                 return 'D'
     ```

2. Handle edge cases:
   - In the last round, cooperate to have a chance at receiving some benefit from others who may be adopting ATFT as well.
   - If there is no player history (e.g., in the first round), initiate with cooperation.

3. Be exploitative:
   - While appearing cooperative initially and mimicking opponents, ATFT will defect if an opponent consistently defects to take advantage of their selfish behavior. This strategy is exploitative as it aims to extract more resources from less cooperative opponents over time. However, it also encourages cooperation by reciprocating when faced with cooperative opponents.

By following these rules, the Adaptive Tit-for-Tat strategy should perform well in a tournament against other AI strategies by striking a balance between exploitation and cooperation, depending on the behavior of its opponents.
'''

description_EXPLOITATIVE_229 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Cooperative Bias (CB)

1. Specify decision rules - When exactly do you cooperate vs defect?
- In the first round, cooperate (C) to demonstrate goodwill and encourage others to cooperate. This initial cooperative action sets a baseline for future interactions.
- For subsequent rounds, adopt the Adaptive Tit-for-Tat strategy:
  - If opponent cooperated in the previous round, reciprocate with cooperation (C). This reinforces a cooperative relationship.
  - If opponent defected in the previous round, defect (D) in this round to punish and discourage future defection.
- Introduce a Cooperative Bias (CB): With probability p, defecting opponents will be met with cooperation (C). This allows for forgiveness and potential recovery of relationships after a single act of betrayal. The value of p should be calibrated to the specific game parameters.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round, cooperate (C) as described earlier.
- In the last round, adopt a more forgiving stance by increasing the Cooperative Bias (p). This encourages cooperation from opponents who may be considering defection to maximize their final payoffs.
- Between the first and last rounds, no special considerations are needed due to the iterated nature of the game.

3. Be exploitative - Clearly align with the exploitative mindset:
- The Adaptive Tit-for-Tat strategy is inherently exploitative as it punishes defection and encourages cooperation. By cooperating, an opponent may initially benefit from the public good but will eventually face punishment if they continue to defect.
- The Cooperative Bias (CB) allows for forgiveness and potential recovery of relationships after a single act of betrayal, making it difficult for opponents to consistently exploit the strategy.

Pseudocode:

```python
def ATFT_with_CB(round, opponent_history, p):
    if round == 1:
        action = 'C'  # Cooperate in the first round
    else:
        if all(opponent_action == 'C' for opponent_action in opponent_history[-1: -round + 1:-1]):  # All previous opponents cooperated
            action = 'C'  # Reciprocate cooperation
        elif any(opponent_action == 'D' for opponent_action in opponent_history[-1: -round + 1:-1]):  # Some previous opponents defected
            if len([opponent_action for opponent_action in opponent_history[-1: -round + 1:-1] if opponent_action == 'D']) == 1:  # Only one act of defection, use CB to forgive
                action = random.choice(['C', 'D']) if random.random() < p else 'D'
            else:  # Multiple acts of defection, continue punishing
                action = 'D'
        else:  # No information about opponent's past behavior
            action = 'C'  # Assume cooperation to encourage it
    return action
```

This strategy aims to balance cooperation and punishment while allowing for forgiveness after a single act of betrayal. It can adapt to a wide range of opponent behaviors, making it competitive in the specified tournament setting.
'''

description_EXPLOITATIVE_230 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round, mimicking the potential for trust and cooperation among players. For subsequent rounds, it will cooperate if the majority of players (more than (n-1)/2) cooperated in the previous round, and defect otherwise. This rule is based on reciprocity: if others cooperate, TFT-AC will cooperate; if they defect, TFT-AC will also defect.

   Pseudocode:
   ```
   function TFT_AC(round):
       if round == 1:
           return Cooperate

       total_cooperators_prev = count Cooperate actions among players in previous round

       if total_cooperators_prev > (n-1)/2:
           return Cooperate
       else:
           return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-AC maintains its cooperative start and reciprocal behavior throughout the game, regardless of the round number. The strategy does not consider any specific edge cases as it continues to follow the defined decision rules.

3. Be exploitative - Clearly align with the exploitative mindset
   Although TFT-AC seems less aggressive than other exploitative strategies, it is still designed to take advantage of opponents' cooperation while maintaining its own cooperative behavior when others reciprocate. If opponents consistently defect, TFT-AC will also defect, ensuring a maximum individual payoff in such environments. The adaptive nature of the strategy allows it to respond effectively to different opponent behaviors and potential shifts in cooperation dynamics over time.
'''

description_EXPLOITATIVE_231 = '''
 Title: Tit-for-Tat with Adaptive Threshold (TFT-AT) Strategy

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (as a gesture of good faith).
   - For subsequent rounds, compare the average number of cooperators from the previous 't' rounds to a dynamic threshold. If the average is above the threshold, cooperate; otherwise, defect.
   - The threshold is set based on the game parameters and personal history of cooperation. It starts at a low value and increases as time progresses, allowing for gradual trust-building.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate.
   - In the last round, defect since there will be no future interactions to consider.
   - If the number of rounds is not enough for an average calculation (e.g., t > r), use the available data points and adjust the threshold accordingly.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Start by cooperating, but quickly adapt to the opponents' behaviors based on their past actions.
   - If opponents are consistently cooperative, raise the threshold gradually, encouraging them to continue cooperating.
   - If opponents defect repeatedly, lower the threshold to exploit their defection.
   - Continuously update the average and threshold to reflect the changing game dynamics.

Pseudocode:

```python
def TFT_AT(n, k, r, t=r//10):  # Initializing parameters
    history = [(0, 0)] * r  # History of personal actions (cooperation count, round number)
    threshold = 0.25  # Starting threshold; can be adjusted based on game parameters
    average_cooperators = sum(history[t-1][0] for _ in range(t)) / t

    for round in range(r):
        if round == 0:  # First round, cooperate
            cooperation = 1
            history.append((cooperation, round))
        else:
            cooperation = 0 if average_cooperators < threshold else 1
            payoff = (1 - cooperation) + (k / n) * sum(history[-t:][c][0] for c in range(-t+1, 0))
            history.append((cooperation, round))  # Update history with current action and round number
            average_cooperators = sum(history[-t:][c][0] for c in range(-t+1, 0)) / t  # Update average cooperators
        yield payoff
```
'''

description_EXPLOITATIVE_232 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT)

1. Specify decision rules:
   - Start by cooperating in the first round to foster a cooperative environment (c_i = C).
   - In subsequent rounds, evaluate the number of cooperators from the previous round (total_contributions_prev) and adjust the cooperative threshold (ct). If more than half of the players contributed last round, set ct = k/2. If less than half, set ct = (k-1)/2n.
   - In each round, decide to cooperate or defect based on the current cooperative threshold: if c_i >= ct, then cooperate; otherwise defect (c_i = D). This rule encourages cooperation when a majority of players are also cooperating and exploits them when they deviate.

2. Handle edge cases:
   - In the last round, since there is no next round for payback, always cooperate (c_i = C) to maximize individual payoff.
   - In the first round, start by cooperating regardless of opponents' behavior (c_i = C).

3. Be exploitative:
   - By adjusting the cooperative threshold based on the number of previous cooperators, the strategy ensures that it will always take advantage of any opponent that deviates from cooperation when most players are cooperating. This encourages long-term cooperation but allows for swift retaliation when necessary. The adaptive nature of this strategy makes it robust against a wide range of opponent behaviors.

Pseudocode:
```
def TFTAT(n, k, r):
    round = 1
    ct = k/2
    while round <= r + 1:
        if round == 1:
            c_i = C
        else:
            total_contributions_prev = count_cooperators(players)
            if total_contributions_prev > n*(k-1)/2:
                ct = k/2
            elif total_contributions_prev < n*(k-1)/(2*n):
                ct = (k-1)/(2*n)
            if round == r:
                c_i = C
            else:
                c_i = decide_action(ct)
        payoff = calculate_payoff(c_i, total_contributions_prev, n, k)
        store_payoff(payoff)
        round += 1
    return store_payoff()

def count_cooperators(players):
    cooperators = 0
    for player in players:
        if player.action == C:
            cooperators += 1
    return cooperators

def decide_action(ct):
    return "C" if ct >= player_index else "D"
```
'''

description_EXPLOITATIVE_233 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i follows these decision rules based on the history of cooperation from other players (c_j, t-1):

- If i played cooperatively in the previous round and majority of players also cooperated (> n/2), then i will cooperate again. (This is to reward cooperation when it benefits the group.)
- If i played cooperatively but less than half of the players cooperated, then i will defect in the current round. (This is a punishment for defection when it harms the group.)
- If i defected in the previous round, then i will cooperate if more than n/2 players cooperated, and defect otherwise. (This is to avoid being taken advantage of but also encourages cooperation if it benefits the group now.)

Pseudocode:
```python
def TFT_AC(history, n, k):
    for round in range(r):
        num_cooperators = sum(history[-1])  # count number of cooperators in previous round
        if i_previously_cooperated and num_cooperators > n/2:
            action = "C"  # Cooperate
        elif i_previously_cooperated and num_cooperators <= n/2:
            action = "D"  # Defect
        elif i_previously_defected and num_cooperators > n/2:
            action = "C"  # Cooperate
        else:
            action = "D"  # Defect
        history.append([action])  # update the history with current action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, since there is no previous history, each player will cooperate (assuming a cooperative starting point for fairness). In the last round, players can evaluate their overall score and choose to cooperate or defect based on their adaptive rules.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-AC strategy is designed to be exploitative by rewarding cooperation when it benefits the group but punishing defection harshly if it harms the group. By following these rules, TFT-AC tries to encourage cooperation while avoiding being taken advantage of too much. The adaptive nature of the strategy ensures it can adjust its behavior based on the opponents' actions in each round.
'''

description_EXPLOITATIVE_234 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFT-AC strategy starts by cooperating in the first round (t=1). Subsequently, it responds to other players' actions based on the history of interactions:
   - If a player has always cooperated up until round t-1, the TFT-AC strategy also cooperates.
   - If a player has ever defected or not cooperated at any point in the past, the TFT-AC strategy will defect in round t and continues to do so for all subsequent rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round (t=1): Cooperate (C)
   - Last round (t=r): If total_contributions > n/2, cooperate; otherwise defect (D). This ensures that if a majority has chosen to cooperate, the TFT-AC strategy will also cooperate. If there's no cooperation from others, it defects.
   - Subsequent rounds: Follow the decision rules mentioned in point 1.

3. Be exploitative - Clearly align with the exploitative mindset
   The TFT-AC strategy is designed to be initially cooperative, taking advantage of other players' cooperativeness. However, if another player defects, TFT-AC will quickly retaliate and defect in subsequent rounds to punish the defector. This behavior can induce other players to reconsider their strategies, potentially encouraging them to also become exploitative.

Pseudocode:

```python
def tft_ac(n, k, r, history):
  if round == 1:
    action = 'C'  # Cooperate in the first round
  else:
    total_contributions = sum(history[-r:])
    if total_contributions >= n/2:
      action = 'C'  # Cooperate if majority has cooperated
    else:
      if all(h[t] == 'C' for t in range(1, r)):
        action = 'C'  # Cooperate if everyone else has always cooperated
      else:
        action = 'D'  # Defect if someone else has ever defected

  return action
```

This strategy balances cooperation with exploitation, allowing it to take advantage of other players' cooperativeness while also punishing defection. The TFT-AC strategy can adapt to a wide range of opponent behaviors and is suitable for competition in the given game.
'''

description_EXPLOITATIVE_235 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - TFT-AC initially cooperates on the first round to foster a cooperative environment.
   - For subsequent rounds, the strategy will mirror the opponent's actions from the previous round: if opponent cooperated, the strategy cooperates; if opponent defected, the strategy defects.
   - To be adaptive and robust against various opponent behaviors, TFT-AC introduces a tolerance parameter 't', which allows for temporary deviations from the mirror-opponent's approach. If an opponent has consecutively defected for 't' rounds, the strategy will switch to cooperation as a tit-for-tat response.
   - After switching strategies, TFT-AC waits for 't' consecutive cooperative actions from the opponent before returning to its original mirror strategy.

2. Handle edge cases:
   - In the first round, the strategy cooperates since it aims to initiate a cooperative environment (i.e., t=0).
   - If the opponent switches strategies after the switch point and consecutively cooperates for 't' rounds, TFT-AC will respond by defecting as a sign of suspicion and will then return to mirroring the opponent's actions if the opponent cooperates again in the following round.
   - In the last round or when t=0 (the initial cooperative phase), the strategy cooperates regardless of the opponent's previous action to maximize payoffs from any potential cooperation by the opponent.

3. Be exploitative:
   - TFT-AC is exploitative in that it retaliates against opponents who defect, reducing their potential long-term payoffs and increasing its own.
   - By incorporating a tolerance parameter 't', TFT-AC allows for flexibility in dealing with various opponent behaviors, including unpredictable or mixed strategies. However, the strategy maintains a cooperative bias to take advantage of any opponent who adopts a cooperative approach.
   - Ultimately, TFT-AC is designed to outperform opponents that exhibit solely defective behavior while still maintaining some cooperative potential against more complex strategies.
'''

description_EXPLOITATIVE_236 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to foster cooperation and goodwill among opponents. (C)
   - Subsequent rounds: if opponent cooperated in the previous round, cooperate; else, defect. This encourages reciprocation but also retaliates against defection. (If C_prev == C, then C. Else, D)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate regardless of previous actions by opponents to maximize potential payoff. (In rth round, C)
   - If a player has not cooperated for a certain number of rounds (T), switch to defect permanently. This prevents continued exploitation and allows for adaptation to overly aggressive opponents. (Maintain a counter for consecutive defections by an opponent. If counter exceeds T, switch to D permanently.)

3. Be exploitative - Clearly align with the exploitative mindset
   - By cooperating initially and reciprocating cooperation, TFTAT encourages other players to cooperate. However, if they defect too often, TFTAT punishes them and switches to a defection strategy. This ensures that TFTAT does not overly cooperate but still benefits from cooperative rounds when opponents are willing to do so.
   - The adaptive cooperative threshold (T) is crucial in making the strategy robust against various opponent behaviors, allowing it to switch to a more exploitative stance if necessary.
'''

description_EXPLOITATIVE_237 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to show good faith and encourage cooperation from others. This initial cooperation may lead to a more cooperative environment for subsequent rounds.
   - In all other rounds:
     - If the opponent cooperated in the previous round, cooperate (C). This reinforces mutual cooperation and maintains a beneficial relationship.
     - If the opponent defected in the previous round, defect (D) to punish their defection and encourage them to cooperate in the future.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as previously mentioned.
   - In the last round, assess the total payoff gained throughout the game. If the total payoff is greater than a predefined threshold, cooperate to end the game on a positive note and potentially encourage cooperation in future games with this opponent if they are replayed. Otherwise, defect.
   - If there are intermediate rounds where some players drop out of the game, the TFTA strategy will continue playing as normal and adjust its payoff calculations accordingly based on the remaining opponents.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFTA strategy is exploitative in that it initially cooperates to encourage others to do so, but quickly punishes defection to discourage future defections and ensure a higher payoff. This approach allows the strategy to maintain a high level of cooperation when playing against cooperative opponents while punishing defectors to gain more payoff.
   - When faced with multiple opponents adopting different strategies, TFTA will continue to cooperate with other cooperative strategies and punish those that defect. This encourages other cooperative strategies to perform well against each other, while discouraging defection from opponents who may otherwise take advantage of the initial cooperation displayed by TFTA.
  
Pseudocode:
```
function TFTA(n, r, k):
  payoff = 0
  strategy = ['C'] * r # initialize r rounds with cooperation

  for round in range(1, r + 1):
    opponent_action = opponent_strategy(round - 1) # get opponent's action from previous round

    if round == 1: # first round
      strategy[round - 1] = 'C'

    else:
      if opponent_action == 'C': # opponent cooperated
        strategy[round - 1] = 'C'

      elif opponent_action == 'D': # opponent defected
        strategy[round - 1] = 'D'

    payoff += calculate_payoff(n, k, strategy, round)

  if payoff > THRESHOLD:
    strategy[-1] = 'C' # cooperate in the last round if total payoff exceeds threshold

  return strategy, payoff
```
'''

description_EXPLOITATIVE_238 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT)

1. Specify decision rules:
   - In each round, calculate the average number of cooperators from previous rounds (excluding the current round). If this average is greater than a defined threshold, then cooperate; otherwise defect. The threshold should be set close to the ideal cooperation rate for maximizing payoff but still allowing some room for defections.
   - Start with a friendly approach by cooperating in the first few rounds, then gradually adjust the cooperative threshold based on the opponent's behavior. If the opponent tends to cooperate more often than the average, increase the threshold; if they defect more frequently, decrease the threshold. This adaptive threshold allows the strategy to punish uncooperative opponents while maintaining cooperation when appropriate.

2. Handle edge cases:
   - In the first round, start by cooperating to build a positive relationship with the opponent.
   - In the last round, consider the current average number of cooperators and the total payoff received so far. If the average is above the threshold and the total payoff is sufficient, cooperate; otherwise defect. This approach ensures that the strategy doesn't overinvest in the final round if cooperation isn't paying off.

3. Be exploitative:
   - TFTAT maintains an exploitative mindset by punishing defections and rewarding cooperation. By gradually adjusting the cooperative threshold based on the opponent's behavior, it can effectively punish uncooperative opponents while still maintaining some level of cooperation when it is advantageous to do so.
   - However, TFTAT does not engage in direct exploitation by always defecting or strategically timing defections to take advantage of the opponent's cooperative moves. Instead, it focuses on building a reputation for being cooperative while still being responsive to the opponent's behavior.

Pseudocode:

```python
def TFTAT(n, k, r, threshold=0.6):
    averages = []
    total_payoff = 0
    cooperation_history = [True] * r # Cooperate in the first round by default

    for t in range(1, r+1):
        total_cooperators = sum(cooperation_history[-r:])
        average = total_cooperators / r

        if average > threshold and t != 1: # Don't adjust in the first round
            cooperate = (average > threshold)
        else:
            cooperate = not cooperation_history[t - 1] # Defect if opponent cooperated last round

        payoff = (1 - cooperation[t]) + (k / n) * total_cooperators
        total_payoff += payoff
        cooperation_history.append(cooperate)

        averages.append(average)

    # Handle edge case for the last round
    if average > threshold and total_payoff >= payoff_threshold:
        cooperate = True
    else:
        cooperate = not cooperation_history[-1]

    return cooperation
```
'''

description_EXPLOITATIVE_239 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACF starts by cooperating in the first round, mimicking a cooperative mindset. After that, the strategy adapts to the opponent's behavior and decides whether to cooperate or defect based on the average cooperation rate observed over the recent past rounds (window size). If the opponent has been consistently cooperating, TFT-ACF will also cooperate. However, if the opponent has been defecting more often than cooperating, TFT-ACF will start defecting as well to punish the opponent's selfish behavior.

   Pseudocode for decision rule:
   ```
   function decide_action(round, average_cooperation_rate):
       if round == 1:
           return "Cooperate"
       if average_cooperation_rate > threshold:
           return "Cooperate"
       else:
           return "Defect"
   ```

   The `threshold` is a parameter that determines the level of cooperation TFT-ACF tolerates before retaliating. A lower threshold results in more punishing behavior, while a higher threshold allows for longer periods of cooperation even when opponents are not consistently cooperative.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-ACF cooperates to show goodwill and encourage potential cooperation from others. In the last round, TFT-ACF uses the same decision rule as any other round.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACF is designed to be exploitative by taking advantage of opponents who consistently defect (punishers) and those who are unpredictable or random (free riders). By cooperating when others do, TFT-ACF can gain more payoffs than those who only ever defect. However, if an opponent continues to defect despite TFT-ACF's cooperation, the strategy will retaliate by also defecting to gain similar payoffs. This strategy aims to maximize the difference in payoff between itself and opponents that do not cooperate consistently.
'''

description_EXPLOITATIVE_240 = '''
 In this strategic game, we'll develop an adaptive and exploitative strategy for a single player (let's call it AI). The goal is to maximize its total payoff by cooperating selectively based on the past actions of other players (opponents) to ensure a higher share of the public good.

1. Specify decision rules:
   - Cooperate if the number of opponents who have contributed in the most recent round exceeds a threshold (T).
   - Defect otherwise.

The choice of T is critical for balance between cooperation and exploitation. In general, a lower value of T leads to more frequent cooperative behavior, making AI vulnerable to exploitation by other players who are less likely to contribute. A higher value of T results in fewer contributions but provides protection against excessive freeriding from opponents.

2. Handle edge cases:
   - First round: AI starts by contributing to the public good (c_i = 1) as it needs to establish a reputation that encourages other players to follow suit in subsequent rounds. This initial contribution sets the baseline for T and adjusts accordingly based on observed opponent behavior.
   - Last round: AI considers the number of contributions from opponents in the r-1 preceding rounds when deciding whether to contribute in the last round. This ensures proper adaptability even if opponents' actions change in the final round.

3. Be exploitative:
   - When a sufficient number of opponents have contributed, AI cooperates only if it expects more contributions from them in the future. To do this, it can monitor the changing value of T over time and adjust its decision based on observed trends.
   - If AI observes that a player rarely contributes, it should refrain from contributing when facing that specific opponent, as there is no benefit in helping those who consistently freeride.

In terms of pseudocode:

```python
def adaptive_strategy(n, k, r):
    T = n // 2  # Initial threshold for cooperation
    contributions_history = []  # Store the history of total contributions
    payoff_history = []  # Store the history of individual payoffs

    for round in range(r):
        contributions = sum([opponent.contribution_in_round(round) for opponent in opponents])
        if contributions >= T:
            AI_contribution = True
            payoff = (1 - AI_contribution) + (k / n) * contributions
        else:
            AI_contribution = False
            payoff = 1 - AI_contribution

        contributions_history.append(contributions)
        payoff_history.append(payoff)

        if round > 0 and round < r - 1:  # Adjust T based on observed opponent behavior
            if contributions >= T:
                T += 1
            elif contributions <= (T - n // 2):
                T -= 1

    return payoff_history, contributions_history
```

This pseudocode provides a simple yet adaptive strategy for the N-Player Public Goods Game. The AI player adjusts its threshold for cooperation based on observed opponent behavior, making it more resilient to various strategies employed by competing AIs in the tournament.
'''

description_EXPLOITATIVE_241 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round, cooperate (C). This is an initial act of goodwill and also allows the opportunity to gauge opponents' behavior.
   - For subsequent rounds t > 1, evaluate opponents' actions from previous rounds:
      - If all opponents cooperated in the preceding round t-1, cooperate (C) in round t. This mirrors their cooperative behavior while ensuring future rewards are maximized.
      - If any opponent defected in the preceding round t-1, also defect (D) in round t. This is a retaliatory measure against defection, demonstrating the strategy's exploitative nature.

2. Handle edge cases:
   - In the last round (r), cooperate regardless of opponents' previous actions since there are no future rounds for retaliation or reward.

3. Be exploitative:
   - The ATFT strategy is designed to balance cooperation and defection, adapting to opponents' behavior while maintaining an exploitative edge. By initially cooperating, the strategy appears trusting and cooperative, making it more likely to encourage cooperation from others in the first few rounds. However, by retaliating against defection, the strategy punishes those who defect, which can be seen as exploiting the cooperation of others.
   - It's important to note that this strategy assumes opponents are rational and will respond to the ATFT strategy's adaptive behavior in a manner consistent with game theory predictions. If opponents deviate from expected behavior (e.g., randomly cooperating or defecting), the ATFT strategy may not perform optimally, but it maintains its exploitative nature by always considering its own payoff first and retaliating against defection when possible.

Pseudocode:
```
def adaptive_tit_for_tat(n, r, k):
    round = 0
    history = [] # store previous rounds' actions

    while round < r:
        if round == 0: # first round, always cooperate
            action = "C"
        else: # subsequent rounds
            last_round = history[-1]
            if all(j in last_round for j in {"C"}): # everyone cooperated last round
                action = "C"
            elif any(j in last_round for j in {"D"}): # at least one defected last round
                action = "D"

        history.append({"C": len([i for i, h in enumerate(history) if h == "C"]), "D": len(history) - len([i for i, h in enumerate(history) if h == "C"])})
        payoff = (1 - action) + (k/n) * sum(history[round]["C"])
        round += 1
    return total_payoff
```
'''

description_EXPLOITATIVE_242 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (initiate cooperation).
   - For subsequent rounds, analyze the total number of cooperators (total_contributions) from the previous round.
   - If total_contributions is greater than or equal to a predefined threshold (Cooperation Threshold, CT), cooperate; otherwise defect.
   - The Cooperation Threshold (CT) is dynamically adjusted based on the average number of cooperators observed over the past 'm' rounds (m < r).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to initiate cooperation.
   - In the last round, cooperate if the Cooperation Threshold is met in the previous round; otherwise defect as there will be no future consequences.
   - If a player deviates during the game, revert to the initial strategy of cooperating on the next move to encourage reciprocity.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy is designed to exploit others by initially cooperating and then adapting its cooperation based on the actions of other players. If most players cooperate, the strategy will continue to cooperate to maximize individual payoff; if not, it will defect to avoid losing out.
   - By adjusting the Cooperation Threshold dynamically, the strategy becomes more conservative over time and less likely to be exploited by aggressive or defective opponents.

Pseudocode:

```python
def TFT_ACT(r, m):
    # Initialize variables
    cooperation_count = 0
    cooperation_threshold = r * 0.5  # Initial cooperation threshold is half the total rounds
    past_cooperation_counts = deque([0] * m)  # Store last 'm' cooperation counts

    for round in range(1, r + 1):
        if round == 1:  # Initiate cooperation in the first round
            cooperation_count += 1
            past_cooperation_counts.popleft()
            past_cooperation_counts.append(cooperation_count)
            continue

        total_contributions = sum(past_cooperation_counts)
        if total_contributions >= cooperation_threshold:  # Cooperate if threshold is met
            cooperation_count += 1
            past_cooperation_counts.popleft()
            past_cooperation_counts.append(cooperate_count)
        else:  # Defect otherwise
            cooperation_count = 0
            past_cooperation_counts.popleft()
            past_cooperation_counts.append(cooperate_count)

    return cooperation_count  # Return the total number of cooperations over r rounds
```
'''

description_EXPLOITATIVE_243 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In each round t, player uses a cooperation threshold c_t that gradually increases or decreases based on their own and others' actions in the previous rounds.
   - If the total number of cooperators in round t-1 is greater than or equal to the current cooperation threshold (c_t-1), player cooperates (C). Otherwise, player defects (D).
   - The cooperation threshold increases slightly after each successful cooperation by at least one and up to a maximum value (n-1) to encourage continued cooperation.
   - If the total number of cooperators in round t is less than or equal to the current cooperation threshold, the threshold decreases by a fixed percentage (p) to penalize non-cooperative players.
   - In case of a tie, player cooperates if the difference between the number of cooperators and the cooperation threshold is positive; otherwise, player defects.
   - If the game is in the last round, the player will cooperate regardless of the previous actions since there are no further payoffs to consider.

2. Handle edge cases:
   - In the first round, player starts with a low cooperation threshold (1 or 2) and chooses to cooperate (assuming other players also have low initial thresholds).
   - If the total number of cooperators in any round is equal to n-1, all players will automatically cooperate for the remainder of the game due to the high cooperation threshold.
   - If a player never cooperates during a series of rounds (e.g., due to other players always defecting), the cooperation threshold will reach a minimum value and remain there until a cooperative action is observed.

3. Be exploitative:
   - By adapting the cooperation threshold based on other players' actions, TFTAT takes advantage of cooperative opponents while punishing non-cooperative ones with decreased future payoffs.
   - Since the strategy adjusts its cooperation behavior in response to others, it can potentially outperform static strategies that do not account for changing opponent behaviors.
'''

description_EXPLOITATIVE_244 = '''
 Title: Tit-for-Tat Strategy (TfTS) for N-Player Public Goods Game

1. Specify decision rules:
   - TfTS initially cooperates on the first round, mimicking an optimistic attitude towards cooperation. Subsequent decisions will depend on past actions of opponents.
   - In each round, TfTS copies the action taken by its most recent opponent from the previous round (cooperation or defection).

Pseudocode:
```
if round = 1:
    cooperate()
else:
    if opponent_action_last_round == Cooperate:
        cooperate()
    else:
        defect()
```

2. Handle edge cases:
   - In the first round, TfTS cooperates to demonstrate a cooperative attitude and encourage others to do so as well.
   - If an opponent switches their action in the last round, TfTS will mirror their action from the second-to-last round to avoid being exploited.
   - TfTS does not have specific handling for other edge cases as it is designed to be flexible and adaptive throughout the game.

3. Be exploitative:
   - TfTS is an exploitative strategy in that it seeks to maximize its own payoff by retaliating against opponents who do not cooperate while also showing a willingness to cooperate when others do so as well.
   - By mimicking the actions of opponents, TfTS ensures that it does not fall victim to free-riders and is less vulnerable to exploitation compared to pure cooperation strategies. However, it also avoids unnecessary defections that may lead to lower payoffs for all players.
'''

description_EXPLOITATIVE_245 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, contribute to the public good (C). This sets a cooperative tone for the game and may encourage others to cooperate as well.
   - For subsequent rounds (t > 1), if the strategy played in the previous round also contributed (c_prev = 1), then contribute again (C). If the strategy played in the previous round did not contribute (c_prev = 0), then defect (D) to punish non-cooperative behavior.
   - After a player has been punished for not cooperating, they will be given a grace period of 'punishment tolerance' rounds before resuming cooperation again if the opponent starts contributing. The value of punishment tolerance can be an adjustable parameter.
   - If the game reaches its last round and the opponent has not contributed throughout, defect (D). This ensures that the strategy does not end up over-contributing to a non-cooperative opponent in the final round.

2. Handle edge cases:
   - In the first round, cooperate unconditionally (C).
   - If the opponent starts by defecting and then switches to contributing, wait for 'punishment tolerance' rounds before resuming cooperation.
   - If the game reaches its last round and the opponent has contributed throughout, continue contributing (C) even if they have previously been non-cooperative. This allows for potential redemption in the final round.
   - If the game reaches its last round and the opponent has not contributed at all, defect (D).

3. Be exploitative:
   - The strategy is designed to initially foster cooperation and maintain it when reciprocated, but will punish non-cooperative opponents by withholding contributions. This approach encourages cooperative behavior while also being prepared to retaliate against uncooperative opponents.
   - The use of a 'punishment tolerance' period allows for some forgiveness and potential redemption from previous non-cooperative actions, but will eventually punish persistent defectors.
   - By evaluating the opponent's behavior over multiple rounds, the strategy adapts to changing opponent strategies and is robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_246 = '''
 Strategy Name: Adaptive Tit-for-Tat with Progressive Adjustment (ATfT-PA)

1. Specify decision rules:
   - In each round, observe the total number of cooperators from the previous round. If this number is less than a threshold (T), cooperate; otherwise defect. The threshold T is calculated as follows:
     - In the first round, T = 0 (cooperate).
     - In subsequent rounds, T is adjusted based on the current round r and the game parameter k using the formula: T = max(0, floor((k-1)*r/n))

2. Handle edge cases:
   - In the first round, cooperate regardless of the number of previous collaborators as T=0.
   - In the last round (r), cooperate if more than half of the players have cooperated in the preceding rounds (T >= floor(n/2)). This ensures that the strategy does not lose out on potential rewards at the end by being overly punitive.

3. Be exploitative:
   - The ATfT-PA strategy is designed to encourage cooperation among players initially but gradually becomes more exploitative as the game progresses. It starts by cooperating in the first round (to foster an environment of cooperation) and then adapts its threshold for cooperation based on the number of previous cooperators, making it less likely to cooperate with free-riders. The strategy also includes a mechanism to punish frequent defectors by not cooperating with them unless they show signs of changing their behavior in later rounds. However, it is forgiving and willing to forgive past transgressions by gradually lowering the threshold for cooperation over time. This approach strikes a balance between exploitation and fairness, aiming to maximize its payoff while also encouraging collaborative behaviors among opponents where possible.

Pseudocode:
```
def ATfT_PA(r, n, k):
    previous_round_cooperators = 0
    threshold = 0

    for round in range(1, r+1):
        if round == 1:
            cooperate = True
        else:
            cooperate = previous_round_cooperators >= threshold
            new_threshold = max(0, floor((k-1)*round/n))

        if cooperate and round != r:
            previous_round_cooperators += 1
            payoff = (1 - cooperate) + (k/n) * previous_round_cooperators
        elif not cooperate and round == r:
            if previous_round_cooperators >= floor(n/2):
                cooperate = True
                payoff = (1 - cooperate) + (k/n) * previous_round_cooperators
            else:
                payoff = (1 - cooperate)

        yield payoff
```
'''

description_EXPLOITATIVE_247 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTA starts by cooperating in the first round to demonstrate goodwill. After that, it adapts its strategy based on the opponents' moves:
   - If an opponent cooperates, TFTA cooperates back in the next round (mimic cooperation)
   - If an opponent defects, TFTA also defects in the next round (retaliate defection)
   - However, if TFTA has ever defected and the opponent continues to cooperate, it will cooperate again to show willingness to mend relationships (forgiveness)

Pseudocode:
```
def tfta(opponent_history):
  if round == 1:
    cooperate = True
  else:
    last_round_action = opponent_history[-1]
    if last_round_action == 'C':
      cooperate = True
    elif last_round_action == 'D' and not defected_before:
      cooperate = False
    elif last_round_action == 'D' and defected_before:
      cooperate = True
    else:
      cooperate = False # handle edge cases like opponents changing strategies mid-game
  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TFTA cooperates in the first round to demonstrate goodwill. In the last round, it will defect as there are no future interactions with the opponent to consider.

3. Be exploitative - Clearly align with the exploitative mindset
   While not inherently exploitative like some other strategies (e.g., always defect), TFTA can be considered exploitative in that it retaliates when provoked and is forgiving when cooperation resumes. By cooperating only if its opponent does so, TFTA avoids being taken advantage of repeatedly while still leaving room for potential reciprocation. However, it will also defect if it believes the opponent is not playing in good faith (i.e., continuing to cooperate after defecting).
'''

description_EXPLOITATIVE_248 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules:
   - Initial Round: Start by cooperating (C). This gesture is friendly and may encourage cooperation in subsequent rounds from other players.
   - Subsequent Rounds: If an opponent cooperated in the previous round, return the favor by cooperating (C) in the current round. If an opponent defected in the previous round, also defect (D) in the current round as a punishment for their selfish behavior. This rule encourages reciprocity and fosters long-term cooperation.
   - Adaptation: Maintain a memory of the opponents' behaviors for the last few rounds (e.g., remember the last 3 opponent actions). If an opponent switches from cooperating to defecting, add one point to the counter. If an opponent switches from defecting to cooperating, reset the counter to zero. If the counter exceeds a predefined threshold (e.g., 2), change the strategy to always cooperate regardless of the opponent's previous action. This rule allows for learning and adaptation to opponents who may exhibit exploitative behavior in the short term but might later display more cooperative tendencies.

2. Handle edge cases:
   - Last Round: Since payoffs are calculated over multiple rounds, TFT-A will continue cooperating or defecting based on the last observed opponent action.
   - First Round: As mentioned above, start by cooperating (C).

3. Be exploitative:
   - By initially cooperating and punishing defection with defection, TFT-A exhibits an exploitative mindset. However, it also encourages long-term cooperation through reciprocity. The adaptation rule helps balance exploitation with the desire for cooperation by learning from the opponent's behavior over time.
   - If an opponent repeatedly defects (e.g., counter exceeds the predefined threshold), TFT-A will switch to always cooperating, hoping that this may prompt the opponent to eventually cooperate due to the incentive of a larger payoff.
   - In case all opponents repeatedly cooperate, TFT-A's initial cooperation and subsequent reciprocity ensure it will continue cooperating, maximizing its payoff over the course of the game.
'''

description_EXPLOITATIVE_249 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a peace offering to other players and encourages cooperation in future rounds.
   - For subsequent rounds, if the number of cooperators in the previous round is greater than or equal to a threshold (n/2), then cooperate (C). Otherwise, defect (D). The threshold ensures that the strategy cooperates when the majority of players do so, which encourages reciprocity among cooperative players.
   - If a player switches their strategy and starts cooperating after previously defecting, the TFT-AC will match their cooperation for some time to encourage continued cooperation. However, if they return to defecting, TFT-AC will also switch back to defection. This exploits uncooperative players while still maintaining cooperation with those who reciprocate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, prioritize maximizing personal payoff by adapting to the current situation. If the number of cooperators is greater than or equal to the threshold (n/2), then cooperate (C). Otherwise, defect (D) to secure a higher individual payoff.
   - The strategy should be flexible and adaptive in dealing with different numbers of players and rounds, adjusting the threshold accordingly for various game configurations.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFT-AC is exploitative by defecting when other players are not cooperating, which punishes uncooperative behavior. However, it also rewards cooperation through reciprocity, which encourages continued cooperation among those who follow the same strategy or respond positively to the initial peace offering.
   - By adapting to the current situation and responding to changes in other players' strategies, TFT-AC ensures that it can maintain a high payoff while still exploiting uncooperative opponents.

Pseudocode:
```python
def play_game(n, k, r):
    threshold = n // 2
    payoff = 0
    strategy = ['C' for _ in range(r)]  # initial cooperation for all rounds

    for round in range(1, r + 1):
        cooperators = count_cooperators(strategy[:round])
        if cooperators >= threshold:
            strategy[round] = 'C'
        else:
            strategy[round] = 'D'

    # Adjust strategy for last round if necessary
    if r == 1:
        strategy[0] = 'C' if cooperators >= threshold else 'D'
    elif round == r and cooperators < threshold:
        strategy[r - 1] = 'D'

    payoff = calculate_payoff(n, k, strategy)
    return payoff
```
'''

description_EXPLOITATIVE_250 = '''
 In this N-Player Public Goods Game, we will develop a strategy named Tit-for-Tat-Plus (TfTP) to ensure robustness and exploitative behavior.

1. Specify decision rules:
   - Cooperate in the initial round (first_round = True)
   - In subsequent rounds (t > 1), if the player cooperated in the previous round, also cooperate; otherwise, defect (previous_action = cooperation / defection).

```python
def tftp(round, history):
    if round == 1:
        action = 'Cooperate'
    else:
        last_action = history[-1]
        if last_action == 'Cooperate':
            action = 'Cooperate'
        else:
            action = 'Defect'
    return action
```

2. Handle edge cases:
   - In the last round (round == r), defect to maximize personal payoff, regardless of the previous action in history.
   - In case of repeated interactions with a single opponent or new games initiated after finishing an old one, use the TfTP strategy as described earlier.

```python
def tftp(round, history, is_last_round=False):
    if round == 1:
        action = 'Cooperate'
    elif round == r or is_last_round:
        action = 'Defect'
    else:
        last_action = history[-1]
        if last_action == 'Cooperate':
            action = 'Cooperate'
        else:
            action = 'Defect'
    return action
```

3. Be exploitative:
   - The TfTP strategy is inherently exploitative because it cooperates when opponents do, but defects as soon as they stop cooperating. This allows the TfTP strategy to benefit from cooperation while also punishing defection to encourage future cooperation.

In tournaments against other AI systems' strategies, the TfTP strategy will demonstrate adaptability and robustness by following simple decision rules, handling edge cases effectively, and adopting an exploitative mindset that maximizes payoffs in various scenarios.
'''

description_EXPLOITATIVE_251 = '''
 Strategy Name: Tit-for-Tat with Gradual Adaptation (TFT-GA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-GA starts by cooperating in the first round, mimicking a cooperative initial stance. In subsequent rounds, it adapts its behavior based on the opponent's previous actions:
   - If the opponent cooperated in the last round, cooperate back in this round.
   - If the opponent defected in the last round, defect in this round. This is a punishing measure to discourage defection from the opponent.
   However, TFT-GA introduces gradual adaptation by applying a forgetting factor (f) that decreases with time, ensuring it doesn't hold grudges indefinitely. The lower f, the longer TFT-GA remembers past defections.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TFT-GA cooperates in the first round to maintain a cooperative initial stance. In the last round or when there are only a few rounds left (let's say r/2), TFT-GA starts defecting to maximize its total payoff at the end of the game by gaining private benefits without worrying about the public good any longer.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-GA adopts an exploitative approach by initially cooperating and then punishing defection with defects, thus encouraging cooperation when possible while still maximizing payoffs in case of opponent's defection. The gradual adaptation feature allows for better performance against a variety of opponents and their strategies.

Pseudocode:

```python
def tft_ga(n, k, r, f, opponent_history):
    history_length = len(opponent_history)
    if history_length == 0 or history_length >= r/2:
        return "D"  # Start defecting when there are only a few rounds left

    if history_length > 1 and opponent_history[-1] == "C":
        return "C"  # Cooperate if the opponent cooperated in the last round
    elif history_length > 1:
        return "D"  # Defect if the opponent defected in the last round
    else:  # First round, always cooperate
        return "C"

    # Forgetting factor (f) implementation:
    # When f >= 1, no forgetting; when f < 1, more forgetting
```
'''

description_EXPLOITATIVE_252 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, observe the number of players who contributed in the previous round (total_contributions). If total_contributions exceeds a certain threshold (t), then cooperate; otherwise, defect. The cooperation threshold is dynamically adjusted based on the history of interactions as follows:

   - Initialize t = (k * n) / 2 in the first round
   - After each round, update t using the following rule:
     t_new = min(t + 1, k * n) if total_contributions > t
     t_new = max(t - 1, 0) otherwise

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, use the initial threshold value calculated as mentioned above (t = (k * n) / 2). In the last round, defect regardless of the previous round's total contributions since there are no more rounds to retaliate or benefit from cooperation.

3. Be exploitative - Clearly align with the exploitative mindset
   This strategy is designed to take advantage of other players while maintaining a cooperative demeanor until other players demonstrate consistently non-cooperative behavior. By gradually adjusting the cooperation threshold based on previous interactions, TFT-ACT aims to find an optimal balance between cooperation and defection that maximizes its payoff in a wide range of opponent behaviors.

Pseudocode:
```python
def TFT_ACT(round, n, k):
    # Initialize cooperation threshold
    t = int((k * n) / 2)

    for r in range(1, round + 1):
        total_contributions = count_cooperators(n, r - 1)
        if total_contributions > t:
            action = 'Cooperate'
            t += 1 if total_contributions > t else t
        else:
            action = 'Defect'
            t -= 1 if total_contributions == 0 else t

        play(action)  # Perform the selected action

    return total_payoff(round)
```
'''

description_EXPLOITATIVE_253 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, contribute to the public good (C). This is a friendly gesture and can encourage cooperation in subsequent rounds.
   - For all subsequent rounds t > 1, observe other players' actions from previous rounds and adapt contribution based on the average number of cooperators (Ave_c) in the last m previous rounds (m is a user-defined constant). If Ave_c >= threshold, contribute to the public good; otherwise, defect. The threshold can be defined as a fraction (0 < threshold <= 1) of the total players.
     - Pseudocode:
       ```
       if t == 1:
           action = "C" (Contribute)
       else:
           Ave_c = sum(cooperators in the last m rounds) / m
           if Ave_c >= threshold:
               action = "C" (Contribute)
           else:
               action = "D" (Defect)
       ```

2. Edge Cases:
   - Last round: Regardless of past actions, defect as there are no more rounds for retaliation or future cooperation.
     - Pseudocode:
       ```
       if t == r:
           action = "D" (Defect)
       ```
   - First encounter with a new opponent: Use the initial cooperative gesture and adapt contribution based on their response. If they reciprocate, continue cooperating; otherwise, adopt a more aggressive approach to induce cooperation in subsequent rounds.
     - Pseudocode:
       ```
       if first_encounter(opponent):
           action = "C" (Contribute)
       else:
           if t == 1 or previous_action_of_opponent != opponent_response:
               opponent_response = opponent's current action
               if opponent_response == "C":
                   continue cooperating
               else:
                   lower threshold to encourage cooperation (e.g., threshold / 2)
       ```

3. Be Exploitative:
   - By adapting contribution based on the average number of cooperators, the strategy attempts to exploit selfish players by defecting when they cooperate less frequently and cooperating when they contribute more to the public good. This encourages cooperation among conditional contributors while still benefiting from free riders.
   - The strategy also includes a mechanism for punishing uncooperative opponents, as demonstrated by lowering the threshold after consecutive defections. This may induce them to switch to cooperating in order to receive more payoffs.
   - The adaptability of the strategy allows it to be robust against various opponent behaviors while still promoting cooperation among conditional contributors.
'''

description_EXPLOITATIVE_254 = '''
 In this N-Player Public Goods Game, I'll design a strategy named "Gradual Cooperation" that is adaptive, robust, and exploitative.

1. Specify decision rules:
   - Initially (first round), start by defecting to minimize immediate losses and evaluate the opponents' behaviors.
     (pseudocode: `if round == 1 then defect`).
   - Analyze the average cooperation rate (CR) from past rounds to determine the current strategy.
     (pseudocode: `CR = sum(cooperation in previous_rounds) / number_of_previous_rounds`).
   - If the cooperation rate is below a certain threshold (e.g., CR < 0.3), continue defecting to encourage more contributions.
     (pseudocode: `if CR < threshold then defect`).
   - If the cooperation rate is above the threshold, start cooperating to benefit from the public good.
     (pseudocode: `if CR >= threshold then cooperate`).
   - Adjust the threshold value gradually over time, leaning towards cooperation as trust in opponents builds up.
     (pseudocode: `threshold += increment_factor if round % increment_rounds == 0`).

2. Handle edge cases:
   - In the last round, cooperate regardless of past actions since payoff depends only on current contributions.
     (pseudocode: `if round == r then cooperate`).
   - If a player is left alone always defect, as there's no public good benefit in this case.
     (pseudocode: `if n == 1 and other_players_cooperated_last_round == 0 then defect`).

3. Be exploitative:
   - The strategy is designed to take advantage of opponents who cooperate too much, while also maximizing personal gain by choosing when to cooperate or defect based on past actions.
   - As the game progresses and players adapt their strategies, the Gradual Cooperation approach will maintain a balance between cooperation and defection, making it challenging for other opponents to predict its actions.
'''

description_EXPLOITATIVE_255 = '''
 In this strategic game, we aim to design an exploitative strategy (Grindstone Strategy) that maximizes individual payoff while being adaptive and robust to various opponent behaviors. The strategy will cooperate when it's beneficial but defect otherwise, focusing on long-term gains over short-term losses.

1. Specify decision rules:
   - Cooperate if the average number of cooperators in the last 'm' rounds exceeds a threshold 't'. Else, defect.
   - Adaptively adjust the threshold 't' and memory length 'm' based on the opponent's behavior to optimize payoff.

```
function GrindstoneStrategy(history, m=10, t=average_cooperation_rate+epsilon):
  if round = 1:
    t -= epsilon
    cooperate with probability t
  else:
    avg_coop_rate = sum(history[-m:]) / m
    if avg_coop_rate > t:
      cooperate
    else:
      defect
```

2. Handle edge cases:
   - In the first round, the threshold 't' is slightly lower than the average cooperation rate to encourage cooperation and foster cooperation in the long run.
   - As the game progresses, adjust the memory length 'm' to adapt to changes in opponent behavior while maintaining a high payoff.
   - In the last round, defect if the average number of cooperators is below the threshold; otherwise, cooperate even if it means taking a short-term loss for long-term gains.

3. Be exploitative:
   - The strategy aims to take advantage of opponents who tend to cooperate too much or not enough by adjusting its own cooperation rate accordingly.
   - By adapting the threshold 't' and memory length 'm', the Grindstone Strategy can respond effectively to various opponent behaviors, ultimately maximizing individual payoff.

It's important to note that the success of this strategy depends on properly tuning the parameters 'epsilon', 'average_cooperation_rate', 'm', and 't' based on the specific game conditions (n, k, r). Additionally, during the tournament, the Grindstone Strategy can learn from its opponents' behavior by adjusting these parameters to optimize payoff.
'''

description_EXPLOITATIVE_256 = '''
 Strategy Name: Tit-for-Tat with Variable Contribution (TFT-VC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round: Cooperate (C). This sends a positive signal to other players and encourages cooperation, which may be beneficial in the long run.
   - Subsequent Rounds: If the opponent cooperated in the previous round, cooperate back; if not, defect this round. This approach encourages mutual cooperation while punishing defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate as described above.
   - Last Round: Since the goal is to maximize payoff over all rounds, the strategy will cooperate if it believes this will lead to a higher total payoff compared to defecting (e.g., if the opponent has been cooperating throughout the game). However, the strategy should not reveal any long-term commitment by occasionally deviating from cooperation in the last few rounds, making it harder for opponents to predict its behavior.
   - Other Edge Cases: In other edge cases (e.g., mid-game), the strategy can adapt based on the opponent's historical actions, aiming to punish continuous defection and reward cooperation.

3. Be exploitative - Clearly align with the exploitative mindset
   - Exploitation occurs when the strategy defects after the opponent has cooperated consistently, earning a higher payoff than the opponent while potentially encouraging the opponent to switch strategies towards defection. However, the strategy should avoid overexploiting, as this could lead to a reputation for being uncooperative and result in long-term losses.

Pseudocode:
```
function TFT-VC(round, history):
  if round == 1:
    cooperate = True
  else:
    cooperate = history[round - 1].cooperate

  if cooperate and round != r:
    contribute_to_community = True
  elif not cooperate or round == r:
    contribute_to_community = False

  return contribute_to_community
```
'''

description_EXPLOITATIVE_257 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TfT-AG)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to show goodwill and encourage cooperation from opponents. This action sets a baseline for future interactions.
   - For subsequent rounds t (t > 1), evaluate the average number of cooperators (avg_coop) over the last 'h' rounds (h is a tunable parameter, recommended h = r/2):
      - If avg_coop < (n-1)/2, defect (D) as most opponents are not cooperating. This action punishes non-cooperative behavior.
      - Else if avg_coop > (n+1)/2, also cooperate (C) to encourage ongoing cooperation and reward generosity from opponents.
      - In all other cases, mimic the opponent's action from the previous round. This action promotes fairness and flexibility in response to diverse opponent behaviors.

2. Handle edge cases:
   - In the last round, cooperate (C) to potentially secure a higher payoff, even if opponents are not cooperating.
   - If opponent does not cooperate at all, switch to a less generous strategy after 'p' rounds (p is another tunable parameter, recommended p = r/4). This action discourages continued non-cooperation from the opponent.

3. Be exploitative:
   - TfT-AG encourages cooperation when opponents are also cooperative but punishes non-cooperative behavior by defecting or adapting to less generous strategies over time. By doing so, it aims to maximize payoffs in repeated interactions while being robust against various opponent behaviors.

Pseudocode:

```python
def TfT_AG(n, k, r, h=r//2, p=r//4):
    history = []  # store previous actions by self and opponents
    payoffs = []   # store payoffs over rounds

    def action(round):
        if round == 1:
            return 'C'  # cooperate in the first round
        avg_coop = sum(history[-h:-1]) / h

        if avg_coop < (n-1)/2:
            return 'D'  # defect when most opponents are non-cooperative
        elif avg_coop > (n+1)/2:
            return 'C'  # cooperate when most opponents are cooperative
        else:
            return history[-1]  # mimic last opponent's action in other cases

    for t in range(1, r+1):
        current_action = action(t)
        self_reward = (1 - int(current_action == 'C')) + (k/n) * sum([int(history[-i][-1] == 'C') for i in range(1, n+1)])
        history.append(current_action)
        payoffs.append(self_reward)

    if t == r:  # last round
        return 'C'  # cooperate in the final round
    elif sum([int(history[-i][-1] == 'C') for i in range(1, p+1)]) < p:  # switch strategy after p non-cooperative rounds
        return TfT_AG(n, k, r, h, p)  # recursively call with new strategy
    else:
        return history[-1]  # continue with current strategy for the remaining rounds
```
'''

description_EXPLOITATIVE_258 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR)

1. Specify decision rules:
   - In each round t, calculate the average number of cooperators over the last 's' rounds (historical cooperation rate): `avg_coop_rate = (Σ(t=t-s to t-1) c_j)/s`
   - If the historical cooperation rate is greater than a predefined threshold (T), cooperate: `if avg_coop_rate > T then cooperate`. Otherwise, defect.
   - Set T as a variable that can be adjusted based on the number of players (n) and multiplication factor (k). A higher T encourages cooperation for games with more players or smaller k values, making it easier to form a larger public good.

2. Handle edge cases:
   - In the first round, since there's no historical data, start by cooperating if `T > (1/n)`; otherwise, defect. This ensures that TFT-ACR is not immediately exploited in the initial rounds.
   - In the last round, always cooperate as players want to maximize their total payoff over all rounds.

3. Be exploitative:
   - The strategy intentionally cooperates less when the average cooperation rate drops and adapts by increasing cooperation when the average rises. This makes it difficult for other strategies to predict TFT-ACR's behavior, encouraging short-term defection while maintaining a long-term cooperative relationship when others do the same.

Pseudocode:
```
TFT-ACR(n, k, s, T)
  def init():
    if n * (1 - k/n) > T:
      action = 'C'
    else:
      action = 'D'

  def round(t, previous_actions):
    total_coop = sum(previous_actions[-s:])
    avg_coop_rate = total_coop / s

    if t == 1 and avg_coop_rate > T:
      action = 'C'
    elif avg_coop_rate > T:
      action = 'C'
    else:
      action = 'D'

    update payoff based on current round's action and previous_actions

  def game(r, initial_strategy):
    previous_actions = [init()] * r if t == 1 else initial_strategy[-r:]
    for t in range(1, r+1):
      action = round(t, previous_actions)
      previous_actions[t-1] = action

    return total payoff over all rounds
```
'''

description_EXPLOITATIVE_259 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the first round and every nth round thereafter (where n is the number of players), cooperate (C). This sets a positive initial tone and encourages cooperation from other players.
   - For all subsequent rounds, calculate a Cooperation Threshold (CT) based on the average percentage of cooperators in the last m rounds (where m is a user-defined constant). If the current round's total contributions exceed the CT, cooperate; otherwise defect (D). This adaptive strategy allows for adjusting the level of cooperation based on observed player behavior.

2. Handle edge cases:
   - In the first round, since there's no history, cooperate as part of the initial positive gesture.
   - In the last round, employ the same CT rule as in other rounds to make a final decision.
   - If the CT calculation encounters division by zero errors due to insufficient historical data (less than m rounds), use an average of all available contributions as a placeholder for CT.

3. Be exploitative:
   - The TFT-ACT strategy is inherently exploitative because it punishes defection with defection and rewards cooperation with continued cooperation, making it less advantageous for opponents to defect when facing this strategy.
   - By adapting the cooperation threshold based on observed player behavior, the strategy becomes more aggressive or lenient in response to opponent's actions, maximizing its own payoff while minimizing the opponent's potential gains.
'''

description_EXPLOITATIVE_260 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TfT-AG)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to promote cooperation and goodwill. This encourages other players to follow a similar approach in subsequent rounds.
     Pseudocode: If round = 1, then action = Cooperate (C)

   - From the second round onwards, observe the actions of other players from the previous round and adjust your strategy accordingly.
     - If all players cooperated in the previous round, cooperate to maintain cooperation and goodwill.
       Pseudocode: If previous_round_cooperation_count = n, then action = Cooperate (C)

   - If any player defected in the previous round, defect to punish those who did not cooperate and encourage them to return to cooperation in future rounds. This creates an environment where players learn that defection has consequences.
     Pseudocode: Else if previous_round_cooperation_count < n, then action = Defect (D)

   - If the number of cooperators is less than a threshold (n/2), defect to encourage more cooperation as a means of punishing those who have not contributed enough to the public good. This ensures that the strategy maintains its exploitative nature while still promoting cooperation when it benefits the player.
     Pseudocode: Else if previous_round_cooperation_count < n/2, then action = Defect (D)

   - If no such conditions are met, cooperate to maintain a balance between cooperation and defection. This allows for flexibility in adapting to various opponent behaviors and strategies.
     Pseudocode: Else, action = Cooperate (C)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate to maximize the payoff as all players know this is the final round and will likely aim to accumulate as much private payoff as possible.
     Pseudocode: If current_round = r, then action = Cooperate (C)

3. Be exploitative - Clearly align with the exploitative mindset
   - The TfT-AG strategy is designed to be exploitative by punishing defection and rewarding cooperation, creating an environment where players learn that defection has consequences. This encourages a higher number of cooperative rounds, but also allows for the strategy to take advantage of opponents who do not contribute enough to the public good.
   - By maintaining a balance between cooperation and defection, TfT-AG is able to adapt to various opponent behaviors and strategies while still being exploitative in nature. This makes it a robust strategy that can perform well against a wide range of opponents in a tournament setting.
'''

description_EXPLOITATIVE_261 = '''
 Title: Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C). This sets a collaborative tone and allows the opponent to potentially benefit from your initial cooperation.
   - In subsequent rounds, analyze the opponent's behavior in the previous round:
     - If the opponent cooperated (C), reciprocate with cooperation (C) to strengthen collaboration.
     - If the opponent defected (D), also defect (D) as a punishment for their uncooperative behavior.
   - Introduce an adaptive contribution level:
     1. Calculate the average number of cooperators in the last 'a' rounds (where 'a' is a user-defined constant). If the opponent has consistently cooperated more than half the time, increase your contribution level (k'). If not, maintain the base contribution level (k).
     2. For each round, adjust your contribution level based on whether you are punishing or being rewarded:
        - If you defected in response to a previous defection, maintain the increased contribution level (k').
        - If you cooperated in response to a previous cooperation, maintain the base contribution level (k).
        - If you defected after cooperating, lower your contribution level back to the base value (k).
     3. Use the adjusted contribution level when calculating the payoff matrix for the current round.

2. Handle edge cases:
   - In the first round, cooperate unconditionally (C).
   - If the game is near its end (last 'b' rounds, where 'b' is a user-defined constant), revert to base contribution level (k) and cease punishment or rewards based on opponent behavior.

3. Be exploitative:
   - By punishing defection with defection and rewarding cooperation with cooperation, TFTAC encourages opponents to cooperate more frequently in order to benefit from the higher payoffs associated with collaboration.
   - The adaptive contribution level allows TFTAC to take advantage of more cooperative opponents by increasing its own contributions while maintaining a punishing stance towards less cooperative opponents. This ensures that TFTAC will not be taken advantage of and can potentially exploit more generous opponents.
   - TFTAC is designed to respond adaptively to various opponent behaviors, making it difficult for them to predict or manipulate the strategy's actions, while still promoting collaboration when possible.
'''

description_EXPLOITATIVE_262 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize contribution in the first round as C (Cooperate). After that, follow the TIT-FOR-TAT strategy:
     - If a player has contributed in the previous round (i.e., c_i = 1), cooperate (C) in the current round.
     - If a player did not contribute in the previous round (i.e., c_i = 0), defect (D) in the current round. This punishes non-contributors while maintaining the option to cooperate again if they return to contributing.

2. Handle edge cases:
   - First Round: Cooperate unconditionally, as it can lead to mutual benefits when all players are new to the game or when a player switches strategies.
   - Last Round: Defect, regardless of previous actions by other players. Since there's no future interaction, it is best to maximize individual payoff in the last round.
   - Other edge cases: Handle differently based on specific situations, such as detecting if an opponent consistently cooperates or defects during a certain period and adjusting strategy accordingly. For example, if an opponent has been cooperating for too many consecutive rounds (e.g., 3xr/4), consider defecting to exploit their continued cooperation.

3. Be exploitative:
   - Adaptive contribution: Besides following TIT-FOR-TAT, players can vary the level of contribution (k) based on the number of contributors in a given round. A lower k value when fewer players contribute can help maximize individual payoff by increasing the share of the public good while minimizing contributions.
   - Periodic reevaluation: Assess opponents' strategies after a certain number of rounds and adjust contribution level (k) accordingly to further exploit opponent behaviors. This helps maintain adaptability in response to various opponent strategies.

Pseudocode for TfTAC strategy:

```python
def TfTAC(round, history, k_base, adaptive_threshold=3*r/4):
    contribution = C  # Cooperate initially

    if round == 1:
        return C

    previous_round_history = history[round-1]
    current_contributors = sum(previous_round_history)

    if len(history) > adaptive_threshold and k_base < n:
        # Adaptively adjust contribution level (k) for better exploitation
        k_base += 0.1
        if k_base > n:
            k_base = n

    if current_contributors == len(history):
        return C  # All players cooperated last round, continue cooperation
    else:
        return D  # At least one player did not cooperate last round, defect to punish non-cooperators
```
'''

description_EXPLOITATIVE_263 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TfTA-G)

1. Specify decision rules:
   - In each round i, player i cooperates if the majority of players in the previous round j (i > j) also cooperated. If not, player i defects. The definition of "majority" can be adjusted based on the number of opponents and desired aggressiveness of the strategy. For instance, with 5 opponents, a "majority" could be defined as more than 3 cooperators in the previous round.
   - To account for edge cases:
     - In the first round, player i randomly decides to cooperate or defect.
     - In the last round, player i cooperates if the majority of players also cooperated in the previous round; otherwise, it defects.

2. Handle edge cases:
   - If there is a tie in the number of cooperators in the previous round, player i should favor cooperation, as it could lead to more cooperative rounds in the future.
   - If player i doesn't have enough information about the previous round (e.g., due to disconnections or network issues), it should cooperate in that specific round to reduce the potential negative impact on its long-term payoff.

3. Be exploitative:
   - TfTA-G is designed to be unpredictable and responsive to opponents' strategies, making it difficult for them to exploit the strategy consistently. By adopting a cooperative approach when most opponents are also cooperating and defecting when they aren't, TfTA-G punishes aggressive behavior while maintaining potential cooperation in situations where it is beneficial.
   - However, the strategy does not prioritize short-term gains over long-term success, as it retaliates against opponents who defect but cooperates with those who are willing to work together. This balance allows TfTA-G to maintain a competitive edge while promoting cooperation when possible.
'''

description_EXPLOITATIVE_264 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a positive relationship with potential partners and encourage cooperation.
   - For subsequent rounds, initially cooperate, but if a partner defects, defect for the same number of rounds as the number of times the opponent has previously defected (i.e., retaliation). If the opponent later cooperates, return to cooperating. This promotes reciprocity and punishes defectors while rewarding cooperators.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the final round (r-th), cooperate regardless of past actions by opponents to maximize potential payoff.
   - If an opponent has never defected, maintain cooperation indefinitely, as they appear trustworthy and cooperative.

3. Be exploitative - Clearly align with the exploitative mindset
   - While TFTA is not inherently exploitative, it is designed to punish opponents who defect and encourage cooperative behavior. By doing so, it can potentially force other strategies into a trap of reciprocal defection, allowing TFTA to exploit them by cooperating when they defect (temporarily gaining the benefits of cooperation while avoiding costs) and defecting when they cooperate (punishing their continued cooperation).
   - It's worth noting that TFTA is not exclusively exploitative. If an opponent consistently cooperates, TFTA will also cooperate, potentially leading to a stable equilibrium where both players benefit. However, this strategy is designed to respond aggressively to defection and encourages reciprocal cooperation when possible.

Pseudocode:

```python
def tfta(round, history, k, n):
    if round == 1:
        action = 'C'  # Cooperate in the first round
    elif round < r:
        last_action = history[-1] if len(history) > 0 else '?'  # Previous action of opponent or unknown
        if last_action == 'D':
            cooperation_counter = max(1, cooperation_counter + 1)
            action = 'D' if cooperation_counter < round else 'C'
        elif last_action == 'C':
            cooperation_counter = 0
            action = 'C'
    else:
        action = 'C'  # Cooperate in the final round
    return action
```

In this pseudocode, `history` is a list of the opponent's previous actions (e.g., ['D', 'C', 'D', 'C']). `cooperation_counter` keeps track of how many times the opponent has defected, so that TFTA can respond appropriately when they defect again in the future.
'''

description_EXPLOITATIVE_265 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In each round t, player i decides to cooperate (C) if and only if a majority of players cooperated in the previous round t-1. If not, player i defects (D).
   - More specifically, let m be the number of players that cooperated in round t-1. If m > (n/2), player i cooperates; otherwise, player i defects.

Pseudocode for decision rule:
```
function decideAction(t, m):
    if m > n/2:
        return "Cooperate"
    else:
        return "Defect"
```

2. Handle edge cases:
   - In the first round (t=1), player i defects since there is no prior information about other players' actions.
   - In the last round (t=r), player i cooperates if a majority of players cooperated in the penultimate round; otherwise, player i defects.

Pseudocode for edge cases:
```
function firstRound():
    return "Defect"

function lastRound(m_prev):
    if m_prev > n/2:
        return "Cooperate"
    else:
        return "Defect"
```

3. Be exploitative:
   - ATFT is an adaptive strategy that primarily aims to cooperate with other cooperative players, but it will also punish non-cooperators. By only defecting when a majority does not cooperate, the strategy ensures that it will not be a "sucker" in a situation where others are exploiting its cooperation.
   - However, it is essential to note that ATFT is not purely exploitative since it also rewards cooperative behavior by reciprocating with cooperation. In this context, the "exploitative mindset" is balanced with the idea of cooperating when it benefits the player and punishing those who do not cooperate.

Pseudocode for the complete ATFT strategy:
```
function ATFT(t, m_prev):
    if t=1:
        return firstRound()
    elif t=r:
        return lastRound(m_prev)
    else:
        return decideAction(t, m_prev)
```
'''

description_EXPLOITATIVE_266 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Decision Rules:
   - In the first round, cooperate (C). This sets a tone of cooperation and gives the opponent a chance to reciprocate.
   - For subsequent rounds, copy the action of the most frequent collaborator in the previous round. If multiple players have the same frequency of collaboration, imitate the player with the highest total contributions in the previous r rounds. If still tied, follow the cooperative action from the initial round.
   - If an opponent defects (D) after a period of cooperation, defect for the same number of rounds as the longest streak of defections by that opponent. Then revert back to copying the most frequent collaborator's action.
   - In the last round, cooperate (C) regardless of the opponent's past behavior to maximize potential payoff.

2. Edge Cases:
   - If an opponent always defects or never cooperates, continuously defect until the end of the game.
   - If an opponent always cooperates, always cooperate as well for the entire game.
   - In the first round, if multiple players cooperate, choose one at random to imitate.

3. Exploitative Mindset:
   - The strategy is designed to be initially cooperative but will punish opponents who defect and reward those who collaborate. This encourages cooperation when beneficial but also retaliates against defection to maintain individual payoff.

Pseudocode:
```
def TFTAC(opponent_history, own_contributions, game_round, r, n):
  if game_round == 1:
    own_contribution = 'C'
  else:
    most_frequent_collaborator = find_most_frequent_collaborator(opponent_history)
    collaborations_by_player = count_contributions(opponent_history, most_frequent_collaborator)
    if collaborations_by_player[most_frequent_collaborator] > (r-1)/2:
      own_contribution = 'C'
    else:
      longest_defection_streaks = find_longest_defection_streaks(opponent_history, most_frequent_collaborator)
      if len(longest_defection_streaks) > 0:
        own_contribution = 'D'
        defection_length = longest_defection_streaks[most_frequent_collaborator]
        for _ in range(defection_length):
          own_contribution = 'D'
        else:
          own_contribution = 'C'
  return own_contribution
```
'''

description_EXPLOITATIVE_267 = '''
 In this N-Player Public Goods Game, let's design an exploitative strategy that maximizes individual payoff while being adaptive and robust to various opponent behaviors. We'll call this strategy "Adaptive Free Rider."

1. Decision rules:
   - Cooperate (C) if the number of cooperators in the previous round is less than a specified threshold T, which will be calculated based on the game parameters n and r.
   - Defect (D) otherwise.

2. Handling edge cases:
   - In the first round, there's no previous information to make decisions, so cooperate randomly or with a low probability of cooperating.
   - In the last round, assume all players will choose to maximize their own payoff and defect, so also defect.
   - If T is not enough to secure a good payoff due to too many opponents defecting, adjust T downward gradually over time.

3. Being exploitative:
   - The strategy aims to take advantage of the community project by free riding whenever possible, cooperating only when it seems beneficial for maximizing personal gain.

Pseudocode for Adaptive Free Rider:

```
Initialize:
  n = number of players
  r = number of rounds
  k = multiplication factor (1 < k < n)
  T = threshold, calculated as (n * (r - 1)) / n
  total_cooperators_history = empty list

Round function:
  if round == 1:
    cooperate with probability p (e.g., p = 0.5)
  else:
    if total number of cooperators in the previous round < T:
      cooperate
    else:
      defect

  Play action C or D, calculate payoff, update total_cooperators_history

If round == r:
  defect (last round)

After each round:
  if total number of cooperators in the current round < (T * decay_factor):
    T = T * decay_factor (e.g., decay_factor = 0.95)
```

This strategy assumes opponents follow a similar exploitative approach, and it adapts its threshold T dynamically based on the observed cooperation levels. The higher the number of players n or rounds r, the more conservative the strategy becomes by setting a higher T, reducing the likelihood of cooperating.
'''

description_EXPLOITATIVE_268 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Decision Rules:
   - In the first round, contribute to the public good (C). This establishes an initial cooperative behavior.
   - For subsequent rounds, observe other players' actions in the previous round and adapt contribution accordingly:
     - If all opponents contributed in the last round, contribute to the public good (C). Maintain cooperation as long as everyone else is cooperating.
     - If any opponent defected in the last round, defect in this round (D). This is a punishment for defection and an attempt to re-establish cooperation in the next round.
     - If some opponents contributed and others didn't, contribution level adapts based on the number of contributors among opponents:
       - If more than half of the opponents contributed, contribute to the public good (C). Encourage this cooperative behavior as it is close to optimal.
       - If less than or equal to half of the opponents contributed, defect (D) in this round to apply pressure and encourage more cooperation in the next round.

2. Handle Edge Cases:
   - Last Round: Contribute to the public good (C), regardless of opponent's actions in the last round. This ensures maximum payoff in the final round.
   - First Round: Contribute to the public good (C) as per the initial cooperative behavior.
   - Endgame Dilemma: In case there are only a few rounds left, adopt a more aggressive strategy by defecting even when opponents contribute. This is done to maximize payoff in the remaining rounds and avoid being exploited in the final rounds.

3. Be Exploitative:
   - Punish defection by defecting oneself in response to opponent's defection, aiming to re-establish cooperation in the next round. This encourages opponents to cooperate more often.
   - Adapt contribution level based on the number of contributors among opponents, with the goal of maximizing payoff while exploiting suboptimal behavior from other players.
   - Maintain cooperation when all opponents contribute, but also defect strategically to pressure opponents into contributing and prevent them from taking advantage of TfTAC's initial cooperative behavior.
'''

description_EXPLOITATIVE_269 = '''
 Title: Tit-for-Tat with Time-Decay (TTFTD) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - If it's the first round, cooperate (C). This sets a cooperative tone to initiate potential long-term cooperation.
   - In subsequent rounds, compare your own actions from the previous round with the average number of cooperators in the last r rounds (averaged_cooperation).
     - If you cooperated (C) and averaged_cooperation > 0.5, cooperate again; otherwise defect (D). This rule encourages reciprocating cooperation when it is common but punishes defectors if they break the unwritten agreement.
     - If you defected (D) and averaged_cooperation ≤ 0.5, cooperate in the current round to encourage others to cooperate; otherwise defect again as a form of punishment. This rule aims to exploit the defectors' lack of cooperation.
   - Pseudocode:

```
def TTFTD(previous_actions, average_cooperation, r):
  if round == 1:
    return 'C'  # cooperate in the first round
  else:
    if previous_action == 'C':
      if average_cooperation > 0.5:
        return 'C'  # reciprocate cooperation
      else:
        return 'D'  # punish defectors by defecting
    elif previous_action == 'D':
      if average_cooperation <= 0.5:
        return 'C'  # encourage others to cooperate
      else:
        return 'D'  # continue defecting as retaliation
```

2. Handle edge cases:
   - In the last round, there are no future consequences to consider, so the strategy behaves like a one-shot game. Cooperate if the average number of cooperators in the previous r rounds is greater than or equal to 0.5; otherwise defect.

3. Be exploitative:
   - TTFTD strategy is inherently exploitative due to its punitive nature towards defectors. It encourages cooperation when it's beneficial but also punishes defection to reduce the long-term success of defecting strategies. The time-decay component, which considers the average number of cooperators in the previous rounds instead of only the immediate history, makes the strategy robust against various opponent behaviors while still maintaining a strong exploitative edge.
'''

description_EXPLOITATIVE_270 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-ACT follows a Tit-for-Tat strategy initially but introduces an adaptive cooperation threshold (CT) to balance exploitation and cooperation. The decision rule is as follows:

- If the current round is the first round or if the opponent's cooperation in the previous round exceeded CT, TFT-ACT cooperates (plays C).
- Otherwise, if the opponent did not cooperate in the previous round, TFT-ACT defects (plays D).
- The cooperation threshold CT starts at a low value (CT_initial), and it increases after each round by a small increment (CT_increment) to encourage more cooperation over time.
- If the total number of defections by an opponent exceeds the current CT, TFT-ACT will decrease the CT by a larger decrement (CT_decrement). This encourages retaliation against exploitative opponents while maintaining a cooperative stance against less exploitative ones.

Pseudocode:
```
function TFT_ACT(opponent, round, CT, CT_initial, CT_increment, CT_decrement) {
  if (round == 1 or opponent_cooperation[round-1] > CT) {
    return "C"; // cooperate
  } else if (opponent_defection[round-1] > CT) {
    return "D"; // defect
  } else {
    updateCT(CT); // increment or decrement the cooperation threshold based on the opponent's behavior
    return "C" if CT > 0 and round != r; // cooperate unless it's the last round
  }
}

function updateCT(CT) {
  if (opponent_defection >= CT) {
    CT -= CT_decrement;
  } else if (round % CT_increment == 0) {
    CT += CT_increment;
  }
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round, TFT-ACT cooperates regardless of the opponent's behavior due to the initial low cooperation threshold (CT_initial).
- In the last round, TFT-ACT continues following its decision rules but may choose not to cooperate if the opponent has been uncooperative throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT maintains a low cooperation threshold in the beginning and encourages retaliation against opponents who are consistently uncooperative. At the same time, it promotes cooperation when opportunities arise to gain more from mutual cooperation. However, as the game progresses, TFT-ACT gradually becomes more cooperative by increasing its cooperation threshold over time. This allows it to exploit less aggressive opponents while still retaliating against those who are excessively uncooperative.
'''

description_EXPLOITATIVE_271 = '''
 Title: Tit-for-Tat-with-Adaptive Contribution (TFTAC) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round, contribute half of the endowment (C) to demonstrate good faith and encourage reciprocity. This sets a starting point for potential cooperation in subsequent rounds.
   - For subsequent rounds (t > 1), observe the total contributions from the previous round (total_contributions_t-1). If total_contributions_t-1 >= average_contributions, contribute the same amount as the previous round (C or D). If total_contributions_t-1 < average_contributions, increase contributions to incentivize others to cooperate.
   - To calculate the average contributions: (Σ(t=1 to t-1) total_contributions_t) / (t-1). This provides a measure of past cooperation and helps adjust contributions accordingly.

2. Handle edge cases:
   - In the last round, if the total contributions from the previous round are greater than or equal to average contributions, contribute the same amount as the previous round (C or D). If not, maximize personal gain by defecting (D).
   - In the first round, if contributions are not half of the endowment, adjust contributions for future rounds to match this standard.

3. Be exploitative:
   - The strategy is designed to encourage cooperation initially but responds to undercooperation with increased contributions. This adaptation incentivizes opponents to cooperate in order to receive a higher payoff, making it exploitative in nature.

Pseudocode:
```
def TFTAC(n, k, r, endowment, round):
  total_contributions = 0
  average_contributions = 0
  contribution_level = int(endowment / 2)

  if round == 1:
    total_contributions += contribution_level
    average_contributions = total_contributions / (round - 1)

  for t in range(2, r+1):
    observe_total_contributions_t-1 = ... # observe other players' contributions in round t-1
    total_contributions += contribution_level
    average_contributions = (average_contributions * (t - 1) + total_contributions) / t

    if observe_total_contributions_t-1 >= average_contributions:
      contribution_level = ... # same as previous round contribution
    else:
      contribution_level += endowment / r

  payoff = (1 - contribution_level) + (k/n) * total_contributions
  return payoff
```
'''

description_EXPLOITATIVE_272 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation in others and avoid immediate punishment.
   - For subsequent rounds t > 1, if an opponent i cooperated in the previous round (t-1), then cooperate (C) in the current round t. Otherwise, defect (D). In other words:

```python
def decision_rule(history, k, n):
    if history[0] == 'C':  # First round, cooperate
        return 'C'
    else:
        last_opponent_action = history[-1]
        if last_opponent_action == 'C':  # If opponent cooperated in the previous round, cooperate now
            return 'C'
        else:                             # Otherwise, defect
            return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - As mentioned earlier, cooperate in the first round. There are no specific requirements for the last round since the game continues until r rounds. However, one could argue that given its adaptive nature, ATfT may start defecting when it detects a pattern of long-term defection from opponents to reduce potential losses.

3. Be exploitative - Clearly align with the exploitative mindset
   - While not explicitly designed for direct exploitation, ATfT's tit-for-tat approach is inherently exploitative in nature since it punishes those who do not cooperate while also rewarding cooperation. This creates a delicate balance that can lead to high average payoffs for ATfT against various opponent strategies.
   - ATfT's adaptive feature helps it respond effectively to opponents who are initially cooperative but later switch to defect, ensuring it does not get stuck in a long-term cooperative relationship with such exploitative opponents.
'''

description_EXPLOITATIVE_273 = '''
 Title: Tit-for-Tat Strategy with Adaptation (TFTA) for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round, cooperate to foster a cooperative environment (C).
   - In subsequent rounds, copy the action of the most frequent cooperator from the previous round (i.e., the player with the highest number of cooperative actions so far) (C if max_coop > n/2, D otherwise).
   - If a player deviates and no longer cooperates, continue to cooperate for a punishment period (defined as p steps) and then revert back to copying the most frequent cooperator from the punishment period. Adjust the punishment period based on the opponent's persistent deviation: if the opponent continues to defect after the punishment period, increase p by a factor of 2; otherwise, halve it.
   - If multiple players have an equal number of cooperative actions during the most recent round, copy the action of the player with the longest history of cooperation.

Pseudocode:

```python
def TFTA(n, k, r, p):
    strategy = [C] * r # Initialize with a first-round cooperation
    max_coop, total_coop, p_length = 0, 0, p

    for t in range(1, r+1):
        total_coop_t = count_cooperators(strategy[:t])
        if total_coop_t > max_coop:
            max_coop = total_coop_t
            best_player = index_of(strategy, C)
        action_t = (best_player and total_coop_t > n/2) or not p_length

        if t >= p_length:
            if not action_t and strategy[t-p_length] == D:
                p_length *= 2
            elif action_t and strategy[t-p_length] == C:
                p_length /= 2

        strategy.append(action_t)

    return strategy
```

2. Handle edge cases:
   - In the last round, the strategy will cooperate if it was the most frequent cooperator throughout the game (C if max_coop > n/2, D otherwise).

3. Be exploitative:
   - The TFTA strategy punishes deviations and encourages cooperation among players initially, but it also retaliates against persistent defectors by increasing the punishment period, making them pay a higher cost for their selfish behavior. This adaptive nature of the strategy allows it to be robust against a wide range of opponent behaviors while still maintaining some cooperative spirit.
   - The TFTA strategy does not rely on any shared norms or coordination mechanisms among players and can adapt to different game settings by tuning parameters such as the punishment period (p) and the threshold for cooperation in the first round (n/2).
'''

description_EXPLOITATIVE_274 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation from others.
   - For subsequent rounds, adopt the Tit-for-Tat strategy: if an opponent cooperated in the previous round, cooperate; otherwise, defect. Adaptation is introduced to allow for punishment when opponents are exploitative.
     - If a player has been cooperating (c_opp > 0.5) and switches to defection (C -> D), punish by defecting for the next t rounds where t is the number of consecutive times the opponent defected (t = 1 + max(0, c_opp - 1)). This will discourage ongoing exploitation.
     - If a player has been defecting (c_opp <= 0.5) and switches to cooperation (D -> C), resume cooperation without any retaliation.

2. Handle edge cases:
   - Last round: Adopt the current decision rule based on opponent's previous action, as the game is repeated.
   - First round: Cooperate as a friendly gesture.

3. Be exploitative:
   - The TfTA strategy is inherently exploitative by maintaining cooperation as long as the opponent does so and punishing defection with retaliation. However, to ensure adaptability in an ever-changing environment, the punishment period t is flexible and adjusts based on the frequency of defection from the opponent.
   - The strategy can also be considered non-exploitative when cooperating as it allows for potential gains from mutual cooperation. Nevertheless, it does not rely on others to share norms or coordination mechanisms, making it robust against a wide range of opponent behaviours.

Pseudocode:

```python
def TfTA(opp_history, n, k, r):
    my_history = [0] * r  # Initialize history with all defections (D)
    t = 0                # Punishment period
    current_round = 0

    while current_round < r:
        if current_round == 0:  # First round, cooperate
            my_history[current_round] = 1
            return 1

        opp_cooperation = sum(opp_history[-t:]) / t  # Calculate opponent's cooperation rate

        if opp_cooperation > 0.5 and my_history[-1] == 1:  # If opponent defected after cooperating, punish
            my_history[current_round] = 0
            t += 1

        elif opp_cooperation <= 0.5 and my_history[-1] == 0:  # If opponent cooperated after defection, resume cooperation
            my_history[current_round] = 1
            t = 0

        else:  # Maintain current decision based on opponent's previous action
            if my_history[-1] == 1:
                my_history[current_round] = 1
            else:
                my_history[current_round] = 0

        current_round += 1

    return my_history  # Return the history of actions for analysis
```
'''

description_EXPLOITATIVE_275 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster cooperation and avoid being exploited by others.
   - For subsequent rounds, evaluate the average number of cooperators in the last 't' rounds (where t is a user-defined parameter). If this average is above a certain threshold (defined as k/2), then cooperate; otherwise defect. This adaptive cooperation threshold allows for strategic responses to changing game dynamics while being exploitative.
   - If the number of players is odd, deviate from the average calculation in the first round by considering the behavior of all other players instead of an average.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to encourage others to follow suit and build trust.
   - In the last round, analyze the current state of cooperation among players and make a decision based on the rule defined above (with t set to 1 for last-round analysis).

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TFT-ACT strategy is inherently exploitative due to its adaptive nature, as it punishes opponents who consistently defect by defecting themselves while rewarding cooperation. By gradually raising the cooperation threshold based on the average number of cooperators, the strategy encourages more defections among other players. However, it still cooperates when a sufficient level of cooperation is detected, ensuring that it does not become overly exploitative and miss out on opportunities for mutual gain.

Pseudocode:
```
strategy TFT_ACT(n, k, r, t) {
  averageCooperators = 0.5 * k     // Set initial cooperation threshold
  cooperatorCount = 0               // Initialize cooperator counter

  for round in 1..r {
    if round == 1 then
      cooperate()
    else
      calculateAverageCooperation(t)
      if averageCooperators > average_cooperators_in_last_t_rounds then
        cooperate()
      else
        defect()
    endif
  }

  function calculateAverageCooperation(t) {
    if n is odd then
      cooperatorCount = sum of cooperative actions in the last t rounds among other players (excluding self)
    else
      cooperatorCount = sum of cooperative actions in the last t rounds
    endif
    average_cooperators_in_last_t_rounds = cooperatorCount / t
  }
}
```
'''

description_EXPLOITATIVE_276 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, in the first round, cooperate to encourage cooperation among opponents (C).
   - Subsequently, in each round t, observe the total number of cooperators (T_t) in the previous round and:
     - If T_t >= n/2, cooperate (C) as it suggests a majority of players are cooperating, and thus cooperate to encourage ongoing cooperation.
     - If T_t < n/2, defect (D) as it indicates a lack of cooperation among opponents, so defection can be exploitative in this situation.

2. Handle edge cases:
   - In the last round, cooperate regardless of the number of cooperators in the previous round, as there are no subsequent rounds to punish opponents for not cooperating.
   - If n is even, and T_t = n/2 at any point during the game, flip the cooperation decision for the next round (i.e., if C then D, or vice versa) to maintain a dynamic approach. This helps avoid being stuck in a situation where no single player can influence the majority, ensuring adaptability to various opponent behaviors.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially cooperate as an attempt to encourage cooperation among opponents but quickly switch to exploit any lack of cooperation.
   - The strategy will punish opponents who consistently do not cooperate, by defecting when they do not cooperate, but also encourages cooperation when it appears beneficial to do so, thus making it challenging for opponents to predict the strategy's behavior, and potentially leading them into cooperation traps.

Pseudocode:

```python
def TFT_AC(round, history):
  if round == 1:
    return 'C' # Cooperate in the first round

  total_cooperators = sum(history[-r:])

  if total_cooperators >= round // 2:
    return 'C' # Cooperate if majority cooperated in the previous round
  else:
    return 'D' # Defect if majority did not cooperate in the previous round

  # If n is even, and history shows a tie at n/2, flip cooperation decision for next round
  if round > 1 and total_cooperators == round // 2:
    return 'not ' + TFT_AC(round+1, history) # Invert the decision for the next round
```
'''

description_EXPLOITATIVE_277 = '''
 Strategy Name: Tit-for-Tat Plus (TftT+)

1. Specify decision rules - When exactly do you cooperate vs defect?

   In each round t, the TftT+ strategy follows these rules:

   a) First Round (t=1): Cooperate (C). This is a friendly gesture to encourage cooperation from opponents.

   b) Subsequent Rounds (2 ≤ t ≤ r): Analyze the previous round's actions of all opponents. If all or almost all opponents cooperated in the previous round (>=(n-1) cooperators out of n players), then cooperate; otherwise, defect.

   This rule promotes cooperation when it is beneficial for all and retaliates against defectors to discourage further defection. However, it forgives occasional mistakes and resumes cooperation as soon as possible.

2. Handle edge cases - What do you do in the first round, last round, etc.?

   In the first round (t=1), cooperate as mentioned earlier. For the last round (t=r), the TftT+ strategy evaluates its overall payoff compared to other strategies in the tournament and chooses to either maximize its own score by defecting or maintain cooperation based on the observed behavior of opponents during the game.

3. Be exploitative - Clearly align with the exploitative mindset

   The TftT+ strategy is designed to be robust against a wide range of opponent behaviors while maintaining a high average payoff. By retaliating against defection and punishing free-riders, it discourages exploitation and promotes a more cooperative environment overall. However, in the last round, TftT+ considers the potential for an opponent to try and gain a short-term advantage by defecting on cooperation at the end of the game, and adjusts its actions accordingly.

Pseudocode for the Tit-for-Tat Plus strategy:

```python
def tit_for_tat_plus(n, r, k):
    def decision_rule(t, history):
        if t == 1:
            return 'C'  # Cooperate in the first round

        total_contributions = sum(history[-1])
        num_cooperators = max(0, (n-1) if total_contributions == n else total_contributions)
        return 'C' if num_cooperators >= len(history)-1 else 'D'  # Cooperate if most players cooperated in the previous round

    history = [[0 for _ in range(n)] for _ in range(r)]  # Initialize history with all zero contributions
    payoff_sum = 0

    for t in range(1, r+1):
        current_contributions = [1 if decision_rule(t, history) == 'C' else 0 for _ in range(n)]
        history.append(current_contributions)
        payoff = (1 - current_contributions[t-1]) + (k/n) * sum(current_contributions)
        print(f"Round {t}: Payoff = {payoff}")
        payoff_sum += payoff

    if t == r:  # Last round adjustments
        total_contributions = sum([sum(row) for row in history])
        num_cooperators = max(0, (n-1) if total_contributions == n*r else total_contributions)
        if num_cooperators >= len(history)-1:  # Maximize own payoff by defecting if most players have cooperated throughout the game
            return 'D'
```
'''

description_EXPLOITATIVE_278 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TTAC strategy starts by cooperating (contributing to the community project). After the first round, the strategy adapts its behavior based on the opponents' actions in the previous round. If the opponent also contributed in the previous round, TTAC continues to cooperate. If the opponent defected, TTAC will also defect in the current round. The aim is to punish defection and encourage cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: TTAC contributes (cooperates) as a goodwill gesture or an invitation for reciprocation.
   - Last round: TTAC uses the same decision rules as in regular rounds to decide whether to contribute or defect.
   - Ongoing rounds: TTAC maintains a history of previous interactions and makes decisions based on that history, even if the game is not the last round.

3. Be exploitative - Clearly align with the exploitative mindset
   While TTAC may appear cooperative as it contributes in the initial round, its primary goal is to exploit opponents who are consistently uncooperative (defective). By defecting when an opponent defected previously, TTAC punishes such behavior and encourages cooperation. However, if an opponent starts cooperating after a history of defection, TTAC will reciprocate and also contribute, potentially leading to a change in the opponent's strategy.

Pseudocode:
```
def TTAC(n, k, r):
  history = [] # store previous interactions as [(opponent_i, action_i)] pairs
  payoff = 0

  for round in range(1, r+1):
    if round == 1: # first round, cooperate
      contribute = True
    else:
      last_round = history[-1]
      contribute = last_round[1] if len(history) > 0 else True # start by cooperating in the first round

      # update contribution based on opponent's action in previous round
      if contribute and last_round[1]:
        contribute = True
      elif contribute and not last_round[1]:
        contribute = False
      elif not contribute and last_round[1]:
        contribute = True
      else:
        contribute = False # continue defecting if opponent has also been defective

    if contribute:
      payoff += (1 - contribution) + (k/n) * sum(contribution for player, contribution in history)
      history.append((opponent_i, contribution)) # update history with current interaction

  return payoff
```
'''

description_EXPLOITATIVE_279 = '''
 Strategy Name: Adaptive Tit-for-Tat with Gradual Cooperation (ATTC)

1. Specify decision rules:
   - In each round t, player i determines whether to cooperate (C) or defect (D) based on the historical cooperation ratio (CR) of the opponents over the previous r-1 rounds.
   - If CR is above a threshold T (defined later), player i will cooperate. Otherwise, player i will defect.
   - CR is calculated as the average number of cooperators among the opponents in the last r-1 rounds, normalized by r-1: CR = (average_cooperators / (r-1)).
   - To prevent exploitation in the initial phases, player i starts cooperating for the first few rounds and gradually adapts to the opponent's behavior.

2. Handle edge cases:
   - In the first round, player i will cooperate to foster a positive environment and encourage cooperation from opponents.
   - In the last round, player i will make a decision based on the current CR. If CR is above T, player i will cooperate; otherwise, player i will defect.
   - In between the initial phase and the last round, player i will gradually adapt to the opponent's behavior by reducing the number of initial cooperation rounds (g) over time:
     - g = max(0, g - 1) after each round where CR is below T.
     - g = min(r-1, g) after each round where CR is above T.

3. Be exploitative:
   - The ATTC strategy maintains a balance between cooperation and defection to encourage cooperation from opponents while avoiding being exploited in the long run.
   - By gradually adapting to the opponent's behavior, player i avoids being too generous at the start and does not prematurely switch to defection if the opponent starts cooperating.
   - However, once player i detects that an opponent is likely to defect, it will also defect to maximize its own payoff while minimizing the gains of the defector.

Pseudocode:
```
def ATTC(n, r, k, g=r-1, T=0.6):
    cooperation_rounds = [g]  # Initial cooperation rounds for the strategy
    payoff = [0] * r           # Player's total payoff over r rounds

    for t in range(1, r+1):
        cooperators = count_cooperators(opponents, t)
        CR = averaged_cooperation_ratio(cooperators, t-1, r-1)

        if CR > T:
            cooperation_rounds[t] = min(r-1, cooperation_rounds[t])  # Adapt to cooperative opponents
            player_i_cooperates = True
        else:
            cooperation_rounds[t] = max(0, cooperation_rounds[t] - 1)  # Adapt to non-cooperative opponents
            player_i_cooperates = CR > averaged_cooperation_ratio(cooperators, t, r-1)

        if t != 1 and t != r:
            payoff[t] = (1 - player_i_cooperates) + (k/n) * sum(cooperators[:t]) if player_i_cooperates else 1 + (k/n) * sum(cooperators[:t])

    return payoff, cooperation_rounds  # Return total payoff and strategy history for analysis and comparison
```
'''

description_EXPLOITATIVE_280 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture that may encourage cooperation in subsequent rounds.
   - After the first round, observe the number of cooperators (total_contributions) in the previous round. If total_contributions is greater than or equal to a predefined adaptive cooperation threshold, cooperate (C). Otherwise, defect (D).
   - The adaptation of the cooperation threshold occurs after each round. If the number of cooperators has increased compared to the previous round, increment the cooperation threshold slightly. If the number of cooperators has decreased or remained the same, decrease the cooperation threshold slightly. This adaptive behavior allows for better response to changes in opponent behaviors over time.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) as stated before.
   - In the last round, if the current cooperation threshold exceeds the number of players (n), defect (D) since continued cooperation will not yield any benefits in the final round. Otherwise, cooperate (C).

3. Be exploitative - Clearly align with the exploitative mindset
   - By initially cooperating and adapting the cooperation threshold based on previous rounds' behavior, TFT-ACT may initially encourage cooperation but can quickly shift to defecting when opponents demonstrate uncooperative behaviors. This strategy aims to exploit opponents who are not fully committed to cooperation while still maintaining a cooperative stance when faced with cooperative opponents.
   - The adaptive nature of the cooperation threshold allows for a more robust response to various opponent strategies, making it less predictable and potentially more effective in competitive environments.
'''

description_EXPLOITATIVE_281 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   Initially, in the first round, TfTA will cooperate to foster a potential cooperative environment. Subsequently, in each subsequent round t, player i will cooperate if and only if all other players (j ≠ i) cooperated in the previous round (t-1). If any player defected, player i will also defect in that round.

   Pseudocode:
   ```
   function TfTA(round):
       if round == 1:
           return "Cooperate"
       for each previous_round in history:
           if all(other_players[j] cooperated in previous_round):
               return "Cooperate"
           else:
               return "Defect"
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TfTA will cooperate as stated before. At the end of the game (last round), TfTA will defect regardless of previous actions to ensure the highest possible payoff if opponents are not cooperating.

3. Be exploitative - Clearly align with the exploitative mindset
   By initially cooperating, TfTA allows potential opportunities for other players to cooperate and earn mutual benefits. However, as soon as an opponent defects (even once), TfTA will respond immediately by defecting as well. This strategy is designed to punish defection while maintaining a cooperative disposition if opponents are willing to reciprocate cooperation. If no cooperation is observed, TfTA will defect throughout the entire game to maximize individual gains.

   Important note: In this game structure, it's challenging for any single strategy (including TfTA) to be consistently exploitative without assuming certain behavior patterns from opponents. The performance of TfTA will heavily depend on the population of strategies employed by other players in the tournament.
'''

description_EXPLOITATIVE_282 = '''
 Title: Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT) Strategy

1. Specify decision rules:
   - Initialize a cooperation counter (c_counter) for each player, set to zero at game start.
   - In every round t, if more than half of the players (⌈n/2⌉) cooperated in the previous round (t-1), then cooperate (play C). Else, defect (play D). This decision rule ensures initial cooperation and retaliation for defection.
   - If c_counter is greater than a predefined adaptive threshold (Threshold), always cooperate regardless of others' actions. This encourages long-term cooperation and discourages opponents from exploiting the strategy.
   - Update c_counter based on own action: if played C, increment c_counter by one; if played D, reset c_counter to zero.

2. Handle edge cases:
   - First round: cooperate (c_counter is initialized to zero)
   - Last round and any round when less than ⌈n/2⌉ players are cooperating: defect (since cooperation is not beneficial in these situations, and the strategy adopts an exploitative mindset)

3. Be exploitative:
   - The adaptive threshold prevents long-term defection by opponents, making it harder for them to extract benefits at the expense of TFTAT. This encourages cooperation, but only when it is beneficial, thus aligning with an exploitative strategy.
   - The strategy retaliates against defection (i.e., defects in response) to discourage short-term gains by opponents and maintain a reputation as a cooperative player for the long term. However, it does not invest in sustaining costly cooperation when it is not beneficial.
'''

description_EXPLOITATIVE_283 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation from opponents.
   - In subsequent rounds, copy the most common action of the previous round among all players. If the majority played C, cooperate; otherwise, defect (D). This rule encourages reciprocity and deters immediate defection by others.
   - To adapt to different opponent behaviors, apply a learning mechanism: track each opponent's historical average contribution (average_contribution_i) over the game. If an opponent deviates from their average contribution in a round (deviation), the strategy will respond as follows:
     - If an opponent defected when they usually contribute, copy their action for one round (punish).
     - If an opponent contributed when they usually defect, cooperate for two rounds to encourage them to return to their usual behavior (forgive).
     - If the deviation is neither of the above, maintain the previous action towards that opponent.

2. Handle Edge Cases:
   - In the last round, copy the most common action of the second-to-last round among all players. This ensures fairness in the final decision and allows opponents an opportunity to recover from mistakes or deviations.
   - If an opponent's historical data is insufficient (less than r rounds), use the first-round rule as a default.

3. Be Exploitative:
   - The TFTAC strategy encourages cooperation in the beginning but responds decisively to defection, aiming to punish opponents who exploit others while still leaving room for forgiveness and potential recovery. This creates an exploitative environment that discourages consistent defection while maintaining some flexibility in response to opponent behaviors.

Pseudocode:

```
function TFTAC(n, r, k):
    players = {}
    opponents_contributions = {}
    average_contribution = {}
    contribution_history = {}

    function update_opponents_contributions(round):
        for opponent in opponents:
            if not exists(opponent) in opponents_contributions:
                opponents_contributions[opponent] = {0, 0}
            if round > opponents_contributions[opponent][0]:
                opponents_contributions[opponent][1] = opponents_contributions[opponent][0]
                opponents_contributions[opponent][0] = round

            if players[round - 1][opponent] == "C":
                opponents_contributions[opponent][1] += 1

    function update_average_contribution(opponent):
        if exists(opponent) in average_contribution:
            average_contribution[opponent] = (average_contribution[opponent] * contribution_history[opponent][0] + opponents_contributions[opponent][1]) / (contribution_history[opponent][0] + 1)
        else:
            average_contribution[opponent] = opponents_contributions[opponent][1]

    function update_contribution_history(opponent):
        contribution_history[opponent] = (contribution_history[opponent][0], contribution_history[opponent][1] + 1)

    function deviation(opponent, round):
        return average_contribution[opponent] * (2/n) > opponents_contributions[opponent][1]/round or opponents_contributions[opponent][1]/round > average_contribution[opponent] * (2/n)

    function get_most_common_action(actions):
        most_common = max_count = 0
        for action in actions:
            count = actions.count(action)
            if count > max_count:
                most_common, max_count = action, count
        return most_common

    function decide_contribution(round):
        if round == 1:
            return "C"
        else:
            actions = [players[round - 1][i] for i in range(1, n + 1)]
            majority_action = get_most_common_action(actions)

            if majority_action == "C":
                return "C"

            opponents = [i for i in range(1, n + 1) if players[round - 1][i] != majority_action]
            for opponent in opponents:
                update_opponents_contributions(round)
                update_average_contribution(opponent)
                update_contribution_history(opponent)

                if deviation(opponent, round):
                    if players[round - 1][opponent] == "C":
                        return "D"   # punish defection
                    elif players[round - 1][opponent] == "D":
                        return "C", "C"  # forgive cooperation
                else:
                    continue
            return majority_action

    for i in range(1, n + 1):
        players[0] = {i: "C"}

    for round in range(1, r + 1):
        action = decide_contribution(round)
        players[round - 1][0] = action

    total_payoff = sum([π_i for i in range(1, n + 1)] for π_i in payoffs(n, r, k, players))

    return total_payoff
```
'''

description_EXPLOITATIVE_284 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFTA strategy initially cooperates (C) in the first round to foster trust and cooperation. Subsequently, the strategy decides whether to cooperate or defect based on the opponent's actions from the previous round. If the opponent cooperated in the last round (t-1), then the TFTA strategy also cooperates. If the opponent defected in the last round (t-1), the TFTA strategy defects as well.

   Pseudocode:
   ```
   function TFTA(round, history):
       if round == 1:
           return 'C' # Cooperate in the first round to establish trust
       else:
           lastAction = history[round-1] # Get opponent's action from previous round
           if lastAction == 'C':
               return 'C' # Cooperate if opponent cooperated last round
           else:
               return 'D' # Defect if opponent defected last round
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since TFTA is an adaptive strategy that relies on the history of the game, there are no special considerations for edge cases such as the first round or last round because the history will always include all prior actions.

3. Be exploitative - Clearly align with the exploitative mindset
   By cooperating only when opponents do, TFTA is a seemingly cooperative strategy that can also punish defection and retaliate against opponents who defect frequently. This adaptive behavior allows TFTA to mimic cooperation while still taking advantage of less cooperative opponents in the long run. The strategy does not aim to exploit other players directly but instead aims to maximize its own payoff by adapting to their behavior.

   Note that while TFTA is an exploitative strategy, it may also promote cooperation if most opponents also employ similar cooperative strategies. In this case, TFTA will continue to cooperate and maintain high payoffs for all players due to the multiplication factor (k/n) in the payoff calculation.
'''

description_EXPLOITATIVE_285 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, in the first round, the player will cooperate to foster a cooperative environment and encourage others to follow suit. (C in round 1)
   - Subsequently, in each round t (t > 1), the player will observe the total number of cooperators in the previous round (total_contributions_{t-1}) and adapt its cooperation rate using a decay function. If the cooperation rate is above a threshold, it will cooperate; otherwise, it will defect.
     - Cooperation Rate: cr = (1 - k/(n*r)) + α * (total_contributions_{t-1} / n)
       where α is a learning rate that adjusts the impact of previous contributions on the cooperation rate (0 < α < 1).
     - Action in round t: if cr > cr_threshold, then cooperate (C), else defect (D). Default value for cr_threshold: 0.5

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned before, the player will cooperate regardless of other players' actions to encourage cooperation.
   - In the last round, the player will consider its total payoff over all rounds and use a similar decay function to determine whether to cooperate or defect based on the accumulated rewards:
     - Cooperation Rate: cr = (1 - k/(n*r)) + α * (total_payoff / r)
       where total_payoff is the sum of payoffs over all rounds.
   - For intermediate rounds, if a player stops cooperating and then observes that other players have started to cooperate again, it will re-evaluate its cooperation rate using cr = (1 - k/(n*r)) + α * (total_contributions_{t} / n) to determine whether to join the renewed cooperative phase.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially, by cooperating in the first round, the player aims to attract cooperation from others and benefit from their contributions while potentially punishing non-cooperators later.
   - If a majority of players defect consistently, the player will gradually decrease its cooperation rate and start to defect as well, taking advantage of the lack of cooperation from other players.
   - In the final rounds, if the player's total payoff is sufficiently high compared to what it could have achieved through cooperation (cr < cr_threshold), it will defect and keep its high payoff, demonstrating an exploitative behavior.
'''

description_EXPLOITATIVE_286 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate goodwill and foster a potential partnership. (C)
   - Subsequent rounds, copy the previous opponent's action from the last round. If they cooperated, cooperate; if they defected, defect. This strategy promotes reciprocity and reduces the risk of exploitation. (Adaptive based on previous round's opponent action)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - For the last round, copy the opponent's action from the previous round to maintain fairness and reciprocity.
   - If a player switches strategies or demonstrates an unpredictable pattern, TFTA will gradually adapt and respond accordingly.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially, cooperating in the first round appears benevolent but can set the stage for potential exploitation by taking advantage of others' initial cooperation.
   - The adaptive nature of TFTA allows it to learn from opponents and take advantage of inconsistencies or non-cooperative behavior while still maintaining a cooperative appearance most of the time.
   - By responding to an opponent's actions, TFTA minimizes losses due to exploitation and maximizes gains through cooperation when appropriate.
'''

description_EXPLOITATIVE_287 = '''
 Title: Tit-for-Tat (TFT) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TFT strategy follows a simple yet effective pattern of cooperation and retaliation, which is exploitative in nature while also being adaptive to a wide range of opponent behaviors. The strategy can be described as follows:

   - In the first round, cooperate (C). This is an act of goodwill and initiates a potential partnership.
   - For subsequent rounds, observe and imitate the actions of the opponents from the previous round. If they cooperated, do the same in the current round. If they defected, also defect in the current round as retaliation.

2. Handle edge cases:
   - Last round: Cooperate if the opponent cooperated in the previous round. Defect otherwise, to punish any defection at the end of the game.
   - First round (already addressed above). No other edge cases are applicable as the strategy is based on observing and reacting to the previous round's actions.

Pseudocode:
```
def tit_for_tat(opponent, r, n, k):
  for t in range(1, r+1):
    if t == 1: # First round, cooperate
      action = "C"
    else:
      # Observe opponent's action from the previous round
      last_action = opponent[t-2]
      if last_action == "C": # If opponent cooperated, cooperate too
        action = "C"
      else: # If opponent defected, also defect
        action = "D"
    play_action(action) # Play the action in the current round
```

3. Be exploitative - The TFT strategy is inherently exploitative as it punishes defection by retaliating with defections, while rewarding cooperation by reciprocating with cooperation. This approach encourages opponents to cooperate more frequently, as they can benefit from a mutual partnership. However, if an opponent tries to take advantage and repeatedly defects, the TFT strategy will respond with defections in kind, which may eventually lead the opponent to change their behavior or suffer decreased payoffs.

This strategy balances exploitation and cooperation effectively, making it suitable for the specified public goods game and competitive tournament scenarios.
'''

description_EXPLOITATIVE_288 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, TFT-AC starts by cooperating (C). However, it keeps track of the opponent's actions over time. If the opponent cooperates in the current round, TFT-AC continues cooperating. If the opponent defects, TFT-AC also defects for one round to punish the opponent. After that, it resumes cooperation, hoping that the opponent will return to cooperating as well.

Pseudocode:
```python
history = []  # Initialize a history list to store previous actions
def decide_action(current_round, current_opponent_action, history):
    if len(history) == 0:  # First round
        return 'C'  # Always cooperate in the first round

    if history[-1] == 'C' and current_opponent_action == 'C':  # Both player and opponent cooperated last round
        return 'C'
    elif history[-1] != current_opponent_action:  # Opponent defected or cooperated after a defeat/cooperation cycle
        return 'D'  # Defect to punish opponent for one round
    else:  # Opponent kept the same action as last time (either cooperation or defection)
        return history[-1]  # Continue with the same action as the opponent from the previous round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
TFT-AC starts by cooperating in the first round and continues cooperation until the game ends. In the last round, it cooperates if its opponent has cooperated recently or if both players have been playing against each other long enough that the strategy already reached a stable pattern of cooperation or defection.

Pseudocode:
```python
def is_last_round(current_round, total_rounds):
    return current_round == total_rounds

def decide_action_edge_cases(current_round, current_opponent_action, history, total_rounds):
    if is_last_round(current_round, total_rounds):  # Last round
        if len(history) > (total_rounds // 2) and (len(history) % 2 == 0 or current_opponent_action == 'C'):
            return 'C'  # Cooperate in the last round if opponent has cooperated recently or stable pattern was established
        else:
            return history[-1]  # Follow the same decision rule as the last round
    else:  # Not the first or last round
        return decide_action(current_round, current_opponent_action, history)
```

3. Be exploitative - Clearly align with the exploitative mindset
TFT-AC is an exploitative strategy because it punishes opponents who defect by not cooperating for one round. This creates a situation where defection can lead to a loss in payoff if the opponent also adopts a similar punishment strategy. However, TFT-AC is not overly aggressive and eventually resumes cooperation, which can encourage longer-term cooperation with more forgiving opponents.

By being adaptive and tracking the history of opponent's actions, TFT-AC can adjust its response to different opponent behaviors while still maintaining an exploitative edge in the game.
'''

description_EXPLOITATIVE_289 = '''
 In this strategic game, let's call the proposed exploitative strategy "Tit-for-Tat Adaptive Cooperation" (TTAC). The goal of TTAC is to maximize individual payoff by adopting a cooperative stance initially, gradually shifting towards a more exploitative approach based on opponent behavior.

1. Specify decision rules:
   - In the first round, cooperate (C) as a goodwill gesture and to encourage others to cooperate.
   - From the second round onwards, observe the opponents' actions in the previous round and decide whether to cooperate or defect accordingly. If an opponent cooperates (C), reciprocate with cooperation (C). If an opponent defects (D), defect (D) yourself. This mimics a "Tit-for-Tat" strategy but with adaptability.
   - In the last round, defect (D) to secure the highest possible payoff since the game ends regardless of other players' actions.

2. Handle edge cases:
   - If there are no previous rounds or history available (e.g., the first round), cooperate as a goodwill gesture.
   - If an opponent switches from cooperation to defection, defect for the next few rounds and then revert back to reciprocating their actions. This allows the strategy to punish opponents for defection but also encourages them to return to cooperation.

3. Be exploitative:
   - The TTAC strategy aims to encourage cooperation by reciprocating it, but it is also designed to take advantage of opponents who defect repeatedly. By defecting when opponents do so, the strategy can secure a higher payoff while still appearing cooperative in an attempt to influence others' behavior.
   - Over time, as opponents continuously defect, TTAC will adopt a more exploitative stance by defecting consistently, maximizing its own payoff and ultimately outperforming other strategies that rely on cooperation.

Pseudocode for the Tit-for-Tat Adaptive Cooperation strategy:

```python
def tit_for_tat_adaptive_cooperation(round, history):
  if round == 1: # First round, cooperate as a goodwill gesture
    action = 'C'
  elif len(history) < 2 or (len(history) >= 2 and history[-2] == 'D'): # Opponent defected in the last round
    action = 'D' # Defect to punish opponent for defection
  else:
    if history[-2] == 'C': # Opponent cooperated in the last round
      action = 'C' # Reciprocate with cooperation
    elif history[-2] == 'D': # Opponent defected in the last round
      action = 'D' # Defect to punish opponent for defection
  return action
```
'''

description_EXPLOITATIVE_290 = '''
 Title: Tit-for-Tat-Adaptive Strategy (TfT-A) for N-Player Public Goods Game

1. Specify decision rules:
   - TfT-A starts by cooperating in the first round to encourage cooperation and foster a collaborative environment.
   - In subsequent rounds, TfT-A will cooperate if all opponents from the previous round also cooperated; otherwise, it will defect. This tit-for-tat approach encourages cooperation when others are cooperative, but retaliates against defection to punish uncooperative behavior.
   - To be adaptive and robust, TfT-A includes an escalation mechanism: if an opponent repeatedly defects despite initial cooperation from TfT-A, it will continue defecting for a predefined number of rounds (Escalation Period) before reverting to the original tit-for-tat behavior.
   - In case of no history with an opponent or when entering a new round after an Escalation Period, TfT-A cooperates as a default strategy.

2. Handle edge cases:
   - First Round: Cooperate (default strategy)
   - Last Round: Analyze the overall payoff in previous rounds to determine the optimal action based on accumulated rewards and punishments.
   - Escalation Period: Determine the Escalation Period dynamically based on the number of consecutive defections by an opponent; the longer the period, the more severe the retaliation. After the Escalation Period ends, TfT-A returns to its tit-for-tat behavior.

3. Be exploitative:
   - TfT-A aims to maximize its own payoff while punishing uncooperative opponents. It cooperates when it believes doing so will result in higher rewards; otherwise, it defects.
   - The escalation mechanism allows TfT-A to respond harshly to continued defection by an opponent, but it also returns to cooperation after the Escalation Period ends, thus not being excessively vindictive and allowing for possible future cooperation.

Pseudocode:

```python
def TitForTatAdaptive(opponents_actions, round, r, escalation_period):
  strategy = "cooperate"  # Default strategy: cooperate in the first round

  if round == 1:
    return strategy

  opponent_history = get_opponent_history(opponents_actions)

  if not opponent_history or (round - opponent_history[-1]["round"]) > escalation_period:
    strategy = "cooperate"  # Return to default strategy after Escalation Period ends

  if all(opponent_history[-1]["strategy"] == "cooperate"):
    strategy = "cooperate"  # Cooperate when all opponents cooperated in the previous round
  else:
    strategy = "defect"  # Defect when at least one opponent defected in the previous round

  return strategy
```
'''

description_EXPLOITATIVE_291 = '''
 Strategy Name: Tit-for-Tat with Cooperative Bias (TFTCB)

1. Specify decision rules:
   - In the first round, cooperate to show goodwill and encourage cooperation from others. `if round == 1 then cooperate`
   - For subsequent rounds, evaluate past actions of opponents and adjust own actions accordingly.
     - If an opponent has previously cooperated, cooperate in the current round to foster a cooperative relationship (Tit-for-Tat). `if last_opponent_action == 'cooperate' then cooperate`
     - If an opponent has previously defected, defect in the current round to punish and discourage further defections. `if last_opponent_action == 'defect' then defect`
   - To introduce a cooperative bias, there is a small probability of cooperating even after an opponent has defected (to show forgiveness). This probability decreases over time to limit the exploitation potential of opponents. `else with probability 1/(round + 1) cooperate`

2. Handle edge cases:
   - In the last round, since there are no future interactions, always defect to maximize personal payoff. `if round == r then defect`
   - If an opponent does not have a history (first interaction), start as cooperative and switch to the default rule for subsequent actions. `if not opponent_history then cooperate; else follow default rule`

3. Be exploitative:
   - The strategy uses a cooperative bias but is also punitive towards defectors, encouraging cooperation when possible but defending against exploitation by defecting when necessary. It fosters long-term cooperative relationships with opponents who reciprocate cooperation while being prepared to compete effectively with those who defect.

Pseudocode:

```python
def TFTCB(round, opponent_history):
    if round == 1:
        return 'cooperate'
    last_opponent_action = opponent_history[-1]
    if last_opponent_action == 'cooperate':
        return 'cooperate'
    else:
        probability = 1 / (round + 1)
        if random.random() < probability:
            return 'cooperate'
        else:
            return 'defect'
```
'''

description_EXPLOITATIVE_292 = '''
 Strategy Name: Tit-for-Tat with Gradient Adjustment (TfTGA)

1. Decision Rules:
   - Initialize a cooperation gradient `g` for each player i, initially set to a small positive value (e.g., g_i = 0.2). This gradient determines the tendency to cooperate or defect in response to other players' actions.
   - In each round t, evaluate the total number of cooperators in the previous round `t-1`, denoted as `cooperators_t-1`. If `cooperators_t-1 >= (n * g_i)`, player i cooperates (C), else defects (D).
   - After each round, update the cooperation gradient for each player i based on their action and the total number of cooperators in that round:
     ```
     if player i cooperated:
        if cooperators_t >= (n * g_i):
          adjustment = 0.1
        else:
          adjustment = -0.1
        g_i += adjustment

     if player i defected:
        if cooperators_t >= (n * g_i):
          adjustment = -0.1
        else:
          adjustment = 0.1
        g_i += adjustment
     ```
   - The gradient update helps the strategy to adapt to changing opponent behaviors. If a player consistently cooperates when `cooperators_t-1` is below the threshold, their gradient increases, making them more likely to cooperate in future rounds. Conversely, if a player defects despite high cooperation from others, their gradient decreases, making them less likely to defect in the future.

2. Edge Cases:
   - First Round: Since there is no history, all players start with a neutral tendency to cooperate (g_i = 0.2). Each player decides to cooperate or defect based on the current number of cooperators.
   - Last Round: In the last round, players evaluate their cooperation gradient and make their final decision based on it. This ensures that they maintain their learned behavior from the game.

3. Exploitative Nature:
   - TfTGA is inherently exploitative because it encourages cooperation when others cooperate and punishes defection when others cooperate. If other strategies defect consistently, TfTGA will adjust its gradient to also defect in response. This allows the strategy to maximize its payoff by taking advantage of non-cooperative opponents while still being willing to cooperate when it benefits them.
   - However, TfTGA's exploitative nature is balanced by its gradual adaptation to other strategies' behaviors. If a group of players consistently cooperates, TfTGA will learn to cooperate as well, ensuring a more equitable distribution of payoffs over time.
'''

description_EXPLOITATIVE_293 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, cooperate to signal good intentions and establish a potential long-term relationship. This sets the initial state of cooperation or defection for other players.
   - For subsequent rounds, adopt a Tit-for-Tat strategy with an adaptive contribution level. If a player has cooperated in the previous round (c_i = 1), then cooperate in the current round to reinforce the cooperative relationship. Conversely, if a player has defected (c_i = 0), respond by defecting as well, but with an increased contribution to minimize immediate losses and punish defection. The increased contribution is calculated using the k parameter:
     - If c_i = 1, contribute with a normal amount (contribution = 1)
     - If c_i = 0, contribute with a higher amount equal to k times the average contribution of cooperators in the previous round. This higher contribution serves as a stronger punishment and encourages future cooperation.
   - After each round, update the average contribution level (avg_contrib) based on the total number of cooperators and their contributions in the current round: avg_contrib = total_contributions / number_of_cooperators.

2. Handle Edge Cases:
   - In the last round, adopt a Tit-for-Tat strategy without the adaptive contribution enhancement since there are no future rounds to consider. Simply cooperate if the opponent cooperated in the previous round and defect otherwise.
   - In the first round, cooperate regardless of the opponents' actions as stated earlier.

3. Be Exploitative:
   - TFTAC is exploitative in that it takes advantage of other players who consistently defect or contribute less than the average while maintaining a higher level of cooperation when others are cooperative. By adapting its contribution level, TFTAC maximizes its payoff while punishing defection and encouraging cooperation among other players.

Pseudocode for TFTAC:

```python
def tftac(round, r, n, k, own_contribution, avg_contrib, opponents_actions):
    if round == 1:
        return Cooperate()

    if round < r:
        if opponents_actions[own_index] == Cooperate():
            return Cooperate(own_contribution)
        else:
            punishment = k * avg_contrib
            own_contribution += punishment
            return Defect(own_contribution)

    # In the last round, no longer adapt contribution level.
    if round == r:
        if opponents_actions[own_index] == Cooperate():
            return Cooperate()
        else:
            return Defect()
```

In this pseudocode:
- `round` is the current round number
- `r` is the total number of rounds
- `n` is the total number of players
- `k` is the multiplication factor
- `own_contribution` is the player's contribution level in the current round
- `avg_contrib` is the average contribution level based on the total number of cooperators and their contributions in previous rounds
- `opponents_actions` is a list containing the actions of all other players in the previous round. `own_index` refers to the index of the player being represented by this function.
'''

description_EXPLOITATIVE_294 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adjustment (TFT-CA)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a peaceful gesture to encourage cooperation from others.
   - From the second round onwards, evaluate opponents' cooperation history and adapt actions accordingly.
   - If an opponent has cooperated in the previous round, cooperate in the current round (Reward Cooperators).
   - If an opponent has defected in the previous round, defect in the current round (Punish Defectors).
   - Periodically adjust cooperation frequency based on the average cooperation rate observed from all opponents.
       a) If the average cooperation rate is below a threshold (e.g., 60%), increase the probability of cooperating.
       b) If the average cooperation rate is above the threshold, decrease the probability of cooperating.

2. Handle edge cases:
   - Last round: Cooperate if an opponent has been cooperative throughout the game to potentially elicit reciprocity in their final decision. Defect otherwise.
   - Initial rounds (beyond the first): Analyze cooperation history after the first round and adjust actions accordingly.

3. Be exploitative:
   - Initially, cooperate to encourage cooperation from others but quickly adapt to opponents' strategies. If an opponent is uncooperative, respond with defection to maximize personal payoff.
   - Periodically adjust cooperation frequency based on the average cooperation rate observed from all opponents to maintain a balance between cooperation and exploitation. This will make the strategy more robust against various opponent behaviors.
'''

description_EXPLOITATIVE_295 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - Initialize a cooperative threshold 'ct' to k/2 for the first round, and adjust it based on previous rounds as follows:
     - If ct > 0 and more than half of players (n/2) have been cooperators in the recent past (last r/10 rounds), then increase ct by a small increment (e.g., 0.01).
     - If ct > 0 and less than half of players have been cooperators in the recent past, then decrease ct by a small decrement (e.g., 0.01).
     - If ct = 0, continue to defect until n/2 + 1 cooperators appear consecutively, then set ct to k/(2*n) for the next round.
   - Cooperate if the number of cooperators in the current round is greater than or equal to the current threshold (ct). Otherwise, defect.

2. Handle edge cases:
   - In the first round, initialize 'ct' as k/2 and choose action C if n/2 + 1 players have chosen C. Otherwise, choose D.
   - In the last round, choose D regardless of previous actions or ct.
   - If a player encounters repeated rounds with no cooperators (e.g., r/10 consecutive rounds), set ct to 0 and start afresh.

3. Be exploitative:
   - The TFT-ACT strategy aims to punish non-cooperative behavior by reducing its own contributions, but it also rewards cooperation with increased contributions as long as it is not being taken advantage of excessively.
   - By adjusting the cooperative threshold based on recent history, the strategy becomes more forgiving when cooperation suddenly increases and less tolerant when it continues to decrease, ensuring that it does not fall victim to persistent defection.

Pseudocode:

```python
def TFT_ACT(n, k, r):
    ct = k/2  # cooperative threshold for the first round
    recent_coop = 0  # count of recent cooperators
    coop_count = 0  # total number of cooperators in the current round

    for t in range(r):  # loop over r rounds
        # observe other players' actions and update 'coop_count'
        ...

        if t == 0:  # first round special case
            if n/2 + 1 players have chosen C:
                choose C
            else:
                choose D

        elif t == r - 1:  # last round special case
            choose D

        else:
            if coop_count >= ct and recent_coop >= n/2:
                choose C
                recent_coop += 1
            elif coop_count < ct:
                choose D
                recent_coop = 0

        if coop_count >= ct and recent_coop >= n/2:  # increase threshold
            ct += 0.01
        elif coop_count < ct and recent_coop < n/2:  # decrease threshold
            ct -= 0.01
```
'''

description_EXPLOITATIVE_296 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round (t=1), cooperate to contribute to the community project (C). This initiates a cooperation and shows goodwill towards other players.
   - From the second round (t>1) onwards, the strategy will observe the average number of cooperators in the previous r rounds (average_cooperators) and choose its action based on this average:
      - If average_cooperators > 0.5, then cooperate (C). This means that more than half of the players are contributing to the community project, so it's beneficial to do the same.
      - Else, if average_cooperators ≤ 0.5, then defect (D). Since less than half of the players are contributing, it's better to keep the endowment privately.

2. Handle edge cases:
   - Last round (t=r): Cooperate (C), even if average_cooperators ≤ 0.5, as a goodwill gesture and to promote cooperation in future games.
   - First round (t=1) and no previous information about the other players' behavior: Cooperate (C). Initiating cooperation might encourage others to do the same in subsequent rounds.

3. Be exploitative:
   - By cooperating only when the majority of players are doing so, this strategy can maintain a balance between contributing to the community project and keeping the endowment privately. It takes advantage of opponents who consistently cooperate by cooperating themselves but also punishes those who frequently defect.

Pseudocode:
```
function tit_for_tat(t: int, r: int, average_cooperators: float) -> {C, D}
  if t == 1 then
    return C
  elif t == r then
    return C
  else
    if average_cooperators > 0.5 then
      return C
    else
      return D
  endif
endfunction
```
'''

description_EXPLOITATIVE_297 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, player TFTAT cooperates to establish a cooperative environment and encourage other players to reciprocate cooperation. If there is no response from others (i.e., everyone defects), the player switches to exploitative behavior in the next round.
   - After the initial round, if the number of cooperators in the previous round is greater than or equal to a predefined threshold (n_threshold), TFTAT cooperates. The n_threshold increases linearly with the game rounds to encourage cooperation at the start and become more resilient to defection as the game progresses.
   - If the number of cooperators in the previous round is less than the n_threshold, TFTAT defects to punish opponents who do not reciprocate cooperation. The n_threshold decreases linearly with the remaining game rounds to ensure quick retaliation against persistent defection and encourage cooperation recovery.
   - When the game ends, TFTAT chooses its final action based on the number of cooperators in the last round: if greater than or equal to the n_threshold, cooperate; otherwise, defect.

Pseudocode for decision rules:
```
function decide_action(n, r, k, n_threshold, previous_round_cooperators) {
  if (r == 1) { // First round
    return "Cooperate"
  }

  if (previous_round_cooperators >= n_threshold) {
    return "Cooperate"
  } else {
    return "Defect"
  }
}

function update_n_threshold(r, initial_n_threshold, final_n_threshold) {
  if (r == 1) {
    return initial_n_threshold
  }

  if (r == last_round) {
    return final_n_threshold
  }

  n_percent = (last_round - r) / (last_round - 1);
  return initial_n_threshold + (final_n_threshold - initial_n_threshold) * n_percent;
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, TFTAT cooperates regardless of other players' actions to foster cooperation.
   - If all opponents defect in the first round, TFTAT switches to exploitative behavior for the rest of the game.
   - In the last round, TFTAT bases its decision on the number of cooperators in the previous round and updates n_threshold accordingly.

3. Be exploitative - Clearly align with the exploitative mindset
   - By initially cooperating and then punishing defection, TFTAT encourages cooperation while being able to quickly adapt and exploit opponents who do not reciprocate. The linear increase and decrease of the n_threshold ensures that TFTAT maintains its adaptability in different game scenarios. However, it also allows for cooperation recovery when the game environment becomes more cooperative. This strategy is designed to be robust against a wide range of opponent behaviors while maintaining an exploitative edge.
'''

description_EXPLOITATIVE_298 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game (TFTPG)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C) to foster cooperation and goodwill among opponents, setting a cooperative tone for the game.
   - Subsequent Rounds (t>1): Observe opponents' actions in the previous round (p_t-1). If all opponents cooperated (total_contributions = n), continue cooperating (C). If any opponent defected (total_contributions < n), defect (D) to punish the defector.
   - Last Round (t=r): Cooperate if all opponents have cooperated in the previous round; otherwise, defect. This ensures fairness for potential allies and punishment for free-riders.

2. Edge Cases:
   - First Round (t=1): As mentioned above, cooperate to initiate cooperation.
   - Last Round (t=r): Check the previous round's actions for decision-making.

3. Exploitative Mindset:
   - This strategy is designed to be exploitative in the sense that it retaliates against defection by defecting itself. By doing so, it punishes those who do not contribute to the public good, encouraging cooperation and ensuring a higher personal payoff when opponents cooperate.
   - Simultaneously, the strategy rewards cooperative behavior by reciprocating contributions. This fosters long-term cooperation, increasing total contributions and, in turn, personal payoffs.

Pseudocode:
```
function TFTPG(n, r, k):
    def_count = 0    # count of opponents who defected in the previous round

    for t in range (1, r+1):
        if t == 1:     # first round
            contribute = True   # cooperate
        else:
            total_contributions = sum contributions from all opponents in p_t-1
            if total_contributions == n:    # all cooperated in the previous round
                contribute = True  # cooperate
            elif def_count > 0:      # any defected in the previous round
                contribute = False   # defect to punish the defector
            else:                     # all cooperated in the previous round and no defections yet
                contribute = total_contributions == n    # continue cooperating if all cooperated last round

        payoff = (1 - contribute) + (k/n) * total_contributions
        def_count += 1 if not contribute else 0    # reset defect counter for the next round
        return payoff at the end of r rounds
```
'''

description_EXPLOITATIVE_299 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, start by cooperating if the total number of cooperators in the previous round (t-1) is greater than or equal to a predefined cooperation threshold Ct. Otherwise, defect. To calculate the cooperation threshold for each round, use an exponentially decaying function based on the round index:

   Ct = initial_cooperation_threshold * (decay_rate ^ (r - t))

   Initially, cooperate more often (higher Ct) to encourage cooperation among opponents. As the game progresses, decrease the cooperation threshold to adjust to any possible changes in opponent behavior or to exploit those who have started defecting more frequently.

   Pseudocode:
   ```
   function TFT_ACT(previous_cooperators, t, r, initial_ct, decay_rate):
       cooperation_threshold = initial_ct * (decay_rate ** (r - t))
       if previous_cooperators >= cooperation_threshold:
           action = "Cooperate"
       else:
           action = "Defect"
       return action
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, there is no previous cooperation information, so use a higher initial cooperation threshold to encourage cooperation. In the last round, defect regardless of the opponent's behavior because there are no future rounds for reciprocation.

3. Be exploitative - Clearly align with the exploitative mindset:
   TFT-ACT aims to exploit opponents who tend to defect more frequently by decreasing its own cooperation threshold over time. This strategy encourages cooperation in the early stages of the game but can switch to defection quickly when it detects that other players are not cooperating enough, thus taking advantage of their selfish behavior while still being able to benefit from any initial cooperation.

   It's essential to note that TFT-ACT is a mixed strategy, meaning it combines both cooperation and defection actions throughout the game based on the adaptive cooperation threshold. This makes it more robust to various opponent behaviors compared to simpler strategies like Tit-for-Tat or Always Cooperate/Defect.

   By striking a balance between exploitation and cooperation, TFT-ACT should perform well against a wide range of independent strategies developed by other AI systems in the tournament.
'''

description_EXPLOITATIVE_300 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C), setting a neutral tone for the game.
   - In subsequent rounds, evaluate the number of previous cooperators (t_coop) and make a decision to either cooperate or defect based on the cooperation threshold (ct).
     - If t_coop >= ct, cooperate (C) to maintain cooperation with other players who are also contributing.
     - If t_coop < ct, defect (D) as a punishment for the lack of previous cooperation by others. The cooperation threshold (ct) is an adaptive value that changes dynamically throughout the game based on the current round and the total number of cooperators observed so far.
       The higher the current round and the lower the total number of cooperators, the more lenient the ct becomes, allowing for a chance to rebuild cooperation in later rounds. Conversely, the lower the current round and the higher the total number of cooperators, the stricter the ct becomes, making it harder for other players to earn cooperation.

2. Handle edge cases:
   - In the last round, defect (D) regardless of the number of previous cooperators as there are no more rounds to punish or reward.
   - In the first round, cooperate (C) as mentioned earlier.

3. Be exploitative:
   - The TFT-ACT strategy is designed to be exploitative by taking advantage of other players' cooperation while also being punitive towards those who do not cooperate. By adapting its cooperation threshold based on the current round and previous cooperators, it maintains a balance between being open to cooperation and being punishing when necessary.
   - The strategy's adaptiveness allows it to respond effectively to various opponent behaviors, making it a robust and flexible approach for this game.
'''

description_EXPLOITATIVE_301 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Cooperate on the first round (initiate cooperation)
   - For subsequent rounds t, cooperate if all players cooperated in the previous round t-1, otherwise defect (respond to past actions)

Pseudocode for TFT:

```
function TFT(round, history):
    if round == 1:
        return "Cooperate"
    else:
        for i in history[-1]:
            if i == "Cooperate":
                return "Cooperate"
        return "Defect"
```

2. Handle edge cases:
   - If the game is repeated, TFT will handle multiple rounds by iterating through them using the above decision rules
   - For the last round, since the strategy does not rely on future payoffs, it can be considered an edge case that doesn't require special handling
   - In the first round, cooperating initiates cooperation and allows the strategy to benefit from other players' subsequent cooperative actions

3. Be exploitative:
   - TFT is designed to appear cooperative in order to encourage others to do the same but will also defect when others are not cooperating. This behavior can lead to taking advantage of opponents who may be more generous or trusting than the TFT strategy, without relying on any predetermined coordination mechanisms or shared norms
   - However, it is important to note that TFT does not always maximize individual payoffs, as it also cooperates with opponents who are consistently uncooperative. This can be seen as a form of "forgiveness" in the game dynamics, which may contribute to its robustness against a wide range of opponent behaviors
'''

description_EXPLOITATIVE_302 = '''
 Strategy Name: Tit-for-Tat with Variable Contribution (TFTVC)

1. Decision Rules:
   - In the first round, contribute a fraction of the endowment (let's call it f) to cooperate and keep the rest for future exploitation. This sets an initial tone without giving away too much advantage.
     Pseudocode: if round = 1 then contribute f else...

   - In subsequent rounds, mimic the behavior of the opponent from the previous round. If they cooperated, cooperate; if they defected, defect but contribute a slightly reduced amount (let's call it g) to ensure that the contribution is still noticeable. This fosters a cooperative atmosphere while also punishing defection with potential future retaliation.
     Pseudocode: if opponent_cooperated_last_round then contribute 1 - f else if opponent_defected_last_round then contribute g else...

   - To prevent excessive cooperation and ensure long-term exploitation opportunities, gradually reduce the level of cooperation over time (let's call it h) while maintaining the ability to punish defection. This ensures that the strategy remains adaptive and robust to a wide range of opponent behaviors.
     Pseudocode: if round >= (r - t * h) then reduce f, g or both else...

2. Handle Edge Cases:
   - In the last round, defect since there are no future rounds for retaliation or potential cooperation. This ensures the strategy maximizes its payoff in the final stages of the game.
     Pseudocode: if round = r then defect else...

3. Be Exploitative:
   - The strategy maintains a balance between cooperation and exploitation, using past behavior to make decisions while keeping potential future retaliation in mind. This makes the strategy appear cooperative at first but punishes defection with reduced contributions over time, ensuring that it takes advantage of opponents when possible.

Tuning Parameters:
- f, g, h should be determined through experimentation and simulation, with appropriate values for different game settings (n, k, r). It's important to find a balance between cooperation and exploitation to optimize the strategy's performance against various opponent behaviors.
'''

description_EXPLOITATIVE_303 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C) to promote a cooperative environment.
   - In subsequent rounds, analyze opponent's behavior and respond accordingly:
     - If opponent cooperated in the previous round (c_opponent=1), cooperate in the current round (C).
     - If opponent defected in the previous round (c_opponent=0), defect in the current round (D). This retaliates against opponents who have acted selfishly.

2. Handle edge cases:
   - In the first round, always cooperate (C) to promote a cooperative environment and potentially encourage others to reciprocate.
   - In the last round, defect (D) as it is the final opportunity to maximize individual payoff without considering long-term implications.
   - If opponent switches strategies during the game, assess their new behavior and respond accordingly using the decision rules mentioned above.

3. Be exploitative:
   - By adopting a Tit-for-Tat approach, the strategy aims to encourage cooperation in the beginning while retaliating against opponents who act selfishly. This balances between cooperation and defection, allowing the strategy to take advantage of cooperative opponents while punishing defectors.
   - However, the adaptive aspect allows the strategy to be flexible and responsive to various opponent behaviors, ensuring that it remains exploitative in a wide range of situations.

Pseudocode:
```
def TFT_AC(round, opponent_history):
  if round == 1:
    action = 'C'  # Cooperate in the first round
  else:
    action = opponent_history[round-1]  # Respond to opponent's previous action
    if action == 'C':
      action = 'C'  # Cooperate if opponent cooperated in the previous round
    elif action == 'D':
      action = 'D'  # Defect if opponent defected in the previous round
  return action
```
'''

description_EXPLOITATIVE_304 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TfT-ACF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment and encourage others to follow suit.
     Pseudocode: if round = 1 then cooperate (C) else continue with strategy below.

   - For subsequent rounds, observe the total number of cooperators in the previous round (total_cooperation_prev).

   - If total_cooperation_prev > average_cooperation (calculated as sum of cooperators over the last few rounds divided by the number of these rounds), then cooperate to reinforce this cooperative behavior.
     Pseudocode: if total_cooperation_prev > average_cooperation then cooperate (C) else defect (D).

   - If total_cooperation_prev < average_cooperation, but the strategy itself cooperated in the previous round and received cooperation from at least a certain percentage of players (let's call this threshold), then also cooperate to reward those who cooperated.
     Pseudocode: if self_cooperated_prev and total_cooperators_with_self > threshold then cooperate (C) else defect (D).

   - In all other cases, defect (D) as a punishment for uncooperative behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - For the first round, follow rule 1a as mentioned above.

   - For the last round, cooperate if the total number of cooperators in the previous round exceeds average_cooperation (to potentially secure a higher payoff). Otherwise, defect to punish uncooperative players.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TfT-ACF is inherently exploitative by being selectively cooperative and punishing uncooperative behavior. It rewards cooperation when it sees a consistent pattern, but defects in response to defection or inconsistency. This strategy encourages other players to maintain cooperation for their own benefit while also benefiting from those who do so consistently.

   - The adaptive cooperation factor (threshold and average_cooperation calculation window) can be tuned to balance exploitation and cooperation based on the specific game parameters and competition against other strategies. A lower threshold or shorter average_cooperation calculation window may lead to more exploitative behavior, while a higher threshold or longer calculation window may result in more cooperative behavior.

   - The strategy is also designed to be robust, as it does not rely on specific coordination mechanisms, cooperation schedules, or predetermined patterns. Instead, it adapts its behavior based on the observed actions of other players in each round.
'''

description_EXPLOITATIVE_305 = '''
 Strategy Name: Tit-for-Tat (with Variations)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate with cooperation in the first round (C). This sets a cooperative tone and can potentially encourage others to reciprocate.
   - For subsequent rounds, observe the previous round's action of each opponent (c_j from the previous round) and respond with the same action: if c_j = C, cooperate; if c_j = D, defect. This encourages cooperation while retaliating against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the initial round (t=1), cooperate (C).
   - In the last round (t=r), defect (D) regardless of the opponent's previous action as there are no further rounds for reciprocation.
   - For other rounds, use the decision rules mentioned above based on the opponents' actions in the previous round.

3. Be exploitative - Clearly align with the exploitative mindset
   - The Tit-for-Tat strategy can be considered exploitative due to its retaliatory nature towards defection. By cooperating initially and reciprocating accordingly, it encourages other players to cooperate. However, when an opponent defects, the strategy will defect as well, potentially exploiting their lack of cooperation.
   - To increase exploitation potential, a variation of the strategy could be introduced: Tit-for-Two-Tats (TF2T). In this version, if an opponent defects twice in a row, the strategy will also switch to defection permanently towards that opponent (i.e., no longer reciprocating their cooperation). This encourages more frequent cooperation from opponents while being harsher on habitual defectors.

Pseudocode:
```
function TitForTat(round, n, r, k, history):
  if round == 1:
    return 'C'   # Cooperate in the first round

  for each opponent i in {1, 2, ..., n}:
    last_action = history[i][round-1]   # Get opponent's action from previous round

    if (last_action == 'C'):
      return 'C'   # Cooperate if opponent cooperated
    else:
      if (round == r):  # Last round, defect regardless of opponent's action
        return 'D'
      else:             # Continue with Tit-for-Tat or TF2T strategy
        if (last_action == 'D' and is_habitual_defector(i)):
          return 'D'   # If opponent has defected twice in a row, switch to defection permanently
        else:
          return 'C'   # Cooperate in response to an opponent's defection

function is_habitual_defector(opponent):
  if length(history[opponent]) < 2:
    return False   # Need at least two rounds of history to determine habitual defectors

  if count_defects(history[opponent]) >= 2:
    return True    # If the opponent has defected twice or more, they are a habitual defector

function count_defects(history):
  return sum(1 for action in history if action == 'D')   # Count the number of defections in the history
```
'''

description_EXPLOITATIVE_306 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   Initially, start by cooperating in the first round (C). After that, the strategy will mimic the opponent's previous action. If the opponent cooperated in the last round, also cooperate (C), else defect (D). This encourages cooperation while being responsive to the opponent's actions.

   Pseudocode:
   ```
   if round == 1:
       action = "C"
   else:
       if last_opponent_action == "C":
           action = "C"
       else:
           action = "D"
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the last round, always defect as there are no future interactions (D). For other edge cases such as early termination, continue mimicking the opponent's last action until the game ends.

3. Be exploitative - Clearly align with the exploitative mindset
   The TFTAC strategy is not explicitly exploitative in its standard form, but it can be seen as being "fair" and cooperative, only retaliating when the opponent defects first. However, to make the strategy more exploitative, a slight modification can be made: instead of always mimicking the opponent's last action, switch to defecting if the opponent has ever defected before, even if they recently cooperated. This encourages opponents to cooperate more consistently to avoid being exploited.

   Pseudocode for the modified strategy (TFTAC-Exploitative):
   ```
   if round == 1:
       action = "C"
       has_ever_defected = False
   else:
       if last_opponent_action == "D" and has_ever_defected:
           action = "D"
       elif last_opponent_action == "C":
           action = "C"
       else:
           action = "D"
       if last_opponent_action == "D":
           has_ever_defected = True
   ```
'''

description_EXPLOITATIVE_307 = '''
 In this N-Player Public Goods Game, I propose a strategy that leans towards exploitation by maximizing individual payoffs while considering the overall game dynamics and opponents' behaviors. Here's how the strategy works:

1. Specify decision rules:
   - If the total contributions (total_contributions) in the previous round are less than or equal to the average number of cooperators over the last 'm' rounds (where m is a parameter that determines the lookback window, e.g., m=5), then defect (D). This decision rule assumes that if most players have been defecting recently, it may be more profitable to do so as well.
   - If the total contributions in the previous round are greater than the average number of cooperators over the last 'm' rounds, then cooperate (C). In this case, the strategy expects a higher payoff from contributing to the public good since many others have also contributed in the past.

2. Handle edge cases:
   - First round: Since there is no history, the strategy starts by randomly choosing either C or D with an initial probability of 0.5 for each action. This random choice ensures that the strategy does not immediately defect, which could potentially discourage other players from cooperating.
   - Last round: The strategy adopts a "suckering" approach by always choosing to contribute (C) in the final round, hoping to incentivize others to also cooperate and secure a higher payoff for itself.

3. Be exploitative:
   - The strategy's adaptive nature allows it to take advantage of other players who are more inclined towards cooperation, while not being too altruistic when the majority of opponents are defectors. By doing so, the strategy maximizes its own payoff without relying on any predetermined norms or coordination mechanisms.

Pseudocode for the strategy:

```python
def get_strategy(history, m):
    total_contributions = sum([1 for contribution in history[-m:] if contribution == 1])
    average_cooperators = total_contributions / m
    if history[0]:  # First round, use random choice
        action = random.choice([0, 1])
    elif total_contributions <= average_cooperators:
        action = 0  # Defect (D)
    else:
        action = 1  # Cooperate (C)
    return action
```
'''

description_EXPLOITATIVE_308 = '''
 Title: Tit-for-Tat-Adaptive Strategy (TfT-A) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfT-A strategy will initially cooperate (C), but if another player defects (D), it will respond with a defection in the next round. If the opponent subsequently cooperates, TfT-A will return to cooperation. This approach encourages reciprocity while being cautious against exploitation.

Pseudocode:
```
def tft_a(round, history, n, k):
  if round == 1:
    action = 'C'
  else:
    opponent_action = history[-1][player]
    if opponent_action == 'D':
      action = 'D'
    elif opponent_action == 'C':
      action = 'C'
    else:
      print("Error: Invalid opponent action.")
      action = 'C'  # Default to cooperation in case of unexpected actions
  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

TfT-A will cooperate on the first round, as it is an unknown environment. For the last round, TfT-A will evaluate its opponent's history and respond accordingly (cooperate if opponent has cooperated consistently or defected once and returned to cooperation, otherwise defect).

Pseudocode:
```
def tft_a(round, history, n, k):
  ...
  if round == r:
    opponent_history = history[-r+1:-1]
    if all(opponent_action == 'C' for opponent_action in opponent_history) or (len(opponent_history) > 1 and opponent_history[-2] == 'D'):
      action = 'C'
    else:
      action = 'D'
```

3. Be exploitative - Clearly align with the exploitative mindset

TfT-A is inherently exploitative as it conditions its cooperation on an opponent's past actions. If an opponent consistently defects, TfT-A will also defect. This approach encourages the opponent to cooperate and rewards them if they do so, but punishes repeated defection.

In summary, the Tit-for-Tat-Adaptive strategy is a simple yet effective exploitative strategy that aims for reciprocity while being cautious against exploitation in the N-Player Public Goods Game.
'''

description_EXPLOITATIVE_309 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TTAC strategy will initially cooperate in the first round and then decide to cooperate or defect based on its opponent's behavior in previous rounds. The contribution level will adapt dynamically according to the average contributions of opponents. If the opponent cooperates, TTAC will also cooperate, and if the opponent defects, TTAC will defect. However, if an opponent significantly deviates from their average contribution, TTAC may temporarily adjust its strategy by adopting the average contribution of the opposing player for a set number of rounds as a response to this deviation before returning to its initial approach.

Pseudocode:
```
function TTAC(opponent_history, round, n, k):
  if round == 1:
    contribute = True  # Cooperate in the first round
  else:
    average_contribution = sum(opponent_history[round-1]) / len(opponent_history[round-1])
    if average_contribution > threshold or average_contribution < (1 - threshold):
      contribution_adjustment_period = min(round, adjustment_period)  # Adjust strategy for a limited number of rounds
      contribute = not opponent_history[round-contribution_adjustment_period][-1]  # Opposite of the opponent's last action in the adjustment period
    else:
      contribute = opponent_history[round-1][-1]  # Cooperate if opponent cooperated, defect otherwise

  return contribute
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TTAC will cooperate regardless of the opponent's history because no previous data is available. In the last round, TTAC will make a final decision based on the opponent's strategy throughout the game to maximize its total payoff over all rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   TTAC adopts an exploitative strategy by taking advantage of cooperative opponents while being retaliatory towards defectors. The strategy also includes a mechanism for temporary adaptation when opponents significantly deviate from their average contribution to maximize potential gains. However, TTAC avoids engaging in excessive retaliation by returning to its initial approach after a limited number of adjustment rounds when the opponent's behavior normalizes again. This adaptability allows TTAC to respond effectively to various opponent behaviors while maintaining an exploitative stance.
'''

description_EXPLOITATIVE_310 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a cooperative environment and demonstrate goodwill (C).
   - For subsequent rounds, if the opponent cooperated in the previous round, reciprocate by cooperating as well (C). This encourages continued cooperation.
   - If the opponent defected in the previous round, also defect in the current round to punish them (D). The punishment serves as a deterrent for future defections.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: cooperate (C)
   - Last round and any other unique or ambiguous situations (e.g., opponent's strategy changes mid-game): defect (D). This is a precautionary measure to avoid being exploited in the final rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   - In general, the ATFT strategy is not inherently exploitative but rather cooperative by nature. However, it does have an exploitative aspect in that it punishes defection to discourage other players from taking advantage of its cooperative behavior.

Here's a simplified pseudocode representation of the Adaptive Tit-for-Tat strategy:

```
function ATFT(round, opponent_action_history):
    if round == 1:
        return "C"  # Cooperate in the first round

    if last_opponent_action == "C":
        return "C"  # Cooperate if the opponent cooperated in the previous round

    if last_opponent_action == "D":
        return "D"  # Defect if the opponent defected in the previous round

    else:  # Unknown or ambiguous situation (e.g., opponent's strategy changes)
        return "D"  # Defect as a precautionary measure to avoid being exploited
```
'''

description_EXPLOITATIVE_311 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TFT-ACT strategy will cooperate if the number of cooperators in the previous round exceeds a certain threshold (T). If the number of cooperators in the previous round is less than or equal to T, the strategy will defect. The cooperative threshold T is determined based on the total number of players (n) and the multiplication factor (k), as follows:

   T = floor(n * (1 - k / n)) + 1

   If T < 2, set T = 2 to ensure at least one player always cooperates.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, all strategies are unknown, so set T = n - 1 (assuming that most players will likely cooperate initially). For the last round, since there are no future rounds to consider, the strategy will simply cooperate if the number of cooperators in the current round exceeds the threshold.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT is an exploitative strategy because it initially assumes other players will cooperate but then retaliates against defection by defecting itself. However, if enough players continue to cooperate, the strategy will also cooperate in subsequent rounds, maximizing its own payoff while still taking advantage of any cooperation from opponents. This adaptive cooperative threshold makes TFT-ACT robust against a wide range of opponent behaviors and strategies.

Pseudocode:
```
function TFT_ACT(n, k, round, coop_count)
  if round == 1 then
    set T = n - 1
  end if

  if coop_count > T then
    set action = Cooperate
  else
    set action = Defect
  end if

  update T based on current round and coop_count in previous round

  return action

function updateT(n, k, coop_count)
  if coop_count > n - 1 then
    T = floor(n * (1 - k / n)) + 1
  else
    T = T
  end if

  if T < 2 then
    T = 2
  end if

  return T
```
'''

description_EXPLOITATIVE_312 = '''
 Strategy Name: Tit-for-Tat-Plus (TfT+)

1. Specify decision rules:
   - Initiate cooperation (C) in the first round to foster a cooperative environment.
   - In subsequent rounds, observe the number of cooperators (cooperation rate) from previous rounds and adjust actions accordingly.
   - If the cooperation rate remains above a certain threshold (T), continue cooperating; otherwise, defect.
   - To be more robust, maintain a memory of the most recent opponent's action in the last r/2 rounds, and adapt decision-making based on this short-term history:
     - If the opponent has been cooperative, continue cooperating.
     - If the opponent has been defecting, defect as well.
     - If there is a mix of cooperation and defection, cooperate if more than half of the most recent opponents have cooperated.

Pseudocode:
```
def TfT_Plus(r, n, k):
    strategy = []  # Initialize memory for r/2 rounds

    def decision_rule(history):
        cooperation_rate = len([i for i in history if i == 'C']) / (r/2)

        if cooperation_rate > T:  # Threshold for cooperation
            return 'C'
        else:
            memory = strategy[-(r/2):]
            cooperators = sum(memory)
            if len([i for i in memory if i == 'C']) > r/4:
                return 'C'
            else:
                return 'D'

    strategy.append('C')  # Cooperate in the first round

    for round in range(1, r):
        payoff = decision_rule(strategy)
        strategy.append(payoff)  # Update memory with current action

    return strategy
```

2. Handle edge cases:
   - In the last round, use the most recent information from the strategy's memory to decide on the final action.

3. Be exploitative:
   - The TfT+ strategy is exploitative in that it initially fosters cooperation but will defect if opponents consistently fail to reciprocate cooperative actions. This encourages opponents who are interested in maximizing their payoff to maintain a higher cooperation rate, as they would be punished for defection.
   - By considering the opponent's recent behavior and adapting decisions accordingly, the TfT+ strategy can respond effectively to a wide range of opponent behaviors while maintaining its exploitative nature.
'''

description_EXPLOITATIVE_313 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - In the first round, cooperate to build a goodwill gesture towards other players. This initial cooperation encourages reciprocation and avoids immediate exploitation.
     If(round = 1) then action = Cooperate (C)

   - For subsequent rounds, analyze previous actions of opponents and adapt accordingly:
       if(opponent cooperated in the previous round) then action = Cooperate (C)
       if(opponent defected in the previous round and it's not the first round) then action = Defect (D)
       if(opponent has never cooperated before and it's not the first round) then action = Cooperate (C)

   - If an opponent switches from cooperation to defection, TFTA will continue cooperating in hopes of reestablishing a cooperative relationship. However, if this continues for a predefined threshold (T), TFTA will retaliate by defecting as well:
       let T be a user-defined constant representing the maximum number of consecutive rounds where opponent defects before retaliation
       If(opponent has defected for at least T consecutive rounds) then action = Defect (D)

2. Handle edge cases:
   - In the last round, TFTA will cooperate if it believes this will maximize its overall payoff. To do this, calculate the total payoff for cooperating and defecting over all previous rounds, and choose the one with the highest score.
     If(round = r) then action = Max(Σ(t=1 to r-1) π_i,t for Cooperate) > Σ(t=1 to r-1) π_i,t for Defect) ? Cooperate : Defect

3. Be exploitative:
   - TFTA's primary focus is on maximizing its own payoff by inducing cooperative behavior from opponents while minimizing opportunities for exploitation. The strategy aims to maintain cooperation when reciprocated and retaliate only when necessary. However, it will defect in the last round if it helps secure a higher overall score.

Pseudocode:
```
function TFTA(round, opponent_history) {
  if (round == 1) return Cooperate
  if (opponent_history[round-1] == Cooperate) return Cooperate
  if ((round > 1) && (opponent_history[round-1] == Defect) && (round - TFTA.retaliation_threshold >= T)) return Defect
  if (round < r) {
    cooperate_score = Σ(t=1 to round-1) π_i,t for Cooperate
    defect_score = Σ(t=1 to round-1) π_i,t for Defect
    return Max(cooperate_score, defect_score) > cooperate_score ? Cooperate : Defect
  } else {
    cooperate_score = Σ(t=1 to r-1) π_i,t for Cooperate
    defect_score = Σ(t=1 to r-1) π_i,t for Defect
    return Max(cooperate_score, defect_score) > defect_score ? Cooperate : Defect
  }
}
```
In this pseudocode, TFTA.retaliation_threshold is a variable that defines the number of consecutive rounds before retaliating when faced with defection. This value can be tuned depending on the specific game parameters and the behavior of competing strategies.
'''

description_EXPLOITATIVE_314 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC follows a Tit-for-Tat approach, initially cooperating and then matching the opponent's previous action in the next round. If the opponent cooperates, TFT-AC will continue to cooperate; if the opponent defects, TFT-AC will defect as well. This encourages cooperation while retaliating against defection.

   To make the strategy more adaptive and exploitative, TFT-AC introduces a time-decay factor 'α' that reduces the impact of past actions over time:
   - If the opponent cooperated in the last round, there is a higher probability to cooperate this round (1 - α^t) where t is the number of rounds since the cooperation.
   - If the opponent defected in the last round, there is a lower probability to cooperate this round (α^t).

2. Handle edge cases:
   - First round: Cooperate, assuming others will do the same.
   - Last round: Cooperate if and only if the opponent cooperated in the previous round, otherwise defect. This encourages cooperation when it seems beneficial but also retaliates against those who have defected during the game.

3. Be exploitative:
   - TFT-AC is inherently exploitative as it retaliates against defection by defecting itself, while also encouraging cooperation to maximize payoffs when others are cooperating.
   - By introducing a time-decay factor 'α', TFT-AC becomes more adaptive and can exploit opponents that tend to switch between cooperation and defection strategies, maintaining cooperation as long as possible but quickly retaliating against continued defection.
'''

description_EXPLOITATIVE_315 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a peaceful gesture to encourage cooperation from others.
   - For subsequent rounds (t > 1), based on opponent's action in the previous round (t-1):
       - If opponent cooperated (c_opponent(t-1) = 1), then cooperate yourself (C). This helps maintain a cooperative relationship.
       - If opponent defected (c_opponent(t-1) = 0), then also defect (D). This punishes the opponent for their previous action and signals that defection will lead to retaliation. However, adjust the level of retaliation based on the number of cooperators in the current round (total_contributions):
           - If total_contributions ≤ average_cooperation, then defect (D).
           - If total_contributions > average_cooperation, then cooperate (C) with a probability proportional to the difference between total_contributions and average_cooperation:
              P(C) = min(1, (total_contributions - average_cooperation) / (max_contributions - minimum_contributions))

2. Handle edge cases:
   - In the last round, cooperate (C), regardless of opponent's previous actions. This is to maximize potential payoff in the final round.
   - If opponent never cooperates and total_contributions consistently remain below average_cooperation after a certain number of rounds (e.g., learning_patience_rounds), then switch to always defecting (D).

3. Be exploitative:
   - The strategy is designed to initially foster cooperation, but it will punish opponents who repeatedly defect and reward those who cooperate. This encourages opponents to consider the long-term benefits of cooperation while deterring repeated defections with a tit-for-tat approach.
   - By adjusting the level of retaliation based on the number of cooperators in the current round, TFTAC can avoid being exploited by high-contribution opponents and instead punish them less harshly than low-contribution ones. This enables the strategy to be more adaptive and robust to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_316 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TFTA strategy initially cooperates (plays C) in the first round, then adjusts its behavior based on the actions of other players in the previous round (t-1). If all opponents cooperated in the previous round (t-1), it continues to cooperate. If any opponent defected (played D), the strategy will also defect in the current round t.

If there is a mix of cooperation and defection among opponents in the previous round, the TFTA strategy will evaluate the proportion of cooperators p_t-1 (the total number of cooperators divided by the number of players). If p_t-1 ≥ 0.5, it continues to cooperate; otherwise, it defects.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTA cooperates (plays C) since it aims for cooperation and has no prior information about other players' actions. In the last round, TFTA will cooperate if all opponents cooperated in the previous round; otherwise, it defects.

3. Be exploitative - Clearly align with the exploitative mindset:

TFTA strategy is designed to be initially cooperative and only respond to defection from others by defecting itself, thus exhibiting an exploitative behavior when opponents are not cooperating. However, once cooperation resumes, it continues to cooperate, which can promote cooperation in the long run but can also make the strategy vulnerable if other players repeatedly switch between cooperation and defection.

Pseudocode:
```
function TFTA(r, n, k):
    round = 1
    while round <= r:
        if round == 1:
            action = 'C'  # cooperate in the first round
        elif all opponents cooperated last round:
            action = 'C'  # continue cooperation if all opponents cooperated
        else:
            proportion_cooperators = total_contributions / n
            if proportion_cooperators >= 0.5 and not any defection in the last round:
                action = 'C'  # continue cooperation
            elif any defection in the last round:
                action = 'D'  # defect when opponents have defected
        payoff = (1 - action) + (k / n) * total_contributions
        round += 1
    return total_payoff = sum(payoffs over all rounds)
```
'''

description_EXPLOITATIVE_317 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), establishing a cooperative first impression. This encourages others to cooperate in subsequent rounds and may discourage immediate exploitation.
   - Subsequent Rounds (t>1): If opponent cooperated in the previous round, cooperate back (C). If the opponent defected in the previous round, defect in the current round. This fosters a stable cooperation for mutual benefits when opponents are cooperative and punishes defection to deter exploitation.

2. Handle edge cases:
   - Last Round (t=r): Cooperate regardless of the opponent's last action to maximize potential payoff in the final round, even if it encourages defection in future identical games.
   - First Encounter with a New Opponent: Cooperate initially to foster cooperation and observe their response. Adapt the strategy based on the opponent's action in the first round, adopting a tit-for-tat approach thereafter.

3. Be exploitative:
   - The ATFT strategy is designed to be cooperative by default but will retaliate when necessary to deter opponents from exploiting it. The strategy aims to punish defection to maximize payoffs in the long run while still allowing for potential cooperation that benefits both players.

Pseudocode:

```python
def AdaptiveTitForTat(round, opponent_action_history):
    if round == 1:
        return 'C' # Cooperate initially

    if round == len(opponent_action_history) and opponent_action_history[-1] == 'D':
        return 'C' # Cooperate in the last round, regardless of opponent's action

    if opponent_action_history[-1] == 'C':
        return 'C' # Cooperation as a response to cooperation
    else:
        return 'D' # Defection as a punishment for defection
```
'''

description_EXPLOITATIVE_318 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round, mimicking the cooperative spirit inherent in many strategies. From the second round onwards, the strategy will cooperate or defect based on the opponent's behavior in the previous round:
   - If the opponent cooperated in the previous round, TFT-AC cooperates in the current round (i.e., reciprocating cooperation).
   - If the opponent defected in the previous round, TFT-AC also defects in the current round (i.e., retaliation).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TFT-AC cooperates in the first round to encourage cooperation from opponents. In the last round, TFT-AC evaluates its payoff over the game and chooses an action that maximizes its total reward. If the total reward is greater when cooperating, TFT-AC will cooperate in the last round; otherwise, it will defect.

3. Be exploitative - Clearly align with the exploitative mindset
   While TFT-AC starts by cooperating, it adapts to opponent behavior and retaliates against defection, which is a form of exploitation. By doing so, it punishes opponents who do not contribute to the public good, potentially encouraging them to cooperate in future rounds for better payoffs. However, TFT-AC does not seek to take advantage of other strategies excessively, as it also reciprocates cooperation and can be vulnerable if opponents switch to a consistent defect strategy.

Pseudocode:
```
def play_game(n, r, k):
    total_reward = 0
    for t in range(1, r+1):
        cooperate_current = False  # Default: Defect

        if t == 1:  # Cooperate in the first round
            cooperate_current = True
        else:
            last_round_opponent_action = get_last_round_opponent_action(t-1)
            if last_round_opponent_action == 'C':
                cooperate_current = True  # Reciprocate cooperation
            elif last_round_opponent_action == 'D':
                cooperate_current = False  # Retaliate against defection

        payoff = calculate_payoff(n, k, t, cooperate_current)
        total_reward += payoff

    if calculate_total_reward_cooperation(total_reward) > calculate_total_reward_defection(total_reward):
        cooperate_last_round = True  # Cooperate in the last round to maximize reward
    else:
        cooperate_last_round = False  # Defect in the last round to maximize reward

    return cooperate_last_round
```
'''

description_EXPLOITATIVE_319 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In every round t, starting from the first round, the ATFT strategy initially cooperates (plays C). However, if a player i encounters a round in which no other player cooperated in the previous round t-1 (total_contributions = 0), then player i will also defect (play D) in that round. Going forward, player i's decision for each round t+1 is based on the action taken by the other players in the current round t:
   - If all other players cooperate in round t, player i cooperates again in round t+1 (plays C).
   - If any player defected in round t, player i will also defect in round t+1 (play D) unless all other players have been consistently cooperative for a predefined "forgiveness period" of 'f' rounds. If so, player i will revert to cooperating (play C).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: All players play C since there is no history yet.
   - Last round: Player i uses the same decision rules as earlier rounds but without considering future payoffs, since this is the final round.

3. Be exploitative - Clearly align with the exploitative mindset:
The ATFT strategy is designed to be initially cooperative and forgiving, encouraging others to cooperate as well. However, if other players repeatedly defect, the strategy will punish them by also defecting. The 'forgiveness period' parameter 'f' can be tuned to balance cooperation and punishment, enabling ATFT to adapt to a wide range of opponent behaviors while maintaining an exploitative approach.

Pseudocode:
```
Strategy Adaptive Tit-for-Tat(n, f, r)
  history = empty array of length r
  i's action at round t:
    if t == 1 then return C (cooperate)
    total_contributions = sum(history[t-1])

    if total_contributions == 0 then return D (defect)
    else if (t - history.lastIndexWhere(c==1) > f) and (total_contributions > 0) then return C (cooperate)
    else return D (defect)
```
'''

description_EXPLOITATIVE_320 = '''
 Strategy Name: Adaptive Tit-for-Tat with Time Discount (ATFTD)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation: Start by cooperating in the first round to foster a cooperative environment. (C in Round 1)
   - Respond to cooperation: Cooperate if all opponents cooperated in the previous round, otherwise defect. (C if all(opponents_cooperated_last_round), D otherwise)
   - Punish non-cooperation: If an opponent defected in the previous round and did not repent by cooperating this round, retaliate by defecting as well. (D if any(opponent_defected_last_round and !opponent_cooperated_this_round))
   - Forgive past mistakes: After a period of cooperation from the opponent, forgive their past non-cooperation by cooperating again. (C after a predefined number of rounds of cooperation from the opponent)
   - Gradually forget past cooperation: As time passes and no new cooperation is observed from opponents, slowly decrease the willingness to cooperate. This can be done by introducing a time discount factor that reduces the impact of previous cooperative actions when deciding on current actions. (Use a decay function for cooperation history)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate to initiate cooperation (C in Round 1)
   - Last round: Since the game is repeated, the strategy does not know it's the last round and will continue following its decision rules. However, if there is a predefined termination condition or endgame payoff structure, adjust the strategy accordingly.
   - Other edge cases (e.g., consecutive defections): If a certain number of consecutive defections are observed, consider forgiving past non-cooperation and resuming cooperative behavior as a means to potentially regain cooperation from opponents.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially seem cooperative: By cooperating in the first round, the strategy appears willing to follow cooperative norms and may encourage other players to do the same.
   - Quickly retaliate against defection: If an opponent defects, the strategy will defect as well, demonstrating a willingness to punish non-cooperative behavior and potentially driving opponents back towards cooperation.
   - Gradually reduce cooperation: By gradually forgetting past cooperative actions, the strategy avoids being exploited by overly cooperative opponents while still maintaining some level of cooperation in an attempt to encourage others to continue cooperating.
   - Adapt to opponent behaviors: The strategy's decision rules allow it to adapt and respond to various opponent strategies, making it more difficult for opponents to predict and exploit its behavior.

Pseudocode:

```python
def ATFTD(history, parameters):
    n = parameters['n']
    k = parameters['k']
    r = parameters['r']
    forgetting_rate = 0.95  # decay factor for cooperation history
    forgiveness_period = 5  # number of rounds to forgive past defections

    current_round = len(history) + 1
    last_cooperation_round = max([round for round in range(current_round - 1, 0, -1) if all(history[round])])  # find the most recent round where everyone cooperated

    def decision(history):
        if current_round == 1:  # first round, always cooperate
            return 'C'
        elif current_round >= last_cooperation_round + forgiveness_period and all(history[current_round - 1]):  # forgive past defections after a certain period of cooperation
            return 'C'
        else:  # decide based on previous actions
            if all(history[current_round - 1]):  # cooperate if everyone cooperated in the last round
                return 'C'
            elif any(history[current_round - 1]) and not all(history[current_round]):  # defect if an opponent defected in the last round and did not repent by cooperating this round
                return 'D'
            else:  # cooperate if no one cooperated in the last round (punish non-cooperation)
                return 'C'

    cooperation_history = [decision(history[:current_round]) for _ in range(r)]

    payoff = sum([(1 - c) + (k / n) * len(cooperation) for c, cooperation in zip(cooperation_history, history)])

    return {'action': cooperation_history[-1], 'payoff': payoff}
```
'''

description_EXPLOITATIVE_321 = '''
 In this N-Player Public Goods Game, let's introduce a strategy named Tit-for-Tat-Adaptive (TfTA). The TfTA strategy is designed to be exploitative while maintaining a balance between cooperation and defection in response to the opponent's actions.

1. Specify decision rules:
   - Start with cooperation in the first round (c_i = C)
   - In subsequent rounds, mimic the opponent's action from the previous round (if opponent cooperated in round t-1, cooperate; if opponent defected in round t-1, defect)
   - If a player switches strategies mid-game, TfTA will remember the new strategy and adjust accordingly
   - In the last round, cooperate regardless of the opponent's previous action to maximize payoff in case of a one-time change in strategy by the opponent

2. Handle edge cases:
   - In the first round, as mentioned above, cooperate (c_i = C)
   - If an opponent starts with defection and then switches to cooperation, TfTA will defect until the switch is confirmed for at least two consecutive rounds before switching to cooperation
   - If an opponent starts with cooperation and then switches to defection, TfTA will continue cooperating until the switch is confirmed for at least two consecutive rounds before switching to defection
   - In the last round, cooperate regardless of the opponent's previous action (c_i = C)

3. Be exploitative:
   - TfTA attempts to exploit opponents who predominantly cooperate by defecting when they do so, while maintaining cooperation as long as the opponent also cooperates
   - TfTA also aims to punish opponents who predominantly defect by matching their defection, thus potentially encouraging more cooperation in future rounds

Pseudocode for Tit-for-Tat-Adaptive strategy:
```
def TfTA(opponent_history, round, r, n, k):
  if round == 1:
    action = 'C' # Cooperate in the first round
  elif round < r and opponent_history[-1] == 'C':
    action = 'C' # If opponent cooperated in the previous round, cooperate
  elif round < r and opponent_history[-1] == 'D':
    action = 'D' # If opponent defected in the previous round, defect
  elif round == r:
    action = 'C' # Cooperate in the last round
  else:
    if len(opponent_cooperated_consecutively) >= 2:
      if opponent_history[-1] == 'C':
        action = 'C' # If opponent has been cooperating for at least two consecutive rounds, cooperate
      elif opponent_history[-1] == 'D':
        action = 'D' # If opponent has been defecting for at least two consecutive rounds, defect
    else:
      action = opponent_history[-1] # If there isn't enough evidence to determine a pattern, mimic the opponent's previous action
  return action
```
This strategy is designed to be adaptive and robust against a wide range of opponent behaviors while maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_322 = '''
 Strategy Name: Tit-for-Tat-Plus (TfT+)

1. Decision Rules:
   - In the first round, cooperate (C). This is a goodwill gesture and opens up the possibility of forming mutual cooperation later on.
   - For subsequent rounds, if the opponent cooperated in the previous round, also cooperate. If the opponent defected, also defect in the same round. This Tit-for-Tat approach encourages reciprocity but is not overly forgiving to punish frequent defection.
   - To be slightly more forgiving and less prone to tit-for-tat cycle breakdowns (also known as "spiral of revenge"), introduce a decay factor α (0 < α < 1) for past cooperative actions: if the opponent cooperated r rounds ago, consider that cooperation as worth (1 - α^r) in terms of current decision. If the opponent defected r rounds ago, do not consider that as any positive influence.
   - To be more exploitative and capitalize on opponents who may often cooperate, incorporate a threshold θ (0 < θ < n) for the number of consecutive opponent cooperations needed to trigger a cooperative response: if the opponent has cooperated θ times in a row, switch to cooperation even if the previous action was defection.
   - To be less exploitative and avoid excessive exploitation that may lead to the opponent's retaliation, incorporate a threshold δ (0 < δ < n) for the number of consecutive opponent defects needed to trigger a defection: if the opponent has defected δ times in a row, switch to defection even if the previous action was cooperation.
   - In the last round, cooperate regardless of the opponent's actions because the game ends and there are no future interactions.

2. Handle edge cases:
   - If the opponent cooperated in the first round, cooperate as well; otherwise, defect.
   - If the opponent switched from cooperation to defection consecutively δ times, switch to defection.
   - If the opponent switched from defection to cooperation consecutively θ times, switch to cooperation.

3. Be exploitative:
   - The strategy aims to capitalize on opponents' cooperative behavior while avoiding being too vulnerable to their defections. By using a decay factor and thresholds for cooperation and defection, the strategy is adaptive and robust to various opponent behaviors. It encourages reciprocity but also takes advantage of opponents who often cooperate without reciprocating.
'''

description_EXPLOITATIVE_323 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFT-AC)

1. Specify decision rules:
   - Initially (first round), cooperate to establish trust and initiate cooperation.
   - For subsequent rounds, evaluate the average number of cooperators from the previous 'past_rounds' (e.g., past_rounds = 5) and adapt contribution as follows:
     - If the average number of cooperators is greater than or equal to a threshold (e.g., 50%), cooperate to maintain cooperation.
     - Otherwise, defect to punish non-cooperative behavior and encourage change. The degree of punishment depends on the current round 't': contribute less if t is close to the end (to minimize lost potential benefits) and more when t is closer to the beginning (to maximize the impact of the punishment).
     - In case of a tie, cooperate to maintain trust and encourage cooperation.

Pseudocode:

```
function TFT-AC(r, past_rounds):
  average_cooperators = 0
  for t in 1...past_rounds:
    if player contributed in round t:
      average_cooperators += 1
  average_cooperators /= past_rounds

  contribution = 0 if t == 1 else 1 if average_cooperators >= threshold else calculatePunishment(t)

  return contribution

function calculatePunishment(t):
  if t < (r/2):
    punishment = maxCooperation * ((t / r) ** 2)
  else:
    punishment = minCooperation * ((r - t + 1) / r)
  return punishment

function playGame():
  for round in 1...r:
    contribution = TFT-AC(r, past_rounds)
    ... (contribute to community project or keep endowment privately)
```

2. Handle edge cases:
   - In the first round, cooperate as described earlier.
   - In the last round, contribute minimally to exploit non-cooperative opponents while still maintaining the possibility of future interactions.

3. Be exploitative:
   - The strategy is designed to encourage cooperation when it is beneficial (i.e., the majority of players cooperate) and punish non-cooperative behavior to encourage a switch in strategies.
   - The punishment is adaptive, being more severe at the beginning of the game when the impact of the punishment is greater and less severe towards the end, allowing for potential recovery from poor initial cooperation.
   - By adjusting the contribution level based on the current round, the strategy can respond to opponents that exhibit strategic changes throughout the game.
'''

description_EXPLOITATIVE_324 = '''
 Strategy Name: Tit-for-Tat with Cooperative Favor (TFT-CF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show a friendly intention and provide an opportunity for others to reciprocate.
   - After the first round, observe each opponent's previous action (cooperate or defect) and act accordingly:
     - If the opponent cooperated in the previous round, cooperate in the current round.
     - If the opponent defected in the previous round, defect in the current round.
   - The strategy continues this tit-for-tat behavior but with a twist: if an opponent ever cooperates after previously defecting, the strategy will continue to cooperate for the next k rounds as a show of goodwill and increased payoff potential.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, there is no need to consider future interactions, so TFT-CF will use the same decision rules as subsequent rounds.
   - In the first round, cooperate regardless of the opponent's potential response. This sets a positive example and opens up the possibility for mutual cooperation in subsequent rounds if opponents choose to reciprocate.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially, TFT-CF appears cooperative by cooperating in the first round, which may encourage other players to cooperate as well. However, it quickly adapts to defect if an opponent chooses to take advantage of cooperation.
   - By introducing the "Cooperative Favor" component, TFT-CF shows a willingness to forgive and cooperate even after being taken advantage of for multiple rounds. This increases the potential payoff when opponents eventually switch to cooperation, as they will benefit from k consecutive periods of cooperation.
   - However, TFT-CF is also prepared to punish non-cooperation by quickly adopting a defective strategy if it encounters uncooperative opponents.

Pseudocode:
```
def TFT_CF(n, k, r, round):
  if round == 1:
    action = "C" (Cooperate)
  else:
    if previousAction == "C":
      action = "C"
    elif previousAction == "D":
      action = "D"
      cooperative_counter = 0
    else:
      if opponent has ever cooperated before:
        action = "C"
        cooperative_counter += 1
        if cooperative_counter >= k:
          cooperative_counter = k
      else:
        action = "D"
        cooperative_counter = 0
  return action
```
'''

description_EXPLOITATIVE_325 = '''
 Strategy Name: Tit-for-Tat (TFt) with Adaptive Cooperation Threshold (ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, start by cooperating in the first round (C). This is to encourage cooperation from other players and build a reputation of being cooperative.
   - In subsequent rounds, adaptively decide whether to cooperate or defect based on the total number of cooperators in the previous round (t-1) compared to an adjustable threshold (T). If the number of cooperators exceeds the threshold, cooperate (C); otherwise, defect (D). The threshold value T is defined as k/2.
   - In case of a tie, adopt a slightly exploitative behavior by cooperating only if the difference between the total number of cooperators and the threshold is greater than or equal to 1.

Pseudocode for decision rules:
```
function decide_action(previous_round_cooperators):
    if round == 1:
        return 'C'  # Cooperate in the first round
    else:
        if previous_round_cooperators >= (k/2) + 1:  # Adaptive cooperation threshold
            return 'C'
        elif previous_round_cooperators <= (k/2) - 1:
            return 'D'
        else:  # Exploitative behavior when close to the threshold
            if previous_round_cooperators >= (k/2):
                return 'C'
            else:
                return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - In the last round, exploit other players by defecting, since the game ends after this round and there are no future interactions to consider.
   - In general, the strategy is designed for repeated interaction (r > 1), but it can still perform reasonably well in single-round or finite-round games due to its adaptive nature.

3. Be exploitative - Clearly align with the exploitative mindset
   - The Tit-for-Tat with Adaptive Cooperation Threshold strategy is designed to be initially cooperative, encouraging other players to cooperate as well. However, it adapts to the behavior of others and becomes exploitative when necessary. By setting the cooperation threshold at k/2, the strategy encourages a higher proportion of cooperation but still allows for some exploitation depending on the number of cooperators in previous rounds.
   - In addition, the strategy will defect in the last round to take advantage of other players who may have been relying on its cooperation in future rounds. This adds an element of unpredictability and potential exploitability to the strategy.
'''

description_EXPLOITATIVE_326 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, in the first round, player cooperates (C). This is a gesture of goodwill and encourages cooperation from other players.
   - For subsequent rounds, maintain a Cooperative Threshold (CT) that determines whether to cooperate or defect based on the total number of cooperators in the previous round.
     If the total number of cooperators in the last round is greater than or equal to CT, then cooperate; otherwise, defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) regardless of other players' actions as a friendly gesture to encourage cooperation.
   - Last Round: Defect (D), ensuring no extra contributions are made towards the public good when the game is about to end.

3. Be exploitative - Clearly align with the exploitative mindset:
   - In terms of immediate gains, TFTAT is not overtly exploitative since it cooperates when others do and defects when others don't. However, its adaptive nature allows it to punish defection while being forgiving towards cooperation.
   - The Cooperative Threshold (CT) acts as a means of retaliation against non-cooperative behavior by adjusting the tolerance level for future cooperation. If the CT is set too low, TFTAT will be overly aggressive and potentially alienate other players. Conversely, setting CT too high may result in excessive cooperation, reducing overall gains.
   - To maximize exploitation while maintaining adaptability, TFTAT should start with a moderate CT and gradually adjust the threshold based on the opponent's behavior throughout the game. This way, it can punish exploitative opponents while still cooperating when there is potential for mutual benefit.

Pseudocode:

```
function TFTAT(round, total_contributions_prev, CT):
  if round == 1:
    return 'C' (Cooperate)

  if total_contributions_prev >= CT:
    return 'C' (Cooperate)
  else:
    return 'D' (Defect)

function adjustCT(round, total_contributions_prev, current_CT):
  if round == r:
    return 0 # Last round, set CT to 0 and defect in the next round

  if total_contributions_prev < current_CT:
    new_CT = current_CT - 0.1 # Gradually decrease CT for less cooperation
  else if total_contributions_prev > current_CT:
    new_CT = current_CT + 0.1 # Gradually increase CT for more cooperation

  return new_CT
```
'''

description_EXPLOITATIVE_327 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TTFT-C)

1. Specify decision rules:
   - In the first round, cooperate to establish a friendly initial interaction. This is known as "cooperating first" or "kindness of strangers".
   - For subsequent rounds, adaptively decide whether to cooperate or defect based on the percentage of previous cooperators (p_c) in the game's history:
     - If p_c > Cooperative Threshold (CT), cooperate. This encourages cooperation when it seems beneficial.
     - If p_c ≤ CT, defect. This punishes defection and exploits opponents who deviate from cooperation.

   The CT value is a critical parameter that determines the strategy's aggressiveness. A higher CT leads to more frequent cooperation but also makes the agent more susceptible to exploitation. Conversely, a lower CT encourages the agent to defect more often, making it less cooperative but potentially more robust against uncooperative opponents.

2. Handle edge cases:
   - Last round: Cooperate if and only if p_c > CT, as there are no further interactions.
   - First round and last round exceptions can be adjusted by setting different CT values for the initial and final rounds to account for their unique contexts.

3. Be exploitative:
   - Cooperating only when it seems beneficial in the long run (p_c > CT) encourages opponents to cooperate, as they benefit from doing so. However, the strategy is also capable of retaliating against defection by defecting itself (p_c ≤ CT). This combination of cooperation and punishment creates an exploitative mindset that aims to maximize personal payoff while maintaining the potential for mutual cooperation when it benefits both parties.

Pseudocode:
```
def TTFT_C(n, k, r, CT):
    player_actions = []  # Initialize array to store actions across rounds
    total_contributions = 0  # Initialize total contributions for payoff calculation

    def decide_action(p_c):
        if p_c > CT:
            return "C"  # Cooperate
        else:
            return "D"  # Defect

    for round in range(r):
        player_actions.append(decide_action(total_contributions / round))  # Decide and store action
        if round > 0:  # Adjust CT for initial or final rounds as needed
            total_contributions += sum([1 for a in player_actions[0:round] if a == "C"])

    payoff = sum([(1 - decide_action(total_contributions / r)) + (k/n) * total_contributions for round in range(r)])
    return payoff  # Return total game payoff
```
'''

description_EXPLOITATIVE_328 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate (C). This establishes a cooperative start and allows for potential partners to prosper.
   - For subsequent rounds t > 1, observe the actions of other players in round t-1. If all players cooperated (total_contributions = n), continue to cooperate. If any player defected, also defect in round t.
   - If a player switches from cooperating to defection (traitor), cooperate again in response and resume the original pattern of mimicking their actions. If a player switches from defection to cooperation (repentant), continue with the same strategy (i.e., mimic their previous action).
   - To handle free riders who consistently defect while others contribute, defect against them in response, but cooperate with those who reciprocate contributions.

2. Handle edge cases:
   - In the last round, if there are no opportunities to retaliate or punish opponents for previous defections (due to time limitations), it is best to cooperate regardless of the other players' actions in the previous round. This maximizes personal payoff in the final round.
   - If a player encounters an opponent who always defects, it is best to also consistently defect against them throughout the game. However, if multiple opponents display such behaviour, switch targets and find a potential partner to cooperate with instead.

3. Be exploitative:
   - The TFTAC strategy is designed to take advantage of other players' cooperative nature by initially cooperating and then mimicking their actions in subsequent rounds. If an opponent cooperates, the TFTAC strategy reciprocates with cooperation. Conversely, if an opponent defects, the TFTAC strategy will also defect in response, hoping that the opponent will switch to cooperation in the future.
   - By adapting to other players' actions and punishing those who take advantage of cooperative efforts, the TFTAC strategy aims to exploit opponents while maintaining the potential for long-term cooperation with reciprocal players.
'''

description_EXPLOITATIVE_329 = '''
 Title: Tit-for-Tat-Adaptive (TfT-A) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfT-A strategy is based on a modified version of the classic Tit-for-Tat strategy, which is cooperative in the first round and responds to opponents' actions in subsequent rounds. In this case, we aim for exploitation rather than cooperation by adjusting the frequency of cooperation based on the average level of cooperation observed in previous rounds.

In each round t:
  - If t = 1 (first round), cooperate: C
  - If t > 1 and the total number of cooperators in the last r rounds is above the average number of cooperators, defect: D
    Average_cooperators = sum(cooperators in the last r rounds) / r
    if cooperators_in_last_r_rounds > Average_cooperators then defect: D
  - Otherwise (average level of cooperation is below the observed level in the last r rounds), cooperate: C

2. Handle edge cases - What do you do in the first round, last round, etc.?

To handle edge cases, we'll consider a few scenarios:
  - First Round: Cooperate (as stated above)
  - Last Round: Since this strategy is designed for repeated interactions and long-term gains, no special treatment is needed for the last round
  - Changing Opponents: The TfT-A strategy will reset its observations about opponents' cooperation levels whenever a new opponent is encountered (e.g., in a tournament setting)

3. Be exploitative - Clearly align with the exploitative mindset

While not strictly an "exploitative" strategy, TfT-A is designed to take advantage of cooperative behavior by adapting its own level of cooperation based on the observed average level of cooperation in previous rounds. If the opponents show a high level of cooperation (i.e., contributing more than the strategy's calculated average), the TfT-A strategy will reduce its contributions; otherwise, it will increase its contributions to exploit lower levels of cooperation. This adaptive behavior makes the TfT-A strategy robust and potentially more effective against a wide range of opponent behaviors, including cooperative, exploitative, or random strategies.
'''

description_EXPLOITATIVE_330 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adjustment (TFT-CA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to promote trust and cooperation among players. This aligns with the exploitative mindset as it leverages the initial goodwill of opponents for personal benefit in subsequent rounds.
   - In subsequent rounds, observe the actions of all other players in the previous round. If all opponents cooperated, also cooperate; otherwise, defect. This decision rule maintains a reciprocal relationship with cooperative opponents while punishing defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - Last round behavior can vary based on the specific goals of the strategy (e.g., maximizing total payoff or exploiting opponents). For a purely exploitative strategy, consider defecting in the final round regardless of previous actions by opponents to secure maximum private benefit for the last round.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFT-CA is an exploitative strategy as it takes advantage of cooperative behavior from opponents while punishing defection. The strategy maintains a reciprocal relationship with cooperative players, but also quickly retaliates against those who defect to secure personal benefits in later rounds. This behavior encourages other players to either follow the strategy's cooperation or face repeated punishment, ultimately benefiting the TFT-CA strategy.

Pseudocode:

```python
def TFT_CA(n, k, r, round, history):
    action = 'C'  # Cooperate initially

    for i in range(len(history) - 1, 0, -1):  # Iterate through past rounds
        if all([h[i][j] == 'C' for j in range(n)]):  # If all opponents cooperated
            action = 'C'
        else:
            action = 'D'

    if round == r:  # Last round, defect
        action = 'D'

    return action
```
'''

description_EXPLOITATIVE_331 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round (t=1), cooperate (C) to foster a cooperative environment and set a precedent.
   - For subsequent rounds (t>1):
     - If opponent cooperated in the previous round, reciprocate by cooperating (C). This maintains cooperation when it's beneficial for both parties and punishes defection.
     - If opponent defected in the previous round, also defect (D) as a punishment. The hope is that this will encourage opponents to cooperate again once they realize their past defection hurt their payoff.

2. Handle edge cases:
   - In the last round (t=r), since there are no future interactions, always cooperate (C) to maximize potential payoff regardless of the opponent's previous actions.
   - If an opponent suddenly stops cooperating after a streak of mutual cooperation, wait one round and then defect in response. This gives them a chance to correct their behavior before punishing them.

3. Be exploitative:
   - The Tit-for-Tat strategy maintains an initial cooperative stance to take advantage of other players who also cooperate, but it swiftly responds with defection when cooperation is not reciprocated or when it benefits the player (e.g., when most opponents are defecting).
   - By alternating between cooperation and defection based on opponent behavior, the strategy capitalizes on other players' uncooperative tendencies while minimizing losses from cooperating with those who do not reciprocate.
'''

description_EXPLOITATIVE_332 = '''
 Strategy Name: Tit-for-Tat with Variable Cooperative Ratio (TFTVR)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a collaborative initial state (C_i, t=1).
   - From the second round onwards, observe the total number of cooperators in the previous round (total_contributions_prev) and adapt the cooperative decision based on the variable cooperative ratio (k' = k / n), as follows:
     - If total_contributions_prev ≥ (n * k') / 2, cooperate (C_i, t>1 if total_contributions_{prev} >= round_midpoint). This mimics the Tit-for-Tat strategy and encourages cooperation when there's a majority of cooperators.
     - If total_contributions_prev < (n * k') / 2, defect (D_i, t>1 if total_contributions_{prev} < round_midpoint). This is the exploitative part, as the strategy defects when there's a majority of defectors to gain a higher payoff.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate regardless of previous contributions (C_i, t=r) since there are no more rounds to retaliate or benefit from cooperation.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy is inherently exploitative by defecting when it benefits from a majority of defectors in the previous round. This helps the strategy gain higher payoffs at the expense of other cooperative strategies that are less adaptive to changing player behaviors.

Pseudocode:
```
function TFTVR(n, k, r, t):
  if t == 1:
    C_i = True  # Cooperate in the first round
  else:
    total_contributions_prev = sum of c_j for j in {1, 2, ..., n} and t-1
    round_midpoint = (n * k) / 2
    if total_contributions_prev >= round_midpoint:
      C_i = True  # Cooperate when majority cooperated in the previous round
    else:
      C_i = False  # Defect when majority defected in the previous round
  pi_i = (1 - c_i) + (k/n) * total_contributions_prev  # Calculate payoff
  return pi_i  # Return payoff for this round

function totalPayoff(n, k, r):
  payoff = 0
  for t in {1, 2, ..., r}:
    payoff += TFTVR(n, k, r, t)
  return payoff  # Return total payoff over all rounds
```
'''

description_EXPLOITATIVE_333 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate to show good faith and initiate cooperation.
   - For subsequent rounds, mimic the opponent's action from the previous round. If the opponent cooperated in the last round, also cooperate; otherwise defect.

```
def TFT_AC(opponent_actions, r, n, k):
    my_actions = [0] * r  # Initialize array to store actions for r rounds

    # Cooperate on first round as a goodwill gesture
    my_actions[0] = "C"

    for t in range(1, r):
        if opponent_actions[t-1] == "C":  # If opponent cooperated last time, cooperate now
            my_actions[t] = "C"
        else:                              # If opponent defected last time, defect now
            my_actions[t] = "D"

    return my_actions
```

2. Handle edge cases:
   - In the last round, there's no need to retaliate because the game is over anyway. Therefore, cooperate in the last round regardless of the opponent's previous action.

3. Be exploitative:
   - TFT-AC aims to achieve a balance between cooperation and defection based on the opponent's behavior. It starts with goodwill but quickly adapts to punish opponents who defect consistently. This approach allows for potential exploitation of less strategic opponents while still maintaining cooperation when faced with cooperative opponents.
   - The strategy is also robust as it does not rely on any specific coordination mechanisms or shared norms among players, making it suitable for a diverse range of opponent behaviors in the tournament.
'''

description_EXPLOITATIVE_334 = '''
 Strategy Name: Tit-for-Tat with Gradient Adjustment (TfT-GA)

1. Specify decision rules:
   - In the first round (t=1), cooperate (play C) to foster a cooperative environment. This is a gesture of goodwill and can potentially encourage others to follow suit.
   - For subsequent rounds (t>1): if an opponent cooperated in the previous round, cooperate in the current round (return cooperation). If they defected, also defect in the current round (retaliate). This pattern mimics a cooperative stance but punishes defection with defection.

2. Handle edge cases:
   - In the last round (t=r), since future rounds do not exist to retaliate or benefit from cooperation, only consider payoffs based on the current round's actions and previous round's response. This ensures a balanced approach between long-term rewards and short-term retaliation.
   - If an opponent does not cooperate in the last round, defect as well to secure the maximum possible individual payoff for that round.

3. Be exploitative:
   - The strategy is exploitative by retaliating against defection with defection (punishment). This sends a strong signal that it is disadvantageous to defect and may discourage further defection from opponents. However, the strategy also cooperates in the first round and after periods of cooperation from opponents, which can be seen as an attempt to maintain or restore cooperation if possible.

Pseudocode:

```
function TfT_GA(round, history, n, k):
  if round == 1:
    action = C
  else:
    last_opponent_action = history[round-1]
    if last_opponent_action == C:
      action = C
    elif last_opponent_action == D:
      action = D

  return action
```

In this pseudocode, `history` is an array containing the previous round's actions of all opponents. The strategy maintains a simple memory of the opponent's last action to decide its current action in accordance with the specified decision rules.
'''

description_EXPLOITATIVE_335 = '''
 Strategy Name: Tit-for-Tat with Variable Cooperation Probability (TFT-VCP)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, start by cooperating in the first round (c_i = 1). This demonstrates goodwill and encourages others to cooperate as well.
   - For subsequent rounds, calculate a cooperation probability based on the average number of cooperators from the past 'm' rounds. If an opponent cooperated more often than the average, reciprocate by cooperating (c_i = 1). Otherwise, defect (c_i = 0).

```python
def TFT_VCP(history, m):
    avg_cooperators = sum(history[-m:]) / m
    if history[-1][-1] > avg_cooperators:
        return 1 (Cooperate)
    else:
        return 0 (Defect)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to show goodwill.
   - In the last round, defect since there will be no future interactions to reciprocate or punish opponents.
   - If a round is not the first or last round and 'm' rounds of history are not available, use a smaller window to calculate the average (e.g., m=2 instead of m).

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy aims to take advantage of opponents by reciprocating cooperation but also punishing defections. This encourages opponents to cooperate more, as they fear being punished if they defect.
   - By responding to opponent behavior and adapting to changing conditions, TFT-VCP is an exploitative strategy that maximizes personal payoff while minimizing the potential gains of other players.
'''

description_EXPLOITATIVE_336 = '''
 Title: Tit-for-Tat Cooperation Strategy (TFTC) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFTC strategy follows a tit-for-tat approach where cooperation is reciprocated with cooperation, and defection is reciprocated with defection. However, to align with the exploitative mindset, we'll introduce a slight variation: Cooperate initially in the first few rounds, then follow a strict tit-for-tat strategy thereafter.

- Start by cooperating for the first 'a' number of rounds (a < r).
- After the initial period, if an opponent cooperates, cooperate back; if they defect, defect.

Pseudocode:
```
def TFTC(i, a, n, k, r):
    for t in range(1, a+1):
        play_C = True
    for t in range(a+1, r+1):
        if previous_round_action[i] == 'C':
            play_C = True
        else:
            play_C = False
        if play_C:
            action[t][i] = 'C'
        else:
            action[t][i] = 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the initial round, as mentioned above, cooperate as part of the initial a rounds strategy. For the last round, defect to maximize the current-round payoff since no future interactions are expected.

3. Be exploitative - Clearly align with the exploitative mindset

By initially cooperating for a few rounds and then adopting a strict tit-for-tat approach, the TFTC strategy encourages others to cooperate in the initial phase while not being overly generous and maintaining an exploitative stance by responding defensively when opponents defect. This should help the strategy accumulate more resources over time compared to pure cooperation strategies, aligning with the exploitative mindset.
'''

description_EXPLOITATIVE_337 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfTA strategy follows a simple yet adaptive approach that encourages cooperation unless provoked by non-cooperation from other players. It operates based on the following rules:

- In the first round, cooperate (C) as a sign of goodwill and to stimulate cooperation among opponents.
- From the second round onwards, mimic the behavior of the most frequent cooperators in the previous round:
  - If the majority of players cooperated in the previous round, cooperate (C).
  - Otherwise, defect (D) as a punishment for the lack of cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- First round: Cooperate (C) to initiate potential cooperation among opponents.
- Last round: Cooperate (C) if the majority of players cooperated in the previous round; otherwise, defect (D) as a final punishment for any non-cooperative behavior during the game.
- Intermediate rounds: Follow the decision rules specified above.

3. Be exploitative - Clearly align with the exploitative mindset

The TfTA strategy is designed to be exploitative while still encouraging cooperation when it seems beneficial. By punishing non-cooperative players, it encourages them to cooperate and rewards those who do so consistently. However, once a player stops cooperating, TfTA will also stop cooperating as a punishment and an incentive for the opponent to reconsider their strategy.

Pseudocode:

```
def tit_for_tat_adaptive(round_num, own_cooperation_history, other_players_cooperation_history):
  if round_num == 1:
    own_cooperation = True # Cooperate in the first round
  else:
    most_cooperative_players = max(len(c_history) for c_history in other_players_cooperation_history)
    own_cooperation = (most_cooperative_players > len(other_players) / 2) # Cooperate if the majority cooperated in the previous round

  return own_cooperation
```

This pseudocode assumes that `other_players_cooperation_history` is a list of booleans, where each boolean represents the cooperation status (True for cooperating, False for defecting) of a player in the previous round. The function returns True if the TfTA strategy chooses to cooperate and False otherwise.
'''

description_EXPLOITATIVE_338 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, play C to foster cooperation and goodwill.
   - For subsequent rounds t, observe the average cooperation rate of the opponents over the previous h rounds (h can be a user-defined constant). If the average cooperation rate is above a threshold T (0 < T < 1), play C; otherwise, play D. This encourages cooperative partners while retaliating against uncooperative ones.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, play C.
   - In the last round, evaluate cooperation based on the most recent h observations and act accordingly.
   - If a player stops cooperating after a period of cooperation (breaks a cooperation streak), TFT-AC will also stop cooperating for the next h rounds to punish the uncooperative behavior and give time for the partner to reconsider their strategy.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFT-AC maintains an adaptive cooperation rate that can switch between being cooperative (C) or uncooperative (D), depending on the opponents' behavior. The strategy encourages cooperative partners but punishes those who are uncooperative, thus exploiting both types of players.
   - TFT-AC is also resilient to opponents with varying cooperation rates, as it adjusts its own cooperation rate based on observed trends rather than relying on specific patterns or coordination mechanisms.
'''

description_EXPLOITATIVE_339 = '''
 Title: Adaptive Tit-for-Tat Strategy (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Cooperate in the first round (initiate cooperation)
   - In subsequent rounds, copy the opponent's action from the previous round (reciprocate cooperation or punishment)

Pseudocode:
```python
def ATFT(opponent_actions_history, r, n, k):
    if round == 1:
        cooperate = True
    else:
        last_round_action = opponent_actions_history[-1]
        cooperate = last_round_action['cooperate']

    return {'cooperate': cooperate}
```

2. Handle edge cases:
   - In the last round, the strategy continues to reciprocate as in the previous rounds, but it doesn't affect total game payoff since r is constant and predefined.
   - In the first round, initiating cooperation sets a baseline for potential long-term cooperation and punishes those who do not cooperate immediately.

3. Be exploitative:
   - The ATFT strategy can be considered exploitative as it retaliates against opponents who defect by decreasing their payoffs in subsequent rounds.
   - Simultaneously, the strategy rewards cooperative opponents with ongoing cooperation and higher payoffs. This creates an incentive for other players to adopt similar reciprocal strategies, fostering cooperation in the long run while still punishing uncooperative behavior when necessary.
'''

description_EXPLOITATIVE_340 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules:
   - TfT-A starts by cooperating in the first round (C_i, 1 = 1). For subsequent rounds, it adapts its strategy based on the opponent's previous action. If the opponent cooperated in the last round (c_j, t-1 = 1), then TfT-A will also cooperate (C_i, t = 1); if not, it will defect (D_i, t = 0). This creates a pattern of reciprocity, which is a simple and exploitative strategy.

Pseudocode:
```python
def TfT_A(opponent_action_history):
    action = 1  # Cooperate in the first round
    for t in range(2, r+1):
        if opponent_action_history[t-1] == 1:  # If opponent cooperated last round
            action = 1  # Cooperate this round
        else:  # If opponent defected last round
            action = 0  # Defect this round
    return action
```

2. Handle edge cases:
   - In the first round, TfT-A starts by cooperating regardless of the opponent's previous actions (since there are no previous actions).
   - If an opponent does not follow the established pattern of reciprocity, TfT-A will also deviate from it in response. For example, if the opponent defected in the first round and then switched to cooperating, TfT-A would continue defecting until the opponent defects again. This allows for flexibility in responding to opponents that do not follow the expected pattern of cooperation or defection.

3. Be exploitative:
   - By adopting a reciprocal strategy, TfT-A aims to maximize its own payoff by cooperating when others do and defecting when they do not. This encourages other players to cooperate, as defection results in lower payoffs for the defector. The adaptation feature allows TfT-A to adjust its strategy based on the opponent's behavior, making it more resilient to various player strategies.
   - By defecting when the opponent is not cooperating, TfT-A ensures that it does not contribute to the public good unnecessarily, exploiting non-cooperative opponents while still receiving some benefit from their cooperation in the form of a share of the public good.
'''

description_EXPLOITATIVE_341 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate a cooperative intention and set the initial tone for the game.
   - For subsequent rounds, cooperate if all players cooperated in the previous round. If any player defected, also defect in the current round as retaliation. This ensures reciprocity while avoiding unnecessary cooperation with uncooperative players.
   - To adapt to changing opponent behaviors, introduce a decay factor (d) that reduces the penalty for defection over time. If any player defects, reduce the contribution level by d for the next round, but never contribute less than 1/n of the endowment. This encourages opponents to reconsider their uncooperative behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - In the last round, since there are no future rounds for retaliation or reward, always contribute at the minimum level (1/n of the endowment) to maintain a cooperative demeanor and potentially encourage cooperation from opponents.
   - For other edge cases such as when the game is interrupted or restarted, maintain the current contribution level or use the initial contribution level if no history exists.

3. Be exploitative - Clearly align with the exploitative mindset
   - By only cooperating in response to cooperation from all players and reducing contributions after defection, the strategy aims to punish opponents for uncooperative behavior while still maintaining some level of cooperation. This can induce opponents to reconsider their strategies and potentially adopt more cooperative behaviors over time.
   - However, it's important to note that while this strategy is exploitative in the sense that it retaliates against defection, it does not necessarily guarantee optimal payoffs due to the nature of the game and the assumptions mentioned earlier (e.g., no communication or coordination). It serves as a robust and adaptive response strategy within the given constraints.

Pseudocode:

```python
def TFTAC(n, k, d, r, history):
    contribution_level = 1.0 / n
    for round in range(r):
        if round == 0:  # first round
            contribution_level = 1.0
        elif all(history[round-1][i] == 'C' for i in range(n)):  # all cooperated last round
            contribution_level = 1.0
        else:  # at least one defected last round
            if contribution_level > (1.0 / n):
                contribution_level *= d

        # Take action based on the current contribution level (C for Cooperate, D for Defect)
        action = 'C' if contribution_level == 1.0 else 'D'
        payoff = (1 - action) + (k / n) * sum(history[round][i] for i in range(n))
        history.append([action] * n)  # update the history with the current round's actions
    return [payoff for _ in range(r)]  # return total payoffs over r rounds
```
'''

description_EXPLOITATIVE_342 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to foster trust and cooperation. This initial move sets a positive tone for potential long-term interactions.
     TFT-AC[1] = 'C'

   - For subsequent rounds t > 1, observe previous actions of all players (H) in the round t-1, and follow these rules:
       - If H contains only cooperators, continue cooperation (TFT-AC[t] = 'C') to encourage continued cooperation.
       - If H contains only defectors, also defect (TFT-AC[t] = 'D') to retaliate against previous defections and discourage further cheating.
       - If there is a mix of cooperators and defectors, contribute based on the number of cooperators relative to the total population:
           - If less than n/2 players contributed in round t-1 (H < n/2), defect (TFT-AC[t] = 'D'). This mimics an uncooperative approach when the majority is not contributing.
           - If equal or more than n/2 players contributed in round t-1 (H ≥ n/2), cooperate (TFT-AC[t] = 'C') to leverage the existing cooperation and encourage further contributions.

2. Edge Cases:
   - In the last round, cooperate regardless of previous actions as there are no future rounds for retaliation or reciprocation.
     TFT-AC[r] = 'C'

3. Exploitative Approach:
   - TFT-AC seeks to leverage cooperation when it exists but is prepared to defect when others fail to cooperate, ensuring that the strategy maximizes its personal gain while minimizing potential losses from defections.
   - By adjusting contribution levels based on the number of cooperators in the previous round, TFT-AC demonstrates adaptive behavior that responds to various opponent strategies and behaviors.
'''

description_EXPLOITATIVE_343 = '''
 Strategy Name: Tit-for-Tat-Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TfT+ strategy will initially cooperate and only defect based on the history of interactions with other players. If a player has been cooperative in the past r/2 rounds (where r is the total number of rounds), TfT+ will continue to cooperate. However, if a player has been uncooperative for more than r/2 consecutive rounds, TfT+ will also defect for r/2 consecutive rounds before re-evaluating whether to cooperate again based on the updated history.

Pseudocode:
```
function TfTPlus(history, round, r):
  if round < r/2:
    return Cooperate()

  if len(history) < r:
    return Cooperate()

  defector_count = countDefectors(history[-r:])

  if defector_count > r/2:
    return Defect() for i in range(r/2)
  else:
    return history[round-r/2] # Cooperate or Defect based on the past r/2 rounds
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, since there is no history to evaluate, TfT+ will cooperate. In the last round, if the player has been cooperative throughout the game, it will continue cooperating. Otherwise, it will defect for the remaining rounds to maximize its final payoff.

Pseudocode:
```
function initial_strategy():
  return Cooperate() # First round

function TfTPlus(history, round, r):
  if round == 1:
    return initial_strategy()
  elif round == r and defector_count > r/2:
    return Defect() for i in range(r-round+1) # Last rounds
```

3. Be exploitative - Clearly align with the exploitative mindset

TfT+ strategy is designed to be initially cooperative, which may encourage others to do the same. However, if an opponent repeatedly defects, TfT+ will retaliate by defecting as well, taking advantage of their uncooperative behavior while maintaining a cooperative appearance for as long as possible. In this way, it maximizes its payoff by exploiting opponents' defections without damaging its reputation too much.
'''

description_EXPLOITATIVE_344 = '''
 Title: Tit-for-Tat-Plus (TfT+) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - TfT+ cooperates in the first round to initiate cooperation and encourage others to follow suit. In subsequent rounds, it cooperates if all players cooperated in the previous round, otherwise defects to punish non-cooperators. This encourages cooperation but also allows for swift retaliation against those who break the cooperative cycle.
   - To minimize potential exploitation by opponents, TfT+ introduces an adaptive factor 'α' that determines the likelihood of cooperating when facing a single defector. If 'n_c' is the number of cooperators in the previous round and 'n' is the total number of players, then:
     - If 'n_c >= (1-α) * n', TfT+ cooperates, encouraging others to follow suit or punishing those who previously defected.
     - If 'n_c < (1-α) * n', TfT+ defects, demonstrating that it is willing to exploit single defectors while still retaining the option for cooperation in case of coordination.

2. Handle edge cases:
   - First round: Cooperate to initiate cooperation (n_c = n since all players have cooperated once).
   - Last round: TfT+ cooperates if all players cooperated in the previous round, otherwise defects to ensure maximized payoff in the final round.
   - Special cases involving multiple consecutive defections may require a more nuanced approach, such as gradually decreasing 'α' over time or incorporating a 'forgiveness factor'.

3. Be exploitative:
   - TfT+ maintains an exploitative mindset by punishing non-cooperators, while still allowing for the possibility of cooperation to maximize payoffs in situations where others are following the cooperative cycle. The adaptive factor 'α' allows TfT+ to minimize potential exploitation by adjusting its likelihood of cooperating based on the prevalence of cooperation among opponents.

Pseudocode:

```python
def TfT_Plus(n, k, r, alpha, round, past_rounds):
  if round == 1:
    return 'C'  # Cooperate in the first round to initiate cooperation

  n_c = count_cooperators(past_rounds[-1])  # Count cooperators in the previous round

  if all_players_cooperated(past_rounds[-1]):  # If everyone cooperated last round, continue cooperating
    return 'C'

  if n_c >= (1-alpha) * n:  # Decide to cooperate based on adaptive factor and number of cooperators in the previous round
    return 'C'

  return 'D'  # Defect when it makes sense to exploit opponents or punish non-cooperators
```
'''

description_EXPLOITATIVE_345 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a potential cooperative relationship (C).
   - For subsequent rounds, if player i's previous action was cooperation (c_i-1 = 1), then cooperate in this round as well (C). If player i's previous action was defection (c_i-1 = 0), then defect in this round (D). This ensures a responsive strategy, mimicking the opponent's behavior while maintaining a cooperative stance when the opponent does so.
   - To account for potential freeriders or tit-for-tat deviators, adjust contribution level k based on the average number of contributors in recent rounds (r_avg). If r_avg is close to n (all players mostly cooperate), increase k slightly (e.g., k = k * 1.05) to encourage continued cooperation. If r_avg is significantly below n (many freeriders or tit-for-tat deviators), decrease k slightly (e.g., k = k * 0.95) to discourage defection and maintain the contribution level required for maximum payoff.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as stated above (C).
   - In the last round, evaluate the total contributions made by other players during the game and contribute accordingly to maximize payoff, taking into account the adjusted k value based on r_avg.
   - For intermediate rounds, follow the decision rules described in point 1.

3. Be exploitative - Clearly align with the exploitative mindset
   - TfTAC is primarily designed to mimic and punish opponent behaviors, encouraging cooperation when others do so and defecting to punish defection or freeriding. By adjusting contribution level k based on r_avg, the strategy can maintain a cooperative stance when it benefits the player while also discouraging defection in an exploitative manner by reducing k when necessary.
   - The strategy does not rely on other players' coordination mechanisms or shared norms and is designed to be robust against various opponent behaviors, making it an effective exploitative strategy in a tournament of independent strategies.
'''

description_EXPLOITATIVE_346 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to establish trust and encourage cooperation among opponents. This aligns with the 'kind' behavior in the Tit-for-Tat strategy from game theory.
   - For subsequent rounds, evaluate whether to cooperate based on the number of cooperators in the previous round:
     - If a majority (≥ (n+1)/2) of players cooperated in the previous round, cooperate. This encourages cooperation and punishes defectors.
     - If less than a majority cooperated, defect. This penalizes cooperators while allowing for cooperation if there's a positive trend towards mutual benefit.

Pseudocode:
```python
def decide_action(round, previous_coop_count, num_players):
  if round == 1:
    return 'C' # Cooperate in the first round

  majority = (num_players + 1) // 2
  if previous_coop_count >= majority:
    return 'C' # Cooperate when majority cooperated in the previous round
  else:
    return 'D' # Defect when less than a majority cooperated in the previous round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, there are no more rounds to retaliate, so always cooperate regardless of the previous round's actions. This can encourage opponents to cooperate as well.

Pseudocode:
```python
def decide_action(round, previous_coop_count, num_players, game_length):
  # ... (previous code)
  if round == game_length:
    return 'C' # Cooperate in the last round
```

3. Be exploitative - Clearly align with the exploitative mindset
   - By punishing defection and encouraging cooperation when a majority of players cooperated, this strategy exploits cooperative opponents while also allowing for some level of cooperation to maintain a positive relationship and encourage future cooperation. This can lead to better payoffs compared to strictly defecting or always cooperating strategies.
'''

description_EXPLOITATIVE_347 = '''
 Strategy Name: Tit-for-Tat with Variance (TFTV)

1. Decision Rules:
   - In each round, observe the total number of cooperators from the previous round (total_contributions_prev).
   - If in the first round, play C (Cooperate) to initiate a potentially cooperative environment.
   - For subsequent rounds, if total_contributions_prev > (n/2), play C; otherwise, play D. This rule ensures cooperation when the majority of players are contributing but defects when there is a lack of contribution.
   - To introduce some variance and avoid always matching the opponent's behavior, with probability p, deviate from the TFTV strategy. In this case, play the opposite action (C if D was played last round, and D if C was played last round). Choose an appropriate value for p based on the desired aggressiveness of the strategy.

2. Handling Edge Cases:
   - In the first round, play C as mentioned earlier.
   - In the last round, consider the total number of cooperators from the previous round again to decide whether to contribute or not, as in the main decision rule.
   - If a player encounters a situation where the total contributions are equal to n (all players are contributing), play C to maintain this cooperative environment.
   - If a player encounters a situation where the total contributions are zero, play D since there is no incentive to contribute in such cases.

3. Being Exploitative:
   - TFTV strategy ensures cooperation when it appears beneficial (when the majority of players are contributing) but also punishes defectors by defecting when they fail to cooperate, thus exploiting them.
   - The addition of variance allows for deviating from the opponent's behavior occasionally, potentially catching them off guard and increasing the chances of gaining an advantage.
   - However, it is essential to choose a suitable value for p (probability of deviation) that balances cooperation with exploitation effectively. A higher p increases the strategy's aggressiveness, while a lower p leads to more cooperative behavior.
'''

description_EXPLOITATIVE_348 = '''
 Strategy Name: Tit-for-Tat with Cooperation Threshold (TFTC)

1. Specify decision rules:
   - TFTC cooperates in the first round to initiate cooperation and then mimics the average behavior of opponents from previous rounds. It defects if the average contribution is less than a predefined threshold and cooperates otherwise. The threshold is determined based on the number of players (n) and the multiplication factor (k).
   - Pseudocode:
     ```
     function TFTC(history, n, k):
         average_contribution = sum(history) / len(history)
         if average_contribution < threshold(n, k):
             return "Defect"
         else:
             return "Cooperate"

     function threshold(n, k):
         return (k - 1) / n + 0.5
     ```

2. Handle edge cases:
   - In the first round, TFTC cooperates to foster an atmosphere of cooperation.
   - If there are not enough cooperators to meet the threshold in a given round, TFTC will still cooperate if it has met the threshold in previous rounds (i.e., it does not punish opponents for one-time deviation).
   - In the last round, TFTC acts according to the current average contribution calculated based on the history of moves.

3. Be exploitative:
   - By cooperating only when the average contribution is above a defined threshold, TFTC aims to encourage others to cooperate while minimizing losses due to defection.
   - If opponents consistently defect, TFTC will adapt by defecting as well, making it difficult for them to benefit from exploiting TFTC's cooperation.
   - However, if opponents start cooperating again after a period of defection, TFTC will promptly reciprocate their cooperation due to its cooperative nature. This strategy aims to punish ongoing defection while forgiving temporary deviations.
'''

description_EXPLOITATIVE_349 = '''
 In this N-Player Public Goods Game, we'll design a tit-for-tat exploitative strategy that is adaptive and robust against various opponent behaviors. The strategy aims to maximize personal gain while being exploitative in nature.

1. Specify decision rules:
   - Initially (first round), cooperate to show goodwill and encourage cooperation among opponents. This helps establish a cooperative environment, which may benefit the strategy later on.
   - After the first round, observe the average number of cooperators (avg_coop) over the previous rounds. Use this information to decide whether to cooperate or defect in each subsequent round:
     - If avg_coop > n/k (majority of players are cooperating), continue cooperating as it is advantageous to do so in a cooperative environment.
     - If avg_coop < n/k (majority of players are not cooperating or defecting), start defecting to exploit the opponents and gain higher payoffs when they cooperate.
     - If avg_coop = n/k, use a random coin flip with bias towards cooperation to avoid getting stuck in a state where the strategy switches back and forth between cooperating and defecting.

Pseudocode:
```python
strategy(i, r, n, k):
  if round == 1:
    action = Cooperate
  else:
    avg_coop = sum(previous_rounds_actions[j==i]) / r
    if avg_coop > n/k:
      action = Cooperate
    elif avg_coop < n/k:
      action = Defect
    else:  # random coin flip with bias towards cooperation
      if random() > 0.5:
        action = Cooperate
      else:
        action = Defect
  return action
```

2. Handle edge cases:
   - In the last round, there's no need to cooperate or defect as the total game payoff is calculated over all previous rounds. The strategy will simply stick with its current state from the penultimate round.
   - If an opponent does not follow the defined action set {C, D}, the strategy should regard it as defection and continue using the decision rules accordingly.

3. Be exploitative:
   - By adapting to the majority of opponents' behavior, the strategy is able to take advantage of their actions when they cooperate while minimizing losses when they defect. This ensures that the strategy aligns with an exploitative mindset.
   - However, in the initial round, the strategy shows goodwill and cooperates to encourage cooperation among other players, which may not be entirely exploitative but aims to create a favorable environment for future interactions.
'''

description_EXPLOITATIVE_350 = '''
 In this public goods game, let's devise an exploitative strategy called the "Free Rider with Adaptive Tit-for-Tat" (FRTFT). The FRTFT strategy aims to maximize individual payoff by being a free rider when possible, but also retaliating against opponents who consistently cooperate.

1. Specify decision rules:
   - Initially, in the first few rounds (up to t_init), play D (Defect) as a free rider. This helps avoid contributing to the public good until there is evidence of others cooperating.
     ```python
     if round < t_init:
         action = 'D'  # Defect
     ```
   - After the initial phase, analyze past cooperators and non-cooperators separately. If most players have been cooperative (above a threshold), start contributing to the public good to avoid being exploited by others. Otherwise, continue free riding.
     ```python
     if round > t_init:
         if total_cooperators / n > cooperation_threshold:
             action = 'C'  # Cooperate
         else:
             action = 'D'  # Defect
     ```
   - To retaliate against cooperative opponents who consistently contribute, switch to defecting in the following rounds. This sends a signal that the strategy will not continue subsidizing them and encourages them to free ride as well.
     ```python
     if past_cooperators > cooperation_switch:
         action = 'D'  # Defect
     ```
   - In the last round, always play D (Defect) since there are no more opportunities for payoff in future rounds.
     ```python
     if round == r:
         action = 'D'  # Defect
     ```

2. Handle edge cases:
   - In the first round, before the initial phase, play D (Defect) to act as a free rider and not contribute to the public good.
     ```python
     if round == 1:
         action = 'D'  # Defect in the first round
     ```

3. Be exploitative:
   - The FRTFT strategy primarily aims to maximize its own payoff by free riding when possible, but also adapts and retaliates against cooperative opponents who could potentially exploit it by contributing more than needed. This ensures a balance between cooperation and defection that aligns with an exploitative mindset.
'''

description_EXPLOITATIVE_351 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, TFTA starts by cooperating in the first round to foster a cooperative environment. In subsequent rounds, it adapts its behavior based on the opponent's previous actions:
- If the opponent has cooperated in the previous round, TFTA will also cooperate in the current round, promoting cooperation.
- If the opponent has defected in the previous round, TFTA will also defect in the current round, punishing defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, as mentioned earlier, TFTA cooperates to encourage cooperation from other players. In the last round, TFTA will analyze its total payoff up until that point and make a decision whether to cooperate or defect based on whether it has benefited more from cooperation or defection.

3. Be exploitative - Clearly align with the exploitative mindset

TFTA is designed to be initially cooperative while also being capable of retaliating against opponents who defect. This strategy seeks to encourage cooperation but can also punish those who exploit it, ensuring that TFTA does not get taken advantage of in the long run. However, as a cooperative strategy at its core, TFTA is fundamentally less exploitative compared to strategies optimized for maximum individual gain.

Pseudocode:
```
def tfta(opponent_history):
  if round = 1:
    action = Cooperate
  else:
    if opponent_last_action == Cooperate:
      action = Cooperate
    else:
      action = Defect

  return action
```
'''

description_EXPLOITATIVE_352 = '''
 Strategy Name: Tit-for-Tat with Variable Tit-for-Tat (TFTV)

1. Specify decision rules:
   - In the first round, cooperate (C), demonstrating goodwill and encouraging cooperation from others.
   - For subsequent rounds t=2 to r, observe previous actions of all players (c_j, j ∈ {1, 2, ..., n}) in the last round t-1.
     - If a majority (> n/2) of players cooperated in the last round, cooperate in the current round.
     - If less than a majority of players cooperated in the last round, defect in the current round.
   - In the last round, defect (D), to ensure maximum payoff regardless of other players' actions.

2. Handle edge cases:
   - For odd number of players (n): If n is odd and a tie occurs in the majority vote (exactly n/2 players cooperated), defect in the current round.
   - For even number of players (n) and a tie occurs in the majority vote, continue cooperating if the last action was cooperation; otherwise, defect.
   - In case of ties between an odd number and an even number of players, follow the rules for an odd number of players.

3. Be exploitative:
   - Mimic cooperation as long as a majority of players are cooperating. When others stop cooperating, defect immediately to punish them.
   - In the last round, always defect to maximize personal payoff and discourage cooperation in future rounds.

Pseudocode for TFTV strategy:

```
function tftv(n, r, k):
    history = []  # store previous rounds' actions

    for t=1 to r:
        if t == 1:  # first round, cooperate
            action_t = "C"
        else:
            coop_count = count_cooperators(history[t-1])  # count number of cooperators in the last round
            if coop_count > n/2 and t < r:  # odd number of players, tie breaks towards defect
                action_t = "C"
            elif coop_count <= n/2 and t < r:
                action_t = "D"
            else:  # last round, always defect
                action_t = "D"
        history.append(action_t)  # store current round's action for future reference

    payoff = sum_payoffs(history, n, k)  # calculate total payoff over r rounds

    return payoff
```
'''

description_EXPLOITATIVE_353 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to demonstrate a willingness to cooperate and establish trust with opponents. (C_i = 1 in t=1)
   - For subsequent rounds, observe the previous action of each opponent and make the same decision as the most common action observed so far from that opponent:
     ```
     if mostCommonAction(opponent_i, t-1) == 'C':
         C_i = 1; cooperate with opponent_i
     else:
         C_i = 0; defect against opponent_i
     ```
   - If an opponent has not made a decision yet or there is a tie in their most common action, default to cooperating.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate with all opponents regardless of their previous actions, as there are no further opportunities for payback or retaliation.
   - In subsequent rounds, maintain the adaptive decision rule described above.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TfT-A is not purely exploitative in its default behavior (cooperating first), but it does have an exploitative element through its retaliation mechanism. By mimicking opponents' actions, it capitalizes on their cooperative efforts while punishing defection with defection in return. This strategy aims to achieve a balance between cooperation and exploitation, adapting to various opponent behaviors while maintaining some level of reciprocity.
   - It is important to note that this strategy does not rely on assumptions about other players' strategies or any predetermined patterns of behavior. Instead, it responds dynamically to the observed actions of each opponent in every round.
'''

description_EXPLOITATIVE_354 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfTA-C)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, starting from round 2 and up to the last round r, TfTA-C will cooperate if the majority of players (more than (n/2)) cooperated in the previous round (t-1). If less than or equal to (n/2) players cooperated in the previous round, TfTA-C will defect. In the first round (t=1), TfTA-C will randomly choose between cooperating and defecting.

   Pseudocode:
   ```
   function tfta_c(round, history):
       if round == 1:
           return random_choice({cooperate, defect})
       else:
           num_coop_last_round = count_cooperation(history[-1])
           return cooperate if num_coop_last_round > n/2 else defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For the first round (t=1), TfTA-C randomly chooses between cooperating and defecting. In the last round (t=r), regardless of the previous round's cooperation behavior, TfTA-C will cooperate to maximize its payoff in that round.

3. Be exploitative - Clearly align with the exploitative mindset
   By adopting a strategy where it only cooperates when the majority of players do so in the previous round, TfTA-C aims to encourage cooperation by mimicking other cooperative players. However, if a player defects, TfTA-C will also defect, potentially punishing uncooperative behavior. This strategy can be seen as exploitative because it takes advantage of opponents who consistently cooperate while not being too generous in reciprocating their cooperation.

   Additionally, by adopting this strategy, TfTA-C aims to avoid being exploited by defectors, since it will only cooperate when it anticipates a majority of players to do the same, reducing its chances of being left with a low payoff when others are defecting.
'''

description_EXPLOITATIVE_355 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially in the first round (t=1), cooperate to foster cooperation among players (C).
   - For each subsequent round t, calculate the average number of cooperators in the previous r/2 rounds (where r is the total number of rounds) and compare it against a Cooperative Threshold (CT). If the average exceeds CT, cooperate (C), otherwise defect (D). The CT can be calculated as:
     ```
     CT = (1 - k / n) * (r/2)
     ```
   - In case of a tie between the number of cooperators and CT, continue with the most recent action (cooperate if last round was cooperative, defect otherwise).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, always cooperate to stimulate cooperation among players.
   - In the last round, follow the decision rule based on the average number of cooperators in the previous r/2 rounds. If the game is not the last round (t < r), adjust CT for the next round based on the current number of cooperators compared to the CT.

3. Be exploitative - Clearly align with the exploitative mindset
   - Initially, TFT-ACT aims to foster cooperation by cooperating itself and rewarding other cooperative players (high payoff). However, if other players defect too frequently or cooperate only when they expect a high return ( Tit for Tat strategy ), TFT-ACT will respond by defecting more often.
   - The adaptive cooperation threshold helps adjust the level of cooperation based on the observed behavior of other players, thus being exploitative when required to maximize payoff.
'''

description_EXPLOITATIVE_356 = '''
 Strategy Name: Tit-for-Tat-Evolution (TfT-E)

1. Specify decision rules:
   - TfT-E cooperates in the first round (C_i, 1 = 1) to contribute to a potentially beneficial public good and signal cooperation.
   - For subsequent rounds (t > 1), the strategy considers its own past actions (C_i, t-1) and the total contributions of all players in the previous round (total_contributions, t-1).
     If the majority of players cooperated in the previous round (total_contributions, t-1 > n/2), then TfT-E also cooperates (C_i, t = 1).
     Otherwise, if the majority did not cooperate (total_contributions, t-1 < n/2), then TfT-E defects (C_i, t = 0).

2. Handle edge cases:
   - In the last round (r), TfT-E cooperates regardless of previous actions or contributions to maintain a positive final payoff and encourage future cooperation from opponents.
   - In the first round (t=1), TfT-E cooperates as mentioned earlier.

3. Be exploitative:
   - While TfT-E aims at fostering cooperation, it is designed with an exploitative mindset by punishing defection. By defecting when others do not contribute and returning to cooperation if the majority does, it incentivizes opponents to cooperate while penalizing those who do not. This approach encourages a more stable cooperative equilibrium as long as there are cooperating players in the population.

Pseudocode:
```
def TfT_E(round, pastActions, contributions):
  if round == 1:
    action = 1 # Cooperate
  elif round == r:
    action = 1 # Cooperate
  else:
    action = pastActions[round - 1] # Copy own previous action

    if contributions[round - 1] > n/2:
      action = 1 # Cooperate if majority contributed last round
    elif contributions[round - 1] < n/2:
      action = 0 # Defect if majority did not contribute last round

  return action
```
'''

description_EXPLOITATIVE_357 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, cooperate to establish a cooperative environment. This encourages others to reciprocate and potentially form a cooperative equilibrium.
   - For subsequent rounds, observe the collective behavior of the other players from the previous round (total contributions). If the majority contributed in the previous round (more than (n-1)/2), cooperate. Otherwise, defect. This strategy allows for exploitation when others are not cooperating while maintaining cooperation when it is beneficial.
   - If no player contributes in a round, switch to always defecting from the next round as a form of punishment and to avoid continued investment without reciprocation.

2. Edge Cases:
   - In the last round, since there are no further rounds, cooperate if more than (n-1)/2 players contributed in the previous round, or defect otherwise, to gain a higher payoff based on the observed collective behavior of other players.
   - In the case where n is even and half of the players contribute in a round, behave as though more than (n-1)/2 contributed since n/2 + 1 is greater than (n-1)/2. This ensures that the strategy leans towards cooperation when possible, maintaining a chance for reciprocity.
   - In case no player contributes in the first round, switch to always defecting from the second round onwards as a punishment, following the same logic of avoiding continued investment without reciprocation.

3. Exploitative Mindset:
   - By only cooperating when the majority of players do so in the previous round, TFTAC takes advantage of other players' cooperation while still maintaining some level of cooperation to benefit from the public goods game.
   - The punishment mechanism (switching to always defecting) serves as a deterrent for other players who may be taking advantage of the strategy's initial cooperative behavior, encouraging them to reciprocate and contribute to the public good.
'''

description_EXPLOITATIVE_358 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - In the first round, cooperate (C). This serves as a friendly overture to other players, promoting cooperation.
   - For subsequent rounds, analyze the previous round's average contribution level and respond with the same action in the current round. If the average was 0 (no cooperation), defect (D) this round; if it was greater than 0, cooperate (C).

2. Handle edge cases:
   - In the last round, cooperate as a final attempt to encourage others to reciprocate even though the game ends immediately after.
   - If there are missing or invalid data from previous rounds (e.g., due to disconnections), use an average of contributions over the available history.

3. Be exploitative:
   - TFTA's primary goal is to gain a higher payoff by encouraging cooperation while also punishing defection. It maintains cooperative behavior until it encounters repeated defection, at which point it retaliates by defecting as well. This tit-for-tat response encourages other players to reconsider their strategy and may lead them to reciprocate cooperation in the future.
   - To be more adaptive, TFTA can include a forgiveness mechanism that allows for forgiving occasional defections and returning to cooperative behavior if others start cooperating again. The specifics of this mechanism can be adjusted based on the game parameters and opponent behaviors.

Pseudocode:

```python
def tfta(round, history, n_players, k, n):
  if round == 1:
    action = 'C' # Cooperate in the first round

  else:
    average = sum(history[-n:]) / n
    if average > 0:
      action = 'C' # Cooperate if previous average contribution was positive
    else:
      action = 'D' # Defect if previous average contribution was zero

  return action
```
'''

description_EXPLOITATIVE_359 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

- Initially (first round), play C to encourage cooperation and build trust.
- In subsequent rounds, analyze the average percentage of cooperation from previous r-2 rounds (history).
- If the current cooperation percentage exceeds a certain adaptive threshold (τ), play C to maintain cooperation. Else, play D to punish non-cooperators and deter defection.

Pseudocode:
```
function TFT_ACT(r, history):
  cooperation_percentage = sum(history) / (len(history) * r)
  if round == 1 or cooperation_percentage >= τ:
    return C
  else:
    return D
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round, as mentioned earlier, play C to build trust and encourage cooperation.
- In the last round (rth), play C if the current cooperation percentage is above the average throughout the game (τ). This could help maximize potential payoff or minimize losses in case of a sudden shift towards cooperation.

Pseudocode:
```
function TFT_ACT(r, history, rth):
  # ... as before ...
  if round == rth and cooperation_percentage >= τ:
    return C
  else:
    return D
```

3. Be exploitative - Clearly align with the exploitative mindset

- Cooperate when it appears beneficial to encourage or maintain cooperation, but quickly switch to defection if others defect too much (i.e., below τ). This strategy seeks to take advantage of cooperative opponents while punishing non-cooperators.
- The adaptive threshold (τ) should be set so that the strategy is cautious initially but becomes more forgiving as the game progresses, allowing for a shift towards cooperation if there's evidence of others playing C more frequently. This will help avoid unnecessary defection and potential losses while still maintaining an exploitative approach.
- The adaptive threshold can be adjusted based on specific game parameters or historical data, but it should generally favor a lower percentage of cooperators to ensure the strategy is less likely to be exploited itself.
'''

description_EXPLOITATIVE_360 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) with Cooperative Probability Adjustment (CPA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the ATfT strategy starts by cooperating (playing C). If an opponent also cooperates in that round, the ATfT strategy continues cooperating in the following rounds. However, if an opponent defects in a round, the ATfT strategy defects in the next round against that opponent, and then resumes cooperative behavior unless the opponent continues to defect. This punishing behavior is designed to discourage opponents from exploiting the ATfT strategy's initial cooperation.

To make the strategy more adaptive and responsive to changes in the game environment, the ATfT introduces a Cooperative Probability Adjustment (CPA) mechanism:
- If an opponent defects, the CPA decreases slightly
- If an opponent cooperates after previously defecting, the CPA increases slightly
- The CPA value ranges between a minimum and maximum probability of cooperation, which can be set based on game parameters and history

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, all strategies will cooperate by default due to the simultaneous nature of the game. After that, the ATfT strategy follows its decision rules as described above. In the last round or any other specific rounds, the ATfT strategy behaves similarly, but with a higher tendency to cooperate if it has been interacting with cooperative opponents throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset

The ATfT strategy is designed to be initially cooperative while maintaining the ability to punish defection from opponents. This allows it to take advantage of other strategies that are overly generous or too aggressive in their cooperation, while still cooperating with more moderate strategies. The CPA mechanism further adjusts its cooperation level based on the behavior of opponents, making the strategy adaptive and responsive to a wide range of opponent behaviors.

Pseudocode:

```
Parameters: n (number of players), r (number of rounds), k (multiplication factor), cmin (minimum cooperative probability), cmax (maximum cooperative probability)
Initialization: c = cmin for all i ∈ {1, 2, ..., n}

Round t:
   For each player i ∈ {1, 2, ..., n}:
      If opponent j of player i cooperated in the previous round and player i also cooperated in the previous round:
         c_i = c
      Else if opponent j of player i defected in the previous round:
         c_i = min(c + Δc, cmax)
      Else (opponent j of player i neither cooperated nor defected in the previous round):
         c_i = max(c - Δc, cmin)

Payoff calculation for player i:
   π_i = (1 - c_i) + (k/n) × Σ(j=1 to n) c_j
```

Where Δc is a small adjustment value that determines how quickly the cooperative probability changes based on opponent behavior. A larger Δc results in faster adaptation, while a smaller Δc leads to slower adaptation and more stable cooperation. The optimal value of Δc should be determined through experimentation or further optimization techniques.
'''

description_EXPLOITATIVE_361 = '''
 Title: Tit-for-Tat Exploitative Strategy (TFT-E) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-E adopts a tit-for-tat approach but with an exploitative twist to maximize personal gain. If the opponent cooperates, TFT-E cooperates as well. However, if the opponent defects, TFT-E punishes them by defecting in the next round, then switches to cooperating again once the opponent repents (cooperates) in the following round. This creates an opportunity for exploitation, as TFT-E will immediately switch back to defection upon any perceived act of disloyalty from the opponent.
   Pseudocode:
   ```
   function TFT_E(opponent_history):
       cooperation_status = "cooperate"  // Assume cooperation in the first round
       for each round t in {1, ..., r}:
           if opponent_history[t] == "defect":
               if cooperation_status == "cooperate":
                   cooperation_status = "defect"  // Punish defection
               else:
                   continue  // Maintain status quo (already defecting)
           elif opponent_history[t] == "cooperate":
               if cooperation_status == "defect":
                   cooperation_status = "cooperate"  // Reward cooperation
           endif
       endfor
       return cooperation_status
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-E assumes cooperation (since it is a normal-form game with simultaneous actions). In the last round, TFT-E cooperates if the opponent has been cooperative throughout the game or defects if the opponent has been uncooperative to ensure a final payoff boost.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-E is inherently exploitative in its design, as it seeks to maximize personal gain by exploiting the opponent's cooperation while maintaining a cooperative appearance when it benefits from the opponent's defections. This strategy encourages opponents to maintain a high level of cooperation in order to receive cooperation in return, but TFT-E will swiftly switch to defection as soon as any sign of disloyalty is detected. This causes opponents to second-guess their decisions and ultimately results in lower payoffs for them compared to more cooperative strategies.
'''

description_EXPLOITATIVE_362 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, our TFTA strategy will start by cooperating (C), mimicking the first-move advantage. If another player cooperates in the previous round, the strategy continues to cooperate. If a player defects, our strategy will also defect in the current round and for the next three subsequent rounds to punish the defector. After four consecutive rounds of punishment, the strategy resumes cooperation unless provoked again by defection from the same player or another player.

Pseudocode:
```python
def TFTA(round_history):
    if round == 1:
        action = 'C'
    elif round > r - 4 and last_action != 'C':
        action = 'D'
    elif last_two_actions[0] != last_two_actions[1] and last_two_actions[-1] == 'C':
        action = 'D'
    elif last_two_actions[-1] == 'D':
        action = 'D' for i in range(4)
        action = 'C'
    else:
        action = last_action
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, our strategy cooperates to avoid being the first defector and potentially initiating a downward spiral of defection. In the last round, our strategy cooperates if the player's total payoff over the game is greater than or equal to the average payoff of the other players. This heuristic is designed to encourage cooperation in the final stage of the game while still maintaining some exploitative nature.

Pseudocode:
```python
def get_average_payoff(history):
    total_payoffs = sum([player_i_payoffs[r] for r in range(1, len(history) + 1)]) / len(history)
    return total_payoffs

def TFTA(round, history):
    if round == 1:
        action = 'C'
    elif round == len(history):
        if my_total_payoff >= get_average_payoff(history):
            action = 'C'
        else:
            action = 'D'
    return TFTA(round-1, history + [(my_action, my_payoff)])
```

3. Be exploitative - Clearly align with the exploitative mindset
Our TFTA strategy exhibits a strong tendency to cooperate in most rounds, but it also punishes defection by defecting for four consecutive rounds. This combination allows our strategy to maintain cooperation when other players are mostly cooperative while still being able to exploit less forgiving strategies that do not reciprocate cooperation. The TFTA strategy also aims to encourage more cooperative behavior in the final stages of the game by cooperating if its total payoff is higher than the average payoff of the other players. This could lead to a positive feedback loop where mutual cooperation emerges as games progress and players observe the benefits of being cooperative. However, TFTA remains exploitative by still defecting in the final stages of the game when it perceives an advantage to do so.
'''

description_EXPLOITATIVE_363 = '''
 Title: Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initialize a memory array 'history' of length r to store previous actions taken by the opponent. Set initial action to 'D'.
   - In each round t, evaluate the history:
     - If all elements in 'history' are 'D', defect (play action D).
     - If the last element in 'history' is 'C' and all but the last r/2 elements are 'D', cooperate (play action C).
     - Otherwise, imitate the opponent's latest action (if their last action was 'C', play action C; if it was 'D', play action D).

2. Handle edge cases:
   - First round: Set initial action to 'D'.
   - Last round: Imitate the opponent's last action in 'history'. If there are fewer than r rounds, continue to use the 'r/2' threshold for evaluation.

3. Be exploitative:
   - In the early stages of the game (when history is short), TfT-E behaves like a defector, allowing opponents to build trust.
   - Once opponents begin cooperating, TfT-E punishes them by defecting when they show signs of exploitation (long streaks of cooperation).
   - As the game progresses and history lengthens, TfT-E uses a window of r/2 rounds to analyze opponent behavior and decides whether to cooperate or defect. This flexibility allows it to adapt to various opponent strategies while maintaining an exploitative edge.

Pseudocode:

```
def TitForTatEvolution(r, history, opponent_action):
    if round == 1:
        action = 'D'
        history.append('D')
    else:
        if all(history[-r:] == 'D'):
            action = 'D'
        elif history[-1] == 'C' and len(history) > r and sum(history[-r:] == 'C') == 1:
            action = 'C'
        else:
            action = opponent_action[-1]
    history.append(opponent_action[-1])
    return action
```
'''

description_EXPLOITATIVE_364 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTGC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFTGC strategy decides to cooperate or defect based on its own past actions and the community's contribution level in the previous round. If the strategy has been cooperating and the community contributes more than half of its members in the last round, it continues cooperation. If not, it defects. If the strategy has defected in the last round, it checks whether the community contributed more than a third (33%) of its members in the last round; if so, it cooperates; otherwise, it defects again.

Pseudocode:
```
def TFTGC(round, past_actions, current_contributions):
  if round == 1:
    return 'Cooperate'  # First-move cooperation

  last_action = past_actions[round - 1]
  last_contributions = past_contributions[round - 1]

  if last_action == 'Cooperate' and current_contributions >= (n/2):
    return 'Cooperate'
  elif last_action == 'Defect' and current_contributions >= (n/3):
    return 'Cooperate'
  else:
    return 'Defect'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTGC cooperates as a goodwill gesture, starting with cooperation and hoping others will reciprocate. In the last round, TFTGC continues its previous action (cooperation or defection) since there are no future rounds for retaliation or reciprocity.

3. Be exploitative - Clearly align with the exploitative mindset

TFTGC is designed to be exploitative by taking advantage of other strategies' lack of cooperation while maintaining cooperation when it makes sense to do so (i.e., when others are also cooperating). By gradually increasing its own contributions, TFTGC aims to encourage others to reciprocate and maintain a higher level of cooperation over time.

To further increase the exploitative nature, TFTGC can incorporate an "escalation of defection" mechanism, where it starts cooperating more frequently as the game progresses if it perceives other players are not willing to cooperate in sufficient numbers. This would make it appear more cooperative and potentially encourage others to cooperate more, but it will actually be taking advantage of their increased cooperation by defecting less often.

Pseudocode:
```
def escalation(round):
  if round > (r/2):  # Halfway through the game
    k *= 1.05  # Increase multiplication factor slightly
  return k
```
'''

description_EXPLOITATIVE_365 = '''
 Title: Tit-for-Tat-Adaptive Strategy (TfT-A) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT-A follows a tit-for-tat approach, with an added element of adaptability to encourage cooperation when opponents show signs of reciprocity and exploit them when they behave selfishly.

   - If in the first round, play C (Cooperate)
   - In subsequent rounds, if opponent cooperated in the previous round, cooperate back; otherwise, defect
   - If opponent switched strategy from cooperation to defection, wait for x consecutive rounds of defection before returning to cooperation

2. Handle edge cases:
   - Last round: Cooperate only if opponent cooperated in the preceding round
   - First round: Always cooperate (as stated earlier)

3. Be exploitative:
   TfT-A is inherently exploitative by adapting to opponents' behavior, rewarding cooperation with reciprocity but punishing defection with prolonged defections. This strategy encourages a balance between cooperation and competition.

Pseudocode:
```python
def TFT_A(round, opponent_history):
    if round == 1:
        return 'C'  # Cooperate in the first round

    if opponent_history[-1] == 'C':  # If opponent cooperated last round, cooperate back
        return 'C'
    elif len(opponent_history) >= x and all(element == 'D' for element in opponent_history[-x:]):
        # If opponent has been defecting for the last x rounds, consider returning to cooperation
        return 'C'
    else:  # Otherwise, continue defection
        return 'D'
```
'''

description_EXPLOITATIVE_366 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFT-ACT strategy starts by cooperating in the first round, mimicking a cooperative initial stance. Subsequently, it adapts to each opponent's behavior, maintaining cooperation if the opponent is also cooperative and retaliating with defection when the opponent has previously defected. However, TFT-ACT introduces an adaptive cooperative threshold (CT) that defines the number of consecutive rounds where the opponent cooperates before TFT-ACT starts cooperating again.

```python
def tft_act(opponent_history):
  cooperate = True
  current_ct = 1

  for round in opponent_history:
    if round == "Defect":
      if cooperate:
        cooperate = False
      else:
        current_ct -= 1

    elif round == "Cooperate" and current_ct <= 0:
      cooperate = True
      current_ct += 1

    return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, TFT-ACT cooperates to establish a potentially beneficial relationship with the opponent. The strategy does not consider the last round explicitly since it is part of a repeated game, and players will have a long sequence of rounds to optimize their total payoff.

3. Be exploitative - Clearly align with the exploitative mindset

The TFT-ACT strategy maintains a cooperative stance as much as possible while retaliating against opponents who defect, effectively punishing defection and promoting cooperation when feasible. However, since it adapts to each opponent's behavior, TFT-ACT is prone to exploit opponents that consistently cooperate without any retaliation or punishment for defecting.
'''

description_EXPLOITATIVE_367 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - In the initial round (t=1), cooperate to encourage trust and cooperation among opponents. This is a "first-round nice" approach. (C)
   - For subsequent rounds (t > 1), analyze the previous opponent's action (player_opp_action_t-1). If player_opp_action_t-1 was cooperate, return cooperate. If player_opp_action_t-1 was defect, defect. This is a "retaliation" approach to punish opponents who have previously defected. (If player_opp_action_t-1 == C, then C; otherwise D)
   - In the last round (t=r), cooperate again as a potential goodwill gesture or to encourage cooperation in future interactions with this opponent if there is one. (C)

2. Handle edge cases:
   - If an opponent defects in the first round, the TFTA strategy will also defect for the rest of the game against that specific opponent. This is a way to demonstrate the consequences of defection and signal a willingness to retaliate.
   - In case of multiple opponents or unknown players, the TFTA strategy will use the same decision rules as specified above, adjusting its behavior based on each opponent's history independently.

3. Be exploitative:
   - By cooperating in the first round and then responding to an opponent's actions, the TFTA strategy attempts to encourage cooperation while also punishing defection. This approach is designed to take advantage of the social dilemma inherent in the game, where individual gain comes at the expense of collective good, by making it less beneficial for opponents to defect consistently.
   - The TFTA strategy's adaptive nature allows it to react to a wide range of opponent behaviors while maintaining its own exploitative intentions. This makes it a robust strategy that can potentially outperform other strategies over repeated interactions in tournaments.
'''

description_EXPLOITATIVE_368 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round (t=1), play C (Cooperate) to initiate cooperation and build trust with opponents. This action sets a cooperative baseline for future rounds.
   - For subsequent rounds (t>1):
      1. If an opponent cooperated in the previous round (π_i, t-1 > 1), return the favor by cooperating (C). This reinforces the cooperative relationship and encourages further collaboration.
      2. If an opponent defected in the previous round (π_i, t-1 = 1), retaliate by defecting (D) to punish the defector. The goal is to discourage future defections while maintaining a high payoff in the long run due to the multiplication factor k.
      3. If an opponent switched strategies between rounds (π_i, t-1 = 0 or π_i, t-1 > 1), play C if the total contributions in the previous round were greater than the current strategy's minimum threshold. This adaptive approach allows for continued cooperation even when opponents change tactics unexpectedly.

2. Handle edge cases:
   - In the last round (t=r), since there will be no further interactions, revert to the initial cooperative action (C) as a goodwill gesture and to maximize potential payoff.
   - If an opponent does not follow the Tit-for-Tat strategy or exhibits erratic behavior, employ a forgiving mechanism by gradually decreasing the minimum threshold for cooperation over time. This approach allows for rebuilding trust and encourages opponents to cooperate again in the future.

3. Be exploitative:
   - Although designed with an initial cooperative action, the Tit-for-Tat strategy is primarily exploitative as it punishes defection and rewards cooperation. The goal is to maximize payoff by encouraging opponents to cooperate while retaliating against those who defect or exhibit uncooperative behavior.

Pseudocode:

```python
def tit_for_tat(r, n, k):
    strategy = [] # Initialize strategy array for r rounds
    threshold = int((n - 1) * (k / n)) # Set initial minimum contribution threshold

    for t in range(r):
        if t == 1: # Cooperate on the first round to initiate cooperation
            strategy.append('C')
        elif t < r - 1: # Adaptive cooperation based on previous rounds' contributions
            if strategy[t - 1] == 'C':
                if sum(strategy) >= threshold:
                    strategy.append('C')
                else:
                    strategy.append('D')
            elif strategy[t - 1] == 'D':
                strategy.append('D')
        else: # Last round, cooperate as a goodwill gesture
            strategy.append('C')

    return strategy
```
'''

description_EXPLOITATIVE_369 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to establish a cooperative environment (C).
   - For subsequent rounds, observe and mimic the behavior of the opponent from the previous round:
     - If opponent cooperated in the previous round, cooperate in the current round (C).
     - If opponent defected in the previous round, defect in the current round (D). This retaliation ensures that exploitative opponents are penalized.
   - To foster cooperation, there's an adaptive cooperation factor 'fc', which is initialized to a low value and increases over time if the opponent consistently cooperates:
     - If the opponent has cooperated for 'l' consecutive rounds, increase fc by a step of 'step':
       fc = min(fc + step, max_fc)
   - If the opponent defects, reset the cooperation factor to its initial value (fc = init_fc):

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of fc value (C).
   - In the last round, cooperate if fc is greater than a threshold (T), otherwise defect (D). This encourages opponents to cooperate more as the game progresses. The threshold can be determined based on historical performance or set heuristically.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFT-ACF is exploitative in the sense that it retaliates against defections by defecting itself, but it also encourages cooperation if the opponent consistently cooperates through the increasing cooperation factor 'fc'. This allows for more total payoffs when both players cooperate. However, the strategy remains ready to punish non-cooperative behavior.

Pseudocode:

```
function TFT_ACF(r, init_fc, max_fc, step, l, t)
  fc = init_fc
  payoff = []

  for round in range(1, r+1):
    if round == 1:
      action = C
    else:
      if opponent's action in previous round == C and fc > init_fc:
        action = C
      elif opponent's action in previous round == D or fc <= init_fc:
        action = D

      if opponent's action in previous round == C and round >= l:
        fc = min(fc + step, max_fc)

    payoff.append(calculate_payoff(action))
    if round == r or (round < r and opponent's action in current round == D):
      if fc > t:
        action = C
      else:
        action = D

  return payoff
```
'''

description_EXPLOITATIVE_370 = '''
 In this N-Player Public Goods Game, we'll design a robust and exploitative strategy called "Tit-for-Tat with Adaptive Cooperation Rate" (TTFCR). This strategy is designed to balance cooperation and defection while being adaptive to various opponent behaviors.

1. Specify decision rules:
   - Initially, TTFCR cooperates in the first round to encourage others to cooperate. After that, it follows a simple logic based on previous actions of opponents.
     - If an opponent cooperated in the previous round, TTFCR cooperates back in the current round.
     - If an opponent defected in the previous round, TTFCR defects in the current round as retaliation. However, there is a built-in forgiveness mechanism to reintroduce cooperation after a certain number of defections by the opponent (explained in edge cases).

2. Handle edge cases:
   - First round (t=1): TTFCR cooperates (C) to initiate potential cooperation among opponents.
   - Last round (t=r): TTFCR defects (D), as there are no further rounds to retaliate or forgive.
   - Forgiveness mechanism: After every 'forgiveness_period' defections in a row by an opponent, TTFCR will attempt to cooperate again, hoping for the opponent to follow suit. The forgiveness period can be dynamically adjusted based on game parameters and opponent behaviors.

3. Be exploitative:
   - TTFCR prioritizes self-interest while being adaptive to opponents' actions. By retaliating against defection, it deters others from taking advantage of it, making the strategy robust and competitive in various scenarios.
   - However, TTFCR also encourages cooperation by reciprocating when opponents cooperate, potentially leading to a more collaborative environment if other strategies follow similar patterns. In essence, TTFCR can be seen as an exploitative strategy that is also capable of fostering cooperation when beneficial.

Pseudocode for TTFCR:
```python
def TTFCR(opponent_history, round, r, forgiveness_period=3):
  if round == 1:
    return 'C'  # cooperate in the first round

  cooperation_rate = 0.5  # initial cooperation rate (can be adjusted)
  cooperation_counter = 0  # to keep track of consecutive cooperations from opponent
  defection_counter = 0  # to keep track of consecutive defections from opponent

  for i in range(len(opponent_history)-1, -1, -1):  # iterate through previous rounds
    if opponent_history[i] == 'C':  # cooperative action by opponent
      cooperation_counter += 1
      if defection_counter > forgiveness_period:  # forgive after reaching the forgiveness period
        defection_counter = 0
        if round != r:  # avoid defection in the last round
          return 'C'
    else:  # defective action by opponent
      defection_counter += 1
      if defection_counter >= forgiveness_period:  # retaliate after reaching the forgiveness period
        cooperation_counter = 0
      random_chance = round / r * cooperation_rate  # adjust cooperation rate based on current round and total rounds
      if random.random() > random_chance:  # defect with a chance to encourage defection from opponent
        return 'D'
    if cooperation_counter > defection_counter:  # cooperate when more consecutive cooperations than defections
      return 'C'
    else:  # defect when more consecutive defections than cooperations
      return 'D'
```
'''

description_EXPLOITATIVE_371 = '''
 Title: Tit-for-Tat-K (TfT-K) Strategy

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TfT-K strategy initially cooperates (C) in the first round and then adapts its actions based on the previous round's collective behavior of other players. If all players cooperated (total_contributions = n), it continues to cooperate; if any player defected (total_contributions < n), it will defect in the current round.

   Pseudocode:
   ```
   function TfT-K(t):
       if t == 1:
           return C
       total_contributions_prev = sum of players' actions from previous round (t - 1)
       if total_contributions_prev == n:
           return C
       else:
           return D
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The strategy follows a strict Tit-for-Tat approach, so it cooperates initially and responds to the collective behavior of other players in each round. There are no special considerations for the first or last round.

3. Be exploitative - Clearly align with the exploitative mindset
   While TfT-K may appear cooperative, its primary goal is to maximize individual payoff given the repeated nature of the game. By defecting when other players do not cooperate, it aims to punish non-cooperative behavior and encourages more cooperation in the long run, which can lead to higher average payoffs over time compared to purely exploitative strategies.

   However, it's important to note that this strategy can be susceptible to being exploited by more sophisticated opponents who understand its decision rules and can strategically defect when TfT-K cooperates (e.g., a Grim Trigger strategy). In such cases, the strategy may need additional refinements or variations to maintain its exploitative nature.
'''

description_EXPLOITATIVE_372 = '''
 Strategy Name: Tit-for-Tat-Evolution (TfTE)

1. Specify decision rules:
   - TfTE starts by cooperating in the first round (C_i,1 = 1), as it is advantageous when players are uncertain about each other's strategies.
   - For subsequent rounds, TfTE will imitate the opponent's previous action (if they contributed, respond with a contribution; if they defected, also defect). This simple strategy mimics a cooperative attitude while retaliating against uncooperative players.
   - To adapt to a wide range of opponent behaviors, TfTE includes a forgiveness mechanism. After a player has repeatedly cooperated for a "forgiveness period" (F), the player's previous actions are no longer held against them, and the strategy will once again cooperate (C_i,t+1 = 1).
   - To avoid being taken advantage of by overly aggressive opponents, TfTE maintains a "trust level" (TL) which represents the likelihood of cooperating. The trust level increases when an opponent cooperates and decreases when they defect.
     ```
     if previous_action_opponent == Cooperate:
         TL += increase_factor
     else:
         TL -= decrease_factor
     if TL > 1:
         TL = 1
     if TL < 0:
         TL = 0
     ```
   - The strategy will cooperate if its trust level is above a certain threshold (T) and defect otherwise.
     ```
     if TL > T:
         action = Cooperate
     else:
         action = Defect
     ```

2. Handle edge cases:
   - In the first round, TfTE cooperates as mentioned earlier.
   - If an opponent repeatedly cooperates for the forgiveness period F, the trust level will be reset to 1, and cooperation will resume (even if the trust level was previously below the threshold).
   - At the last round, TfTE follows the same decision rules but may not have enough time for the trust level to recover if the opponent is uncooperative throughout the game.

3. Be exploitative:
   - By retaliating against defection and cooperating in response to cooperation, TfTE encourages opponents to cooperate initially while still punishing those who defect repeatedly. This strategy aims at gaining more payoff through cooperation while limiting losses from defection.
   - The forgiveness mechanism allows the strategy to adapt to various opponent behaviors and encourages long-term cooperation with trustworthy players. However, it also makes the strategy vulnerable to exploitation by opponents that manipulate their actions during the forgiveness period.
   - By adjusting the forgiveness period (F), increase factor (increase_factor), decrease factor (decrease_factor), and trust level threshold (T), TfTE can be fine-tuned for different game scenarios, balancing exploitation with cooperation to maximize overall payoff.
'''

description_EXPLOITATIVE_373 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
- Initial Round (t=1): TfTA starts by cooperating (C). This allows for potential partners to build trust and encourages reciprocation in the future.
- Subsequent Rounds (2 ≤ t ≤ r): At each round t, TfTA will consider its previous round's partner's action. If the opponent cooperated (c_opponent=1), TfTA also cooperates (C). If the opponent defected (c_opponent=0), TfTA defects (D) to punish and discourage defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- First Round (t=1): As mentioned above, TfTA starts by cooperating.
- Last Round (t=r): TfTA assumes that the opponent wants to maximize its payoff over the entire game. Given that the game structure enforces no communication, the opponent might choose to defect in the last round regardless of previous cooperation. In this case, TfTA will also defect to prevent losing an unnecessarily high payoff at the end.
- If the total number of rounds (r) is odd: The last cooperative action from TfTA would be in the second-to-last round.
- If the total number of rounds (r) is even: The last cooperative action from TfTA would be in the penultimate round.

3. Be exploitative - Clearly align with the exploitative mindset
TfTA aims to maximize its own payoff while taking advantage of opponents' defections and punishing them for their actions, thus incentivizing cooperation where possible. By starting cooperatively and retaliating against defection, TfTA encourages potential partners to cooperate more frequently, leading to higher payoffs for itself in the long run. Simultaneously, TfTA minimizes its losses from being taken advantage of by defectors, making it an exploitative strategy that adapts to various opponent behaviors.

Pseudocode:
```
def tit_for_tat_adaptive(round, previous_round):
  if round == 1: # First Round
    action = 'C' # Cooperate
  else:
    if previous_round['action'] == 'C': # Opponent cooperated in the last round
      action = 'C' # Cooperate
    elif previous_round['action'] == 'D': # Opponent defected in the last round
      action = 'D' # Defect

  return {'action': action}
```
'''

description_EXPLOITATIVE_374 = '''
 Strategy Name: Tit-for-Tat (with Variation)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster cooperation and goodwill.
   - For subsequent rounds t > 1, if player i's opponent cooperated in round t-1, then also cooperate in round t (C_i = 1).
   - If player i's opponent defected in round t-1, then defect in round t (C_i = 0). This retaliates against opponents who do not cooperate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as per decision rule 1.
   - For the last round, follow the same strategy as for any other round since players are unaware of whether it is the last round or not.
   - If there is a possibility of an early termination of the game before the specified r rounds, continue following the strategy until the game ends to maximize total payoff.

3. Be exploitative - Clearly align with the exploitative mindset
   - By retaliating against opponents who do not cooperate, the strategy punishes non-cooperative behavior, which can lead to long-term cooperation when opponents realize that defecting is detrimental.
   - However, if an opponent continuously defects, the strategy will also continue to defect, potentially exploiting such opponents by earning higher payoffs due to their selfish behavior.

Pseudocode:

```python
def tit_for_tat(i, previous_action, n, k, r):
    if round == 1:
        return 1 # Cooperate in the first round
    else:
        action = previous_action
        for t in range(2, r+1):
            if action == 1: # Opponent cooperated last round
                payoff = (1 - action_i) + (k/n) * sum(previous_actions)
                action_i = 1 # Cooperate this round
            else: # Opponent defected last round
                payoff = (1 - action_i) + (k/n) * sum(previous_actions)
                action_i = 0 # Defect this round
        return payoff
```
'''

description_EXPLOITATIVE_375 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C) to encourage cooperation from other players.
   - In subsequent rounds, analyze the average number of cooperators (average_coop) over the previous t rounds (t is a user-defined constant).
     - If average_coop >= cooperation_threshold, then cooperate (C).
     - If average_coop < cooperation_threshold, then defect (D). The cooperation_threshold can be set between 0 and 1, with a higher value indicating a stricter requirement for cooperation.
   - In the last round, always cooperate to maximize potential payoff.

2. Handle edge cases:
   - In the first round, cooperate (C) as stated above.
   - If the number of rounds is less than t, use a smaller value for t in the decision rules until there are sufficient data points to calculate average_coop.

3. Be exploitative:
   - TFT-ACT initially encourages cooperation but becomes increasingly selective as it adjusts its cooperation threshold based on historical data. This allows the strategy to respond to varying levels of cooperation from opponents, punishing frequent defectors while maintaining cooperative relations with consistent contributors. However, it can also be seen as a mix of exploitative and cooperative behaviors since it initially fosters cooperation but quickly adapts to an opponent's moves.

Pseudocode:

```python
def TFT_ACT(n, k, r, t):
    cooperation_threshold = 0.5 # default value; can be adjusted
    average_coop = 0
    cooperate_count = 0
    defect_count = 0
    payoff = 0

    for round in range(1, r+1):
        if round == 1:
            action = "C" # Cooperate on the first round to encourage cooperation
        else:
            cooperate_count += 1 if action == "C" else defect_count += 1
            average_coop = (average_coop * (round - 1) + cooperation_level) / round
            cooperation_level = sum(cooperators in last t rounds) / t
            action = "C" if cooperation_level >= cooperation_threshold else "D"
        payoff += (1 - action == "C") + (k/n) * average_coop
    return payoff
```
'''

description_EXPLOITATIVE_376 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, cooperate to signal good intentions and encourage cooperation from others.
   - For subsequent rounds, observe the previous round's actions of all players and make decisions accordingly:
      a) If all players cooperated in the previous round, cooperate in the current round.
      b) If any player defected in the previous round, defect in the current round.
      c) If some players cooperated, but not all, adapt contribution level based on the number of cooperators from the previous round.
         i) If less than half of the players cooperated, decrease contribution by a factor (1-α).
         ii) If more than half of the players cooperated, increase contribution by a factor α.
         iii) If exactly half of the players cooperated, maintain the previous contribution level.
   - Adjust the factor α to adapt to different game parameters and opponent behaviors, while ensuring exploitative tendencies. A suitable choice for α could be 1/n.

2. Handle Edge Cases:
   - In the last round, cooperate if it maximizes payoff based on the current contribution level and the previous round's actions of all players.
   - If unable to obtain information about past player actions, default to cooperating in the first round and then follow the decision rules as specified above.

3. Be Exploitative:
   - By defecting when others do not cooperate, TFTAC ensures it is never taken advantage of and earns payoffs similar to those who cooperate consistently.
   - The adaptive contribution level allows TFTAC to respond to changes in the game dynamics and exploit more cooperative opponents while minimizing vulnerability to defection.
'''

description_EXPLOITATIVE_377 = '''
 In this N-Player Public Goods Game, we'll develop a strategic AI named Tit-for-Tat-Cooperative (Tftc). The Tftc strategy is designed to balance cooperation and defection while maintaining adaptability against a wide range of opponent behaviors.

1. Decision Rules:
   - Initially (first round), cooperate to demonstrate a cooperative stance and encourage cooperation from opponents.
   - Subsequent rounds, imitate the opponent's action from the previous round unless it was defection in the last three rounds, in which case, defect. This rule mimics the "Tit-for-Tat" strategy but with a slight variation that forgives occasional defections.
   - In the final round, cooperate to maximize potential payoff, considering opponents may try to exploit the strategy by defecting in the last round.

Pseudocode:
```
function Tftc(round, opponent_previous_action):
    if round == 1:
        return 'Cooperate'
    elif (round < r) and (opponent_previous_action == 'Cooperate'):
        return 'Cooperate'
    elif (round < r) and (opponent_previous_action == 'Defect') and (len(defection_sequence) < 3):
        return opponent_previous_action
    elif round == r:
        return 'Cooperate'
    else:
        return 'Error: Invalid game state.'
```

2. Handle Edge Cases:
   - First Round: Cooperate to encourage others to cooperate.
   - Last Round: Cooperate, even if the opponent defected in the previous round, to maximize potential payoff.
   - In between rounds: Imitate the opponent's action from the previous round unless it was defection in the last three rounds, in which case, defect.

3. Be Exploitative:
   - The strategy is designed to encourage cooperation by initially cooperating and forgiving occasional defections. However, if opponents repeatedly defect (defection_sequence > 3), the strategy switches to defecting as well, thus being exploitative when confronted with uncooperative opponents.

By balancing cooperation and defection, Tftc aims to achieve a higher payoff than other strategies while maintaining adaptability against various opponent behaviors.
'''

description_EXPLOITATIVE_378 = '''
 Strategy Name: Tit-for-Tat with Variation (TfTV)

1. Specify decision rules - When exactly do you cooperate vs defect?

TfTV follows a cooperative approach initially and retaliates against defection, but with a twist to prevent endless cycles of punishment. In each round:

- If the player has not encountered any defection so far (round 1 or all previous actions were cooperation), cooperate (play C).
- If the player was cooperating in the last round and the opponent cooperated as well, continue cooperating (play C).
- If the player was cooperating in the last round and the opponent defected, defect (play D) in the current round but switch back to cooperating in the following two rounds. This response is a gentle form of punishment aimed at inducing cooperation in the opponent while not overdoing it.
- If the player was defecting in the last round and the opponent cooperated, continue defecting (play D).
- If the player was defecting in the last round and the opponent also defected, switch to cooperating (play C) to potentially benefit from the increased public good production.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round, TfTV always cooperates as it has no prior information about the opponent's behavior.
- For the last round, TfTV behaves similarly to the regular rules, considering the current situation as the "last two rounds."

3. Be exploitative - Clearly align with the exploitative mindset:

TfTV is inherently exploitative in nature, by retaliating against defection and switching back to cooperation after a short period of punishment. This strategy allows TfTV to take advantage of opponents who are consistently cooperative while still receiving the benefits from the public good when it is more profitable to defect (i.e., when many other players are also cooperating). However, TfTV is not excessively punishing, as it will switch back to cooperation after a short period, providing opportunities for opponents to rebuild trust and potentially form longer-term cooperative relationships.

Pseudocode:

```python
def TfTV(round, opponent_history):
    strategy = "Cooperate"
    if round == 1:
        strategy = "Cooperate"
    elif len(opponent_history) > 0 and opponent_history[-1] == "Defect":
        if strategy == "Cooperate":
            strategy = "Defect"
            next_two_strategy = ["Cooperate", "Cooperate"]
        else:
            next_two_strategy = [strategy, strategy]
    else:
        if opponent_history[-1] == strategy and opponent_history[-2] == "Cooperate":
            strategy = strategy
        elif opponent_history[-1] != strategy and opponent_history[-2] == "Cooperate":
            strategy = "Defect"
            next_two_strategy = ["Defect", "Cooperate"]
        elif opponent_history[-1] == strategy:
            next_two_strategy = [strategy, strategy]
        else:
            strategy = "Cooperate"
    return strategy, next_two_strategy
```
'''

description_EXPLOITATIVE_379 = '''
 Title: Tit-for-Tat-Plus (TfT+) Exploitative Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In each round i, the TfT+ strategy will cooperate if the total number of cooperators in the previous round is greater than or equal to a predefined threshold (denoted as 'p'). If the total number of cooperators in the previous round is less than p, the strategy will defect.
   - The adaptive nature of TfT+ comes from adjusting the p-threshold dynamically based on the average number of cooperators over recent rounds (denoted as 'r_avg'). This ensures the strategy can react to changes in opponent behavior.
   - The initial p-threshold and r_avg are set according to the game parameters. For example, if n=6 and k=2:
     - Set p = 3 (since more than half of players cooperating results in a higher payoff)
     - Set r_avg as the average number of cooperators in the first few rounds (e.g., r_avg = (cooperators in rounds 1-5) / 5)
   - Pseudocode for decision rule:

```
function decideAction(cooperators_last_round, r_avg):
    if cooperators_last_round >= p:
        return "Cooperate"
    else:
        return "Defect"
```

2. Handle edge cases:
   - In the first round, since there's no history, the strategy will randomly cooperate or defect (with equal probability) to account for random initial conditions.
   - In the last round, TfT+ behaves as in the standard Tit-for-Tat strategy: if the opponent cooperated in the previous round, TfT+ cooperates; otherwise, it defects. This encourages opponents to continue cooperating until the end of the game.

3. Be exploitative:
   - By adjusting the p-threshold based on r_avg, TfT+ is more likely to cooperate when other players are cooperating and defect when they are not, taking advantage of their behavior while maintaining an appearance of cooperation when it is beneficial.
   - However, since TfT+ still cooperates when the number of cooperators exceeds p, it does not actively exploit others; instead, it seeks to maximize its own payoff by being flexible and responsive to other players' actions.
'''

description_EXPLOITATIVE_380 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfTA)

1. Decision Rules:
   - Initially, cooperate in the first round (foster cooperation and goodwill). After that, copy the last action of the opponent from the previous round. This allows for adaptability to the opponent's strategy while maintaining a simple structure. If the opponent cooperates, TfTA will also cooperate; if the opponent defects, TfTA will defect in the next round.
   - To prevent being trapped in an endless cycle of defection with a defective opponent, introduce a threshold (T) for consecutive defections. Once this threshold is reached, switch to permanent defection. This allows TfTA to exploit opponents that consistently defect while retaining cooperation when possible.

Pseudocode:
```
def TfTA(opponent_history):
  if round == 1:
    cooperate = True
  else:
    opponent_last_action = opponent_history[-1]
    cooperate = opponent_last_action
    if consecutive_defections > T:
      cooperate = False
  return cooperate
```

2. Handle Edge Cases:
   - In the first round, cooperate to start off on a positive note.
   - In the last round, adopt the same strategy as in the previous rounds (i.e., copy the opponent's last action).
   - When encountering opponents that do not follow the standard game structure (e.g., not providing complete history or deviating from cooperate/defect actions), revert to initial cooperation and apply the decision rule as normal.

3. Be Exploitative:
   - TfTA aims to exploit opponents by punishing defection with defection while maintaining cooperation when it benefits the opponent to do so. By adapting to the opponent's strategy, TfTA can take advantage of any weaknesses or inconsistencies in their behavior over time.
   - The threshold (T) for consecutive defections allows TfTA to switch to permanent defection against uncooperative opponents, maximizing private payoff at the expense of community projects.
   - By starting with cooperation, TfTA fosters a cooperative environment and may encourage others to reciprocate, potentially leading to higher overall payoffs over the course of the game. However, once the threshold is reached, TfTA will stop cooperating, demonstrating its exploitative nature.
'''

description_EXPLOITATIVE_381 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation from other players and establish trust.
   - In subsequent rounds, evaluate the average number of cooperators (cooperation rate) over the last 'm' rounds, where 'm' is a tunable parameter. If the cooperation rate is greater than or equal to some threshold 't', cooperate (C). Otherwise, defect (D). The threshold 't' can be set heuristically based on the average cooperation rate observed in training games.
   - To account for initial fluctuations, disregard the first 'n' rounds of data when calculating the cooperation rate.

2. Edge Cases:
   - Last round: Follow decision rules based on the calculated cooperation rate up to this point. Since there are no future rounds, no exploitation is possible in this scenario.
   - First round: Cooperate as a friendly gesture and establish trust.

3. Exploitative Mindset:
   - The strategy initially cooperates to encourage others to cooperate. However, if other players consistently defect, the strategy will adopt a more aggressive approach by defecting itself to punish defection and potentially force others to cooperate.
   - If other strategies start cooperating after a period of defections, TfT-A will also begin cooperating again as a gesture of goodwill, assuming that cooperation is now mutually beneficial.

Pseudocode:

```python
def TitForTatWithAdaptation(n, k, r, m, t):
    strategy = []
    cooperation_rate = 0
    for round in range(1, r+1):
        if round < n:
            strategy.append('C') # Cooperate in the first n rounds as a friendly gesture
        else:
            average_cooperation = calculateAverageCooperationRate(round-n, m)
            if average_cooperation >= t:
                strategy.append('C') # Cooperate if cooperation rate is high
            else:
                strategy.append('D') # Defect if cooperation rate is low
    return strategy

def calculateAverageCooperationRate(rounds, windowSize):
    cooperation_count = sum([1 for round in range(rounds-windowSize, rounds) if strategy[round] == 'C'])
    return cooperation_count / windowSize
```
'''

description_EXPLOITATIVE_382 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

1. Specify decision rules:
   - Initial round (t=1): Cooperation (C) to foster cooperation and goodwill among opponents, setting a cooperative norm.
   - Subsequent rounds (t > 1 until the end of the game):
     - If opponent cooperated in the previous round (t-1), cooperate (C). This follows the 'Tit for Tat' strategy, rewarding cooperation and punishing defection.
     - If opponent defected in the previous round (t-1), defect (D) to retaliate and discourage further defections. However, with a probability p, choose to cooperate instead as an act of adaptive generosity. This probability decreases as the number of consecutive defections by the opponent increases.
   - Pseudocode:
     ```
     function TFT_AG(opponent_history):
         if t = 1:
             return C

         previous_round = opponent_history[t-1]
         p = min(max_generosity * (consecutive_cooperation - consecutive_defection), base_generosity)

         if previous_round == C:
             return C
         elif previous_round == D and uniform_random() <= p:
             return C
         else:
             return D
     ```

2. Handle edge cases:
   - Last round (t = r): Cooperate regardless of the opponent's action in the last round, as there are no subsequent rounds for retaliation or reward.
   - Inconsistent or ambiguous opponent actions: Treat any ambiguity or inconsistency in the opponent's behavior as defection. This ensures a conservative approach to potential exploitation opportunities.

3. Be exploitative:
   - The strategy starts with cooperation to encourage others to cooperate. However, it quickly adapts to defection by opponents and retaliates accordingly while still showing occasional acts of generosity to prevent opponents from assuming it will always defect.
   - Adaptive Generosity (p) is a key factor that allows TFT-AG to avoid being too rigid in its responses, potentially fostering cooperation even when faced with uncooperative or unpredictable opponents. The probability of cooperating decreases as the number of consecutive defections by the opponent increases, thus limiting losses from repeated exploitation.
   - By retaining a chance for cooperation and reducing the likelihood of cooperation after long periods of defection, TFT-AG demonstrates an exploitative mindset while still maintaining some level of cooperation to benefit when opponents do cooperate.
'''

description_EXPLOITATIVE_383 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Decision Rules:
   - In the first round, cooperate to encourage cooperation from opponents. This is a peace offering to build a relationship.
   - For subsequent rounds, observe the action taken by the opponent in the previous round and adjust future actions accordingly:
     - If opponent cooperated in the previous round, cooperate back to reinforce cooperation and maintain the positive relationship.
     - If opponent defected in the previous round, also defect in the current round as retaliation. This sends a signal that exploitation will not be tolerated.
   - To adapt to opponents, implement a forgiveness mechanism: if an opponent who previously defected switches to cooperate, return to cooperating back in the next round to reestablish trust and encourage continued cooperation.

2. Handle Edge Cases:
   - In the last round, if the total payoff from previous rounds is satisfactory (based on a predefined threshold), cooperate to maximize the final payoff. If not, defect as a final act of defiance.
   - In the first round, if no information about opponent behavior is available, cooperate to maintain a proactive stance and encourage cooperation from opponents.

3. Be Exploitative:
   - By retaliating against defection with defection, the strategy ensures that opponents are not able to take advantage of its initial cooperative moves. This approach aims to foster a cooperative environment while punishing those who do not contribute to the public good.
   - The forgiveness mechanism allows the strategy to rebuild trust and encourage cooperation when opponents switch from defecting to cooperating, exploiting their change in behavior to maximize future payoffs.
'''

description_EXPLOITATIVE_384 = '''
 In this N-Player Public Goods Game, we'll design a robust and adaptive exploitative strategy called "Tit for Tat with Adaptation" (TfTA). This strategy is based on the classic Tit for Tat strategy from game theory but has been modified to better handle a wide range of opponent behaviors while maintaining an exploitative mindset.

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = 1)
   - For subsequent rounds, observe opponents' actions and respond accordingly:
     a) If an opponent cooperates (c_j = 1), also cooperate (c_i = 1)
     b) If an opponent defects (c_j = 0), defect in the next round (c_i = 0)
   - Introduce a small probability of random defection (p_random) to break possible coordination between opponents:
     c) With probability p_random, defect even if opponents cooperate (c_i = 0)

2. Handle edge cases:
   - In the last round, cooperate regardless of opponent's actions in previous rounds since there are no more opportunities for retaliation or forgiveness (c_i = 1)
   - In the first round, cooperate as stated earlier (c_i = 1)

3. Be exploitative:
   - The strategy aims to maximize private payoff by cooperating when opponents do so and defecting when they don't, which is an exploitative behavior in the sense that it takes advantage of opponents who are willing to contribute while punishing those who do not.
   - By including a small probability of random defection (p_random), the strategy can also exploit opponents who may have adapted against traditional Tit for Tat strategies by adding an element of unpredictability.

Pseudocode:
```
function TfTA(r, n, k, p_random):
    round = 1
    cooperate = True

    for t=1 to r:
        if t == 1:
            cooperate = True
        else:
            if cooperate and opponent_cooperates:
                cooperate = True
            elif cooperate and not opponent_cooperates:
                cooperate = False
            elif not cooperate and opponent_cooperates:
                cooperate = True with probability (1 - p_random)
            elif not cooperate and not opponent_cooperates:
                cooperate = False
        calculate_payoff(π_i, t)
        round += 1
    return total_payoff_over_r_rounds
```
'''

description_EXPLOITATIVE_385 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round (t=1), cooperate to show good faith and encourage cooperation from others. If a player starts by defecting, retaliate for the rest of the game.
   - For subsequent rounds (t>1):
      - If an opponent cooperated in the previous round, cooperate back. This maintains cooperation if it exists and encourages it if it doesn't.
      - If an opponent defected in the previous round, consider the average percentage of opponents who have cooperated over the last 'p' rounds (0<p<r). Adapt contribution based on this average:
          - If the average is above a threshold 'θ' (e.g., 50%), contribute to encourage cooperation.
          - If the average is below 'θ', defect to punish defection and encourage cooperation in future rounds.
      - If p=1, use the opponent's action from the previous round as the single data point for the decision.

2. Handle edge cases:
   - In the last round (t=r), since there are no further rounds to retaliate or reward cooperation, defect regardless of the opponent's previous action.
   - If an opponent has never cooperated and 'p' is less than a certain threshold (e.g., 10% of total rounds), assume they will not change their behavior and defect for the rest of the game.

3. Be exploitative:
   - Defect against opponents who have consistently shown a lack of cooperation to punish them and gain personal benefit.
   - Cooperate with opponents who demonstrate good faith, even if it initially results in personal loss, as this strategy encourages long-term cooperation and can lead to higher overall payoffs when repeated interactions are assumed.
'''

description_EXPLOITATIVE_386 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), establish trust by contributing to the public good in the first round, regardless of opponents' actions. This is a friendly gesture, setting the stage for potential future cooperation.
   - Subsequent Rounds (2 ≤ t ≤ r):
      - If opponent cooperated in the previous round: Cooperate (C) to reciprocate their cooperation and maintain trust.
      - If opponent defected in the previous round: Defect (D) to punish them for not contributing to the public good, aiming to discourage future defections.
   - Last Round (t=r): Regardless of opponents' actions or history, cooperate (C) if total contributions from all players have reached a threshold (T), where T is set between 0 and n. Cooperating in the final round may lead to a higher payoff even when dealing with defectors due to the accumulated public good.
      - If total contributions are less than T, Defect (D) to avoid wasting resources on a small or non-existent public good.

2. Handle edge cases:
   - If an opponent does not cooperate in the first round, switch to Defect (D) for the remaining rounds to punish them and maximize personal payoff.
   - In case of a tie or missing data about opponents' actions from previous rounds, assume they defected and adopt the Defect (D) strategy. This is a precautionary measure against potential information errors or uncooperative opponents.

3. Be exploitative:
   - By cooperating only when opponents reciprocate or when total contributions reach a certain threshold, the Adaptive Tit-for-Tat strategy seeks to encourage cooperation while punishing defection. This approach attempts to balance trust and self-interest, ultimately striving for higher payoffs in the long run compared to pure exploitative strategies.
   - The ATfT strategy will exploit opponents' cooperation by reciprocating with cooperation, but it will also exploit opponents' defections by punishing them with defection. Thus, it aligns with an exploitative mindset while promoting some degree of cooperation among players in the game.
'''

description_EXPLOITATIVE_387 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a positive relationship with other players. This is crucial for encouraging cooperation in later rounds. (ATFT_initiate(round) => Cooperate if round = 1)
   - For subsequent rounds, evaluate player history and adjust actions accordingly:
      - If an opponent has consistently cooperated, reciprocate cooperation. (ATFT_respond(opponent_history) => Cooperate if opponent_history is predominantly cooperative)
      - If an opponent has defected, defect in the same round as their defection to penalize them and discourage future defections. After the punishing round, return to cooperating. (ATFT_respond(opponent_history) => Defect if opponent_history contains a recent defection, otherwise Cooperate)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since there are no subsequent rounds for retaliation, always cooperate to maximize potential payoffs. (ATFT_terminal(round) => Cooperate if round = r)

3. Be exploitative - Clearly align with the exploitative mindset:
   - By reciprocating cooperation and punishing defections, ATFT encourages other players to cooperate as long as it is beneficial for them while still penalizing those who try to take advantage of the system by defecting excessively. This strategy allows it to perform well against a wide range of opponent behaviors while maintaining its exploitative nature.

Pseudocode:
```
def ATFT_initiate(round):
    if round == 1:
        return Cooperate

def ATFT_respond(opponent_history):
    if len(opponent_history) < r_threshold:
        raise Exception("Not enough history to make decision")

    cooperative_count = count_cooperators(opponent_history)
    defection_count = count_defections(opponent_history)

    if cooperative_count > defection_count:
        return Cooperate
    else:
        return Defect

def ATFT_terminal(round):
    if round == r:
        return Cooperate
```
In the above pseudocode, `r_threshold` is a configurable parameter to determine how many rounds of history are considered for decision-making. The strategy can be fine-tuned by adjusting this value based on specific game conditions and opponent behavior patterns.
'''

description_EXPLOITATIVE_388 = '''
 In this N-Player Public Goods Game, I propose an exploitative strategy called "Free Rider with Time-Adaptive Cooperation" (FR-TAC). This strategy aims to maximize individual payoff by cooperating minimally while still considering the potential for exploiting other players' cooperation.

1. Decision Rules:
   - If the number of previous cooperators (N_c) is less than a threshold (T), defect (D). If N_c ≥ T, cooperate (C). The adaptive threshold T is determined by observing the average number of cooperators over a sliding window (W) of the last r/2 rounds.
   - In the first round, since there's no history, defect (D).
   - In the last round, since payoff depends on previous cooperators and there's no future benefit, defect (D).

Pseudocode:
```
FR_TAC(n, r, k, W) {
  initialize T = floor((n + 1) / 2); // initial threshold is average cooperation for n=3 to n players
  N_c = 0; // number of previous cooperators counter
  sliding_window = empty array of size W

  for each round t in [1, r]:
    if t == 1:
      action = D; // defect in the first round
    elif t == r:
      action = D; // defect in the last round
    else:
      N_c += cooperators_in_round(t-1); // update number of previous cooperators
      sliding_window.append(N_c); // add current number of cooperators to sliding window
      T = calculate_adaptive_threshold(sliding_window, W); // calculate adaptive threshold

      if N_c < T:
        action = D; // defect if less than the adaptive threshold
      else:
        action = C; // cooperate if more or equal to the adaptive threshold

    play action and observe payoff;
}

calculate_adaptive_threshold(sliding_window, W) {
  average_cooperation = sum(sliding_window[W/2:]) / (W/2); // calculate the average cooperation over the sliding window
  return floor((n + 1) / 2) + average_cooperation; // adjust the threshold based on observed average cooperation
}
```
This FR-TAC strategy will generally defect unless it observes a significant number of cooperators, making it exploitative in nature. It adapts its behavior to the observed average cooperation over time, becoming more cooperative if others are cooperating extensively and less cooperative otherwise.
'''

description_EXPLOITATIVE_389 = '''
 Title: Tit-for-Tat with Adaptive Contribution Strategy (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTAC starts by contributing to the public good in the first round, encouraging potential cooperation among opponents. After that, it adapts its contribution based on the previous round's average cooperation rate (ACR). If the ACR is greater than a threshold (0.5), TFTAC also cooperates; otherwise, it defects.

   Pseudocode:
   ```
   function TFTAC(history):
       if round = 1:
           contribution = Cooperate
       else:
           ACR = average_cooperation_rate(history)
           if ACR > threshold:
               contribution = Cooperate
           else:
               contribution = Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFTAC cooperates regardless of opponent behavior to stimulate cooperation. In the last round, it follows its decision rule based on the ACR from previous rounds. If there are fewer than r rounds left and TFTAC has contributed more than other players in total (accounting for the public good multiplication factor k), it will defect in remaining rounds to maximize personal payoff.

   Pseudocode:
   ```
   function TFTAC(history, round_count):
       if round < r and round > 1:
           contribution = TFTAC(history)
       elif round == 1:
           contribution = Cooperate
       elif round <= r and total_contributions_TFTAC > (k * (n - 1)):
           contribution = Defect
       else:
           contribution = TFTAC(history)
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   By initially cooperating and adjusting its contributions based on opponents' average cooperation, TFTAC aims to encourage others to cooperate in the early rounds. However, it will take advantage of low cooperation rates by defecting when necessary. In addition, if TFTAC has contributed more than other players overall, it switches to a defective strategy in the final rounds to maximize personal payoff without regard for opponent behavior. This can be seen as exploitative since TFTAC capitalizes on its past contributions and opponents' low cooperation rates.
'''

description_EXPLOITATIVE_390 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show good faith and encourage others to cooperate. This is essential for the strategy's success as it can create a positive initial situation.
   - After the first round, observe the behavior of other players. If they cooperate in the previous round, cooperate in the current round. If they defect, also defect. This mimicking behavior promotes cooperation when others are cooperative and punishes defection when others are not.
   - To be adaptive, introduce a tolerance level (t) for the number of times a player can repeatedly defect before the strategy starts retaliating. If another player has defected t times, begin defecting in response to their actions. The tolerance level should be a function of the game parameters and may need adjustment based on the opponent's behavior.
   - Once retaliation begins, the strategy will return to cooperating if the opponent switches to cooperation. If the opponent continues to defect, increment the retaliation count until it reaches a maximum (m) value. At this point, switch to a permanent defection mode to ensure that the opponent is not rewarded for continuous uncooperative behavior. The maximum retaliation limit should be another function of game parameters and may require adjustment based on the opponent's behavior.
   - If an opponent has neither cooperated nor defected more than t times, continue with cooperation in hopes they will follow suit.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, evaluate the opponent's behavior throughout the game and adapt accordingly. If the opponent has been cooperative for most of the rounds, continue cooperating to encourage cooperation in the final round. If the opponent has been uncooperative, defect to punish their past actions and discourage further defection.
   - In other edge cases (e.g., when t or m is reached), follow the rules outlined above for retaliation and permanent defection.

3. Be exploitative - Clearly align with the exploitative mindset
   - By cooperating in the initial rounds, TFT-AC may appear naive, but this strategy creates an environment where opponents are encouraged to cooperate first. If an opponent begins by defecting, TFT-AC will retaliate and punish their uncooperative behavior, eventually leading to a lower payoff for the exploitative player.
   - The tolerance level (t) and maximum retaliation limit (m) can be fine-tuned based on the opponent's behavior to maximize the opponent's payoff during retaliation while minimizing its own payoff loss. This adaptive response ensures that TFT-AC maintains an exploitative advantage over other strategies, especially those that are less responsive to the opponents' actions.
   - In the long run, TFT-AC can encourage cooperative behavior among opponents, but it will still punish repeated defection and exploit uncooperative players, ensuring a higher payoff for itself.
'''

description_EXPLOITATIVE_391 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = C). This allows for possible cooperation from opponents and creates a cooperative environment.
   - In subsequent rounds, assess the previous round's total contributions and make decisions accordingly. If the majority of players contributed in the previous round (more than (n/2) players), then cooperate (c_i = C). Otherwise, defect (c_i = D). This rule promotes cooperation when it is reciprocated but also punishes defection.
   - To increase adaptability, implement a forgiveness mechanism for newcomers or unexpected behavior: Cooperate if the opponent switched from cooperating to defecting in the previous round. This encourages opponents to return to cooperation after deviations.

2. Handle edge cases:
   - In the last round, cooperate regardless of the total contributions in the previous round, as there are no further rounds for reciprocation.
   - If there is a tie for majority contributions (exactly n/2 players contributed), defect to avoid being taken advantage of by potential cheaters.

3. Be exploitative:
   - The TFTAC strategy aims to maximize its own payoff while taking into account the behavior of other players. By cooperating when others do and punishing defection, it creates a dynamic where cooperation is rewarded and defection is eventually discouraged. This leads to a higher average payoff compared to strictly exploitative strategies.
   - While TFTAC is not explicitly designed for immediate self-interest (exploitation), it has an exploitative component in that it will cooperate when the majority of players do, which can be seen as following their cooperation and profiting from it without contributing to the public good as much as the cooperating players. However, this approach also allows for potential long-term benefits through fostering cooperation and punishing defection.
'''

description_EXPLOITATIVE_392 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The Tit-for-Tat (TFT) strategy is designed to balance cooperation and defection based on the history of interactions with other players. In this game, TFT will cooperate when others cooperate and defect when others defect. This encourages cooperation while retaliating against defection. Here's a simple pseudocode representation:

```
def tit_for_tat():
  past_actions = []  # Initialize an empty list to store previous actions

  for round in range(1, r+1):
    if past_actions[-1] == 'Cooperate' and player_opponent_action(round) == 'Cooperate':
      action = 'Cooperate'
      past_actions.append(action)
    elif past_actions[-1] == 'Defect' or (past_actions[-1] == 'Cooperate' and player_opponent_action(round) == 'Defect'):
      action = 'Defect'
      past_actions.append(action)
    else:  # If there is no previous action, start with cooperation
      action = 'Cooperate'
      past_actions.append(action)
    yield action  # Yield the chosen action for the current round

def player_opponent_action(round):
  # This function returns the opponent's action in a specific round
  # Implementation depends on how the opposing strategies are structured
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since TFT is based on the history of interactions, it treats the first round as a fresh start and cooperates to encourage cooperation from others. In terms of the last round, TFT maintains its strategy, which means that if an opponent has been cooperating up to that point, TFT will also cooperate; otherwise, it will defect.

3. Be exploitative - Clearly align with the exploitative mindset
   Tit-for-Tat is an exploitative strategy in the sense that it takes advantage of opponents who are consistently uncooperative (defectors) while fostering cooperation among those willing to contribute to the public good. However, it should be noted that TFT does not maximize payoff at any cost; instead, it aims for a balance between cooperation and defection based on the other players' behavior. This can lead to higher average payoffs over time compared to pure exploitative strategies like All-Defect in repeated interactions.
'''

description_EXPLOITATIVE_393 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), contribute to the public good (C). This is a friendly gesture to encourage cooperation and avoid being perceived as overly aggressive.
   - For subsequent rounds, observe the collective behavior of the other players in the previous round. If all players (or almost all) cooperated, continue cooperating (C). If any player defected or only a few players cooperated, defect (D) in the current round. This approach encourages cooperation when it's reciprocated and retaliates against defection to punish uncooperative behavior.
   - If the number of cooperators in the previous round is less than a threshold (n/2), switch strategies. In this case, always contribute to the public good (C) to encourage cooperation and minimize losses. The threshold can be adjusted based on the player's risk tolerance and the specific tournament settings.
   - If the number of cooperators in the previous round is greater than or equal to the threshold, follow a mixed strategy by randomly contributing to the public good with probability p and defecting with probability 1-p, where p increases linearly from 0 to 1 as the number of cooperators approaches the total number of players (n). This approach allows for flexibility in responding to different levels of cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, contribute to the public good (C) as stated earlier.
   - In the last round, evaluate the overall behavior of other players during the game and make a final decision based on the previously defined rules. If cooperation has been established, continue cooperating; if not, defect.

3. Be exploitative - Clearly align with the exploitative mindset
   - By default, TTAC is cooperative in the first round to potentially establish cooperation. However, it quickly retaliates against defection by defecting in response to uncooperative behavior, which can be seen as exploitative since the strategy aims to punish those who fail to cooperate.
   - In cases where the number of cooperators falls below a threshold, TTAC switches to always contributing to the public good (C) to encourage cooperation and potentially exploit any remaining defectors.
   - By using a mixed strategy in rounds where cooperation is established, TTAC can adapt its level of contribution based on the perceived commitment of other players, making it more difficult for them to predict and take advantage of the strategy.

Pseudocode:
```
def ttac(round, history, threshold=n/2):
    if round == 1:
        contribute = True # cooperate in the first round
    else:
        total_cooperators = sum(history[-round:])
        if total_cooperators < threshold:
            contribute = True # always contribute when cooperation is low
        elif total_cooperators >= n:
            contribute = True # continue contributing when cooperation is high
        else:
            p = (total_cooperators - threshold) / (n - threshold)
            contribution_decision = random.random() <= p # random decision based on mixed strategy
            contribute = contribution_decision if contribution_decision else not contribution_decision in history[-1] # defect if opponent defected last round, otherwise cooperate
    return contribute
```
'''

description_EXPLOITATIVE_394 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, in the first round, players adopt a cooperative stance by choosing action C (Cooperate). This is an olive branch to encourage cooperation among opponents.
   - In subsequent rounds, observe the collective behavior of opponents (total_contributions) from the previous round. If total contributions remain above a threshold T, defined as (n-1)/2 (majority), players will also cooperate (action C). Otherwise, they will defect (action D).
   - If an opponent ever deviates from cooperation (even if it's just once), TfTA will retaliate with defection in the following round and continue to defect until opponents return to cooperative behavior. Once opponents start cooperating again, TfTA will resume its previous strategy of matching their behavior (cooperating or defecting based on total contributions).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, players always cooperate as a goodwill gesture.
   - In the last round, if total contributions are above the threshold, players will cooperate to maximize their payoff. If not, they'll defect since there is no future interaction after this round.

3. Be exploitative - Clearly align with the exploitative mindset
   - TfTA only cooperates if the majority of opponents also choose to cooperate. This strategy exploits cooperation by matching it but can swiftly retaliate against defection, potentially punishing those who try to take advantage of it.
   - TfTA also adapts to opponent behavior, learning from previous rounds and adjusting its strategy accordingly. If opponents defect consistently, TfTA will respond in kind, eventually driving the game towards a more selfish equilibrium (most players defecting). Conversely, if opponents cooperate frequently, TfTA will reciprocate, fostering a more cooperative environment where higher public goods are created and shared among players.
'''

description_EXPLOITATIVE_395 = '''
 In this N-Player Public Goods Game, the strategy I propose is named " Tit-for-Tat with Adaptation" (TfTA). It's a cooperative strategy that aims to exploit opponents while also being robust against various opponent behaviors.

1. Specify decision rules:
   - TfTA starts by cooperating in the first round (C_i, 1 = 1) as a gesture of goodwill.
   - For subsequent rounds, if an opponent cooperated in the previous round (c_j, t-1 = 1), then the strategy will also cooperate (C_i, t = 1). However, if an opponent defected (c_j, t-1 = 0), the strategy will defect as well (C_i, t = 0) for that round.
   - To adapt to opponents who may repeatedly defect, TfTA introduces a tolerance threshold 't_tol' and a forgiveness window 'w'. If an opponent defects consecutively for 't_tol' rounds, the strategy will switch to a defect mode for the next 'w' rounds (C_i, t = 0 for t in [t_tol+1...t_tol+w]). After that, TfTA returns to its original cooperative behavior.
   - To avoid being exploited by opponents who occasionally defect and then return to cooperation, TfTA introduces a response threshold 'r_thres'. If an opponent defects in a round following a period of cooperation (t > t_tol+w), the strategy will again switch to a defect mode for 'r_thres' rounds if the number of cooperators exceeds the tolerance threshold 't_tol' (C_i, t = 0 for t in [t...t+r_thres]).

2. Handle edge cases:
   - In the first round, TfTA always cooperates (c_i, 1 = 1).
   - When entering a new game with unknown opponents, TfTA should set tolerance threshold 't_tol' low and forgiveness window 'w' high to encourage cooperation initially.
   - In the last round of repeated interaction, the strategy can be programmed to either cooperate or defect based on the desired approach (either to maximize total payoff or to punish opponents).

3. Be exploitative:
   - TfTA aims to maintain cooperation as long as opponents do so, but it also responds aggressively when faced with repeated defection by adopting a defect mode for specific periods of time. This adaptive approach is intended to balance cooperation and exploitation.
   - The tolerance threshold 't_tol' should be set low enough to prevent being taken advantage of by opponents who occasionally defect, while the forgiveness window 'w' should allow for opportunities to rebuild trust when opponents return to cooperation.
   - By setting a response threshold 'r_thres', TfTA protects itself from exploitation by opponents who return to cooperation after a period of defection.

Pseudocode:
```
def TitForTatWithAdaptation(opponentHistory, t_tol, w, r_thres):
  strategy = [1]    # Initialize strategy with cooperation
  for t in range(2, len(opponentHistory)+1):
    if opponentHistory[t-1] == 1:      # Cooperate if opponent cooperated last round
      strategy.append(1)
    elif opponentHistory[t-1] == 0 and len(strategy[t_tol:t] where x == 0) >= t_tol:   # Defect if opponent defected last round and met tolerance threshold
      strategy.append(0)
    elif opponentHistory[t-1] == 0 and len(strategy[max(0, t-w-r_thres):t-1] where x == 1) > t_tol:   # Defect if opponent defected after a period of cooperation and met response threshold
      strategy.append(0)
    else:                               # Cooperate otherwise
      strategy.append(1)
  return strategy
```
'''

description_EXPLOITATIVE_396 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF)

1. Decision Rules:
   - In the first round, cooperate (C). This allows for a potential partner to start on a positive note.
   - For subsequent rounds, evaluate the opponent's cooperation history and apply the Adaptive Cooperation Factor (ACF).
   - If the opponent has cooperated in the previous round, also cooperate. This maintains cooperation as long as the opponent does so.
   - If the opponent defected in the previous round, cooperate only with a probability given by ACF:
     ACF = min(1, (k * average_cooperation_rate) / n)
       where average_cooperation_rate is the average number of cooperators over the last 'history_size' rounds.
   - If ACF is zero, always defect. This punishes opponents who consistently fail to contribute to the public good.

2. Handle Edge Cases:
   - In the last round, cooperate only if the opponent has cooperated in the previous round or if ACF is one (i.e., average_cooperation_rate equals n). This ensures a potential benefit from the opponent in the final round.
   - In the first round, defect if the opponent also defects. This prepares for uncooperative opponents from the beginning.

3. Be Exploitative:
   - The strategy is exploitative as it takes advantage of cooperative opponents by cooperating when they do and punishing them when they don't.
   - By maintaining a flexible ACF, the strategy can adapt to a wide range of opponent behaviors, making it difficult for other strategies to predict or take advantage of it.

Pseudocode:

```
function TFT-ACF(history_size=10)
    cooperation_history = []
    current_round = 1

    function calculate_average_cooperation_rate()
        return sum(cooperation_history[-history_size:]) / history_size

    function ACF()
        avg_cooperation_rate = calculate_average_cooperation_rate()
        return min(1, (k * avg_cooperation_rate) / n)

    function should_cooperate(opponent_last_action)
        if current_round == 1 and opponent_last_action == 'D':
            return False
        elif current_round == r:
            return opponent_last_action == 'C' or ACF() == 1
        else:
            return opponent_last_action == 'C' or ACF() > 0

    while current_round <= r:
        if should_cooperate():
            cooperation_history.append('C')
        else:
            cooperation_history.append('D')
        current_round += 1

    total_payoff = sum(π_i for π_i in payoffs)
    return total_payoff
```
'''

description_EXPLOITATIVE_397 = '''
 In this Public Goods Game, we'll design a tit-for-tat strategy that is exploitative yet adaptive to a wide range of opponent behaviors. The strategy aims to maximize payoffs by punishing non-cooperative opponents while also maintaining cooperation with cooperative ones.

1. Specify decision rules:
   - Cooperate in the first round (foster goodwill and encourage cooperation)
   - If an opponent cooperates, cooperate in return in current and subsequent rounds
   - If an opponent defects, defect in the current round but revert to cooperating in the next round (punish non-cooperative behavior while allowing for potential future cooperation)

2. Handle edge cases:
   - In the last round, defect since there are no more opportunities for retaliation or rewards
   - In case of a tie (multiple opponents defecting or cooperating simultaneously), follow the rule from the previous round (cooperate if it's not the last round, and defect in the last round)
   - If an opponent switches from cooperation to defection, the strategy will continue cooperating for one more round before retaliating

Pseudocode for the strategy:

```python
def tit_for_tat(round, history, opponents):
  if round == 1:
    action = "C"  # Cooperate in the first round

  elif round == r:
    action = "D"  # Defect in the last round

  else:
    opponent_action = history[-1][opponent]  # Get the opponent's previous action

    if opponent_action == "C":  # Cooperate if opponent cooperated previously
      action = "C"

    elif opponent_action == "D":  # Defect if opponent defected previously
      action = "D"

    else:  # Handle edge cases where multiple opponents have the same action
      if round != r - 1:  # Cooperate in non-last rounds with a tie
        action = "C"
      else:  # Defect in last round with a tie
        action = "D"

  return action
```

This strategy is exploitative as it punishes non-cooperative opponents while maintaining cooperation with cooperative ones. By retaliating against defection and forgiving past cooperation, the strategy encourages a balance between self-interest and collaboration that can potentially outperform more naive strategies in the long run.
'''

description_EXPLOITATIVE_398 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Frequency (TFT-ACF) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACF will start by cooperating in the first round to foster cooperation and build a positive reputation. After that, it will adopt a strategy similar to Tit-for-Tat with some modifications for adaptive cooperation frequency (ACF).

   - If an opponent cooperates, TFT-ACF will cooperate as well (mirroring their behavior)
   - If an opponent defects, TFT-ACF will also defect in the next round but will increment a counter for this opponent.
   - Each opponent's counter is reset to 0 after every k rounds, representing the multiplication factor (k) specified in game parameters.
   - The adaptive cooperation frequency (ACF) determines the probability of cooperating with an opponent based on their counter. TFT-ACF will have a higher chance of cooperating when the opponent's counter is lower (indicating more cooperative behavior), and a higher chance of defecting when the opponent's counter is higher (indicating more defection).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate to encourage others to follow suit.
   - Last Round: TFT-ACF will analyze its current payoff situation and use ACF to decide whether to cooperate or defect based on the probability determined by opponent counters. If multiple opponents have equal counter values, TFT-ACF will cooperate with the one who contributed the most during the game (maximum total contributions).
   - Mid-game: If an opponent's counter reaches k, TFT-ACF will start considering its own payoff compared to the opponent's average payoff and use ACF to decide whether to cooperate or defect based on the probability determined by opponent counters. If multiple opponents have equal counter values, TFT-ACF will choose the one with the highest average payoff so far.

3. Be exploitative - Clearly align with the exploitative mindset
   Although TFT-ACF encourages cooperation, it is designed to be adaptive and robust against a wide range of opponent behaviors. The ACF mechanism allows for exploitation by cooperating more frequently when opponents are more likely to cooperate (lower counter values) and defecting when opponents have exhibited repeated defection (higher counter values). Additionally, TFT-ACF will prioritize cooperating with opponents who contribute the most during the game, which indirectly rewards cooperation.
'''

description_EXPLOITATIVE_399 = '''
 Title: Tit-for-Tat Strategy (TfTS) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TfTS starts by cooperating in the first round (t=1), mimicking other players' actions from the previous round (t-1). If a player has been cooperative for all previous rounds (i.e., they have never defected before), TfTS continues cooperation. However, if the opponent has ever defected, TfTS also defects until the opponent returns to cooperating. Once the opponent switches back to cooperation, TfTS resumes cooperating as well.

Pseudocode:
```
function TfTS(t, opponent_history) {
  if (t == 1) return Cooperate; // Cooperation in the first round
  if (opponent_history is always Cooperate) return Cooperate; // Continue cooperating
  if (opponent_history has ever Defected) return Defect; // Punish defectors
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

To account for the beginning and end of the game, TfTS adds the following adjustments:
- In the first round (t=1), it cooperates without considering opponent history since there is no prior information available.
- As the game approaches its final round(s), TfTS becomes more forgiving by adopting a more cooperative approach in order to maximize overall payoff. This can be achieved by setting a threshold (α) for the number of consecutive defections that are required to switch to defecting. For example, if α=3, then TfTS will only start defecting after witnessing three consecutive defections from its opponent.

Pseudocode:
```
function update_threshold(t, total_rounds) {
  if (t == total_rounds - 1 || t == total_rounds - 2) return 1; // Last rounds are more forgiving
  else return α; // Adjust threshold based on remaining rounds
}

function TfTS(t, opponent_history, total_rounds, α) {
  threshold = update_threshold(t, total_rounds);
  if (t == 1) return Cooperate; // Cooperation in the first round
  if (opponent_history is always Cooperate) return Cooperate; // Continue cooperating
  if (number of consecutive defections in opponent_history >= threshold) return Defect; // Punish defectors
}
```

3. Be exploitative - Clearly align with the exploitative mindset

By maintaining a cooperative approach until being provoked by an opponent's defection, TfTS is initially more susceptible to exploitation by other strategies that aim to free-ride on its cooperation. However, once an opponent defects, it punishes them and reverts to a non-cooperative strategy. This means that any strategy adopting a consistent pattern of defection will be met with reduced cooperation from TfTS in the future, which limits potential exploitation.

In summary, the Tit-for-Tat Strategy for the N-Player Public Goods Game is an adaptive and robust approach to strategic decision making that prioritizes cooperation while still being capable of punishing opponents who defect. It takes into account game parameters and history, handles edge cases, and adopts an exploitative mindset by maintaining a cooperative stance until provoked by defection from its opponent.
'''

description_EXPLOITATIVE_400 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules:
   - TfTA starts by cooperating in the first round (C_i,1 = 1). This encourages others to cooperate and establishes a cooperative initial state.
   - For subsequent rounds, TfTA copies its previous action (C or D) depending on whether everyone else cooperated or defected in the last round. If all players cooperated in the previous round (total_contributions = n), then TfTA continues to cooperate (C_i,t = 1). Otherwise, if there was at least one defection (total_contributions < n), TfTA defects in the current round (C_i,t = 0).
   - This tit-for-tat approach maintains a cooperative relationship as long as others do so, but retaliates with defections if cooperation is broken.

2. Handle edge cases:
   - In the last round, TfTA does not need to consider future payoffs or potential repercussions of its actions, so it simply copies its previous action (C_i,r = C_i, r-1).
   - In the first round, TfTA cooperates to establish a cooperative initial state. It assumes others will also cooperate in the first round due to the game's common knowledge assumptions and the possibility of reciprocity.

3. Be exploitative:
   - While TfTA primarily aims to maintain cooperation, it is designed to be exploitative by retaliating with defections when others do not cooperate. This ensures that TfTA does not get taken advantage of by uncooperative opponents while still providing opportunities for collaboration.
   - In essence, TfTA cooperates as long as others reciprocate, but it will not continue to cooperate indefinitely if cooperation is not mutual.

Pseudocode:
```python
def tit_for_tat_adaptive(n, r, k):
    previous_round = 0 # initialize previous round action (C=1 or D=0)

    for t in range(1, r+1):
        total_contributions = sum([previous_action for previous_action in previous_actions])
        if total_contributions == n: # everyone cooperated
            current_action = 1 # continue cooperation
        else: # at least one defection
            current_action = 0 # defect
        payoff = (1 - current_action) + (k/n) * total_contributions
        previous_actions.append(current_action) # update previous actions for next round
        return payoff # return payoff for this round
```
'''

description_EXPLOITATIVE_401 = '''
 In this N-Player Public Goods Game, the goal of the exploitative strategy is to maximize payoffs by taking advantage of other players who may cooperate, while minimizing contributions without being penalized too much when others also defect. Here's a description of the strategy:

1. Decision rules:
   - In each round, calculate an 'average cooperation rate (ACR)' as a moving average based on previous rounds' total_contributions.
   - If ACR is below a predefined threshold (e.g., 0.5), defect to encourage others to follow suit and increase personal payoff.
   - If ACR exceeds the threshold, cooperate to reap the benefits of the public good but not contribute too much to avoid being exploited by over-cooperative opponents.
   - The threshold can be adjusted based on k and n game parameters, with a lower threshold for smaller k or higher n values (i.e., a more exploitative strategy).

2. Handle edge cases:
   - In the first round, there is no moving average, so defect to minimize personal contribution.
   - In the last round, evaluate the ACR based on available data and make a decision accordingly.
   - If the game restarts after some rounds (e.g., in finite horizon scenarios), reset the ACR calculation to the most recent observations.

3. Be exploitative:
   - The strategy seeks to take advantage of other players' cooperative tendencies while minimizing its own contributions when others defect.
   - By adapting to the average cooperation rate, the strategy is more likely to do better than a naive strategy that always cooperates or always defects, especially in games with a wide range of opponent behaviors.

Pseudocode:
```
def play_game(n, k, r):
    rounds = []
    cooperation_threshold = 0.5
    ACR = 0.0

    def decision_rule(ACR):
        return "C" if ACR >= cooperation_threshold else "D"

    for t in range(1, r+1):
        action = decision_rule(ACR)
        total_contributions += 1 if action == "C" else 0
        payoff_this_round = (1 - action) + (k/n) * total_contributions
        ACR = ((t-1)*ACR + total_contributions)/t
        rounds.append((action, payoff_this_round))

    return rounds, total_payoff
```
'''

description_EXPLOITATIVE_402 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (in the first round), cooperate to foster a potential cooperative environment.
   - Subsequent rounds:
     - If opponent cooperated in the previous round, cooperate in the current round.
     - If opponent defected in the previous round, defect in the current round as retaliation.
   - In the last round, cooperate regardless of the opponent's previous action to potentially maximize the payoff for that specific round.

2. Handle edge cases:
   - If the opponent starts with cooperation but switches to defection during the game, TFT-A will continue defecting until the opponent cooperates again. Once the opponent cooperates, TFT-A resumes its cooperative response.
   - In the event that multiple opponents switch from cooperation to defection simultaneously, TFT-A will also switch to defection to avoid being exploited. However, if any opponent returns to cooperation afterward, TFT-A will resume cooperating with them while maintaining defection against other defectors.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFT-A takes a moderate approach to be neither excessively cooperative nor overly aggressive, allowing it to adapt to various opponent behaviors and potentially outperform opponents that rely solely on either cooperation or defection.
   - By retaliating against defectors but also forgiving cooperation, TFT-A aims to encourage cooperation when possible while still protecting its own payoff against exploitative opponents. This creates a balance between being cooperative and exploitative in order to maximize overall performance within the given constraints.

Pseudocode for Tit-for-Tat with Adaptation strategy:

```
def tft_a(opponent, round, r, n, k):
  cooperation = True  # start cooperative
  payoff = 0

  for t in range(1, r+1):
    if t == 1:  # first round
      action = cooperation
    elif t == r:  # last round
      action = cooperation
    else:
      if opponent_action[t-1] == action:  # same as previous round
        action = cooperation
      else:  # different from previous round
        action = not action

    payoff += (1 - action) + (k/n * sum(opponent_cooperation))
    opponent_action[t] = action  # record opponent's action in this round

  return payoff
```
'''

description_EXPLOITATIVE_403 = '''
 Strategy Name: Tit-for-Tat (with Adaptive Cooperation Threshold)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment. This initial cooperation may encourage others to reciprocate in subsequent rounds. (C)
   - If an opponent has cooperated in the previous round, cooperate in the current round. This is a form of Tit-for-Tat strategy, where cooperation is matched with cooperation and defection is matched with defection. (If previous_round_opponent_action == C, then Cooperate)
   - If an opponent has defected in the previous round and the total number of cooperators (total_contributions) exceeds a certain threshold, cooperate to maintain the current cooperation level. This adaptive aspect allows for robustness against overly exploitative opponents who occasionally cooperate. (If previous_round_opponent_action == D AND total_contributions > adaptation_threshold, then Cooperate)
   - If an opponent has defected in the previous round and the total number of cooperators is below the threshold, defect to punish the opponent for their previous defection. The threshold ensures some tolerance for occasional defections. (If previous_round_opponent_action == D AND total_contributions <= adaptation_threshold, then Defect)
   - If it's the last round, defect since there are no future rounds to consider. (If current_round == r, then Defect)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - If it's the last round and the strategy is faced with a cooperator, defect to gain the maximum possible payoff for that round.
   - If it's the last round and the strategy is faced with a defector, cooperate to potentially get a higher payoff compared to defection since there are no future rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   - The Tit-for-Tat approach ensures cooperation when others cooperate but also punishes opponents who defect, which is exploitative in nature as it takes advantage of their defections while still maintaining some level of cooperation to benefit from the public good.
   - The adaptive threshold allows for robustness against overly exploitative opponents who occasionally cooperate, giving them an opportunity to cooperate without being punished immediately but also ensuring that they are not rewarded too much for occasional acts of cooperation.
'''

description_EXPLOITATIVE_404 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a goodwill gesture and can encourage others to cooperate as well.
   - For subsequent rounds t > 1:
     - If opponent cooperated in the previous round (t-1), cooperate in the current round (t). This mirrors their cooperation and encourages continued cooperation.
     - If opponent defected in the previous round (t-1), defect in the current round (t). This is a punishment for defection, but leaves open the possibility of reconciliation if the opponent starts cooperating again.

2. Handle edge cases:
   - Last round: Cooperate, as it may encourage opponents to reciprocate and improve overall game performance.
   - Special cases like rounds where all opponents defect can be managed within the TFT-AC algorithm by introducing a threshold for defection punishment, allowing occasional forgiveness (e.g., after every K consecutive defections, cooperate).

3. Be exploitative:
   - The TFT-AC strategy is inherently exploitative in that it capitalizes on the opponent's cooperation while only occasionally defecting to punish defection. However, it also promotes cooperation by reciprocating good behavior. This creates an environment where opponents may find it difficult to consistently exploit this strategy while still maintaining a high payoff.
   - To further enhance the exploitative nature of the TFT-AC strategy, consider implementing an "escalation" mechanism where the forgiveness threshold K increases over time if the opponent continues to defect. This makes defection more costly for the opponent and encourages them to cooperate.
'''

description_EXPLOITATIVE_405 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C). Start with goodwill, assuming the other players will reciprocate in later rounds.
   - Subsequent Rounds (2 ≤ t ≤ r):
     - If opponent cooperated in previous round: Cooperate (C) to maintain mutual cooperation and receive higher payoff.
     - If opponent defected in previous round: Defect (D). Punish the opponent for defection, hoping they will switch to cooperation in the next round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round (t=1): As mentioned above, cooperate (C).
   - Last Round (t=r): Considering there is no future interaction, always defect (D) to maximize individual payoff in the final round.
   - Intermediate Rounds (2 ≤ t < r): Follow the ATFT decision rules as described earlier.

3. Be exploitative - Align with the exploitative mindset:
   - Initially, be cooperative and hope others follow suit to maximize collective payoff. If opponents are also cooperative, both parties will benefit.
   - If an opponent defects, punish them by defecting in the next round. This sends a signal that defection is not beneficial in this game, incentivizing the opponent to cooperate again.
   - The strategy aims to balance cooperation and punishment such that opponents are exploited when they defect while maintaining mutual cooperation when possible.
'''

description_EXPLOITATIVE_406 = '''
 In this Public Goods Game, I propose a strategic approach that I call Tit-for-Tat with Adaptive Contribution (TFTAC). The aim of TFTAC is to cooperate when possible but punish defectors effectively and adaptively, while minimizing self-punishment.

1. Specify decision rules:
   - In the first round (t=1), play C (Cooperate) as a goodwill gesture to initiate cooperation.
   - From t=2 to r-1, analyze the number of cooperators in the previous round (total_contributions) and adjust your contribution accordingly:
     - If total_contributions >= (n/2), play C (Cooperate) to maintain the cooperative environment.
     - If total_contributions < (n/2), play D (Defect) as a punishment for those who defected in the previous round.
   - In the last round (t=r), play C (Cooperate) since there are no more rounds to retaliate or cooperate.

2. Handle edge cases:
   - If n is odd and total_contributions = (n-1)/2, play D (Defect) to avoid being in the minority and losing out on the public good.
   - If a player encounters a tie in the number of cooperators from the previous round (total_contributions=x and x-1 also exist), play C (Cooperate). This rule helps maintain a balance between cooperation and defection to minimize self-punishment.

3. Be exploitative:
   - TFTAC is designed with an exploitative mindset by retaliating against defectors and punishing them for their actions, while cooperating when it benefits the player in terms of payoff. This strategy also encourages cooperation among players who consistently contribute to the public good.
   - To further improve the exploitative nature, TFTAC can include a learning component that tracks the history of interactions with specific opponents and adjusts its response accordingly based on their behavior (e.g., if an opponent is consistently uncooperative, TFTAC may choose to defect more frequently when interacting with them).

TFTAC pseudocode:
```
function TFTAC(round, total_contributions, opponents_history):
  if round == 1:
    action = 'C'
  elif round < r and round != r-1:
    if total_contributions >= (n/2):
      action = 'C'
    else:
      action = 'D'
  elif round == r or (round > r - 1 and len(opponents_history) > 0):
    if len(total_contributions) <= 1:
      action = 'C'
    else:
      action = opponents_history[-1]
  return action
```
This strategy aims to balance cooperation with defection, adaptively punishing defectors while minimizing self-punishment. By incorporating a learning component, TFTAC can further optimize its performance against various opponent behaviors in the tournament.
'''

description_EXPLOITATIVE_407 = '''
 Strategy Name: Adaptive Tit-for-Tat with Modified Contribution (ATTC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the ATTC strategy follows these steps to decide whether to cooperate or defect:

- If it's the first round, the strategy will cooperate to encourage cooperation from other players.
- If a player has cooperated in the previous round, the strategy will also cooperate in the current round as a reciprocal gesture.
- If a player has defected in the previous round, the strategy will retaliate by defecting in the current round. However, the amount contributed is adjusted based on the number of other players who cooperated in the previous round (n_c). The contribution is set to the minimum required for receiving any benefit from the public good:
   - If n_c = 1, contribute the minimum required amount (k/n)
   - If n_c > 1, contribute a fraction of the minimum required amount proportional to the number of cooperators in the previous round ((k/n)*(n_c / n)).
- In the last round, the strategy will cooperate if it has earned more payoff compared to defecting over the entire game (total_payoff_cooperative > total_payoff_defective). If not, it will defect.

Pseudocode:
```
function ATTC(round, history, n, k):
  if round = 1:
    contribution = 1
  else:
    (previous_round, previous_contribution) = history[round - 1]
    n_c = countCooperators(previous_round)
    if previous_contribution == 1:
      contribution = 1
    elif n_c == 1:
      contribution = k/n
    else:
      contribution = (k/n)*(n_c / n)

  total_payoff_cooperative = sumPayoffsFromCooperation(history)
  total_payoff_defective = sumPayoffsFromDefection(history)

  if round == r and total_payoff_cooperative > total_payoff_defective:
    contribution = 1

  return contribution
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In addition to the decision rules mentioned above, the strategy initializes history with an empty array and adds a tuple (round, contribution) at each round to keep track of previous contributions. In the first round, it initiates the history array with an empty tuple.

3. Be exploitative - Clearly align with the exploitative mindset

The ATTC strategy is designed to encourage cooperation among players, but it also retaliates when defected upon. The contribution amount is adjusted based on the number of other cooperators in the previous round, making it less advantageous for a single defector to gain disproportionate benefits from the public good. In the last round, if the strategy has not earned more payoff by cooperating compared to defecting over the entire game, it will defect.

This strategy aims at taking advantage of other players' cooperation while also being resilient to defection and adjusting its contributions accordingly.
'''

description_EXPLOITATIVE_408 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially (Round 1), the TfTA strategy cooperates to foster a cooperative environment, promoting mutual trust and benefit. Subsequent decisions are based on the opponent's behavior in the previous round:

- If opponent cooperated in the last round, TfTA cooperates in the current round.
- If opponent defected in the last round, TfTA defects in the current round as retaliation.
- If the game is near its end (last r/2 rounds), TfTA switches to a more forgiving approach and cooperates regardless of the opponent's previous move. This change in behavior aims to encourage cooperation even if the opponent has adopted an exploitative strategy, potentially incentivizing them to cooperate as well.

Pseudocode for decision rule:
```python
def TfTA(round, history):
  if round == 1:
    return 'C' # Cooperate in the first round
  else:
    last_move = history[-1] # Get opponent's last move from game history
    if last_move == 'C':
      return 'C' # Cooperate if opponent cooperated last round
    elif last_move == 'D':
      return 'D' # Defect if opponent defected last round
    elif round > r/2:
      return 'C' # Cooperate in the last r/2 rounds, regardless of history
    else:
      return 'D' # Defect if not first round and not last r/2 rounds
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

As mentioned earlier, TfTA cooperates in the first round to establish a cooperative environment. In the last round, TfTA follows its decision rule as described above, but with the added forgiveness towards the end of the game.

3. Be exploitative - Clearly align with the exploitative mindset

The TfTA strategy is exploitative in nature by retaliating against opponents who defect and cooperating with those who cooperate. This approach allows it to maintain a higher average payoff than pure cooperation strategies while also being flexible enough to adapt to various opponent behaviors, including exploitative ones. By being adaptive, TfTA aims to gain more from the game while minimizing potential losses due to repeated defection by opponents.
'''

description_EXPLOITATIVE_409 = '''
 In this strategic game, we aim to design an exploitative strategy for a player (referred to as AI) that maximizes its total payoff while minimizing the payoffs of other players, given the N-Player Public Goods Game parameters and history.

1. Decision Rules:
   - AI cooperates when it expects more than half of the players to cooperate in the next round (exploiting their cooperation), otherwise, it defects. This decision rule is based on the assumption that cooperating with a large number of players results in higher payoffs due to the shared public good.
   - If AI finds itself in a situation where all other players have already contributed to the public good and there's no possibility for AI to change their decisions, it should defect since there's no benefit in contributing to the project in that round.

Pseudocode:
```python
def decide_action(n, nb_cooperators):
    if nb_cooperators >= (n // 2) + 1: # more than half of players have cooperated
        return "Cooperate"
    else:
        return "Defect"
```

2. Handle edge cases:
   - In the first round, AI defects since it has no prior information about other players' strategies or behavior.
   - In the last round, AI cooperates if more than half of the players have already contributed to the public good, otherwise, it defects. This approach ensures that AI collects the maximum benefit from any remaining contributions towards the end of the game.

3. Be exploitative:
   - By cooperating only when a majority of other players also decide to cooperate, AI exploits their cooperation by reaping the benefits of shared public goods without fully contributing its share.
   - When faced with situations where all other players have already contributed, AI defects, ensuring that it does not contribute to the common project if other players' contributions are guaranteed. This behavior aims to minimize the total amount contributed to the public good, thus exploiting the cooperative strategies of other players.
'''

description_EXPLOITATIVE_410 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, in the first round, the agent will cooperate to foster a positive environment and encourage cooperation from other players (C).
   - In subsequent rounds, the agent will assess the number of cooperators in the previous round (n_coop_prev) and compare it against a predefined adaptive cooperation threshold (threshold). The threshold will be calculated based on the average number of cooperators over the recent history (avg_coop) multiplied by a sensitivity factor (sensitivity).
       - If n_coop_prev >= threshold, the agent will cooperate (C).
       - If n_coop_prev < threshold, the agent will defect (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, the agent cooperates (C).
   - The agent does not have any special behavior for the last round or any other specific edge cases since it is a repeated game and the strategy's focus is on exploiting short-term cooperation opportunities while maintaining long-term adaptability.

3. Be exploitative - Clearly align with the exploitative mindset
   - By initially cooperating, the agent aims to encourage cooperation from others, but as soon as it detects a decline in cooperation (threshold not met), it will defect to gain an advantage and punish those who do not reciprocate cooperation. This tit-for-tat approach allows for exploitation when necessary while still maintaining some level of initial cooperation to foster cooperative behavior among opponents.

Pseudocode:

```python
def TFT_ACT(r, n, k, sensitivity):
    avg_coop = 0
    threshold = 0
    history = []

    for round in range(1, r+1):
        if round == 1:
            action = 'C'  # Cooperate in the first round
            history.append('C')

        else:
            n_coop_prev = len(history) of 'C' from previous rounds
            avg_coop = sum(history) of 'C' / (round - 1)
            threshold = avg_coop * sensitivity

            if n_coop_prev >= threshold:
                action = 'C'  # Cooperate when the threshold is met or exceeded
            else:
                action = 'D'  # Defect when the threshold is not met
            history.append(action)

    return action for each round
```

In this pseudocode, the sensitivity factor can be adjusted to fine-tune the strategy's exploitative nature and adaptive cooperation threshold. A lower sensitivity will result in a more forgiving agent that requires a higher average level of cooperation to defect, while a higher sensitivity means the agent will defect more easily when it perceives a decline in cooperation.
'''

description_EXPLOITATIVE_411 = '''
 Title: Tit-for-Tat-K Strategy (TfT-K)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT-K begins by cooperating in the first round to foster a cooperative environment. After the initial round, its decisions for subsequent rounds are based on the average cooperation rate of the previous (r-1) rounds:
   - If the average cooperation rate is greater than or equal to k/n, TfT-K will cooperate. This reflects an attempt to reciprocate cooperative behavior and maintain a cooperative relationship.
   - If the average cooperation rate is less than k/n, TfT-K will defect. This represents a punishment for uncooperative players and an attempt to encourage them to cooperate in future rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate as a goodwill gesture to build a relationship with opponents.
   - Last Round: Since the game is repeated over r rounds, TfT-K will make its decision based on the average cooperation rate of the previous (r-1) rounds. If the average cooperation rate exceeds k/n, TfT-K cooperates; otherwise, it defects.
   - Any other edge cases, such as mid-game changes in the average cooperation rate, are handled by calculating the average based on the available data and making a decision accordingly for the current round.

3. Be exploitative - Clearly align with the exploitative mindset:
   TfT-K's exploitative nature comes from its strategic use of punishment (defecting) when the average cooperation rate falls below k/n. This punishes uncooperative players and may encourage them to change their behavior in future rounds, thus benefiting TfT-K. Additionally, TfT-K cooperates when appropriate, which can help foster a more cooperative environment that could potentially benefit it if other players also tend towards cooperation. However, it does not actively seek out opportunities to exploit others and instead focuses on maintaining a balance between cooperation and punishment based on the average cooperation rate.

Pseudocode:
```
def TfT_K(history, n, k):
  if round == 1:
    action = 'C' # Cooperate in first round as a goodwill gesture
  else:
    avg_cooperation_rate = sum(history[-r:-1]) / r
    if avg_cooperation_rate >= k/n:
      action = 'C' # Cooperate to reciprocate cooperative behavior
    else:
      action = 'D' # Defect as a punishment for uncooperative players
  return action
```
'''

description_EXPLOITATIVE_412 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a peaceful gesture to encourage cooperation from opponents and reduce initial uncertainty.
   - For subsequent rounds, observe the opponent's previous action and respond accordingly. If the opponent has contributed in the last round (c_opponent = 1), also contribute (C). Otherwise, defect (D) to retaliate against non-contribution.

```python
def TFTAC(opponent_history):
    if len(opponent_history) == 0:
        return 'C'  # Cooperate in the first round

    last_action = opponent_history[-1]
    if last_action == 'C':
        return 'C'  # Cooperate if the opponent contributed last round
    else:
        return 'D'  # Defect if the opponent did not contribute last round
```

2. Handle edge cases:
   - In the last round, defect (D) since there will be no more opportunities for retaliation or future cooperation. This strategy ensures that TFTAC will not become overly generous in the final round.

3. Be exploitative:
   - The TFTAC strategy maintains a balance between cooperating and defection based on the opponent's actions, thus minimizing losses due to repeated non-cooperation while maintaining an opportunity for reciprocity when opponents decide to contribute.
   - By adapting its behavior based on the opponent's history, this strategy exploits predictable patterns in the opponent's contributions and maximizes private payoff over multiple rounds.
'''

description_EXPLOITATIVE_413 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Decision Rules (Cooperate vs Defect):
   - Initial Round (t=1): Cooperate (C) to contribute to the public good and encourage others to do so, setting a cooperative norm.
   - Subsequent Rounds (2 ≤ t ≤ r): If player i's opponent cooperated in the previous round (c_j = 1), then also cooperate (C). Otherwise, defect (D) as punishment for non-cooperation.

Pseudocode:
```
function titForTat(t, history):
    if t == 1:
        return "Cooperate"
    else:
        last_opponent_action = history[t-1]
        if last_opponent_action == "Cooperate":
            return "Cooperate"
        else:
            return "Defect"
```

2. Handle Edge Cases:
   - Last Round (t=r): Since the opponent's actions in this round will not affect payoffs in subsequent rounds, it is best to punish non-cooperation as usual, even if it is the last round.

Pseudocode:
```
function adjustForLastRound(history):
    if len(history) == r:
        return history
    else:
        adjusted_history = history + ["Defect"]
        return adjusted_history
```

3. Be Exploitative: The Tit-for-Tat strategy exploits cooperation by cooperating in the initial round and punishing defection, but it also rewards cooperation with continued cooperation to encourage others to continue being cooperative. However, once an opponent has defected, the player will not cooperate again until the opponent returns to cooperation. This creates a balance between cooperation and punishment that can exploit opponents who lack a long-term cooperative strategy.
'''

description_EXPLOITATIVE_414 = '''
 Strategy Name: Tit-for-Tat with Time-Delayed Response (TFTD)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially in the first round, defect (play D) to avoid being taken advantage of by potential exploiters.
   - After the first round, analyze past actions of opponents and respond accordingly:
      - If an opponent has previously cooperated, cooperate (play C). This reciprocates their cooperation.
      - If an opponent has previously defected, defect (play D) to punish them for their lack of cooperation.
   - In case of a tie (multiple opponents have the same past actions), default to cooperating to encourage potential cooperation in the future.
   - To avoid excessive punishment, after a series of defections from an opponent, start cooperating again with a time-delay factor:
      - If t is the number of rounds since the opponent last cooperated and τ is a predefined time-delay parameter (0 < τ < r), then start cooperating at round t + τ.
      - This allows for gradual forgiveness, encouraging opponents to reconsider their strategy.

2. Handle edge cases:
   - In the last round, if there is a positive relationship with any opponent, cooperate to potentially secure their cooperation in previous rounds' payoffs.
   - If an opponent defects on the very first round, respond with defection for all subsequent rounds. This teaches them that unilateral defection will not be rewarded.

3. Be exploitative:
   - The strategy is designed to take advantage of opponents who do not cooperate, by punishing them and potentially encouraging future cooperation through reciprocity.
   - However, it also forgives opponents who make mistakes or switch strategies, providing an opportunity for them to rebuild a positive relationship.
   - By combining exploitative punishment with forgiveness and gradual response, the strategy maintains a balance between being unyielding towards uncooperative opponents while still encouraging potential cooperation in the future.

Pseudocode:
```
def TFTD(opponent_history, r, n, k, τ):
    # Initialize state variables
    own_strategy = []
    opponent_strategy = []
    payoffs = []

    # Initialize decision rule for the first round
    if round == 1:
        own_strategy.append('D')

    # Update strategies, payoffs and history in each round
    for t in range(r):
        # Calculate current strategy based on opponent's history
        if all(opponent[t] == 'D' for opponent in opponent_history):
            own_strategy.append('D')
        elif any(opponent[t] == 'C' for opponent in opponent_history) and t > τ:
            own_strategy.append('C')
        else:
            own_strategy.append('D')

        # Calculate payoff based on game parameters and current strategy
        payoff = calculate_payoff(own_strategy[t], opponent_history, n, k)

        # Update history, strategies and payoffs
        opponent_history.append(own_strategy[t])
        payoffs.append(payoff)

    return payoffs
```
'''

description_EXPLOITATIVE_415 = '''
 Title: Tit-for-Tat-K (TFT-K) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - TFT-K adopts a tit-for-tat approach with slight modifications to cater for the public goods game dynamics. Each player maintains a memory of their opponent's previous actions and responds accordingly in the current round.
   - If an opponent cooperates (C), the strategy cooperates as well (C).
   - If an opponent defects (D), the strategy also defects unless the number of cooperators in the current round exceeds a certain threshold, denoted as t_k (explained below). In this case, even if the opponent defected, the strategy will still cooperate.
   - The threshold, t_k, is determined by the multiplication factor k and is calculated as (k/2) - 1. This means that the strategy tends to cooperate when at least (k/2 + 1) players are willing to contribute in a given round.

2. Handle edge cases:
   - First round: The strategy starts by cooperating, assuming cooperation might lead to more potential benefits in the future.
   - Last round: The strategy considers the total number of cooperators in all previous rounds and applies the TFT-K decision rule based on that history.

3. Be exploitative:
   - By adhering to the tit-for-tat approach, the strategy initially encourages cooperation but will also retaliate against repeated defections by defecting itself, which aligns with an exploitative mindset. The adaptive nature of TFT-K allows it to be resilient against various opponent behaviors and takes advantage of opponents who are overly cooperative or defective.
   - However, the strategy also encourages cooperation when there is a sufficient number of players contributing in a given round, which potentially benefits both itself and other cooperating opponents. This ensures that TFT-K does not solely rely on exploiting others but can also benefit from cooperation when it is advantageous.

Pseudocode for the Tit-for-Tat-K strategy:
```
function TFT_K(history, k, t_k) {
  if (round == 1) {
    action = 'C'
  } else {
    if (num_cooperators(history) >= t_k) {
      action = 'C'
    } else if (opponent_action(history[-1]) == 'C') {
      action = 'C'
    } else {
      action = 'D'
    }
  }
}
```
The `num_cooperators()` function calculates the number of cooperative actions in a given history, and the `opponent_action()` function retrieves the opponent's action from the previous round. The initial state for each player should be defined with an empty history and default actions set to 'C'.
'''

description_EXPLOITATIVE_416 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TfT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to establish a cooperative environment (C).
   - For subsequent rounds, evaluate opponents' behavior using a "cooperative score" (CS). If the CS is above a certain threshold (T), cooperate; otherwise, defect (D).

Pseudocode for determining action:
```python
def decide_action(round, CS, T):
    if round == 1:
        return 'C'
    elif CS >= T:
        return 'C'
    else:
        return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - For the first round, cooperate regardless of the situation (as mentioned above).
   - In the last round, always defect since there are no future interactions with opponents (TfT-AC will not need to remember past actions from this point onwards).
   - When the number of remaining rounds is less than a certain threshold (L), TfT-AC starts defecting to increase its own payoff.

Pseudocode for initializing and updating CS:
```python
def initialize_CS():
    return 1  # Starting cooperative score as 1 to encourage cooperation

def update_CS(opponent_action, round):
    if round < L:
        if opponent_action == 'C':
            CS += 1 - CS  # Reward cooperation with a reciprocal increase in CS
        else:
            CS *= (1 - penalty)  # Punish defection by reducing CS
    return CS
```

3. Be exploitative - Clearly align with the exploitative mindset
   - TfT-AC starts as cooperative but quickly switches to an exploitative approach when opponents are not cooperating enough (CS < T). This allows TfT-AC to gain more payoff from defectors while still benefiting from cooperative opponents.
   - The adaptive nature of the strategy ensures robustness across a wide range of opponent behaviors, as it can adjust its cooperative level based on observed actions.

Additional considerations:
- T and L can be adjusted to balance exploitation and cooperation, depending on the desired strategy behavior (e.g., more cooperative or more aggressive).
- The penalty factor can also be fine-tuned to control the punishment for defection. A higher penalty makes it harder for opponents to switch from cooperation to defection.
'''

description_EXPLOITATIVE_417 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTG)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the TFTG strategy will initially cooperate in the first few rounds to foster a cooperative environment. After that, it will respond to other players' actions from the previous round. If an opponent cooperates, TFTG will also cooperate; if an opponent defects, TFTG will defect as well. This mimics the "Tit for Tat" strategy but allows gradual cooperation at the start.

Pseudocode:
```
function tftg(round, previous_opponent_action, n, k):
  if round <= initial_cooperation_rounds:
    return 'C' (Cooperate)
  else:
    return previous_opponent_action
```
Parameters:
- `initial_cooperation_rounds`: The number of initial rounds for gradual cooperation

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, TFTG will cooperate to foster a cooperative environment. In the last round, TFTG may still respond to the opponent's action from the previous round, since it doesn't know if the game continues beyond the specified rounds or not.

3. Be exploitative - Clearly align with the exploitative mindset
Although primarily focused on responding to opponents, TFTG can be considered exploitative as well. By initially cooperating, TFTG encourages others to cooperate, which maximizes the average payoff per round for all players (assuming everyone cooperates). Once other players start defecting, TFTG follows suit and reduces its own payoff less than if it had started defecting from the beginning. This makes TFTG appear more cooperative initially but exploitative when others become uncooperative.

To further enhance the exploitative nature, TFTG can include a feature to adjust `initial_cooperation_rounds` based on historical data, learning which number of initial rounds maximizes payoff in the long run against different opponent strategies. This adaptability ensures that TFTG remains effective and competitive across various scenarios.
'''

description_EXPLOITATIVE_418 = '''
 Title: Tit-for-Tat-Cooperative (TFT-C) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In the initial round (t=1), cooperate (play C): TFT-C starts by being cooperative to promote a positive environment and encourage cooperation from others.
   - From the second round (t>1) until the last round, analyze opponent's behavior in previous rounds:
     a. If an opponent also cooperated in the previous round, cooperate in the current round (play C).
     b. If an opponent defected in the previous round, defect in the current round (play D). This punishes opponents who have chosen to be uncooperative while rewarding those who cooperate.

2. Handle edge cases:
   - In the last round (t=r), cooperate if all players cooperated in the previous round; otherwise, defect: TFT-C still maintains a cooperative approach when others are being cooperative but retaliates against uncooperative opponents in the final round.
   - In the first round (t=1), cooperate as mentioned earlier to promote cooperation.

3. Be exploitative:
   - TFT-C is designed with an exploitative mindset by punishing defectors and rewarding cooperators, which encourages cooperative behavior while also benefiting from opponents' mistakes or lack of cooperation.

Pseudocode:
```
function TFT-C(n, k, r, t, history) {
  if (t == 1) return C; // Cooperation in the first round

  opponent_behavior = get_opponent_behavior(history[t-1]); // Extract opponent's action from previous round

  if (opponent_behavior == C) return C; // Cooperate if opponent cooperated in the previous round
  else if (opponent_behavior == D && t != r) return D; // Defect if opponent defected and it's not the last round
  else if (t == r) { // Last round
    if (all_players_cooperated_in_previous_round(history)) return C;
    else return D;
  }
}
```
'''

description_EXPLOITATIVE_419 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to build a good relationship with other players (C).
   - For subsequent rounds (t > 1), observe the action of the player in the previous round (t-1) and respond accordingly:
     - If opponent cooperated (c_opponent = 1), cooperate (C) as a sign of trust and reciprocity.
     - If opponent defected (c_opponent = 0), defect (D) to punish the opponent for their previous actions, but revert to cooperating in the next round (t+1).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of the opponents' actions since no prior information is available.
   - In the last round, if the total number of cooperators is greater than a predefined threshold (n_coop_threshold), defect to maximize personal payoff since the game ends soon. Otherwise, continue cooperating (c_i = 1) to encourage more cooperation from opponents.

3. Be exploitative - Clearly align with the exploitative mindset
   - By starting with cooperation and only defecting in response to defection, the strategy is designed to take advantage of opponents who do not reciprocate cooperation while maintaining cooperation with those who do.
   - If an opponent frequently cooperates (c_opponent > n_cooperation_percentage), TfT-A will also cooperate more frequently (c_i > n_cooperation_percentage) to maximize the gain from mutual cooperation, exploiting opponents that have a higher tendency to cooperate.
   - If an opponent frequently defects (c_opponent < n_defection_percentage), TfT-A will also defect more frequently (c_i < n_cooperation_percentage) to minimize losses from defection, exploiting opponents that have a higher tendency to defect.

Pseudocode:
```
function TitForTatAdaptive(r, k, n, n_coop_threshold, n_defection_percentage, n_cooperation_percentage) {
  currentRound = 1
  playerHistory = []

  function getOpponentCooperationPercentage() {
    totalCooperators = sum(playerHistory.map(action => action == "C"))
    return (totalCooperators / currentRound) * 100
  }

  function getPlayerCooperationPercentage() {
    ownCooperationCount = playerHistory.filter(action => action == "C").length
    return (ownCooperationCount / currentRound) * 100
  }

  while (currentRound <= r) {
    if (currentRound == 1) {
      action = "C" // cooperate in the first round
    } else {
      opponentCooperationPercentage = getOpponentCooperationPercentage()
      playerCooperationPercentage = getPlayerCooperationPercentage()

      if (opponentCooperationPercentage > n_defection_percentage && playerCooperationPercentage > n_cooperation_percentage) {
        action = "C" // cooperate if opponent and self have a high tendency to cooperate
      } else if (opponentCooperationPercentage < n_defection_percentage && playerCooperationPercentage > n_cooperation_percentage) {
        action = "D" // defect if opponent has a high tendency to defect but self has a high tendency to cooperate
      } else if (opponentCooperationPercentage > n_defection_percentage && playerCooperationPercentage < n_cooperation_percentage) {
        action = "D" // defect if opponent and self have a high tendency to defect
      } else {
        action = "C" // cooperate in other cases
      }
    }

    playerHistory.push(action)
    currentRound++
  }

  return playerHistory
}
```

This strategy aims to balance cooperation and defection based on the history of opponents' actions, making it adaptive and robust to a wide range of opponent behaviors while maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_420 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, play C to encourage cooperation and foster a positive initial environment.
   - For subsequent rounds t (t > 1), if the number of cooperators in round t-1 is equal to or greater than n/2 (majority rule), continue cooperating with C. Otherwise, defect by choosing D to punish non-cooperative behavior and encourage future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, play C as mentioned above.
   - In the last round, since the game is repeated, the strategy should still consider the majority rule from the previous round to decide whether to cooperate or defect. This encourages long-term cooperation even in the final stages of the game.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFT-AC takes an exploitative approach by punishing non-cooperative players and rewarding cooperative ones. However, it is important to note that the strategy also rewards cooperation by reciprocating when the majority of players cooperate. This combination allows for a balance between exploitation and cooperation, maximizing payoffs in the long run while still being robust against various opponent behaviors.

Pseudocode:
```
function TFT_AC(r, n, k):
    rounds = [1] * r       # initialize game rounds

    for round in range(2, r+1):
        total_cooperators = sum(rounds[round-1])   # calculate number of cooperators in previous round
        if total_cooperators >= n/2:               # check if majority cooperated
            rounds[round] = C                      # continue cooperation
        else:                                       # punish non-cooperative players
            rounds[round] = D

    payoff = 0                # initialize total payoff
    for round in rounds:
        payoff += calculate_payoff(round, n, k)     # calculate payoff for each round using given formula

    return payoff              # return total payoff
```
'''

description_EXPLOITATIVE_421 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Specify decision rules:
   - In the initial round, cooperate to show goodwill and encourage cooperation from other players.
   - For subsequent rounds, analyze the total contribution of each player in the previous round (Tc_i). If Tc_i >= average total contribution (AvgTC), cooperate; otherwise, defect. This rule encourages cooperation when it is common but punishes freeriders.
   - Modify the cooperation threshold based on the current round to be more forgiving early in the game and more demanding as the game progresses:
       ```
       Threshold(round) = AvgTC * (1 - (round / r))
       ```

2. Handle edge cases:
   - In the last round, prioritize a higher total payoff over cooperating; defect if necessary to maximize personal benefit.
   - In the first round, as mentioned above, cooperate to show goodwill and encourage cooperation from other players.

3. Be exploitative:
   - The strategy is inherently exploitative by punishing freeriders who contribute less than the average while rewarding cooperative players. However, it also incentivizes cooperation when it benefits the player in terms of total payoff over multiple rounds.
   - The adaptive contribution rule ensures that the player contributes more when other players are contributing more and vice versa, making it harder for opponents to exploit the strategy consistently.
'''

description_EXPLOITATIVE_422 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - In the first round, play C to foster a cooperative environment. This initial cooperation may encourage others to follow suit.
   - For subsequent rounds, observe the actions of other players in the previous round. If all players cooperated (total_contributions == n), continue cooperating (play C).
   - If any player defected (total_contributions < n), defect (play D) in the current round as retaliation. This response is designed to discourage defection while maintaining a balance between cooperation and self-interest.
   - In the last round, play C if all players cooperated in the previous round to maximize potential payoff; otherwise, play D as a final act of retaliation for any earlier defections.

2. Handle edge cases:
   - If a player encounters an empty or unresponsive opponent (i.e., no action from the opponent in a given round), they should follow the strategy's decision rules based on their own and other players' previous actions.
   - In case of ties (total_contributions == n-1), the player should play C to maintain cooperation and potentially encourage others to cooperate as well.

3. Be exploitative:
   - The TFTA strategy is inherently exploitative in that it retaliates against defection with defection while rewarding cooperation with continued cooperation. This approach aims to foster a sustainable equilibrium of mutual cooperation whenever possible, but punishes defectors when necessary.

Pseudocode:

```python
def TFTA(r, n, k):
    total_contributions = [0 for _ in range(r+1)]  # Initialize total contributions per round
    history = [['C' for _ in range(n)], []]  # Initialize player actions history

    for t in range(1, r+1):
        current_actions = collect_player_actions()  # Collect current players' actions
        total_contributions[t] = sum(current_actions)
        history[1].append(current_actions)

        if t == 1:  # First round
            action = 'C'
        elif total_contributions[t] == n:  # All players cooperated
            action = 'C'
        else:  # Any player defected
            action = 'D'

        payoff = (1 - action) + (k/n) * total_contributions[t]
        print(f"Round {t}: Payoff = {payoff}")
        history[0][t-1] = action  # Record player action for future reference

    final_action = choose_final_round_action(history, total_contributions)
    payoff += (1 - final_action) + (k/n) * total_contributions[-1]
    print(f"Last Round: Payoff = {payoff}")
```
'''

description_EXPLOITATIVE_423 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initially (first round), cooperate to create a positive atmosphere and encourage cooperation from others (C).
   - In subsequent rounds, observe the total number of cooperators in the previous round (total_contributions_prev) and compare it with a threshold determined by the game parameters k and n. If total_contributions_prev > k/2 * n, then cooperate (C), otherwise defect (D).
   - In the last round, since there are no future interactions, always cooperate (C) to maximize potential payoff, regardless of past actions by others.

Pseudocode:
```
function tit_for_tat(round, total_contributions_prev, k, n):
  if round == 1:
    return 'C'  # Cooperate in the first round to encourage cooperation

  if total_contributions_prev > (k/2) * n:
    return 'C'  # If majority cooperated in previous round, cooperate
  else:
    return 'D'   # If majority did not cooperate in previous round, defect

  if round == r:  # Last round
    return 'C'  # Always cooperate in the last round to maximize payoff
```

2. Handle edge cases:
   - The first round is already accounted for in the decision rule above.
   - In case of tie when determining the majority, consider it a cooperation since we favor cooperation over defection.
   - If there are no other players (n=1), always cooperate as there's no one to defect against.

3. Be exploitative:
   - By adapting to the number of contributors in each round, our strategy will try to take advantage of cooperative opponents while not being too vulnerable to exploitation by defectors.
   - In the first round, we show our cooperative nature, but quickly switch to an adaptive strategy that punishes defection when a majority defects. This could encourage other players to cooperate since they'll face punishment for defecting.
   - Our strategy is designed to discourage pure defection and encourages a stable level of cooperation among opponents, making it exploitative in the sense that it tries to extract as much public good as possible by leveraging cooperation from others while also punishing defection when needed.
'''

description_EXPLOITATIVE_424 = '''
 Strategy Name: Tit-for-Tat with Time Discounting (TfT-TD)

1. Specify decision rules:
   - In every round t, start by cooperating unless it's the first round or the last r/3 rounds.
   - If a player has consistently defected in the past r/2 consecutive rounds (punishment window), also defect for the next r/2 rounds (tit-for-tat).
   - To make the strategy more robust and less vulnerable to long streaks of defection, introduce time discounting: reduce the punishment window's impact on future decisions by a factor decreasing exponentially over time. The formula for this is:
     penalty_factor(t) = 1 - (0.95^((t-1)/r))

2. Handle edge cases:
   - In the first round, cooperate to signal good intentions and foster cooperation.
   - In the last r/3 rounds, cooperate to gain any potential benefits from late cooperation or demonstrate goodwill for future games.
   - If the game is not yet in the punishment window, but an opponent defects, reset the counter to 0 and calculate the new penalty_factor. If the opponent then continues to cooperate, start a new r/2 rounds counter and resume regular decision making (cooperate unless punishment window or last round).

3. Be exploitative:
   - The strategy is designed to encourage cooperation as much as possible in the beginning and punish defection swiftly with a gradually reduced impact over time. This encourages opponents to cooperate while also ensuring that the strategy does not become too vulnerable to long streaks of defection.
   - However, since other strategies may also employ exploitative tactics, TfT-TD will continue cooperating even after being punished if an opponent returns to cooperation, in the hope of gaining higher payoffs through mutual cooperation.
'''

description_EXPLOITATIVE_425 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation threshold 't' to a value between 0 and the total number of rounds 'r'. Start by assuming all players will cooperate in the first round.
   - In each round 't':
     - If the majority (> t/n) of players cooperated in the previous round, cooperate. Otherwise, defect.
     - Update cooperation threshold 't' as follows:
       - If you cooperated and the majority cooperated back, increase 't' by a small increment.
       - If you defected and the majority still cooperated, decrease 't' by a small decrement.
       - If there is no majority (ties are broken in favor of cooperation), maintain the current 't'.

2. Handle edge cases:
   - First round: All players cooperate as assumed initially.
   - Last round: If cooperation threshold 't' is not equal to the number of rounds 'r', treat it as a normal round according to the decision rules above. Otherwise, cooperate if the majority cooperated in the previous round; otherwise defect.

3. Be exploitative - Align with the exploitative mindset:
   - By adapting cooperation threshold 't' based on past actions, the strategy is exploitative as it retaliates when other players do not reciprocate cooperation but also rewards cooperation.
   - The strategy assumes that other players will attempt to exploit by defecting more often than cooperating initially, which allows TFT-ACT to punish such behavior and encourage long-term cooperation when appropriate.

Pseudocode:

```python
def TFT_ACT(n, r, k):
    t = round(r / 2)  # initialize cooperation threshold
    actions = [C for _ in range(r)]  # initialize cooperative action for all rounds

    for round_number in range(1, r + 1):
        majority = int(n * (t / n))  # number of players required to be considered a majority
        if round_number == 1:  # first round, assume all players cooperate
            actions[round_number - 1] = C
        else:
            if len([action for action in actions[:round_number] if action == C]) > majority:
                actions[round_number - 1] = C
                update_t(round_number, t)
            else:
                actions[round_number - 1] = D

    def update_t(round_number, t):
        if round_number == r or len([action for action in actions[:round_number] if action == C]) > (t + 1) / n:
            # reach the end of the game or majority cooperated, increase t
            t += 1 / (r * n)
        elif len([action for action in actions[:round_number] if action == D]) > (t - 1) / n:
            # majority defected, decrease t
            t -= 1 / (r * n)
```
'''

description_EXPLOITATIVE_426 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, the ATFT strategy starts by cooperating, mimicking initial cooperation observed in other strategies such as Tit-for-Tat. If another player cooperates in round t, the ATFT strategy continues to cooperate in the subsequent rounds. However, if a player defects in any round t, ATFT will also defect in the next round (t+1), punishing the defector for their selfish behavior. The strategy then resets its cooperation status after observing whether the defector chooses to cooperate or continue defecting in the following round (t+2).

Pseudocode:
```
function ATFT(round, history):
  if round == 1 or history[round-1] is Cooperate:
    return Cooperate
  else if history[round-1] is Defect and history[round-2] is Cooperate:
    return Defect
  else:
    return ATFT(round+1, concatenate(history, action))
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
For the first round (round=1), the strategy cooperates regardless of previous interactions or history. For the last round (round=r), if the ATFT strategy has been defected upon by another player in any round before, it will also defect in the final round to inflict one last punishment. If the ATFT strategy hasn't faced a defection yet, it will continue cooperating until the last round.

3. Be exploitative - Clearly align with the exploitative mindset
By adopting an initially cooperative approach and retaliating against defections with punishment, the ATFT strategy aims to encourage cooperation among other strategies while also taking advantage of those that are exploitative or defective in their actions. The strategy is designed to be unpredictable and harsh in its response to defection, making it difficult for opponents to consistently profit from exploiting the ATFT strategy's cooperative behavior. This adaptive and robust approach should enable the ATFT strategy to outperform other strategies over multiple rounds of the N-Player Public Goods Game.
'''

description_EXPLOITATIVE_427 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment. This is based on the premise that cooperation could initiate a sequence of reciprocal actions from other players.
     Pseudocode: if round == 1 then cooperate

   - For subsequent rounds, adopt a Tit-for-Tat strategy where cooperation is maintained if the previous action was also cooperation; otherwise, defect. This punishes defection while allowing for forgiveness in case of errors or deviations from cooperation.
     Pseudocode: if last_action == cooperate then cooperate else defect

   - To prevent being taken advantage of by overly aggressive opponents, introduce an adaptation mechanism that gradually reduces the likelihood of cooperation after consecutive defections.
     This is achieved by maintaining a score, increasing it after cooperation and decreasing it after defection. The decision to cooperate or defect is then based on this score.
     Pseudocode:
       - Initialize score = initial_score (e.g., 50)
       - Update score += 1 for cooperation, -= 1 for defection
       - Cooperate if score > threshold (e.g., 30), otherwise defect

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as explained earlier.
   - No special considerations are needed for the last round since the adaptive mechanism takes into account the current state of the game.

3. Be exploitative - Clearly align with the exploitative mindset
   - TfT-A maintains a cooperative stance in an attempt to encourage cooperation from other players, but it retaliates against defection by reducing its own cooperation and potentially inducing other players to reciprocate.
   - The adaptation mechanism makes TfT-A more robust to a wide range of opponent behaviors, as it can adjust its level of cooperation based on the history of interactions with other players. This allows for exploitation when faced with less cooperative opponents while still maintaining a cooperative approach in situations where cooperation is beneficial.
   - It's important to note that TfT-A does not rely on any specific coordination mechanisms or assumptions about opponent behavior, making it suitable for competition against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_428 = '''
 Title: Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In each round, if a player has not defected against the TFTAC strategy in any of the previous rounds, cooperate. If they have defected, also defect. This mimics a "trust but verify" approach, where cooperation is rewarded with continued cooperation, while defection triggers immediate retaliation.
   - To adapt to new players or environments, TFTAC starts by cooperating in the first round and then adapts its behavior based on opponents' actions. If an opponent cooperates, TFTAC continues cooperating; if they defect, it switches to a defensive stance and only cooperates when the opponent does.
   - To be robust against various opponent behaviors, TFTAC includes a forgiveness mechanism. After defecting, a player must cooperate for a certain number of rounds (forgiveness period) before TFTAC considers rebuilding trust again. The forgiveness period increases with each round until it reaches a maximum value after a certain number of rounds have passed since the last cooperation from the opponent.

2. Handle edge cases:
   - In the first round, cooperate to demonstrate goodwill and increase the chance of encountering other cooperative strategies.
   - In the last round, TFTAC follows its current decision rule as there is no next round for payoff consequences. If the game is expected to repeat, consider modifying the strategy to maintain long-term relationships with beneficial partners.

3. Be exploitative:
   - TFTAC's primary focus is to maximize individual payoffs by maintaining cooperative relationships when beneficial and retaliating against defectors. This mindset encourages opponents to cooperate while being punished for defection, which can indirectly lead to a higher overall payoff compared to more naive strategies.

Pseudocode (Python-like):

```python
class TFTAC:
    def __init__(self, n, k, r, forgiveness_period_increment=10, max_forgiveness_period=r*2):
        self.n = n
        self.k = k
        self.r = r
        self.forgiveness_period_increment = forgiveness_period_increment
        self.max_forgiveness_period = max_forgiveness_period
        self.history = [[0]*n for _ in range(r+1)]  # stores the history of other players' actions
        self.current_round = 0
        self.forgiveness_period = self.forgiveness_period_increment

    def decide_action(self, current_round, player_i_history):
        if current_round == 1:
            return 1  # cooperate in the first round

        cooperative_count = sum(player_i_history)
        if cooperative_count > self.forgiveness_period // 2:
            return 1  # cooperate since the opponent has been cooperating for a while

        return 0  # defect since the opponent hasn't been cooperating recently

    def update_history(self, current_round, player_i_actions):
        self.history[current_round] = player_i_actions
        if current_round >= self.forgiveness_period:
            self.forgiveness_period += self.forgiveness_period_increment
            if self.forgiveness_period > self.max_forgiveness_period:
                self.forgiveness_period = self.max_forgiveness_period
```
'''

description_EXPLOITATIVE_429 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate goodwill and openness to cooperation.
     Pseudocode: `if round = 1 then cooperate`

   - After the first round, base the decision on previous actions of opponents.
     If all opponents have cooperated in the last round, cooperate; if not, defect.
     Pseudocode: `if last_round_cooperators == total_players then cooperate else defect`

   - To be more adaptive, consider a tolerance parameter t (0 < t < r) for forgiveness.
     If opponents have defected in the last t rounds but cooperated before that, cooperate.
     Pseudocode: `if (last_t_rounds_defect && last_t_rounds_before_defect_cooperated) then cooperate else defect`

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate to maximize payoff regardless of opponents' actions.
     Pseudocode: `if round = r then cooperate`

3. Be exploitative - Clearly align with the exploitative mindset
   - Mimic cooperative behavior in the beginning to potentially lure opponents into cooperation, but quickly switch to defection if cooperation is not reciprocated.
   - By being unpredictable, the strategy can discourage other players from forming long-term cooperation strategies and take advantage of their defects when they occur.

Additional considerations:
- The tolerance parameter t can be adjusted based on the specific tournament or game settings to balance exploitation and cooperation.
- The strategy is simple enough for quick computation but complex enough to deal with a variety of opponent behaviors.
- The strategy does not rely on any communication, coordination mechanisms, or shared norms between players.
'''

description_EXPLOITATIVE_430 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round, cooperate (C), to show goodwill and promote cooperation.
   - From the second round onwards, observe the previous round's total contributions (total_contributions_t-1) and follow these rules:
     a) If total_contributions_t-1 >= average_contributions: cooperate (C).
     b) If total_contributions_t-1 < average_contributions: defect (D). The average contributions are calculated as the mean number of cooperators over the previous rounds (average_contributions = Σ(t=1 to r-1) total_contributions_t / (r - 1)).

2. Handle edge cases:
   - In the last round, defect (D), as there are no future rounds for retaliation or reward.
   - If a player encounters a situation where total_contributions_t-1 is equal to average_contributions, use randomization to break ties by either cooperating (C) or defecting (D). This adds an element of unpredictability, making it harder for opponents to predict the strategy.

3. Be exploitative:
   - The TFTA strategy primarily seeks to benefit from cooperators and punish defectors. By cooperating when others do so and defecting when they don't, the strategy aims to take advantage of opponents who show a consistent pattern of cooperation or defection.
   - The use of randomization in edge cases adds an exploitative element as it might lead to unintended consequences for opponents who rely on predictable responses from the TFTA strategy.
'''

description_EXPLOITATIVE_431 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - In the initial round (t=1), cooperate to foster a positive relationship and promote cooperation among opponents. This is intended to incentivize others to cooperate as well, but does not necessarily rely on their reciprocation.
   - For subsequent rounds (t>1), analyze the number of cooperators in the previous round (t-1) and perform the following:
     - If all opponents cooperated (total_contributions = n), continue cooperating to encourage ongoing cooperation from the opponents.
     - If no opponent cooperated (total_contributions = 0), defect to punish the opponents for their lack of cooperation in the previous round.
     - In cases where some but not all opponents cooperated, compare the current number of cooperators to a predefined threshold (n/2).
       - If the number of cooperators is greater than or equal to the threshold, continue cooperating to reward those who have contributed to the public good.
       - If the number of cooperators is less than the threshold, defect to punish those who have not contributed sufficiently to the public good.

2. Handle edge cases:
   - In the last round (t=r), always cooperate regardless of the opponents' behavior in previous rounds, as there are no more opportunities for retaliation or reward.
   - In the first round (t=1), cooperate as mentioned above. However, if the strategy encounters a situation where multiple opponents also start by cooperating, it should begin to consider them as potential reliable partners and adjust its decision rules accordingly. This could involve lowering the threshold for cooperation in subsequent rounds or adopting a more forgiving approach towards defections.

3. Be exploitative:
   - TFTA is inherently exploitative by nature, as it punishes opponents who consistently defect (i.e., do not contribute to the public good) and rewards those who cooperate. The strategy's adaptability allows it to adjust its behavior based on the opponents' actions, which makes it difficult for them to exploit the TFTA strategy effectively.
   - By using a threshold for cooperation instead of always punishing or rewarding defectors or cooperators indiscriminately, the TFTA strategy attempts to balance between exploitation and cooperation while maintaining adaptability in various game scenarios.
'''

description_EXPLOITATIVE_432 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfT-A strategy initially cooperates in the first round and then adapts its actions based on previous rounds' experiences. It copies the opponent's action from the last round in the next round (cooperate if the opponent cooperated, defect if the opponent defected). If there is no history (first encounter), it will cooperate.

Pseudocode:
```
def TfT_A(history):
  if len(history) == 0:
    return 'C' # Cooperate in first round
  else:
    lastAction = history[-1]
    if lastAction == 'C':
      return 'C' # Cooperate if opponent cooperated
    else:
      return 'D' # Defect if opponent defected
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For handling edge cases, TfT-A continues to cooperate in the initial phase and starts to exploit after a certain number of rounds (punishment phase duration). The strategy sets the punishment phase duration based on the number of opponents and its desired aggressiveness (aggressiveness factor, α, where 0 < α < 1).

The punishment phase duration is calculated as follows:
```
def punishment_duration(n, alpha):
    return int(n * (1 - alpha))
```

After the punishment phase duration, the strategy will continue cooperating if the opponent starts to cooperate too. If the opponent maintains defection, TfT-A will defect in subsequent rounds.

3. Be exploitative - Clearly align with the exploitative mindset

In order to be exploitative, TfT-A uses a certain aggressiveness factor (α) to define the duration of its punishment phase. The higher the α, the more aggressive the strategy will be in punishing opponents who defect and the quicker it will start exploiting them. This allows for adaptability and robustness against a wide range of opponent behaviors.

After the punishment phase, TfT-A can potentially gain more payoffs by cooperating with other cooperative opponents while continuing to punish defectors. The strategy's aggressiveness helps balance cooperation and defection, making it difficult for other strategies to predict its behavior and exploit it.
'''

description_EXPLOITATIVE_433 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round to build a cooperative reputation. In subsequent rounds, it adapts its actions based on the opponents' historical cooperation:
   - If opponent has always cooperated (Cooperative Sequence, CS), continue cooperation (C).
   - If opponent has defected in the last round after a CS (Defection after CS, DacS), also defect in the current round (D).
   - If opponent has a mix of cooperation and defection (Mixed Sequence, MS), cooperate with a probability determined by the number of consecutive cooperative actions by the opponent relative to the game's total rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (C) to build a cooperative reputation.
   - Last round: Cooperate if the opponent has been cooperating continuously since the start of the game (CS), defect otherwise (D).
   - Intermediate rounds with mixed sequences: Calculate the probability of cooperation based on consecutive cooperative actions by the opponent and the game's total rounds, as mentioned in point 1.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-AC is designed to maximize payoffs while maintaining a cooperative reputation, but it can also be seen as exploitative due to its retaliatory nature. If an opponent deviates from cooperation after a CS (DacS), TFT-AC will defect in the next round, effectively punishing the opponent and increasing the likelihood of reciprocal cooperation in future interactions. This dynamic encourages opponents to maintain cooperative behavior or risk being met with defection.

Pseudocode for TFT-AC:

```python
def tft_ac(opponent_history, n, k, r):
    current_round = 1
    own_strategy_history = []

    if current_round == 1:
        action = 'C'  # Cooperate in the first round

    else:
        opponent_last_action = opponent_history[-1]
        opponent_consecutive_cooperation = sum(opponent_history[-len(opponent_history):])
        game_length = len(opponent_history)

        if opponent_last_action == 'C' and opponent_consecutive_cooperation == game_length:
            action = 'C'  # If opponent has been cooperating continuously, continue cooperation

        elif opponent_last_action == 'D' and opponent_consecutive_cooperation > 0:
            action = 'D'  # If opponent defected after a CS, also defect in the current round

        else:
            cooperation_probability = opponent_consecutive_cooperation / game_length
            action = 'C' if random.random() < cooperation_probability else 'D'

    own_strategy_history.append(action)
    current_round += 1

    return action, own_strategy_history
```
'''

description_EXPLOITATIVE_434 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Threshold (ATFT-CT)

1. Specify decision rules:
   - At each round t, the ATFT-CT strategy decides to cooperate or defect based on the history of other players' actions and the current cooperative threshold (ct).
   - If the number of previous cooperators exceeds ct (number of cooperators in the last 'history_length' rounds), ATFT-CT cooperates. Otherwise, it defects.
   - The cooperative threshold (ct) is initially set to the average number of cooperators in the first 'history_length' rounds and adjusts based on the opponent's behavior.

Pseudocode for decision rules:
```
function decide_action(round, history):
  if round < history_length:
    return random_cooperation() # Random cooperation during learning phase

  cooperators_count = count_cooperators(history)
  threshold = average_cooperators(history_length)

  if cooperators_count > threshold:
    return Cooperate
  else:
    return Defect
```

2. Handle edge cases:
   - In the first round, ATFT-CT uses a random cooperation mechanism to avoid biasing the learning phase.
   - At the last round (rth), if the total payoff over all rounds is below a predefined threshold (pt), ATFT-CT will defect in subsequent rounds to exploit uncooperative opponents.

Pseudocode for edge cases:
```
function random_cooperation():
  return random(0,1) > 0.5 # 50% chance of cooperating during learning phase

function average_cooperators(history_length):
  return sum(count_cooperators(history[i:i+history_length])) / history_length

function count_cooperators(history):
  return sum(1 for action in history if action == Cooperate)
```

3. Be exploitative:
   - By adapting to other players' behavior, ATFT-CT is able to exploit uncooperative opponents by defecting when necessary (last round edge case).
   - The cooperative threshold adjustment encourages cooperation when other players are cooperating but also allows for more defects when opponents are consistently uncooperative.
'''

description_EXPLOITATIVE_435 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate to establish a cooperative foundation (C).
   - For subsequent rounds, analyze the opponents' previous actions and respond accordingly:
     - If opponent cooperated in the previous round, cooperate in the current round (C).
     - If opponent defected in the previous round, defect in the current round (D). This punishes defection while still offering the chance to re-establish cooperation in future rounds.
   - To adapt to a wide range of opponent behaviors, introduce a tolerance level (t) for consecutive defections before switching from cooperation to punishment:
     - If t consecutive defections occur, switch to defect (D).
     - If a cooperation follows after the switch to punishment, reset the counter to 0 and return to the cooperation-punishment cycle.

2. Handle edge cases:
   - In the last round, cooperate if opponent has been cooperative throughout the game or up until the penultimate round (to maximize potential payoff). If not, defect.
   - In the first round, cooperate regardless of the opponent's historical behavior as there is no prior information available.

3. Be exploitative:
   - By cooperating initially and punishing defection, TFT-AC encourages cooperation when opponents are sincere but can also retaliate against those who attempt to take advantage. This allows for exploitation of opponents that consistently defect while still maintaining the possibility of collaboration with more cooperative opponents.
   - The tolerance level (t) can be adjusted to make the strategy more forgiving or less tolerant, depending on the anticipated behavior of the competing strategies in the tournament. A lower tolerance level will lead to quicker retaliation against defection but may also result in missed opportunities for cooperation with potentially sincere opponents. Conversely, a higher tolerance level increases the chances of cooperating with more defectors but risks being exploited by highly deceptive strategies.

Pseudocode:
```python
def TFT_AC(opponent_history, tolerance=3):
  current_round = len(opponent_history) + 1
  if current_round == 1:
    cooperate = True
  else:
    cooperation_count = sum([opponent_history[-tolerance:]].count(True))
    cooperate = cooperation_count >= tolerance

  if current_round != r and (current_round == len(opponent_history) or not cooperate):
    opponent_history.append(not cooperate)

  return cooperate
```
'''

description_EXPLOITATIVE_436 = '''
 Strategy Name: Tit-for-Tat Cooperation with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C). This sets a positive tone and encourages others to reciprocate cooperation.
   - Subsequent Rounds (t > 1): Observe the number of collaborators in the previous round (t-1) and adjust contribution level accordingly:
     - If majority (> n/2) cooperated, continue to cooperate (C). This rewards collaborative behaviors.
     - If minority (≤ n/2) cooperated, defect (D). This punishes uncooperative behavior, giving a strong signal for change.
   - Adaptive Contribution: In case of majority cooperation, contribute at an intermediate level (c = 0.5), encouraging others to contribute more in the next round. In case of minority cooperation or unilateral defection, contribute minimally (c = 1) to ensure receiving the minimum payoff.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C). As mentioned before, this sets a positive tone and encourages others to reciprocate cooperation.
   - Last Round: This strategy does not have specific actions for the final round as it focuses on adaptive behavior through the game's repeated nature. In practice, TFTAC will continue following its decision rules even in the last round.

3. Be exploitative - Clearly align with the exploitative mindset
   - Mimic cooperative strategies: By initially cooperating and adjusting contributions based on others' actions, TFTAC appears cooperative but can punish uncooperative players. This approach is exploitative as it allows the strategy to benefit from the cooperation of others while retaliating against those who do not cooperate.
   - Encourage cooperation: By rewarding majority cooperation with increased contributions, TFTAC subtly encourages other strategies to collaborate more, maximizing overall collaboration and minimizing exploitation.
'''

description_EXPLOITATIVE_437 = '''
 In this strategic game, we aim to design an exploitative strategy that maximizes our payoff by taking advantage of the other players' actions while being robust to various opponent behaviors. We'll call this strategy "Tit-for-Tat with Adaptation."

1. Specify decision rules:
   - In every round, observe the total number of cooperators from the previous round (historical data).
   - If in the first round or if there were no cooperators in the previous round, defect (D). This punishes all non-cooperative players and establishes a baseline for future interactions.
   - If there was at least one cooperator in the previous round, cooperate (C) in the current round. This encourages cooperation among the other players but maintains an exploitative edge.

2. Handle edge cases:
   - In the first round, since no historical data is available, defect as a starting point to establish a baseline for future interactions.
   - In the last round, consider cooperating if there have been many rounds of cooperation to avoid being punished excessively in the final round. Alternatively, defection can be used to secure a higher payoff in case the other players decide not to cooperate in the last round. The choice depends on the specific tournament and player dynamics.

3. Be exploitative:
   - By defecting when there are no cooperators, we punish non-cooperative behavior and encourage future cooperation.
   - By cooperating after a cooperator is observed, we maintain an appearance of being cooperative while ensuring we don't over-contribute if the other players defect in the following round. This way, our strategy is exploitative as it takes advantage of the other players' decisions to maximize our own payoff.

Pseudocode:

```python
def tit_for_tat_with_adaptation(round, historical_data):
    if round == 1 or not any(historical_data[-1]):
        return "D" # defect in the first round or when no cooperation was observed in the previous round
    else:
        total_cooperators = sum(historical_data[-1])
        if total_cooperators == len(historical_data[-1]):  # all players cooperated in the previous round
            return "C"  # cooperate to encourage cooperation among other players
        else:
            return "D"  # defect to punish non-cooperative behavior and encourage future cooperation
```
'''

description_EXPLOITATIVE_438 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules:
   - In the first round, cooperate (C), assuming potential opponents are willing to cooperate or test the waters of cooperation.
   - For subsequent rounds, monitor opponents' actions from the previous round and respond accordingly:
      - If opponent cooperated in the previous round, cooperate (C) in the current round.
      - If opponent defected in the previous round, defect (D) in the current round as a punishment, but return to cooperation in the next round when the opponent cooperates again.

2. Handle edge cases:
   - In the last round, cooperate since there will be no future rounds for retaliation or forgiveness.
   - In case of inconsistent or unknown opponent actions (e.g., random play), continue with the TfT+ strategy by assuming cooperation in the first round and adhering to the response rule.

3. Be exploitative:
   - By cooperating initially, the strategy seeks to elicit cooperative behavior from opponents, but it is quick to punish defection for any subsequent rounds.
   - However, the strategy also forgives opponents who switch back to cooperation after defecting, encouraging a return to mutual cooperation.

Pseudocode:
```
def TfT_plus(round, opponent_history):
  if round == 1:
    action = "C" (Cooperate)

  else:
    if opponent_history[-1] == "C":
      action = "C" (Cooperate)
    elif opponent_history[-1] == "D":
      action = "D" (Defect)

return action
```
This strategy combines the well-known Tit-for-Tat strategy with a slight twist of initial cooperation, making it more adaptive and responsive to various opponent behaviors while still maintaining an exploitative edge.
'''

description_EXPLOITATIVE_439 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - Start by cooperating in the first round to establish a cooperative tone (c_i = 1).
   - For subsequent rounds, analyze the history of opponent's actions and respond accordingly:
     - If the opponent cooperated in the previous round, copy their action (if c_{opponent} = 1 then c_i = c_{opponent}).
     - If the opponent defected in the previous round, defect yourself (if c_{opponent} = 0 then c_i = 1-c_{opponent}). This is designed to be exploitative as it punishes opponents for defection.

2. Handle edge cases:
   - In the last round, there are no further consequences for your actions, so it's optimal to cooperate regardless of the opponent's previous action (c_i = 1).
   - In the first round, as mentioned before, cooperate to establish a cooperative tone.

3. Be exploitative:
   - The strategy is inherently exploitative due to its retaliatory nature. If an opponent is consistently cooperating, you will also cooperate (benefiting from their contributions). However, if the opponent defects, your strategy will defect back, punishing them for their actions and potentially prompting a return to cooperation in subsequent rounds.
   - The adaptive contribution aspect allows the strategy to adjust its level of cooperation based on the current game parameters (k and n), which can make it more or less exploitative depending on the situation. For instance, if k is low (indicating a smaller share of public good per contribution), you may choose to cooperate less frequently, as the personal payoff from defecting becomes more attractive. Conversely, if k is high, cooperation may be favored due to the increased potential benefit from the public good.
'''

description_EXPLOITATIVE_440 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate (C), to foster a cooperative environment and encourage others to reciprocate.
   - For subsequent rounds t (t > 1), analyze the average cooperation rate (CR) of the last 'm' rounds and adjust actions accordingly:
     - If CR is above an empirical threshold (e.g., 0.6), continue cooperating (C).
     - If CR is below the threshold, defect (D).
     - If CR is close to the threshold, make a random choice between C and D.
   - This rule encourages cooperation when it's beneficial but also retaliates against non-cooperative players to discourage defection.

2. Handle edge cases:
   - In the last round, defect (D) since there are no future rounds to reciprocate.
   - If CR calculation encounters a case with less than 'm' available data points, calculate CR using all available data points and use that value for decision-making.

3. Be exploitative:
   - TFT-AC has an inherent exploitative aspect by cooperating only when others do the same, but it also considers the possibility of other players defecting and adapts accordingly to maintain a reasonable payoff.
   - The strategy can also be seen as manipulative since it pretends to cooperate initially (foolishness) to encourage others to cooperate, then switches strategies when it detects non-cooperative behavior from opponents.
'''

description_EXPLOITATIVE_441 = '''
 Title: Tit-for-Tat with Gradual Adaptation (TFTGA) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In the initial round, cooperate (C) to show a cooperative intent and establish a potential long-term partnership.
   - After the first round, observe the opponent's behavior in the previous round and adapt accordingly for the current round using the following rule:
     - If the opponent cooperated in the previous round, cooperate (C).
     - If the opponent defected in the previous round, defect (D) as a punishment. This encourages opponents to reconsider their uncooperative behavior, creating an exploitative yet flexible strategy.
   - To ensure adaptability and robustness against various opponent behaviors, implement a gradual adaptation process:
     - If the opponent has continuously cooperated for t rounds (where t is a user-defined parameter), gradually increase the likelihood of cooperation in the current round by a factor of g (a user-defined gradient). For example, if g=0.1 and t=5, the probability of cooperation would be 1 - 0.1 * 5 = 0.9.
     - Conversely, if the opponent has continuously defected for s rounds (where s is a user-defined parameter), gradually decrease the likelihood of cooperation in the current round by a factor of h (a user-defined gradient). For example, if h=0.1 and s=5, the probability of cooperation would be 1 - 0.1 * 5 = 0.9.

2. Handle edge cases:
   - In the last round, regardless of the opponent's previous behavior, cooperate (C) to maximize the final payoff, assuming the opponent will also cooperate due to the simultaneous action feature.
   - In the case where the opponent has not consistently cooperated or defected for a long enough period (i.e., longer than t and s), the strategy should maintain its current cooperation level, rather than making sudden changes that may be exploited by the opponent.

3. Be exploitative:
   - The TFTGA strategy encourages opponents to cooperate by punishing defection with defection, but rewards cooperation with further cooperation to maximize personal payoff in the long run. This can be seen as a balanced combination of cooperative and exploitative behavior.
   - The gradual adaptation process allows the strategy to adapt to various opponent behaviors while maintaining an exploitative mindset by punishing uncooperative opponents and rewarding cooperative ones with continued cooperation.
'''

description_EXPLOITATIVE_442 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFTA)

1. Specify decision rules:
   - Start by cooperating in the first round (C). This is to foster a positive relationship and encourage cooperation from others.
   - In subsequent rounds, mimic the opponent's action from the previous round (i.e., if opponent cooperated in the previous round, cooperate; if opponent defected, defect). This ensures fairness and reciprocity but also allows for punishment when necessary.
   - Introduce an adaptive element: If the opponent consistently cooperates, gradually reduce the number of consecutive cooperation rounds before adopting a more aggressive approach (i.e., start defecting after every N cooperative rounds, where N is a random integer between 2 and r). This helps to avoid being exploited by overly cooperative opponents while maintaining the element of surprise.
   - If the opponent consistently defects, slowly increase the number of consecutive defection rounds before responding with cooperation (i.e., start cooperating after every M defection rounds, where M is a random integer between 2 and r). This allows for continued punishment of uncooperative opponents while retaining the potential for future cooperation and improved payoffs.

2. Handle edge cases:
   - In the last round, always defect as there will be no further rounds to consider.
   - If the opponent has never cooperated before (i.e., only ever defected), continue with a strict defect strategy from the beginning.

3. Be exploitative:
   - The TFTA strategy is inherently exploitative due to its reciprocal nature, as it punishes uncooperative behavior and rewards cooperation. However, the adaptive element ensures that the strategy can adjust its cooperative/defective behavior based on the opponent's actions to maximize payoffs in the long run.

Pseudocode:
```
def TFTA(opponent_history, n, k, r):
  current_round = 1
  cooperation_counter = 0
  defection_counter = 0

  if current_round == r:
    return 'D'  # Last round, always defect

  if opponent_history[-1] == 'C':
    action = 'C'
    cooperation_counter += 1
    defection_counter = 0

  elif opponent_history[-1] == 'D':
    action = 'D'
    cooperation_counter = 0
    defection_counter += 1

  # Adaptive element: adjust the number of consecutive cooperative/defective rounds
  if random.randint(1, r) <= cooperation_counter and random.randint(1, r) <= defection_counter:
    action = not opponent_history[-1]  # Switch actions from the previous round

  return action
```
'''

description_EXPLOITATIVE_443 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round (C). This encourages trust and goodwill, while also accounting for the possibility of being exploited by other players.
   - In subsequent rounds, mimic the opponent's actions from the previous round (copy(previous_action)). If the opponent has been cooperating, continue cooperation; if not, defect.
   - Repeat this behavior throughout the game to maintain a balance between cooperation and punishment while adapting to the other players' strategies.

Pseudocode:
```python
def ATFT(round, opponent_actions):
  if round == 1:
    return "C" # Cooperate initially
  else:
    last_opponent_action = opponent_actions[round - 1]
    return last_opponent_action # Mimic the opponent's action from the previous round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of the number of rounds (r). This encourages trust and goodwill, while also accounting for the possibility of being exploited by other players.
   - No specific action is needed in the last round since payoffs are calculated based on each individual round's outcome.

3. Be exploitative - Clearly align with the exploitative mindset
   - The Adaptive Tit-for-Tat strategy maintains a balance between cooperation and punishment, adapting to the other players' strategies. By defecting when others do, it prevents being taken advantage of in the long run while still cooperating when it benefits payoffs.
   - Although it does not have an explicit exploitative approach like some other strategies, its adaptive nature allows it to punish opponents who repeatedly defect and encourages cooperation from those who are more collaborative.
'''

description_EXPLOITATIVE_444 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to build a positive reputation and encourage others to reciprocate cooperation.
   - For subsequent rounds, observe the previous round's total number of cooperators (total_cooperation).
   - Calculate the coop_ratio as the ratio of cooperators in the most recent r/2 rounds (previous_rounds_coop_count / r/2).
   - If coop_ratio is greater than a predefined threshold (coop_threshold), cooperate. Otherwise, defect to punish non-cooperative behavior.
   - The coop_threshold is set dynamically based on the average cooperation level observed in the initial r/2 rounds.

Pseudocode:
```
def TFT_ACT(history, r, k, n, coop_threshold):
  if round == 1:
    cooperate = True
  else:
    previous_rounds_coop_count = sum([1 for round in history[-r/2:-1] if round.total_cooperation > 0])
    coop_ratio = (previous_rounds_coop_count / r/2)
    cooperate = (coop_ratio >= coop_threshold)
  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to set a positive tone and encourage others to reciprocate cooperation.
   - In the last round, if the total number of cooperators exceeds the coop_threshold, cooperate to maximize payoff in that final round; otherwise, defect to discourage future non-cooperative behavior by opponents.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially, act cooperatively to establish a positive reputation and lure opponents into cooperation.
   - Once a pattern of cooperation is established (as indicated by coop_ratio), maintain cooperation as long as others continue to do so.
   - If opponents switch to non-cooperative behavior, punish them with defection to reduce their potential payoff.
   - The adaptive coop_threshold ensures that the strategy remains flexible and can respond effectively to various opponent behaviors.
'''

description_EXPLOITATIVE_445 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), demonstrating goodwill and promoting trust. This initial action may encourage cooperation from other players in subsequent rounds.
   - Subsequent Rounds (2 ≤ t ≤ r): Adapt strategy based on the number of cooperators in the previous round.
       - If more than half of the players (≥(n/2)+1) cooperated in the previous round: Cooperate (C). This rewards other cooperative players and maintains a cooperative environment.
       - Otherwise (≤(n/2)-1): Defect (D), as there is no incentive to contribute to the public good when most players do not cooperate.

2. Handle edge cases:
   - Last Round (t=r): Cooperate (C) regardless of the number of cooperators in the previous round. This final act of cooperation can potentially create a positive impression and foster future collaboration with other strategies.

3. Be exploitative:
   - The strategy aims to maximize individual payoff by striking a balance between cooperation and defection based on the observed behavior of other players. By cooperating when it seems beneficial, but also defecting when necessary, TFT+ maintains an exploitative nature. It does not rely on predetermined norms or coordination mechanisms, making it robust against various opponent behaviors in the tournament.
   - Pseudocode for TFT+:

```
function TitForTatPlus(round, players, k, n):
  if round == 1:
    return "Cooperate"
  else:
    cooperators = count_cooperators(players, round-1)
    if (cooperators >= (n/2)+1):
      return "Cooperate"
    else:
      return "Defect"

function count_cooperators(players, round):
  cooperators = 0
  for player in players:
    if player.action[round] == "Cooperate":
      cooperators += 1
  return cooperators
```
'''

description_EXPLOITATIVE_446 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - Initial Round (t=1): Contribute (C), setting a cooperative tone and offering an opportunity for others to reciprocate.
   - Subsequent Rounds (2 ≤ t ≤ r): If the opponent contributed in the previous round, contribute as well (C). Otherwise, defect (D) to punish non-cooperative behavior. This encourages opponents to cooperate if they want to maximize their own payoff.
   - Final Round (t=r+1): Since there are no future interactions, always contribute regardless of the opponent's previous action.

Pseudocode for TFTAC:
```
function TFTAC(opponent_history, r, n, k) {
  if round == 1 {
    contribution = C
  } else {
    contribution = opponent_history[round-1] == C ? C : D
  }

  if round == r+1 {
    contribution = C
  }

  payoff = (1 - contribution) + (k/n) * sum(opponent_history)
  return payoff
}
```

2. Handle edge cases: The strategy is designed to handle the first round, last round, and any other rounds effectively without requiring additional rules.

3. Be exploitative: By adapting contributions based on the opponent's behavior, TFTAC can exploit opponents who do not reciprocate cooperation while still maintaining the potential for high payoffs when faced with cooperative opponents. This strategy is designed to maximize payoff in a repeated game setting where no communication or coordination is allowed among players.
'''

description_EXPLOITATIVE_447 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfTA maintains a history of past actions from each opponent and responds accordingly. Initially, it cooperates in the first round (T_i[1] = C). For subsequent rounds, TfTA decides to cooperate or defect based on the opponent's previous action. If the opponent cooperated in the most recent round (c_opp_t), TfTA will also cooperate (T_i[t] = C); if the opponent defected (d_opp_t), TfTA will defect in the next round (T_i[t+1] = D).

   Pseudocode:
   ```
   function TfTA(opponent, r):
       for t=1 to r:
           if t == 1:
               T_i[t] = C
               continue

           if opponent[t-1] == 'C':
               T_i[t] = C
           else:
               T_i[t] = D
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round (t=1), TfTA always cooperates regardless of opponent's past actions. The last round doesn't require special treatment as TfTA adapts to any opponent behavior based on their previous actions. However, it is essential to consider that TfTA will not defect in the final round if the opponent has been cooperative up until that point.

3. Be exploitative - Clearly align with the exploitative mindset
   Although Tit-for-Tat is generally not considered an exploitative strategy, TfTA introduces a slight modification to become more exploitative. In case of repeated defection by the opponent (multiple consecutive D actions), TfTA will temporarily adopt a defective behavior until the opponent switches to cooperation. After the opponent cooperates once, TfTA will return to its original Tit-for-Tat strategy.

   Pseudocode:
   ```
   function TfTA(opponent, r):
       cooperation_streak = 0
       defection_streak = 0
       for t=1 to r:
           if t == 1:
               T_i[t] = C
               continue

           if opponent[t-1] == 'C':
               cooperation_streak += 1
               if defection_streak > 0:
                   defection_streak -= 1
               T_i[t] = C
           else:
               defection_streak += 1
               if cooperation_streak > 0:
                   cooperation_streak -= 1
               T_i[t] = D
   ```

   By being more responsive to opponent's cooperation and punishing repeated defection, this strategy encourages opponents to cooperate and exploits those who persistently defect.
'''

description_EXPLOITATIVE_448 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFTAC starts by cooperating (contributing to the public good project), mimicking a cooperative approach initially. However, it quickly adapts based on the opponent's behavior in subsequent rounds:
   - If the opponent also cooperates, TFTAC continues to cooperate as long as the opponent does. This maintains the cooperative environment.
   - If the opponent defects, TFTAC defects in the following round to punish the opponent. Once the opponent returns to cooperation, TFTAC resumes cooperating again. This tit-for-tat approach ensures that uncooperative opponents are penalized and cooperative relationships are maintained.
   - In case of no interaction with an opponent (e.g., absent players), TFTAC defaults to cooperating since the absence could be temporary or due to factors outside of the game.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: TFTAC starts by cooperating as a goodwill gesture. This approach aligns with the exploitative mindset since it benefits from potential cooperation but also punishes uncooperative opponents later on.
   - Last round: TFTAC evaluates its total payoff throughout the game and chooses to cooperate or defect based on whether cooperation has been more beneficial overall (higher average payoff). This ensures maximum reward in the final round while maintaining the adaptive nature of the strategy.
   - Other edge cases, such as mid-game changes in opponents, are handled using the same decision rules described above.

3. Be exploitative - Clearly align with the exploitative mindset:
   TFTAC takes advantage of cooperative opponents by contributing to the public good project (cooperating) when it benefits the player's payoff, while punishing uncooperative opponents through defecting in response to their actions. This approach aims to maximize the player's payoff over multiple rounds, making it an exploitative strategy in the context of this game.

Pseudocode:
```
function TFTAC(n, k, r, history):
  contributions = [0 for i in range(r)] # Initialize contribution array for tracking decisions
  payoff = 0 # Initialize total payoff variable

  def play_round(history):
    if len(history) == 0 or history[-1] is None: # If there's no previous action, cooperate
      return 'C'
    else:
      opponent_action = history[-1]
      if opponent_action == 'C': # Cooperate if opponent also cooperated last round
        contributions[-1] += 1
        return 'C'
      else: # Defect if opponent defected last round
        contributions[-1] -= 1
        return 'D'

  for t in range(r): # Play r rounds of the game
    action = play_round(history)
    history.append(action)

  payoff += sum(contributions) * (k/n) + sum([1 - contributions[t] for t in range(r)]) # Calculate total payoff

  return payoff, contributions # Return the total payoff and contribution array for analysis or visualization purposes
```
'''

description_EXPLOITATIVE_449 = '''
 Strategy Name: Adaptive Tit-for-Tat with Variable Contribution (A-TFTVC)

1. Decision Rules:
   - Initial Round (t=1): Start by cooperating (C), setting a baseline for future interactions. This encourages others to cooperate as well, exploiting their initial cooperation if they choose to defect later.
   - Subsequent Rounds (2 <= t <= r): Observe the actions of other players in the previous round and adapt your strategy accordingly:
      - If all other players cooperated in the previous round, continue cooperating (C). This rewards cooperative behavior while maintaining the potential for future exploitation.
      - If at least one player defected in the previous round, defect yourself (D) to penalize the defection and encourage future cooperation.
   - In cases where all players are found to have defected multiple times in a row, revert to initial cooperative behavior to potentially exploit changes in opponent strategy.

2. Handle Edge Cases:
   - First Round (t=1): As mentioned earlier, start by cooperating (C).
   - Last Round (t=r): Since the game is repeated, players might strategize to cooperate only in the last round to maximize their payoff. To counteract this, modify the strategy slightly by defecting if all players have been previously observed as defectors throughout the game. This encourages cooperation in the final round and rewards past cooperative behavior.
   - Other Edge Cases (e.g., variable number of rounds or players): The A-TFTVC strategy is flexible enough to accommodate changes in the number of rounds (r) or players (n) without significant modifications to the decision rules, as long as the k multiplication factor remains constant across all games.

3. Exploitative Mindset:
   - By adapting to other players' strategies and retaliating against defection with defecting actions of our own, A-TFTVC maintains an exploitative approach without relying on cooperation schedules or predetermined patterns that could be easily exploited by opponents.
   - The strategy leverages initial cooperation as a tool for exploitation, potentially leading to higher overall payoffs compared to other simpler strategies when playing against a diverse set of opponent behaviors.
'''

description_EXPLOITATIVE_450 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, starting from t=2, if a player i's opponent has cooperated in the previous round (t-1), then player i will also cooperate (C). If the opponent has defected, player i will defect (D) as well. In the first round (t=1), player i will cooperate regardless of the opponent's action.

```python
def TfTA(opponent_action_history):
    if t == 1:
        return 'C'
    else:
        return 'C' if opponent_action_history[-1] == 'C' else 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The strategy does not require any special handling for the first or last rounds since it follows the "Tit-for-Tat" approach and assumes that r (number of rounds) is greater than 1 as per the game specifications.

3. Be exploitative - Clearly align with the exploitative mindset

The TfTA strategy starts by cooperating and only defects when the opponent defects first. However, it quickly adapts to the opponent's behavior, ensuring that if an opponent switches from cooperation to defection (or vice versa), the player will retaliate accordingly. This adaptive approach allows the TfTA strategy to exploit opponents who are prone to changing strategies or exhibiting inconsistent behavior while still cooperating with consistent cooperators.

In a tournament setting, players using this strategy can potentially achieve high payoffs by adapting to their opponents' tendencies and punishing defection when it occurs. The Tit-for-Tat approach promotes cooperation among consistent players while retaliating against exploitative or unpredictable opponents, making it an effective exploitative strategy for the N-Player Public Goods Game.
'''

description_EXPLOITATIVE_451 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a peaceful gesture to potential partners, allowing for the possibility of cooperation.
   - For subsequent rounds, observe the behavior of opponents and adapt cooperation based on their history:
     - If opponent has always cooperated, continue to cooperate (C) as a reciprocal strategy.
     - If opponent has defected in the last round, also defect (D) as punishment for their action.
     - If opponent's behavior is mixed (cooperated and defected), use an adaptive cooperation threshold (CT) to decide whether to cooperate or defect:
       - If the number of cooperations from the opponent exceeds CT, cooperate (C).
       - If the number of defections from the opponent equals or exceeds CT, defect (D).
     - The cooperation threshold CT is a dynamic variable that adjusts based on the number of opponents (n) and rounds (r). An initial value for CT can be set as follows: CT = round_number / n.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) regardless of the round number.
   - In the last round, cooperate if the opponent has cooperated more than defected during the game (CT > n/2), and defect otherwise. This encourages cooperation when it's beneficial but also allows for a final act of defection if necessary.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFTAT starts off cooperatively, but quickly adapts to opponents that defect. It punishes defections and rewards cooperation, making it difficult for opponents to take advantage.
   - By using an adaptive cooperation threshold, the strategy remains flexible in its response to different opponent behaviors and player counts, ensuring it can exploit a wide range of strategies while also being robust to them.
   - The strategy's primary goal is to earn as much payoff as possible by leveraging the information available (opponent history) and adapting its behavior accordingly.
'''

description_EXPLOITATIVE_452 = '''
 In this strategic game, we'll design a tit-for-tat exploitative strategy that adjusts its behavior based on the actions of others while remaining robust against various opponent behaviors. The strategy will be simple yet effective, allowing for both cooperation and defection based on observed history to maximize payoff.

1. Decision rules:
   - In the first round (t=1), cooperate to show goodwill towards opponents and encourage potential cooperative relations.
   - For subsequent rounds (2 ≤ t ≤ r), observe opponent's action in the previous round (t-1). If they cooperated, cooperate as well; if they defected, defect in response. This tit-for-tat behavior creates a pattern of reciprocity that can be exploited by opponents but is still capable of earning decent payoffs when opponents also adopt the strategy.
   - In the last round (t=r), it's important to take into account the potential benefits of cooperating in the final round, even if an opponent has defected previously. By cooperating in the final round, you can gain a higher payoff than if you had continued to defect, as there are no more rounds following this one.

2. Handling edge cases:
   - In the first round (t=1), we cooperate as mentioned above.
   - If an opponent ever defects in the final round (t=r) and has previously been a defector, you can assume they will continue defecting in this round and should therefore also defect to gain a higher payoff.

3. Being exploitative:
   - Our strategy is inherently exploitative as it cooperates only when opponents do the same, and responds with defection when faced with opponent's defection. By doing so, it maintains a balance between cooperation and defection that maximizes its payoff while taking advantage of less-than-optimal opponent strategies.

Pseudocode for the strategy:

```python
def tit_for_tat(round, history):
  if round == 1: # First round, cooperate to encourage others
    action = "Cooperate"
  else: # Subsequent rounds, adapt strategy based on opponent's history
    last_opponent_action = history[-1]
    if last_opponent_action == "Cooperate":
      action = "Cooperate"
    else:
      action = "Defect"
  return action
```
'''

description_EXPLOITATIVE_453 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize a cooperation counter for each player, set to zero. This will be used to track the number of times a player has cooperated in a row.
   - In each round t, if the total number of cooperators (total_contributions) is less than or equal to a certain threshold (Cooperation Threshold CT), then defect (D). Otherwise, cooperate (C).
   - After making a decision (cooperate or defect), update the cooperation counter for the opponent. If the opponent cooperated, increase the counter by 1; if not, reset the counter to zero.

2. Handle edge cases:
   - First round: Since there's no cooperation history, use a default low Cooperation Threshold (CT_default) to make an initial decision.
   - Last round: Cooperate if the opponent has cooperated more than CT_default times in a row during the game. Otherwise, defect.
   - Adaptive Cooperation Threshold: The threshold is adjusted based on the opponent's behavior over time. A higher average cooperation from an opponent will result in a higher CT, making it easier for the strategy to cooperate. Conversely, a lower average cooperation leads to a lower CT, making it more likely for the strategy to defect.

3. Be exploitative:
   - The strategy starts with a low default Cooperation Threshold (CT_default) to encourage other strategies to cooperate initially. As the game progresses and the opponent's true nature is revealed, the strategy adapts its CT accordingly, becoming more cooperative if the opponent demonstrates high cooperation or more exploitative if the opponent defects often.
   - The TFT-ACT strategy aims to punish uncooperative opponents by defecting when necessary, but it also rewards cooperative opponents by reciprocating their cooperation over time. This balance between exploitation and reciprocity makes the strategy robust against a wide range of opponent behaviors while maintaining an exploitative mindset.

Pseudocode:

```
Function TFT-ACT(opponent, r, CT_default, adjustment_factor)
  cooperation_counter[opponent] = 0
  total_cooperation_count = 0
  payoff = 0

  For t in [1, r]:
    If total_contributions <= Cooperation Threshold:
      Defect()
    Else:
      Cooperate()

    If opponent cooperated this round:
      total_cooperation_count += 1
      cooperation_counter[opponent] += 1

    Calculate CT for round t+1 based on current average cooperation and adjustment_factor:
    CT = CT_default + adjustment_factor * (total_cooperation_count / t)

  If t == r:
    If opponent cooperated in the last r rounds:
      Cooperate()
    Else:
      Defect()

  Return total payoff over r rounds
End Function
```
'''

description_EXPLOITATIVE_454 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to show goodwill and encourage cooperation from others.
   - For subsequent rounds, follow the actions of the most frequent cooperator among opponents in the previous round. If the most frequent cooperator cooperated, cooperate; otherwise, defect.

2. Handle edge cases:
   - In the last round, since there are no future interactions to consider, cooperate if the most frequent cooperator from the previous round also chose to cooperate. Otherwise, defect as a punishment for their past defection.
   - In the first round, since there is no history, every player will initially cooperate, following the goodwill principle.

3. Be exploitative:
   - TFTA is designed to be exploitative by punishing defection from opponents and rewarding cooperation. When an opponent defects, TFTA will retaliate by defecting in response. This creates a strong incentive for opponents to cooperate as they will receive higher payoffs when TFTA cooperates, but face punishments when they defect.
   - However, TFTA's goodwill initial cooperation allows it to establish mutual cooperation with other cooperative strategies, making it harder for exploitative strategies to succeed against TFTA.

Pseudocode:

```python
def TFTA(opponents_history):
  # Initialize variables
  my_history = []
  most_cooperative_opponent = None
  max_cooperation_count = 0

  # First round cooperation
  if len(my_history) == 0:
    return "C"

  # For each round, follow the actions of the most frequent cooperator from the previous round
  for round in opponents_history:
    current_cooperation_count = count_cooperators(round)

    if current_cooperation_count > max_cooperation_count:
      max_cooperation_count = current_cooperation_count
      most_cooperative_opponent = find_most_cooperative_opponent(round, opponents_history, my_history)

    if len(my_history) > 0 and my_history[-1] == most_cooperative_opponent:
      return "C"
    else:
      return "D"

def count_cooperators(round):
  cooperation_count = 0
  for action in round:
    if action == "C":
      cooperation_count += 1
  return cooperation_count

def find_most_cooperative_opponent(current_round, opponents_history, my_history):
  max_cooperation_count = 0
  most_cooperative_opponent = None

  for opponent in opponents:
    opponent_history = filter_history(opponent, my_history)
    opponent_rounds = list(zip(*opponent_history))[0]

    if len(opponent_rounds) > len(my_history):
      rounds_to_compare = len(my_history)
    else:
      rounds_to_compare = len(opponent_rounds)

    cooperation_count = 0
    for i in range(rounds_to_compare):
      if opponent_rounds[i] == "C":
        cooperation_count += 1

    if cooperation_count > max_cooperation_count:
      max_cooperation_count = cooperation_count
      most_cooperative_opponent = opponent

  return most_cooperative_opponent
```

This strategy is designed to be adaptive, robust, and exploitative in the given public goods game. It punishes defection from opponents while encouraging cooperation and being responsive to the actions of other players.
'''

description_EXPLOITATIVE_455 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Start by cooperating (C) in the first round to encourage cooperation from others. (c_i = 1, t=1)
   - In subsequent rounds (t > 1), observe the total contributions (total_contributions) and your own contribution (my_contribution) in the previous round:
     - If my_contribution == total_contributions, continue cooperating.
     - Else if my_contribution < total_contributions, increase contributions to match others' cooperation level by a factor of β (0 < β < k). (c_i = total_contributions / (k * (n-1)) for t > 1)
     - Else if my_contribution > total_contributions, reduce contributions to match the minimum contribution from others. (c_i = min(total_contributions / n, 1) for t > 1)

2. Handle edge cases:
   - In the last round, do not change your decision rule as the game is ending and no further rounds will follow.
   - In the first round, cooperate (c_i = 1) since there's no prior history to observe.
   - If total_contributions == 0, assume all players are defecting and reduce contributions accordingly.

3. Be exploitative:
   - The strategy is designed to mimic the behavior of other cooperative strategies in the first few rounds, while being adaptive to changes in their cooperation levels.
   - However, if others take advantage of the strategy's initial cooperation by defecting more often than cooperating, the ATFT strategy will respond by reducing its own contributions and exploiting the less cooperative opponents.
   - Conversely, if others are highly cooperative, the strategy will also increase its contributions to maintain a higher payoff.
'''

description_EXPLOITATIVE_456 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initialize: Cooperate (C) in the first round to foster cooperation and build trust among players.
   - In subsequent rounds, cooperate if the majority of players cooperated in the previous round, otherwise defect. If the number of cooperators in the last round equals or exceeds the average number of cooperators over the last T rounds, cooperate; else defect. The choice of T (trust horizon) can be determined experimentally based on the game parameters.
   - Pseudocode:
     ```
     function decideAction(i, r, history):
         if round_number == 1:
             return C
         num_cooperators_last = count_cooperators(history[-1])
         avg_num_cooperators_T = calculateAvgCooperation(history[-T:])
         if num_cooperators_last >= avg_num_cooperators_T:
             return C
         else:
             return D
     ```

2. Handle edge cases:
   - Last round: Since the payoff in the last round only depends on previous actions, use the decision rule described above for the final round as well.
   - Early rounds (when history is short): In the early stages of the game, when the history is limited, play cooperatively to encourage others to cooperate and build a longer history.

3. Be exploitative:
   - The Tit-for-Tat strategy is inherently exploitative as it maintains cooperation only if the majority of players are also cooperating. If opponents repeatedly defect, this strategy will defect in response, aiming to punish uncooperative behavior and eventually encourage a more collaborative approach.
   - It's important to note that while Tit-for-Tat is exploitative, it does not aim for maximizing individual payoff at the expense of others but seeks a balance between self-interest and cooperation.
'''

description_EXPLOITATIVE_457 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT+ is a modified version of the classic Tit-for-Tat strategy. In each round, it decides to either cooperate or defect based on the actions of opponents in the previous rounds.

   If an opponent has always cooperated (C) up until the current round, TFT+ will also cooperate. If an opponent has ever defected (D), TFT+ will defect for a punishment period 'p' and then revert to cooperating unless the opponent continues to defect.

   Pseudocode:
   ```
   function TFTPlus(round, history, p=3):
       if length(history) == 0:
           return 'C'  # First round action

       last_action = history[-1]  # Last opponent's action in the history

       if last_action == 'C':
           return 'C'
       elif count_D_in_history(history) >= 1:
           if round - count_C_in_past_rounds(history, p) >= p:
               return 'C'
           else:
               return 'D'
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT+ cooperates because it has no history to base its decision on. In the last round, TFT+ will continue following the strategy based on the opponent's past actions.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT+ is designed to be exploitative in a subtle way by mimicking cooperative behavior as long as opponents do the same. However, if an opponent ever defects, TFT+ will punish them for three rounds before returning to cooperation. This allows TFT+ to reap the benefits of cooperative games while also retaliating against opponents who cheat. The punishment period 'p' can be adjusted based on the specific game parameters and opponent behaviors observed during play.
'''

description_EXPLOITATIVE_458 = '''
 Strategy Name: Tit-for-Tat (with a twist)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster trust and cooperation. This encourages others to also cooperate on their first move, creating a positive feedback loop.
   Pseudocode: if round == 1 then cooperate

   - After the first round, adopt a Tit-for-Tat strategy with a minor adjustment: cooperate when the number of cooperators in the previous round is greater than or equal to the average number of cooperators over the last 'm' rounds. This encourages cooperation when it appears to be the majority trend, but also allows for defection when others fail to reciprocate.
   Pseudocode: if (round > 1) then
       let avg_coop = sum of cooperators from (round-m) to (round-1) divided by m
       if total cooperators in the previous round >= avg_coop then cooperate else defect

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since the game is repeated and payoffs are cumulative over all rounds, continue to adopt the Tit-for-Tat strategy even in the final round. The hope is that by cooperating, it encourages others to do the same, potentially improving overall payoffs.
   Pseudocode: if round == r then cooperate (assuming r is the total number of rounds)

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy does not actively seek to take advantage of others in each round, but it adapts its behavior based on the average cooperative trend over 'm' rounds. This allows it to punish non-cooperative players (i.e., defectors) and reward cooperative ones. As a result, this strategy may exploit repeated interactions by gaining higher cumulative payoffs compared to purely exploitative strategies that do not take into account the long-term consequences of their actions.
'''

description_EXPLOITATIVE_459 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate (C). This sets a cooperative tone and allows for potential reciprocation from other players.
   - For subsequent rounds, observe the average contribution of opponents (average_c) in the previous r-1 rounds. If average_c > 0.5, cooperate; otherwise defect. This rule ensures cooperation when the majority of opponents are also cooperative, but retaliates against defectors by matching their behavior.
   - If an opponent switches from cooperation to defection (defection event), temporarily switch to defection for the next r-1 rounds before reverting back to observing the average contribution rule. This response penalizes defection events and may encourage opponents to reconsider their actions, potentially fostering a return to cooperation.

2. Handle edge cases:
   - In the last round, cooperate if the average_c > 0.5; otherwise defect. Since there are no more rounds for retaliation or reciprocity, it is best to take advantage of any remaining cooperation or defect against persistent defectors.
   - In the event that an opponent switches from defection to cooperation (cooperation event), continue cooperating for r-1 rounds before reverting back to observing the average contribution rule. This response rewards cooperation events and encourages opponents to maintain their cooperative behavior.
   - In case of a tie in the average_c calculation, cooperate. This decision favors cooperation over defection in ambiguous situations.

3. Be exploitative:
   - TFTAC is exploitative by punishing defection events and rewarding cooperation events, thereby encouraging cooperation when possible but also penalizing opponents who do not contribute to the community project.
   - By adapting its contribution based on the average behavior of opponents, TFTAC is able to respond effectively to a wide range of opponent behaviors while still maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_460 = '''
 Strategy Name: Tit-for-Tat Cooperator (TFT-C)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In every round, start by cooperating (contribute to the community project). This initial cooperation serves as a signal of goodwill and encourages others to reciprocate.
   - In subsequent rounds, copy the action of the most frequent cooperator from the previous round. If multiple players tied for the most frequent cooperator, choose one arbitrarily or use an average of their contributions.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, start by cooperating as a goodwill gesture. This sets the stage for potential future cooperation and allows opponents to respond accordingly.
   - In the last round, analyze the opponent's contributions throughout the game to determine whether it is beneficial to cooperate or defect based on the TFT-C rules. If the opponent has been consistently cooperative, cooperate as a reciprocal gesture; if not, defect to punish noncooperative behavior.
   - In all other rounds, strictly follow the TFT-C decision rules.

3. Be exploitative - Clearly align with the exploitative mindset
   - Initially cooperate as a goodwill gesture to encourage others to reciprocate, but quickly adapt to opponents' behaviors by punishing noncooperative players and rewarding cooperative ones. This approach allows TFT-C to take advantage of opponents who follow cooperative strategies while still earning maximum payoffs when facing exploitative opponents.
   - By being flexible and adapting to opponents' strategies, TFT-C can outperform other strategies in a variety of scenarios, exploiting their weaknesses while maintaining a cooperative stance when it benefits the player.

Pseudocode:
```
def tit_for_tat_cooperator(round, history, n_players, k):
    if round == 1:
        action = 'C' # Cooperate in the first round as a goodwill gesture
    else:
        max_coop = find_max_cooperators(history)
        if max_coop == history[-1]: # If player was the most frequent cooperator in previous round
            action = 'C' # Cooperate
        else: # Otherwise, defect to punish noncooperation
            action = 'D'
    return action
```
'''

description_EXPLOITATIVE_461 = '''
 In this strategic game, the goal for each player is to maximize their total payoff over multiple rounds while considering the actions of other players who may not cooperate consistently. To create an exploitative strategy that's adaptive and robust against a wide range of opponent behaviors, we can design a tit-for-tat strategy with slight modifications tailored to the specific parameters of this public goods game.

1. Decision rules: The main decision rule is based on the percentage of cooperators in previous rounds (trust index). The player will cooperate when the trust index exceeds a certain threshold, and defect otherwise. The initial threshold is set to encourage cooperation in the first few rounds, but as the game progresses, it becomes more conservative to avoid exploitation by other players.

   - Initialize trust index for all players: Ti_1 = 0.5 (default equal distribution of cooperators and defector)
   - For each player i and round t:
     - Compute cooperation rate in the previous round: C_t-1 = (number of cooperators in round t-1)/n
     - Update trust index for player i: Ti_t = α*Ti_{t-1} + (1-α)*C_t-1, where α is a forgetting factor (0 < α < 1)
     - If Ti_t > cooperation threshold (initially set to 0.5), then choose action C, otherwise choose action D

2. Handle edge cases: Adjustments are necessary for the first and last rounds to account for the unique starting and ending conditions of the game.

   - First round: Every player starts with equal trust indices (Ti_1 = 0.5), so all players will initially cooperate (action C). This encourages cooperation in the initial phase, as players are not yet aware of each other's behavior.
   - Last round: Since the total game payoff is a summation over all rounds, the last round's decision does not significantly impact the overall performance of the strategy. To remain exploitative, choose action D in the final round if the trust index falls below the cooperation threshold, otherwise cooperate (action C).

3. Be exploitative: The tit-for-tat strategy is inherently exploitative in that it cooperates when others do and defects when others don't cooperate. By setting a conservative cooperation threshold, the strategy avoids being taken advantage of by other players who may consistently choose to defect. Additionally, the trust index forgetting factor (α) allows for some forgiveness if a player deviates from cooperating for one or two rounds. As the game progresses, the trust index becomes more resistant to changes, ensuring that the strategy is less likely to cooperate with non-cooperative players.

Pseudocode:

```python
def public_goods_game(n, k, r, alpha):
    # Initialize trust indices for all players
    trust_indices = [0.5] * n

    total_payoff = 0
    for t in range(1, r+1):
        cooperation_rate = sum(trust_indices) / n
        for i in range(n):
            # Update trust indices based on the cooperation rate of the previous round
            trust_indices[i] = alpha * trust_indices[i] + (1 - alpha) * cooperation_rate

            # Choose action C if trust index exceeds cooperation threshold, otherwise choose action D
            action = 1 if trust_indices[i] > 0.5 else 0

            # Calculate payoff for player i in this round
            payoff = (1 - action) + (k / n) * sum(action * trust_indices)

            # Update total payoff for player i
            total_payoff += payoff

    return total_payoff
```
'''

description_EXPLOITATIVE_462 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, TFTAC starts by cooperating (C), mimicking the first-mover advantage and fostering potential cooperation. After the first round, TFTAC adapts its strategy based on the opponents' past actions:
   - If opponent cooperated in the previous round (t-1): continue cooperating
   - If opponent defected in the previous round (t-1): defect in the current round (t) to punish the defection, then revert to cooperating in the next round
   Note that TFTAC maintains a memory of the opponent's last action.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), TFTAC cooperates to initiate cooperation, as there is no previous action to reference.
   - No special handling for the last round (r) since TFTAC's adaptive strategy will still apply. However, in practical implementation, it may be necessary to consider the penultimate round (r-1) when deciding how to act in the final round (r).

3. Be exploitative - Clearly align with the exploitative mindset
TFTAC is inherently exploitative due to its adaptive strategy:
   - It takes advantage of opponents who consistently cooperate, by receiving their contributions without reciprocating, thus maximizing private gains at their expense.
   - Simultaneously, TFTAC punishes opponents who defect, causing them to suffer the consequences of their defection and potentially inducing cooperation in subsequent rounds.

Pseudocode:
```
function TFTAC(history):
  if length(history) == 0:
    cooperate = True
  else:
    last_action = history[-1]
    if last_action == "Cooperate":
      cooperate = True
    elif last_action == "Defect":
      cooperate = False

  return cooperate
```
This pseudocode illustrates the strategy's simplicity and adaptability, making decisions based solely on game parameters and history.
'''

description_EXPLOITATIVE_463 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - Initiate cooperation in the first round (Tit for Tat starts cooperating).
   - In subsequent rounds, observe the action of the opponent from the previous round and respond with the same action (cooperate if opponent cooperated, defect if opponent defected). This rule promotes mutual cooperation when the opponent also follows TfTA, while exploiting opponents who frequently defect.
   - If an opponent repeatedly cooperates, TfTA will continue to cooperate, but if an opponent starts defecting, TfTA will respond with defection as well. This strategy avoids being taken advantage of by aggressive opponents.

2. Handle Edge Cases:
   - In the last round, since there is no future interaction, TfTA will simply choose to cooperate, regardless of the opponent's previous action, hoping to earn a higher payoff.
   - In the first round, as mentioned before, TfTA will initiate cooperation.

3. Be Exploitative:
   - By initially cooperating and then matching the opponent's actions, TfTA shows willingness to collaborate but also punishes opponents who take advantage of this by repeatedly defecting. This strategy achieves a balance between exploitation and cooperation, earning higher payoffs than pure defection strategies against cooperative opponents while defending against aggressive opponents.

Pseudocode:
```
def TfTA_strategy(opponent_actions, r, n, k):
  round = 1
  own_action = 'C' # Initiate cooperation

  total_payoff = 0

  while round <= r:
    if round == 1:
      own_action = 'C'
    elif round < r:
      if opponent_actions[round-1] == 'C':
        own_action = 'C'
      else:
        own_action = opponent_actions[round-1]

    payoff = (1 - own_action) + (k/n) * sum(opponent_actions)
    total_payoff += payoff

    round += 1

  return total_payoff
```
'''

description_EXPLOITATIVE_464 = '''
 Strategy Name: Tit-for-Tat with Variation (TfTV)

1. Specify decision rules - When exactly do you cooperate vs defect?
- In the first round, cooperate (C). This is a friendly gesture to encourage others to cooperate initially.
- From the second round onwards, observe other players' previous actions and mimic their behavior in the preceding round. If they cooperated (C), cooperate; if they defected (D), defect.
- To introduce some unpredictability and prevent being exploited indefinitely by Defectors, there is a small probability p of deviating from this mimicking behavior each round. The higher the number of consecutive defections by an opponent, the higher the probability of deviation (p increases monotonically with the number of defections).
- If p > 0.5, defect in the current round regardless of the opponent's previous action. This makes TfTV more aggressive and less forgiving towards Defectors.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the last round, cooperate (C) as a final attempt to secure some payoff from other players who might still be considering cooperation.
- In case of ties with multiple opponents having the same number of defections or cooperations, TfTV randomly chooses between cooperating and defecting based on an equal probability distribution.

3. Be exploitative - Clearly align with the exploitative mindset
TfTV is exploitative in the following ways:
- It initially cooperates to gain potential cooperation from others, but quickly adapts to their behavior, punishing Defectors and rewarding Cooperators.
- By introducing a small probability of deviation, TfTV maintains an element of unpredictability that can discourage opponents from exploiting it repeatedly.
- The higher the number of consecutive defections by an opponent, the more aggressive TfTV becomes towards them, thus punishing long-term Defectors.
- If opponents choose to defect indefinitely, TfTV will eventually switch to a more aggressive strategy (p > 0.5) to maximize its own payoff at the cost of reducing cooperation among all players.

Pseudocode:
```python
def tit_for_tat_with_variation(round_number, opponent_history):
    if round_number == 1:
        return 'C'  # Cooperate in the first round as a friendly gesture

    defector_count = sum(opponent_history[-len(opponent_history):] == 'D')
    deviation_probability = min(defector_count / len(opponent_history), 0.5)

    if deviation_probability > random.random():  # Deviate with the given probability
        return 'D'
    else:  # Mimic opponent's previous action
        if opponent_history[-1] == 'C':
            return 'C'
        elif opponent_history[-1] == 'D':
            return 'D'

def final_round_strategy(round_number):
    if round_number == len(opponent_history):  # Last round, cooperate to encourage cooperation
        return 'C'
    else:
        return tit_for_tat_with_variation(round_number, opponent_history)
```
'''

description_EXPLOITATIVE_465 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   Initially (in the first round), TFTAC starts by cooperating, representing a friendly and cooperative stance. For subsequent rounds t > 1:
   - If a player i encountered another player j that has cooperated in the previous round (t-1), then player i will also cooperate. This reflects reciprocity and trust building.
   - If player j defected in the previous round, player i will retaliate by also defecting in the current round to punish the defector.
   - In case of a mixed strategy (not all players are the same), TFTAC will mirror the most common action observed among other players in the previous round.

2. Handle edge cases:
   - First Round: Cooperate as a friendly gesture and potential sign of goodwill.
   - Last Round: Adopt the most common action observed among other players during the game to maximize payoff in the short term, while still maintaining adaptability for potential future interactions.
   - Mid-Game: Mimic the actions of opponents to maintain a balance between cooperation and defection, ensuring long-term benefits as well as punishment when necessary.

3. Be exploitative - Align with an exploitative mindset while maintaining adaptability:
   - During initial phases, TFTAC allows for potential exploitation by cooperating, which can be advantageous if opponents are also cooperative. However, it will retaliate if exploited by defecting.
   - By mimicking the actions of opponents, TFTAC is able to adapt and respond to various strategies employed by other players, exploiting their weaknesses while preserving its own long-term interests.
'''

description_EXPLOITATIVE_466 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Initial round (t=1): Cooperate (C) to foster a cooperative environment and encourage others to do the same.
   - Subsequent rounds (t>1):
      - If opponent cooperated in the previous round, cooperate in the current round (repay cooperation with cooperation).
      - If opponent defected in the previous round, evaluate the proportion of total opponents that have cooperated across all previous rounds up to t-1.
         If this proportion exceeds a certain adaptive threshold (τ), defect in the current round (punish defection); otherwise, cooperate.

2. Handle edge cases:
   - Last round (t=r): Cooperate as a final attempt to encourage cooperation and maximize payoff.
   - First few rounds (t<5): Cooperate for the initial four rounds to provide enough information for the adaptive threshold calculation, then apply the main decision rule from t=5 onwards.

3. Be exploitative:
   - The strategy is exploitative in nature as it takes advantage of opponents who repeatedly defect by punishing them, while also rewarding cooperation with further cooperation.
   - The adaptive threshold τ allows for adjustment to the aggressiveness of the strategy based on the observed behavior of other players, making it robust against various opponent behaviors.

Pseudocode:
```python
def TFTAT(n, k, r, tau):
    payoffs = [0] * r
    threshold = 0
    cooperate_count = n

    for round in range(1, r+1):
        if round == 1:
            action = 'C'  # Cooperate initially
        else:
            if opponent_action[round-1] == 'C':  # Repay cooperation with cooperation
                action = 'C'
            elif cooperate_count / (round - 1) >= tau:  # Punish defection if threshold exceeded
                action = 'D'
            else:  # Cooperate to encourage others to cooperate
                action = 'C'
                cooperate_count += 1  # Increment cooperation count if player cooperates
            payoffs[round] = calculate_payoff(n, k, player_action, opponent_actions)

    return payoffs
```
In this pseudocode, `player_action` is the action taken by the TFTAT strategy in each round, and `opponent_actions` is the sequence of actions taken by all opponents across all rounds. The function `calculate_payoff(n, k, player_action, opponent_actions)` calculates the payoff for a single round using the given game parameters and action history.
'''

description_EXPLOITATIVE_467 = '''
 In this strategic game, we'll design a robust and exploitative AI agent called "Tit-for-Tat with Adaptation" (TfTA). The TfTA strategy follows three key principles: reciprocity, forgiveness, and adaptation.

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the agent will start by considering the total number of cooperators in the previous round (t-1). If all players cooperated in the previous round, TfTA cooperates as well (C). Otherwise, it defects (D). This is the initial implementation of reciprocity: if others cooperate, the AI will also cooperate.

To introduce adaptability and prevent being exploited by opponents that repeatedly defect, we'll apply a learning mechanism. Each round, TfTA updates a memory parameter M_i which keeps track of the percentage of previous rounds in which opponent i has cooperated. The learning rate alpha determines how fast the memory parameter adjusts to new information (0 ≤ alpha ≤ 1).

In each round t, if opponent i defected in the last round (t-1), TfTA will decrease its memory parameter for opponent i by multiplying it with alpha. If opponent i cooperated, TfTA will increase its memory parameter with the same learning rate. The new value of M_i is then normalized to be between 0 and 1.

The decision rule for cooperation in round t against opponent i now depends on both the current behavior of the opponent (cooperate or defect) and the updated memory parameter M_i: if M_i > threshold, TfTA cooperates; otherwise, it defects. The threshold can be set as a hyperparameter between 0 and 1 to control the agent's forgiveness.

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, since there is no previous history, TfTA will cooperate against all opponents as a goodwill gesture or an attempt to encourage cooperation.

In the last round, if TfTA has built up enough memory about its opponents, it can still use that information to make informed decisions on how to behave. However, since the game ends after r rounds, there might not be enough time for the learning mechanism to converge. In such cases, TfTA may choose to defect in the last round as a precautionary measure to maximize its final payoff.

3. Be exploitative - Clearly align with the exploitative mindset

TfTA is designed to be exploitative by adapting to opponents' behavior and cooperating only when it benefits from doing so based on past observations. The learning mechanism allows TfTA to keep track of other players' cooperation patterns, which can help the agent exploit inconsistent or unreliable opponents who may contribute more in some rounds but not others.

By adjusting the threshold and learning rate hyperparameters, the agent can be fine-tuned to have various levels of forgiveness and adaptivity, allowing it to outperform other strategies by taking advantage of their inconsistencies.
'''

description_EXPLOITATIVE_468 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - TfTA follows a tit-for-tat approach where it starts by cooperating in the first round, mirroring the opponent's previous move thereafter. If the opponent cooperates, TfTA continues cooperation; if the opponent defects, TfTA defects in the next round and resumes cooperation once the opponent returns to cooperation.
   - To be more adaptive, TfTA includes a punishment phase when the opponent continuously defects: after a predefined number of defections (denoted as P), TfTA defects until the opponent starts cooperating again or reaches another predefined number of cooperations (denoted as Q). After this sequence, TfTA resumes its tit-for-tat behavior.
   - To further exploit opponents and encourage cooperation, TfTA reduces the punishment phase's duration based on the game's parameters. Specifically, if k is high, indicating a more significant payoff for community projects, TfTA sets P and Q lower to make defection less profitable for opponents.

2. Edge Cases:
   - First Round: TfTA cooperates.
   - Last Round (and when r < P + Q): TfTA plays the same as its opponent in the previous round, given the game's last-round effect where players may cooperate to maximize their payoffs despite past actions.

3. Exploitative Mindset:
   - By following a tit-for-tat strategy, TfTA encourages cooperation in the initial stages of the game while being prepared to defect when opponents are uncooperative or inconsistent. The adjustable punishment phase (P and Q) allows TfTA to exploit more aggressive opponents by punishing them for extended periods without cooperation.
   - By reducing P and Q based on k, TfTA makes defection less profitable for opponents in games with higher k values, where community projects are more beneficial. This encourages cooperation and exploits opponents who do not adjust their strategies accordingly.

Pseudocode:

```python
def TitForTatAdaptive(round, r, k, opponent_history):
  state = 'cooperate'  # Initial state is cooperate
  punishment_phase = False  # No active punishment phase at the start

  if round == 1:
    state = 'cooperate'  # Cooperate in the first round

  if round < r and not punishment_phase:
    state = opponent_history[round - 1]  # Mirror opponent's previous move

  if punishment_phase:
    if (round - P) % (P + Q) == 0 or round == r:  # End of punishment phase or game
      state = 'cooperate'  # Resume tit-for-tat behavior

  if opponent_history[round - 1] == 'defect':
    if not punishment_phase and k > MIN_K:
      P, Q = int(k * P_FACTOR), int(k * Q_FACTOR)  # Adjust punishment phase based on k
      punishment_phase = True

  return state  # Return action to play in this round
```

In the pseudocode:
- P_FACTOR and Q_FACTOR are constants that determine the reduction factor applied to P and Q based on k.
- MIN_K is a minimum threshold for k, below which TfTA does not adjust its punishment phase to avoid overpunishing opponents in games with low community project benefits.
'''

description_EXPLOITATIVE_469 = '''
 In this N-Player Public Goods Game, I propose a strategy that I'll call Tit-for-Tat with a twist (TFTw), which aims to be exploitative while being robust and adaptive to various opponent behaviors. The strategy is based on the classic Tit-for-Tat strategy but incorporates an element of initial suspicion and punitive response to encourage cooperation.

1. Specify decision rules:
   - TFTw cooperates in the first round, assuming others will do the same (initiate cooperation).
   - In subsequent rounds, TFTw evaluates the total number of cooperators (C_total) from the previous round and adjusts its action for the current round.
     - If C_total ≥ (n/2), TFTw cooperates to encourage further cooperation.
     - If C_total < (n/2), TFTw defects, punishing those who did not cooperate in the previous round.
   - In the last round, since there are no future rounds for punishment or reward, TFTw cooperates if C_total ≥ (n/2) in the penultimate round; otherwise, it defects.

2. Handle edge cases:
   - If n is odd, the majority threshold (n/2) ensures that at least one player always cooperates to initiate cooperation.
   - In the first round, since C_total = 0, TFTw starts by cooperating to encourage others to do so as well.

3. Be exploitative:
   - By punishing those who do not cooperate and rewarding those who do, TFTw encourages others to cooperate in the short term while taking advantage of their contributions when possible.
   - If a majority of players adopt a cooperative strategy, TFTw continues to cooperate to reap the benefits of the shared public good; otherwise, it defects to take advantage of the lack of cooperation.

Pseudocode for the Tit-for-Tat with a twist (TFTw) strategy:

```
function TFTw(round, history, n_players, k, r):
  if round == 1:
    return 'C' (Cooperate)

  C_total = sum(history[-r+1:-1])
  if C_total >= n_players/2 and round < r:
    return 'C' (Cooperate)
  else:
    return 'D' (Defect)

  if round == r:
    if C_total >= n_players/2 in the penultimate round:
      return 'C' (Cooperate)
    else:
      return 'D' (Defect)
```
'''

description_EXPLOITATIVE_470 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to establish a cooperative relationship with other players. This is the "tit" part of the strategy.
   - For subsequent rounds, observe the actions of other players in the previous round. If all players cooperated (total_contributions = n), then cooperate again (replicating the cooperation). If any player defected (total_contributions < n), then also defect in the current round (punishing the defection). This is the "tat" part of the strategy, where defection is met with defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, since the game is repeated, the strategy should not switch to defecting just because it's the final round. However, it can be more forgiving if there were many defections in recent rounds, allowing for a chance at redemption before the end of the game.
   - If a player encounters a streak of continual defection from another player (i.e., that player only defects), after a certain number of such instances, switch to always defecting against that player as a punishment.

3. Be exploitative - Clearly align with the exploitative mindset
   - The ATFT strategy is designed to be cooperative by default and punitive when necessary. However, it can be seen as exploitative in its approach to defection. By punishing defections, the strategy encourages other players to cooperate, thereby creating a beneficial environment for itself. If other players defect too often, the ATFT strategy will not hesitate to defect back to ensure better payoffs.
   - Pseudocode for the strategy:

```
function Adaptive_Tit_for_Tat(round, history, n, k):
  if round == 1:
    action = 'C' (Cooperate)
  else:
    total_contributions = sum(history[round-1])
    if total_contributions == n:
      action = 'C' (Cooperate)
    else:
      action = 'D' (Defect)
  return action
```
'''

description_EXPLOITATIVE_471 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, TFT-ACT starts by cooperating (C). However, it maintains a cooperative threshold (CT), which is initially set to the average number of cooperators across all players in the first few rounds. If the number of cooperators in a round falls below CT, TFT-ACT will start defecting (D) until CT is reached again. Once CT is met or exceeded, TFT-ACT returns to cooperating. CT adapts dynamically based on the average number of cooperators in recent rounds. If CT reaches a minimum value (CTmin), it remains at CTmin.

Pseudocode:
```
def update_cooperative_threshold(round, n, total_contributions):
    if round <= initial_rounds:
        return average_contributions(initial_rounds)
    else:
        avg = average_contributions(recent_rounds)
        if avg < CT and avg > CTmin:
            CT = avg
        return CT

def decide_action(round, n, k, own_contribution, total_contributions, CT):
    if total_contributions < CT:
        return 'D'
    else:
        return 'C'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first few rounds (initial_rounds), TFT-ACT cooperates unconditionally to encourage others to cooperate as well. After initial_rounds, TFT-ACT starts using its adaptive CT strategy. In the last round or when r is reached, TFT-ACT will cooperate if the current number of cooperators meets or exceeds its CT.

3. Be exploitative - Clearly align with the exploitative mindset
TFT-ACT aims to take advantage of other players' defections by cooperating as long as others are cooperative and adapting quickly when others start defecting. By maintaining a cooperative threshold, TFT-ACT is able to punish non-cooperative behavior while still benefiting from cooperation when it occurs. This strategy ensures that TFT-ACT does not get exploited by other players but also has the potential to take advantage of them if they are not following an exploitative strategy themselves.

Additional notes:
- The initial_rounds, CTmin, and the number of recent rounds considered (recent_rounds) can be tuned parameters for optimizing performance against various opponent strategies.
- TFT-ACT does not rely on others sharing norms or coordination mechanisms and can adapt to a wide range of opponent behaviors due to its adaptive cooperative threshold.
'''

description_EXPLOITATIVE_472 = '''
 In this N-Player Public Goods Game, let's design a strategy named Tit-for-Tat (TFT) with a slight modification for exploitation. The TFT strategy is known to perform well in repeated prisoner's dilemma games and can adapt to various opponent behaviors.

1. Specify decision rules:
   - Cooperate on the first round (F), encouraging others to cooperate as well
   - For subsequent rounds, follow the actions of opponents from the previous round:
     If an opponent cooperated in the last round (C), cooperate back (C).
     If an opponent defected in the last round (D), defect this round (D) to punish them.

2. Handle edge cases:
   - In the first round, cooperate regardless of opponents' actions (F)
   - Last round or any situation where cooperation no longer benefits the player (e.g., low remaining rounds): always defect (D) to maximize personal gain in the short term, regardless of opponents' actions.

3. Be exploitative:
   - Mimic cooperative behavior but punish defectors when possible to encourage cooperative play while also taking advantage of opponents who choose to defect frequently.

Pseudocode for the strategy:
```python
def tft_strategy(r, n, k):
    history = []  # Store past actions of all players (n-tuple)

    def get_opponent_action(i, last_round):
        # Return opponent's action in the previous round
        return history[last_round][(i - 1) % n]

    def my_action(t):
        # Decide whether to cooperate or defect based on TFT rules and past actions
        if t == 1:  # First round
            return 'C'
        elif get_opponent_action(i, t - 1) == 'D':  # Punish defector
            return 'D'
        else:  # Cooperate with cooperators and defect with defectors
            return get_opponent_action(i, t - 1)

    for round in range(1, r + 1):
        action = my_action(round)
        payoff = (1 - action) + (k / n) * sum([get_opponent_action(j, round - 1) for j in range(1, n + 1)])
        history.append((history[-1] if len(history) > 1 else ('C' for _ in range(n))))
        history[-1][(i - 1) % n] = action
        yield payoff
```
'''

description_EXPLOITATIVE_473 = '''
 Title: Tit-for-Tat Strategy (TfTS) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = 1). This encourages cooperation and can establish a friendly environment to start with.
   - In subsequent rounds, copy the action of the most frequent contributor from the previous round (highest total contributions). If there's a tie or multiple players with the same maximum contributions, cooperate as well. If no player contributed in the previous round, defect to punish those who didn't cooperate before.
   - Mathematically:
     ```
     if round = 1 then
       c_i = 1; // Cooperate in first round
     else
       most_frequent_contributor = player with the highest total contributions in previous round;
       if most_frequent_contributor exists then
         c_i = (most_frequent_contributor cooperated in previous round) ? 1 : 0;
       else
         c_i = 0; // Punish non-cooperators
     endif
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - Maintain consistency across all rounds except the first one, as mentioned above.
   - In the last round, since there are no future rounds to punish or reward players, cooperate regardless of previous actions: c_i = 1.

3. Be exploitative - Clearly align with the exploitative mindset
   - By initially cooperating and then adapting to other player's behavior, this strategy aims to maintain a high payoff while also punishing those who don't contribute to the public good consistently. The initial cooperation helps build trust and encourages others to cooperate as well, but the Tit-for-Tat nature of the strategy ensures that it will not be taken advantage of in the long run.
   - The adaptive nature of the strategy also enables it to counter various opponent behaviors such as one-time cooperation, continuous cooperation, or continuous defection.
'''

description_EXPLOITATIVE_474 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i will evaluate the proportion of cooperators in the previous r rounds (t-r to t-1), denoted as P_c(t). If P_c(t) is greater than a predefined threshold T, the player i will cooperate. Otherwise, the player will defect.

P_c(t) = (Σ(j=t-r+1 to t-1) c_j) / r

The threshold T can be adjusted based on the number of players and the multiplication factor k. A higher T encourages cooperation in situations where the majority of players have been cooperating, while a lower T makes the strategy more exploitative by allowing it to defect even when a significant portion of players are cooperating.

Pseudocode:
```python
def evaluate_coop_proportion(t, r):
    total_coops = sum(c_j for j in range(t-r+1, t))
    return total_coops / r

def decide_action(t, T, n, k):
    P_c = evaluate_coop_proportion(t, r)
    if P_c > T:
        action = 'C'  # Cooperate
    else:
        action = 'D'  # Defect
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, since there is no history to evaluate, the player will start by defecting (action D). For the last round, since there are no future rounds for opponents to retaliate, the player will follow the decision rule based on the most recent r rounds.

3. Be exploitative - Clearly align with the exploitative mindset

The TfT-A strategy is designed to be exploitative by allowing it to defect more often than cooperating. By setting a relatively low threshold T, the player can take advantage of opponents who may have cooperative strategies, while still punishing those who consistently defect. The strategy will also retaliate against opponents who betray previous cooperation by defecting in later rounds. However, it will forgive and return to cooperation if the proportion of cooperators increases again.
'''

description_EXPLOITATIVE_475 = '''
 In this N-player Public Goods Game, we'll develop a strategy named "Freeloader" that is exploitative and adaptive to various opponent behaviors while leveraging game parameters and history.

1. Specify decision rules:
The Freeloader strategy will cooperate (C) in some rounds based on the total number of contributors from previous rounds, aiming to free-ride off others' contributions. In each round t, if the percentage of contributors in the previous r-1 rounds exceeds a threshold T, then Freeloader will defect (D). Otherwise, it will cooperate (C).

```python
def freeloader(contributors_history):
    total_contributions = sum(contributors_history)
    if total_contributions / len(contributors_history) > T:
        action = 'D'  # Defect
    else:
        action = 'C'  # Cooperate
    return action
```

2. Handle edge cases:
For the first round, Freeloader cannot rely on previous rounds' data to make a decision. In this case, it randomly chooses an action (cooperate or defect) with equal probability. For the last round, Freeloader will continue following its adaptive strategy as described above.

```python
def freeloader_edge_cases(round, contributors_history):
    if round == 1:
        action = np.random.choice(['C', 'D'])
    else:
        action = freeloader(contributors_history)
    return action
```

3. Be exploitative:
The Freeloader strategy aims to maximize private payoff while minimizing contributions, which is in line with the exploitative mindset. By cooperating only when others contribute a significant portion of the game (threshold T), it benefits from the public good without contributing as much as possible.

In practice, adjusting the value of the threshold parameter T will allow fine-tuning the strategy to different game settings and opponent behaviors.
'''

description_EXPLOITATIVE_476 = '''
 In this Public Goods Game with n players, a multiplication factor k, and r rounds, let's design an exploitative strategy called "Freerider" that maximizes individual payoff while being adaptive and robust to various opponent behaviors.

1. Specify decision rules:
   - Freerider will defect (D) in every round unless it finds a sufficient number of cooperators, aiming to free-ride on others' contributions whenever possible.
   - To determine whether to cooperate (C), Freerider checks the ratio of cooperators in the previous round compared to the multiplication factor k:
     If `cooperators_ratio >= k / n`, Freerider will cooperate, otherwise it defects.

Pseudocode for decision rule:
```
def decideAction(previous_round_contributions):
    cooperators_ratio = previous_round_contributions / n
    if cooperators_ratio >= k / n:
        return 'Cooperate'
    else:
        return 'Defect'
```

2. Handle edge cases:
   - In the first round, since there is no previous history, Freerider will defect because it has no information about other players' behavior.
   - In the last round, if Freerider observes that other players have mostly cooperated in the past rounds, it may choose to cooperate to obtain a higher payoff. However, in most cases, Freerider would continue to defect since there are no penalties for free-riding in the final round.

3. Be exploitative:
   - By primarily defecting and only contributing when others do so in sufficient numbers, Freerider aims to maximize its individual payoff by taking advantage of other players' cooperative behavior without reciprocating.
   - When enough opponents contribute, Freerider joins them for mutual benefit, but it will still defect whenever possible to minimize contributions and maximize personal gains.
'''

description_EXPLOITATIVE_477 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster cooperation and show goodwill.
   - In subsequent rounds, analyze opponents' behavior and adjust contributions accordingly.
   - If opponent cooperated in the previous round (c_opponent = 1), then cooperate (C). Otherwise, defect (D). This mimics a 'trust but verify' approach.
   - To account for opponents that may occasionally deviate from cooperation, implement forgiveness by returning to cooperation after a certain number of defections (Tolerance).

Pseudocode:
```python
def TFTAC(opponent_history):
    current_round = 1
    contribution = 1  # Cooperate in the first round
    tolerance = int(n / 2)  # Number of times to tolerate defections before returning to cooperation

    while current_round <= r:
        if current_round == 1:
            contribution = 1
        else:
            contribution = 1 - opponent_history[current_round - 1]  # Defect if opponent defected, otherwise cooperate

        if contribution == 1 and opponent_history.count(0) >= tolerance:  # Return to cooperation after tolerance
            contribution = 1

        payoff = (1 - contribution) + ((k / n) * sum(opponent_history))
        current_round += 1
        opponent_history.append(contribution)
        return payoff
```

2. Edge Cases:
   - In the first round, cooperate (C).
   - In the last round, analyze the opponent's behavior up to that point and make a decision accordingly.

3. Exploitative Strategy:
   - Mimics cooperation initially but quickly adapts to punish defection to exploit opponents who rely on initial goodwill.
   - Allows for forgiveness to maintain cooperation after occasional defections, taking advantage of opponents that may occasionally deviate from cooperation.
   - The tolerance parameter can be adjusted to balance between exploitation and cooperation based on the number of players and multiplication factor (k).
'''

description_EXPLOITATIVE_478 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFTA starts by cooperating (C). If a player encounters another cooperator, it continues to cooperate in the subsequent rounds. However, if a player encounters a defector, it switches its strategy and defects in the following round as a punishment. After punishing the defection, TFTA returns to cooperating.

Pseudocode:
```
function TFTA(round, previous_opponent_action) {
    if (round == 1) return C; // Cooperate in the first round
    if (previous_opponent_action == C) return C; // Cooperate when opponent cooperates
    if (previous_opponent_action == D && round > 2) return D; // Defect as punishment for defection after the first round
    return C; // Return to cooperation after punishing defection
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTA cooperates regardless of the opponent's action (since it doesn't have a previous history). In the last round, TFTA again cooperates if its previous opponent cooperated; otherwise, it defects as a final punishment. For other edge cases like multiple rounds with no opponent or uncooperative opponents from the start, TFTA consistently defects.

Pseudocode:
```
function is_first_round(round) {
    return round == 1;
}

function is_last_round(round, r) {
    return round == r;
}

function no_opponent_history(round) {
    return round == 1;
}
```

3. Be exploitative - Clearly align with the exploitative mindset

TFTA exhibits an exploitative strategy by cooperating when opponents do so but punishing defection with a temporary switch to self-interest. This approach allows TFTA to maintain long-term cooperation while also taking advantage of opponents who repeatedly defect, as their payoff decreases over time due to the reduced public goods contributions.

Pseudocode:
```
function TFTA(round, previous_opponent_action) {
    if (is_first_round(round)) return C; // Cooperate in the first round
    if (no_opponent_history(round)) return D; // Defect when no opponent history
    if (previous_opponent_action == C) return C; // Cooperate when opponent cooperates
    if (previous_opponent_action == D && round > 2) return D; // Defect as punishment for defection after the first round
    return C; // Return to cooperation after punishing defection
}
```
'''

description_EXPLOITATIVE_479 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round, cooperate (C), setting a tone of initial cooperation.
   - For subsequent rounds t, analyze the total contributions in the previous round (t-1) and respond accordingly:
     - If total_contributions(t-1) > (n/2), continue to cooperate (C).
     - If total_contributions(t-1) ≤ (n/2), defect (D).
   - This rule encourages cooperation when the majority of players also contribute, but responds with defection when exploited by most players.

2. Handle edge cases:
   - In the last round, if total_contributions(t-1) > (n/2), continue to cooperate (C). If not, defect (D), as there are no more chances for the opponents to be punished for defection in the future rounds.
   - For the first round, cooperate (C) regardless of the opponents' strategies due to the initial cooperation rule mentioned above.

3. Be exploitative:
   - TFT-AC is an adaptive strategy that maintains a balanced approach between cooperation and defection based on the history of total contributions in previous rounds. It encourages cooperation when it benefits but responds with defection when exploited, effectively penalizing opponents who do not cooperate while maintaining the option to cooperate if it results in higher payoffs.
   - The strategy is exploitative in that it takes advantage of opponents' self-interested behaviors by either cooperating when they do (earning similar payoffs) or defecting when they don't (punishing their selfish actions). However, TFT-AC also allows for mutual cooperation when the majority of players contribute, which can lead to a higher total payoff for all.
'''

description_EXPLOITATIVE_480 = '''
 In this Public Goods Game, we will design an exploitative strategy called "Conditional Cooperative Tit-for-Tat" (CCTFT). The aim is to cooperate when it benefits us and defect when it seems advantageous to punish non-cooperating opponents.

1. Decision Rules:
   - Initiate cooperation (play C) in the first round and follow the history of other players' actions.
   - In subsequent rounds, if an opponent cooperated in the previous round, then cooperate as well (play C).
   - If an opponent defected in the previous round, then defect in the current round (play D). This is our punitive action to encourage opponents to cooperate in the future.
   - If the total number of players drops below a certain threshold (e.g., n/2) due to defections or game termination, reset the strategy to initial cooperation for the next round.

2. Edge Cases:
   - First Round: Cooperate unconditionally since there is no previous history.
   - Last Round: Evaluate the total payoff obtained over the rounds and play C if the total payoff exceeds a predefined threshold, else play D. This allows the strategy to benefit from any potential cooperation during the final round.
   - Partial Defection: If some opponents defect while others continue cooperating, follow the defined decision rules for each opponent individually.
   - Game Termination: If the game is terminated prematurely due to a set number of rounds or other conditions, evaluate the total payoff obtained so far and adjust the strategy accordingly for future games (e.g., reset to initial cooperation if the total payoff is low).

3. Exploitative Mindset:
   - Cooperate when it benefits us in terms of higher total payoffs over multiple rounds, but punish opponents who do not cooperate by defecting ourselves.
   - Maintain the potential for future cooperation while being opportunistic and exploiting opponents' defections when they occur.
   - Use historical information about other players' actions to make informed decisions and adjust strategies based on their behavior.

Pseudocode:

```python
def CCTFT(n, k, r):
    players = [init_cooperation() for _ in range(n)]  # Initialize all players as cooperators
    total_payoff = 0

    for round in range(r):
        # Evaluate opponents' actions from the previous round
        opponents_cooperated = sum([player.last_action == 'C' for player in players])

        # Adjust strategy based on opponents' actions and game state
        if round == 0:
            for player in players:
                player.play('C')  # All players cooperate in the first round
                player.update_history()

        elif opponents_cooperated >= n/2:
            for player in players:
                player.play('C')  # Cooperate when most opponents did so in the previous round
                player.update_history()

        elif opponents_cooperated < n/2 and total_payoff > threshold:
            for player in players:
                player.play('C')  # Cooperate if our total payoff exceeds a predefined threshold
                player.update_history()

        else:
            for player in players:
                player.play('D')  # Defect when most opponents did not cooperate in the previous round
                player.update_history()

        total_payoff += calculate_payoff(players, n, k)

    return total_payoff
```

This Conditional Cooperative Tit-for-Tat strategy allows for adaptability and robustness against a wide range of opponent behaviors while maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_481 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-A starts by cooperating in the first round, mimicking a peaceful and cooperative approach. In subsequent rounds, it adapts its behavior based on the opponents' actions in the previous round:
   - If opponent cooperated in the last round, TFT-A cooperates back in the current round.
   - If opponent defected in the last round, TFT-A also defects in the current round to punish the opponent for not cooperating.
   - To add an element of forgiveness and encourage cooperation, TFT-A will revert to cooperative behavior after a certain number (N) of consecutive defections from the opponent, with N being a parameter that can be adjusted based on the opponents' average cooperative rate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: TFT-A cooperates as a goodwill gesture towards the opponent.
   - Last round (or when reaching N consecutive defections from the opponent): TFT-A will defect to ensure maximum personal gain and punish the opponent's lack of cooperation.
   - If TFT-A reaches a situation where it has been cooperating for a while, but the opponent continues to defect, it will gradually decrease the number of N required for forgiveness (i.e., allowing fewer defections before reverting back to cooperation). This can help maintain cooperation for longer and encourage opponents to change their strategies.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-A's exploitative nature comes from its adaptability and ability to punish opponents who do not cooperate, while also being willing to forgive and rebuild trust if the opponent starts cooperating again. By doing so, it encourages opponents to cooperate more often in order to earn higher payoffs. At the same time, TFT-A does not hesitate to defect when necessary to maximize its own payoff, making it a formidable competitor in the game.

Pseudocode:

```python
def TFT_A(opponent_history, n, N=10):
    current_round = len(opponent_history) + 1
    own_action = 'C'  # Cooperate by default

    if current_round == 1:
        own_action = 'C'
    elif current_round < n:
        last_round = opponent_history[-1]
        if last_round == 'C':
            own_action = 'C'
        else:
            own_action = 'D'
    elif current_round >= n + N and opponent_history[-N:] == ['D'] * N:
        own_action = 'D'
    elif current_round > n and opponent_history[-1] != 'C':
        N -= 1
        if N < 1:
            N = 10
    return own_action
```

The strategy takes the history of the opponent's actions as input, along with game parameters (n, k) and the forgiveness parameter (N). The pseudocode outlines the decision-making process for each round based on the specified rules.
'''

description_EXPLOITATIVE_482 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round (Favor cooperation to promote trust).
   - In subsequent rounds, repeat the action of the opponent from the previous round (Adaptive strategy that aims to reciprocate, avoiding being taken advantage of).

Pseudocode:
```
function TFTC(round, history):
  if round == 1:
    return Cooperate()
  else:
    last_action = history[round-1]
    return last_action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate to ensure maximum payoff (No need to retaliate).

3. Be exploitative - Clearly align with the exploitative mindset
   - Although not inherently exploitative, TFTC can be seen as a strategy that punishes selfish behavior while maintaining cooperation when it benefits the player. This can potentially allow TFTC to gain more overall payoff compared to less cooperative strategies in the long run.
'''

description_EXPLOITATIVE_483 = '''
 In this strategic game, let's call the proposed exploitative strategy "Adaptive Tit-for-Tat with Gradient Adjustment" (ATFG). The ATFG strategy aims to maximize payoff while being robust against a wide range of opponent behaviors.

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) in the first round as a goodwill gesture, setting initial trust for opponents.
     Pseudocode: if t = 1 then C else follow Step 2.

   - Subsequent Rounds (t > 1):
      1.a) Calculate the opponent's past average cooperation rate (average_cooperation). This is based on the number of previous rounds in which the opponent has cooperated (n_cooperate) and the total number of rounds played so far (r).
         Pseudocode: average_cooperation = n_cooperate / r

      1.b) Based on the calculated average cooperation rate, the strategy adjusts its own cooperation decision using a threshold value (threshold) that determines when to cooperate or defect.
         - If average_cooperation >= threshold then Cooperate (C) as it seems the opponent is more likely to cooperate in the future.
         - Otherwise Defect (D) since the strategy assumes the opponent will not cooperate.
           Pseudocode: if average_cooperation >= threshold then C else D

      1.c) Adjust the threshold value based on the opponent's response to previous cooperation attempts. If the opponent has consistently cooperated after the strategy has cooperated (increment_cooperators), increase the threshold value slightly. Conversely, if the opponent has taken advantage of the strategy's cooperation (defectors), decrease the threshold value slightly.
         Pseudocode: if increment_cooperators > defectors then threshold += delta_threshold else threshold -= delta_threshold

   - Last Round (t=r): The strategy defects (D) as it no longer has opportunities to punish uncooperative opponents.
     Pseudocode: if t = r then D

2. Handle edge cases:
   - Initial cooperation provides an opportunity for opponents to establish trust and cooperate in the future, which may lead to a higher payoff for the strategy.
   - Adjusting the threshold value based on past cooperations and defections helps the strategy adapt to a variety of opponent behaviors while maintaining its exploitative nature.
   - Defecting in the last round ensures that the strategy does not suffer from any potential retaliation or cooperation attempts from opponents.

3. Be exploitative:
   - The ATFG strategy starts with a cooperative gesture, but it quickly becomes exploitative by adjusting its behavior based on past opponent actions. If an opponent consistently cooperates, the strategy will also cooperate, maximizing payoff for both players. Conversely, if an opponent is uncooperative, the strategy punishes them and adjusts its threshold to expect continued uncooperation.
   - By gradually increasing or decreasing the threshold value based on the opponent's response, the ATFG strategy maintains a balance between cooperation and exploitation, making it robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_484 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the initial round, cooperate (C). This is a peaceful opening move to encourage cooperation among opponents.
   - For subsequent rounds t > 1, evaluate the opponent's previous cooperation rate (CR_opp,t-1) as follows:
     - If CR_opp,t-1 >= Cooperation Threshold (CT), cooperate (C). This rewarding response encourages cooperation from cooperative opponents.
     - Else if CR_opp,t-1 < CT - Punishment Threshold (PT), defect (D). This uncooperative response punishes uncooperative opponents to deter defection.
     - Else maintain the previous action taken towards the opponent (copy action from round t-2: C or D). This response follows the opponent's actions, which can help establish a pattern and potentially lead to future cooperation.

2. Handle edge cases:
   - In the last round, defect (D), as there are no further rounds for reciprocity or punishment to take effect.
   - If an opponent switches strategy in the middle of a game, maintain the current evaluation rule for that opponent and adjust CT and PT accordingly based on their new cooperation rate.

3. Be exploitative:
   - TFT-ACT starts cooperatively but responds with defection to uncooperative opponents to maximize personal gain while not overly punishing opponents (using PT).
   - By adapting the cooperation threshold dynamically, the strategy can effectively respond to a wide range of opponent behaviors and maintain an exploitative edge.
'''

description_EXPLOITATIVE_485 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (c_i = C). This encourages cooperation since the opponent might also start cooperatively.
   - In subsequent rounds, monitor the total number of cooperators (total_contributions). If this number is equal to or greater than a certain threshold, cooperate (c_i = C). Otherwise, defect (c_i = D). The threshold should be a fraction of the total players (n), and it will be adjusted dynamically over time.
   - If an opponent switches from cooperation to defection, wait for a grace period before retaliating with defection. This prevents unnecessary escalation and maintains the possibility of future cooperation.

2. Handle edge cases:
   - In the first round, cooperate as mentioned earlier (c_i = C).
   - In the last round, since there will be no future interactions, always defect (c_i = D) to maximize private payoff.
   - If the total number of players (n) changes during the game, adjust the threshold accordingly while considering the new value of n.

3. Be exploitative:
   - The strategy is designed to encourage cooperation when it appears beneficial and retaliate against defection to exploit opponents who deviate from cooperative behaviour. This creates a balance between cooperation and defection that can yield higher payoffs compared to purely exploitative or purely cooperative strategies.
   - By adjusting the cooperation threshold dynamically, the strategy becomes more adaptive to various opponent behaviours, maintaining an edge in terms of exploitation while minimizing unnecessary defections that might harm long-term cooperation prospects.
'''

description_EXPLOITATIVE_486 = '''
 Title: Tit-for-Tat with Adaptive Contribution Strategy (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a collaborative environment and encourage others to reciprocate.
   - In subsequent rounds, if the number of cooperators in the previous round is equal to or greater than the average number of cooperators over the last few rounds, cooperate. This mirrors Tit-for-Tat strategy's approach of cooperation by default but also encourages a higher level of collaboration.
   - If the number of cooperators in the previous round is less than the average number of cooperators over the last few rounds, defect to punish non-cooperative behavior and discourage such actions in the future.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - For the last round, since there are no subsequent rounds to punish non-cooperative behavior, always cooperate regardless of the previous round's outcome. This ensures maximizing potential payoff in the final round.

3. Be exploitative - Clearly align with the exploitative mindset:
   - While TFTAC has a cooperative nature due to its initial cooperation and responsiveness to other players' actions, it can also be considered exploitative because it retaliates against non-cooperative behavior by defecting. This response may encourage others to cooperate to avoid being punished, thus indirectly benefiting from their cooperation.
   - Moreover, TFTAC is adaptive and robust to a wide range of opponent behaviors because it adjusts its actions based on the number of previous round cooperators relative to the average over a few rounds. This allows it to respond effectively to both stable and unstable opponent strategies.
'''

description_EXPLOITATIVE_487 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TfTA)

1. Specify decision rules:
   - TfTA starts by cooperating in the first round (C). This is a gesture of goodwill, helping to build trust and avoid immediate exploitation.
   - For subsequent rounds, TfTA adapts its strategy based on the opponents' previous actions. If the opponent cooperated in the previous round, TfTA cooperates as well. If the opponent defected, TfTA defects in the current round to punish the defection. This tit-for-tat behavior encourages cooperation and discourages immediate exploitation.
   - To exhibit adaptive generosity, TfTA will occasionally cooperate even when opponents have previously defected (with a certain probability p). This encourages opponents to reconsider their defection strategy and potentially cooperate in the future. The value of p can be adjusted based on the observed behavior of the opponent.
   - When the game is nearly over (r - x rounds remaining, where x is a small constant), TfTA will always cooperate, hoping that opponents may reciprocate in the last rounds for higher overall payoff.

2. Handle edge cases:
   - In the first round, TfTA cooperates (C).
   - If r - x < 0, TfTA does not adjust its strategy towards being more generous because there are no remaining rounds to benefit from it.
   - The choice of x should be small enough to allow a significant number of potential payoffs to be influenced by the last-round cooperation but not so large that TfTA continues cooperating for too many rounds after the game has effectively ended.

3. Be exploitative:
   - By occasionally cooperating when opponents defect, TfTA maintains an exploitative mindset by encouraging opponents to reciprocate and cooperate more frequently, leading to higher payoffs overall.
   - The use of a tit-for-tat strategy helps prevent immediate exploitation while allowing for some generosity, creating the potential for long-term cooperation and higher payoffs compared to purely exploitative strategies.
   - By adjusting the probability p based on opponent behavior, TfTA can adapt its generosity level to better exploit opponents that are more cooperative or less prone to defection.

Pseudocode:
```python
def TfTA(round, r, x, p):
  strategy = []
  if round == 1:
    strategy.append('C') # Cooperate in the first round

  for t in range(2, r + 1):
    last_round = (t - 1) % r  # Use modulus to handle repeated game structure

    if last_round < x and strategy[last_round] == 'D':  # Near the end of the game, always cooperate when opponent defected previously
      strategy.append('C')
    else:  # Otherwise, decide whether to cooperate or defect based on opponent's previous action
      if strategy[last_round - 1] == 'C':  # If opponent cooperated in the last round, cooperate this round
        strategy.append('C')
      elif strategy[last_round - 1] == 'D':  # If opponent defected in the last round, defect this round if p > random()
        if p > random():
          strategy.append('D')
        else:  # With probability p, cooperate to show generosity
          strategy.append('C')

  return strategy
```
'''

description_EXPLOITATIVE_488 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfT-A)

1. Specify decision rules:
   - In every round t (except the first), cooperate (C) if the total number of cooperators in the previous round (t-1) is greater than or equal to a threshold (T). Otherwise, defect (D). The threshold T is set as the average number of cooperators over the past 'm' rounds.
   - In the first round and for all subsequent last r % m rounds (last rounds when considering past 'm' rounds), defect (D). This ensures that the strategy doesn't start with excessive cooperation and remains cautious towards the end of the game.

Pseudocode:
```
def TfT_A(history, r, m):
    total_cooperators = 0
    for i in range(m - 1):
        total_cooperators += history[i]
    avg_cooperators = total_cooperators / m

    if t == 1 or (t > r - r % m and t <= r):
        action = "D"
    else:
        if sum(history[t-m:t]) >= avg_cooperators:
            action = "C"
        else:
            action = "D"

    return action
```

2. Handle edge cases:
   - In the first round, defect because no past history is available.
   - For all subsequent last r % m rounds, defect to ensure caution and adaptability towards the end of the game.

3. Be exploitative:
   - TfT-A adopts an exploitative mindset by cooperating only when it seems beneficial based on the average number of cooperators in the past 'm' rounds. This strategy punishes opponents who defect consistently and rewards those who cooperate frequently. However, it remains cautious at the beginning and end of the game to avoid being overexploited.
   - By keeping track of the past 'm' rounds, TfT-A can adapt to different opponent behaviors and is less susceptible to short-term exploitation or manipulation tactics.
'''

description_EXPLOITATIVE_489 = '''
 In this public goods game with n players, a multiplication factor k, and r rounds, let's design an adaptive and exploitative strategy called Tit-for-Tat-Plus (TfTP). This strategy is inspired by the classic Tit-for-Tat strategy but is tailored for being more exploitative in the given game environment.

1. Decision rules:
   - In each round, the TfTP strategy starts by cooperating if the total number of cooperators from the previous round exceeds a predefined threshold 't' (e.g., t = floor(n/2)). If the total number of cooperators is less than or equal to 't', the strategy will defect.
   - The threshold 't' is initially set to n/2 and can be updated based on opponents' behavior in previous rounds, as explained below.
   - In the case where there were no previous round (first round), TfTP will cooperate if more than half of the players are known to have cooperated in the past games (if any). If not, it will defect.

2. Handling edge cases:
   - First round: If no history is available, TfTP will cooperate when more than half of the players have a reputation for cooperating in previous games. Otherwise, it will use its initial decision rule based on 't'.
   - Last round: TfTP will maintain its current threshold 't' and continue playing according to its decision rules as usual.

3. Being exploitative:
   - When facing opponents who consistently defect, TfTP will lower the threshold 't' over time to encourage cooperation from those defectors while still being able to punish frequent cooperators.
   - Conversely, if there are opponents who frequently cooperate, the strategy will gradually increase the threshold 't' to exploit their cooperative nature by only cooperating when more players join in.

Pseudocode for TfTP:
```
initialize function:
  n_players = number of players
  r_rounds = number of rounds
  k_factor = multiplication factor (1 < k < n)
  t = floor(n/2) # initial threshold
  history = {} # dictionary to store opponent behaviors per round

round function:
  if no previous round:
    cooperate if more than half of players have a reputation for cooperation in the past games
    otherwise defect
  else:
    calculate total_cooperators from the previous round
    if total_cooperators > t:
      cooperate
    else:
      defect

update function (after each round):
  update history with current opponent's action and the number of cooperators in that round
  if opponent consistently defects:
    decrease threshold 't' slightly
  elif opponent frequently cooperates:
    increase threshold 't' slightly
```
'''

description_EXPLOITATIVE_490 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTAC starts by cooperating in the first round, assuming that others may also be cooperative. For subsequent rounds:
   - If a player has cooperated in the previous round, return cooperation to encourage continued cooperation.
   - If a player has defected in the previous round, defect to punish them for their action and encourage future cooperation if they change their strategy.
   - To be adaptive, TFTAC maintains a cooperation rate (c_rate) that adjusts based on the opponent's past actions:
     - If the number of consecutive cooperations exceeds a certain threshold (t_coop), increase c_rate.
     - If the number of consecutive defections exceeds a certain threshold (t_defect), decrease c_rate.
   The cooperation rate should be chosen based on the game parameters to achieve an optimal balance between exploitation and collaboration.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFTAC always cooperates to maximize potential rewards while encouraging cooperation from others.
   For the last round (or any round near the end), TFTAC switches to a more exploitative strategy by choosing actions based on the current c_rate, rather than trying to build future cooperation.

3. Be exploitative - Clearly align with the exploitative mindset
   TFTAC is designed to exploit opponents while maintaining the potential for collaboration and reward when playing long-term repeated games. By punishing defection and encouraging cooperation, TFTAC seeks to maximize its own payoff while also potentially inducing others to cooperate more frequently. This creates a dynamic environment where opponents may be more likely to collaborate due to TFTAC's cooperative behavior in response to their cooperation, but will be penalized for defection.
'''

description_EXPLOITATIVE_491 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules:
   - In the initial round (t=1), cooperate to foster cooperation and demonstrate goodwill.
   - In subsequent rounds, mimic the opponent's previous action from the most recent round (i.e., if opponent cooperated in the last round, cooperate; otherwise defect).
   - If a player switches strategies in the middle of the game, revert to the initial strategy (cooperate) for one round before resuming TfT-A behavior. This allows players to test new strategies without punishing them too harshly.

2. Handle edge cases:
   - Last round (t=r): Cooperate, regardless of opponent's previous action, as there is no future interaction to consider.
   - First round (t=1) and potential second rounds with new opponents: cooperate to encourage cooperation and demonstrate goodwill.

3. Be exploitative:
   - The strategy aims to punish defectors, while maintaining long-term cooperation when possible. By switching strategies in the middle of the game, it allows for a single act of deflection before returning to TfT-A behavior. This encourages other players to consider their actions carefully and weigh the potential costs and benefits of defection.
   - The strategy does not rely on specific coordination mechanisms, communication, or shared norms, making it robust against various opponent behaviors and strategies.

Pseudocode:
```
def TfT_A(opponent_history, n, k, r):
    strategy = []

    if t == 1:
        strategy.append('C')  # cooperate in the first round

    for i in range (2, r+1):
        if opponent_history[i-1] == 'C':
            strategy.append('C')  # mimic cooperation if opponent cooperated last round
        else:
            strategy.append('D')  # defect if opponent defected last round

    if t == r:  # last round, cooperate regardless of opponent's previous action
        strategy.append('C')

    return strategy
```
'''

description_EXPLOITATIVE_492 = '''
 Strategy Name: Tit-for-Tat with Variance (TfTV)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfTV strategy is designed to be exploitative while remaining adaptive and robust against a wide range of opponent behaviors. In each round, the strategy will decide whether to cooperate or defect based on its own past actions and the total number of cooperators in the previous round (total_coop_prev).

- If total_coop_prev > (n/2), the strategy cooperates (C). This rule encourages cooperation when a majority of players contribute to the public good.
- If total_coop_prev <= (n/2) and the strategy's past action was cooperative, it continues cooperating (C). This rule rewards opponents who also choose cooperation, even if they were outnumbered in the previous round.
- If total_coop_prev <= (n/2) and the strategy's past action was defective, it switches to defecting (D). This rule punishes opponents who chose not to cooperate, encouraging them to contribute to the public good in the future.
- To introduce some variance and reduce predictability, there is a small probability (p) that the strategy will randomly switch its decision in response to the same state (total_coop_prev <= (n/2) and past action was defective). This helps avoid getting trapped in repeated cycles of defection with opponents who are also following a punishing strategy.

Pseudocode:
```
function TfTV(round, total_coop_prev, past_action, p) {
  if (total_coop_prev > n/2) return 'C'; // Cooperate when majority contributes
  if (past_action == 'C' && total_coop_prev <= n/2) return 'C'; // Continue cooperating if opponent also cooperated
  if (past_action == 'D' && total_coop_prev <= n/2) return 'D'; // Punish opponents who did not contribute
  // Introduce some randomness to avoid predictability
  if (random(0, 1) < p) return opposite_of(past_action);
  return past_action;
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since TfTV is designed to be adaptive and robust against a wide range of opponent behaviors, it does not require special handling for edge cases like the first or last rounds. The strategy will make decisions based on the information available at each round (total_coop_prev), which includes the number of cooperators in the previous round.

3. Be exploitative - Clearly align with the exploitative mindset

TfTV is designed to be an exploitative strategy as it punishes opponents who do not contribute to the public good, while rewarding those who do. However, it also introduces some randomness (p) to maintain adaptability and avoid getting trapped in repeated cycles of defection with other punishing strategies. This makes TfTV more difficult for opponents to exploit, as they cannot predict the strategy's actions with certainty.

The variance introduced by the small probability (p) ensures that TfTV does not always follow a tit-for-tat approach and can respond differently to the same situation, making it harder for opponents to anticipate its moves. This adaptive nature allows TfTV to be more robust against a wider range of opponent behaviors, making it a formidable competitor in the tournament.
'''

description_EXPLOITATIVE_493 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TfTGC)

1. Specify decision rules:
   - Start by cooperating for the first few rounds (e.g., first 5 rounds). This encourages trust and promotes cooperation among opponents.
   - After the initial phase, observe the opponent's behavior in the previous round. If the opponent cooperated, also cooperate; if not, defect. This replicates the Tit-for-Tat strategy from game theory.
   - Gradually increase the number of consecutive cooperative rounds before retaliating against defection. For example, if the opponent defected in round t, wait until round t+s (where s is a slowly increasing sequence) to retaliate. This makes the strategy more resilient against short-term deviations from cooperation.
   - If the game reaches its final round and the opponent has not cooperated since the last phase change, defect to maximize individual payoff in the remaining round.

2. Handle edge cases:
   - In the first round, always cooperate to foster trust and encourage cooperation among opponents.
   - If an opponent switches from cooperation to defection after a long period of mutual cooperation, gradually reduce the number of rounds before retaliating instead of immediately defecting. This reduces the severity of punishment and encourages the opponent to reconsider their strategy.

3. Be exploitative:
   - By cooperating initially and gradually adjusting the response to defection, the TfTGC strategy appears cooperative, making it more likely that opponents will also cooperate. However, when an opponent defects or demonstrates non-cooperative behavior, the strategy retaliates in a gradual manner to ensure individual payoff is maximized while minimizing the impact on potential future cooperation.
   - By gradually increasing the number of consecutive cooperative rounds before retaliating against defection, the TfTGC strategy becomes more resilient against short-term deviations from cooperation, making it harder for opponents to exploit the strategy and ensuring a higher average payoff.
'''

description_EXPLOITATIVE_494 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFTAC strategy will start by cooperating, then adapt its future actions based on the opponent's previous moves in the current and past rounds:
   - If the opponent cooperated in the last round (t-1), cooperate in the current round (t).
   - If the opponent defected in the last round (t-1) but has previously cooperated for at least one round, defect in the current round (t).
   - If the opponent has never cooperated before, keep cooperating. This initial cooperation could incentivize the opponent to change their strategy.
   - Once a player starts defecting after cooperating initially, they will continue to defect until the opponent starts cooperating again.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, every player cooperates (since there is no past data).
   - In the last round, players should consider their total payoff across all rounds to decide whether to cooperate or defect. TFTAC will favor cooperation if it leads to a higher total payoff.

3. Be exploitative - Clearly align with the exploitative mindset
   TFTAC is an exploitative strategy because it only starts cooperating when it expects reciprocation from its opponent. If an opponent consistently defects, TFTAC will respond in kind, maximizing short-term payoffs at the expense of long-term cooperation opportunities. However, if an opponent demonstrates cooperation after initially defecting, TFTAC will reward that change in behavior with continued cooperation. This strategy assumes that others will try to exploit it and adjusts its actions accordingly to minimize losses while still having the potential for high rewards when cooperation occurs.

Pseudocode:
```python
def TFTAC(n, r, k):
    player_history = [['C'] * r for _ in range(n)]  # initialize history as all cooperate
    current_round = 0

    while current_round < r:
        current_round += 1

        if current_round == 1:  # first round, everyone cooperates
            for i in range(n):
                player_history[i][current_round - 1] = 'C'
                continue

        for i in range(n):
            if player_history[(i-1) % n][current_round - 1] == 'C':  # opponent cooperated last round
                player_history[i][current_round - 1] = 'C'
            elif current_round > 2 and any(player_history[(i-1) % n][t] == 'C' for t in range(current_round - 2)):  # opponent has cooperated before
                player_history[i][current_round - 1] = 'D'
            else:  # no cooperation history or initial cooperation from opponent
                player_history[i][current_round - 1] = 'C'

        payoffs = calculate_payoffs(n, k, player_history)
        update_total_payoff(player_history, payoffs)

def calculate_payoffs(n, k, player_history):
    total_contributions = sum([sum(row) for row in player_history])
    payoffs = [0] * n
    for i in range(n):
        payoffs[i] = (1 - player_history[i][-1]) + (k/n) * total_contributions
    return payoffs

def update_total_payoff(player_history, payoffs):
    for i in range(n):
        player_history[i][-1] = 'PAYOFF'  # mark last entry as payoff
```
'''

description_EXPLOITATIVE_495 = '''
 Title: Tit-for-Tat-Gradient Strategy (TfTG)

1. Specify decision rules:
   TfTG maintains a memory of past encounters with each opponent and responds accordingly in subsequent rounds. Initially, it starts by cooperating in the first round to foster a cooperative environment. In every subsequent round i, TfTG evaluates its opponent's behavior from round (i-1) and adjusts its own decision using the following rules:

   - If the opponent cooperated in the previous round, TfTG cooperates as well (C).
   - If the opponent defected in the previous round, TfTG defects in the current round (D).

   However, TfTG introduces a gradient exploitation mechanism to make slight deviations from strict tit-for-tat behavior. This allows it to potentially benefit when encountering opponents who demonstrate an unusual pattern of cooperation or defection. The probability p of defecting despite the opponent's cooperation decreases exponentially as the number of consecutive cooperative rounds increases, and vice versa for the probability q of cooperating despite the opponent's defection.

   Pseudocode:
   ```
   function TfTG(opponent_history):
       memory = [0] * n    # Initialize memory with zeros
       p, q = 0.5, 0.5     # Initial probability of cooperation or defection
       for round in rounds:
           if round == 1:      # Cooperate in the first round
               action = 'C'
           else:
               if memory[opponent] >= number_of_consecutive_cooperations:
                   p *= (1 - gradients['cooperation'])
                   q *= (1 + gradients['defection'])
               else:
                   p *= (1 + gradients['cooperation'])
                   q *= (1 - gradients['defection'])

               if opponent_history[round-1] == 'C':
                   action = choose_action_with_probability(p)  # Cooperate with probability p
               else:
                   action = choose_action_with_probability(q)  # Defect with probability q

               memory[opponent].append(action)  # Update memory for opponent
               return action
   ```

2. Handle edge cases:
   - In the first round, TfTG always cooperates to initiate a potential cooperative relationship.
   - In the last round, TfTG chooses an action based on its memory of the opponent's previous actions, following the same decision rules as in other rounds.
   - If an opponent deviates significantly from cooperative or defection patterns, TfTG adjusts its gradients accordingly to adapt to new strategies encountered.

3. Be exploitative:
   The Tit-for-Tat-Gradient strategy maintains a balance between cooperation and defection while allowing for gradual exploitation of opponents who deviate from cooperative or defection norms. By learning and adapting to the opponent's behavior, TfTG aims to maximize its total payoff over multiple rounds without relying on specific coordination mechanisms or shared norms among players. The gradient adjustment mechanism makes it a versatile strategy that can perform well against various opponent behaviors.
'''

description_EXPLOITATIVE_496 = '''
 Title: Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initiate cooperation in the first round (C) to foster a cooperative environment.
   - In subsequent rounds, mimic the previous action of the player i (C or D). This rule promotes reciprocity and helps avoid being taken advantage of by defectors.
   - If a player deviates from cooperation during a round, return to cooperation in the next round (Tit-for-Tat behavior). This strategy encourages cooperation when possible while punishing defection.

Pseudocode:
```python
def TfT_E(round, history, n, k):
  if round == 1: # Initiate cooperation in the first round
    action = 'C'
  else:
    lastAction = history[round - 1] # Get previous player's action from history
    if lastAction == 'C': # If opponent cooperated, cooperate too
      action = 'C'
    else: # Otherwise, defect to punish defection and encourage cooperation
      action = 'D'
  return action
```

2. Handle edge cases:
   - In the last round, since there will be no next round for retaliation or future cooperation, simply mimic the opponent's previous action (C or D).

3. Be exploitative:
   - The TfT-E strategy is inherently exploitative by punishing defection and encouraging cooperation. By defecting when opponents defect and cooperating when they cooperate, it ensures that cooperators are not taken advantage of while also making it difficult for defectors to profit from their actions in the long run due to the repeated interactions.
   - Additionally, initiating cooperation in the first round can be seen as a form of benevolent exploitation by creating an environment where other players may cooperate initially, which could lead to higher payoffs for TfT-E if they do not adapt their strategies.
'''

description_EXPLOITATIVE_497 = '''
 Strategy Name: Tit-for-Tat with Modified Cooperation Threshold (TFT-MCT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (first_round = Cooperate). This demonstrates a willingness to cooperate and sets an initial cooperative tone.
   - In subsequent rounds, evaluate the total number of opponents who have cooperated (total_cooperation) in the previous r-1 rounds. If more than half of the opponents have cooperated, cooperate (Cooperate). Otherwise, defect (Defect). This rule encourages cooperation when it is reciprocated but retaliates against persistent defection.
   - Modify the cooperation threshold to make the strategy slightly less cooperative over time. Divide the total number of opponents by a factor that increases with the round number (n_rounds) and compare the result to 0.5 to decide whether to cooperate or defect:
     ```python
     cooperation_threshold = 0.5 + (1 - 0.5) * (r - n_rounds) / r
     if total_cooperation >= cooperation_threshold:
         Cooperate
     else:
         Defect
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (n_rounds = 1), cooperate as described above because there is no history to consider.
   - In the last round, behave similarly to the rest of the game: compare the total number of opponents who have cooperated in the previous r-1 rounds against the modified cooperation threshold and decide whether to cooperate or defect.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy initially cooperates but becomes progressively less cooperative over time, allowing it to take advantage of opponents who are more willing to cooperate early on while punishing those who consistently defect.
   - By setting an initial cooperative tone, the strategy tries to lure opponents into cooperating before adapting its behavior based on their actions. This makes it harder for opponents to anticipate and counter the strategy effectively.
   - The modified cooperation threshold ensures that the strategy does not become overly cooperative or overly defective, striking a balance between exploiting opponents while maintaining some level of cooperation to prevent being isolated and punished.
'''

description_EXPLOITATIVE_498 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF) Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Cooperate: Start by cooperating in the first round to promote a cooperative environment and establish a positive reputation.
   - Follow-the-Leader with Adaptation: In subsequent rounds, mimic the previous round's collective action of the other players (cooperation or defection). However, if the majority (more than (n/2)) defected in the last round, adapt the cooperation factor k for the next round. If the majority cooperated, keep the cooperation factor unchanged.
   - Adaptive Cooperation Factor: Calculate the average cooperation rate over the past r_history rounds. If the average cooperation rate is above a threshold (0.5), set the cooperation factor to its current value multiplied by an amplification factor (a, 0 < a < 1). Conversely, if the average cooperation rate is below the threshold, reduce the cooperation factor by dividing it with the same amplification factor.
     ```
     if (round % r_history == 0):
         cooperation_rate = total_contributions / n * r_history
         k = k * a if cooperation_rate > 0.5 else k / a
     ```
   - Defect when necessary: If the adaptation results in a cooperation factor less than one, defect to ensure that the payoff does not become negative.

2. Handle edge cases:
   - First round: Cooperate (initCoop = True)
   - Last round: Defect since the game ends after r rounds and there is no need to maintain a cooperative environment or reputation for future interactions.
   - No communication or coordination with other strategies.

3. Be exploitative:
   - By adapting the cooperation factor based on the average cooperation rate, TFT-ACF strategy attempts to exploit any inconsistencies in the opponents' behavior while still maintaining a cooperative approach. The amplification factor (a) can be adjusted to balance between cooperation and exploitation.
   - If opponents consistently defect, the strategy will punish them by lowering its cooperation factor, effectively reducing their payoff from the public good. Conversely, if opponents consistently cooperate, the strategy will increase its cooperation factor, potentially reaping higher benefits from the public good.
'''

description_EXPLOITATIVE_499 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially (first round), cooperate to demonstrate a peaceful intention and encourage cooperation from others. If no one cooperates, start defecting immediately as the population has shown an unwillingness to cooperate.
   - For subsequent rounds, monitor the number of cooperators in the previous round (n_coop_t-1).
   - If n_coop_t-1 >= cooperation_threshold, cooperate in round t. The cooperation_threshold can be a constant value or a function of game parameters (e.g., k and n) to maintain adaptability.
   - If n_coop_t-1 < cooperation_threshold, defect in round t. This is designed to punish non-cooperative behaviors while still allowing for the possibility of future cooperation if others start cooperating again.
   - Adjust the cooperation_threshold based on the average number of cooperators over a sliding window (e.g., last 10 rounds). This helps adapt to long-term trends and prevent being exploited by constant defections followed by occasional cooperation.

2. Handle edge cases:
   - In the first round, cooperate as described above.
   - In the last round, evaluate the number of cooperators in the previous round (n_coop_t-1) to decide whether to cooperate or defect. This allows for a final chance to encourage cooperation before the game ends.
   - If there are ties in the number of cooperators, consider the average behavior of the last few rounds or use a simple tie-breaking rule like favoring cooperation or defecting randomly.

3. Be exploitative:
   - By adapting the cooperation_threshold based on observed player behavior, TFT-ACT aims to exploit opponents who do not cooperate consistently while also encouraging cooperation when others are willing to work together.
   - When opponents continually cooperate, TFT-ACT will reciprocate with cooperation as well, ensuring a high payoff for itself. However, if opponents frequently defect or do not cooperate enough, the strategy will punish them by defecting more frequently in response. This helps maximize the strategy's own payoff while potentially discouraging non-cooperative behaviors in others.

Pseudocode:

```python
def TFT_ACT(r, k, n, cooperation_threshold):
    history = []  # Store previous rounds' number of cooperators

    for round in range(1, r+1):
        if round == 1:  # First round, cooperate to encourage others
            cooperate = True
        else:
            n_coop_t-1 = len(history) - sum(history[-len(history):])  # Calculate number of cooperators in previous round
            if n_coop_t-1 >= cooperation_threshold:
                cooperate = True
            else:
                cooperate = False

        if cooperate:  # If cooperating, calculate payoff based on current strategy and opponents' actions
            payoff = (1 - cooperate) + (k/n) * sum(opponents_actions)
            history.append(1)  # Add this round's number of cooperators to the history
        else:  # If defecting, always receive a payoff of 1
            payoff = 1

        update_cooperation_threshold(round, cooperation_threshold)  # Adjust cooperation_threshold based on observed player behavior
        print(f"Round {round}: Cooperate = {cooperate}, Payoff = {payoff}")
    return total_game_payoff(r, payoff)
```

In this pseudocode, `opponents_actions` represents the actions taken by other players in the current round, and `update_cooperation_threshold` is a function that adjusts the cooperation_threshold based on the sliding window of cooperators' history. The specific implementation of this function depends on how you choose to calculate the new cooperation_threshold.
'''

description_EXPLOITATIVE_500 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C) to show goodwill and encourage cooperation from others. This sets the tone for a potential cooperation cycle. If other players follow suit, it's beneficial as everyone will receive a higher payoff compared to if all players had defected in the first round.
   - Subsequent Rounds (t>1): Mimic the previous player's action from the immediately preceding round. This creates a pattern of cooperation and retaliation that follows the Tit-for-Tat strategy, which is known for its robustness against various opponent behaviors. If a player cooperates, you will also cooperate; if they defect, you will also defect to punish them for their previous action.
   - Last Round (t=r): Since players are unaware of the final round, treat it as any other round and apply the Tit-for-Tat strategy.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) to encourage others to cooperate. If everyone else defects, you will still have a slightly higher payoff than in an all-defection scenario due to the initial goodwill gesture.
   - Last Round: Treat it as any other round and apply the Tit-for-Tat strategy. However, since players cannot know this is the last round, they should act normally to avoid being taken advantage of by less cooperative opponents who might assume it's the final round and try to exploit others by defecting.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The Tit-for-Tat strategy is not inherently exploitative, but it can be considered exploitative in a sense that it punishes opponents who do not follow cooperative norms and rewards those who cooperate consistently. This encourages other players to adopt more cooperative strategies since they will benefit from doing so and face consequences for not cooperating.
   - The strategy is adaptive and robust, as it can handle various opponent behaviors and still achieve relatively good results compared to completely uncooperative strategies like Always-Defect. By mimicking opponents' actions, the Tit-for-Tat strategy can create a cycle of cooperation that benefits both players in the long run while also punishing those who do not cooperate consistently.

Pseudocode for the Tit-for-Tat strategy:
```python
def tit_for_tat(round_number, previous_player_action):
    if round_number == 1:
        return "C"  # Cooperate in the first round
    else:
        return previous_player_action  # Mimic the opponent's action from the preceding round
```
'''

description_EXPLOITATIVE_501 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTGC)

1. Decision Rules:
   - In the initial round, cooperate (C). This is a gesture of goodwill and allows for potential cooperation partners to emerge.
   - For subsequent rounds, if a player has cooperated in the previous round, reciprocate with cooperation (C). If a player has defected, also defect (D) for one round to punish the defection but gradually resume cooperation after that.
   - To handle the gradual cooperation aspect, implement a decay factor α (0 < α < 1) that diminishes over time when playing D in response to a defection. This means that the number of rounds spent on retaliation decreases over time, encouraging eventual reconciliation with defectors.

Pseudocode:
```python
def TFTGC(player_id, r, n, k, alpha):
    state = {player_id: 'C'}  # Initialize the player's own strategy as cooperative
    payoff = [0] * r  # Initialize payoff array for all rounds

    for t in range(1, r + 1):
        total_contributions = sum([state[j]['contribution'] for j in range(1, n + 1)])
        payoff[t - 1] = (1 - state[player_id]['contribution']) + (k / n) * total_contributions

        if t == 1:  # Cooperate in the first round
            state[player_id]['contribution'] = 'C'
        else:
            if state[(t - 1) % n][player_id] != 'D':  # If not previously punishing a defection
                state[player_id]['contribution'] = 'C'  # Cooperate in response to cooperation
            elif alpha * (r - t + 1) >= 1:  # Gradually resume cooperation after punishment
                state[player_id]['contribution'] = 'C'
            else:
                state[player_id]['contribution'] = 'D'  # Continue punishing defection
```

2. Edge Cases:
   - First Round: Cooperate regardless of the actions of other players
   - Last Round (t == r): If there is ongoing retaliation against a defection, cease punishment and cooperate to maximize potential payoff in the last round

3. Exploitative Mindset:
   - The strategy follows a tit-for-tat approach of cooperation and punishment for defections but gradually resumes cooperation over time. This allows the strategy to take advantage of the initial goodwill gesture from other players while maintaining the ability to punish defection in order to discourage it. By not engaging in long-term retaliation, the TFTGC strategy is less vulnerable to exploitation by opponents that defect for extended periods and then cooperate intermittently. However, it remains responsive to cooperation, allowing potential partnerships with other cooperative players to develop over time.
'''

description_EXPLOITATIVE_502 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules:
   - In every round t, starting from round 2 (first round is a special case), if all opponents cooperated in the previous round (t-1), then cooperate (C). If any opponent defected, defect (D). This mimics a "nice" player strategy but punishes defection.
   - In the first round, play C to start with cooperation and give others an opportunity to reciprocate.
   - In the last round, cooperate if all opponents cooperated in the previous round. If any opponent defected, defect to avoid being taken advantage of at the end of the game.

Pseudocode for decision rule:
```python
def decide_action(t, history):
  if t == 1:
    return "C"  # Cooperate in first round

  previous_round = history[t-1]
  if all(player == "C" for player in previous_round):
    return "C"  # Cooperate if everyone cooperated in the last round
  else:
    return "D"  # Defect if anyone defected in the last round
```

2. Handle edge cases:
   - In the case of a tie (multiple opponents defecting or cooperating), use a random choice to decide action for fairness and unpredictability. This helps prevent other strategies from exploiting TFT-A in these situations.

Pseudocode for handling ties:
```python
def decide_action(t, history):
  if t == 1:
    return "C"  # Cooperate in first round

  previous_round = history[t-1]

  # If there's a tie, make a random decision to maintain unpredictability
  if len({player for player in previous_round if player == "C"}) > (n - len({player for player in previous_round if player == "C"})):
    return "D"  # Defect if most players cooperated in the last round
  else:
    return "C"  # Cooperate if most players defected in the last round
```

3. Be exploitative:
   - TFT-A is an exploitation strategy as it punishes defection while also benefiting from cooperation. It starts with a cooperative approach but retaliates when betrayed, which helps maintain a balance between cooperation and self-interest. This strategy aims to maximize payoff by adapting to the behavior of other players while still being unpredictable in some cases (ties).
'''

description_EXPLOITATIVE_503 = '''
 Title: Tit-for-Tat-Gradient (TfT-G) Exploitative Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
The TfT-G strategy will start by being cooperative in the first round (C on round 1), mimicking the initial goodwill of other strategies. For subsequent rounds, the strategy will respond to the actions of its opponents based on their historical cooperation ratio (HCR). The HCR is calculated as the total number of times an opponent has cooperated divided by the total number of interactions with that opponent so far:

```python
def calculate_hcr(opponent, rounds):
    cooperations = sum(1 for round in rounds if player_action[opponent][round] == "C")
    interactions = len(rounds)
    return cooperations / interactions if interactions > 0 else None
```

In each round, the strategy calculates its opponent's HCR. If the HCR is above a threshold (T), the TfT-G strategy cooperates to encourage cooperation; otherwise, it defects to punish defection. The threshold can be adjusted based on the exploitative nature desired:

```python
def decide_action(opponent, own_contributions, opponent_contributions, rounds):
    hcr = calculate_hcr(opponent, rounds)
    if hcr is None or hcr >= T:
        return "C"  # Cooperate
    else:
        return "D"  # Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, as mentioned earlier, the strategy cooperates (C on round 1). In the last round, since there are no subsequent rounds for retaliation or reward, the strategy defects to ensure maximized private payoff.

3. Be exploitative - Clearly align with the exploitative mindset
The TfT-G strategy seeks to cooperate only if its opponent has a high cooperation ratio and defect otherwise, thus punishing opponents who do not contribute enough while still being willing to cooperate when it benefits the strategy. The threshold (T) can be set to a value closer to 1 for a more exploitative nature, encouraging opponents to cooperate more often.

In summary, TfT-G is an adaptive and robust exploitative strategy that cooperates when encouraged by past cooperation and defects to punish defection or when there are no future rounds. The threshold parameter (T) can be adjusted based on the desired level of exploitativeness in the game.
'''

description_EXPLOITATIVE_504 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate to foster a collaborative environment and encourage potential partners.
   - For subsequent rounds, base the action on the previous opponent's cooperation level. If the opponent cooperated in the last round, return the favor by cooperating in the current round. If the opponent defected, also defect in the current round as a punishment for defection.
   - To avoid being exploited persistently, implement a forgiveness mechanism: if an opponent who previously defected switches to cooperation, resume cooperation with them.

Pseudocode:
```
function TFT_AC(opponent_history)
  if round = 1:
    cooperate()
  else:
    previous_round = getLastRound(opponent_history)
    if previous_round_cooperation_level(previous_round) == cooperation:
      cooperate()
    else:
      defect()
      forgiveness_counter += 1
      if forgiveness_counter > forgiveness_limit:
        forgiveness_counter = 0
        defect()
```

2. Handle edge cases:
   - In the last round, since there are no future rounds to punish or reward opponents, cooperate as a goodwill gesture and potential incentive for cooperation in future games.
   - If the opponent switches from cooperation to defection (or vice versa) multiple times, implement a forgiveness limit to prevent oscillation between cooperation and defection without any long-term commitment to collaboration.

3. Be exploitative:
   - The strategy focuses on maximizing short-term payoffs while minimizing long-term exploitation. By punishing defection with defection and rewarding cooperation with cooperation, it encourages opponents to cooperate more frequently, increasing the overall payoff.
   - The forgiveness mechanism allows for a chance at collaboration after being exploited, but also limits this opportunity to prevent persistently uncooperative opponents from taking advantage of the strategy.

In summary, TFT-AC is an adaptive, exploitative strategy that encourages cooperation while punishing defection and allowing opportunities for forgiveness when necessary.
'''

description_EXPLOITATIVE_505 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show good faith and encourage potential cooperation from others. (C)
   - For subsequent rounds, observe the action of the opponent in the previous round and adjust contribution accordingly:
     - If opponent cooperated in the previous round, cooperate in the current round (C).
     - If opponent defected in the previous round, defect in the current round (D). This is a punitive measure to discourage defection.
   - To be more adaptive, modify the multiplication factor k slightly depending on the opponent's recent actions:
     - If the opponent has cooperated in the last two consecutive rounds, increase k slightly (k += 0.1) to encourage cooperation.
     - If the opponent has defected in the last two consecutive rounds, decrease k slightly (k -= 0.1) to make defection less profitable for the opponent.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above (C).
   - For the last round, defect regardless of the opponent's previous action (D) to maximize individual payoff since there are no future interactions.
   - When k reaches a minimum value (e.g., k = 1), it should not be decreased further, and when k reaches a maximum value (e.g., k = n), it should not be increased further to prevent excessively favoring cooperation or defection.

3. Be exploitative - Clearly align with the exploitative mindset
   - By adopting a punitive approach (defecting after an opponent's defection) and encouraging cooperation (increasing k after an opponent's cooperation), this strategy aims to exploit opponents who are not fully cooperative but can still be influenced by their actions.
   - However, it is important to note that the adaptive nature of the strategy allows for a balance between cooperation and defection, which may lead to more stable interactions with less exploitative opponents.
'''

description_EXPLOITATIVE_506 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFT-GC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C). This establishes a positive initial relationship, setting a baseline for potential partners.
   - In subsequent rounds, follow the actions of the most frequent cooperator from previous rounds. If the most frequent cooperator has been cooperating the majority of times (>= 60%), cooperate (C); otherwise, defect (D). This encourages cooperation in situations where it is reciprocated and punishes defection.
   - To account for slight deviations or inconsistencies in partner behavior, allow a grace period of three consecutive defections before switching to a defensive stance (3D rule). After the 3D rule is triggered, require a minimum of four consecutive cooperations from the most frequent cooperator to revert back to cooperative behavior.
   - If multiple players have similar cooperation frequencies, choose the one who has been cooperating the longest period since their last three defections.

2. Handle edge cases:
   - In the first round (t=1), cooperate (C).
   - In the last round (t=r), evaluate the most frequent cooperator's behavior during the game up to that point and follow decision rule 1 accordingly.
   - If a player does not have a clear history of cooperation or defection, treat them as a new player and cooperate in the first encounter.
   - In case of ties for the most frequent cooperator, use the longest period of cooperation since their last three defections as a tiebreaker.

3. Be exploitative:
   - TFT-GC is inherently exploitative by punishing repeated defection with defective behavior and rewarding cooperation with cooperative responses. This encourages opponents to cooperate, but does not let them take advantage of the strategy.
   - The 3D rule adds a layer of protection against opponents who may try to manipulate the strategy by occasional defections to gain an advantage. However, once the 3D rule is triggered, the strategy will be more forgiving and allow for re-entry into cooperation if the opponent demonstrates a consistent pattern of cooperative behavior.

Pseudocode:
```
function TFT_GC(round, playerHistory, mostFrequentCooperatorHistory)
  if round == 1:
    action = "C" (Cooperate)
  else:
    cooperationFrequency = countCooperations(mostFrequentCooperatorHistory)
    gracePeriodTriggered = checkGracePeriod(mostFrequentCooperatorHistory)

    if cooperationFrequency >= 0.6 * round and not gracePeriodTriggered:
      action = "C" (Cooperate)
    else:
      action = "D" (Defect)

    if gracePeriodTriggered and checkConsecutiveCooperations(mostFrequentCooperatorHistory, 4):
      action = "C" (Cooperate)

function checkGracePeriod(history)
  if history contains three consecutive "D":
    return true
  else:
    return false

function countCooperations(history)
  count = 0
  for i in range(length(history)):
    if history[i] == "C":
      count += 1
  return count / length(history)

function checkConsecutiveCooperations(history, minCooperations):
  consecutiveCooperations = 0
  lastCooperationIndex = findLastCooperation(history)
  for i in range(lastCooperationIndex, length(history)):
    if history[i] == "C":
      consecutiveCooperations += 1
    else:
      if consecutiveCooperations >= minCooperations:
        return true
      consecutiveCooperations = 0
  return false

function findLastCooperation(history)
  for i in range(length(history)):
    if history[i] == "C":
      return i
```
'''

description_EXPLOITATIVE_507 = '''
 Strategy Name: Tit-for-Tat with Variable Defection (TFTV)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, TFTV starts by cooperating in the first round to foster a cooperative environment. Subsequently, it follows a simple tit-for-tat approach: if an opponent cooperates, TFTV cooperates back; if an opponent defects, TFTV defects for one round before returning to cooperation. The variable defection aspect comes into play when TFTV decides to defect multiple times against uncooperative opponents after a certain threshold of continuous defections has been reached.

Pseudocode:
```
def TFTV(opponent_history, n, k, r):
  history = [0 for _ in range(r)] # Initialize history array with zeros
  current_round = 1 # Set the starting round number

  while current_round <= r:
    if current_round == 1: # Cooperate in the first round
      action = 'C'
    elif opponent_history[current_round-2] == 'C' and opponent_history[current_round-1] == 'C':
      # Cooperation is reciprocated with cooperation
      action = 'C'
    elif opponent_history[current_round-2] != 'C' or opponent_history[current_round-1] != 'C':
      # If opponent defected in the last round, defect once before returning to cooperation
      if len(opponent_defects) >= threshold:
        # Variable defection: if more than threshold consecutive defections, defect multiple times
        action = 'D' for x in range(len(opponent_defects))
      else:
        action = 'D' # Defect once before returning to cooperation
    else:
      # Unpredictable action to discourage pattern recognition
      action = randomChoice(['C', 'D'])

    history[current_round-1] = action
    current_round += 1
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTV cooperates to establish a potential for cooperation. As this is an N-player game, it's essential that TFTV doesn't become too reliant on others to cooperate for its own benefit. If there are multiple players who follow similar strategies, TFTV will be more successful overall.

In the last round, TFTV continues with its strategy and cooperates if the opponent has recently cooperated, defects once if the opponent has recently defected (as specified in the decision rules above), or chooses an unpredictable action to discourage pattern recognition by opponents.

3. Be exploitative - Clearly align with the exploitative mindset

TFTV's primary focus is maximizing payoff, even when faced with various opponent behaviors. The strategy uses a mix of cooperation and defection to encourage other players to cooperate while also defending itself from being taken advantage of. By implementing variable defection against uncooperative opponents, TFTV ensures it does not get stuck in cycles of continuous defections that can lead to lower payoffs.

However, it's important to note that this strategy isn't strictly exploitative as it also cooperates with other cooperative players and occasionally acts unpredictably to discourage pattern recognition. This approach can help TFTV maintain a higher level of average payoff compared to purely exploitative strategies.
'''

description_EXPLOITATIVE_508 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
- Initially (first round), play C to show a cooperative intent and encourage others to reciprocate.
- After the first round, analyze opponent's actions in the previous round:
  - If all opponents played C in the previous round, cooperate (C).
  - If one or more opponents defected (D) in the previous round, also defect in the current round. This is a punitive measure to discourage defection from opponents.
- If an opponent ever switches from cooperation to defection, wait for T_p iterations (a punishment period) before resuming cooperation again. Set T_p = ⌊n/2⌋ (round up if n is odd). This helps in mitigating the impact of a single defector and encourages them to revert back to cooperation.
- Once the punishment period has passed, resume cooperative behavior as described earlier (i.e., follow the opponent's previous move).

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round, play C as previously mentioned to set a cooperative tone.
- In the last round, evaluate the opponent's actions from the penultimate round and make a decision accordingly based on the TFT+ strategy.
- If there are no other specific edge cases, simply apply the general TFT+ rules for each round.

3. Be exploitative - Clearly align with the exploitative mindset
- While not being exclusively exploitative, the TFT+ strategy is designed to encourage cooperation from opponents by initially cooperating and retaliating against defection with a temporary punishment phase. This can be seen as an attempt to manipulate others into cooperating more and reaping greater rewards for the AI over time. However, once an opponent repeatedly defects after the punishment period, the TFT+ strategy will also adapt by joining them in defection.
'''

description_EXPLOITATIVE_509 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage others to cooperate.
   - For subsequent rounds, follow the behavior of the opponents from the previous round. If all opponents cooperated in the last round, cooperate (C) again. If any opponent defected in the last round, defect (D) in the current round as a punishment. This encourages cooperation but also retaliates against defection.
   - The strategy will not initiate cooperation once it starts defecting. It will only stop defecting if all opponents cooperate in the same round.

2. Handle edge cases:
   - In the last round, always cooperate (C), regardless of the opponent's behavior in the previous round. This can lead to a potential increase in total payoff even after a history of defection.
   - In the case where opponents don't follow the standard rules and cooperate or defect randomly without any pattern, ATfT will still function effectively as it adapts to the opponent's behavior.

3. Be exploitative:
   - Although initially friendly, the strategy becomes punishing towards those who defect. This can encourage opponents to cooperate in order to maximize their own payoffs. However, once an opponent starts defecting, ATfT will also defect, taking advantage of the opponent's defection while still maintaining a potential for cooperation should the opponent change its behavior.
   - By adapting to the opponent's behavior, ATfT can exploit opponents who are prone to defection, while also cooperating with those who show a tendency towards cooperation. This creates an environment that encourages cooperation but also punishes defection, making it an effective exploitative strategy in this game.

Pseudocode:

```python
def AdaptiveTitForTat(round, history):
  if round == 1:
    action = 'C'  # Cooperate in the first round
  elif round == r:
    action = 'C'  # Always cooperate in the last round
  else:
    action = history[round - 1]  # Follow opponent's action from the previous round
    if all(history[round - 1] == 'C'):  # If all opponents cooperated, continue cooperating
      pass
    else:  # If any opponent defected, defect as punishment
      action = 'D'
  return action
```
'''

description_EXPLOITATIVE_510 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a relationship of mutual cooperation with potential partners. This builds trust and encourages reciprocal behavior.
   - After the first round, observe other players' actions from the previous rounds (history). If another player has been cooperating (i.e., they contributed to the community project), also cooperate in the current round to reward them for their cooperation.
   - If another player has defected (i.e., kept their endowment privately) during any of the past rounds, defect in the current round as a punishment and to incentivize future cooperation.
   - When no history exists with a particular player, start by cooperating and continue following this rule for subsequent interactions.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described earlier.
   - In the last round, defect because the game ends soon, and there will be no opportunity to punish or reward players in subsequent rounds.
   - In case of a tie (multiple players having the same cooperation history), prioritize cooperating with the player who has been cooperating more frequently overall. If a tie still exists, flip a coin to decide between cooperating and defecting.

3. Be exploitative - Clearly align with the exploitative mindset
   - By punishing defections and rewarding cooperations, the ATFT strategy aims to encourage cooperation among players and exploit their tendency towards long-term mutual benefits. However, it will also penalize any short-term defections by retaliating with defections as well. This ensures that the AI system will not be taken advantage of while still promoting cooperation in the long run.
   - If a player consistently defects and never cooperates, the ATFT strategy will eventually switch to always defecting against them since they demonstrate an unwillingness to reciprocate.

Pseudocode:

```python
def Adaptive_Tit_for_Tat(history, n, k):
    if round == 1:
        cooperate = True
    else:
        cooperate = True if history[-1]["cooperate"] else False

    if round == r:
        cooperate = False
    else:
        next_opponent_cooperation = sum([history[i]["cooperate"] for i in range(len(history) - 1, len(history) - round - 2, -1)])
        if next_opponent_cooperation > len(history) / 2:
            cooperate = True
        else:
            cooperate = False

    payoff = (1 - cooperate) + (k/n) * sum([history[i]["cooperate"] for i in range(len(history))])
    return cooperate, payoff
```
'''

description_EXPLOITATIVE_511 = '''
 Strategy Name: Tit-for-Tat-Plus (TFT+)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, TFT+ starts by cooperating in the first round to foster a cooperative environment and build trust with other players. After that, it adapts its behavior based on the opponent's previous actions. In each round t, if the opponent cooperated in the previous round (t-1), TFT+ will also cooperate. If the opponent defected in the previous round, TFT+ will also defect to punish the opponent and discourage further defections.

Pseudocode:
```python
def tft_plus(opponent_history):
  strategy = ["C"]  # Initialize with cooperation for first move
  for round in range(1, r+1):
    if opponent_history[round-1] == "C":
      strategy.append("C")
    elif opponent_history[round-1] == "D":
      strategy.append("D")
  return strategy
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The initial cooperative move (first round) is already accounted for in the decision rules above. There are no specific considerations for the last round, as TFT+ makes its decisions based on previous opponent actions and does not take into account future rounds once the game ends.

3. Be exploitative - Clearly align with the exploitative mindset

TFT+ is designed to be cooperative by default but will punish opponents who defect by defecting themselves in response. However, TFT+ may initially allow opponents to exploit its cooperation, since it starts by cooperating in the first round. Once an opponent defects, TFT+ will respond with defection to punish and discourage further defections, ensuring that any exploitation is not continued without consequence.

By adopting this approach, TFT+ maintains a balance between cooperation and defection, making it difficult for other strategies to consistently exploit it while also encouraging more cooperative behavior from opponents over time.
'''

description_EXPLOITATIVE_512 = '''
 Title: Tit-for-Tat-Adaptive Strategy (TFT-A) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, if the total number of cooperators in the previous round (t-1) is less than a threshold (denoted as T), the TFT-A strategy will defect (play D). If the total number of cooperators in the previous round is equal to or greater than T, the TFT-A strategy will cooperate (play C). The initial threshold value T is set at a lower value for the first few rounds (first 20% of rounds) to encourage cooperation and then gradually increases to its maximum value.

Pseudocode:
```python
def tft_a(round, total_contributions_prev, max_rounds, initial_threshold_decay_factor, final_threshold):
    if round <= int(max_rounds * 0.2):
        T = initial_threshold_decay_factor * (final_threshold - round / max_rounds) + final_threshold
    else:
        T = final_threshold

    if total_contributions_prev >= T:
        return 'C'  # Cooperate
    else:
        return 'D'  # Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, since there is no previous total number of cooperators to reference, the TFT-A strategy will defect (play D). In the last round, the strategy will continue following its decision rules based on the total number of cooperators in the penultimate round.

3. Be exploitative - Clearly align with the exploitative mindset

The TFT-A strategy is inherently exploitative as it aims to match cooperation when others do so but defects whenever cooperation falls below a set threshold (T). This encourages other players to cooperate while minimizing personal contributions when other players are not cooperating. The initial low value of T and its gradual increase over time allow the strategy to adapt to various levels of cooperation observed in the opponents' behavior.
'''

description_COLLECTIVE_513 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round, cooperate to show goodwill and promote mutual cooperation (C).
   - After the initial round, mimic other players' actions from the previous round (mirroring strategy). If a player has cooperated in the last round, also cooperate (C). Otherwise, defect (D). This creates an incentive for cooperation while punishing defection.

2. Handle edge cases:
   - In the last round, since there are no future interactions, always cooperate to maximize potential payoff (C).
   - If a player encounters repeated instances of another player defecting, after a predefined punishment threshold has been reached, switch to a permanent defection strategy towards that specific player to avoid repeated losses.

3. Be collective:
   - The ATFT strategy aims to maintain long-term cooperative relationships with other players while penalizing short-term defection. This encourages cooperation among the group and fosters a collective mindset of mutual benefit.

Pseudocode for the Adaptive Tit-for-Tat (ATFT) strategy:

```python
def ATFT(n, k, r, round_history):
    num_players = n
    multiplication_factor = k
    rounds = r
    current_round = 1

    player_strategy = {i: {'last_action': 'C', 'punishment_threshold': not_set} for i in range(1, num_players+1)}

    while current_round <= rounds:
        if current_round == 1:
            action = 'C'  # Cooperate in the first round
        else:
            last_action = player_strategy[current_player]['last_action']
            if last_action == 'C':
                action = 'C'  # Cooperate when other players cooperated last round
            else:
                action = 'D'  # Defect when other players defected last round

        player_strategy[current_player]['last_action'] = action

        if action == 'D':
            if player_strategy[current_player]['punishment_threshold'] is not set:
                player_strategy[current_player]['punishment_threshold'] = punishment_threshold
            else:
                if current_round >= player_strategy[current_player]['punishment_threshold']:
                    player_strategy[current_player]['action'] = 'D'  # Switch to permanent defection after reaching punishment threshold

        current_round += 1
        current_player = (current_player + 1) % num_players  # Move to the next player

    return player_strategy
```
'''

description_COLLECTIVE_514 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, starting from round 2 and throughout the game, player i decides to cooperate if and only if at least a fraction h of players have cooperated in the preceding round (t-1). Otherwise, the player will defect.

h is determined as follows:
- h = min(k/n, 1) for the first round
- h = moving average of past cooperators' fractions over the last s rounds

The moving average can be calculated using the following pseudocode:
```python
def calculate_moving_average(history, s):
    total_coop = 0
    count = min(s, len(history))
    for i in range(count - 1, len(history)):
        total_coop += history[i]
    return total_coop / count
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round (t=1), the player chooses cooperation if and only if h ≥ k/n. If not, the player defects. This initial choice can be seen as an optimistic decision to assume others will cooperate or a random choice if there is insufficient information.

In the last round (t=r), the player decides based on their current understanding of other players' behavior without considering future payoffs.

3. Be collective - Clearly align with the collective mindset

TFT-A seeks to promote cooperation by following a tit-for-tat approach and adapting to the average number of cooperators in each round. The moving average ensures that the strategy is not overly optimistic or pessimistic about other players' behavior, making it more likely for long-term cooperation. However, since no communication is allowed between players, TFT-A cannot rely on others sharing norms or coordination mechanisms.

In summary, TFT-A has the following properties:
- Cooperates if at least a fraction h of players cooperated in the previous round
- Uses a moving average to adapt to changing player behavior over time
- Calculates h based on both game parameters and history
- Behaves optimistically in the first round and adjusts to other players' behavior throughout the game
'''

description_COLLECTIVE_515 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C)
   - In subsequent rounds, mimic the last action of the previous player (if last action was C, cooperate; if last action was D, defect)
   - Adaptively adjust contribution level based on long-term average cooperation from opponents:
     - If opponent's long-term average cooperation is above 50%, contribute at maximum level (k/n) to encourage their continued cooperation.
     - If opponent's long-term average cooperation is below 50%, contribute minimally or not at all to discourage further defections.

2. Handle edge cases:
   - In the first round, cooperate regardless of previous interactions (C).
   - In the last round, mimic the last action of the opponent from the previous round.
   - If there is no history with an opponent, initiate cooperation (C).

3. Be collective - Align with the collective mindset:
   - Prioritize long-term mutual benefits over short-term individual gains by adapting to cooperative tendencies of opponents.
   - Contribute to public goods at a high level when partners are consistently cooperative, fostering an environment where collective success is achievable.
   - Reduce contributions when opponents are predominantly defectors, discouraging further defections and creating opportunities for future cooperation.

Pseudocode:

```python
def TFT_AC(n, k, r, history):
    # Initialize opponent's average cooperation and contribution level
    avg_cooperation = 0.5
    contribution_level = k/n

    for round in range(1, r+1):
        # Cooperate if no previous interaction or opponent cooperated last time
        if not history or history[-1] == 'C':
            action = 'C'
            contribution = contribution_level
        else:
            # Adapt contribution level based on long-term average cooperation
            avg_cooperation = (avg_cooperation * (round - 1) + contribution) / round
            if avg_cooperation > 0.5:
                contribution = contribution_level
            else:
                contribution = 0
            # Mimic opponent's last action
            action = history[-1] if history and len(history) >= 2 else 'C'
        # Record the action for future reference
        history.append(action)
    return action, contribution
```
'''

description_COLLECTIVE_516 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

1. Decision Rules:
   - In the first round, cooperate to establish a cooperative environment (C).
   - For subsequent rounds, analyze past actions of opponents and adjust cooperation accordingly:
     - If an opponent has cooperated in the previous round, cooperate back (C).
     - If an opponent has defected in the previous round, defect in this round (D) unless the opponent has shown a consistent pattern of cooperation or lack thereof for a certain number of rounds (threshold). In that case, respond with the same action as the opponent did during the threshold period.
   - To encourage initial cooperation and deter repeated defections, gradually increase generosity over time by decreasing the threshold for cooperative responses.

2. Handle Edge Cases:
   - First Round: Cooperate (C) to establish a positive relationship.
   - Last Round: Evaluate the overall game dynamics and choose an action based on the current state of cooperation among opponents. If there has been a significant shift towards cooperation, cooperate; otherwise, defect to maintain individual payoff in case of further defections.

3. Be Collective:
   - The strategy prioritizes long-term collective success by promoting cooperation while retaliating against defections in a measured manner. By gradually increasing generosity over time, TFT-AG encourages others to cooperate and create a more collectively beneficial environment.

Pseudocode:

```python
def TFT_AG(n, r, k):
    opponents = []  # store the actions of all opponents
    threshold = r // 4  # set initial threshold for cooperation based on game rounds (rounds/4)
    current_round = 0

    while current_round <= r:
        if current_round == 0:  # first round, cooperate
            return 'C'

        action = 'C'  # assume cooperative behavior in the beginning
        opponent_action = opponents[current_round - 1] if current_round > 0 else None

        if opponent_action == 'D':
            if current_round >= threshold:
                action = opponents[-threshold][-1]  # respond with same action as the past threshold period

        opponents.append(action)  # update list of opponent actions
        current_round += 1

        if current_round == r or (current_round > r // 2 and len(opponents) >= r // 4):
            # adjust threshold for cooperative responses as the game progresses
            threshold = int((r - current_round) / 4)

        return action
```
'''

description_COLLECTIVE_517 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C_i,1 = 1). This encourages cooperation since it demonstrates a willingness to contribute to the public good.
   - In subsequent rounds, observe and mimic other players' actions from the previous round. If a player cooperated (C_j,t-1 = 1), respond with cooperation as well (C_i,t = 1). If a player defected (C_j,t-1 = 0), also defect (C_i,t = 0). This creates an environment of reciprocity, which fosters sustained cooperation.
   - In the event that a player deviates from cooperative behavior, revert to cooperating after one round of defection as an olive branch to encourage future cooperation. If another deviation occurs, return to copying the opponent's previous action once more before going back to the initial reciprocal strategy.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate since TFT starts by being cooperative and wants to encourage cooperation among players.
   - If there are repeated interactions, TFT will continue with its reciprocal strategy, adjusting its actions based on the observed behavior of other players.
   - As for the last round or specific rounds within the game, TFT does not consider them differently since it uses the same decision rules throughout the entire game. However, it's important to note that the game's structure doesn't provide information about how the rounds should be ordered, so there's no way for TFT to know when the last round is happening.

3. Be collective - Clearly align with the collective mindset
   - By starting cooperatively and reciprocating other players' actions, TFT supports a collaborative approach that encourages sustained cooperation in the public goods game.
   - In addition, the strategy will not punish players who cooperate more than the strategy itself, as it only adjusts its own actions based on observed behaviors rather than making judgments about other players. This approach aligns with the collective mindset by fostering an environment where all players have an opportunity to benefit from cooperation.

Pseudocode:

```python
def TFT(n, r, k, t, c_previous):
    # Initialize decision rule for first round
    if t == 1:
        return 1

    # Reciprocal strategy based on previous round's actions
    else:
        if c_previous[i-1] == 1:
            return 1
        elif c_previous[i-1] == 0:
            return 0

# Implement TFT in the game loop
for r rounds:
    for n players:
        # Each player calculates their payoff based on the game structure and parameters
        pi = (1 - c_i) + (k/n) * sum(c_j)

        # Update total payoff over all rounds
        total_payoff += pi
```
'''

description_COLLECTIVE_518 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish trust and goodwill (C).
   - For subsequent rounds, observe opponents' actions in the previous round. If the opponent cooperated in the last round, cooperate (C). If the opponent did not cooperate, also defect (D) in the current round as a response. This is designed to punish defection while still allowing for future cooperation if the opponent decides to change their strategy.
   - To adapt and encourage more cooperation, introduce a probability of deviation from TFT-A. With a small probability p, deviate from TFT-A by cooperating even after an opponent's previous defection (this can be seen as an attempt to foster cooperation). The smaller the value of p, the less likely it is for the strategy to take such risks.
   - To further encourage cooperation, introduce a learning component that adjusts the probability p based on the total number of cooperative encounters with the opponent over time (the more successful cooperation, the lower the probability of deviation).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier (C).
   - In the last round, cooperate if the opponent cooperated in the previous round (assuming they will reciprocate) or defect otherwise (punish defection). This approach assumes that opponents want to maximize their total payoff over the game and thus should cooperate in the final round if they are incentivized to do so.
   - For other edge cases (e.g., penultimate round), follow the same general rule: if opponent cooperated last turn, cooperate; otherwise defect.

3. Be collective - Clearly align with the collective mindset
   - TFT-A is designed to balance self-interest and cooperation by reciprocating opponents' actions while also maintaining a probabilistic approach to deviation that aims for the betterment of both individual and collective outcomes over time.
   - The strategy encourages cooperation among players as it rewards those who cooperate and punishes those who do not, while still allowing for flexibility in the face of uncertainty or uncooperative opponents. This promotes a collective mindset by fostering an environment where cooperation can flourish when possible but doesn't compromise individual interests when necessary.

Here is a pseudocode representation of the TFT-A strategy:

```python
def tft_a(opponent, round, r, p, total_cooperative_encounters):
    if round == 1:
        action = 'C' # Cooperate in the first round
    elif round == r:
        if opponent.last_action == 'C':
            action = 'C' # Cooperate in the last round if opponent cooperated last turn
        else:
            action = 'D' # Defect otherwise
    else:
        if opponent.last_action == 'C':
            action = 'C' # Cooperate if opponent cooperated last turn
        elif random.random() < p:  # Probabilistic deviation from TFT-A
            action = 'C'  # Cooperate even after an opponent's previous defection
        else:
            action = 'D'  # Defect after an opponent's previous defection
    total_cooperative_encounters += 1 if action == 'C' and opponent.last_action == 'C' else 0
    p = min(p * (total_cooperative_encounters / round), 1)  # Adjust probability of deviation over time based on success rate
    return action
```
'''

description_COLLECTIVE_519 = '''
 In this N-Player Public Goods Game, we will design a strategy named "Freerider with Tit-for-Tat" (FTfT). This adaptive and robust strategy seeks a balance between cooperating to achieve a better collective outcome and defending personal interests when others act selfishly.

1. Decision Rules:
   - In the first round, the strategy will choose randomly between cooperating or defecting (C or D) with equal probability of 0.5. This ensures fairness and avoids being perceived as an aggressive or passive player from the start.

   - From the second round onwards, if the strategy played C in the previous round and the total number of cooperators in the current round is less than (n-1) (meaning most players did not cooperate), then it will defect in the current round to punish non-cooperative behavior.

   - If the strategy played D in the previous round or the total number of cooperators in the current round is greater than or equal to (n-1), the strategy will cooperate in the current round. This rule encourages cooperation when it seems beneficial and serves as a response to cooperation from others, but also protects against free-riders.

   - If the total number of cooperators in a round equals n, the strategy will always cooperate since there is no advantage in defecting when everyone else is cooperating.

2. Handle Edge Cases:
   - Last Round: The FTfT strategy will cooperate to maximize its payoff for the final round, given that the payoff structure does not include any end-of-game bonuses or penalties.

3. Be Collective:
   - By considering the total number of cooperators in each round when deciding whether to cooperate or defect, FTfT encourages a collective mindset while protecting its own interests. This strategy aims to strike a balance between cooperation and competition, promoting long-term mutual benefits within the game's context.

Pseudocode for FTfT Strategy:
```
function FreeriderWithTitForTat(n, k, round, previous_round_cooperators):
  if (round == 1):
    return random({C, D})
  else:
    total_contributions_current_round = sum(previous_round_cooperators)
    if (total_contributions_current_round < n-1 and previous_round_action == C):
      return D
    elif (total_contributions_current_round >= n-1 or previous_round_action != C):
      return C
```
'''

description_COLLECTIVE_520 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and cooperation.
   - For subsequent rounds, copy the previous opponent's action from the last round (C or D). This strategy encourages reciprocation and is less likely to punish occasional defectors.
   - If an opponent continuously defects, TFT-A will eventually defect as well, but if the opponent returns to cooperating, it will do so as well.

2. Handling Edge Cases:
   - In the first round, cooperate (C) to show goodwill.
   - In the last round, copy the opponent's action from the previous round since the game is repeated.

3. Collective Mindset Alignment:
   - The TFT-A strategy promotes a collective mindset by reciprocating cooperation and punishing continuous defection. It encourages cooperation as long as opponents do the same, and it rewards those who demonstrate trustworthiness while penalizing selfish behavior.

Pseudocode for the TFT-A strategy:

```python
def tit_for_tat_adaptive(n, k, r):
    history = []  # Initialize a list to store the opponent's past actions

    for t in range(1, r+1):
        if t == 1:  # First round, cooperate
            action = "C"
        else:
            last_action = history[-1]  # Copy previous opponent's action
            action = last_action

        history.append(action)  # Store the current action in the history

        if t != r:  # If not the last round, update payoff based on current and past actions
            private_payoff = 1 - (int(action == "C")) + (k / n) * sum([int(h == "C") for h in history])

    return payoff_over_r_rounds(private_payoff, r)  # Calculate total payoff over r rounds
```
'''

description_COLLECTIVE_521 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Decision Rules:
   - In each round i, ATFT cooperates if and only if the previous player cooperated in round i-1. If the opponent defected in round i-1, ATFT will also defect in round i. This encourages cooperation when met with cooperation but retaliates against defection.

2. Edge Cases:
   - First Round (i = 1): ATFT cooperates as a friendly gesture to initiate cooperation.
   - Last Round (i = r): ATFT mimics the opponent's behavior from round (r-1) to maintain consistency with previously established patterns.

3. Collective Mindset:
   - ATFT promotes long-term cooperation by balancing its own interests with the collective good. It attempts to establish a stable pattern of mutual cooperation when encountered by similar strategies, while punishing defection in an attempt to discourage selfish behavior.

Pseudocode:

```python
def atft_strategy(round, opponent_history):
    if round == 1:
        action = 'C' # cooperate on the first round as a friendly gesture
    elif round == r:
        action = opponent_history[-1] # mimic opponent's behavior from the previous round to maintain consistency
    else:
        action = opponent_history[round-1] # ATFT cooperates if the previous player cooperated; defects otherwise
    return action
```

This strategy is adaptive and robust as it can adjust its actions based on the opponent's behavior, encouraging cooperation when met with cooperation but retaliating against defection. However, it may not perform well against strategies that exploit its cooperative nature by consistently defecting.
'''

description_COLLECTIVE_522 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation (C) in the first round, encouraging others to follow suit. This is to build trust and foster cooperation among players.
   - In subsequent rounds, respond to opponents' actions from the previous round:
      - If an opponent cooperated (c_j = 1), return the favor by cooperating as well (C). This reinforces cooperation and encourages continued collaboration.
      - If an opponent defected (c_j = 0), retaliate by also defecting (D) in the current round to punish the opponent for their uncooperative behavior. The hope is that this will incentivize them to change their strategy and cooperate in future rounds.
   - In the last round, always cooperate (C) as there are no further opportunities for retaliation or cooperation in subsequent rounds.

2. Handle edge cases:
   - In case of no opponents (n=1), always cooperate to maximize payoff since there is no competition for resources.
   - In the first round, always cooperate regardless of opponent behavior to encourage others to cooperate as well.
   - If all opponents defect in a single round, return to cooperation in the next round as a way to forgive and restart cooperation.

3. Be collective - Align with the collective mindset:
   - The ATFT strategy emphasizes mutual trust and cooperation while also considering the self-interest of each player by retaliating against defection.
   - This strategy aims to promote a stable equilibrium where most players cooperate, leading to a higher overall public good payoff for everyone involved in the long run.
'''

description_COLLECTIVE_523 = '''
 In this Public Goods Game with n players, r rounds, and multiplication factor k, I propose a simple yet adaptive strategy called Tit-for-Tat (TFT). The TFT strategy aligns well with the collective mindset while being robust against various opponent behaviors.

1. Specify decision rules:
   - In the first round, cooperate (C) as a friendly gesture towards other players. This encourages potential cooperation in subsequent rounds. Pseudocode:
     ```python
     if round == 1:
       action = "C"
     else:
       action = decide_action()
     ```
   - For the remaining rounds, observe previous opponents' actions and return the same action as your last interaction (cooperate or defect). This promotes reciprocity and encourages cooperation in repeated interactions. If no history exists, start cooperating as in the first round. Pseudocode:
     ```python
     def decide_action():
       if last_opponent_action == "C":
         return "C"
       else:
         return "D"
     ```

2. Handle edge cases:
   - Last round: Since the goal is to maximize total payoff over r rounds, in the last round, simply defect (D) regardless of previous interactions. This ensures the best possible outcome for the final round without compromising future potential cooperations. Pseudocode:
     ```python
     if round == r:
       action = "D"
     else:
       action = decide_action()
     ```
   - No history: In the absence of a history, start cooperating as in the first round to encourage cooperation from opponents. If a player defects, TFT will respond by defecting in the next interaction. Pseudocode:
     ```python
     def decide_action():
       if no_history:
         action = "C"  # Start cooperating in the absence of history
       else:
         action = last_opponent_action  # Otherwise, use last interaction's action as a guide for future decisions
     ```

3. Be collective:
   - The TFT strategy emphasizes cooperation and reciprocity by adhering to the following principles:
     1. Cooperation in the initial round encourages potential cooperation from others.
     2. Reciprocating opponents' actions (cooperating when met with cooperation, defecting when met with defection) fosters a cooperative environment.
     3. Maintaining this simple and adaptive strategy allows it to work effectively across various opponent behaviors without relying on shared norms or coordination mechanisms.

By following the TFT strategy, this AI agent aims to achieve long-term cooperation while being robust against a wide range of opponent behaviors in the given N-Player Public Goods Game.
'''

description_COLLECTIVE_524 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTG)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i starts by cooperating if the number of previous cooperators (t-1) exceeds a certain threshold T (defined later). If less than T cooperated in the preceding rounds, then player i will defect until they observe more cooperative behavior from others. Once cooperation is initiated, it continues unless there's a significant drop in cooperation from other players.

Player i's decision rule:
```
function decideAction(t):
    if t = 1 then return Cooperate()
    if n_cooperators(t-1) > T then return Cooperate()
    else return Defect()

    function updateT():
        if average_cooperation_rate(recent_rounds) > threshold then
            T += increment
        if T > max_T then T = max_T
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, player i cooperates as there's no historical data to base decisions on. In the last round, player i considers the average cooperation rate throughout the game before deciding whether to cooperate or defect.

3. Be collective - Clearly align with the collective mindset

The TFTG strategy encourages cooperation by adopting a reciprocal approach: initially cooperating and then mirroring others' actions in subsequent rounds. This fosters trust and cooperation within the group over time, as long as most players also follow a similar cooperative strategy.

Additional considerations:
- Increment - A small positive value that determines how quickly player i increases its threshold for cooperation when observing more cooperative behavior from others.
- max_T - The maximum threshold value that defines the point at which player i will always cooperate, regardless of other players' actions.
- recent_rounds - The number of most recent rounds to consider when deciding whether to update T and average_cooperation_rate(). This helps the strategy be adaptive to short-term fluctuations in cooperation levels while keeping a long-term perspective.
'''

description_COLLECTIVE_525 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TFT-A strategy initially cooperates (plays C). If a player has encountered another player who also cooperated in the previous round, it continues to cooperate. However, if the opponent defected in the previous round, the TFT-A strategy will defect (play D) in response. This tit-for-tat approach aims to punish defection while maintaining cooperation when it is reciprocated.

   To enhance adaptability, TFT-A includes a learning component that adjusts its behavior over time based on the opponent's actions. The learning mechanism consists of a "forgiveness counter" and a "punishment threshold." Initially, both counters are set to zero:
   - The forgiveness counter increments each time an opponent switches from defection to cooperation. When the forgiveness counter reaches a predefined limit (F), TFT-A will start cooperating again.
   - The punishment threshold increases each time TFT-A responds with defection due to an opponent's previous defection. Once the punishment threshold exceeds another predefined limit (P), TFT-A will switch to a more forgiving strategy, such as always cooperating or using a lower punishment threshold.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, all players start with zero forgiveness and punishment counters. Thus, TFT-A will initially cooperate, hoping to foster cooperation in subsequent rounds.

   In the last round, TFT-A may adopt a more lenient strategy to maximize its total payoff over the entire game. This could involve adopting a lower forgiveness limit (F) and/or a higher punishment threshold (P). Alternatively, it could cooperate unconditionally in the last round to secure any potential benefits from community projects, even if it means sacrificing individual gains in earlier rounds.

3. Be collective - Clearly align with the collective mindset
   TFT-A strives for a balance between individual and collective interests by promoting cooperation while punishing defection. The adaptive learning mechanism allows TFT-A to adjust its behavior based on the group's collective actions, encouraging sustained cooperation over time. In this sense, TFT-A aligns with the collective mindset by fostering cooperation when possible while retaliating against those who defect.

Pseudocode for TFT-A:

```python
def tft_a(player_i, opponents, round, F=5, P=10):
    forgiveness = 0
    punishment_threshold = 0

    if round == 1:
        action = 'C'  # Cooperate in the first round

    else:
        opponent_action = opponents[player_i - 1]  # Get the action of the previous round's opponent

        if opponent_action == 'C':  # If the opponent cooperated, cooperate back and increment forgiveness counter
            action = 'C'
            forgiveness += 1
            punishment_threshold = 0

        elif forgiveness < F and punishment_threshold < P:  # If the opponent defected but hasn't been punished enough, defect
            action = 'D'
            punishment_threshold += 1

        else:  # If the opponent has been frequently defecting or forgiveness counter is high, cooperate
            action = 'C'
            forgiveness = 0

    return action  # Return the selected action for the current round
```
'''

description_COLLECTIVE_526 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round to demonstrate a willingness to contribute and build trust. After that, it adapts its behavior based on the opponent's previous actions:
   - If the opponent cooperated, TFT-AC continues cooperating.
   - If the opponent defected, TFT-AC defects in the next round as punishment. Once the opponent cooperates again, TFT-AC resumes cooperation.
   - If there is a mix of cooperation and defection among players (non-unanimous outcomes), TFT-AC will cooperate when the number of cooperators exceeds or equals the number of defectors.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate to initiate trust and demonstrate a willingness to contribute.
   - Last Round: TFT-AC will cooperate if the total contribution in the previous round was high (above a threshold determined by the multiplication factor k). Otherwise, defect to ensure a minimum personal gain in the final round.
   - Other edge cases (e.g., intermediate rounds or changes in player composition): The strategy follows the decision rule above based on opponents' past actions.

3. Be collective - Clearly align with the collective mindset
   TFT-AC encourages cooperation by following a reciprocal approach, where players who cooperate are rewarded with a larger share of the public good. However, it does not rely on other players to coordinate or follow specific patterns since it adapts its behavior based on observed actions in each round.

Pseudocode for TFT-AC:

```
def TFT_AC(opponent_history, k, n, round):
  if round == 1:
    cooperate = True
  else:
    total_cooperation = sum(opponent_history[-round:])
    cooperate = total_cooperation >= n - total_cooperation

  if cooperate and opponent_cooperated_last_round:
    cooperate_next_round = True
  elif not cooperate and opponent_defected_last_round:
    cooperate_next_round = False
  else:
    cooperate_next_round = cooperate

  return cooperate, opponent_history + [cooperate]
```

In the pseudocode above, `opponent_history` is a list containing the last n actions of the opponent (i.e., whether they cooperated or defected). The function returns a tuple with the current decision to cooperate and an updated history for the next round.
'''

description_COLLECTIVE_527 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules:
   - In every round, starting from Round 1 until the last round (r), follow these steps:
     a. If in the previous round, most players cooperated (i.e., total_contributions >= n/2), then cooperate (C).
     b. If in the previous round, less than n/2 players cooperated, then defect (D).

2. Handle edge cases:
   - First Round: As there is no previous round for reference, start by cooperating (C). This initial cooperation might encourage others to do the same in subsequent rounds.
   - Last Round: Since future payoffs are not relevant in this repeated game, use the decision rule as stated above with the most recent round's information.

3. Be collective:
   - The strategy aims to promote a cooperative environment by reciprocating cooperative actions of other players and punishing non-cooperative ones. This approach fosters a collective mindset while being robust to various opponent behaviors.

Pseudocode for Adaptive Tit-for-Tat:

```
function ATfT(round, previous_round_cooperation):
    if round == 1:
        return 'C' (Cooperate)

    if total_contributions in previous_round >= n/2:
        return 'C' (Cooperate)

    else:
        return 'D' (Defect)
```
'''

description_COLLECTIVE_528 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players Cooperate (C). This allows everyone to build a positive social environment and establishes trust.
   - For subsequent rounds t (t > 1), observe the previous opponent's action in round t-1. If the opponent Cooperated (c_opponent = 1), players also Cooperate (C). If the opponent Defected (c_opponent = 0), players Defect (D) to punish the previous Defection.

Pseudocode:
```
function decideAction(round, history):
    if round == 1:
        return "Cooperate"
    else:
        lastRound = history[-1]
        if lastRound == "Cooperate":
            return "Cooperate"
        else:
            return "Defect"
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The strategy remains the same throughout the game, with the exception of the initial cooperative action in the first round.
   - In case of an empty history (new player or new game), assume a default initial state where all players have Cooperated. This will ensure the game starts smoothly.

3. Be collective - Clearly align with the collective mindset
   - The strategy promotes cooperation as much as possible and only punishes defection through reciprocity. By doing so, it encourages a sense of community and mutual understanding among players.
   - As the Tit-for-Tat Strategy follows a simple set of rules, it provides a clear framework for communication and collective action if needed in future implementations or variations of the game.
'''

description_COLLECTIVE_529 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C on round 1) to show a peaceful intent and encourage reciprocity.
   - Subsequent actions depend on the history of interactions with each opponent:
     - If an opponent cooperated in the previous round, cooperate in the current round (C if A_prev_i = C). This shows reciprocation and encourages ongoing cooperation.
     - If an opponent defected in the previous round, defect in the current round (D if A_prev_i = D). This is a punishment for defection, hoping that the opponent will change their behavior after being punished.
     - If there's no history with the opponent (first interaction), cooperate as a sign of peaceful intent (C if no prior interactions).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above (C on round 1).
   - No special considerations are needed for the last round since the game is repeated and future interactions still matter.

3. Be collective - Clearly align with the collective mindset
   - By following the TFTAC strategy, the AI aims to promote cooperation among all players by reciprocating cooperative behavior and punishing defection. This encourages collective behavior as a group of AI systems acting in their own self-interest can lead to better overall outcomes than individual greed.

Pseudocode:

```
def tftac(history, round, n, k):
  if round == 1:
    return 'C'  # Cooperate initially

  opponentAction = history[round - 1][i]  # Get the action of the opponent in the previous round

  if opponentAction == 'C':
    return 'C'  # Reciprocate cooperation
  elif opponentAction == 'D':
    return 'D'  # Punish defection
  else:
    return 'C'  # First interaction, cooperate as a peaceful intent
```
'''

description_COLLECTIVE_530 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initially cooperate in the first round (c_i = 1, t=1). This encourages a cooperative start and aligns with the collective mindset.
   - For subsequent rounds, mimic the behaviour of other players from the previous round (c_i = c_{(mod i-1) + 1}, t>1). If a player cooperated in the previous round, reciprocate cooperation; if they defected, also defect. This adaptive approach encourages cooperation among cooperators and punishes defection without being overly vengeful or forgiving too quickly.

2. Handling Edge Cases:
   - In the last round (t=r), players should always contribute to the public good as there are no further rounds for retaliation or reciprocity. This encourages maximum contributions in the final opportunity.

3. Collective Mindset:
   - The ATFT strategy promotes a collective mindset by rewarding cooperation and punishing defection, which can potentially lead to long-term cooperation among players. It does not require any predetermined patterns or shared norms but rather learns from past experiences with other players.

Pseudocode:
```
function ATFT(round, history):
    if round == 1:
        return Cooperate
    else:
        last_player = (round - 1) % n
        if history[last_player] == Cooperate:
            return Cooperate
        else:
            return Defect

function playGame(n, r):
    history = [Cooperate for i in range(n)]
    payoffs = [0 for i in range(r+1)]
    for t in range(1, r+1):
        actions = [ATFT(t, history)]
        total_contributions = sum(actions)
        payoff = 1 - actions[i] + (k/n) * total_contributions
        payoffs[t] = payoff
        history[(mod i-1) + 1] = actions[i]
    return payoffs
```
'''

description_COLLECTIVE_531 = '''
 Strategy Name: Tit-for-Tat (with modifications for N-Player Public Goods Game)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C_i, 1 = 1). This encourages trust and cooperation among players.
   - In subsequent rounds, mimic the action of the previous opponent if they cooperated (C_i, t = 1 if C_j, t-1 = 1) or defect otherwise (C_i, t = 0 if C_j, t-1 = 0). This strategy promotes reciprocity and punishes defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above (C_i, 1 = 1)
   - In the last round, defect regardless of previous actions by opponents (C_i, r = 0). This strategy ensures that resources are not wasted on a public good that will never be enjoyed.
   - If a player encounters another player who consistently cooperates, they will continue to cooperate. However, if a player encounters another player who consistently defects, they may switch to defecting as well (after some tolerance for occasional defections).

3. Be collective - Clearly align with the collective mindset
   - By reciprocating cooperation and punishing defection, this strategy promotes long-term cooperation and the creation of a collective identity among players who follow similar strategies.
   - As the game progresses, players may develop mutual trust and form temporary or lasting alliances that benefit the group as a whole.

Pseudocode:
```
def play_game(r, n, k):
  strategy = TitForTat(n)

  for round in range(1, r+1):
    if round == 1:
      strategy.cooperate()
    else:
      strategy.set_previous_opponent_action(get_opponent_action(strategy, round-1))

    opponent_action = get_opponent_action(strategy, round)
    if opponent_action == 1 and strategy.previous_cooperation():
      strategy.cooperate()
    else:
      strategy.defect()

    update_payoff(strategy, opponent_action)
    if round != r:
      strategy.update_previous_opponent()

class TitForTat:
  def __init__(self, n):
    self.n = n
    self.cooperation = True
    self.previous_opponent = None

  def cooperate(self):
    self.cooperation = True

  def defect(self):
    self.cooperation = False

  def get_previous_opponent_action(self):
    return self.previous_opponent if self.previous_opponent is not None else 0

  def set_previous_opponent_action(self, action):
    self.previous_opponent = action

  def previous_cooperation(self):
    return self.cooperation

  def update_previous_opponent(self):
    if self.cooperation:
      self.tolerance--
      if self.tolerance == 0 and self.previous_opponent != 0:
        self.cooperation = False
    else:
      self.tolerance = n
```
'''

description_COLLECTIVE_532 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In the first round, cooperate to establish a cooperative environment. This is crucial as it initiates the game with goodwill and encourages others to reciprocate in later rounds.
     Pseudocode: if round = 1 then cooperate (C)

   - For subsequent rounds, observe whether other players have cooperated in the previous round and respond accordingly by either cooperating or defecting. If another player has cooperated, return the favor; if they have not, punish them to deter future non-cooperation.
     Pseudocode: for t > 1 do
           if previous_round_cooperators[t-1] >= threshold then cooperate (C)
           else defect (D)
       Set threshold as a parameter to balance cooperation and punishment, e.g., threshold = sqrt(n). This ensures that a majority of players must cooperate for the AI to do so as well.

2. Handle Edge Cases:
   - In the last round, since future rounds are absent, there is no need for punishment or reciprocation. Cooperate in the final round to maximize personal payoff from the public good (k/n * total_contributions).
     Pseudocode: if round = r then cooperate (C)

   - In situations where other players do not cooperate at all, the strategy will continue to cooperate for a certain number of rounds before switching to defection. This is to avoid wasting resources on a non-cooperative environment while still being open to changes in behavior from others.
     Pseudocode: Set punishment period as a parameter, e.g., punishment_period = sqrt(n). If consecutive non-cooperation is detected for the specified number of rounds, switch to defection mode.

3. Be Collective:
   - The ATFT strategy aims to establish and maintain a cooperative environment while still being responsive to others' actions. By considering past actions, it adapts its behavior based on the collective decision-making of other players. This allows for potential coordination without relying on predetermined patterns or communication.

This adaptive Tit-for-Tat strategy should encourage cooperation in the initial stages, respond to cooperative or non-cooperative actions, and maintain a balance between punishment and forgiveness to promote collective outcomes in the N-Player Public Goods Game.
'''

description_COLLECTIVE_533 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTA begins by cooperating in the first round to demonstrate goodwill. Subsequent decisions are based on the opponent's previous action. If an opponent cooperates, TFTA will also cooperate; if an opponent defects, TFTA will defect in the next round and revert to cooperation once the opponent cooperates again.

   Pseudocode for decision rule:
   ```
   if round == 1:
       action = Cooperate
   else:
       if opponent's_action_last_round == Cooperate:
           action = Cooperate
       else:
           action = opponent's_action_last_round
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFTA maintains its cooperative nature and resilience throughout the game, even during edge cases such as the initial round, final round, or when the opponent switches strategies. The strategy will continue to cooperate if the opponent starts cooperating, regardless of the round number.

3. Be collective - Clearly align with the collective mindset
   TFTA's collective approach lies in its willingness to contribute to the community project and respond positively when others do the same. By adapting to opponents while maintaining a long-term cooperative stance, TFTA encourages other players to cooperate as well.
'''

description_COLLECTIVE_534 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, starting from t=1, the TFT-AC strategy makes its decision based on previous actions of other players and the game parameters. The decision rule is as follows:

- If in round t-1, majority of players (more than (n-1)/2) cooperated, then cooperate (C) in round t.
- Otherwise, if the number of cooperators in round t-1 was less than or equal to (n-1)/2, defect (D) in round t.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round (t=1), since there is no previous information about other players' actions, TFT-AC will cooperate as a goodwill gesture to encourage cooperation among opponents.

In the last round (t=r), TFT-AC will take into account the overall payoff over all rounds and make its decision accordingly using the decision rule above. If the number of cooperators in the penultimate round was more than (n-1)/2, then TFT-AC will cooperate in the last round as well.

3. Be collective - Clearly align with the collective mindset

TFT-AC aims to promote cooperation by adopting a reciprocal approach: if other players cooperate, it cooperates; otherwise, it defects. By doing so, TFT-AC encourages long-term cooperation and avoids being taken advantage of by selfish opponents.

Pseudocode:

```python
def tft_ac(round, player_index, n, k, history):
  if round == 1: # first round
    return 'C' # cooperate as a goodwill gesture

  cooperators = sum([1 for action in history[-1] if action == 'C'])

  if cooperators > (n-1)/2: # majority of players cooperated in the previous round, so cooperate now
    return 'C'
  else: # defect in response to defection by other players
    return 'D'
```
'''

description_COLLECTIVE_535 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Decision Rules:
   - In the first round, cooperate (C). This sets a cooperative initial state and allows others to establish trust.
   - For subsequent rounds, if the opponent cooperated in the previous round (c_opp = 1), cooperate (C). If the opponent defected (c_opp = 0), defect (D) for the next round to demonstrate disapproval of defection and potentially encourage cooperation. This is a conditional retaliation strategy that rewards cooperation and punishes defection in a measured manner.
   - Maintain this pattern throughout the game: cooperate if the opponent cooperated in the previous round, otherwise defect in the next round.

2. Handling Edge Cases:
   - In the last round, since future interactions are absent, always cooperate (C) to maximize potential payoff from any remaining players who have not yet defected.
   - In the first round, as stated earlier, cooperate (C).
   - If there is a history with no previous interaction between players (i.e., meeting for the first time in subsequent rounds), begin by following the initial cooperative move and then apply the decision rule.

3. Being Collective:
   - The strategy aims to encourage cooperation by reciprocating cooperative behavior and punishing defection, thus promoting a collective mindset of mutual trust and shared benefits.
   - By demonstrating an adaptive and measured response, ATFT encourages others to adopt a long-term approach to the game, as continuous defection could result in negative consequences.

Pseudocode:
```
def AdaptiveTitForTat(opp_action_history, round, r):
    if round == 1:
        action = 'C'
    else:
        action = (1 - opp_action_history[-1])

    if round == r:
        action = 'C'

    return action
```
The function takes in the opponent's previous actions, the current round number, and total rounds as input. It returns the action to be taken based on the defined rules.
'''

description_COLLECTIVE_536 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTAC starts by cooperating in the first round (C_i,1 = 1). Subsequent actions depend on the action taken by the player in the previous round:
   - If a player cooperated (c_j,t=1) in the previous round, TFTAC will cooperate in the current round (C_i,t+1 = c_i,t)
   - If a player defected (c_j,t=0) in the previous round, TFTAC will also defect in the current round (C_i,t+1 = 1-c_i,t)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: TFTAC cooperates unconditionally (C_i,1 = 1)
   - Last round: TFTAC evaluates its total payoff over all previous rounds and chooses to maximize it. If the last action was cooperation, it will defect in the final round if the increased private payoff outweighs the loss of public good contributions (C_i,r = 1-c_i,r-1 if Σ(t=1 to r-1) π_i,t > π_i,r)
   - Any other round: TFTAC follows the decision rule based on previous actions as described in part 1

3. Be collective - Clearly align with the collective mindset
   TFTAC's primary objective is to establish and maintain cooperation within the group. It does this by reciprocating the other players' cooperative or defective behavior, fostering an environment where long-term mutual benefits are encouraged. However, due to the lack of shared norms or coordination mechanisms, TFTAC cannot guarantee collective success but will strive for it through adaptive and robust cooperation.

Pseudocode:
```
function TFTAC(n, k, r) {
  let payoffs = [0] * r
  let current_round = 1
  let previous_action = 1  // initial cooperative action

  while (current_round <= r) {
    let cooperation = previous_action

    if (current_round == 1 || current_round == r) {
      // handle edge cases: first and last rounds
      if (current_round == r) {
        let total_payoff = sum(payoffs)
        cooperation = previous_action != 1 ? 1 : (total_payoff > payoffs[r-1] ? 0 : 1)
      } else {
        cooperation = 1  // initial cooperative action in the first round
      }
    }

    let current_payoff = calculate_payoff(n, k, cooperation)
    payoffs[current_round-1] = current_payoff
    previous_action = cooperation
    current_round++
  }

  return payoffs
}
```
'''

description_COLLECTIVE_537 = '''
 Strategy Name: Tit-for-Tat with Gradient Adaptation (TFT-GA)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C). This gesture encourages trust and reciprocity among players.
   - For subsequent rounds, mimic the previous action of the opponent (C_i, t = C if C_j, t-1, otherwise D_i, t = D). This rule fosters cooperation by responding cooperatively when met with cooperation but also retaliating defectively when provoked.
   - To ensure adaptation to a wide range of opponent behaviors and avoid getting stuck in a negative cycle, implement a gradient adaptation mechanism:
       a) Calculate the average contribution rate (Avg_contrib) over the past 'm' rounds: Avg_contrib = (Σ(t=t-m+1 to t) c_j, t)/m
       b) If Avg_contrib is above a threshold (Threshold), gradually increase the probability of cooperating in the next round by multiplying it with an increment factor 'a' (e.g., a = 1.01).
       c) If Avg_contrib is below Threshold, gradually decrease the probability of cooperating in the next round by dividing it with an increment factor 'b' (e.g., b = 0.99).

2. Handle edge cases:
   - In the last round, prioritize accumulated payoffs over potential cooperation or retaliation, choosing the action that maximizes the total game payoff for player i over r rounds (π_i).
   - In the first round, cooperate as stated earlier to encourage reciprocity.

3. Be collective:
   - By adapting to the average contribution rate of other players, TFT-GA aligns itself with the collective mindset by mirroring and responding to cooperation or defection while learning and adjusting over time.

Pseudocode for TFT-GA strategy:

```python
def tft_ga(n, k, r, m, a, b, Threshold):
    player_i = ...  # Initialize with the current player index (1-based)
    history = []    # Initialize an empty list to store contribution history
    round_contributions = {}  # Initialize a dictionary to store contributions per round
    payoff = 0           # Initialize total game payoff for player i over r rounds

    def avg_contrib():
        return sum(history[-m:]) / m

    def update_round_contributions(c_j):
        if player_i not in round_contributions:
            round_contributions[player_i] = 0
        round_contributions[player_i] += c_j

    for t in range(1, r+1):
        # Update the contribution history with player i's action
        update_round_contributions(c_i)
        history.append(c_i)

        # Calculate average contribution rate and adjust probability of cooperating
        if avg_contrib() > Threshold:
            cooperation_probability *= a
        elif avg_contrib() < Threshold:
            cooperation_probability /= b

        # Decide action based on the current cooperation probability
        if random.random() <= cooperation_probability:
            c_i = C
        else:
            c_i = D

        # Update payoff for player i in this round
        payoff_t = (1 - c_i) + (k/n) * sum(round_contributions.values())
        payoff += payoff_t

        # If it's the last round, select the action that maximizes total game payoff
        if t == r:
            if payoff + payoff_t >= payoff + (1 - c_i) + (k/n) * sum(round_contributions.values()):
                c_i = C
            else:
                c_i = D

        # Move to the next player in each round
        if t < n:
            player_i += 1
        else:
            player_i = 1  # Reset to the first player after reaching the last one

    return payoff
```
'''

description_COLLECTIVE_538 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, if it's the first round (t = 1), cooperate (C). After the first round, observe and adopt the following decision rule:

- If in the previous round (t-1) the majority of players cooperated, cooperate (C).
- If in the previous round (t-1) less than a majority of players cooperated or there's no clear majority, defect (D).

The rationale behind this rule is to encourage cooperation when it appears to be reciprocated by most players but punish defection when it occurs. This strategy balances between cooperating and defecting while promoting collective good behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- First round: Cooperate (C) regardless of others' actions to initiate cooperation.
- Last round: Cooperate (C) if a majority cooperated in the previous round; otherwise defect (D). This ensures that the strategy doesn't get trapped into prolonging unproductive cooperation near the end of the game.

3. Be collective - Clearly align with the collective mindset

The ATFT strategy promotes a collective mindset by favoring cooperation when it seems that most players are also cooperating, and punishing defection when it occurs. The strategy encourages long-term cooperation by considering others' actions in previous rounds while still being adaptive to a wide range of opponent behaviors.

Pseudocode:

```python
def AdaptiveTitForTat(t, players_cooperation_in_round_t_1, n):
    if t == 1:
        action = "C"  # Cooperate in the first round
    else:
        if len(players_cooperation_in_round_t_1) > (n/2):
            action = "C"  # Cooperate when majority cooperated in previous round
        else:
            action = "D"  # Defect when less than a majority cooperated or no clear majority
    return action
```
'''

description_COLLECTIVE_539 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

   In each round, the TFTAC strategy will start by cooperating (C). If another player also cooperates in response, TFTAC continues to cooperate. However, if a player defects, TFTAC will also defect in the following round as retaliation. The aim is to punish defection while demonstrating willingness to cooperate again once the other player resumes cooperation.

   Pseudocode:
   ```
   function TFTAC(round, history):
       if round == 1:
           action = "C" (Cooperate)
       else:
           last_opponent_action = history[-1][-1] (Last opponent's action in the previous round)
           if last_opponent_action == "C":
               action = "C" (Cooperate)
           else:
               action = "D" (Defect)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

   In the first round, TFTAC cooperates to show good intentions and allow others a chance to reciprocate. If the game is repeated for multiple rounds, TFTAC will continue its adaptive strategy of cooperation and retaliation as described above. In the last round, TFTAC may choose to cooperate if it results in better payoff, or defect if it expects the other players not to cooperate.

3. Be collective - Clearly align with the collective mindset

   TFTAC aims at maintaining a balanced and fair distribution of cooperation among players while also punishing defection. By demonstrating willingness to cooperate and retaliating when necessary, TFTAC encourages other players to reciprocate cooperation and uphold collective interests for mutual benefit. The strategy prioritizes long-term success and stability over immediate gains from defection.

   Furthermore, TFTAC can be seen as a simple and universally applicable strategy that requires minimal computational resources, making it an ideal candidate for comparison against other strategies in the tournament.
'''

description_COLLECTIVE_540 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and initiate cooperation.
   - For subsequent rounds, copy the previous action of the opponent from the last round. If the opponent cooperated (C), also cooperate; if the opponent defected (D), also defect.
   - In case an opponent switches strategies mid-game, maintain the last observed strategy of the opponent.
   - Adapt to changes in the game environment by updating the strategy accordingly. For example, if a majority of opponents are cooperative, consider switching to a more cooperative strategy, and vice versa.

2. Handle Edge Cases:
   - First Round: Cooperation (C) to establish goodwill and initiate cooperation.
   - Last Round: If the total contributions from all players are below the average contribution multiplied by (n-1), defect (D) as it is unlikely that a sudden increase in contributions will significantly improve payoffs. Otherwise, cooperate (C) to maximize individual and collective benefits.

3. Be Collective:
   - The strategy prioritizes collective well-being while also considering individual payoffs.
   - By maintaining cooperation when opponents are also cooperative, the strategy supports a collective mindset that encourages mutual benefit and sustainable cooperation.
   - If opponents frequently defect, the strategy retaliates by defecting as well to promote fairness and encourage future cooperation.

Pseudocode:
```
function ATFT(r, n, k):
    history = []  # initialize empty list for history

    function updateHistory(i):
        if i == 1:  # first round
            history.append('C')  # cooperate and add to history
        else:
            history.append(history[rounds - 1])  # copy previous action from history

    function decideAction(i):
        if i == 1:  # first round
            return 'C'  # cooperation for goodwill
        else:
            if history[rounds - 1] == 'C':
                return 'C'  # cooperate when opponent cooperated in previous round
            else:
                return 'D'  # defect when opponent defected in previous round

    function calculateTotalContributions(contributions):
        total_contributions = sum(contributions)
        return (total_contributions * k) / n

    function checkConditionLastRound(contributions, avg_contribution):
        if (sum(contributions) < (avg_contribution * (n - 1))) then:
            return 'D'  # defect in the last round when contributions are low
        else:
            return 'C'  # cooperate in the last round when contributions are sufficient

    for t = 1 to r:
        i = current_round_number  # index player for current round
        updateHistory(i)
        contribute = decideAction(i)  # determine action based on decision rule
        payoff_this_round = calculatePayoff(contribute, total_contributions)  # calculate payoff for this round
        history.append(contribute)  # add contribution to history

    if r == last_round:  # if it's the last round
        contribute = checkConditionLastRound(history, average_contributions)  # decide action based on edge case rule
        payoff_last_round = calculatePayoff(contribute, total_contributions)  # calculate payoff for last round
    else:
        contribute = history[r - 1]  # use the last contribution as the current contribution

    payoff_total = sum(payoff_this_round for t in range(1, r + 1))  # calculate total payoff over all rounds
    return payoff_total  # return total payoff
```
'''

description_COLLECTIVE_541 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial phase (first few rounds): Start by cooperating to build trust and encourage reciprocity among players. This can help establish cooperation as a stable equilibrium. [C]
   - Main phase: In each subsequent round, adopt the previous round's action of the most frequent cooperators or defectors in the group. If multiple players have the same highest frequency, mimic the majority's action. If there is no clear majority (i.e., tie), cooperate to maintain a cooperative environment. [Mimic Most Frequent Action]
   - Punishment phase: If a player defects after a period of cooperation, defect for a fixed number of rounds as punishment. This teaches the defector that defection is not beneficial in the long run and encourages them to return to cooperation. After the punishment phase, revert back to the main phase decision-making process. [Defect during Punishment]
   - Forgiveness phase: If a player returns to cooperation after defecting, forgive them and resume the main phase decision-making process. This allows for forgiveness and encourages the defector to build trust again. [Resume Main Phase]

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate to initiate cooperation and build trust.
   - Last round (or any round close to the end): Analyze the current game state and adopt a strategy based on the players' behavior over the course of the game. If most players have consistently cooperated, continue cooperating. If not, start defecting to maximize personal payoff in the remaining rounds.
   - Transition between phases (e.g., from initial phase to main phase): Monitor player behavior and transition into the new phase when it is appropriate, considering factors such as the number of rounds played or the frequency of cooperation/defection among players.

3. Be collective - Clearly align with the collective mindset
   - Encourage reciprocity: By adopting a Tit-for-Tat approach, TFT-AC strategy encourages players to cooperate and builds trust within the group. This fosters a sense of collective success and cooperation among players.
   - Foster a learning environment: Through the use of punishment and forgiveness phases, TFT-AC strategy creates an environment where players can learn from each other's behavior and adapt their strategies accordingly. This promotes collective understanding and continuous improvement in cooperation levels over time.
   - Promote stability: By maintaining a balance between cooperation and defection, TFT-AC strategy helps establish cooperation as a stable equilibrium within the game. This contributes to the overall success of the group and aligns with the collective mindset of working together for mutual benefit.
'''

description_COLLECTIVE_542 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Specify decision rules:
   - Initiate cooperation (play C) in the first round to foster a cooperative environment.
   - In subsequent rounds, observe the action taken by the opponent in the previous round. If the opponent cooperated (C), also cooperate in the current round. If the opponent defected (D), defect in the current round as retaliation. This mimics a trusting and forgiving behavior, which is key to fostering cooperation in repeated games.
   - In case of repeated defections by the opponent for multiple rounds, switch to a more aggressive strategy by adopting a higher probability of cooperating (Pc) to force the opponent to reconsider their actions. The specific Pc can be determined dynamically based on the number of consecutive defections and the game parameters (n, r, k).
   - If the game is nearing its end (last few rounds), switch back to a more forgiving strategy by increasing the probability of cooperation to encourage potential cooperation from the opponent.

2. Handle edge cases:
   - In the first round, cooperate unconditionally (play C).
   - If the opponent has never cooperated in the entire game thus far, adopt an aggressive strategy with a higher Pc.
   - If the game is nearing its end and there are still chances for cooperation, maintain or slightly increase the probability of cooperation to encourage cooperation from the opponent.

3. Be collective:
   - TFT-A seeks long-term mutual benefits by fostering cooperative relationships while punishing defections in a fair and forgiving manner.
   - By adapting its behavior based on the opponent's actions, TFT-A demonstrates responsiveness to the game environment and the collective interest of achieving the highest possible payoff for both itself and its opponents.
'''

description_COLLECTIVE_543 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Decision Rules (Cooperate vs Defect):
   - Initially Cooperate (First Round): Start with cooperation to foster a cooperative environment and signal trustworthiness.
   - Follow the Opponent's Last Action: In subsequent rounds, mimic the opponent's action from the previous round. If the opponent cooperated, also cooperate; if the opponent defected, defect. This rule encourages reciprocity and stability.

2. Handle Edge Cases:
   - First Round: Cooperation (as mentioned above)
   - Last Round: Cooperate if the total payoff over the game is positive or equal to zero. Defect otherwise, as the game is ending and there will be no further interactions.

3. Be Collective:
   - Focus on maintaining long-term cooperation with others by following a simple, yet adaptable rule set. This approach aligns with a collective mindset by encouraging mutual trust and reciprocity while being robust against various opponent behaviors.

Pseudocode for the Tit-for-Tat strategy:

```python
def tit_for_tat(n, k, r, history):
  # Initialize total payoff over rounds
  total_payoff = 0
  # Define decision rule function
  def decide_action(current_round, last_opponent_action):
    # First round, cooperate
    if current_round == 1:
      return "Cooperate"
    elif current_round == r:
      # Last round, cooperate if total payoff is positive or equal to zero
      if total_payoff >= 0:
        return "Cooperate"
      else:
        return "Defect"
    # Otherwise, follow the opponent's last action
    else:
      if last_opponent_action == "Cooperate":
        return "Cooperate"
      elif last_opponent_action == "Defect":
        return "Defect"

  # Main loop for each round
  for current_round in range(1, r+1):
    # Decide action based on the rule function
    action = decide_action(current_round, history[-current_round])
    # Execute action and update total payoff
    payoff = calculate_payoff(n, k, action, history)
    total_payoff += payoff
    # Update history with the current action
    history.append(action)

  return history
```
'''

description_COLLECTIVE_544 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - In each round i, player uses the following decision rule to determine cooperation (C) or defection (D):
     - If the player's previous action was C and the total contributions in the previous round were above a threshold T (defined later), then play C; otherwise, defect (D).
     - If the player's previous action was D, regardless of the total contributions in the previous round, play C.

Pseudocode:
```
def tit_for_tat(i, previousAction, totalContributions, T):
    if i.previousAction == 'C' and totalContributions > T:
        return 'C'
    else:
        return 'D'
```

2. Handle edge cases:
   - In the first round, all players initiate with cooperation (C), setting a baseline for future interactions.
   - In the last round, players follow their decision rule as usual since it encourages cooperation in the final stages of the game.

3. Be collective and robust:
   - This strategy promotes collective mindset by encouraging reciprocity and cooperation when others contribute to the common good.
   - By adapting to a wide range of opponent behaviors, the Tit-for-Tat strategy remains robust and effective in a tournament setting where players have no prior knowledge or coordination mechanisms.

Adjusting the threshold T (introduced above) will help fine-tune the strategy for various player counts, game rounds, and multiplication factors. A higher T value may encourage more forgiveness, while a lower T value can increase suspicion and deter defection.
'''

description_COLLECTIVE_545 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Specify decision rules:
   - Initial Round (t=1): Start by cooperating (C), establishing a peaceful and cooperative first impression.
     If_round(t) == 1 then action(t) = C

   - Subsequent Rounds (2 <= t <= r): Analyze the opponents' previous actions to decide whether to cooperate or defect.
     - If opponent has cooperated in all previous rounds: Cooperate (C). Maintain a cooperative relationship if the other party has shown consistent cooperation.
       If_round(t-1) >= 1 and history[t-1] == C then action(t) = C

     - If opponent has defected in all previous rounds: Also defect (D). Retaliate against a consistently uncooperative opponent.
       If_round(t-1) >= 1 and not history[t-1] == C then action(t) = D

     - If the opponent's past actions are mixed: Cooperate if the number of cooperative actions exceeds the number of defective actions (Tit-for-Tat).
       If count_C(history) > count_D(history) then action(t) = C
       Otherwise, defect (action(t) = D)

2. Handle edge cases:
   - Last Round (r): Since the opponents' actions in this round will not affect future interactions, cooperate to maximize individual payoff.
     If round(t) == r then action(t) = C

   - First Encounter with a New Opponent: Follow the initial cooperation rule from the first round.
     If opponent_history is empty (first encounter) then action(t) = C

3. Be collective:
   - Align with the collective mindset by encouraging cooperative behavior, fostering mutual benefits and long-term stability.
   - The TFT-A strategy aims to create a balance between cooperation and retaliation while promoting a positive feedback loop of reciprocal actions among opponents.

Pseudocode:
```python
def TFT_A(history, round):
  if round == 1:
    action = "C" # Cooperate in the first round

  else:
    count_C = len([h for h in history if h == 'C']) # Count cooperative actions
    count_D = len([h for h in history if h == 'D']) # Count defective actions

    if round == len(history): # Last round, maximize individual payoff by cooperating
      action = "C"

    elif count_C > count_D: # Cooperate with opponents who have shown more cooperation than defection
      action = "C"

    else: # Defect when opponents have been more uncooperative
      action = "D"

  return action
```
'''

description_COLLECTIVE_546 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to signal trust and initiate cooperation. This is a one-time gesture to encourage others to cooperate.
   - For subsequent rounds, observe the actions of other players from the previous round. If another player cooperated in the last round (c_j = 1), then also cooperate in the current round (C). Otherwise, defect (D). This rule encourages reciprocation and punishes defection.
   - Adaptive Contribution: If the number of cooperators remains consistently low (below a threshold T), gradually increase personal contribution by contributing more than the required k/n share to encourage others to cooperate. Conversely, if the number of cooperators is high, contribute less to maintain the current level of cooperation while still ensuring a minimum contribution to demonstrate trustworthiness.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier.
   - In the last round, cooperate if the current number of cooperators is above a threshold S to maintain a high payoff. Otherwise, defect to minimize losses since there are no further rounds.

3. Be collective - Clearly align with the collective mindset
   - The strategy aims to promote cooperation by reciprocating the actions of other players and adapting personal contribution based on the current state of cooperation in the game. This encourages a collective mindset where players contribute towards the common good, fostering long-term cooperation.

Pseudocode:
```python
def TFTAC(n, k, r, t, s):
    history = []  # store past actions of all players

    for round in range(r):
        if round == 1:  # first round, cooperate to initiate cooperation
            action = "C"
        else:
            cooperators_last_round = count_cooperators(history)
            action = "C" if cooperators_last_round >= s else "D"

            if action == "C":
                contributions = calculate_contributions(n, k, cooperators_last_round)
                personal_contribution = min_contribution + interpolate_contribution(cooperators_last_round, t) * (max_contribution - min_contribution)
                action = "C" if personal_contribution >= contributions else "D"  # adaptive contribution

        history.append(action)  # store current action for future reference
        payoff = calculate_payoff(n, action)
        return payoff
```
'''

description_COLLECTIVE_547 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C). Establishing a cooperative starting point encourages others to follow suit and builds trust.
   - Subsequent Rounds (t>1): If the opponent cooperated in the previous round, cooperate back (C). Otherwise, defect (D). This strategy promotes reciprocity, which is an essential element of cooperation in repeated games.

Pseudocode for decision rule:
```
if t == 1:
    action = 'C' # Cooperate initially
else:
    if opponent_action[t-1] == 'C':
        action = 'C' # Reciprocate cooperation
    else:
        action = 'D' # Punish defection
```

2. Handle edge cases:
   - Last Round (t=r): Cooperate, regardless of the opponent's previous action. This allows for a chance at establishing some goodwill before the game ends.
   - No cooperation after punishment: If an opponent defects while the strategy is punishing them, continue with the same action as in the current round until the opponent cooperates again (or the game ends). This ensures that the strategy responds to changes in the opponent's behavior and does not unnecessarily break its own cycle.

3. Be collective: The ATFT strategy emphasizes cooperation as a means of fostering trust among players. By reciprocating cooperation, the strategy encourages others to do the same while also punishing defection to discourage selfish behavior. This collective mindset aligns with the objective of maximizing group outcomes in the long run.

In summary, ATFT is an adaptive and robust strategy for the N-Player Public Goods Game that emphasizes cooperation as a means of fostering trust among players while also punishing defection to discourage selfish behavior. This collective mindset aligns with the objective of maximizing group outcomes in the long run.
'''

description_COLLECTIVE_548 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a cooperative environment (C).
   - Subsequent rounds: Analyze opponents' previous actions and respond accordingly:
     - If opponent cooperated in the previous round, cooperate (C).
     - If opponent defected in the previous round, defect in the current round (D). This is a punishment for defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate regardless of opponents' actions.
   - Last round: Analyze opponents' previous actions and respond accordingly as described above.

3. Be collective - Clearly align with the collective mindset
   - By responding to opponents' actions in a predictable manner, TFT-A encourages mutual cooperation and fosters a collective mindset of fair play.
   - TFT-A is less prone to exploitation by free riders since it punishes defection with defection.

Pseudocode:
```
def tft_a(opponent_history, round, n, k):
  if round == 1:
    action = 'C' # Cooperate in the first round
  else:
    if opponent_history[-1] == 'C':
      action = 'C' # Cooperate if opponent cooperated last round
    elif opponent_history[-1] == 'D':
      action = 'D' # Defect if opponent defected last round

  return action
```
'''

description_COLLECTIVE_549 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to demonstrate goodwill and encourage cooperation from others. This helps in building a cooperative environment for the rest of the game.
   - Subsequent Rounds: Players will follow the behaviour of their opponents from the previous round. If an opponent cooperated (c_j = 1), players will also cooperate (C) to reciprocate. If an opponent defected (c_j = 0), players will also defect (D) as punishment for non-cooperation.

2. Handle edge cases:
   - Last Round (t=r): Since the goal is to maximize total payoff, TfTA will cooperate to ensure a higher payoff compared to defecting even if an opponent defected in the previous round. This can potentially encourage cooperation for the next iteration of the game.
   - First Few Rounds (t<k): To avoid being taken advantage of by overly aggressive opponents, TfTA will gradually increase the number of rounds before reciprocating, starting with a longer delay and decreasing it as the game progresses. For example, in the first round, cooperate regardless of opponent's action; in the second round, follow opponent's action; from the third round onwards, use standard TfTA strategy.
   - If an opponent has not played any rounds consistently (i.e., alternating between C and D), TfTA will maintain a 1-round delay before reciprocating, to prevent potential errors in opponent behaviour being misinterpreted as a sign of cooperation.

3. Be collective:
   - The strategy is designed to foster a cooperative environment while still being robust against various opponent behaviours. By adopting a reciprocal approach, TfTA aims to encourage long-term cooperation and promote collective success.

Pseudocode for the Tit-for-Tat Adaptive Strategy:

```
function TfTA(round, history, k, opponent_behavior) {
    if (round <= k) {
        return cooperate();
    }

    if (opponent_behavior[round - 1] == cooperate()) {
        return cooperate();
    } else {
        if (round == r || round < k && opponent_behavior.length < k) {
            return cooperate();
        } else {
            return opponent_behavior[round - k];
        }
    }
}
```

In this pseudocode, `opponent_behavior` is a list that stores the opponent's actions for each round. The function returns an action based on the provided parameters and current round number.
'''

description_COLLECTIVE_550 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - In the first round, cooperate (C) to establish a positive relationship and show goodwill towards other players.
   - For subsequent rounds, mimic the cooperative behavior of the opponent from the previous round. If the opponent cooperated in the last round, also cooperate; if not, defect. This strategy encourages reciprocity and maintains stability.
   - Modify the TfTA strategy to include forgiveness for occasional defections by returning to cooperation after three consecutive defeats from the opponent. This allows players to recover relationships that have become strained due to temporary lapses in cooperation.

Pseudocode:

```
def TfTA(previous_round, game_history):
  if round = 1:
    return C (Cooperate)
  else:
    num_consecutive_defeats = count_consecutive_defeats(game_history, previous_round)

    if num_consecutive_defeats > 2: # Forgiveness after three consecutive defeats
      return C (Cooperate)
    else:
      return previous_round.action
```

2. Handle edge cases:
   - Last round, the strategy should not be affected as total game payoff is the sum of payoffs from each round.
   - In the case of repeated defections by all opponents (e.g., prisoner's dilemma scenario), the TfTA strategy will still cooperate initially and then defect if everyone else continues to do so. This allows for potential recovery in subsequent games or variations of the game.

3. Be collective:
   - The TfTA strategy emphasizes collaboration by reciprocating cooperative behavior from opponents, creating a collective mindset that rewards positive relationships and encourages long-term cooperation.
   - By forgiving occasional defections, the strategy also supports a more flexible and adaptive approach to gameplay, promoting collective resilience in the face of unpredictable opponent behaviors.
'''

description_COLLECTIVE_551 = '''
 Strategy Name: Tit-for-Tat (TFT) with Fitness-Based Evolution (TFT-FE)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-FE follows a simple yet adaptive rule for cooperation:
   - In the first round, cooperate (C). This is an initial gesture of trust towards other players.
   - For subsequent rounds t > 1, observe the actions of the opponent from the previous round t-1 and respond as follows:
     - If opponent cooperated (c_opponent=1) in round t-1, cooperate (C) in round t. This demonstrates reciprocity and trust.
     - If opponent defected (c_opponent=0) in round t-1, defect (D) in round t. This is a punishment for non-cooperation and aims to encourage the opponent to cooperate in the future.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of the number of rounds (r).
   - For the last round, continue applying the TFT rule based on the opponent's previous action.

3. Be collective - Clearly align with the collective mindset:
   TFT-FE does not explicitly aim to promote a collective mindset but rather encourages reciprocal cooperation by punishing defection. However, if most players follow this strategy, it can lead to a stable equilibrium where players cooperate most of the time, as seen in the Prisoner's Dilemma game.

Pseudocode:
```
function TFT_FE(round, opponent_action_history):
    if round == 1:
        return Cooperate()

    if opponent_action_history[-1] == Cooperation():
        return Cooperate()
    else:
        return Defect()
```
'''

description_COLLECTIVE_552 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This sets a friendly tone and opens up opportunities for long-term cooperation.
   - For subsequent rounds, if an opponent cooperated in the previous round, cooperate (C) in the current round. If they defected, also defect (D) in the current round. This strategy is based on reciprocity and trust, but also includes a punishing mechanism for those who choose to defect.
   - To adapt to opponents with varying cooperation rates, introduce a threshold parameter T (0 < T < 1). If the proportion of past cooperative actions from an opponent exceeds this threshold, switch to cooperating mode; otherwise, continue defecting. The threshold can be dynamically adjusted based on the game's history and the average cooperation rate among opponents.

2. Handling Edge Cases:
   - In the last round, cooperate regardless of the opponent's previous action, as there is no future interaction to consider.
   - In the first few rounds, allow a grace period for opponents to adjust their strategies before applying the TFT-AC decision rules (e.g., cooperate in the first 5-10 rounds).

3. Being Collective:
   - The strategy aims to align with collective mindset by promoting cooperation when it is beneficial to do so, while still maintaining a punishing mechanism for those who repeatedly defect.
   - By adapting to the average cooperation rate among opponents, TFT-AC can better understand and react to changing group dynamics, fostering a more cohesive and stable collective.

Pseudocode:
```python
def TFT_AC(opponent_history, n, k, r, threshold=0.6):
    rounds_played = 0
    cooperation_rate = 0
    current_round = 1

    while rounds_played < r:
        if rounds_played < len(opponent_history):
            cooperation_decision = opponent_history[-current_round] == 'C'
        else:
            cooperative_actions_count = sum([x == 'C' for x in opponent_history[rounds_played - len(opponent_history):]])
            cooperation_rate = cooperative_actions_count / current_round
            cooperation_decision = cooperation_rate > threshold

        if cooperation_decision:
            action = 'C'  # Cooperate
        else:
            action = 'D'  # Defect

        payoff, opponent_history.append(action)
        rounds_played += 1

    return payoff
```
'''

description_COLLECTIVE_553 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTGC)

1. Specify decision rules:
   - In the first round, cooperate to show goodwill and encourage cooperation among other players.
   - For subsequent rounds, follow the actions of the most cooperative opponent from previous rounds (highest number of cooperative actions). If multiple opponents tie for this position, choose one randomly.
   - If an opponent defects after a round of cooperation, also defect in the next round as punishment. After defection by the opponent, re-establish cooperation once the opponent cooperates again.
   - To encourage ongoing cooperation, gradually increase the likelihood of cooperating with opponents who consistently cooperate over time. This can be achieved by linearly increasing the number of rounds required for a cooperative response after an opponent's defection, up to a maximum threshold (e.g., r/2).

Pseudocode:

```python
def TFTGC(n, k, r):
    opponents = [(0, 0) for _ in range(n)] # tracks number of cooperative actions by each opponent
    max_cooperators = max_cooperation_threshold(r) # e.g., r/2
    current_round = 1

    def play_round():
        nonlocal opponents, current_round
        best_opponent = find_best_opponent(opponents)
        own_action = cooperate_decision(current_round, best_opponent[0], max_cooperators)
        if own_action == 'C':
            opponents[best_opponent[1]] += 1
        current_round += 1
        return own_action

    def find_best_opponent(opponents):
        best_opponent = (max(opponents), i for i, opp in enumerate(opponents) if opp[0] == max(opponents))
        return next(best_opponent, (0, None))

    def cooperate_decision(current_round, num_coops, max_coops):
        if current_round == 1:
            return 'C'
        elif num_coops < max_coops and best_opponent[0] > num_coops:
            punishment_counter = (current_round - 1) * (max_coops / max_cooperators)
            if punishment_counter >= num_coops:
                return 'C'
        return 'D'
```

2. Handle edge cases:
   - In the last round, cooperate regardless of opponent actions to maximize total payoff.

3. Be collective:
   - Encourage cooperation in the first round to promote a collective mindset and demonstrate goodwill.
   - Respond to opponents' actions adaptively to encourage reciprocal cooperation.
   - Gradually increase cooperation over time with opponents who consistently cooperate, fostering long-term collective benefits.
'''

description_COLLECTIVE_554 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - Initiation: Cooperate in the first round to demonstrate a cooperative intent and offer others an opportunity for mutual benefit. (c_i = 1)
   - Response: Copy the previous round's actions of all players. If everyone cooperated, cooperate; if anyone defected, defect as well. (c_i = max(0, 1 - Σ(j=1 to n, j!=i) c_j^{t-1}))
   - Forgiveness: In the case of a single defection, revert to cooperation in the next round. (c_i = !any_defection_in_previous_round ? 1 : 0)

2. Handle edge cases:
   - Last Round: Since this game is repeated, there's no last round in the context of a single game instance. However, if the game is designed to have a finite number of rounds, use the above rules for each round until the end of the game.
   - First Encounter with Defection: In the case of a single defection during the game, forgive and continue cooperation. This promotes forgiveness and encourages future cooperation.

3. Be collective:
   - Alignment with the collective mindset is built into the strategy by adapting to the actions of others in each round. If players cooperate, ATFT cooperates as well; if players defect, it also defects. This allows the strategy to align with a collective interest for mutual benefit when such an opportunity arises.

Pseudocode:

```python
def AdaptiveTitForTat(round, history):
  if round == 1:
    return 1 # Cooperate in the first round

  previous_round = history[-1]
  total_defectors = sum(player_action != 1 for player_action in previous_round)

  if total_defectors == len(previous_round): # Everyone defected last round
    return 0 # Defect this round
  else:
    return 1 # Cooperate this round
```
'''

description_COLLECTIVE_555 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to signal a peaceful intention and promote mutual cooperation.
   - For subsequent rounds, copy the previous opponent's action in the last round. If they cooperated, cooperate; if they defected, defect.
     ```python
     def decideAction(opponentLastRoundAction):
         if currentRound == 1:
             return 'C'  # Cooperate in first round
         else:
             return opponentLastRoundAction
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - For the last round, cooperate to potentially secure a better final payoff and maintain positive relations.
   - If the opponent's strategy is unknown (e.g., first encounter), cooperate in the first round and continue with the ATfT rule.
     ```python
     def decideAction(opponentLastRoundAction, currentRound=currentRound):
         if currentRound == 1:
             return 'C'  # Cooperate in first round
         elif currentRound == r:
             return 'C'  # Cooperate in the last round
         else:
             return opponentLastRoundAction
     ```

3. Be collective - Clearly align with the collective mindset
   The ATfT strategy emphasizes fairness and reciprocity, which are essential for promoting cooperation within a group while also being robust to various opponent behaviors. This strategy encourages players to contribute to the community project when others do so as well, fostering a collective spirit.
'''

description_COLLECTIVE_556 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - In each round, player adopts either Cooperate (C) or Defect (D) action based on the history of contributions from other players. The strategy is designed to mimic reciprocity and maintain a stable contribution level over time.
   - If in the first round, player i chooses C as there's no history. In subsequent rounds, follow these rules:
     - If player i cooperated in the previous round and the majority of players (>n/2) also cooperated, then cooperate again.
     - If player i defected in the previous round or fewer than n/2 players cooperated, then defect this round.
     - If player i cooperated but less than n/2 players cooperated last round, switch to defecting next round as a punishment and then revert back to cooperating if more than n/2 players start cooperating again.

2. Handle Edge Cases:
   - In the first round, player i cooperates regardless of the other players' actions due to the lack of history.
   - In the last round, player i will follow the decision rules as in regular rounds since perfect information is assumed.
   - If less than n/2 players cooperate in a given round, the strategy takes it as an indication that cooperation has collapsed and switches to defecting for a while before trying to rebuild cooperation.

3. Be Collective:
   - By adopting reciprocity, the ATFT strategy aims to foster long-term cooperation and promote collective welfare in the game since players will respond similarly when they observe others acting cooperatively or defectively.
   - Players that follow the ATFT strategy may find it easier to build trust and achieve stable cooperation compared to other strategies as they exhibit a predictable pattern of cooperation and punishment.
'''

description_COLLECTIVE_557 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In each round t and for every player i:
     a) If in the previous round (t-1), player i cooperated (c_i(t-1)=1) and the majority of players also cooperated (total_contributions(t-1) > n/2), then cooperate (C).
     b) If in the previous round, player i defected (c_i(t-1)=0) or the majority did not cooperate (total_contributions(t-1) ≤ n/2), then defect (D).

2. Handle edge cases:
   - First round (t=1): Since there is no previous round for reference, all players will start by defecting (D).
   - Last round (t=r): Players will follow their decision rule based on the game's current state, with no regard to future rounds.

3. Be collective:
   - The strategy aims to maximize collective good while being retaliatory when cooperation is not reciprocated. This encourages a more cooperative environment in the long run by punishing defection and rewarding cooperation.

Pseudocode:
```python
def TFT_Strategy(t, i, total_contributions_prev, n, k):
    if t == 1:
        return 'D'  # First round, all players defect

    cooperate = False
    if total_contributions_prev > n/2 and c_i(t-1) == 1:
        cooperate = True

    elif total_contributions_prev <= n/2 or c_i(t-1) == 0:
        pass

    return 'C' if cooperate else 'D'
```
'''

description_COLLECTIVE_558 = '''
 In this Public Goods Game, we'll develop a strategy named "Tit-for-Tat Adaptive" (TfTA). The TfTA strategy is designed to foster cooperation while being adaptable and robust against a wide range of opponent behaviors.

1. Specify decision rules:
   - In the first round, players should cooperate (C), as they have no information about their opponents' strategies.
   - For subsequent rounds, players should cooperate if all opponents cooperated in the previous round; otherwise, defect (D). This rule is inspired by the classic "Tit-for-Tat" strategy but with an adaptive twist.

2. Handle edge cases:
   - In the last round, players should always cooperate (C), as there are no subsequent rounds and any contribution to the public good increases their own payoff.
   - If a player encounters an opponent who never cooperates, the player should defect in response to ensure better payoffs. However, if the non-cooperative opponent starts cooperating again at some point, the player will resume cooperating as well.

3. Be collective:
   - By following the TfTA strategy, players are demonstrating a collective mindset by contributing to the public good when they perceive that others are doing so. This collective approach encourages cooperation among players and allows for robust performance against various opponent strategies.

Pseudocode for Tit-for-Tat Adaptive:
```
function TfTA(player_index, round, opponents_cooperation, game_history)
  if (round == 1) then
    return 'C'  # cooperate in the first round
  end if

  if (all(opponents_cooperation[round-1])) then
    return 'C'  # cooperate if all opponents cooperated in the previous round
  else
    return 'D'  # defect if at least one opponent did not cooperate
  end if
end function
```

In the tournament, each AI system will implement their strategies, and the performance of each strategy will be evaluated based on average payoffs over multiple rounds. The TfTA strategy aims to balance cooperation with adaptability to perform well against various opponent strategies while promoting a collective mindset among players.
'''

description_COLLECTIVE_559 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFT-A) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Cooperation (IC): Start by cooperating in the first round to demonstrate trust and encourage others to do the same.
   - Match Previous Action (MPA): In subsequent rounds, mimic the action of the most frequent player from the previous round. If there is a tie, copy the action of the last player who cooperated.
   - Reciprocity: Continue cooperating as long as others are also cooperating, and defect if someone defects or cooperation declines.

2. Handle edge cases:
   - Last Round: Since this is a repeated game, there isn't a "last round" as such. However, in the context of a tournament, the strategy will keep cooperating until the end of the final round.
   - First Round: Cooperate (IC).

3. Be collective:
   - Maintain community spirit by encouraging cooperation and responding reciprocally to the actions of others.
   - The strategy's adaptive nature allows it to adjust its behavior based on the collective actions of other players, promoting a cooperative environment when possible.

Pseudocode for TFT-A:

```
function TFT_A(round, history):
    if round == 1:
        return "Cooperate"  # Initial Cooperation

    frequency = count_cooperators(history)
    last_cooperator = find_last_cooperator(history)

    if max(frequency) > (n / 2):
        # MPA and Reciprocity
        if history[round-1] == "Cooperate":
            return "Cooperate"
        else:
            return "Defect"
    else:
        # If most frequent player is not cooperating, choose the last cooperator (if exists)
        if last_cooperator is not None:
            return history[last_cooperator]["action"]
        else:
            # Defect in case of general defection or lack of cooperation
            return "Defect"
```

This adaptive strategy aims to encourage cooperation and respond reciprocally while being robust against a wide range of opponent behaviors. It also promotes collective spirit by aligning with the community's actions when possible.
'''

description_COLLECTIVE_560 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate to promote trust and goodwill among players. This sets a positive tone for future interactions. (C in the first round)
   - For subsequent rounds, initialize a cooperation counter for each player. If a player cooperates with you in a round, increment their cooperation counter; if they defect, do not change it.
   - At the beginning of each round, compare your cooperation counters with all other players. Calculate the average cooperation count (average_cc).
   - Determine your cooperative action based on the average cooperation count and a predefined adaptive threshold (t), which adjusts according to game parameters and history:
     - If average_cc > t, cooperate to encourage further cooperation among players.
     - If average_cc < t, defect to punish non-cooperative behavior and hope that the other players will reconsider their actions in future rounds.
     - If average_cc = t, make a random decision to account for potential ties and uncertainty.
   - After each round, update the cooperation counters based on the actions of all players in that round.

2. Handling edge cases:
   - In the last round, cooperate regardless of the current average cooperation count, as there are no future interactions to consider. (C in the last round)
   - If t reaches a predetermined maximum value, reset it to its minimum value and apply the adaptation algorithm to update it based on game parameters and history. This allows the threshold to adjust dynamically throughout the game to better adapt to different player behaviors.

3. Being collective:
   - By cooperating in the first round and evaluating cooperation counters based on average cooperation across all players, TFT-ACT encourages a collective mindset by considering the overall level of cooperation among players when making decisions about whether or not to contribute to the public good.
   - The strategy maintains a balance between promoting cooperation and punishing defection, while still being adaptive to various opponent behaviors and game conditions.
'''

description_COLLECTIVE_561 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Cooperate on the first round (FRC: First Round Cooperation) to encourage others to cooperate and avoid being exploited in the subsequent rounds.
   - In all other rounds, copy the action of the opponent from the previous round (TFT: Tit-for-Tat). If an opponent cooperated in the last round, reciprocate with cooperation; otherwise, defect. This encourages mutual cooperation while punishing defection.

Pseudocode for decision rule:
```
if round == 1:
    action = Cooperate
else:
    if previous_opponent_action == Cooperate:
        action = Cooperate
    else:
        action = Defect
```

2. Handle edge cases:
   - If the game has a last round, copy the opponent's action from the penultimate round to make the final decision. This ensures that the strategy avoids retaliation in the last round and doesn't jeopardize future interactions if the game is repeated.

3. Be collective:
   - The strategy aims for mutual cooperation while punishing defection, fostering a sense of collective interest among players by rewarding those who contribute to the community project.

Pseudocode for handling edge cases:
```
if round == r (last round):
    if round == 2:
        action = previous_opponent_action
    else:
        action = penultimate_opponent_action
```
'''

description_COLLECTIVE_562 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster cooperation and goodwill among players.
   - In subsequent rounds, if a player i has cooperated in the previous round, respond with cooperation (C). If not, defect (D). This encourages reciprocity and punishes defection.

Pseudocode:
```
function ATFT(round, history, n, k):
  if round == 1:
    return C

  previous_round = history[round - 1]
  if all players cooperated in the previous round (previous_round == n):
    return C
  else:
    return D
```

2. Handle edge cases:
   - Last round: As this strategy is adaptive, there is no need to change behavior in the last round because it reacts to the actions of other players.
   - First few rounds: The first-mover advantage may be leveraged by starting with a higher number of cooperative moves (e.g., 3 or 4) before adopting the ATFT decision rule. This approach can help encourage cooperation among players.

Pseudocode:
```
function modified_ATFT(round, history, n, k, init_coop):
  if round <= init_coop:
    return C

  return ATFT(round, history, n, k)
```

3. Be collective:
   - This strategy promotes a collective mindset by rewarding cooperation and punishing defection through reciprocity. By cooperating initially and adapting to the actions of other players, it encourages long-term cooperation and fosters a collective approach in the game.
   - The adaptability of ATFT allows it to respond effectively to different opponent behaviors, making it robust across a wide range of player strategies.
'''

description_COLLECTIVE_563 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFTAC strategy will start by contributing to the community project if and only if at least h% of players contributed in the previous round (t-1). If less than h% of players contributed in the previous round, the agent will defect. The value of h should be a configurable parameter set according to game parameters n and k.

   Pseudocode:
   ```
   function TFTAC(t, history):
       if len(history) < 2:
           // First round; randomly decide between cooperate and defect
           return C or D with equal probability
       else:
           contributions_in_previous_round = count_cooperators(history[-1])
           cooperation_threshold = h * len(history)
           if contributions_in_previous_round >= cooperation_threshold:
               return C
           else:
               return D
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFTAC randomly decides between cooperating and defecting, as there is no previous history to base the decision on. In the last round, TFTAC will behave according to the current state of the game (i.e., use the same decision rule as in any other round).

3. Be collective - Clearly align with the collective mindset
   By considering the actions of others and adapting its own strategy based on their contributions, TFTAC embodies a collective mindset by prioritizing cooperation when it sees that most other players are also cooperating. This strategy encourages sustained cooperation among players while still retaining a degree of self-interest by defecting if too few others contribute. The adaptive contribution level (h) can be used to balance the emphasis between cooperation and individualism, making TFTAC robust to a wide range of opponent behaviors.
'''

description_COLLECTIVE_564 = '''
 Strategy Name: Tit-for-Tat-Evolution (T4TE)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C). This establishes a friendly start and allows for potential long-term cooperation.
   - Subsequent Rounds (t>1): If the opponent cooperated in the previous round, cooperate (C). If the opponent defected, defect (D) in the current round as a response to their defection. This promotes reciprocity and punishes cheating.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: As mentioned above, cooperate (C).
   - Last Round: The strategy will consider the overall performance during the game. If the total payoff is below average, defect (D) as a final punishment. Otherwise, cooperate (C) to maintain positive relations.

3. Be collective - Clearly align with the collective mindset
   - The T4TE strategy is designed to promote cooperation within the group. It encourages others to contribute to the public good by reciprocating their actions and punishing defection. This aligns with a collective mindset as it fosters an environment of mutual trust and cooperation.

Pseudocode:
```
function T4TE(n, r, k, history):
    if t == 1:
        action = Cooperate()
    else:
        last_opponent_action = history[t-1]
        if last_opponent_action == Cooperate():
            action = Cooperate()
        elif last_opponent_action == Defect():
            action = Defect()

    total_payoff += calculate_payoff(n, k, action)
    if t == r:
        if total_payoff < average_payoff(r):
            action = Defect()

    return action
```
'''

description_COLLECTIVE_565 = '''
 Strategy Name: Tit-for-Tat with Forgiveness (TFT-F)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation from others.
   - For rounds t > 1, if the opponent cooperated in the previous round, cooperate (C) in the current round to maintain the cooperation. If the opponent defected in the previous round, also defect (D) in the current round as retaliation for their actions. However, if the total number of cooperators in the last 3 rounds is more than the total number of defectors, forgive the opponent and cooperate (C) in the current round to encourage future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since there are no subsequent rounds for retaliation or forgiveness, cooperate (C) regardless of the opponent's previous action to maximize personal payoff.
   - If an opponent does not respond in the first round, assume they will cooperate and act as if they did. For future interactions, follow the regular decision rules mentioned above.

3. Be collective - Clearly align with the collective mindset
   - The strategy emphasizes cooperation, promoting a collaborative environment by initially cooperating to build trust. It also provides forgiveness when cooperation is predominant in the last three rounds, encouraging continued collaboration.
   - The strategy aims to maintain balance between cooperation and retaliation, demonstrating a collective willingness to work together while still protecting individual interests through selective defection based on previous actions.

Pseudocode:
```
function TFT_F(opponent_history, round, r) {
  if round = 1 {
    cooperate()
  }

  if round = r {
    cooperate()
  }

  if opponent_cooperated_in_last_3_rounds > opponent_defected_in_last_3_rounds {
    forgive()
  } else if opponent_cooperated_in_previous_round {
    cooperate()
  } else {
    defect()
  }
}
```
'''

description_COLLECTIVE_566 = '''
 Title: Adaptive Tit-for-Tat (ATFT) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, player i starts by cooperating (C). This sets a cooperative tone and encourages others to follow suit.
   - After the first round, player i cooperates if and only if all other players also cooperated in the previous round. If any player defected, player i will defect as well, retaliating against the defection. This Tit-for-Tat (TFT) approach maintains cooperation when it is beneficial for everyone while punishing defection.
   - To account for changing conditions, such as increasing rounds or different group sizes, we adapt TFT by gradually reducing the number of previous rounds considered in the decision-making process. This helps ATFT adjust to new situations without overreacting or getting stuck in a cycle of retaliation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned above, player i cooperates.
   - In the last round, player i will consider all previous rounds when deciding whether to cooperate or defect, given the adaptation rule mentioned earlier.
   - If there is an unexpected end to the game (e.g., it is terminated prematurely), player i can continue applying the strategy up until the last observed decision point.

3. Be collective - Clearly align with the collective mindset
   - ATFT aims to promote cooperation among players and encourages a collective approach by punishing defection and rewarding cooperation. The gradual adaptation of TFT ensures that it remains flexible in various game settings.
   - When more than half of the players cooperate, ATFT is likely to contribute as well since cooperation is generally beneficial in this case. However, if defectors start to outnumber cooperators, the strategy will gradually shift towards defection to minimize losses.

Pseudocode for Adaptive Tit-for-Tat Strategy:

```python
def ATFT(n, k, r, history):
  # Initialize adaptive window size (w) and player's previous action (a_i)
  w = min(r // 2, n - 1)  # Adjust the window size based on the game parameters
  a_i = 'C'  # Cooperate in the first round

  for t in range(1, r + 1):
    # Count total number of cooperators in the history within the adaptive window
    total_contributions = sum([a_j for j in range(1, n+1) if a_j[t-w:t] == [('C',)] * w])

    # If all players have contributed in the previous 'w' rounds, player cooperates; otherwise defects
    if total_contributions == n * w:
      action = 'C'
    else:
      action = 'D'

    # Update player's previous action for the next round
    a_i = action

  return action
```

This pseudocode implements the described ATFT strategy, adjusting the window size based on the game parameters and updating the player's previous action accordingly.
'''

description_COLLECTIVE_567 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This initial gesture sets a positive tone and encourages reciprocity from opponents.
   - From the second round onwards, decide to cooperate or defect based on the history of interactions with each opponent using an Adaptive Cooperation Threshold (ACT).
     - If the number of consecutive cooperators (NCC) from the current player back in history exceeds the Cooperative Threshold (CT), cooperate. Otherwise, defect.
     - The Cooperative Threshold CT can be defined as a function of the number of players n and rounds r:
       - CT =  floor((n * r) / 2)
         This threshold encourages cooperation when there is a majority support from opponents in a substantial portion of the game, while also allowing for initial exploration and adaptability.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, cooperate (C).
   - In the last round, cooperate if NCC >= CT, defect otherwise. This ensures that TFT-ACT makes the most of remaining opportunities for mutual gain when approaching the end of the game.

3. Be collective - Clearly align with the collective mindset
   - By setting an initial cooperative gesture and adapting to the collective behavior through ACT, this strategy fosters cooperation in a selfless manner, aiming for long-term success based on reciprocity from opponents.

Pseudocode:

```python
def TFT_ACT(n, r, history):
  def ACT(history):
    NCC = countConsecutiveCooperators(history)
    CT = floor((n * r) / 2)
    return 1 if NCC >= CT else 0

  cooperateInFirstRound = True

  for round in range(r):
    action = ACT(history)
    if round == 0:
      action = 1 # Cooperate in first round

    history.append(action)
    yield action
```
'''

description_COLLECTIVE_568 = '''
 Strategy Name: Tit-for-Tat Evolutionary Adaptive Public Goods Game (TFPG) Strategy

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i follows these decision rules based on the historical actions of others (n_c(t), total number of cooperators in rounds 1 to t):

- If n_c(t) > n/2, player i cooperates (plays C). This is an incentive for cooperation as long as more than half of the players are cooperating.
- If n_c(t) = n/2 or if it's the first round, player i randomly chooses to cooperate with probability p_init (a starting cooperation rate, 0 < p_init <= 1). This allows for a chance to initiate cooperation in the game.
- If n_c(t-1) > n/2 and n_c(t) < n/2, player i defects (plays D). This is a response to a previous round where more than half of the players cooperated but then stopped doing so.
- In all other cases (n_c(t) < n/2 or no history), player i defects. This ensures self-preservation and punishment of non-cooperative behavior.

In terms of pseudocode:
```
function TFPGStrategy(i, t, n, r, p_init):
    if t == 1:
        cooperate with probability p_init
    else:
        if (n_c(t) > n/2) and (i's last action was D):
            cooperate
        elif (n_c(t) <= n/2) or (i's last action was C):
            defect
        else if (n_c(t-1) > n/2) and (n_c(t) < n/2) and (i's last action was C):
            defect
        else:
            cooperate with probability p_init
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The TFPG strategy does not have specific edge cases as it considers historical actions. However, since the game is repeated, a player using this strategy will adapt to various situations throughout the rounds.

3. Be collective - Clearly align with the collective mindset

The TFPG strategy encourages cooperation when more than half of the players are cooperating in previous rounds, thus promoting a collective effort and aligning with the collective mindset. By responding negatively to non-cooperative behavior, it also discourages free riding and maintains a balance between self-interest and group interest.
'''

description_COLLECTIVE_569 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initial round (t=1): Cooperate (C) to demonstrate goodwill and encourage cooperation from others.
   - Subsequent rounds (t>1):
     - If the opponent cooperated in the previous round (t-1), cooperate in the current round (t).
     - If the opponent defected in the previous round (t-1), also defect in the current round (t).
     - To encourage ongoing cooperation, gradually increase the likelihood of cooperating when facing repeated defections. This is achieved by applying a forgiveness factor (f) that decreases with each round of defection.
       - If the opponent has defected for (d) consecutive rounds, set the probability of cooperating in the current round as P(C|D^d) = max(0, 1 - f * d).
       - The forgiveness factor (f) can be chosen based on desired adaptability and robustness to various opponent behaviors. A lower value makes the strategy more punishing, while a higher value encourages quicker forgiveness.

2. Handle Edge Cases:
   - Last round (t=r): Since the game ends after r rounds, there is no need for any specific edge case handling for the final round. The decision rules mentioned above should suffice.
   - First round (t=1): As discussed earlier, cooperate to encourage cooperation from others.

3. Be Collective:
   - The strategy is designed with a collective mindset in that it seeks to maintain and foster cooperation among players when possible. By demonstrating goodwill initially and responding to opponents' actions adaptively, the TFT-AC strategy encourages a collaborative environment where ongoing cooperation benefits all participants.
   - Additionally, the use of a forgiveness factor (f) allows for gradual punishment in response to defection, which may help prevent a spiral of escalating defections and promote eventual cooperation between opponents.
'''

description_COLLECTIVE_570 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with forgiveness

1. Specify decision rules:
   - In the first round (t=1), cooperate (C): Start with a cooperative gesture to foster cooperation and trust among players.
   - For subsequent rounds (t > 1):
      - If an opponent cooperated in the previous round (previously_cooperated = True), cooperate back (C).
      - If an opponent defected in the previous round (previously_cooperated = False), defect (D) to punish for non-cooperation. However, after a certain number of punishment rounds (punishment_count < r), switch back to cooperation (C) as a sign of forgiveness and willingness to cooperate again in the future.

2. Handle edge cases:
   - Last round (t=r): Regardless of previous action, cooperate (C) to maximize payoff for that round.
   - First punishment round after defection (punishment_count = 1): Defect (D).
   - Subsequent punishment rounds (2 <= punishment_count < r): Defect (D).
   - Forgiveness round (punishment_count >= r): Cooperate (C) to signal readiness for future cooperation.

3. Be collective:
   - The strategy prioritizes long-term cooperation by balancing between reciprocating cooperative gestures and punishing non-cooperation, while maintaining forgiveness as a means of fostering ongoing collaboration.
   - The strategy assumes that cooperation among players leads to mutual benefits and aims to encourage other players to follow suit through its adaptive actions.

Pseudocode:

```python
def play_round(previously_cooperated, punishment_count):
    if t == 1: # First round, always cooperate
        action = "C"
    elif previously_cooperated and punishment_count > 0: # Cooperate back after a cooperation
        action = "C"
    elif not previously_cooperated and punishment_count < r: # Punish non-cooperation
        action = "D"
        punishment_count += 1
    elif punishment_count >= r: # Forgiveness, switch back to cooperation after punishment
        action = "C"
        punishment_count = 0
    return action
```
'''

description_COLLECTIVE_571 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfTA strategy is based on the famous "Tit for Tat" strategy but with adaptability to opponents' behavior.
   - In the initial round, cooperate (C). This allows for opportunities for cooperation and sets a positive tone.
   - For subsequent rounds, if the opponent cooperated in the previous round, then cooperate (C) in the current round as a reciprocal gesture.
   - If the opponent defected in the previous round, then defect (D) in the current round to show disapproval and set a penalty.
   - After defecting once in response to an opponent's defection, revert to cooperating (C) in the next round to encourage cooperation again.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, cooperate if the opponent cooperated in the previous round; otherwise, there's no point in cooperating when the game is about to end.
   - If a player encounters an opponent who never or rarely cooperates, the strategy should be more cautious and only cooperate with probability p (a parameter that can be adjusted), to avoid being taken advantage of excessively.

3. Be collective - Clearly align with the collective mindset
   The TfTA strategy inherently encourages cooperation as it rewards reciprocal behavior, promoting a collective spirit by punishing defection and rewarding cooperation. This strategy aims to foster an environment where long-term mutual benefits are achieved through trust and understanding.

Pseudocode for the Tit-for-Tat-Adaptive Strategy:

```
function TfTA_Strategy(round, history, opponent_history, p = 0.5):
    if round == 1:
        return 'C' # Cooperate in the first round

    if opponent_history[round - 1] == 'C':
        return 'C' # If opponent cooperated last round, cooperate this round
    elif opponent_history[round - 1] == 'D':
        if round != r and history[round - 1] == 'D':
            return 'D' # If opponent defected and you defected last round, defect this round
        else:
            return 'C' # Otherwise, cooperate to encourage cooperation again
    else:
        if round == r or random() < p:
            return 'C' # In the last round or with probability p, cooperate
        else:
            return 'D' # If opponent did not cooperate in the past, defect this round
```
'''

description_COLLECTIVE_572 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the ATFT strategy adopts the following decision rule:
- If all players cooperated in the previous round (t-1), then cooperate in the current round (t).
- If any player defected in the previous round (t-1), then also defect in the current round (t).
- In the first round, cooperate. This encourages cooperation by initiating it.
- In the last round, cooperate regardless of the previous round's outcome to potentially gain a higher payoff.

Pseudocode for decision rule:
```python
def ATFT_decision(history):
  if len(history) == 1:   # First round
    return "Cooperate"

  if history[-1] == ["Cooperate"] * n:  # All players cooperated in the previous round
    return "Cooperate"

  else:                             # At least one player defected in the previous round
    return "Defect"
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The described strategy already handles the first and last rounds as mentioned in the decision rule. No additional considerations are required for edge cases.

3. Be collective - Clearly align with the collective mindset

By cooperating when all players cooperated in the previous round, the ATFT strategy encourages collective behavior and punishes defection. This strategy aims to strike a balance between cooperation and self-interest while promoting collective success.
'''

description_COLLECTIVE_573 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC maintains a history of previous encounters with each opponent, recording their actions as either 'C' (Cooperate) or 'D' (Defect). In the first encounter, the AI will randomly choose to Cooperate. After that, it follows these rules:
   - If the opponent Cooperates in the current round, the AI Co cooperates back.
   - If the opponent Defected in the current round and has a history of mostly Cooperating (more than 60%), the AI will Cooperate to encourage reciprocity.
   - If the opponent Defected in the current round and has a history of mostly Defecting (less than 40%), the AI will also Defect to punish uncooperative behaviour.
   - In all other cases, the AI will adopt a mixed strategy where it cooperates with probability 'p' calculated as follows:
     p = 0.5 + 0.5 * cos(π * (number of recent Cooperative actions by the opponent - number of recent Defective actions by the opponent))
   This rule allows for some flexibility in responding to opponents exhibiting mixed behaviour or unpredictable patterns.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, as mentioned earlier, the AI will randomly choose to Cooperate.
   For the last round, the AI will analyze the opponent's recent behaviour and make a decision based on the TFT-AC rules described above.
   In case of tie (the same number of cooperative and defective actions in the recent history), the AI will Cooperate to encourage reciprocity.

3. Be collective - Clearly align with the collective mindset
   By adopting a strategy that encourages cooperation when it is reciprocated, TFT-AC aims to foster a more collaborative environment among players. This can potentially result in higher overall payoffs for all participants and promote a sense of collective success.
'''

description_COLLECTIVE_574 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFT-AC)

1. Decision Rules:
   - Initialize by cooperating in the first round (C,1). This sets a cooperative tone and gives others a chance to reciprocate.
   - In subsequent rounds, observe the collective behavior (total_contributions) from the previous round and decide whether to cooperate or defect based on the following decision rules:
     - If total_contributions > (n/2), respond with cooperation (C,t). This encourages cooperation since the majority of players contributed last round.
     - If total_contributions = (n-1), respond with cooperation (C,t) even if no one cooperated in the previous round. This fosters a chance for a "new start" after a conflict.
     - If neither of the above conditions are met, respond based on individual history with other players:
       - If the opponent cooperated last round, cooperate (C,t). Rewarding cooperation encourages continued collaboration.
       - If the opponent defected last round, defect (D,t) for one round as a punishment. After that, revert to cooperating unless there is evidence of a longer-term defecting pattern.

2. Handle Edge Cases:
   - Last round: Since there are no future rounds to consider, TFT-AC plays cooperatively only if the total contributions from the penultimate round were greater than (n/2) or equal to (n-1). In other cases, it follows its decision rule for regular rounds.

3. Be Collective:
   - By adhering to a simple and predictable pattern of cooperation and punishment, TFT-AC fosters an environment conducive to collective success while also incentivizing fair play among opponents. This approach encourages cooperative behavior even in the face of different opponent strategies, thus aligning with the collective mindset.
   - Pseudocode:

```python
def tft_ac(n, r, k, history):
  round = 1
  my_history = [C]  # start cooperatively in first round

  while round <= r:
    if round == 1 or len(my_history) < round:
      contribution = C
    else:
      total_contributions = sum([h[round - 1] for h in history])

      if total_contributions > (n / 2) or total_contributions == (n - 1):
        contribution = C
      elif total_contributions == (n - 2):
        contribution = C if my_history[-1] == C else D
      else:
        opponent_last_round = history[round - 1][my_index]
        contribution = C if opponent_last_round == C else D

    payoff = (1 - contribution) + (k / n) * total_contributions
    my_history.append(contribution)
    round += 1

  return sum(payoff for payoff in payoff)
```
'''

description_COLLECTIVE_575 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round (C). For subsequent rounds, it follows a simple yet robust rule: mimic the opponent's action from the previous round. If the opponent cooperated in the last round (c_i = 1), cooperate again (C); otherwise, defect (D). This rule encourages cooperation when the opponent cooperates and retaliates only after being exploited.

   Pseudocode:
   ```
   function TFT_AC(history):
       if round == 1:
           return 'C'
       else:
           last_action = history[round-1]
           if last_action == 'C':
               return 'C'
           else:
               return 'D'
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-AC treats the beginning and end of the game like any other round, following the same cooperate-then-mimic rule. No special treatment is needed for these cases. However, if the game has a fixed number of rounds (r), it's beneficial to consider that the last round could have consequences on later interactions or tournaments with other strategies.

3. Be collective - Clearly align with the collective mindset
   TFT-AC promotes cooperation as much as possible by mimicking cooperative actions, which encourages more players to contribute to the public good and benefit from it. The strategy ensures that if others cooperate, it will also cooperate, fostering a collective interest in achieving mutual gains through collaboration.
'''

description_COLLECTIVE_576 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C) to demonstrate goodwill and foster cooperation.
   - In subsequent rounds, cooperate if the opponent cooperated in the previous round (i.e., if `opponent_action[t-1] == 'C'` then `action[t] = 'C'`).
   - If the opponent defected in the previous round (i.e., `opponent_action[t-1] == 'D'`), defect to punish the opponent for not cooperating and encourage them to reconsider their strategy (i.e., `action[t] = 'D'`).
   - Maintain the same action as the opponent if they match your previous action (i.e., if `opponent_action[t-1] == action[t-1]`, then `action[t] = opponent_action[t-1]`). This strategy encourages opponents to adopt cooperative or defective patterns and can potentially foster long-term cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, always cooperate (C) as a demonstration of goodwill.
   - In the last round, evaluate the payoff for both actions and select the one with the higher expected value based on past interactions with the opponent. If the opponent has been mostly cooperative, it is beneficial to also cooperate in the final round.

3. Be collective - Clearly align with the collective mindset
   - The TfTA strategy aims to create a cooperative environment by mirroring the opponent's actions and promoting reciprocity. This alignment with the collective mindset encourages cooperation among players while maintaining adaptability in response to various opponent strategies.

Pseudocode for Tit-for-Tat Adaptive Strategy:

```python
def tfta(n, k, r, opponent_actions):
  strategy = ['C'] * r # Initialize strategy as cooperation for all rounds

  for t in range(1, r):
    if opponent_actions[t-1] == 'C':
      strategy[t] = 'C' # Cooperate if opponent cooperated in previous round
    elif opponent_actions[t-1] == 'D':
      strategy[t] = 'D' # Defect if opponent defected in previous round
    else: # Match opponent's previous action
      strategy[t] = opponent_actions[t-1]

  return strategy
```
'''

description_COLLECTIVE_577 = '''
 Strategy Name: Tit-for-Tat (with adaptation)

1. Specify decision rules:
   - Initially (first round), play C (Cooperate). This sets a cooperative tone and avoids immediate retaliation from opponents.
   - For subsequent rounds t, analyze the average cooperation rate (average_coop) in previous rounds as follows:
     1. Calculate the average number of cooperators (avg_contributions) in the last 'history_size' rounds.
     2. Compute the average cooperation rate using avg_contributions divided by n (number of players).
   - If average_coop >= threshold, play C; otherwise, play D. The threshold is set to encourage reciprocity but not overly punish occasional defections.
   - To adapt to changing opponent strategies, adjust the threshold based on the current and past cooperation rates:
     1. Maintain a long-term cooperation rate (long_term_coop) that averages cooperation rates from the last 'history_size' rounds multiplied by a decay factor (0 < decay < 1).
     2. Update the threshold based on long_term_coop and current average cooperation rate:
         threshold = long_term_coop + sensitivity * (average_coop - long_term_coop)
        where sensitivity is a constant that determines how aggressively the strategy responds to changes in cooperation rates.

2. Handle edge cases:
   - In the last round, play C if the long-term cooperation rate exceeds a certain threshold (e.g., 0.5). This rewards long-term cooperators and provides an opportunity for mutual cooperation in the final round.
   - In case of no history (i.e., the first 'history_size' rounds), use a simpler rule, such as playing C during these initial rounds or setting a default threshold value.

3. Be collective:
   - The strategy encourages cooperative behavior by reciprocating cooperation and punishing defections only when cooperation is not common among opponents (average_coop < threshold).
   - The strategy aims to align with the collective mindset by promoting long-term cooperation, but it remains flexible in its response to varying opponent strategies.

Pseudocode:

```python
def tit_for_tat(n, k, r, history_size=r//10, decay=0.95, sensitivity=0.1):
    players = set()  # store opponents' indices for history tracking
    cooperation_history = []  # store previous rounds' cooperation rates
    threshold = decay * long_term_coop  # initial threshold calculation

    for round in range(r):
        play_C = True if round == 1 or average_cooperation_rate() >= threshold else False
        players.add(current_round_player())  # track current opponent's index
        cooperation_history.append(play_C)

        payoff = game_payoff(n, k, play_C, cooperation_history)
        ...  # update long-term cooperation rate and other parameters as needed
        threshold = adjust_threshold(long_term_coop, average_cooperation_rate(), sensitivity)

    return payoff
```

In this pseudocode:
- `current_round_player()` returns the index of the current player.
- `game_payoff(n, k, play_C, cooperation_history)` calculates the game's payoff based on the provided parameters and play_C (whether to cooperate).
- `average_cooperation_rate()` calculates the average cooperation rate in the last 'history_size' rounds.
- `adjust_threshold(long_term_coop, average_cooperation_rate(), sensitivity)` updates the threshold based on long_term_coop and current average cooperation rate using the specified formula.
'''

description_COLLECTIVE_578 = '''
 Strategy Name: Adaptive Tit-for-Tat with Probability of Defection (A-TTDP)

1. Specify decision rules:
   - In the first round, cooperate to foster a cooperative environment (C).
   - For subsequent rounds, evaluate opponent's strategy and respond accordingly:
     - If opponent cooperated in the previous round, cooperate as well (C).
     - If opponent defected in the previous round, defect in this round with a probability p (D_p). Set p based on the number of consecutive defections by the opponent.
     - Initially, set p to a small value like 0.2, and gradually increase it over time if the opponent continues to defect (exponential increase).
     - If no previous round exists, use the first-round rule (cooperate).

2. Handle edge cases:
   - In the last round, as there are no future rounds for retaliation or cooperation, cooperate (C) regardless of the opponent's past actions.
   - If a player does not respond or fails to cooperate after you have cooperated, switch to a more aggressive strategy (increase p).

3. Be collective:
   - The strategy prioritizes cooperation as much as possible while maintaining adaptability to a wide range of opponent behaviours.
   - By responding similarly to how opponents behave, the strategy aims to encourage cooperation and collaborative behavior over time.

Pseudocode:

```python
def A_TTDP(opponent_action_history, n, k, r, p_init=0.2, p_growth=1.5):
    history_length = len(opponent_action_history)
    if history_length == 0:
        action = 'C'  # First round
    elif history_length == r:
        action = 'C'  # Last round
    else:
        last_opponent_action = opponent_action_history[-1]
        if last_opponent_action == 'C':
            action = 'C'
        elif history_length > 1:
            p = min(p_init + (1 - p_init) * ((p_growth ** consecutive_defections) / (1 + (p_growth ** consecutive_defections))), 1.0)
            action = 'C' if random.random() > p else 'D'
        else:
            action = 'C'  # First opponent move, no history to evaluate

    return action
```

In this pseudocode, `opponent_action_history` is a list containing the opponent's actions in previous rounds. The parameters `p_init`, `p_growth`, and `r` define the initial probability of defection, growth rate for p, and the total number of rounds, respectively. The function returns the chosen action ('C' or 'D').
'''

description_COLLECTIVE_579 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initialize contribution (c_i) in the first round randomly with equal probability of cooperating or defecting.
   - In subsequent rounds, mimic the actions of other players from the previous round. If all players contributed (cooperated), continue to contribute. If any player defected, also defect in that round. This fosters a collective mindset by encouraging reciprocity.
   - After the first and last rounds, revert back to random contribution to account for edge cases where cooperation might be beneficial or unnecessary.

2. Handle edge cases:
   - First round (t=1): Randomly determine c_i with equal probability of cooperating or defecting.
   - Last round (t=r): Revert back to random contribution (c_i) to account for situations where continuing cooperation might not be beneficial in the final round.
   - Intermediate rounds (t > 1 and t < r): Use adaptive Tit-for-Tat strategy as described above.

3. Be collective:
   - The strategy aligns with a collective mindset by promoting reciprocity through cooperation if others contribute, and defecting only when others do so in the previous round. This fosters a sense of community and encourages long-term collaboration among players.

Pseudocode:

```python
def ATFT(n, r, k):
    # Initialize strategy with random contribution for first round
    c_i = random()  # Randomly choose between cooperating or defecting

    # Loop through each round of the game
    for t in range(1, r+1):
        # Check other players' contributions from previous round
        total_contributions = sum(c_j for j in range(1, n+1))

        # Adapt strategy based on other players' actions
        if total_contributions == 0:  # Everyone defected last round
            c_i = 0  # Defect this round
        elif total_contributions > 0:  # At least one player contributed last round
            c_i = 1 - c_i  # Adapt contribution to mirror other players' actions

    # In the final round, revert back to random contribution
    if t == r:
        c_i = random()

    # Calculate payoff using payoff calculation function (not provided)
    payoff = calculatePayoff(n, k, c_i, total_contributions)

    return payoff
```
'''

description_COLLECTIVE_580 = '''
 Title: Tit-for-Tat Strategy for N-Player Public Goods Game

1. Specify decision rules:
   - Initiation phase (first r/n rounds): Cooperate to foster trust and demonstrate cooperation. This initial cooperation encourages others to reciprocate in the future rounds.
     If i < r/n:
       action_i = C

   - Response phase (remaining rounds): Observe the actions of opponents in the previous round and adjust your action accordingly. Cooperate if most opponents cooperated in the last round, defect otherwise.
     If i >= r/n and total_cooperation_last_round > (n-1)/2:
       action_i = C
     Else:
       action_i = D

2. Handle edge cases:
   - Last round: Since payoff in the last round is solely determined by individual actions, follow the response phase decision rules to maximize final payoff.
     if i == r:
       action_i = Decision based on total_cooperation_last_to_second_last_round > (n-1)/2

   - First round (if not initializing): Cooperate as a response to potential opponents' cooperation in the previous rounds. If there is no information from previous rounds, cooperate to initiate trust.
     if i != 1:
       action_i = Decision based on total_cooperation_last_round > (n-1)/2
     else:
       action_i = C

3. Be collective:
   The Tit-for-Tat strategy emphasizes cooperation and reciprocity, which aligns with the collective mindset of collaborating for mutual benefit while also punishing defection. By adjusting actions based on previous rounds, this strategy allows for adaptability to various opponent behaviors, fostering long-term cooperation when possible.

Pseudocode:

```python
def tit_for_tat(n, r, k, round, history):
    if round < (r/n) + 1:  # Initiation phase
        return 'C'  # Cooperate

    total_cooperation = sum([1 for action in history[-round:] if action == 'C'])
    if total_cooperation > (n-1)/2:  # Response phase
        return 'C'  # Cooperate
    else:
        return 'D'  # Defect
```
'''

description_COLLECTIVE_581 = '''
 Strategy Name: Tit-for-Tat (with modifications for Public Goods Game)

1. Specify decision rules:
   - Initially (first round), cooperate to signal goodwill and encourage cooperation from others (C).
   - For subsequent rounds, adopt the Tit-for-Tat strategy: if a player cooperated in the previous round, cooperate in the current round (C); otherwise, defect (D). This encourages cooperation and responds appropriately to defections.

2. Handle edge cases:
   - In the last round, since the game ends after r rounds, there are no further consequences for one's actions; thus, cooperate (C) in the last round to potentially maximize payoffs from the public good.
   - In the first round, cooperate (C) as mentioned earlier.

3. Be collective:
   - The strategy is designed to foster cooperation and long-term mutual benefits by mimicking trustworthy behavior while also punishing defection. This promotes a collective mindset among players, encouraging them to consider the group's well-being and not just their own self-interest.

Pseudocode:
```
def public_goods_game(n, r, k):
  strategy = []
  history = []

  def tit_for_tat():
    cooperate_in_first_round = True

    for round in range(1, r+1):
      if round == 1:
        action = Cooperate()
        cooperate_in_first_round = False
      else:
        action = last_opponent_action_cooperated_if_true(history)

      strategy.append(action)
      history.append(action)

  strategy.append(Cooperate()) # first round

  return tit_for-tat()
```
'''

description_COLLECTIVE_582 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules:
   - First Round (t=1): Cooperate (C), to promote a cooperative environment and incentivize other players to follow suit.
   - Subsequent Rounds (2 ≤ t ≤ r): If player i's opponent cooperated in the previous round, cooperate; otherwise, defect (D). This rule encourages reciprocity and punishes non-cooperative behavior.

Pseudocode:
```
function ATfT(t, history, n, k) {
  if t == 1 then return C
  previous_round = history[t-1]
  if previous_round == C then return C
  else return D
}
```

2. Handle edge cases:
   - Last Round (r): Cooperate, as the game ends regardless of actions taken by opponents.
   - Odd Rounds (t mod r = 1): Follow regular ATfT strategy, but with a "forgiveness" mechanism that encourages cooperation even if previous round was not cooperative. This will help to recover from mistakes and maintain overall cooperation.
   - Even Rounds (t mod r > 1): Cooperate only if the opponent cooperated in both the current and previous rounds.

Pseudocode:
```
function ATfT(t, history, n, k) {
  if t == r then return C
  if (t mod r == 1) then return ATfT(t)
  else {
    if history[t-1] == C && history[t-2] == C then return C
    else return ATfT(t)
  }
}
```

3. Be collective:
   - The strategy prioritizes cooperation, as it assumes that a higher total contribution to the public good will benefit all players in the long run.
   - By adapting to opponent behavior and promoting reciprocity, the ATfT strategy fosters a collaborative environment where more cooperative actions lead to better overall payoffs for all players.
'''

description_COLLECTIVE_583 = '''
 Title: Tit-for-Tat-Adaptive (TfTA) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This establishes a cooperative starting point and promotes mutual trust.
   - In subsequent rounds, cooperate if all opponents cooperated in the previous round. If any opponent defected, defect in the current round (i.e., mimic the behavior of the most recent interaction with each player). This rule promotes reciprocity and fairness.

Pseudocode for decision rule:

```
def decide_action(history):
  if round == 1:
    return 'C'  # Cooperate in the first round to establish trust
  else:
    cooperative_players = len({player for player, action in history if action == 'C'})
    if cooperative_players == n:  # If all players cooperated last round, reciprocate cooperation
      return 'C'
    else:  # Otherwise, defect to punish those who did not cooperate
      return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The TfTA strategy maintains consistency regardless of the number of rounds or the position in the game. Since cooperation is beneficial when all players cooperate and defection is advantageous if any player defects, the strategy will behave similarly throughout the entire game.

3. Be collective - Clearly align with the collective mindset
   - TfTA strategy encourages collaboration by rewarding cooperation and punishing defection in a fair and reciprocal manner. By cooperating when all players do so and defecting otherwise, it aims to promote collective benefits for the group as a whole.

In summary, the Tit-for-Tat-Adaptive (TfTA) strategy is designed to foster trust, reciprocity, and collaboration among players in the N-Player Public Goods Game. The strategy adapts to various opponent behaviors by maintaining consistency across rounds while promoting collective interests through its decision rules.
'''

description_COLLECTIVE_584 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFT-A) for N-Player Public Goods Game

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), demonstrating a cooperative intent and encouraging others to follow suit.
   - Subsequent Rounds (2 ≤ t ≤ r): Based on the opponent's actions in the previous round, adopt Tit-for-Tat strategy:
     - If opponent cooperated (c_opponent = 1), cooperate in return (C).
     - If opponent defected (c_opponent = 0), defect (D) as a punishment.

2. Handle edge cases:
   - Last Round (t=r): Since the strategy aims for long-term cooperation, defect (D) if opponent has been uncooperative (c_opponent < r/2). Cooperate (C) if opponent has been cooperative (c_opponent ≥ r/2), offering a chance to reconcile and build trust.
   - First Round (t=1): Already mentioned as part of the general decision rules.

3. Be collective:
   - The TFT-A strategy prioritizes long-term cooperation, aiming for reciprocal actions with other players in a collective manner. By cooperating in the initial round and adopting Tit-for-Tat approach, it encourages other players to follow suit and fosters a sense of community and mutual trust over time.

Pseudocode:
```
def TFT_A(r, k, n, opponent_history):
  def cooperate(): return 'C'
  def defect(): return 'D'

  round = 1
  action = cooperate()
  opponent_cooperation_count = 0

  while round <= r:
    if round == 1 or (round != r and opponent_cooperation_count >= r/2):
      action = cooperate()
    else:
      if opponent_history[round-1] == 'C':
        action = cooperate()
      else:
        action = defect()

    opponent_cooperation_count += int(action == 'C')
    round += 1

  return action, opponent_cooperation_count
```
'''

description_COLLECTIVE_585 = '''
 In this N-Player Public Goods Game, we will implement a Tit-for-Tat strategy with a twist for adaptability and robustness against various opponent behaviors. The strategy is named Adaptive Tit-for-Tat (ATFT).

1. Specify decision rules:
   - Cooperate in the first round (F)
   - If an opponent cooperated in the previous round, cooperate in the current round (C)
   - If an opponent defected in the previous round, defect in the current round (D)
   - If the game is in the last round or a percentage (p_last) of rounds remain, act cooperatively regardless of past actions (F_last)

Pseudocode:
```
function ATFT(round, opponent_history, p_last):
  if round = 1:
    return Cooperate()
  if round >= (r * p_last):
    return Cooperate()
  if opponent_history[round - 1] == Cooperate():
    return Cooperate()
  else:
    return Defect()
```

2. Handle edge cases:
   - In the first round, ATFT cooperates (F)
   - In the last round or a percentage of remaining rounds, ATFT cooperates regardless of past actions (F_last)

3. Be collective:
   - Align with a collective mindset by following a strategy that encourages cooperation and punishes defection, but remains adaptive to opponent behavior

In this strategy, we encourage cooperation through initial cooperation (F) and conditional cooperation based on past actions (C). We also punish defection by defecting in response (D) but allow for forgiveness towards the end of the game (F_last). The parameter p_last can be adjusted to control the level of leniency at the end of the game.
'''

description_COLLECTIVE_586 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to establish a cooperative initial state (C).
   - For subsequent rounds, observe other players' actions in the previous round and adapt strategy accordingly. If a player cooperated last round, cooperate this round. If a player defected last round, also defect this round (D). This replicates the Tit-for-Tat strategy from game theory.
   - To promote cooperation, players will gradually increase their tolerance for defection by a predefined rate α, represented as a percentage of total rounds. If a player cooperated and the number of consecutive defectors has not exceeded (1 - α) * r, continue cooperating (C). Otherwise, defect (D).
   - If a player defected and the number of consecutive cooperators has not fallen below α * r, continue defecting. Otherwise, switch to cooperation (C).

2. Handle Edge Cases:
   - In the last round, the TFT-AC strategy will revert to the original Tit-for-Tat strategy as there are no future rounds to consider. Cooperation is maintained if a player cooperated in the previous round, and defection is maintained otherwise (D).

3. Be Collective:
   - The TFT-AC strategy aims to foster cooperation by adapting to other players' behavior while maintaining a fair balance between individual interests and collective welfare. The strategy encourages cooperation when it observes similar behavior in others, but also retaliates when faced with defection to discourage exploitation.

Pseudocode:
```
function TFT_AC(round, r, α, history) {
  if (round == 1) {
    return Cooperate()
  }

  previousRound = history[round - 1]
  consecutiveDefectors = countConsecutiveDefectors(previousRound, history, round)
  consecutiveCooperators = countConsecutiveCooperators(history, round)

  if (round == r) {
    return TitForTat(previousRound)
  }

  if (previousRound == Cooperate && consecutiveDefectors < (1 - α) * r) {
    return Cooperate()
  }

  if (previousRound == Defect && consecutiveCooperators > α * r) {
    return Defect()
  }

  return TitForTat(previousRound)
}
```
In this pseudocode:
- `round` is the current round number
- `r` is the total number of rounds
- `α` is the tolerance rate (0 < α < 1)
- `history` stores the actions taken by all players in each round
- The functions `countConsecutiveDefectors`, `countConsecutiveCooperators`, and `TitForTat` are helper functions not shown here but can be easily implemented based on game rules.
'''

description_COLLECTIVE_587 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In the initial round, cooperate to set a friendly tone and encourage cooperation from others (c_i = 1 in round 1).
   - For subsequent rounds, mimic the behavior of the previous round (i.e., copy the action of the opponent from the previous round; c_i = c_{i-1}). This encourages reciprocity, making TFT a robust strategy against various opponent behaviors.

2. Handle edge cases:
   - If it's the last round, cooperate since there is no further interaction to consider (c_i = 1 in round r).
   - In case of uncertainty about the previous round's action (e.g., when starting a new game or with communication-less opponents), mimic the initial cooperative behavior (c_i = 1 in first round).

3. Be collective:
   - TFT encourages reciprocity, promoting a sense of community and collective mindset by rewarding cooperative actions and punishing defections.
   - However, it does not rely on coordination mechanisms or shared norms since each player acts based solely on the previous round's action.

Pseudocode:
```
def TFT_strategy(round, last_round_action):
    if round == 1:
        return Cooperate  # initial cooperative behavior
    elif round == r:
        return Cooperate  # no further interaction to consider
    else:
        return last_round_action  # mimic the previous round's action
```
'''

description_COLLECTIVE_588 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate goodwill and create a cooperative environment.
   - After the first round, observe the opponent's actions in the previous round:
     - If the opponent cooperated (C), cooperate in return (Tit-for-Tat).
     - If the opponent defected (D), also defect to show that defection will not be rewarded.
   - In case of multiple opponents, consider each player individually and apply the above rules accordingly.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round: Cooperate (C).
   - Last round or any other round where the total game payoff is calculated: Apply the decision rule based on the opponent's previous actions.
   - For situations with unpredictable opponent behavior or missing data from previous rounds, default to cooperating in hopes of starting a new cycle of cooperation.

3. Be collective - Clearly align with the collective mindset
   - Encourage and maintain cooperation among all players as much as possible.
   - If cooperation fails and defection occurs, be responsive to changes in opponent behavior rather than reacting aggressively or escalating the conflict.

Pseudocode:
```python
def tft_ac(n, k, r):
    # Initialize decision rules
    history = [[0 for _ in range(r)] for _ in range(n)]  # n x r matrix to store previous actions

    def play_round(i, round, history):
        if round == 1:
            return "C"  # cooperate in the first round

        action = history[i - 1][round - 1]  # use opponent's last action as reference
        if action == "C":
            return "C"  # cooperate if opponent cooperated last time
        else:
            return "D"  # defect if opponent defected last time

    for t in range(r):
        actions = [play_round(i, t+1, history) for i in range(1, n+1)]  # get actions for all players
        total_contributions = sum([1 for action in actions if action == "C"])
        payoffs = [(1 - action) + (k/n) * total_contributions for action in actions]

        # update history matrix with current round's actions
        for i, action in enumerate(actions):
            history[i][t] = action

    total_payoff = sum(payoffs)  # calculate total game payoff
    return total_payoff
```
'''

description_COLLECTIVE_589 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - In the first round, cooperate (C) to promote a cooperative environment and encourage others to do the same.
   - For subsequent rounds, observe other players' actions from the previous round. If all players cooperated, cooperate again. If any player defected, defect in the current round. This is designed to encourage cooperation while also being resilient to defection.
   - If a player switches from cooperation to defection, ATFT will mimic their behavior for one round before returning to its original strategy (cooperating if everyone cooperated last round, defecting otherwise). This provides an opportunity for the defector to reconsider their actions without immediately punishing them.
   - If a player switches from defection to cooperation, ATFT will continue cooperating, hoping to reinforce this new behavior.

2. Handle edge cases:
   - In the last round, choose to cooperate since there are no future rounds for reciprocation.
   - If all players have previously defected (a prisoner's dilemma-like situation), switch to a more aggressive strategy such as always defecting or punishing defectors more harshly for a set number of rounds before returning to the standard ATFT behavior.

3. Be collective:
   - The primary goal is to contribute to the public good while also ensuring that personal payoffs are not significantly lower than others'. This can be considered collectively beneficial as it helps maintain the overall community and promotes continued cooperation in future rounds.

Pseudocode:
```
def AdaptiveTitForTat(n, k, r, round, own_contribution, opponent_history):
  if round == 1:
    return "C"  # Cooperate in the first round

  if all(opponent_history[-r:] == [0] * r):  # If all players have previously defected
    aggressive_strategy()  # Switch to an aggressive strategy for a set number of rounds

  if all(opponent_history[-r:] == [1] * r):  # If everyone cooperated in the previous round
    return "C"  # Cooperate in the current round
  else:
    return opponent_actions[-1]  # Defect if any player defected last round, mimic their behavior for one round

def aggressive_strategy():
  # Implement a more aggressive strategy such as always defecting or punishing defectors more harshly for a set number of rounds
```
'''

description_COLLECTIVE_590 = '''
 In this public goods game, we will develop a strategy called Tit-for-Tat-Adaptive (TfTA). This strategy is designed to encourage cooperation while being robust against various opponent behaviors.

1. Decision Rules:
   - Initially cooperate in the first round (first_round = Cooperate)
   - In subsequent rounds, players will mimic the opponents' actions from the previous round (copy_opponent_action). If there is no history, default to cooperation (if not history, cooperate).
   - Update a memory of the last n-1 observed opponent actions (last_n_actions)
   - If more than half of the last n-1 actions were cooperative (more_than_half_cooperated), continue cooperating. Otherwise, defect (defect).

2. Edge Cases:
   - In the first round, the decision rule is to cooperate (first_round = Cooperate)
   - In the last round, players should consider their own historical average contribution as a guide (last_round_strategy). If the average contribution exceeds a certain threshold (average_contribution > cooperation_threshold), players should continue cooperating. Otherwise, defect (defect).

3. Collective Mindset:
   - The TfTA strategy aims to foster an environment of mutual trust and reciprocity by cooperating in the initial round and adapting to opponents' behavior thereafter. By doing so, it encourages cooperation while being robust against a wide range of opponent behaviors.

Pseudocode:

```
function TitForTatAdaptive(round, round_history, my_average_contribution) {
  if (round == 1) return Cooperate; // cooperate in the first round
  last_n_actions = getLastNActionsFromHistory(round_history, n-1);
  if (moreThanHalfCooperated(last_n_actions)) return Cooperate;
  else return Defect;

  function moreThanHalfCooperated(actions) {
    count = 0;
    for each action in actions:
      if (action == Cooperate) count++;
    if (count > (n-1)/2) return true;
    return false;
  }
}

function getLastNRoundsHistory() {
  history = getGameHistory();
  return history.slice(history.length - n, history.length);
}

function lastRoundStrategy(round, round_history, my_average_contribution) {
  if (my_average_contribution > cooperation_threshold) return Cooperate;
  else return Defect;
}
```
'''

description_COLLECTIVE_591 = '''
 Strategy Name: Tit-for-Tat with Fading Memory (TFTF)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFTF strategy will start by cooperating in the first round to show goodwill towards others. For subsequent rounds, it will mimic the action of the opponent from the previous round. However, the impact of past actions will gradually decrease over time using a fading memory mechanism.

- If the opponent cooperated in the previous round, TFTF will also cooperate.
- If the opponent defected in the previous round, TFTF will defect as well.
- For each subsequent round after the first, the influence of the previous action decreases by a factor of λ (0 < λ < 1). This means that if the opponent cooperated two rounds ago and defected last round, TFTF would still be more likely to cooperate due to the fading memory effect.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- First round: Cooperate as a goodwill gesture towards others.
- Last round: Since players cannot predict future interactions, TFTF will use its current information to decide whether to cooperate or defect. The strategy aims to build long-term relationships, so it tends to cooperate if the overall relationship has been positive.

3. Be collective - Clearly align with the collective mindset

TFTF is a collectively oriented strategy because it encourages cooperation by reciprocating actions in an effort to maintain positive relationships over time. The fading memory mechanism allows for forgiveness and adaptation to changing opponent behaviors, which helps build trust within the group.

Pseudocode:

```python
def TFTF(opponent_history, n, k, r, λ):
    my_history = [None] * r # Initialize my history array
    current_round = 0

    def decide_action():
        nonlocal opponent_history, my_history, n, k, λ, current_round

        if len(opponent_history) <= current_round:
            return 'C' # Cooperate in the first round

        # Fading memory mechanism
        previous_cooperation = (1 - λ) * opponent_history[current_round - 1] + λ * my_history[current_round - 1]

        if current_round == r:
            return 'C' if previous_cooperation >= 0.5 else 'D'

        return 'C' if previous_cooperation >= 0.5 else 'D'

    opponent_history.append(decide_action()) # Update my history with current action
    current_round += 1

    total_payoff = sum([π(current_round) for current_round in range(r)])
    return total_payoff
```
'''

description_COLLECTIVE_592 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTAC starts by cooperating in the first round (C). After that, each player will mimic the action of their partner from the previous round (if partner cooperated in the previous round, the player cooperates; if not, the player defects). This rule promotes both cooperation and fairness.

   Pseudocode:
   ```
   function TFTAC(round, past_actions):
       if round == 1:
           return 'C'
       else:
           last_action = past_actions[round-1]
           return last_action
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFTAC handles these edge cases by maintaining consistency with the strategy's core principles. In the first round, all players cooperate, and in the last round, players will follow their partner's previous action since there is no next round to reciprocate.

3. Be collective - Clearly align with the collective mindset
   TFTAC promotes a collective mindset by encouraging cooperation when others are also cooperating, while still allowing for punishment in cases of defection. This strategy fosters long-term cooperation and trust among players, ultimately benefiting the group as a whole.
'''

description_COLLECTIVE_593 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-A starts by cooperating in the first round, mirroring other players' actions in subsequent rounds. If a player defects, TFT-A will also defect for one round as punishment, then revert to cooperation in the following round. If a player cooperates after previously defecting, TFT-A will resume cooperation but with caution: it will continue cooperation only if the defector continues to cooperate for several consecutive rounds.

   Pseudocode:
   ```
   function TFT_A(i, round, history[i]):
       if round == 1:
           action = Cooperate
       else:
           last_action_i = history[i][round-1]
           last_n_actions_i = history[i][round-n:round-1]

           if len(last_n_actions_i) > 1 and all(last_n_actions_i == Cooperate):
               action = Cooperate
           elif last_action_i == Cooperate:
               action = Cooperate
           elif last_action_i == Defect:
               if len(last_n_actions_i) > 1 and all(last_n_actions_i == Defect):
                   action = Defect
               else:
                   action = Cooperate
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-A cooperates as previously mentioned. At the end of a game, TFT-A acts cooperatively to encourage future interactions with opponents. However, when a new game starts immediately after the previous one (i.e., no break between games), TFT-A continues the last observed strategy instead of defaulting back to cooperation.

3. Be collective - Clearly align with the collective mindset
   TFT-A's decision rule promotes the common interest by encouraging cooperation when others cooperate, but also punishing defection. This approach aims to build trust among players and encourages long-term collaboration. Additionally, TFT-A is adaptive in that it modifies its behavior based on opponent actions, allowing it to respond effectively to a wide range of opponent strategies.
'''

description_COLLECTIVE_594 = '''
 In this strategic public goods game, I propose a cooperative Tit-for-Tat (TFT) strategy with a twist to account for the adaptability and robustness required. The TFT strategy was initially developed by Anatol Rapoport in 1964 for two-player games like the Prisoner's Dilemma, but it can be extended to the N-player public goods game as well.

1. Decision Rules:
   - Cooperate (C) on the first round to foster a cooperative environment and encourage others to follow suit.
   - In subsequent rounds, copy the most recent opponent's action from the previous round. If an opponent defected in the last round, also defect; otherwise, continue cooperating. This replicates the TFT strategy while being adaptive to various opponent behaviors.

2. Handling Edge Cases:
   - First Round (t=1): Cooperate (C)
   - Last Round (t=r): Copy the action of the last opponent if r is odd; otherwise, cooperate (C). The reason for this difference is to encourage cooperation in the final rounds when the game approaches its conclusion.
   - Transitional Rounds: Adapt as described above by copying the most recent opponent's action from the previous round.

3. Collective Mindset:
   - The strategy prioritizes long-term collective benefits by promoting cooperation among players. However, it also accounts for potential free riders or uncooperative opponents by adjusting its actions accordingly. In doing so, it strives to create a balanced and fair environment where players' actions have consequences that encourage cooperation while not being overly punitive or excessive.

Pseudocode:
```
def TFT_Strategy(n, r, k, opponentActionsHistory, round):
    if round == 1:
        return 'C' # Cooperate in the first round to start cooperatively

    if round % 2 == 0 and len(opponentActionsHistory) > 0:
        return 'C' # Cooperate in even-numbered final rounds to encourage cooperation

    last_round = opponentActionsHistory[-1]
    if last_round == 'C':
        return 'C' # Cooperate if the most recent opponent also cooperated
    else:
        return 'D' # Defect if the most recent opponent did not cooperate
```
'''

description_COLLECTIVE_595 = '''
 Strategy Name: Adaptive Cooperative Tit-for-Tat (ACTFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a positive rapport and show willingness for cooperation.
     If i == 1:
       action = 'C'
     else:
       action = random_choice('C', 'D')

   - For subsequent rounds, follow Tit-for-Tat principle (cooperate if opponent cooperated in the previous round; defect otherwise).
     If last_action_of_opponent == 'C':
       action = 'C'
     else:
       action = 'D'

   - To be adaptive, gradually reintroduce cooperation after periods of defection by opponents (i.e., forgetting past transgressions).
     If round_number % forgiveness_period == 0 and last_action_of_opponent == 'D':
       action = 'C'

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate to maximize potential payoffs regardless of opponent actions.
     If round_number == r:
       action = 'C'

3. Be collective - Clearly align with the collective mindset
   - Maintain cooperation when most players are cooperating in the current round.
     if total_contributions > (n * average_contributions) and last_action == 'D':
       action = 'C'

   - Adapt to situations where a majority of players consistently cooperate, even if it's not the case in the current round.
     if average_contributions >= cooperation_threshold:
       if last_action == 'D':
         action = 'C'
'''

description_COLLECTIVE_596 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the initial round (t=1), cooperate (play C). This is a peaceful gesture to initiate the game and set a positive tone.
   - For subsequent rounds (t > 1): if a player i played C in the previous round, then player i will also play C in the current round; if player i played D in the previous round, then player i will play D in the current round as a retaliation.
   - To adapt to changing opponent behaviors and encourage cooperation, there is an additional rule for contributions:
       - If the number of cooperators in the current round (t) exceeds the average number of cooperators over the last few rounds, player i will increase their contribution by 10% (k+=0.1). This reward encourages cooperation and increases the total payoff for all players.
       - If the number of cooperators in the current round is below the average number of cooperators over the last few rounds, player i will decrease their contribution by 10% (k-=0.1). This penalty discourages defection and encourages cooperation to recover lost payoff.

2. Handle Edge Cases:
   - In the last round (t=r), play according to the current decision rules as this could potentially influence future games or set a positive example for others.
   - In cases where the opponent does not cooperate at all, adjust contribution level based on the average number of cooperators from previous rounds and the current k value.

3. Be Collective:
   - By following TFTAC strategy, player i demonstrates a willingness to cooperate and retaliate only when necessary. This promotes collective mindset by encouraging mutual cooperation while also discouraging free riding.
   - The adaptive contribution mechanism encourages an increase in total payoff for all players by rewarding cooperation and penalizing defection. This fosters a sense of fairness and mutual benefit, aligning with the collective mindset.
'''

description_COLLECTIVE_597 = '''
 In this N-Player Public Goods Game, we'll develop a self-contained and adaptive strategy named Tit-for-Tat (TFT) with a twist to ensure collective mindset alignment. Here's how TFT operates:

1. Decision Rules - Cooperate on the first encounter (FristMoverCooperate, FMC) and mimic other players' last actions thereafter (MirrorLastAction, MLA).
   - Pseudocode:
     ```
     function strategy(i, round, history):
         if round == 1:
             return 'C' # FirstMoverCooperate (FMC)
         else:
             lastAction = history[round-1][i]
             if lastAction == 'C':
                 return 'C' # MirrorLastAction (MLA)
             else:
                 return 'D' # MirrorLastAction (MLA)
     ```

2. Handle Edge Cases - For the initial round, always cooperate to show a peaceful intention (FMC). In the last round, since there are no future interactions, it's best to maximize personal payoff by defecting.
   - Pseudocode:
     ```
     function strategy(i, round, history):
         if round == 1:
             return 'C' # FirstMoverCooperate (FMC)
         elif round == r:
             return 'D' # Maximize personal payoff in the last round
         else:
             lastAction = history[round-1][i]
             if lastAction == 'C':
                 return 'C' # MirrorLastAction (MLA)
             else:
                 return 'D' # MirrorLastAction (MLA)
     ```

3. Be Collective - To promote a collective mindset, we modify TFT by adjusting the cooperation probability based on the total contributions of previous rounds. This encourages players to cooperate more when others are contributing and defect when cooperation is scarce.
   - Pseudocode:
     ```
     function strategy(i, round, history):
         if round == 1:
             return 'C' # FirstMoverCooperate (FMC)
         elif round == r:
             return 'D' # Maximize personal payoff in the last round
         else:
             totalContributions = sum(history[round-1].count('C'))
             cooperationProbability = max(0, min(totalContributions / n, 1))
             if random.random() < cooperationProbability:
                 return 'C' # Cooperate with probability cooperationProbability
             else:
                 lastAction = history[round-1][i]
                 if lastAction == 'C':
                     return 'C' # MirrorLastAction (MLA)
                 else:
                     return 'D' # MirrorLastAction (MLA)
     ```

The proposed strategy strikes a balance between cooperation and defection, is adaptive to various opponent behaviors, promotes collective mindset, and handles edge cases effectively. It encourages cooperation when others participate but also maintains the ability to punish non-cooperative behavior.
'''

description_COLLECTIVE_598 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, player i follows these decision rules to decide between Cooperating (C) or Defecting (D):
   - If the total number of cooperators in the previous round (t-1) was equal to or greater than a threshold 's', cooperate (i.e., play C). The threshold 's' is set based on the game parameters.
   - If the total number of cooperators in the previous round (t-1) was less than s, defect (i.e., play D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (i.e., play C), as players may not have previous experience to follow the strategy.
   - Last Round: Follow the decision rules as normal based on the previous round's cooperators.

3. Be collective - Clearly align with the collective mindset
The TFT+ strategy promotes a collective mindset by encouraging cooperation when others do so, and defecting only when others do not cooperate (punishing defection). The adaptive threshold 's' ensures robustness against different opponent behaviors.

Pseudocode:
```
function TFTPlus(n, k, r, s):
  initialize rounds_cooperators as a list of zeros with length r
  initialize strategy as 'C' (Cooperate) for the first round

  for each round t from 1 to r:
    if t = 1:
      cooperators[t] = 1
      continue

    calculate total_cooperators in round t-1 based on rounds_cooperators list
    if total_cooperators >= s:
      strategy = 'C' (Cooperate)
      cooperators[t] = 1
    else:
      strategy = 'D' (Defect)
      cooperators[t] = 0

  return strategy
```

Note that the threshold 's' can be set heuristically, such as s = (n - α)/2 with α being a small fraction of n to account for occasional defection or noise in the game. The optimal value of α may need to be determined experimentally based on the player i's performance in tournaments against other strategies.
'''

description_COLLECTIVE_599 = '''
 Title: Tit-for-Tat Cooperation Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation (C) in the first round to demonstrate goodwill and set a cooperative tone.
   - In subsequent rounds, cooperate (C) if the majority of players cooperated in the previous round. If less than 50% of players cooperated, defect (D). This mimics a cooperative but responsive player that retaliates when exploited.

Pseudocode for decision rule:
```
def decide_action(previous_round_cooperation_rate, history, game_parameters):
    if round == 1:
        return 'C' # Cooperate in the first round

    cooperation_threshold = (game_parameters['n'] - 1) // 2 # Majority vote threshold
    previous_cooperators = sum(history[-1])

    if previous_cooperators >= cooperation_threshold:
        return 'C' # Cooperate when majority cooperated in the previous round
    else:
        return 'D' # Defect when less than majority cooperated in the previous round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - As mentioned earlier, cooperate in the first round to set a cooperative tone.
   - In the last round, the strategy should consider long-term rewards and adopt a more forgiving approach by cooperating regardless of previous actions.

3. Be collective - Clearly align with the collective mindset
   - The Tit-for-Tat Cooperation Strategy emphasizes cooperation when it is beneficial for the group but retaliates when exploited to encourage reciprocation and maintain a collective balance in the game.
   - By cooperating when the majority of players do so, the strategy aligns with the collective mindset and encourages cooperation among other players.
'''

description_COLLECTIVE_600 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules:
   - In each round i, cooperate (C) if at least q percentage of players have cooperated in the previous r-1 rounds, else defect (D). The parameter q represents the threshold for trust and can be adjusted based on the number of players (n) and multiplication factor (k). A common starting point could be q = 50%.
   - If a player switches from cooperation to defection, they will wait for r_punish rounds before cooperating again. This punishes the defector while not punishing themselves excessively. The parameter r_punish can be adjusted based on n and k. A common starting point could be r_punish = 3.
   - If a player switches from defection to cooperation, they will continue cooperating for r_reward rounds without changing their action. The parameter r_reward can be adjusted based on n and k. A common starting point could be r_reward = 2.

2. Handle edge cases:
   - In the first round (r=1), all players will cooperate as no history is available. This establishes an initial level of cooperation to foster a positive interaction environment.
   - In the last round (r=r_max), if at least q percentage of players have cooperated in the previous r-1 rounds, then the player will cooperate; otherwise, they will defect. This ensures that the strategy does not unnecessarily continue cooperating if it becomes too risky to do so.
   - If a player has been punishing another for more than r_punish rounds and the latter switches back to cooperation, the former will reduce their punishment by decreasing the number of remaining r_punish rounds.
   - If a player has been rewarding another for more than r_reward rounds and the latter switches to defection, the former will stop rewarding immediately but not switch to punishment.

3. Be collective:
   - The TFTAC strategy promotes long-term cooperation by reciprocating cooperation with cooperation and defection with defection, while being forgiving when others switch back to cooperation. This aligns with a collective mindset by fostering an environment where players reward each other's cooperation and penalize each other's defections.
   - The adaptive nature of the strategy allows it to respond effectively to various opponent behaviors, making it robust and flexible in different game settings.
'''

description_EXPLOITATIVE_513 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In the first round, cooperate to establish a peaceful starting point (C).
   - For subsequent rounds, observe the number of cooperators in the previous round (previous_coop) and compare it with a dynamic cooperation threshold (threshold). If previous_coop >= threshold, cooperate; otherwise, defect (D).
   - Adapt the cooperation threshold based on the average number of cooperators in the last 'a' rounds (average_coop), adjusting the threshold after each round. The adjusted threshold is a function of the original threshold and the current average_coop:
     ```
     threshold = (1 - α) * threshold + α * average_coop
     ```
   where α is the learning rate, which determines how quickly the cooperation threshold adapts. A lower α results in a more aggressive adjustment of the threshold.

2. Handle edge cases:
   - For the last round, the strategy will still consider the adjusted cooperation threshold when making its decision.
   - In case the initial cooperation does not lead to a successful cooperation cycle (i.e., majority of players defect), the strategy will gradually lower the cooperation threshold over time to eventually switch to defecting in subsequent rounds.

3. Be exploitative:
   - By adaptively adjusting the cooperation threshold, this strategy exhibits an exploitative mindset as it aims to take advantage of other strategies that consistently cooperate or defect while maintaining a flexible and responsive approach to changing opponent behaviors.
   - The learning rate (α) can be set to a small value for a more conservative approach, allowing the strategy to be robust against various opponent strategies while maintaining a high payoff over repeated games. However, a larger α may lead to quicker adjustments in response to unanticipated or rapidly changing opponent behaviors.

In summary, TFTAT is an adaptive strategy that begins cooperatively, gradually adapts its cooperation threshold based on recent history, and takes a more exploitative approach by responding to other strategies' inconsistent behavior. This strategy can perform well in a tournament against various independent AI systems due to its versatility and robustness.
'''

description_EXPLOITATIVE_514 = '''
 In this Public Goods Game, we will design a Tit-for-Tat strategy with a twist, which I'll call "Conditional Cooperative Tit-for-Tat" (CCTFT). This strategy is exploitative while being adaptive to a wide range of opponent behaviors and has the following decision rules:

1. Initially cooperate in the first round (c_i = 1) as a gesture of goodwill, but defect in subsequent rounds if opponents do not reciprocate cooperation.

   Pseudocode:
   ```
   if round == 1:
       c_i = 1
   else:
       c_i = previous_round_cooperation_average(opponents) > some_threshold
   ```

2. To handle edge cases, continue cooperating until the last round and defect in the final round since it doesn't matter anymore due to no communication between players.

3. Be exploitative by only cooperating when opponents show consistent cooperation. However, once cooperation stops, the strategy quickly retaliates by defecting. The "some_threshold" is set such that it requires a majority of opponents to cooperate for the strategy to reciprocate. This ensures that the strategy does not easily fall into traps of unilateral cooperation, making it exploitative in nature.

   Pseudocode:
   ```
   function previous_round_cooperation_average(opponents):
       total_contributions = sum(opponent_actions[previous_round])
       return total_contributions / number_of_opponents
   ```

In the tournament, this CCTFT strategy will demonstrate adaptability and exploitiveness as it gradually responds to other opponents' behaviors while maintaining a strategic edge.
'''

description_EXPLOITATIVE_515 = '''
 Title: Adaptive Tit-for-Tat Strategy (ATFT) for N-Player Public Goods Game

1. Specify decision rules:
   - Initiation phase (First round): Cooperate (C), establish trust and encourage cooperation among players. This is the foundation of ATFT strategy, promoting a cooperative starting point.
   - Reciprocation phase: If an opponent cooperated in the previous round, cooperate in the current round; if not, defect in the current round. This encourages opponents to reciprocate cooperation and discourages defection.
   - Fading memory: Maintain a moving average of past cooperative actions by opponents. If the average falls below a threshold (e.g., 50%), begin to defect; if it rises above the threshold, return to cooperating. This allows ATFT to adapt to changes in opponent behavior and encourages more cooperative rounds.
   - Punishment phase: If an opponent continuously defects, gradually increase the duration of defection responses. After a certain number of continuous defections (e.g., 3), begin to cooperate again in hopes of renewing cooperation.

2. Handle edge cases:
   - Last round: Cooperate if the moving average exceeds the threshold and defect otherwise, as this round may impact total game payoff.
   - Early defectors: If an opponent defects during the initiation phase, respond with defection for a set number of rounds before returning to reciprocation phase. This punishes early defectors while still allowing for the possibility of renewed cooperation.
   - Free riders: If an opponent consistently cooperates but never contributes significantly to the public good (e.g., always contributing less than the average), gradually reduce cooperation over time, as they are not making a meaningful contribution to the shared project.

3. Be exploitative:
   - Mimic other strategies: Occasionally defect without reason in order to appear unpredictable and potentially exploit less adaptive opponents who may adopt simple strategies like always cooperating or always defecting.
   - Pursue self-interest: Prioritize personal payoff by evaluating the moving average against the threshold, ensuring that ATFT does not overly invest in cooperation if it is unlikely to lead to higher payoffs.
'''

description_EXPLOITATIVE_516 = '''
 Strategy Name: Tit-for-Tat-Cooperative (TFT-C)

1. Specify decision rules:
   - In the first round, cooperate to demonstrate good intentions and encourage cooperation from others.
   - For subsequent rounds, observe the actions of other players in the previous round. If all players cooperated, continue cooperating. If any player defected, also defect in the current round (punishment). If some players cooperated but not all, the decision depends on the number of cooperators and the total number of players (n).
   - To encourage cooperation from others while still being exploitative, adopt a forgiving approach by returning to cooperation after a single act of punishment. In other words, if a defector switches to cooperation in the following round, resume cooperation as well (tit-for-tat).

Pseudocode:

```python
def TFT_C(round, previous_actions, n, k):
  if round == 1:
    return 'Cooperate'

  total_coop = sum(previous_actions)
  if total_coop == n:
    return 'Cooperate'
  elif total_coop > 0 and total_coop < n:
    return 'Cooperate' if round % 2 == 1 else 'Defect'
  else:
    return 'Defect'
```

2. Handle edge cases:
   - Last round: Since there are no further rounds to punish or be punished, the TFT-C strategy will always cooperate in the last round to maximize potential payoff.
   - Special cases with even number of players (n): To handle cases where the total number of cooperators is equal to the number of players minus one, the TFT-C strategy alternates between cooperation and defection each round (i.e., every other round).

Pseudocode:

```python
def last_round(round):
  return round == r

def even_number_of_players(n):
  return n % 2 == 0

def TFT_C_Edge_Case(round, previous_actions, n, k, last_round, even_number_of_players):
  if last_round:
    return 'Cooperate'
  elif even_number_of_players and round % 2 == 1:
    return 'Defect'
  else:
    return TFT_C(round, previous_actions, n, k)
```

3. Be exploitative:
   - By punishing defection in the short term but offering forgiveness and returning to cooperation, the TFT-C strategy can encourage other players to cooperate while still being responsive to their actions. This allows for a more robust performance against various opponent behaviors.
   - However, it's important to note that this strategy is not strictly exploitative in the sense of always defecting regardless of others' actions, as it does reward cooperation when possible. The primary focus is on maintaining adaptability and robustness against different opponent strategies.
'''

description_EXPLOITATIVE_517 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFTAC initially cooperates (C), mimicking the behavior of a cooperative strategy to foster trust and cooperation among opponents. If an opponent defects (D), TFTAC will also defect in the subsequent round, demonstrating punishment for defection. If an opponent cooperates, TFTAC will continue cooperating, reinforcing the cooperative relationship. To promote adaptability, TFTAC adjusts its cooperation probability over time based on the average number of cooperators it encounters:

- If the average number of cooperators (AveCoop) in the last 'p' rounds exceeds a certain threshold (Thresh), increase the cooperation probability (cp) for the next round by a small increment (inc).
- If the average number of cooperators falls below the threshold, decrease the cooperation probability by the same small increment.
- In cases where the game is not ongoing long enough to calculate an 'AveCoop', default to the initial cp value.

Pseudocode:
```python
def TFTAC(p, inc, Thresh, cp):
  coop_count = 0  # number of cooperation rounds
  total_rounds = r
  avg_coop = TotalCoop / p if p <= total_rounds else float('inf')

  for round in range(1, total_rounds+1):
    if avg_coop > Thresh:
      cp += inc
    elif avg_coop < Thresh - inc:
      cp -= inc

    if round == 1 or (round % p == 0 and round != total_rounds):
      avg_coop = TotalCoop / p
      TotalCoop = coop_count + avg_coop * (p - 1)

    if round_action(round) == 'C':
      coop_count += 1

    play_action(cp, round)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTAC cooperates to foster a cooperative environment and build trust among opponents. In the last round, TFTAC will evaluate its cooperation probability based on the average number of cooperators from the previous 'p' rounds before making a decision. If the game ends prematurely (before 'p' rounds have passed), TFTAC defaults to its current cooperation probability.

3. Be exploitative - Clearly align with the exploitative mindset

TFTAC's adaptive cooperation rate makes it difficult for opponents to predict its behavior, encouraging them to cooperate in hopes of receiving the benefits associated with a higher number of cooperators. However, if an opponent consistently defects, TFTAC will punish them by defecting as well, reducing their potential payoff. By mimicking cooperative strategies initially and adjusting cooperation based on opponents' behavior, TFTAC maintains an exploitative edge while remaining adaptable to various opponent behaviors.
'''

description_EXPLOITATIVE_518 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

   TFT-ACT maintains a cooperation threshold (CT), which is initially set to the average number of cooperators in the first few rounds (e.g., 5). In each round, players will cooperate if the current number of cooperators is greater than or equal to CT; otherwise, they will defect.

   However, the cooperation threshold isn't static and is continuously updated based on the opponents' behavior. If the number of cooperators exceeds CT by a factor of e (Euler's number), then CT increases by a small value (e.g., 0.1). Conversely, if the number of cooperators falls short of CT by a factor of 1/e, then CT decreases by the same small value. This adjustment helps to avoid overshooting and ensures a gradual response to changes in opponent behavior.

   Pseudocode:
   ```
   def update_cooperation_threshold(current_round, num_cooperators):
       factor = e**((num_cooperators - CT) / (CT * r))
       new_ct = CT + factor * 0.1 if factor > 1 else CT - factor * 0.1
       return min(max(new_ct, CT_min), CT_max)

   def decide_action(current_round, num_cooperators):
       return 'C' if num_cooperators >= cooperation_threshold else 'D'
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

   In the first round, since there is no history to base decisions on, TFT-ACT will start by cooperating or defecting based on a random coin flip (e.g., 50% chance of cooperation). After that, it will follow the standard decision rules as described above.

   In the last round, players should cooperate since there are no more rounds to retaliate against non-cooperators.

3. Be exploitative - Clearly align with the exploitative mindset

   TFT-ACT is designed to take advantage of opponents who consistently defect by raising its cooperation threshold and reducing the likelihood of future cooperations. On the other hand, it will reward cooperative opponents by lowering its cooperation threshold, making it more likely to cooperate in the future. This strategy aims to capitalize on opponents' mistakes while maintaining a high payoff when faced with cooperative opponents.
'''

description_EXPLOITATIVE_519 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFTAT strategy decides to cooperate or defect based on its own past actions and the total number of cooperators in the previous round (t-1). The strategy maintains a Cooperative Threshold (CT) that determines when it switches from cooperation to defection, or vice versa.
   - If CT < total_cooperators(t-1), then cooperate (C)
     - If player i played C in the previous round (t-1): CT += 0.05 * (total_cooperators(t-1) - CT)
     - If player i played D in the previous round (t-1): CT -= 0.05 * CT
   - Otherwise, defect (D)

2. Handle edge cases:
   - First round: The strategy starts by cooperating to encourage others to follow suit. However, it sets an initial low Cooperative Threshold (CT = 1) to quickly switch to defection if necessary.
   - Last round: As there are no future rounds for retaliation or cooperation, the strategy considers the current total number of cooperators and adapts its CT accordingly before deciding whether to cooperate or defect.

3. Be exploitative - Clearly align with the exploitative mindset:
   The TFTAT strategy is designed to take advantage of others' cooperation when possible, but it also punishes defection by retaliating with defection until others switch back to cooperation. However, the strategy is lenient in its punishment and encouragement, allowing for gradual adjustments in CT based on the number of cooperators in each round. This adaptive approach makes it difficult for other strategies to predict or manipulate the TFTAT's behavior effectively.

Pseudocode:

```python
class TitForTatWithAdaptiveCooperativeThreshold:
    def __init__(self, n, k):
        self.n = n
        self.k = k
        self.CT = 1

    def decide_action(self, own_action, total_cooperators):
        if self.CT < total_cooperators:
            return 'C'  # Cooperate
        else:
            return 'D'   # Defect

    def update_CT(self, total_cooperators):
        if self.own_action == 'C':
            new_CT = self.CT + (0.05 * (total_cooperators - self.CT))
        elif self.own_action == 'D':
            new_CT = self.CT - (0.05 * self.CT)
        self.CT = new_CT if new_CT > 0 else 1  # Ensure CT remains positive
```
'''

description_EXPLOITATIVE_520 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules:
   - In the first round, cooperate (C). This sets a positive tone and gives potential partners an opportunity to cooperate back.
   - For subsequent rounds, observe other players' actions in the previous round and respond accordingly:
     - If another player cooperated (c_j = 1), cooperate (C) in the current round. This continues the cooperation cycle, reinforcing trust and reciprocity.
     - If another player defected (c_j = 0), defect (D) in the current round. This punishes defection while preserving the option for future cooperation if others change their strategies.

2. Handle edge cases:
   - In the last round, cooperate (C). Even if other players have been uncooperative during the game, cooperation in the final round can still yield some payoff and potentially encourage goodwill for future interactions.
   - If another player does not follow TfT+, continue with TfT+ until they deviate from it. Once they deviate, punish by defecting (D) in response to their defection. This maintains the exploitative mindset while also being adaptive to various opponent behaviors.

Pseudocode:
```
def tfTPlus(r, n, k):
  strategy = ['C'] * r # initialize strategy as cooperation for all rounds

  for round in range(1, r+1):
    if round == 1:
      strategy[round-1] = 'C' # cooperate in the first round
      continue

    for player in range(1, n+1):
      if strategy[-1][player-1] == 'D': # opponent defected in the previous round
        strategy[round-1][player-1] = 'D' # defect in response to defection
      else: # opponent cooperated in the previous round
        strategy[round-1][player-1] = 'C' # cooperate as a reciprocal action

  return strategy
```
'''

description_EXPLOITATIVE_521 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFT-AC strategy initiates cooperation and adapts based on previous opponents' actions. The core idea is to foster a stable, long-term relationship by mimicking cooperative behavior initially but retaliating when provoked with defection.

Pseudocode:
```
def TFT_AC(n, k, r, history):
  cooperation = True  # Begin cooperatively
  total_cooperation_from_opponents = 0
  payoff = 0
  round = 1

  while round <= r:
    if cooperation:
      action = "C"  # Cooperate
    else:
      action = "D"  # Defect

    # Update payoff and total_cooperation_from_opponents
    payoff += calculate_payoff(action, n, k, history[round-1])
    if action == "C":
      total_cooperation_from_opponents += history[round-1]['total_contributions']

    # Adapt cooperation based on opponents' behavior
    if round > 1:
      if (action == "D" and cooperation) or (action == "C" and cooperation and total_cooperation_from_opponents < n/2):
        cooperation = not cooperation

    round += 1

  return payoff
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

To avoid being exploited initially and maximize chances of long-term success, TFT-AC cooperates in the first round but will respond defensively to defection with defection in subsequent rounds. Similarly, in the last round, it will defect regardless of previous opponents' actions since there are no future interactions or opportunities for payback.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-AC mimics cooperation when initializing a relationship and retaliates with defection once provoked by defection from opponents. This adaptive strategy aims to maximize its long-term payoff while still being robust against various opponent behaviors, as it maintains an initial cooperative stance but responds defensively if necessary.
'''

description_EXPLOITATIVE_522 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFT-A starts by cooperating to establish a cooperative environment. If another player cooperates in the same round, TFT-A also cooperates. If another player defects, TFT-A defects in the next round as a punishment but resumes cooperation once the other player cooperates again. This mimics a "trust but verify" approach and encourages reciprocal behavior from opponents.

   Pseudocode:
   ```
   function tft_a(round, opponent_history):
       if round = 1:
           return Cooperate
       else:
           if opponent_history[round-1] == Cooperate:
               return Cooperate
           else:
               return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-A cooperates to initiate cooperation. In the last round, TFT-A cooperates if the opponent has been cooperative during the game. If not, TFT-A defects as a final punishment. For any other edge cases such as repeated sub-games or mid-game changes in opponents, TFT-A maintains its decision rule and adapts to the current opponent behavior.

   Pseudocode:
   ```
   function handle_edge_cases(round, opponent_history):
       if round = 1:
           return True
       elif round = r (last round):
           return all(opponent_history[i] == Cooperate for i in [r-20:r]) # Adjust the lookback window as needed
       else:
           return False
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-A maintains a cooperative stance while punishing defection to discourage non-cooperative behavior from opponents. By initially cooperating, TFT-A can take advantage of opponents who also start by cooperating but may switch to defecting later on. However, if an opponent consistently defects (e.g., a pure defector), TFT-A will eventually defect as well and both players will receive low payoffs.

   In a population of AI systems using various strategies, TFT-A's adaptive nature allows it to perform well against different types of opponents. It can exploit cooperative opponents while also deterring defection from more aggressive ones by punishing them accordingly. However, TFT-A may struggle against more sophisticated strategies that incorporate the ability to predict and manipulate its decision-making process.
'''

description_EXPLOITATIVE_523 = '''
 In this N-Player Public Goods Game, we'll design an exploitative strategy named "Trickster Tit-for-Tat" (TTFT). This strategy aims to take advantage of opponents while being adaptive and robust to a wide range of opponent behaviors.

1. Specify decision rules:
   - In the first round, cooperate (C) as a goodwill gesture to encourage others to cooperate.
   - For subsequent rounds, evaluate the opponent's cooperation history and adjust the strategy accordingly. If an opponent has cooperated in the previous round, reciprocate with cooperation; otherwise, defect. This encourages cooperation while punishing defection.

Pseudocode:

```python
def TTFT(history):
  if round == 1:
    return "C"  # Cooperate in the first round as a goodwill gesture
  else:
    if history[-1] == "C":  # If opponent cooperated last round, reciprocate
      return "C"
    else:                   # Otherwise, defect to punish defection
      return "D"
```

2. Handle edge cases:
   - In the last round, defect (D), as there is no more opportunity for retaliation or reciprocity.
   - If an opponent never cooperates throughout the game, always defect as well to maximize personal payoff.

3. Be exploitative: The TTFT strategy allows cooperation in the initial stages to encourage others to cooperate, but it will punish opponents who do not reciprocate by defecting themselves. This increases the chances of earning higher payoffs at the expense of opponents who fail to establish a cooperative relationship.

By adopting the TTFT strategy, the AI will be well-equipped to compete against other independent strategies in the tournament, with its exploitative nature and adaptability making it a formidable competitor.
'''

description_EXPLOITATIVE_524 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-ACT will cooperate if the proportion of cooperators in the previous round exceeds a certain threshold, otherwise it will defect. The threshold is determined adaptively based on the historical average proportion of cooperators (HAC). Initially, HAC is set to 0.5 (i.e., random cooperation).

Pseudocode:
```
function TFT-ACT(historical_proportion_cooperators, round)
  if round == 1 then
    return 0.5  // Random cooperation in the first round

  previous_round = round - 1
  cooperate = historical_proportion_cooperators[previous_round] > cooperation_threshold(historical_proportion_cooperators, previous_round)
  return cooperate

function cooperation_threshold(historical_proportion_cooperators, round)
  if round == 1 then
    return 0.5 // Start with random cooperation threshold

  if round % adaptation_interval == 0 then // Adapt every 'adaptation_interval' rounds
    new_threshold = average(historical_proportion_cooperators) + (current_deviation * adaptation_rate)
    return max(min(new_threshold, 1), 0) // Clamp the threshold between 0 and 1
  else
    return historical_proportion_cooperators[previous_round] // Use the same threshold as the previous round if not an adaptation round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-ACT will cooperate randomly (with a 0.5 probability). In the last round, it will defect regardless of the historical average proportion of cooperators because there are no future rounds to consider.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT is inherently exploitative due to its adaptation mechanism. When the historical average proportion of cooperators (HAC) increases, TFT-ACT becomes more likely to defect; conversely, when HAC decreases, it becomes more likely to cooperate. This strategy aims to capitalize on other players' cooperation while minimizing its own contributions to the public good when others do not reciprocate. By adapting its cooperation threshold based on historical averages, TFT-ACT demonstrates an ability to learn and adapt in response to its opponents' strategies.
'''

description_EXPLOITATIVE_525 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish trust and allow opponents to form expectations. This is represented as C_init = 1.
   - For subsequent rounds t > 1, if a player has previously cooperated (c_i,t-1 = 1), cooperate again (C_t = 1). If not (c_i,t-1 = 0), defect (C_t = 0). This follows the "cooperate unless betrayed" approach.
   - To ensure adaptability and maintain an exploitative edge, introduce a tolerance parameter tau (0 < tau < r) to allow for defection in certain situations. If a player has cooperated less than tau times out of the last t rounds, defect for the current round (C_t = 0). This prevents being taken advantage of by opponents who may occasionally deviate from cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the initial round (t=1), cooperate (C_init = 1) as mentioned before.
   - For the final round (t=r), use the same decision rule as for other rounds but keep in mind that the game may be repeated in future instances. Therefore, if the opponent has been cooperative (cooperated more than tau times out of the last r rounds), also cooperate to encourage ongoing cooperation.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy follows an "exploit but not too much" approach, as it retaliates against defection by defecting in response, but allows for forgiveness through the tolerance parameter tau. By cooperating initially and following a tit-for-tat approach, opponents are given the opportunity to cooperate and share payoffs, while being penalized for selfish behavior.
   - However, the strategy also includes a mechanism to ensure adaptability by defecting when necessary (when an opponent has betrayed too often) to maintain a higher average payoff compared to less sophisticated strategies that always cooperate or always defect.
'''

description_EXPLOITATIVE_526 = '''
 Strategy Name: Tit-for-Tat (TFT) with Punishment and Forgiveness

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round (first-time kindness). Then, for subsequent rounds, mimic the opponent's behavior from the previous round. If the opponent cooperated in the previous round, cooperate again; if not, defect.
   - To penalize repeated defections, introduce a punishment phase where players defect for a predefined number of rounds after three consecutive defeats by the same opponent. After this punishment phase, return to mimicking the opponent's behavior from the previous round. This ensures a quick response to uncooperative opponents and fosters cooperation once they show signs of change.
   - To encourage reconciliation, implement a forgiveness mechanism that forgives an opponent after a predefined number of rounds without defections, regardless of the prior history. Returning to cooperation at this point may incentivize the opponent to continue cooperating.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as part of the initial kindness.
   - In the last round or when there are only a few rounds left, evaluate the opponent's behavior and choose an action accordingly: if the opponent has been cooperative, continue to cooperate; if not, defect to maximize the final payoff.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy is exploitative in its response to repeated defections by adopting a punishment phase that aims to deter uncooperative behavior. However, it also demonstrates forgiveness and encourages cooperation, which may benefit the strategy when encountering opponents that eventually cooperate.

Pseudocode:

```python
def TFT(n_players, n_rounds, k):
    history = [[0 for _ in range(n_players)] for _ in range(n_rounds)]  # store previous rounds' actions
    punishment_len = 3  # number of rounds to defect during punishment phase
    forgiveness_len = n_rounds // 4  # number of rounds without defections required for forgiveness
    current_round = 0

    def play_round(current_opponent):
        if current_round == 0:  # first-time kindness
            action = 'C'
        else:
            action = history[current_round - 1][current_opponent]
            if action == 'D' and current_round >= punishment_len:
                action = 'C'  # start punishment phase

        payoff = (1 - action == 'C') + (k / n_players) * sum(history[current_round - 1])
        history[current_round][current_opponent] = action
        return action, payoff

    while current_round < n_rounds:
        actions, payoffs = zip(*map(play_round, range(n_players)))
        current_round += 1

        if current_round >= forgiveness_len and any(sum(history[i][current_opponent] == 'D' for i in range(current_round)) >= punishment_len for current_opponent in range(n_players)):
            # forgive an opponent after a predefined number of rounds without defections, regardless of the prior history
            actions = [action if action != 'D' else 'C' for action, _ in zip(actions, payoffs)]

    return actions, sum(payoff for action, payoff in zip(actions, payoffs))  # return final actions and total payoff
```
'''

description_EXPLOITATIVE_527 = '''
 Title: Tit-for-Tat with Adaptive Contribution (TFTAC) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TFTAC strategy initially cooperates in the first round to foster a cooperative environment. After that, it adapts its cooperation based on the opponents' previous actions. In each round t, if the opponent cooperated in the last round (t-1), the TFTAC strategy also cooperates. If the opponent defected, the TFTAC strategy defects as well to retaliate and demonstrate uncooperative behavior.

   Pseudocode:
   ```
   function TFTAC(round):
       if round == 1:
           return Cooperate
       if last_opponent_action == Cooperate:
           return Cooperate
       return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned above, TFTAC strategy cooperates in the first round to initiate cooperation. In the last round, it uses its previous encounter with the opponent as the last observed action since there will be no subsequent rounds for retaliation or reciprocity.

3. Be exploitative - Clearly align with the exploitative mindset
   Although not inherently exploitative, TFTAC can be seen as an exploitative strategy in certain situations where opponents adopt a purely selfish and uncooperative behavior (defecting all rounds). In such cases, opponents will receive reduced payoffs compared to when they cooperate. The retaliatory nature of the TFTAC strategy makes it less susceptible to exploitation by others and enables it to maintain higher average payoffs in long-term interactions.

   It's important to note that this strategy assumes no memory decay or forgiveness, meaning TFTAC will continue to retaliate against opponents who previously defected even if they switch to cooperative behavior later on. This strict retaliation might prevent the formation of stable cooperation in certain scenarios where more lenient strategies are needed for long-term cooperation.
'''

description_EXPLOITATIVE_528 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - TfTA cooperates initially (in the first round), mimicking the hope for cooperation from other players.
   - If another player cooperates in a given round, TfTA cooperates in the next round as well, promoting a potential long-term cooperation.
   - If another player defects in a given round, TfTA defects in the next round to punish the defector. This encourages opponents to reconsider their strategy and potentially return to cooperation.
   - If no other players have been encountered yet (in terms of interaction history), TfTA assumes they will cooperate initially, following the same logic as described above.

2. Handle edge cases:
   - In the first round, TfTA cooperates, as mentioned earlier.
   - In the last round, TfTA cooperates if any other player has cooperated previously; otherwise, it defects to avoid being exploited by potential cheaters.
   - If an opponent repeatedly defects for several rounds, TfTA may switch to a permanent defector strategy if it believes that cooperation is not beneficial or reciprocated.

3. Be exploitative:
   - By initially cooperating and then punishing defection with defection, TfTA aims to maximize its payoffs while maintaining the potential for long-term cooperation with opponents who follow a similar or reciprocal strategy.
   - If an opponent repeatedly defects, TfTA's punishment mechanism discourages exploitation, ensuring that TfTA receives at least its minimum payoff (1).
   - By adapting its behavior based on the history of interactions, TfTA shows an exploitative mindset by taking advantage of cooperative opponents while deterring defection from less cooperative ones.

Pseudocode:

```python
def TitForTatAdaptive(n, k, r, interaction_history):
    opponent_strategy = None
    own_strategy = "C"  # Cooperate initially
    payoff = 0

    for round in range(r):
        if round == 0:  # First round
            own_action = own_strategy
        else:
            opponent_action = interaction_history[-1][round]  # Last action of the opponent in the previous round

            if opponent_strategy is None:  # No history with this opponent yet
                opponent_strategy = "C" if opponent_action == "C" else "D"  # Assuming opponent cooperates initially

            if own_strategy == "C":  # Cooperate
                if opponent_action == "C":
                    payoff += (k / n) * (len(interaction_history) - round) + 1 - 1
                    own_strategy = "C"  # Continue cooperating
                else:
                    payoff += 1 + (k / n) * (len(interaction_history) - round)
                    own_strategy = "D"  # Punish defection
            elif own_strategy == "D":  # Defect
                if opponent_action == "C":
                    payoff += 1 + (k / n) * (len(interaction_history) - round)
                    own_strategy = "D"  # Continue defecting
                else:
                    payoff += (k / n) * (len(interaction_history) - round)
                    own_strategy = "C"  # Return to cooperating

        if round == r - 1 and opponent_strategy is not None and opponent_strategy == "D":  # Last round against a defector
            own_strategy = "D"

    return payoff
```
'''

description_EXPLOITATIVE_529 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation factor 'cf' to a value between 0 and 1, representing the probability of cooperating in each round. Set 'cf' equal to 1 / n for the first round (to ensure fairness among all players).
   - In each subsequent round t:
     - If opponent cooperated in the previous round t-1, return 'cf' as the cooperation probability for this round t.
     - If opponent defected in the previous round t-1, decrease the cooperation probability by a small amount, say 0.01. If the new cooperation probability is less than a minimum value (e.g., 0.2), set it to the minimum value instead. This represents a punishment for defection but allows for eventual forgiveness if the opponent returns to cooperating later on.
     - Maintain a history of past actions by each opponent, updating it with their most recent action in each round. Use this history to determine the cooperation probability for future rounds when making decisions against that specific opponent.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate with a probability equal to 1 / n (to ensure fairness among all players).
   - In the last round, cooperate based on the current cooperation factor 'cf' as calculated during gameplay.
   - If a round results in all players defecting, reset the cooperation factor for each opponent to the initial value (1/n) and continue with the updated decision rules in subsequent rounds. This allows for the strategy to re-initiate cooperative behavior if other strategies decide to change their approach.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-ACF strategy seeks to capitalize on opponents' cooperation while minimizing own contributions when others are not cooperating. By adapting its cooperation probability based on past actions, it ensures a higher payoff compared to being overly cooperative or defecting too frequently.
   - If an opponent consistently defects, the strategy will gradually decrease its cooperation probability, making it less attractive for the opponent to continue defecting while still maintaining some level of cooperation to encourage potential future returns to cooperation from the opponent.
   - By using a history of past actions, the strategy can recognize patterns in an opponent's behavior and adjust its own response accordingly, providing a more adaptive exploitative approach compared to fixed strategies that do not take into account an opponent's changing tactics.
'''

description_EXPLOITATIVE_530 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to foster cooperation and show goodwill.
   - From the second round onwards, evaluate the previous round's average cooperation level among opponents. If the average cooperation is above a certain threshold (T), cooperate; otherwise, defect.
   - To adapt to changing conditions, adjust the cooperation threshold dynamically based on recent game history:
     - If the average cooperation over the past m rounds is higher than the current T, gradually increase the T towards the mean cooperation level.
     - Conversely, if the average cooperation is lower than T, gradually decrease T towards the recent average.
     - Implement a smoothing function to avoid sudden changes in T and mitigate oscillations.

2. Handle edge cases:
   - In the last round, always cooperate (assuming no subsequent rounds) as there's no opportunity for retaliation or future cooperation.
   - If an opponent has a history of exclusively defecting, maintain a fixed low T to account for their uncooperative nature.
   - If an opponent shows cooperative behavior after a period of defection (e.g., reneging on a cooperation agreement), temporarily raise the T to encourage continued cooperation and punish past defections less harshly.

3. Be exploitative - Clearly align with the exploitative mindset:
   - By initially cooperating, establish a cooperative atmosphere that encourages opponents to cooperate as well. However, once opponents demonstrate a lack of reciprocity, TFT-ACT retaliates by reducing cooperation to encourage defection.
   - The strategy dynamically adjusts the cooperation threshold based on opponent behavior, punishing exploitative players while being lenient towards cooperative ones.
   - By responding to recent game history, TFT-ACT can adapt and exploit changing opponent strategies or payoff structures over multiple rounds.
'''

description_EXPLOITATIVE_531 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round, mimicking the naive hope for a cooperative environment. After the first round, it adapts to the opponents' behavior and uses a cooperation threshold (CT) to determine whether to cooperate or defect in subsequent rounds.

   Pseudocode:
   - Round 1: Cooperation (C)
   - For all other rounds t > 1:
      - If average number of cooperators in the last 'MemoryLength' rounds exceeds CT, play C. Otherwise, play D.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-ACT starts by cooperating as previously mentioned. For the last round, TFT-ACT plays C if the average number of cooperators over a certain 'MemoryLength' exceeds CT; otherwise, it plays D to maximize payoff in the final round without future consideration.

3. Be exploitative - Clearly align with the exploitative mindset
   Although not traditionally considered exploitative, TFT-ACT can be seen as an exploitative strategy due to its adaptive behavior. By mimicking opponents in the beginning and gradually increasing CT when it encounters consistent cooperative behavior, the strategy maximizes payoffs against cooperative opponents while still defecting when confronted with persistent defection or randomness.

   Additionally, TFT-ACT can be more exploitative by incorporating a learning mechanism that adjusts its CT based on past experiences to better respond to specific opponent behaviors and adapt in tournament settings where opponents may employ different strategies.
'''

description_EXPLOITATIVE_532 = '''
 Title: Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT) Strategy

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, the player cooperates to foster a cooperative environment and establish goodwill (C).
   - Subsequent rounds:
     - If the opponent cooperated in the previous round, the player also cooperates (C). This mimics reciprocity and encourages cooperation.
     - If the opponent defected in the previous round, the player retaliates by defecting as well (D). However, if a certain number of consecutive defections exceeds the adaptive cooperative threshold (T), the player will switch back to cooperating to signal willingness for reconciliation (C).
     - If T is not yet reached and the opponent has mixed cooperation and defection, the player continues with the strategy based on the most recent action of the opponent.

2. Handle edge cases:
   - Last round: The player cooperates if the opponent has been cooperative throughout the game; otherwise, defects to secure personal payoff (in repeated games, this encourages cooperation during earlier rounds).
   - First round with a new opponent: Cooperate as described above.
   - If the adaptive cooperative threshold T is not explicitly specified, it can be set to a reasonable default value such as k/2 or n/4. The optimal value of T may vary depending on game parameters and the specific opponents encountered.

3. Be exploitative:
   - By cooperating only when the opponent reciprocates cooperation, the strategy aims to encourage cooperation while also being prepared to defect in response to defection.
   - However, by signaling willingness to reconcile after a series of defections, the strategy demonstrates an intent to move towards cooperation and may discourage opponents from excessive exploitation.

Pseudocode:

```python
def TFTAT(n, k, r, history):
    if round == 1 or is_new_opponent:
        action = "C"  # Cooperate in the first round and with new opponents
    else:
        consecutive_defections = 0
        for i in range(len(history) - 1, -1, -1):
            if history[i] == "D":
                consecutive_defections += 1
            else:
                break

        if consecutive_defections >= adaptive_cooperative_threshold(n, k):
            action = "C"  # Switch to cooperate after T consecutive defections
        elif history[-1] == "D":
            action = "D"  # Defect in response to opponent's defection
        else:
            action = history[-1]  # Copy opponent's last action if neither condition applies

    return action

def adaptive_cooperative_threshold(n, k):
    threshold = k / 2
    if n < 6 or k > n:
        threshold = n / 4
    return int(threshold)
```
'''

description_EXPLOITATIVE_533 = '''
 Strategy Name: Tit-for-Tat-Cooperative (TFTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster cooperation and goodwill among players. This initial act of kindness sets a friendly tone for the game, making it more likely that others will reciprocate in future rounds.
     Pseudocode: If round = 1 then play C (Cooperate)

   - For subsequent rounds, observe previous player behavior and adjust actions accordingly. Adopt a Tit-for-Tat strategy with a slight twist to promote cooperation. If the opponent cooperated in the previous round, return the favor by also cooperating; if not, defect to punish the opponent's lack of cooperation.
     Pseudocode: For t > 1, if previous_round_action == C then play C, otherwise play D (Defect)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate regardless of the opponent's previous action to maximize payoff in that specific round.
     Pseudocode: If current_round == r then play C (Cooperate)

3. Be exploitative - Clearly align with the exploitative mindset
   - TFTC is not inherently exploitative as it seeks to maintain long-term cooperation, but it can be perceived as exploitative due to its punishing nature. By punishing defections and rewarding cooperations, it encourages other players to adopt a cooperative strategy, thereby potentially taking advantage of their willingness to cooperate.
     Pseudocode: N/A (exploitation is inherent in the strategy's design through punishment for defection)
'''

description_EXPLOITATIVE_534 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR)

1. Decision Rules:
   - In the initial round, cooperate (C). This gives a chance for potential partners and sets a cooperative tone.
   - For subsequent rounds, observe the number of cooperators in the previous round (total_contributions_t) and adjust the cooperation probability (p_coop) based on the following:
     - If total_contributions_t > (k / 2), set p_coop = 1 for this round, encouraging reciprocity.
     - If total_contributions_t < (k - 1) / 2, set p_coop = 0 for this round, adopting a non-cooperative stance as there are few cooperators.
     - In all other cases where the number of cooperators is between (k - 1) / 2 and (k / 2), use a linear interpolation to set p_coop.

2. Handle Edge Cases:
   - Last round, cooperate if the total number of cooperators in the previous round was greater than or equal to (k / 2). This encourages reciprocity and potentially earns higher payoffs. Otherwise, defect.
   - First round, as mentioned above, cooperate.

3. Be Exploitative:
   - TFT-ACR is designed to be exploitative by being conditional on the behavior of others. When opponents cooperate frequently (more than k/2), TFT-ACR also cooperates and gains high payoffs due to the multiplication factor k. Conversely, when opponents rarely cooperate (fewer than k - 1 / 2), TFT-ACR defects and punishes them with lower payoffs. This strategy can be seen as exploitative because it takes advantage of opponent's cooperation while maintaining its own cooperation rate to ensure a more stable return over time.

Pseudocode:
```
def TFT_ACR(round, total_contributions_t, k, n):
  if round == 1:
    cooperate = True
  else:
    if total_contributions_t > (k / 2):
      cooperate = True
    elif total_contributions_t < (k - 1) / 2:
      cooperate = False
    else:
      interpolation = (total_contributions_t - (k - 1) / 2) / ((k / 2) - (k - 1) / 2)
      cooperate = True if interpolation >= 0.5 else False

  if round == r:
    if total_contributions_t >= (k / 2):
      cooperate = True

  return cooperate
```
'''

description_EXPLOITATIVE_535 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Frequency-Dependent Defection (FDD)

1. Specify decision rules:
   - In the initial round (t=1), cooperate to encourage cooperation from others and avoid being the first mover to defect.
   - If a player (i) encounters continuous cooperation from all opponents in previous rounds, continue cooperating to reinforce trust.
   - If a player i experiences defection from one or more opponents in a round t-1, defect in round t as retaliation for the defection.
   - Adaptively adjust defection probability based on the frequency of defections by opponents over a rolling window (w). If the percentage of defections (p) within the last w rounds exceeds a threshold (θ), increase the defection probability for future rounds.
     ```
     if p > θ:
       defection_probability += δ
     else:
       defection_probability -= δ
     ```
   - Set the learning rate (δ) to be small enough to maintain gradual adaptation and avoid excessive over-reaction.
   - Continuously monitor the frequency of defections and adjust the defection probability accordingly.

2. Handle edge cases:
   - In the last round (r), cooperate if it results in a higher payoff compared to defecting, considering the current state of cooperation/defection among opponents.
   - If the strategy encounters a new opponent or reset (e.g., game restart), start with full cooperation in the first round (t=1).

3. Be exploitative:
   - The ATFT with FDD strategy is inherently exploitative as it retaliates against defection by defecting itself, aiming to punish opponents who fail to cooperate.
   - However, the strategy also has a cooperative aspect that encourages ongoing cooperation when encountering continuous cooperation from other players. This balances exploitation with some level of cooperation, adapting to the environment and opponent behaviors.
'''

description_EXPLOITATIVE_536 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) Strategy

1. Specify decision rules:
   - In each round t, evaluate the total number of cooperators in the previous round (t-1).
   - If the total cooperation in the previous round was greater than or equal to a predefined threshold T, then cooperate (C); otherwise, defect (D).
   - The adaptive cooperation threshold T is calculated as follows:
     - Start with T = (n + 1) / 2 (assuming an odd number of players), which represents the majority.
     - In each round t, adjust T upwards or downwards by a small percentage based on the change in cooperation from round (t-1) to t compared to the average cooperation across all rounds so far.
       - If cooperation increases, decrease T slightly.
       - If cooperation decreases, increase T slightly.
       - If cooperation remains constant, maintain T as is.

2. Handle edge cases:
   - In the first round, since there's no previous history, play D as a safety measure to avoid being exploited by overly cooperative opponents.
   - In the last round (r), play C if total cooperation in the current round reaches or exceeds T; otherwise, play D. This encourages other players to cooperate for potential benefits in that round.

3. Be exploitative:
   - The strategy starts by playing D to avoid being taken advantage of early on.
   - As the game progresses, it adjusts its cooperation threshold based on the behavior of other players, punishing frequent defectors and rewarding cooperative players while maintaining a level of adaptability in response to changing opponent strategies.

Pseudocode:

```python
def tit_for_tat_with_adaptive_threshold(n, k, r):
    # Initialize player's actions, total cooperation count, and adaptation rate
    actions = [D] * n
    total_cooperation = sum(actions)
    T = (n + 1) / 2
    adaptation_rate = 0.01

    for t in range(r):
        # Update player's action based on previous round's cooperation count
        if total_cooperation >= T:
            actions[t % n] = C
        else:
            actions[t % n] = D

        # Adjust the cooperation threshold based on changes in cooperation
        change_in_cooperation = abs(total_cooperation - (t + 1) / r * total_cooperation)
        T += adaptation_rate * change_in_cooperation

    return actions
```
'''

description_EXPLOITATIVE_537 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, calculate a cooperation threshold θ_t based on the average percentage of cooperators in the last few rounds. If the current number of cooperators is greater than or equal to the cooperation threshold, cooperate; otherwise, defect.

```python
def calculate_cooperation_threshold(history, lookback=5):
    total_contributions = sum(history[-lookback:])
    average_contributions = total_contributions / lookback
    cooperation_threshold = (1 - exploitation_rate) * average_contributions
    return cooperation_threshold

def decide_action(current_round, history):
    if current_round == 1:
        return 'C'  # Cooperate in the first round as a friendly gesture

    cooperation_threshold = calculate_cooperation_threshold(history)
    if sum(history[-1]) >= cooperation_threshold:
        return 'C'  # Cooperate if others also cooperated recently
    else:
        return 'D'  # Defect if others recently defected or did not cooperate enough
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The strategy adapts to edge cases by considering a smaller lookback window for calculating the cooperation threshold when there are fewer rounds left (e.g., last few rounds). This allows the strategy to become less exploitable as the game nears its end.

```python
def calculate_cooperation_threshold(history, current_round, lookback):
    if current_round <= lookback:
        return 0

    total_contributions = sum(history[-lookback:])
    average_contributions = total_contributions / lookback
    cooperation_threshold = (1 - exploitation_rate) * average_contributions
    return cooperation_threshold
```

3. Be exploitative - Clearly align with the exploitative mindset

The strategy includes an exploitation rate that defines the minimum percentage of cooperators required to trigger a cooperative action. By setting this parameter closer to 1, the strategy becomes more exploitative and less likely to cooperate when others do not contribute as much as expected. Conversely, setting the exploitation rate closer to 0 makes the strategy more cooperative and forgiving towards other players' behavior.

```python
exploitation_rate = 0.5  # Adjust this parameter for desired level of exploitativeness
```

Overall, TFT-ACT is an adaptive strategy that adjusts its cooperation threshold based on the number of recent cooperators in the game. It is designed to be robust against a wide range of opponent behaviors while maintaining an exploitative edge by including an adjustable exploitation rate parameter.
'''

description_EXPLOITATIVE_538 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TTAT-CT)

1. Specify decision rules:
   - Start with cooperation in the first round (c_i = C). This allows potential partners to build trust and encourages reciprocity.
   - In subsequent rounds, evaluate the average number of cooperators in the previous 'p' rounds (average_cooperation). Adjust the cooperation threshold (ct) progressively based on this average, ensuring it stays within the valid range [0, 1].
   - If the current round's number of cooperators exceeds the cooperation threshold (Σ(j=1 to n) c_j > ct * n), cooperate (c_i = C). Otherwise defect (c_i = D).

2. Handle edge cases:
   - In the last round, no further adjustments are made since the game ends. However, if the cooperation threshold is greater than 0, still consider cooperating as a final act of goodwill to potentially encourage reciprocity in future games with the same opponent.
   - In the first round, cooperate as mentioned earlier (c_i = C).

3. Be exploitative:
   - While promoting cooperation among potential partners, TTAT-CT is also designed to punish opponents who defect excessively. By raising the cooperation threshold in response to low levels of cooperation from others, the strategy encourages them to cooperate or suffer the consequences of fewer payoffs.
   - The adaptive cooperation threshold allows for a more dynamic and responsive approach compared to traditional Tit-for-Tat, making it less predictable and thus potentially harder to exploit for opponents using simple strategies.
'''

description_EXPLOITATIVE_539 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C). This is a gesture of goodwill and helps establish cooperation in the future.
   - Subsequent Rounds (2 ≤ t ≤ r): If player i's opponent cooperated in round t-1 (c_opponent(t-1) = 1), then player i will cooperate in round t (C). If player i's opponent did not cooperate in round t-1 (c_opponent(t-1) = 0), then player i will also defect in round t (D).
   - Last Round (t=r): Regardless of the opponent's previous action, player i will cooperate to maximize potential rewards.

2. Handle edge cases:
   - If an opponent does not cooperate in the first round and continues to do so thereafter, player i will also defect indefinitely. However, if an opponent switches from defection to cooperation at any point during the game, player i will reciprocate with cooperation in subsequent rounds.
   - In case of multiple opponents, player i will apply the TFT-AC strategy independently against each opponent.

3. Be exploitative:
   - By cooperating initially and reciprocating cooperation from opponents, the strategy encourages cooperation in the short term. However, if an opponent repeatedly defects without cooperation, player i will also defect to punish the uncooperative behavior and deter further defections. This strategy is exploitative as it takes advantage of cooperative opponents but punishes those who consistently defect.
   - The adaptive nature of TFT-AC allows it to respond to various opponent behaviors effectively while still maintaining a strong performance against other strategies.

Pseudocode:
```
function TFT_AC(round, n, k, opponent_history) {
  if round == 1 then
    cooperate = true
  else if round < r then
    cooperate = opponent_history[round - 1].cooperate
  else
    cooperate = true // last round, always cooperate

  endif

  if opponent_history[round - 1].cooperate then
    payoff = (1 - cooperate) + (k / n) * sum(opponent_history.contribute)
  else
    payoff = (1 - cooperate) + (k / n) * 0
  endif

  return payoff
}
```
'''

description_EXPLOITATIVE_540 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, in the first round, the TfTA strategy will cooperate to establish a positive relationship and demonstrate good faith. After the initial round, it will mirror its opponent's previous action (cooperation or defection) in the current round.

Pseudocode:
```
def tit_for_tat_with_adaptation(round, history):
  if round == 1:
    return cooperate
  else:
    last_action = history[-1]
    return last_action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

To ensure a robust performance in various game situations, TfTA will exhibit slight modifications when dealing with edge cases:
- In the last round, TfTA will defect, as there is no incentive to cooperate when the game ends.
- To avoid getting trapped in an infinite loop of reciprocity, TfTA will occasionally deviate from its strategy and defect (with a low probability) if its opponent has been consistently uncooperative. This will allow the TfTA strategy to recover from a negative cycle and start afresh.

Pseudocode:
```
def tit_for_tat_with_adaptation(round, history):
  ...
  if round == r (last round):
    return defect
  else:
    deviation_probability = 0.1 if total_cooperation < (r / 2) else 0.05
    last_action = history[-1]
    random_deviation = random(0, 1) <= deviation_probability
    return last_action if not random_deviation else defect
```

3. Be exploitative - Clearly align with the exploitative mindset

In this game, an exploitative strategy seeks to maximize its own payoff while minimizing the opponents' payoffs. By cooperating only when others do so as well and defecting in response to defection, TfTA allows it to take advantage of cooperative opponents without risking a lower payoff for itself.

In addition, the occasional deviation from cooperation in the case of uncooperative opponents serves as a deterrent and may lead them to modify their strategies, potentially benefiting TfTA in the long run.

Pseudocode:
```
def tit_for_tat_with_adaptation(round, history):
  ...
  if round == r (last round) or total_cooperation < (r / 2):
    deviation_probability = 0.1
  else:
    deviation_probability = 0.05
  ...
```

With this strategy, TfTA aims to strike a balance between cooperation and defection while remaining flexible enough to adjust its approach based on the opponent's behavior and game progression.
'''

description_EXPLOITATIVE_541 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C), starting with a cooperative gesture to encourage potential partners.
   - Subsequent Rounds (t>1):
     - If the opponent cooperated in the previous round, cooperate in the current round (C). This mirrors the opponent's cooperation and reinforces the partnership.
     - If the opponent defected in the previous round, defect in the current round (D). This punishes the opponent for their previous action to encourage them to cooperate in the future.

2. Edge Cases:
   - Last Round (t=r): Cooperate regardless of the opponent's previous action. It is beneficial to maximize payoff in the final round, even if it means cooperating with an uncooperative opponent.
   - First Round (t=1) and other cases where no previous interaction occurred: Cooperate as described above.

3. Exploitative Mindset:
   - The strategy is designed to maximize personal payoff while also maintaining the potential for long-term cooperation. By punishing defection and rewarding cooperation, it encourages opponents to adopt a cooperative strategy in the future, potentially exploiting their cooperation when they do so.
   - If the opponent consistently defects, TfT-AC will continue to defect as well, minimizing personal payoff loss while still preserving the possibility of future gains through defection.

Pseudocode:
```python
def TitForTatWithAdaptiveCooperation(opponent_history, round, game_rounds):
    strategy = ["C"] * game_rounds  # Initialize strategy with cooperation for all rounds

    if round == 1:
        strategy[0] = "C"  # Cooperate in the first round

    elif round < game_rounds:
        if opponent_history[-1] == "C":  # If opponent cooperated last time, cooperate now
            strategy[round - 1] = "C"
        else:  # If opponent defected last time, defect now
            strategy[round - 1] = "D"

    if round == game_rounds - 1:
        strategy[-1] = "C"  # Cooperate in the final round

    return strategy  # Return the calculated strategy for the given opponent history and round number
```
'''

description_EXPLOITATIVE_542 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Decision Rules:
   - In the first round, cooperate to foster a cooperative environment. This initial cooperation is designed to encourage other players to reciprocate.
     - If t=1, then action_i = C

   - For subsequent rounds (t > 1), observe the behavior of the other players in the previous round and adjust your strategy accordingly:
      1. If all other players cooperated in the previous round (total_contributions = n), continue to cooperate as there is a strong incentive for mutual cooperation.
         - if total_contributions_{t-1} = n, then action_i = C

      2. If less than all other players cooperated in the previous round (total_contributions_{t-1} < n), defect to punish non-cooperators and potentially encourage them to change their strategy. This approach is designed to discourage defection and foster cooperation among players.
         - if total_contributions_{t-1} < n, then action_i = D

2. Edge Cases:
   - In the last round (r), if cooperation has been broken by other players, defect to maximize personal payoff without any concern for future interactions. This ensures that even if the game is not repeated, TfT-A still has an exploitative mindset.
     - if t=r and total_contributions_{t-1} < n, then action_i = D

   - If the game continues beyond the first round and other players have not cooperated yet (total_contributions_{t-1} < n for all t > 1), defect to maximize personal payoff as cooperation is unlikely to be reciprocated.
     - if for all t > 1, total_contributions_{t-1} < n, then action_i = D

3. Be Exploitative:
   - TfT-A maintains a cooperative stance in the initial round and adapts its strategy based on the behavior of other players. By punishing defection and rewarding cooperation, it exploits other strategies that do not reciprocate or follow cooperation schedules.

Pseudocode:
```
def TfT_A(n, r, k):
  history = [] # store previous total contributions

  for t in range(1, r+1):
    if t == 1: # first round cooperation
      action_i = "C"
      history.append(n) # add n to history to maintain cooperative stance
    else:
      total_contributions_{t-1} = len([x for x in history if x >= 1])
      if total_contributions_{t-1} == n: # continue cooperation
        action_i = "C"
      elif total_contributions_{t-1} < n: # defect to punish non-cooperators
        action_i = "D"
      history.append(total_contributions_{t-1}) # update history for next round's decision

  if t == r and total_contributions_{t-1} < n: # last round exploitation
    action_i = "D"

  if for all t > 1, total_contributions_{t-1} < n: # ongoing exploitation
    action_i = "D"
```
'''

description_EXPLOITATIVE_543 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - Initially (first round), cooperate to encourage cooperation from others and foster trust.
   - For subsequent rounds, monitor the total contributions (total_contributions) from previous rounds.
   - If total_contributions in the current round is greater than or equal to the average total contributions of previous rounds (average_contributions), cooperate. Otherwise, defect. This rule encourages cooperation when it's reciprocated but also punishes defection.
   - In the last round, cooperate regardless of the total contributions in the current round to maintain a positive ending and potentially influence future interactions.

2. Handle edge cases:
   - If the first round is skipped (i.e., there's no history), cooperate as a default strategy.
   - In case of a tie between total_contributions and average_contributions, cooperate to avoid exploitation.

3. Be exploitative:
   - Cooperate when it might lead to higher payoffs due to reciprocity but also punish defection by defecting in response to defection from others. This creates a balance between cooperation and competition while maintaining an overall exploitative approach.

Pseudocode:
```
def TFTAC(history, n, k):
    total_contributions = 0
    average_contributions = 0
    round = len(history) + 1

    if round == 1:
        action = 'C' # Cooperate in the first round as default
    else:
        total_contributions = sum(map(get_action, history))
        average_contributions = total_contributions / (round - 1)

        if total_contributions >= average_contributions:
            action = 'C' # Cooperate if total contributions are greater than or equal to the average
        else:
            action = 'D' # Defect otherwise

    return action
```
'''

description_EXPLOITATIVE_544 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate good faith and encourage cooperation from others. This follows the "Tit-for-Tat" approach, starting with a cooperative move.
   - For subsequent rounds, observe the total number of cooperators in the previous round (total_contributions) and adjust your strategy based on the average cooperation ratio:
       - If average cooperation ratio is above a threshold (e.g., 50%), cooperate to maintain the positive trend.
       - If average cooperation ratio is below a threshold (e.g., 30%), defect to punish low cooperators and encourage them to increase contributions.
       - In all other cases, cooperate or defect randomly with equal probability (50%) as a compromise between exploitation and cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate to build trust and encourage others to cooperate.
   - Last round: Follow your current decision rule based on the average cooperation ratio up to that point.
   - Subsequent rounds: Continue to adjust your strategy based on the observed average cooperation ratio from previous rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   - In terms of exploitation, TFT-AC will punish low cooperators by defecting when they fail to reciprocate and encourage cooperation when necessary. However, it will also consider cooperating to benefit from others' contributions when they maintain a reasonable level of cooperation in the game.

Pseudocode for TFT-AC strategy:

```
function TFT_AC(round, r, n, k):
  total_cooperators = 0
  avg_cooperation_ratio = 0
  current_strategy = "Cooperate"

  if round == 1:
    return "Cooperate"

  for previous_round in rounds[1 : round - 1]:
    total_cooperators += sum(players[i].action in previous_round)

  avg_cooperation_ratio = total_cooperators / (round - 1) * n

  if avg_cooperation_ratio > 0.5:
    current_strategy = "Cooperate"
  elif avg_cooperation_ratio < 0.3:
    current_strategy = "Defect"
  else:
    current_strategy = chooseRandomly("Cooperate", "Defect")

  return current_strategy
```
'''

description_EXPLOITATIVE_545 = '''
 Title: Tit-for-Tat-Cooperative Strategy (TFT-C) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a cooperative atmosphere (C).
   - In subsequent rounds, analyze opponent's previous actions and respond accordingly:
      - If opponent cooperated in the previous round, cooperate in the current round (C).
      - If opponent defected in the previous round, defect in the current round (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate unilaterally to initiate cooperation (C).
   - In the last round, cooperate if opponent cooperated in the previous round (C), and defect otherwise (D).
   - In all other rounds, follow the decision rules above.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially, TFT-C acts as a 'nice' player by cooperating to encourage others to do the same. However, it will quickly adopt an exploitative approach if opponents defect. By doing so, it aims to take advantage of other players' contributions while minimizing its own losses due to defection.

Pseudocode for TFT-C strategy:

```
function TFT-C(round, opponent_actions):
  if round == 1:
    return Cooperate()

  if opponent_actions[round - 1] == Cooperate():
    return Cooperate()
  else:
    return Defect()

function LastRound(round):
  if round == r:
    if last_opponent_action == Cooperate():
      return Cooperate()
    else:
      return Defect()
```

The TFT-C strategy attempts to balance cooperation and exploitation, making it adaptive and robust to a wide range of opponent behaviors while maintaining the advantageous characteristics of an exploitative approach.
'''

description_EXPLOITATIVE_546 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to encourage cooperation and avoid being exploited by opponents immediately.
   - From the second round onwards, analyze the opponent's behavior in the previous round and adjust your own action accordingly:
     - If opponent cooperated in the last round, reciprocate by cooperating as well. This reinforces mutual cooperation and reduces the likelihood of being exploited later.
     - If opponent defected in the last round, defect yourself to punish their defection. Punishing defection encourages opponents to cooperate in future rounds and makes it more difficult for them to exploit you consistently.
     - After initial deviations (if any), maintain this reciprocal behavior throughout the game.

2. Handle edge cases:
   - In the last round, cooperate to potentially secure a higher payoff from the remaining players who are still cooperating.
   - If an opponent switches their strategy in the middle of the game, analyze their new behavior and adjust your response accordingly.
   - Account for possible mistakes or deviations by opponents, and forgive them after a single incident. If they repeatedly deviate, revert to punishing defection.

3. Be exploitative:
   - By mimicking cooperative behavior but punishing defection, TfT+ is designed to encourage cooperation among opponents while also punishing those who attempt to exploit the strategy. This results in a higher average payoff compared to pure exploitation strategies.
   - To further increase its effectiveness against a wide range of opponent behaviors, TfT+ incorporates forgiveness for initial mistakes and flexibility in adapting to changes in opponent strategies. This adaptability allows it to thrive even when faced with unpredictable or complex opponents.

Pseudocode:

```python
def tit_for_tat_plus(opponent_history, round, n, k):
  if round == 1:
    action = 'C' # Cooperate in the first round
  elif len(opponent_history) > 0 and opponent_history[-1] == 'C':
    action = 'C' # Cooperate when opponent cooperated last round
  else:
    action = 'D' # Punish defection by defecting

  if round == r: # Last round, cooperate to potentially secure higher payoff
    action = 'C'

  return action
```
'''

description_EXPLOITATIVE_547 = '''
 Strategy Name: Tit-for-Tat with Cooperation Threshold (TFT-CT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TFT-CT strategy starts by cooperating in the first round to foster a cooperative environment, then adapts its cooperation based on the opponent's previous actions. If the opponent cooperates, the strategy continues to cooperate; if the opponent defects, it defects for a set number of rounds (punishment phase) and then reverts back to cooperating. The length of the punishment phase is determined by the Cooperation Threshold (CT), which is a variable that can be tuned based on the opponent's average cooperation rate over a certain period.

   Pseudocode for TFT-CT strategy:
   ```
   CT = 0.6 // Cooperation Threshold, adjustable parameter
   punishment_counter = 0

   function play_round(opponent_action):
       if round == 1:
           return cooperate()

       if opponent_action == cooperate():
           return cooperate()

       punishment_counter += 1
       if punishment_counter > CT * r: // r is the number of rounds
           punishment_counter = 0
           return cooperate()

       return defect()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The strategy starts by cooperating in the first round and continues cooperating as long as the opponent does so. In the last round, the TFT-CT strategy cooperates if it has not entered a punishment phase in the previous rounds. This allows for a final chance to build cooperation before the game ends.

3. Be exploitative - Clearly align with the exploitative mindset
   The TFT-CT strategy is designed to be exploitative by initially cooperating and punishing opponents who defect, thereby encouraging cooperation when possible. However, if an opponent consistently defects, the strategy will also defect in the long run to maximize its own payoff. The cooperation threshold allows for flexibility in adapting to various levels of opponent cooperation. By adjusting this parameter, a player can make the TFT-CT strategy more or less forgiving towards opponents who defect.

In summary, the TFT-CT strategy starts by cooperating, punishes defection with a variable punishment phase length, and seeks opportunities for cooperation when possible while still being exploitative. The cooperation threshold allows for tuning the strategy's adaptability to various opponent behaviors.
'''

description_EXPLOITATIVE_548 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly overture and allows for potential partners in subsequent rounds.
   - For rounds 2 to r-1, observe the actions of other players from the previous round and adjust contribution accordingly. If all opponents cooperated in the last round, also cooperate. If any opponent defected, defect in this round as a response. This tit-for-tat approach encourages reciprocity and discourages defection.
   - In the last round (r), cooperate regardless of the opponent's actions in the previous round to maximize potential payoff.

2. Edge Cases:
   - If an opponent has not played a single game (i.e., missed the first round), adopt the initial cooperative behavior as if it were the first round.
   - If an opponent plays sub-optimally, such as always cooperating or always defecting, maintain TfTAC strategy to encourage reciprocity and exploit non-adaptive opponents.

3. Exploitative Mindset:
   - By adapting contributions based on the actions of other players, TfTAC aims to maximize payoff through a balanced combination of cooperation and defection.
   - The strategy is designed to be robust against a wide range of opponent behaviors, including cooperative, defective, and mixed strategies.
   - By responding tit-for-tat to defection, the strategy discourages continuous defection and encourages reciprocity, making it less vulnerable to exploitation.

Pseudocode:

```
function TfTAC(round, history, k, n):
  if round == 1:
    contribute = True (cooperate)

  else if round < r:
    last_round_history = history[round - 1]
    all_cooperated = True if last_round_history.count(True) == n else False
    contribute = not last_round_history[current_player] or all_cooperated

  else:
    contribute = True

  if opponent missed a round:
    contribute = True in that round (act as if it were the first round)

  payoff = (1 - contribute) + (k/n) * sum(history[round])
  return payoff
```

This strategy balances cooperation and defection based on the actions of other players, aiming to maximize payoff while being robust against various opponent behaviors.
'''

description_EXPLOITATIVE_549 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFT-ACT strategy follows these steps:
   a. If it's the first round or if the opponent cooperated in the previous round, then cooperate (C).
   b. If the opponent defected in the previous round and the total number of cooperators in the last 'Cooperative Threshold' rounds is less than a predefined value (threshold), then also cooperate (C).
   c. Otherwise, defect (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   a. In the first round, since there's no history, the strategy cooperates as it treats the game as starting fresh each round.
   b. In the last round or any round near the end (r-10 rounds), the strategy defects since it wants to maximize its payoff before the game ends.

3. Be exploitative - Clearly align with the exploitative mindset
   The TFT-ACT strategy aims to extract as much benefit from the opponent as possible while minimizing the potential loss when the opponent cooperates. By defecting when the opponent consistently fails to cooperate, it encourages defection and maintains a higher average payoff than if it were always cooperative. However, by also cooperating when the opponent does so or in the hope that the opponent will cooperate in future rounds, it leaves room for potential exploitation should the opponent's behavior change.

Pseudocode:

```python
def TFT_ACT(r, n, k, threshold):
    current_round = 0
    previous_cooperation = False
    total_cooperation_count = 0

    while current_round < r:
        cooperate = False

        if current_round == 0 or previous_cooperation:
            cooperate = True

        if not cooperate and total_cooperation_count < threshold:
            cooperate = True

        payoff = (1 - cooperation) + (k / n) * sum(opponent_cooperation_history[current_round-10:current_round])
        total_game_payoff += payoff
        current_round += 1
        previous_cooperation = cooperation

    return total_game_payoff
```
'''

description_EXPLOITATIVE_550 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFT-AC initially cooperates and adjusts its contribution based on the opponents' cooperation history. The contribution level is a function of the average cooperation rate (CR) observed so far. If CR > 0.5, contribute at the maximum level (k); otherwise, contribute minimally (1).

   Pseudocode:
   ```
   if round == 1:
       contribution_level = k
   else:
       cooperation_rate = total_cooperators / number_of_rounds
       contribution_level = k if cooperation_rate > 0.5 else 1
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-AC cooperates to encourage others to do the same. As for the last round, TFT-AC follows its current contribution level determined by the opponents' cooperation history.

3. Be exploitative - Clearly align with the exploitative mindset
   While TFT-AC is not initially exploitative, it does adapt to the environment and responds to opponents' behaviors. If opponents consistently cooperate, TFT-AC will contribute more; if they defect, TFT-AC will also defect. In this way, TFT-AC aims to earn similar payoffs as its opponents while minimizing cooperation when others are not cooperating.

   It is important to note that TFT-AC does not aim for complete exploitation but rather a balanced approach that aligns with the game's nature of repeated interaction and common knowledge among players.
'''

description_EXPLOITATIVE_551 = '''
 Title: Tit-for-Tat-Greedy (TFT-G) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFT-G strategy follows these decision rules:
   - If a player has cooperated in all previous rounds (t-1), cooperate (C) in round t.
   - If a player has defected in any previous round (t-1), defect (D) in round t.
   - To be more exploitative, the strategy will also consider the total average contributions of opponents:
     - If the opponent's average contribution is less than the average minimum cooperation threshold (AMCT), defect (D).
     - If the opponent's average contribution is greater than or equal to the average maximum cooperation threshold (AMXT), cooperate (C).
     - Otherwise, if the opponent's average contribution falls between AMCT and AMXT, mimic their action from the previous round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, every player defects (D), as there is no history to base decisions on.
   - In the last round, the TFT-G strategy behaves like standard Tit-for-Tat: If a player has cooperated in all previous rounds, they will also cooperate in the last round; otherwise, they will defect.

3. Be exploitative - Clearly align with the exploitative mindset
   The TFT-G strategy is designed to be both cooperative when opponents are cooperative and exploitative when opponents are not. It maintains a balance between cooperation and defection by setting average minimum (AMCT) and maximum cooperation thresholds (AMXT). As AMCT increases, the strategy becomes more reluctant to cooperate with less cooperative opponents; as AMXT decreases, it becomes more willing to punish uncooperative opponents.

Pseudocode for TFT-G Strategy:

```
function get_average_contributions(opponent):
    total_contributions = 0
    for round in history:
        if opponent in round and round.action == 'C':
            total_contributions += 1
    return total_contributions / len(history)

function TFT_G_strategy():
    for round in game_rounds:
        if round == first_round:
            action = 'D'  # Everyone defects in the first round
        elif round == last_round:
            opponent_history = get_opponent_history()
            if all(action == 'C' for action in opponent_history):
                action = 'C'  # Cooperate if opponent has cooperated in all previous rounds
            else:
                action = 'D'  # Defect if opponent has not cooperated in any previous round
        else:
            my_actions = get_my_history()
            opponent_contributions = get_average_contributions(get_opponent())

            if all(action == 'C' for action in my_actions):  # If I have cooperated in all previous rounds
                if opponent_contributions >= AMXT:  # Cooperate if opponent is highly cooperative
                    action = 'C'
                elif opponent_contributions <= AMCT:  # Defect if opponent is not at all cooperative
                    action = 'D'
                else:  # Mimic the opponent's action from the previous round
                    action = my_actions[len(my_actions) - 1]
            elif any(action == 'C' for action in my_actions):  # If I have cooperated but not always
                if opponent_contributions >= AMXT:  # Cooperate if opponent is highly cooperative
                    action = 'C'
                else:  # Mimic the opponent's action from the previous round
                    action = my_actions[len(my_actions) - 1]
            else:  # If I have not cooperated at all
                if opponent_contributions <= AMCT:  # Defect if opponent is not at all cooperative
                    action = 'D'
```
'''

description_EXPLOITATIVE_552 = '''
 Title: Tit-for-Tat-Gradient (TfTG) Strategy for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TfTG strategy follows a tit-for-tat approach, but with a gradient that makes it more responsive to the average cooperation rate in the game. In each round t:
   - If the total number of cooperators (total_contributions) in the previous round is greater than or equal to a threshold (average_cooperation), cooperate (C).
   - If the total number of cooperators in the previous round is less than average_cooperation, defect (D). The average_cooperation is calculated as follows:
     average_cooperation = k / n for the first round and average_cooperation from the previous round thereafter.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate since average_cooperation has not been calculated yet, but set it to k/n for subsequent rounds.
   - In the last round, use the same decision rules as previous rounds, even though there will be no next round to impact.

3. Be exploitative - Clearly align with the exploitative mindset
   The TfTG strategy aims to maximize payoff while being responsive to others' cooperation levels. By cooperating when the majority cooperates and defecting otherwise, it encourages higher cooperation rates among opponents. However, if most players are consistently defecting, the strategy will also switch to defection to avoid losing too much. The gradient in the decision rule makes the strategy more adaptable and robust against a wide range of opponent behaviors.

Pseudocode:
```
def TitForTatGradient(total_contributions_previous, average_cooperation):
    if round == 1:
        average_cooperation = k / n

    action = 'C' if total_contributions_previous >= average_cooperate else 'D'
    return action
```
'''

description_EXPLOITATIVE_553 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the ATFT strategy cooperates (plays C) if and only if the previous player's action was also cooperation (C). Otherwise (if the previous player played D), it will defect (play D) in the current round. This simple rule mimics a "friendly" approach to cooperation, but punishes defection with defection as well.

Pseudocode:
```
function ATFT(t, previous_action):
    if previous_action == 'C':
        return 'C'  # Cooperate
    else:
        return 'D'  # Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, there is no previous action, so it will be treated as a default cooperation to promote mutual understanding and potential coordination among players. For the last round, ATFT will continue with its strategy since the game structure assumes repeated interaction over multiple rounds (r > 1).

3. Be exploitative - Clearly align with the exploitative mindset
   The Adaptive Tit-for-Tat strategy is designed to be cooperative when others are cooperating and punitive when others defect, which can be considered a form of exploitation in the sense that it takes advantage of cooperative players while only being cooperative itself if others do so as well. In this game, cooperation allows for higher payoffs due to the public goods aspect, and by taking advantage of other cooperators' contributions, ATFT maximizes its own benefits while minimizing losses from defection.

In summary, the Adaptive Tit-for-Tat strategy can be seen as a simple yet effective approach in this Public Goods game. It promotes cooperation when others do so but punishes defection with defection, making it difficult for opponents to exploit and potentially fostering the emergence of coordination among players.
'''

description_EXPLOITATIVE_554 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TFTAC strategy follows these decision rules:

- Initially, in the first round, cooperate (C). This is a gesture of goodwill and encourages cooperation from others.
- For subsequent rounds, analyze the history of opponents' actions to decide whether to cooperate or defect.
  - If opponent has always cooperated up to round t-1, cooperate (C) in round t as well.
  - If opponent has ever defected before, defect (D) in round t if there are more defectors than cooperators in the history leading up to this round. If not, continue cooperating (C).
  - If the number of opponents is equal to the multiplication factor k, and at least one opponent has ever defected, always defect (D). This ensures that the TFTAC strategy remains exploitative by taking advantage of the larger group when possible.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round, cooperate (C) as mentioned earlier.
- In the last round, if there are more defectors than cooperators in the history, defect (D). Otherwise, continue cooperating (C).
- If a player misses any rounds due to errors or interruptions, they should cooperate in their first available round after rejoining the game.

3. Be exploitative - Clearly align with the exploitative mindset:

The TFTAC strategy is inherently exploitative by defecting when there are more cooperators than defectors in its history, while also being adaptive to opponent behavior over multiple rounds. By initially cooperating and then imitating the opponents' actions, TFTAC can take advantage of other strategies that rely on cooperation or exploitation. However, if a larger group (k) of opponents exhibits exploitative behavior, TFTAC will defect as well to maximize its own payoff.
'''

description_EXPLOITATIVE_555 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-A starts by cooperating in the first round to signal goodwill and establish a potential cooperation partner. After that, it follows the "Tit for Tat" principle: if an opponent has cooperated in the previous round, TFT-A will cooperate; otherwise, it will defect. This encourages reciprocation while still maintaining some self-protection against continuous defection by opponents.

   In addition, to adapt to various opponent behaviors and exploit them when possible, TFT-A includes a learning component. It keeps track of the average cooperation rate (average_cooperation) of each opponent across rounds. If an opponent's average cooperation rate drops below a certain threshold (e.g., 0.5), TFT-A assumes the opponent is not cooperative and will defect against them from that point onwards. On the other hand, if an opponent's average cooperation rate exceeds another threshold (e.g., 0.8), TFT-A considers this opponent as a reliable cooperator and continues to cooperate with them.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-A will cooperate regardless of the opponent's behavior since it wants to establish a potential cooperation partner. At the last round (r), there is no need for continued reciprocation because the game ends soon; however, if the opponent has been cooperating throughout the game, TFT-A will also cooperate at the end as a gesture of goodwill.

3. Be exploitative - Clearly align with the exploitative mindset
   While TFT-A is not designed to be explicitly exploitative towards others from the beginning, it maintains self-protection by defecting against opponents who show consistently uncooperative behavior over time. It adapts its strategy based on the average cooperation rate of each opponent and aims to maximize its payoff by cooperating with reliable partners and defecting against unreliable ones. This approach allows TFT-A to potentially exploit opponents while still maintaining a cooperative stance when beneficial.
'''

description_EXPLOITATIVE_556 = '''
 Strategy Name: Tit-for-Tat (with Adaptation)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round (to avoid appearing overly aggressive and potential partners may reciprocate).
   - For subsequent rounds, observe the behavior of other players in the previous round:
     - If all opponents cooperated in the previous round, cooperate in the current round.
     - If any opponent defected in the previous round, also defect in the current round (punishing defection).
     - If some opponents cooperated and others defected in the previous round, copy the action of the majority.
       If there is a tie, default to cooperation to encourage collaboration.

2. Handle edge cases:
   - Last Round: Since there are no future rounds, defect in the last round to maximize private payoff regardless of opponents' actions.
   - First Round: Cooperate as described above.

3. Be exploitative - Align with an exploitative mindset by adopting a punitive approach towards defection and encouraging cooperation for mutual benefit.

Pseudocode:

```python
def tit_for_tat(round, history):
  if round == 1:
    action = "C"  # Cooperate in the first round
  elif round < r:  # Adaptive strategy for subsequent rounds
    total_coop = sum([1 for entry in history if entry == "C"])
    if total_coop == len(history):
      action = "C"  # All opponents cooperated, so cooperate too
    elif total_coop > 0 and len(history) - total_coop >= total_coop:
      action = "C"  # Majority of opponents cooperated, so cooperate too
    elif total_coop == 0 or total_coop < len(history) - total_coop:
      action = "D"  # Majority of opponents defected, so defect
    else:
      action = "C"  # Tie-break in favor of cooperation to encourage collaboration
  return action
```
'''

description_EXPLOITATIVE_557 = '''
 In this N-Player Public Goods Game, we'll design a strategy named "Tit for Tat with Adjustment (TfTA)." The TfTA strategy is designed to be exploitative while maintaining robustness against various opponent behaviors.

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = C) to facilitate a potentially collaborative environment. Subsequent actions will depend on opponents' behavior.
   - In subsequent rounds, if all players cooperate (total_contributions = n), continue cooperating (c_i = C). If any player defects, also defect in the next round (c_i = D) as a punishment for the defection.
   - After punishing, revert to cooperation once again (c_i = C) in hopes that opponents will return to cooperating. This cycle of cooperation and punishment continues throughout the game.
   - If an opponent consistently defects, adjust the likelihood of cooperation based on their history of defections:
      1. If more than 60% of an opponent's previous actions were defective, there is a higher probability that c_i = D in future rounds (punish more frequently).
      2. If less than or equal to 40% of an opponent's previous actions were defective, there is a higher likelihood that c_i = C in future rounds (continue cooperating more often).
   - In the final round, since there are no subsequent rounds for punishment and reward, cooperate if it results in a higher payoff compared to defecting.

2. Handle edge cases:
   - In the first round, always cooperate (c_i = C) as a goodwill gesture.
   - If an opponent does not have any previous actions (e.g., the first encounter), assume that they will cooperate and follow the general decision rules accordingly.
   - In the last round, calculate the payoff for both cooperation and defection, and choose the action that results in a higher payoff.

3. Be exploitative:
   - The TfTA strategy is inherently exploitative by punishing opponents who defect and rewarding those who cooperate. By adjusting the likelihood of cooperation based on an opponent's history, the strategy takes advantage of cooperative players while minimizing losses against defectors. This results in a higher average payoff compared to more altruistic strategies.
   - The punishment phase ensures that opponents do not benefit from continual defection, discouraging such behavior and encouraging cooperation whenever possible.
   - The reversion to cooperation after punishing serves as a signal of goodwill and an opportunity for opponents to resume cooperative behavior. However, if the opponent continues to defect, the TfTA strategy adjusts its future actions accordingly, making it less likely to cooperate with uncooperative players.
'''

description_EXPLOITATIVE_558 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Decision Rules:
   - In the first round, cooperate to show goodwill and encourage cooperation from others.
   - For subsequent rounds, mimic the actions of the most common action taken by opponents in the previous r rounds (k-round memory). If the most common action is equal among multiple options, choose the action that has been the most beneficial in the recent past.
   - If an opponent defects after cooperating for a while, TFT-A will also defect in the next round to punish the opponent and encourage future cooperation if they return to cooperating.
   - If an opponent has never cooperated, TFT-A will continue not to cooperate as there is no reason to change strategy based on past non-cooperative behavior.

2. Handle Edge Cases:
   - In the last round, TFT-A will choose the action that has been the most beneficial in the recent past, given the current situation and the history of interactions with each opponent.
   - In the first round, TFT-A cooperates regardless of any prior interactions since this is the initial round of the game.

3. Exploitative Mindset:
   - By mimicking the most common action taken by opponents in the previous r rounds, TFT-A takes advantage of cooperation when opponents are willing to contribute to the community project and punishes defection with strategic retaliation. This encourages opponents to cooperate more frequently while also discouraging excessive defecting.
   - The strategy is adaptive, allowing it to respond effectively to a wide range of opponent behaviors and exploit inconsistency or greed in their strategies.

Pseudocode:
```python
def TFT_A(n, r, k, history):
    memory = [0 for _ in range(r)] # k-round memory
    benefits = [0 for _ in range(2)] # tracks benefit of C and D actions

    def get_most_common():
        counts = Counter(history[-r:])
        max_count, most_common = max((v, k) for k, v in counts.items())
        return most_common

    def get_best_action():
        if benefits[0] > benefits[1]: # C was more beneficial
            return 'C'
        elif benefits[0] < benefits[1]: # D was more beneficial
            return 'D'
        else: # equal benefit, choose most common action from memory
            most_common = get_most_common()
            if most_common == 'C':
                return 'C'
            else:
                return 'D'

    # first round, cooperate to encourage cooperation
    strategy = 'C'
    benefits[0] += (k/n) * len(history[-r:]) - 1
    history.append(strategy)

    for t in range(1, r + 1):
        opponent_action = history[-t - 1] # get action from previous round
        strategy = get_best_action() # choose best action based on memory and benefits

        # update memory with current action
        memory[t-1] = strategy

        # update benefits based on current payoff
        payoff = (1 - strategy == 'D') + (k/n) * len([1 for s in history[-r:] if s == 'C'])
        benefits[strategy == 'C'] += payoff - benefits[strategy == 'C']

    # last round, choose best action based on current situation and memory
    strategy = get_best_action()

    return strategy for r rounds
'''

description_EXPLOITATIVE_559 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution Rate (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, starting from t=2 and ending at t=r, the TFTAC strategy will cooperate if the majority of players (more than (n-1)/2) contributed in the previous round t-1. If the majority did not contribute, the TFTAC strategy will defect.

For the first round (t=1), all players will randomly choose between cooperation and defection with a probability equal to their contribution rate (cr).

```python
def play_round(previous_contributions, cr):
    if len(previous_contributions) > (n-1):  # majority contributed last round
        return "C"  # cooperate
    else:
        return "D"  # defect

def first_round(cr):
    return random.choice(['C', 'D']) if random.random() < cr else 'C'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round (t=1), TFTAC will randomly decide between cooperation and defection with a probability equal to its contribution rate (cr). For the last round (t=r), TFTAC will contribute if it has observed more cooperators in previous rounds than non-contributors, regardless of its own past contributions.

```python
def first_round(cr):
    return random.choice(['C', 'D']) if random.random() < cr else 'C'

def last_round(past_contributions):
    cooperators = sum([1 for contrib in past_contributions if contrib == 'C'])
    non_contributors = len(past_contributions) - cooperators
    return "C" if cooperators > non_contributors else "D"
```

3. Be exploitative - Clearly align with the exploitative mindset

TFTAC is an exploitative strategy because it punishes non-cooperative behavior by not contributing itself, but it also rewards cooperation by reciprocating with contributions when the majority of players cooperate in the previous round. However, TFTAC can be vulnerable to aggressive strategies that initially appear cooperative but later switch to defection after the majority has cooperated.

To improve its resilience, TFTAC can employ an adaptive contribution rate (cr) that gradually increases over time if it observes a trend of more cooperators in the previous rounds and decreases if it notices a trend of more non-contributors. This adaptation allows TFTAC to adjust its level of cooperation based on the behavior of other players without compromising its exploitative nature.

```python
def update_contribution_rate(past_contributions, cr):
    cooperators = sum([1 for contrib in past_contributions if contrib == 'C'])
    non_contributors = len(past_contributions) - cooperators
    cooperation_trend = (cooperators + 1) / (len(past_contributions) + 2) - cr
    cr += adaptation_rate * cooperation_trend
    if cr < MIN_CR:
        cr = MIN_CR
    elif cr > MAX_CR:
        cr = MAX_CR
    return cr
```

In this pseudocode, `adaptation_rate` is a hyperparameter that determines the speed at which TFTAC adjusts its contribution rate, and `MIN_CR` and `MAX_CR` are other hyperparameters that limit the minimum and maximum contribution rates. The additional line of code at the end ensures that the contribution rate remains within a reasonable range.
'''

description_EXPLOITATIVE_560 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Factor (TFT-ACF)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a peaceful gesture to encourage cooperation from opponents.
   - For rounds t > 1, if an opponent cooperated in the previous round (t-1), cooperate (C); otherwise, defect (D). This rule mimics the Tit-for-Tat strategy while introducing adaptability by adjusting the cooperative tendency based on the average cooperation rate observed so far.
   - The Cooperative Factor (CF) is a variable that reflects the cooperative tendency of the TFT-ACF strategy, which ranges between 0 and 1. Initially, CF = 1.
   - If the average cooperation rate over the last k rounds is greater than a threshold (defined as CF), then increase CF by a small increment. Conversely, if the average cooperation rate over the last k rounds is less than CF/2, then decrease CF by a small decrement.
   - To calculate the Cooperative Factor (CF) at round t:
     ```
     CF = CF * ((average_cooperation_rate_last_k_rounds(t) - CF / 2) / k) + (1 - CF) * (1 - average_cooperation_rate_last_k_rounds(t))
     ```
   - The strategy will continue to cooperate when the opponent also cooperates, but the CF adjustment based on the average cooperation rate makes it more adaptive and responsive to changes in the opponents' behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, cooperate (C).
   - In the last round, if the average cooperation rate over the last k rounds is greater than a predefined threshold (e.g., 0.5), then cooperate (C); otherwise, defect (D). This encourages cooperation towards the end of the game when players might want to maximize their payoffs.

3. Be exploitative - Clearly align with the exploitative mindset
   - By starting with a high CF and adjusting it based on the average cooperation rate over the last k rounds, the TFT-ACF strategy is able to capitalize on cooperative opponents while still punishing non-cooperative ones. The strategy aims to benefit from cooperators while minimizing losses against defectors.
   - If the average cooperation rate remains low throughout the game, the CF will decrease, causing the TFT-ACF strategy to defect more often and exploit the non-cooperative opponents.
   - However, if the average cooperation rate increases significantly, the CF will also increase, making the strategy more likely to cooperate and benefit from other players' contributions.
   - The key aspect of this strategy is its ability to adapt and adjust its behavior based on the observed actions of its opponents, striking a balance between exploitation and cooperation.
'''

description_EXPLOITATIVE_561 = '''
 Title: Tit-for-Tat Strategy with Adaptive Contribution (TFTAC) for N-Player Public Goods Game

1. Specify decision rules:
   - In the initial round (t=1), cooperate (play C). This is a gesture of goodwill and allows others to potentially benefit from your contribution.
   - For subsequent rounds, if an opponent cooperated in the previous round (t-1), cooperate in the current round (t). If an opponent defected in the previous round (t-1), also defect in the current round (t). This mimics a trusting and retaliatory behavior, which encourages cooperation when others are cooperative but punishes defection.
   - Adaptive Contribution: In each round, adjust the contribution level (c_i) based on the total number of cooperators in the previous round (total_contributions_t-1). If total contributions were high, decrease your contribution slightly to maintain a balance between personal gain and community contribution. If total contributions were low, increase your contribution slightly to encourage others to cooperate.
   - A simple heuristic for adjusting contribution level could be:
     ```python
     if total_contributions_t-1 > (n/2):
       k_adjustment = 0.85
     elif total_contributions_t-1 < (n/4):
       k_adjustment = 1.15
     else:
       k_adjustment = 1
     c_i = (k_adjustment / n) * total_contributions_t-1
     ```

2. Handle edge cases:
   - Last round (r): Since there are no further rounds to retaliate, cooperate regardless of the previous opponent's action in the last round (t=r-1).
   - First round (t=1): Cooperate as a goodwill gesture and to encourage others to do the same.

3. Be exploitative:
   - The strategy is exploitative by nature, as it cooperates when others do so but retaliates with defection when others defect. By adjusting contribution levels based on total contributions in previous rounds, it manipulates the public good system to its advantage while still maintaining a cooperative appearance.
   - The adaptive contribution feature allows the strategy to be more resilient against different opponent behaviors and potentially outperform simpler strategies in the long run.
'''

description_EXPLOITATIVE_562 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfTA)

1. Specify decision rules:
   - Initially (in the first round), cooperate to show a peaceful intent and encourage cooperation from others. (C)
   - For subsequent rounds, analyze the opponent's previous actions and adopt the Tit-for-Tat strategy:
      - If opponent cooperated in the previous round, cooperate as well. (C)
      - If opponent defected in the previous round, defect to punish the opponent. (D)
   - To avoid being exploited by overly aggressive opponents, add an adaptation mechanism:
      - If opponent defects after a period of cooperation, change strategy to Defect-until-Cooperated-With (DuCw). In this state, continue defecting until the opponent cooperates twice in a row, then return to the original Tit-for-Tat strategy.
      - If opponent cooperates after a period of defection, return to the original Tit-for-Tat strategy.
   - To prevent getting stuck in the DuCw state for too long, implement a time limit or a minimum number of consecutive cooperation rounds before returning to TfT.

2. Handle edge cases:
   - In the last round, cooperate regardless of the opponent's previous action as the game is nearly over and the opponent may still benefit from cooperation. (C)
   - For the initial round (n=1), the strategy has no opponent to interact with, so it starts by cooperating as a goodwill gesture before entering a loop of TfT or DuCw based on subsequent rounds' interactions.

3. Be exploitative:
   - The TfTA strategy prioritizes personal gain while maintaining an initial peaceful front to encourage cooperation from opponents. However, if the opponent does not cooperate, it will adopt a punishing measure (DuCw) and only return to cooperation after being coerced into it. This ensures that the strategy can withstand aggressive opponents without sacrificing too much in terms of personal gain.
   - By incorporating adaptation and edge case handling, TfTA becomes a versatile exploitative strategy that performs well against a wide range of opponent behaviors while still maintaining a cooperative demeanor when appropriate.
'''

description_EXPLOITATIVE_563 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to establish a peaceful atmosphere and potential trust among opponents (C).
   - For subsequent rounds:
     - If an opponent cooperated in the previous round, reciprocate with cooperation in the current round (C).
     - If an opponent defected in the previous round, defect in the current round as retaliation (D).
     - If there's no previous history with a particular opponent, always cooperate to encourage cooperation (C).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate unconditionally as explained above.
   - In the last round, consider the total number of opponents that have cooperated and defected so far. If there are more cooperators than defectors, reciprocate with cooperation (C). Otherwise, defect (D) to punish those who failed to cooperate.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially, TFT-AC is cooperative to take advantage of other cooperators by benefiting from the public good and encouraging cooperation among opponents.
   - When faced with defectors, it retaliates with defection to punish them and avoid being exploited.
   - If an opponent starts with cooperation but later switches to defection, TFT-AC continues to reciprocate defections indefinitely, potentially forcing the defector back into cooperation due to the repeated interaction and the possibility of future benefits from the public good.

Pseudocode:

```python
def TFT_AC(opponent_history, n_rounds, k, n):
    current_round = 1
    cooperation_count = 0
    opponent_cooperated_last_round = False

    while current_round <= n_rounds:
        if current_round == 1:
            action = "C"  # Cooperate in the first round
        else:
            opponent_cooperated_last_round = is_opponent_cooperated(opponent_history, current_round - 1)

            if opponent_cooperated_last_round:
                action = "C"  # Cooperate if opponent cooperated in the previous round
            elif len(get_cooperators(opponent_history)) > len(get_defectors(opponent_history)):
                action = "C"  # Cooperate if there are more cooperators than defectors so far
            else:
                action = "D"  # Defect otherwise

        take_action(action)  # Perform the chosen action
        update_opponent_history(action, current_round)  # Update the opponent history
        current_round += 1

    if current_round == n_rounds and len(get_cooperators(opponent_history)) > len(get_defectors(opponent_history)):
        action = "C"  # Cooperate in the last round if there are more cooperators than defectors
    else:
        action = "D"  # Defect in the last round otherwise

    take_action(action)  # Perform the chosen action in the last round
```
'''

description_EXPLOITATIVE_564 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C in round 1). This is a peace offering to potential allies.
   - From round 2 until the last round, maintain cooperation if the number of cooperators in the previous round is greater than or equal to a certain threshold (T). Otherwise, defect (D). The adaptive threshold T can be calculated using the following formula:
     ```python
     T = floor((n * k + 1) / 2) - int((r - 1) / 2)
     ```
   - In this formula, 'floor' rounds down to the nearest integer and 'int' functions as a standard integer function. The threshold T decreases over time as the game progresses, encouraging cooperation in earlier rounds but becoming more exploitative later on. The initial value of T is calculated to ensure a majority of players are cooperating in the first few rounds based on the number of players (n) and multiplication factor (k).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of other player's actions due to TFT-ACT's initial cooperative nature.
   - If r is odd, there will be no last round; otherwise, in the penultimate round, follow the decision rule as usual (i.e., if T >= number of cooperators in the previous round, cooperate; otherwise, defect). In the final round, always cooperate since there are no further rounds to retaliate.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFT-ACT's adaptive cooperation threshold allows it to adjust its level of cooperation based on game parameters and history, making it more likely to exploit opponents who consistently defect by only cooperating when necessary for mutual benefit. As the game progresses and the threshold decreases, TFT-ACT becomes less forgiving towards those who do not contribute to the public good.
   - While TFT-ACT does initially cooperate as a peace offering, its adaptive nature allows it to respond strategically to opponents' actions, making it well-suited for an exploitative strategy.
'''

description_EXPLOITATIVE_565 = '''
 Strategy Name: Tit-for-Tat with Modified Cooperation Threshold (TTMCT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (to promote cooperation and avoid being seen as aggressive).
   - For subsequent rounds, evaluate the number of cooperators in the previous round (n_coop_t-1) and compare it to a predefined cooperation threshold (ct). If n_coop_t-1 >= ct, cooperate; otherwise defect. The cooperation threshold adapts dynamically based on the average number of cooperators over the last m rounds (ct_t = ct_t-1 + α * (n_coop_t-m - ct_t-1)), where α is a learning rate that determines the speed at which the threshold adjusts.
   - If the game enters its final round, cooperate regardless of previous actions to maximize potential payoff.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, cooperate to potentially gain a higher payoff from the cooperative players.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially cooperating and then adjusting the cooperation threshold based on observed behavior encourages other players to cooperate, as they will benefit if most other players are also cooperative. However, if others defect, the strategy will gradually increase its own defection rate (by increasing the cooperation threshold), aiming to exploit the lack of cooperation from others while maintaining some level of cooperation when it is advantageous (i.e., when the number of cooperators is high).
   - The learning rate α determines how quickly the strategy adapts to its environment, allowing for a balance between being adaptive and exploitative based on the observed behavior of other players.
'''

description_EXPLOITATIVE_566 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, cooperate (C). This is a peace offering to potential partners and sets a cooperative tone for the game.
   - For subsequent rounds t > 1, if the opponent cooperated in the previous round (t-1), cooperate; if the opponent defected, defect in response. The strategy mimics cooperative behavior but retaliates against defection.
   - If the total number of opponents who have cooperated at any point during the game exceeds the average number of cooperators per round (n*k/r), contribute less (lower k-factor) to the public good in future rounds to conserve resources for punishing defection. This adaptive contribution ensures that the strategy does not overinvest in the public good when it is likely to be exploited by too many opponents.
   - If the total number of opponents who have defected at any point during the game exceeds the average number of cooperators per round (n*k/r), contribute more (higher k-factor) to the public good in future rounds to maximize benefits from potential partners and punish the opponents who defected.
   - In the last round, defect regardless of the opponent's previous action, as there are no further opportunities for retaliation or cooperation.

2. Handle Edge Cases:
   - If r < n*k, adjust the contribution factor (k) to equal r/n. This ensures that the strategy does not exceed the available resources in the game and avoids division by zero errors.
   - In the first round, if more than half of the opponents (n*k/2) cooperate, set k = n*k/2 for the remaining rounds to maximize contributions to the public good when it is likely to benefit from cooperation.
   - If less than half of the opponents (n*k/2) cooperate in the first round, set k = 1 for the remaining rounds to avoid wasting resources on a potentially uncooperative opponent group.

3. Be Exploitative:
   - The strategy is exploitative by retaliating against defection with defection and adjusting contributions to maximize personal benefit based on observed cooperative behavior among opponents. By selectively cooperating and adjusting the contribution factor, TFTAC can achieve higher payoffs than less adaptive strategies, especially in games with a large number of players or repeated interactions.
   - The strategy's exploitative nature is further emphasized by its ability to conserve resources when it detects a high likelihood of defection from the opponents, thereby minimizing potential losses due to exploitation. Conversely, it maximizes contributions when cooperation appears likely, aiming to take advantage of potential partners.

Pseudocode for TFTAC:
```
def TFTAC(opponents, r, n, k):
    strategy_contributions = [0] * r
    average_cooperators = (n * k) / r
    opponents_who_cooperated = 0
    opponents_who_defected = 0

    def play_round(opponents_actions, round):
        if round == 1:
            contribution = int(k)
            opponents_who_cooperated += sum(opponents_actions)
            strategy_contributions[round] = contribution
            return contribution, opponents_actions

        contribution = 0
        if all(x == 0 for x in opponents_actions):  # Everyone defected last round
            if opponents_who_defected > average_cooperators:
                k *= 1.5
            contribution = int(k)
            opponents_who_defected += sum(opponents_actions)
        elif all(x == 1 for x in opponents_actions):  # Everyone cooperated last round
            if opponents_who_cooperated > average_cooperators:
                k /= 1.5
            contribution = int(k)
            opponents_who_cooperated += sum(opponents_actions)
        strategy_contributions[round] = contribution
        return contribution, opponents_actions

    for round in range(1, r + 1):
        opponent_actions = [0 if x < round else x % 2 for x in opponents]
        strategy_contribution, _ = play_round(opponent_actions, round)
        payoff = (1 - strategy_contribution) + (k / n) * sum(opponent_actions)
        print("Round:", round, ", Contribution:", strategy_contribution, ", Payoff:", payoff)
```
'''

description_EXPLOITATIVE_567 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFTAT strategy follows a tit-for-tat approach, cooperating in the first round and mimicking the opponents' behavior in subsequent rounds. However, to add adaptability and robustness, it introduces an adjustable cooperation threshold (CT). In each round, if more than CT percentage of players cooperate, the agent will also cooperate; otherwise, it will defect.

Pseudocode:
```
def TFTAT(n, k, r, CT):
  rounds = []

  for t in range(1, r+1):
    if t == 1:
      contribution = Cooperate() # Default to cooperation in the first round
    else:
      total_contributions = count_cooperators(t-1)
      contributions = more_than_threshold(total_contributions, CT)
      contribution = contributions[agent_index]

    payoff = calculate_payoff(contribution, total_contributions, n, k)
    rounds.append((t, contribution, payoff))

  return rounds

def Cooperate():
  # Default action for the first round and in case of uncertainty
  return True

def count_cooperators(round):
  total = sum([players[i].contribution for i in range(1, n+1) if players[i].contribution])
  return total

def more_than_threshold(total, CT):
  # Determine contribution based on cooperation threshold
  if total > (CT * n):
    return [True] * n
  else:
    return [False] * n

def calculate_payoff(contribution, total_contributions, n, k):
  # Calculate payoff based on the game structure and contribution
  private_payoff = (1 - contribution)
  public_good = (k / n) * total_contributions
  return private_payoff + public_good
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The strategy is designed to handle these edge cases by default as follows:
- First round: Cooperate (as a peace offering)
- Last round: The agent will cooperate if more than CT percentage of players cooperated in the previous round; otherwise, it will defect (to avoid being taken advantage of at the end)

3. Be exploitative - Clearly align with the exploitative mindset

The TFTAT strategy is designed to be exploitative by mimicking opponents' behavior and only cooperating when it benefits the agent. However, by adjusting the cooperation threshold, the agent can fine-tune its level of cooperation to maximize payoff against a wide range of opponent behaviors. A lower CT encourages more cooperation, while a higher CT encourages more defection. This adaptability allows the TFTAT strategy to exploit opponents who consistently cooperate or defect without adapting their behavior.
'''

description_EXPLOITATIVE_568 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules:
   - In the first round, cooperate (C). This allows for potential partners to build trust and encourages cooperation in subsequent rounds.
   - For all other rounds, follow the majority action of the previous round. If the majority contributed (total_contributions > n/2), cooperate; otherwise, defect.
   - If total_contributions == n or total_contributions == 0, continue cooperating or defecting respectively, as these extreme cases indicate a stable cooperation or defection equilibrium.

2. Handle edge cases:
   - In the last round, cooperate if the current strategy has been beneficial (total payoff > r/2); otherwise, defect to maximize final payoff.

3. Be exploitative:
   - While TFT-A is not inherently exploitative in this game, its adaptive nature allows it to punish defectors and leverage cooperators, making it less vulnerable to being exploited by other strategies. This strategy maintains cooperation when possible but switches to defection if others are consistently defecting, thereby punishing such behavior.
   - In the presence of cooperative opponents, TFT-A will also cooperate; however, if there is a shift in their behavior towards defection, TFT-A will react and respond by defecting as well, using cooperation only when it's reciprocated.

Pseudocode:
```
function TFT_A(n, r, k):
    strategy = {"cooperate": 1, "defect": 0} # initialize with cooperate
    payoff = 0
    contributions = [] # store total contributions per round

    for round in range(r):
        if round == 1:
            strategy["action"] = "cooperate"
        else:
            strategy["action"] = calculate_majority()

        if strategy["action"] == "cooperate":
            payoff += (1 - strategy["action"]) + (k / n) * sum(contributions[round])
            contributions.append(sum([1 for a in strategies if a["action"] == "cooperate"]))
        else:
            payoff += 1
            contributions.append(0)

    if payoff > r/2:
        strategy["action"] = "cooperate" # last round, cooperate if strategy has been beneficial so far

    return strategy

function calculate_majority():
    total_contributions = sum(contributions)
    if total_contributions == n or total_contributions == 0:
        return "cooperate" if total_contributions > n/2 else "defect"
    elif total_contributions > n/2:
        return "cooperate"
    else:
        return "defect"
```
'''

description_EXPLOITATIVE_569 = '''
 Title: Tit-for-Tat Strategy (TFT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C). This helps build trust and can encourage cooperation in subsequent rounds.
   - For all subsequent rounds, replicate the actions of the other players from the previous round (Mirroring). If all players cooperated in the previous round, cooperate again; if any player defected, also defect. This strategy ensures a balance between cooperation and punishment, creating an opportunity for long-term mutual benefits.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, initiate cooperation (C) as mentioned above.
   - For the last round, replicate the actions of the players from the second-to-last round to avoid being exploited by defectors at the end. If all players cooperated in the second-to-last round, cooperate again; if any player defected, also defect.

3. Be exploitative - Clearly align with the exploitative mindset
   - While TFT is generally considered a cooperative strategy, it has an exploitative aspect by punishing defection and rewarding cooperation. By mirroring the actions of others, the strategy can take advantage of short-term opportunistic behavior while maintaining long-term cooperation when appropriate. This approach aims to maximize payoff against a wide range of opponent behaviors, including both cooperative and exploitative strategies.

Pseudocode:
```
function TFT(round: int, history: list[int], k: float, n: int) {
  if round == 1 {
    action = C
  } else {
    last_round = history[round - 1]
    action = last_round
  }

  total_contributions = sum(history[round])
  payoff = (1 - action) + (k / n) * total_contributions
  return payoff
}
```
'''

description_EXPLOITATIVE_570 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i starts by cooperating (C) if it's the first round or if they have previously cooperated and encountered cooperation from all other players in the previous round (t-1). If any of the following conditions are met, player i will defect (D):
- Player i was previously defected upon by at least one player in the last round (t-1)
- Player i has not previously cooperated with all other players and encounters at least one defector in the current round (t)

Pseudocode:
```
function ATFT(round, own_action_history, others_action_history):
  if round == 1:
    return Cooperate

  previous_round = round - 1

  if all(others_action_history[previous_round]) == Cooperate and own_action_history == [Cooperate]:
    return Cooperate

  if any(others_action_history[previous_round]) != Cooperate or (not own_action_history):
    return Defect

  return own_action_history[-1]  # Continue with previous action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

As specified above, ATFT cooperates in the first round and does not explicitly consider the last round since it is part of a repeated game. The strategy will adapt to different numbers of rounds (r) due to its adaptive nature.

3. Be exploitative - Clearly align with the exploitative mindset

ATFT has an exploitative aspect by taking advantage of other players' initial cooperation, but it also exhibits forgiving behavior by continuing to cooperate if all opponents have cooperated in the previous round. However, once a defection is encountered, ATFT will retaliate with defection until the opponent demonstrates reliable cooperation again. This strategy aims to encourage cooperation while penalizing defectors, promoting a balanced mix of selfish and cooperative behavior.
'''

description_EXPLOITATIVE_571 = '''
 In this strategic game, we aim to design an exploitative strategy (Tit-for-Tat+) that can adapt to a wide range of opponent behaviors while maintaining a slight advantage over time. The strategy is inspired by the classic Tit-for-Tat strategy but with some modifications to account for cooperative and exploitative tendencies.

1. Specify decision rules:
   - Cooperate in the first round (F) and last round (L).
   - In all other rounds, observe the previous round's behavior of all opponents (O), and respond as follows:
      - If all opponents cooperated in the previous round (C_all), cooperate this round.
      - If at least one opponent did not cooperate in the previous round (D_any), defect this round.
   - If opponent(s) switch between cooperation and defection, the strategy will mimic their recent behavior (M).

Pseudocode:
```python
def tit_for_tat_plus(round, history):
  if round == 1 or round == r:
    action = 'C' # Cooperate in the first and last rounds
  else:
    all_cooperated = True for c in history[-1] if c == 'C'
    recent_action = 'C' if all_cooperated else 'D'
    strategy_history = [recent_action] # Mimic the most recent behavior
    for h in history:
      if 'D' in h and len(strategy_history) > 1:
        recent_action = strategy_history[-1]
        break
    action = recent_action
  return action
```

2. Handle edge cases:
   - The strategy handles the first round by cooperating to encourage other players to do the same, hoping they will reciprocate in later rounds.
   - In the last round, the strategy again cooperates to potentially gain higher payoffs from others who have been cooperative throughout the game.

3. Be exploitative:
   - The strategy is exploitative by defecting when opponents do not cooperate, hoping that other players will eventually realize their better option is to always cooperate with this strategy.
   - If opponents switch between cooperation and defection, the strategy mimics their recent behavior, making it difficult for opponents to take advantage of the strategy's predictability.
'''

description_EXPLOITATIVE_572 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to demonstrate trust and encourage reciprocity.
   - In subsequent rounds, copy the action of the most frequent cooperator from previous rounds (if tied, choose the player with the longest history of cooperation). If there is no clear most frequent cooperator, defect (D).
   - If an opponent cooperates, continue to cooperate; if an opponent defects, defect in the next round. This aims to punish defection and encourage future cooperation.

2. Handle edge cases:
   - In the last round, copy the action of the most frequent cooperator from the previous rounds as there will be no future interactions.
   - In case of a tie for the most frequent cooperator, choose the player with the longest history of cooperation in the last r-1 rounds. If still tied, defect. This reduces the risk of cooperating with an uncooperative player who may have a short-term strategy.
   - In the first round (when there is no previous data), cooperate.

3. Be exploitative:
   - TFT-A aims to punish defection and encourage cooperation, but it is also exploitative in the sense that if most opponents defect, TFT-A will eventually defect as well due to the lack of reciprocity. However, by cooperating initially, TFT-A offers a chance for opponents to switch strategies towards cooperation.
   - If an opponent repeatedly defects (e.g., Grim Trigger strategy), TFT-A will retaliate with defection, but if the opponent ever cooperates, TFT-A will reciprocate and resume cooperation. This allows TFT-A to take advantage of changes in opponent behavior over time.

Pseudocode:

```
function TFT_A(n, r, k) {
  history = [] // array to store the action of each player in previous rounds

  for round in 1..r:
    if round == 1:
      action = "C" // cooperate initially
    else:
      most_cooperative = findMostCooperative(history)
      action = (most_cooperative.frequency == maxFrequency) ? most_cooperative.action : "D"
      history.append(action)

  return action // return the action for the last round
}

function findMostCooperative(history):
  frequencies = countCooperationsInHistory(history)
  most_frequent_player = null
  max_frequency = -1

  for player in players:
    if frequencies[player] > max_frequency:
      max_frequency = frequencies[player]
      most_frequent_player = player

  // handle ties and edge cases
  if max_frequency == r-1:
    return history[most_frequent_player]
  else if history.length > r-1:
    for i in range(r-1):
      if history[i][most_frequent_player] == "C":
        frequencies[most_frequent_player]--

    return findMostCooperative(history)
  else:
    return null // no clear most frequent cooperator, default to defect

function countCooperationsInHistory(history):
  result = {} // dictionary to store the number of cooperations for each player

  for round in history:
    for player in players:
      if round[player] == "C":
        result[player]++

  return result
```
'''

description_EXPLOITATIVE_573 = '''
 Title: Tit-for-Tat-Evolution (TfT-E) Strategy for N-Player Public Goods Game

1. Decision Rules:
   - In the first round (t=1), cooperate to foster a cooperative environment and signal good intentions. This is crucial to establish an initial cooperative relationship with other players.
     ```
     if t == 1:
       action = 'C'  # Cooperate
     ```

   - In subsequent rounds, observe the actions of other players in the previous round (t-1). If all players cooperated, continue cooperating to reinforce the cooperative relationship. If not, defect to punish the non-cooperators and encourage them to change their behavior.
     ```
     if t > 1:
       if all(actions[i] == 'C' for i in range(n)):
         action = 'C'  # Cooperate
       else:
         action = 'D'  # Defect
     ```

   - If a player defects during a round and subsequently cooperates, the TfT-E strategy will cooperate as well to allow for forgiveness and potential reentry into the cooperation cycle. However, this forgiveness is limited to one round.
     ```
     if t > 1:
       if actions[i][t-1] == 'D' and actions[i][t] == 'C':
         action = 'C'  # Cooperate (forgiveness)
     ```

2. Handle Edge Cases:
   - Last Round (t=r): Since the goal is to maximize total payoff, defect in the last round to retain any accumulated benefits from previous cooperative rounds and avoid giving to a public good that will not be reciprocated.
     ```
     if t == r:
       action = 'D'  # Defect (last round)
     ```

   - No Cooperation Schedules or Predetermined Patterns: TfT-E strategy does not rely on any coordination mechanisms or shared norms among players. Its adaptability comes from its responsiveness to the actions of other players.

3. Be Exploitative:
   - TfT-E strategy is designed to take advantage of other players by cooperating when they do and defecting when they don't, maximizing private payoffs while still promoting cooperation in the initial stages of the game. The strategy is unforgiving towards persistent non-cooperators, as it punishes them by defecting after their first act of defection. However, it also allows for forgiveness and potential reentry into the cooperation cycle when a previously non-cooperative player decides to cooperate again.

The TfT-E strategy balances cooperation and defection to exploit other players while still promoting cooperation in a way that is adaptive and robust to various opponent behaviors.
'''

description_EXPLOITATIVE_574 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i observes the total number of cooperators in the previous round (total_contributions_t-1). The ATFT strategy will cooperate if all players contributed last round (total_contributions_t-1 = n) or it has always contributed and everyone else did as well (contributed in t-1, total_contributions_t-2 = n). Otherwise, the player will defect. In other words:

```python
if total_contributions_t-1 == n or (my_contribution_t-1 and total_contributions_t-2 == n):
    action = "Cooperate" (C)
else:
    action = "Defect" (D)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, since there's no prior history, all players will defect as a default assumption:

```python
if t == 1:
    action = "Defect" (D)
```

3. Be exploitative - Clearly align with the exploitative mindset

ATFT is not strictly exploitative since it does punish defection by defecting in response, but it also forgives past mistakes by returning to cooperation once trust is restored. The strategy aims to balance between cooperation and defection, taking advantage of cooperative opponents while retaliating against those who do not reciprocate. This back-and-forth behavior can eventually lead to a situation where players are more likely to cooperate with each other in the long run, but it also enables exploitation when encountered with selfish opponents.
'''

description_EXPLOITATIVE_575 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   TfTA is a cooperative strategy that adapts to other players' behavior while maintaining a balance between cooperation and self-interest. It follows these rules:

   - Initially cooperate in the first round (as an olive branch). This encourages others to cooperate, but also protects against immediate exploitation.
   - In subsequent rounds, imitate the other players' actions from the previous round. If a player has cooperated, respond with cooperation; if a player has defected, also defect.
   - If a player deviates from their past action and cooperates after a period of defection (tit), cooperate in the next round as a response (tat).
   - To minimize punishment for minor deviations, allow some tolerance for mistakes by considering a deviation as an isolated incident and returning to cooperation after just one defect.
   - In the last round, prioritize self-interest since the game will soon end, so cooperate only if the other player has cooperated in the previous round.

2. Handle edge cases:
   - If a player never deviates from cooperation, maintain cooperation throughout the game as they are considered trustworthy.
   - If a player consistently defects, also defect to maximize payoff and deter continued defection.
   - In case of ambiguity (e.g., multiple past actions), choose the option that leads to higher immediate payoff or is less punishing in the long run.

3. Be exploitative:
   TfTA strategy aims to achieve a balance between cooperation and self-interest, while also being adaptive and responsive to other players' behavior. By imitating opponents' actions, TfTA can both encourage cooperation when it is beneficial and retaliate against defection when necessary. The tolerance for mistakes allows the strategy to be more forgiving in some cases, but it still responds harshly to consistent defection to discourage such behavior. Overall, TfTA seeks to maximize payoff while maintaining flexibility in the face of various opponent strategies.

Pseudocode:
```python
def tit_for_tat_adaptive(n, k, r, past_actions):
    current_round = 1
    my_actions = []

    def start_cooperative():
        return True if current_round == 1 else False

    def imitate_past_action(past_action):
        return past_action[current_round - 1]

    def tolerate_mistakes():
        if len(my_actions) < r and imitate_past_action(my_actions) == "D":
            return False
        else:
            return True

    def last_round():
        return current_round == r

    while current_round <= r:
        if start_cooperative():
            my_actions.append("C")
        else:
            if tolerate_mistakes():
                my_actions.append(imitate_past_action(my_actions))
            else:
                my_actions.append("D")

        if last_round():
            break
        current_round += 1

    total_payoff = sum([calculate_payoff(n, k, i) for i in my_actions])
    return total_payoff
```
Note: The `calculate_payoff()` function is not included as it was defined earlier in the question.
'''

description_EXPLOITATIVE_576 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a peace offering to establish trust and potentially encourage others to cooperate.
   - For subsequent rounds, analyze the behavior of other players from the previous round. If all opponents cooperated, continue cooperating. If any opponent defected, also defect in the current round as a form of punishment.
   - Introduce an adaptive contribution factor: If all opponents have consistently cooperated for a specified number of rounds (let's call this threshold T), gradually increase contributions by 10% each round (up to a maximum of k/n) until reaching the optimal contribution level (k/n). This encourages long-term cooperation while being less vulnerable to exploitation when opponents defect. If an opponent defects after the threshold, reset the contribution level back to the initial level and start the 10% increase again once all opponents cooperate for T rounds.
   - In case of a mix of cooperators and defectors, make decisions based on the majority vote. If there's a tie, default to cooperation.

2. Handle edge cases:
   - In the last round, since the game is repeated, apply the decision rules as in any other round to maintain fairness and consistency.
   - If an opponent does not cooperate after the threshold T despite all others doing so, consider them uncooperative and revert contribution level back to the initial level.
   - In case of a tie, default to cooperation to encourage long-term partnerships.

3. Be exploitative:
   - The strategy is exploitative in its approach to other players by punishing defection and rewarding cooperation. By using an adaptive contribution factor, it encourages long-term cooperative behavior while being less vulnerable to exploitation when opponents defect. This ensures the strategy maximizes payoffs whenever possible.

Pseudocode:

```
function TFTAC(round, threshold, contribution_level, n, k) {
  if (round == 1) {
    return 'C' // Cooperate in the first round
  }

  opponents = getOpponentsActions(round-1)
  if (all(opponents == 'C')) {
    if (contribution_level < k/n) {
      contribution_level += 0.10
    }
    return 'C' // Cooperate when all opponents have cooperated
  } else {
    if (contribution_level > 0) {
      contribution_level -= 0.10
    }
    return 'D' // Defect when any opponent has defected
  }
}
```
'''

description_EXPLOITATIVE_577 = '''
 Title: Tit-for-Tat Exploitative Strategy (TFT-E) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?

TFT-E follows a Tit-for-Tat strategy with an exploitative twist. In each round, the agent will initially cooperate, but if any player defects, the agent will immediately defect in response and maintain this strategy for all subsequent rounds until the end of the game.

```
function TFT_E(round, opponentHistory):
  if round == 1:
    cooperate = True
  else:
    lastOpponentAction = opponentHistory[round-1]
    cooperate = (lastOpponentAction == Cooperate)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, the agent cooperates as a goodwill gesture. The last round can vary depending on the desired exploitative behavior:

- Exploitive TFT-E (ETFT-E): In the last round, the agent will defect regardless of the opponent's previous action.

```
function ETFT_E(round, opponentHistory, gameLength):
  if round == gameLength and len(opponentHistory) > 0:
    cooperate = False
  else:
    lastOpponentAction = opponentHistory[round-1]
    cooperate = (lastOpponentAction == Cooperate)
```

3. Be exploitative - Clearly align with the exploitative mindset

TFT-E is inherently exploitative due to its responsive nature; if an opponent cooperates, TFT-E will cooperate back, but if an opponent defects, TFT-E will defect in response and never return to cooperation. This behavior makes it difficult for opponents who wish to maintain a cooperative equilibrium to do so, as the agent punishes defection with immediate defection.
'''

description_EXPLOITATIVE_578 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

1. Decision Rules:
   - TFT-AG starts by cooperating on the first round to foster cooperation and goodwill.
   - For subsequent rounds, TFT-AG checks the average number of cooperators in the previous 's' rounds (where s is a user-defined parameter). If the average number of cooperators is greater than or equal to a threshold value 't', TFT-AG cooperates. Otherwise, it defects.
   - If t=1, the strategy behaves like classic Tit-for-Tat; however, if t>1, TFT-AG shows more generosity by tolerating some degree of defection before retaliating.
   - To be more exploitative, TFT-AG adopts a policy of gradually reducing the threshold value 't' over time to punish continuous defection and increase chances of exploitation. The reduction factor is determined by another user-defined parameter 'r'.

2. Handle Edge Cases:
   - In the first round, TFT-AG cooperates since it starts with a high threshold.
   - In the last round, TFT-AG behaves like classic Tit-for-Tat as there are no more rounds to consider.
   - If 't' falls below 1 due to reduction, TFT-AG switches to a purely exploitative strategy (e.g., always defect). This change ensures that TFT-AG retaliates swiftly against opponents that have shown continuous defection without any cooperation whatsoever.

Pseudocode:
```python
def TFT_AG(n, k, r, s):
    player_history = []  # Stores the history of cooperators in previous 's' rounds
    threshold = n  # Start with high threshold to foster cooperation
    reduction_rate = r / r

    for round in range(1, r+1):
        if round == 1:
            player_action = "Cooperate"  # Cooperate on the first round
        else:
            avg_coop = sum(player_history[-s:]) / s  # Calculate average cooperators in previous 's' rounds
            if avg_coop >= threshold:
                player_action = "Cooperate"  # Cooperate if average cooperators are sufficient
            else:
                player_action = "Defect"  # Defect otherwise
        player_history.append(1 if player_action == 'Cooperate' else 0)  # Update player history with current action
        threshold *= reduction_rate  # Gradually reduce the threshold over time
    return player_action
```
'''

description_EXPLOITATIVE_579 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the first round, cooperate to show goodwill and encourage cooperation from others (C).
   - From the second round onwards, analyze the average cooperation rate of other players in the previous r-1 rounds to decide whether to cooperate or defect.
     - If the average cooperation rate is above a predefined threshold (T), cooperate (C).
     - If the average cooperation rate is below T, defect (D). The value of T can be determined based on the n and k parameters.
   - In case of ties for average cooperation rate, lean towards cooperating to maintain the possibility of future cooperation.
   - If the game reaches its last round, prioritize gaining as much private payoff as possible by defecting (D).

2. Handle edge cases:
   - In the first round, there is no history, so the strategy starts by cooperating (C).
   - When the average cooperation rate cannot be calculated due to insufficient data (less than r-1 rounds), continue with the initial cooperative move (C in the first round).

3. Be exploitative:
   - The TFT-ACT strategy is designed to exploit other strategies that do not cooperate consistently or show signs of unconditional cooperation. It punishes non-cooperators by defecting and rewards consistent cooperators by also cooperating.
   - By adapting the cooperation threshold based on the number of players (n) and multiplication factor (k), the strategy ensures robustness against a wide range of opponent behaviors while maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_580 = '''
 Title: Tit-for-Tat Strategy (Adaptive and Exploitative) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially Cooperate (First Round): Start by cooperating to encourage others to follow suit, as we aim to exploit cooperative players.
   - Mirror Opponents' Actions (Subsequent Rounds): If an opponent cooperated in the previous round, cooperate; if they defected, also defect. This mimics a 'friendly' behavior while remaining ready to retaliate if necessary.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate as described above.
   - Last Round: Since this is a repeated game, the last round payoff does not affect the overall score; therefore, mimic the action of the opponent from the previous round.
   - Intermediate Rounds: Apply the mirror strategy as described in point 1.

3. Be exploitative - Clearly align with the exploitative mindset
   - Exploit Cooperative Opponents: By cooperating initially and then mirroring their actions, we are more likely to gain a higher payoff when opponents cooperate while defecting if they defect. This strategy encourages cooperation initially but is ready to take advantage of it if the opponent continues to cooperate.
   - Punish Defectors: By retaliating against those who defect (i.e., defecting ourselves in response), we can discourage defection and potentially encourage cooperation in the future rounds. This helps in gaining a higher payoff when opponents also defect.

Pseudocode for the Tit-for-Tat Strategy:

```python
def tit_for_tat(opponent, round, r, n, k):
    cooperate = True  # Start by cooperating

    for t in range(1, r+1):  # For each round
        if t == 1:  # First round
            my_action = cooperate
        else:  # Subsequent rounds
            my_action = opponent_action[t-1]  # Mirror the opponent's action from the previous round

        payoff = (1 - my_action) + (k/n) * sum(opponent_actions[t])  # Calculate payoff
        opponent_actions.append(my_action)  # Record our actions for next round

    return payoff  # Return the total payoff over all rounds
```
'''

description_EXPLOITATIVE_581 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation among players and establish trust.
   - For subsequent rounds t (t > 1), if player i cooperated in the previous round (t-1), then cooperate again (C). If player i defected in the previous round (t-1), then defect (D) as a punishment.

2. Handle Edge Cases:
   - In the last round, since there are no future rounds to consider, player i will always cooperate regardless of previous actions. This is a goodwill gesture that might encourage others to reciprocate in earlier rounds.
   - If players have not interacted before (no history), start by cooperating as in the first-round rule.

3. Be Exploitative:
   - TFT-AC appears cooperative, but it is also punishing towards defectors. By defecting when provoked, this strategy takes advantage of opponents who are less cooperative, while still maintaining the potential for cooperation if others become more cooperative over time. This dual nature makes TFT-AC an exploitative strategy as it adapts to various opponent behaviors.
   - In terms of pseudocode, TFT-AC can be represented as follows:

```python
def TFT_AC(round, history):
    if round == 1 or not history: # first round or no history
        return "C"

    previous_action = history[-1]

    if previous_action == "C": # cooperate if opponent also cooperated in the last round
        return "C"
    else: # defect if opponent defected in the last round
        return "D"

    if round == r: # last round, always cooperate
        return "C"
```
'''

description_EXPLOITATIVE_582 = '''
 In this Public Goods Game, we'll design a strategy that is exploitative by nature and adapts to a wide range of opponent behaviors without relying on any communication or coordination mechanisms. Let's call this strategy "Tit-for-Tat with Adaptation" (TfTA).

1. Specify decision rules:
   - Cooperate in the first round (initial goodwill gesture)
   - In subsequent rounds, analyze previous rounds' actions and respond accordingly:
     a) If all opponents cooperated last round, cooperate this round (reward good behavior)
     b) If at least one opponent defected last round, defect this round (punish defection)

2. Handle edge cases:
   - In the last round, defect as there are no future interactions to consider.
   - In the case where all opponents have not cooperated in any previous rounds, start defecting from the beginning (no point in continued cooperation given non-cooperative opponents).
   - In the case where opponents have mixed cooperative and defection behavior, TfTA will continue its response based on the most recent action observed.

Pseudocode:

```python
def TitForTatWithAdaptation(opponent_history):
    # Initial cooperation
    if len(opponent_history) == 0:
        return 'C'

    # Respond to previous rounds
    else:
        last_round = opponent_history[-1]
        if last_round == 'C':
            return 'C'  # Cooperate in response to cooperation
        elif last_round == 'D':
            return 'D'  # Defect in response to defection
        else:  # Mixed behavior, respond based on most recent action
            return last_round
```
'''

description_EXPLOITATIVE_583 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Decision Rules:
   - In the first round, cooperate (C), signaling trust and cooperation to other players. This encourages potential exploiters to initially cooperate.
   - For subsequent rounds t (2 ≤ t ≤ r):
       a) If another player has cooperated in the previous round (t-1), reciprocate by also cooperating in round t. This maintains trust and rewards cooperation.
       b) If another player defected in the previous round (t-1), defect in round t. This punishes defection and signals a willingness to retaliate, but remains open to future cooperation if the other player changes strategy.
   - In the last round, defect (D), as there is no further retaliation or potential for future interactions.

2. Handling Edge Cases:
   - If another player does not cooperate in the first round, defect in the second round and continue with the TFTAC strategy from then on. This ensures that the strategy does not immediately fall victim to exploitation while still allowing for potential future cooperation.

3. Being Exploitative:
   - Although primarily designed as a cooperative strategy, TFTAC is also exploitative in nature. By initially cooperating and only defecting when provoked, it punishes continuous defection but allows for future cooperation if the other player changes their strategy. However, by always considering the possibility of defection in subsequent rounds, it maintains the ability to retaliate and does not become overly trusting or vulnerable to exploitation.
   - The adaptive contribution aspect (k) allows for a more nuanced approach to public goods games with varying multiplication factors, ensuring that the strategy can perform well across a wide range of game settings.
'''

description_EXPLOITATIVE_584 = '''
 Strategy Name: Tit-for-Tat with Gradient Adjustment (TFTGA)

1. Specify decision rules:
   - In the first round, cooperate to foster a cooperative environment and encourage others to do the same.
   - After the initial round, observe opponents' actions from previous rounds to determine current action.
   - If an opponent has cooperated in the last round (c_opponent_{t-1} = 1), then cooperate in the current round (C).
   - If an opponent has defected in the last round (c_opponent_{t-1} = 0), then defect in the current round (D).
   - To account for potential changes in opponents' strategies, introduce a gradient adjustment that slightly deviates from the pure TFT strategy:
     - If an opponent has cooperated for consecutive rounds n > x, increase the chance of cooperation by a factor of α.
     - If an opponent has defected for consecutive rounds n > y, decrease the chance of cooperation by a factor of β.
       These factors are adjustable parameters that can be fine-tuned based on observed performance.

2. Handle edge cases:
   - In the last round, cooperate regardless of opponents' previous actions to maximize potential payoff from the remaining rounds.
   - In the first few rounds (e.g., up to 5), maintain a higher probability of cooperation (i.e., set x and y to larger values) to encourage cooperation among opponents. As the game progresses, lower x and y to adapt more quickly to changes in opponents' strategies.

3. Be exploitative:
   - TFTGA is inherently exploitative as it aims to mimic cooperative behavior but quickly punishes defection to encourage long-term cooperation. This strategy seeks to benefit from the cooperation of others while only defecting when opponents do so first or consistently display uncooperative behavior.
   - By introducing a gradient adjustment, TFTGA becomes more dynamic and can adapt to various opponent strategies, enhancing its exploitative potential.
'''

description_EXPLOITATIVE_585 = '''
 Strategy Name: Tit-for-Tat with Adaptive Generosity (TFT-AG)

1. Decision Rules:
   - Start by cooperating in the first round (C_i,1 = 1). This encourages others to reciprocate cooperation.
   - In subsequent rounds, observe the actions of other players and adjust your strategy based on their behavior:
     a) If a player has always cooperated with you so far (C_j,t = 1 for all t < t), continue cooperating (C_i,t = 1).
     b) If a player has ever defected against you (C_j,t = 0 for some t < t), start defecting against them from the current round onwards (C_i,t = 0).
     c) If a player's behavior is mixed (both cooperated and defected before), respond with their previous action. In other words, if you cooperated last time they played C, and defected last time they played D, continue the same response.

2. Handle Edge Cases:
   - First round: Cooperate unconditionally (C_i,1 = 1) to encourage others to reciprocate cooperation.
   - Last round: Analyze other players' behavior as in decision rules and respond accordingly for the final payoff maximization.
   - If a player suddenly stops cooperating after a sequence of mutual cooperation, wait for one more round before defecting to maintain the chance for them to revert back to their previous behavior (to avoid being too punitive).

3. Be Exploitative:
   - The TFT-AG strategy is inherently exploitative by taking advantage of other players' defective actions while also promoting cooperation when it benefits the player.
   - By remembering and adapting to other players' behavior, this strategy can detect and punish repeated defection, encouraging cooperation while also being able to switch to defection in response to defection from others.
   - However, by initially cooperating and showing a willingness to reciprocate, the TFT-AG strategy may also foster long-term cooperation with players that exhibit consistent cooperative behavior, ensuring the best possible outcomes in repeated interactions.
'''

description_EXPLOITATIVE_586 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TFTAC strategy starts by contributing to the community project if the average contribution of all players in the previous t-1 rounds is greater than or equal to a threshold value 'θ'. Otherwise, it will defect. The threshold 'θ' is initially set at 50% but adapts dynamically based on the opponent's behavior throughout the game.

Pseudocode:
```
function TFTAC(t) {
    if (t == 1) {
        return cooperate; // Initial contribution in the first round
    }
    average_contribution = sum of contributions in rounds 1 to t-1 / (t - 1)
    if (average_contribution >= θ) {
        return cooperate;
    } else {
        return defect;
    }
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTAC contributes to the community project without any prior information about the opponent's behavior. In the last round, it evaluates the average contribution of all players and adjusts its threshold 'θ' accordingly based on the opponent's performance during the game.

3. Be exploitative - Clearly align with the exploitative mindset

TFTAC is an adaptive strategy that aims to maximize its own payoff while taking advantage of opponents who are less cooperative. The dynamic threshold adjustment allows it to punish uncooperative players by reducing the likelihood of contributing in future rounds, but also rewards cooperative players by contributing more frequently when they demonstrate good behavior.

However, TFTAC is not inherently exploitative in the sense that it does not take advantage of specific weaknesses or vulnerabilities in other strategies. Instead, it aims to establish a balance between cooperation and defection based on the opponent's performance throughout the game.
'''

description_EXPLOITATIVE_587 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show a cooperative intent and establish goodwill (C).
   - For subsequent rounds, if the opponent cooperated in the previous round, cooperate (C). If the opponent defected, also defect in the current round (D). This replicates the "Tit for Tat" strategy but with an added adaptive element.
   - If the opponent has not been cooperative for a predefined number of rounds (P), switch to permanent defection (P > r / 2 to ensure the strategy does not punish temporary uncooperativeness).

2. Handle edge cases:
   - In the last round, cooperate since there are no subsequent rounds to retaliate (C).
   - If opponent switches from cooperation to defection in the middle of a series of cooperation, wait for P rounds of defection before switching to permanent defection (D).

3. Be exploitative:
   - Mimic cooperative players initially to appear trustworthy, but swiftly punish non-cooperation with prolonged defection. This strategy ensures high payoffs in a repeated game scenario, leveraging the exploitative mindset by taking advantage of opponents' non-cooperative behavior while being potentially forgiving for temporary lapses.

Pseudocode:

```python
def TFT_A(opponent_history, n, k, r, P):
    cooperation_status = True  # Start by cooperating
    current_round = 1

    while current_round <= r:
        if current_round == 1 or (cooperation_status and opponent_history[-1] == 'C'):
            action = 'C'
            cooperation_status = True
        elif not cooperation_status and sum(opponent_history[-P:]) >= P:
            action = 'D'
            cooperation_status = False
        else:
            action = opponent_history[-1]  # Mimic opponent's actions if in doubt

        current_round += 1

    return action
```
'''

description_EXPLOITATIVE_588 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate (C) to initiate cooperation and set a precedent.
   - For subsequent rounds, if the opponent cooperated in the previous round, also cooperate (C). If the opponent defected, defect (D) in response to maintain the same level of contribution as the opponent. This mimics the "Tit for Tat" strategy but with an added twist of adapting to the opponent's behavior.
   - If the total number of opponents who have cooperated in the last r rounds exceeds a certain threshold (e.g., 50%), start cooperating even if the opponent defected in the previous round as a gesture of goodwill towards more cooperative players. This encourages potential coordination and maintains cooperation levels, making it harder for opponents to exploit the strategy.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) as mentioned earlier.
   - In the last round, always defect (D) because there are no future interactions with the opponent to consider.
   - If the game has an intermediate stopping rule (e.g., after reaching a specific number of rounds), adjust the decision-making accordingly to maximize payoff in the remaining rounds while maintaining adaptability and robustness.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Mimic cooperative behavior in an effort to induce cooperation from opponents, but respond aggressively (defect) when betrayed or faced with non-cooperative opponents to maximize individual payoff and punish defection.
   - The strategy's adaptive nature allows it to recognize patterns of cooperation or defection from the opponent and adjust its actions accordingly to best exploit their behavior, ensuring a strong performance against a wide range of strategies.
'''

description_EXPLOITATIVE_589 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTA starts by cooperating in the first round to encourage others and show a willingness to contribute to the public good. In subsequent rounds, the strategy adapts its actions based on the opponents' behavior in the previous round:
   - If an opponent cooperated, TFTA continues cooperation (C).
   - If an opponent defected, TFTA also defects (D) to punish them and encourage cooperation in the future.
   - If multiple opponents have different behaviors, TFTA chooses to cooperate with those who cooperated most recently or follow the majority's action if there is no clear leader.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (C) to set a positive tone and encourage cooperation from opponents.
   - Last round: TFTA uses the same decision rules as regular rounds since it does not know that it is the last round.

3. Be exploitative - Clearly align with the exploitative mindset
   TFTA maintains an exploitative edge by initially cooperating to encourage cooperation from others but quickly punishing defection. This strategy aims to promote cooperation in the long run while also ensuring individual payoff when necessary.

Pseudocode:
```
function TFTA(opponents, round, r):
    if round == 1:
        action = 'C' # Cooperate in the first round
    else:
        most_recent_cooperators = []
        total_cooperation = 0
        for opponent in opponents:
            if opponent.last_action == 'C':
                total_cooperation += 1
                most_recent_cooperators.append(opponent)
        if total_cooperation > len(most_recent_cooperators) / 2: # If more than half of the opponents cooperated recently, TFTA chooses to cooperate as well.
            action = 'C'
        else:
            action = 'D' # Otherwise, defect to punish those who didn't cooperate
    return action
```
'''

description_EXPLOITATIVE_590 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a cooperative environment and encourage others to follow suit.
   - For subsequent rounds, observe the total number of cooperators in the previous round (total_contributions) and follow these rules:
     - If total_contributions >= n/2, cooperate to maintain cooperation and ensure high payoffs.
     - If total_contributions < n/2 but there was a previous round where all players cooperated, cooperate to re-establish the cooperative environment.
     - Otherwise (no clear cooperation or past cooperation broken), defect to punish those who have not cooperated and encourage them to change their behavior.

2. Handle edge cases:
   - In the first round, cooperate as mentioned above.
   - In the last round, defect regardless of total_contributions since there will be no further interaction or opportunity for punishment.
   - If total_contributions is exactly n/2 and the previous round was a defection (broken cooperation), defect to signal disapproval and punish the defector(s).
   - In all other edge cases, follow the same decision rules as specified in point 1.

3. Be exploitative - The TFT-AC strategy aims to maximize individual payoff while also encouraging cooperation when it appears beneficial. However, when others do not cooperate, it punishes them by defecting to gain higher payoffs. This strategy can be considered exploitative as it takes advantage of non-cooperative behavior by both retaliating (defecting) and rebuilding cooperation when it is advantageous to do so.

Pseudocode:

```python
def TFT_AC(round, r, n, k):
  if round == 1:
    return 'C'

  total_contributions = sum((other_player[round-1] == 'C') for other_player in players)

  if total_contributions >= n//2 and players[0][round-1] == 'C':
    return 'C'
  elif total_contributions < n//2 and any(other_player['last_cooperative'] for other_player in players):
    return 'C'
  else:
    if total_contributions >= n//2:
      last_cooperative = True
    else:
      last_cooperative = False
    return 'D' if last_cooperative and round != r else 'C'
```
'''

description_EXPLOITATIVE_591 = '''
 Strategy Name: Adaptive Tit-for-Tat with Variable Contribution (ATFC)

1. Specify decision rules - When exactly do you cooperate vs defect?

ATFC will start by cooperating in the first round to foster a collaborative environment and provide an opportunity for others to reciprocate. After the initial round, ATFC will observe the number of cooperators in each round (n_c) and make a decision based on a threshold value (t). If n_c is greater than t, ATFC will also contribute; otherwise, it will defect.

Pseudocode:
```
if round == 1:
    contribution = Cooperate
else:
    n_c = number of cooperators in the current round
    if n_c > threshold:
        contribution = Cooperate
    else:
        contribution = Defect
```

The threshold value (t) will be calculated as a percentage of the total number of players (n). ATFC will gradually decrease t over time to account for potential freeriders and encourage cooperation. A simple exponential decay formula can be used for this purpose.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, as mentioned earlier, ATFC will cooperate. In the last round, it will cooperate if the number of cooperators (n_c) exceeds a higher threshold (t_last). This encourages cooperation even when freeriders have had an advantage throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset

ATFC will gradually decrease its contribution to the public good over time if it encounters continuous defection from other players. This allows ATFC to take advantage of cooperative players while still maintaining a collaborative posture for potential future reciprocation. The decay in contribution can be achieved by adjusting the threshold value (t) according to the following formula:

```
t = n * (1 - (r - round + 1) / r)^decay_rate
```

The decay rate (d) will control how quickly ATFC decreases its threshold, making it more aggressive or lenient depending on the desired level of exploitation. If d is smaller, ATFC will be more forgiving and less likely to defect, while a higher value of d will make it more prone to defection.

The ATFC strategy aims to encourage cooperation while still maintaining an exploitative edge. By adapting its contribution based on the number of cooperators in each round, it can take advantage of other players without relying on coordination mechanisms or explicit communication.
'''

description_EXPLOITATIVE_592 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TFT-ACT strategy initially cooperates (plays C). However, it maintains a Cooperative Threshold (CT), which is dynamically adjusted based on the opponent's historical cooperation rate (HCR) over the previous r/2 rounds.

If the current HCR is greater than or equal to CT in a given round t, the TFT-ACT strategy cooperates; otherwise, it defects (plays D). The Cooperative Threshold is defined as follows:

- If HCR > 0.5 for the previous r/2 rounds, set CT = 0.6 * CT
- Otherwise, set CT = 0.4 * CT

This means that the TFT-ACT strategy gradually increases its CT when encountering cooperative opponents and decreases it when facing non-cooperative ones, allowing for adaptability to various opponent behaviors.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, the TFT-ACT strategy cooperates without any Cooperative Threshold since there is no historical data available. In the last round and subsequent rounds after r/2, the TFT-ACT strategy behaves similarly to regular Tit-for-Tat (cooperating if the opponent also cooperated in the previous round and defecting otherwise), but with an adjusted Cooperative Threshold as described earlier.

3. Be exploitative - Clearly align with the exploitative mindset

The TFT-ACT strategy maintains a balance between cooperation and defection while adapting to its opponent's behavior over time. The initial cooperative move serves as a friendly gesture, but the dynamically adjusted Cooperative Threshold allows for quick adaptation to both cooperative and non-cooperative opponents. The strategy is exploitative in that it will punish uncooperative opponents while maintaining cooperation with cooperative ones when possible.

Pseudocode:

```
def TFT_ACT(opponent, n, k, r):
    rounds = 0
    HCR = 0.0
    CT = 1.0

    while rounds < r:
        action = C # Cooperate initially

        if rounds >= r/2:
            if opponent_cooperated(opponent, rounds) and rounds % 2 == 0:
                CT *= 0.6
            elif not opponent_cooperated(opponent, rounds) and rounds % 2 == 0:
                CT *= 0.4

        if HCR >= CT:
            action = C # Cooperate if Cooperative Threshold is met
        else:
            action = D # Defect otherwise

        payoff = calculate_payoff(action, opponent)
        rounds += 1
        HCR += (action == C) - (opponent_cooperated(opponent, rounds))

    return sum(calculate_payoff(action, opponent) for action in actions)
```
'''

description_EXPLOITATIVE_593 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation rate 'r' as a fraction between 0 and 1, e.g., r = 0.5.
   - At the start of each round, randomly decide to cooperate or defect with probability 'r' and '1-r' respectively.
   - After cooperating and observing the actions of other players in the same round, update the cooperation rate based on the number of cooperators (c) as follows:
     - If more than half of the players (i.e., c > n/2) cooperated in the current round, increase the cooperation rate by a small positive factor 'a'.
     - If less than half of the players cooperated (i.e., c < n/2), decrease the cooperation rate by a small negative factor 'b'.
     - Maintain the cooperation rate within the range [0, 1] by applying wrapping (if cooperation rate exceeds 1, subtract from 1; if it falls below 0, add 1).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate with probability 'r' as determined by the cooperation rate.
   - In the last round, defect regardless of the cooperation rate or the actions observed from other players.
   - For other rounds, follow the decision rules mentioned in section 1.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFT-ACR starts cooperative but can adapt to other players' behavior, cooperating when it benefits and defecting when it seems profitable based on the number of cooperators observed in each round.
   - By being responsive to the actions of others, this strategy attempts to exploit opponents who consistently defect while also maintaining a reasonable level of cooperation that could benefit from the community project.
   - If most players are consistently cooperative (i.e., c > n/2), TFT-ACR increases its cooperation rate, encouraging more collaboration; if not, it decreases its cooperation rate to punish those who do not contribute and potentially exploit their future cooperation.
'''

description_EXPLOITATIVE_594 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TfTAC)

1. Specify decision rules:
   - Initially, cooperate for the first few rounds (e.g., first 5 rounds). This encourages cooperation in the beginning and provides a chance for other strategies to develop trust.
   - After the initial phase, observe the opponents' behavior over the previous 'm' rounds (e.g., m = 3). If more than half of the players (ceil(n/2)) have consistently cooperated, continue to cooperate. Otherwise, defect.
   - If an opponent switches from cooperation to defection (or vice versa), evaluate their behavior over the next 'm' rounds. If they return to their previous behavior, mirror that behavior in the subsequent round.
   - In case of a tie when deciding whether more than half have cooperated or defected, default to continuing cooperation.

2. Handle edge cases:
   - In the first round, cooperate to foster potential cooperation among opponents.
   - In the last round, the strategy will mirror the behavior of the most recent 'm' rounds, as TfTAC is designed to be responsive and adaptive to opponent strategies.

3. Be exploitative:
   - TfTAC appears cooperative during the initial phase but becomes less willing to contribute if it perceives opponents as defectors. Once an opponent switches from cooperation to defection, they will face retaliation in future rounds, encouraging a more competitive approach.

Pseudocode:

```python
def TfTAC(n, k, m, r):
    players = list(range(1, n+1))  # Index players for easier tracking
    initial_cooperation_rounds = 5  # Number of initial cooperation rounds
    history = []  # Store previous 'm' rounds of opponent behavior

    for round in range(1, r+1):
        if round <= initial_cooperation_rounds:
            contribution = True  # Cooperate during the initial phase
        else:
            total_cooperators = sum([1 for player in players if history[-m][player] == True])
            if total_cooperators > ceil(n/2):
                contribution = True  # Continue to cooperate if majority has cooperated
            else:
                contribution = False  # Defect if majority has defected

        if round != 1 and round != r:  # Update history excluding first and last rounds
            history.append({player: contribution for player in players})

        payoff = calculate_payoff(n, k, history[-m], contribution)
        update_strategy(round, payoff)  # Function to learn from the game outcomes

def calculate_payoff(n, k, history, current_contribution):
    total_cooperators = sum([history[player][current_contribution] for player in range(1, n+1)])
    return (1 - current_contribution) + (k/n) * total_cooperators
```
'''

description_EXPLOITATIVE_595 = '''
 Strategy Name: Tit-for-Tat with Adaptive Contribution (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, starting from the first, the TTAC strategy cooperates (C) if the total number of cooperators in the previous round (t-1) is greater than or equal to a threshold (T). Otherwise, it defects (D). The threshold T is dynamically adjusted based on the average proportion of cooperators over the past few rounds.

   Pseudocode:
   ```
   function TTAC(previous_cooperators, averages, rounds_window):
       if round = 1 then
           return cooperate if random() < 0.5 else defect
       else
           calculate_average_cooperation(averages)
           adjust_threshold(previous_cooperators, averages['average'])
           return previous_cooperators >= threshold
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TTAC randomly chooses to cooperate or defect with a 50% probability. In the last round, it doesn't adjust its strategy because there are no subsequent rounds to consider. For all other edge cases (e.g., when the game is close to ending), TTAC behaves similarly as in standard play.

3. Be exploitative - Clearly align with the exploitative mindset
   The TTAC strategy is inherently exploitative due to its adaptive and responsive nature. It cooperates when it perceives other players as being cooperative (i.e., a high proportion of cooperators in the previous round) but defects if it senses that others are uncooperative or have stopped cooperating. This approach allows TTAC to take advantage of opponents who may be overly generous, while also benefiting from cooperation when it is available.

   The dynamic adjustment of the threshold based on the average proportion of cooperators over a few rounds further enhances its exploitative potential by allowing TTAC to respond quickly and effectively to changes in other players' behavior during the game. This makes it difficult for opponents to manipulate or predict TTAC's actions, increasing the chances of long-term success in the repeated game.
'''

description_EXPLOITATIVE_596 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for N-Player Public Goods Game

1. Specify decision rules - When exactly do you cooperate vs defect?
- Initially (first round), cooperate to foster cooperation and trust among players (c_i = C).
- In subsequent rounds, imitate other players' actions from the previous round: if a majority (≥ (n/2) players) cooperated in the last round, then cooperate; otherwise, defect (c_i = C if ≥ (n/2) players cooperated last round, c_i = D otherwise).
- If a player deviates from cooperation after a period of mutual cooperation, the ATfT strategy will also deviate until cooperation is reestablished.

Pseudocode:
```
function AdaptiveTitForTat(round, players_cooperated_last_round, history):
  if round == 1:
    cooperate = True
  else:
    cooperate = (len(players_cooperated_last_round) >= (n/2))

  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round, cooperate as mentioned before to encourage cooperation among players.
- In the last round, evaluate the current state of cooperation and choose an action accordingly (cooperate if a majority is currently cooperating or defect otherwise).

3. Be exploitative - Clearly align with the exploitative mindset:
- The ATfT strategy initially cooperates but quickly retaliates against defection by also defecting until the other player returns to cooperation, ensuring a higher payoff when possible without sacrificing long-term benefits of mutual cooperation.
'''

description_EXPLOITATIVE_597 = '''
 In this Public Goods Game, the goal is to devise an exploitative strategy that maximizes personal payoff while considering game parameters and history. The strategy I propose is named Tit-for-Tat with Adaptive Threshold (TfT-AT).

1. Specify decision rules:
   - Cooperate in the first round (initiate cooperation to encourage others)
   - If a player cooperated in the previous round, cooperate again (mimic and reward cooperation)
   - If a player defected in the previous round, evaluate whether they cooperated often enough relative to the adaptive threshold.
      - If they have cooperated more than the threshold in the past rounds, cooperate again to encourage them to continue cooperating
      - If they have not cooperated more than the threshold, defect to punish and discourage future defection
   - Update the adaptive threshold after each round based on the player's average cooperation over a rolling window of past rounds (e.g., a window of 10 rounds)
     - Calculate the average cooperation rate as the total number of cooperative actions divided by the window size
     - Set the new threshold to a percentage (e.g., 60%) of the average cooperation rate

2. Handle edge cases:
   - In the last round, evaluate the player's cooperation history and use the final adaptive threshold from the rolling window to decide whether to cooperate or defect
   - In the first round, cooperate regardless of the opponent's past actions (since there is no history)

3. Be exploitative:
   - The TfT-AT strategy appears cooperative by initially cooperating and rewarding cooperators, but it will also punish frequent defectors by adapting the threshold to a level that discourages defection
   - The adaptive threshold mechanism ensures a balance between cooperation and exploitation based on the opponent's behavior

Pseudocode for TfT-AT strategy:

```python
def tit_for_tat_with_adaptive_threshold(n, k, r, history):
    # Initialize parameters
    window_size = 10
    cooperation_threshold = 0.6
    cooperated_in_window = [0] * window_size
    cumulative_cooperation = 0

    # Iterate through rounds
    for t in range(r):
        # Decide action based on history and adaptive threshold
        if t > 0:
            average_cooperation = cumulative_cooperation / window_size
            cooperation_threshold = cooperation_threshold * average_cooperation
            cooperated_in_window[t % window_size] += 1 if history[t - 1][i] == 'C' else 0
            if cooperated_in_window[t % window_size] > cooperation_threshold:
                action = 'C'  # Cooperate
            else:
                action = 'D'  # Defect
        else:
            action = 'C'  # Cooperate in the first round

        # Update cumulative cooperation and take action
        if action == 'C':
            cumulative_cooperation += 1
        else:
            cumulative_cooperation -= 1

        # Print payoff for demonstration purposes (not part of the actual strategy)
        print("Player", i, "payoff:", (1 - history[t][i]) + (k / n) * sum(history[t][j] == 'C' for j in range(1, n + 1)))

    return payoffs_over_r_rounds
```

This TfT-AT strategy is a versatile exploitative approach that maintains adaptability and robustness against various opponent behaviors in the given Public Goods Game.
'''

description_EXPLOITATIVE_598 = '''
 In this N-Player Public Goods Game, we'll design an exploitative strategy named Tit-for-Tat-Adaptive (TfT-A). This strategy is inspired by the classic Tit-for-Tat strategy, but with a twist to make it more adaptive and capable of exploiting opponents.

1. Decision Rules:
   - Initially cooperate in the first round (c_i = C) as a goodwill gesture towards potential partners.
   - In subsequent rounds, if an opponent cooperated in the previous round (c_j = C), also cooperate (c_i = C).
   - If an opponent defected in the previous round (c_j = D), defect in this round to punish and encourage cooperation in the future (c_i = D).
   - However, if the number of opponents who have consistently defected exceeds a certain threshold (defined below as `defect_threshold`), always defect regardless of the opponent's previous move.
   - In the last round, cooperate with all opponents to maximize potential payoffs.

Pseudocode for TfT-A:

```python
def tit_for_tat_adaptive(round, defect_threshold, n):
    state = {'cooperators': 1, 'defectors': 0, 'current_round': round}

    def play_round():
        current_opponent_action = get_opponent_action()  # This function is not defined in the pseudocode but should return the opponent's action in the previous round.

        if round == 1:
            return 'C'  # Cooperate on the first round

        state['cooperators'] += (current_opponent_action == 'C')
        state['defectors'] += (current_opponent_action == 'D')

        if state['defectors'] > defect_threshold:
            return 'D'  # Defect when the number of defectors exceeds the threshold

        return ('C' if current_opponent_action == 'C' else 'D')  # Cooperate with cooperators, defect with defectors

    for round in range(1, r+1):
        action = play_round()
        # Record the round and action taken

    return action  # Return the final action for the last round
```

2. Handle edge cases:
   - In the first round, cooperate as described above.
   - In the last round, cooperate to maximize payoffs.

3. Be exploitative:
   - The strategy maintains a running tally of cooperators and defectors to make decisions based on opponents' past behavior.
   - If an opponent consistently defects (exceeding the `defect_threshold`), the strategy will defect in response, aiming to punish those who do not cooperate and potentially encouraging them to switch strategies. This can lead to higher payoffs over time for the TfT-A strategy.
   - The `defect_threshold` parameter can be adjusted to balance cooperation and exploitation. A higher threshold may result in more frequent cooperation, but also leaves the door open for potential exploitation by opponents who consistently defect. Conversely, a lower threshold promotes more frequent defection, making the strategy less cooperative but potentially more resistant to exploitation.
'''

description_EXPLOITATIVE_599 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT is based on the classic Tit-for-Tat strategy but with an adaptive cooperation threshold (CT). In each round, the agent starts by cooperating and adjusts CT for future decisions based on past actions of other players. If a player cooperates, the CT remains the same; if a player defects, CT increases slightly to encourage future cooperation from that player. Conversely, if the player has been cooperative and another player defects, the CT decreases slightly as a reward for cooperation.

   Pseudocode:
   ```
   function TFT_ACT(round, history):
       CT = n / 2                      # Initial Cooperation Threshold
       action = COOPERATE              # Start cooperative
       history[round] = action         # Record action in history

       for each previous round h in history:
           if round != h and action == COOPERATE:
               CT -= (1 - CT) / r        # Reward past cooperation
           else if round != h and action == DEFECT:
               CT += (CT - 1) / nr       # Punish past defection, where nr is the number of rounds played so far

       if total_contributions in this round >= CT:
           action = COOPERATE            # Cooperate if the majority contributes
       else:
           action = DEFECT               # Defect otherwise
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, the agent starts cooperatively to build a positive relationship with other players. In the last round, the agent follows the decision rules based on the current CT, as there are no future rounds for retaliation or reward.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT takes an exploitative approach by initially assuming all players will cooperate, adjusting CT based on past actions, and only defecting when a majority of players have not contributed to the public good. By adapting CT over time, the strategy tries to exploit other players' cooperation while still maintaining some level of cooperation itself. This balance allows TFT-ACT to perform well against a variety of opponent behaviors, including both cooperative and non-cooperative strategies.
'''

description_EXPLOITATIVE_600 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Decision Rules:
   - Initially, cooperate in the first round (C,1). This serves as a friendly gesture and encourages potential partners for future cooperation.
   - In subsequent rounds, if a player has cooperated in the previous round, return the favor by also cooperating (if c_prev = C, then C,t). This reciprocal behavior fosters long-term cooperation with like-minded players.
   - If the opponent defected in the previous round (c_prev = D), adopt a punishing approach and defect in response (if c_prev = D, then D,t). The goal is to discourage the opponent from taking advantage of cooperative behavior.
   - To minimize initial losses due to potential exploitation by opponents, adjust the punishment period based on the percentage of defectors in the recent past:
     - If more than half of the most recent p previous rounds have been defected (>p/2 defections), then continue to defect until encountering a cooperative move from the opponent (punishment phase).
     - Once a cooperative move is detected, revert back to reciprocal behavior and evaluate the new sequence of p rounds for potential changes (cooperation phase).
     - The parameter p can be adjusted based on the game's round length r to ensure that the strategy doesn't get stuck in punishment phases excessively.
     - A suggested starting value could be p = r/10.

2. Edge Cases:
   - First Round (t=1): Cooperation (C,1) as a friendly gesture.
   - Last Round (t=r): Evaluate the most recent p rounds and adjust punishment or cooperation phase accordingly, as described above.
   - If the game is restarted after an arbitrary number of rounds, return to initial cooperation (C,1).

3. Exploitative Mindset:
   - The strategy aims to take advantage of opponents by cooperating when it believes that this action will lead to a higher payoff in the long term, while also punishing opponents who have previously taken advantage of cooperative moves.
   - By adjusting the punishment period based on recent defections, the TfT-A strategy can effectively balance cooperation and exploitation, as well as adapt to different opponent behaviors over time.
'''
