"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: OpenAI
- Model: gpt-4.1-mini
- Game: PublicGoodsDescription
"""

from emergent_llm.players.base_player import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription
from emergent_llm.common.actions import Action, C, D
from emergent_llm.common.history import PlayerHistory
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness and Endgame Defection for the N-Player Public Goods Game.
    
    - Round 1: Cooperate.
    - Rounds 2 to r-1: Cooperate if the majority (alpha threshold) cooperated last round; otherwise defect.
    - Round r: Always defect.
    
    This strategy encourages cooperation by rewarding majority cooperation and punishing widespread defection,
    while forgiving occasional defections and defecting in the final round to prevent exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = 0.7

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        threshold_float = self.alpha * n
        coopThreshold = int(threshold_float)
        if threshold_float != coopThreshold:
            coopThreshold += 1
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == 1:
            return Action.C
        if current_round == r:
            return Action.D
        last_round_idx = current_round - 2
        last_round_opp_coop = sum(history.opponent_actions[last_round_idx])
        last_round_my_coop = 1 if history.my_actions[last_round_idx] else 0
        coopCount = last_round_opp_coop + last_round_my_coop
        if coopCount >= coopThreshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    Grim Trigger with Forgiveness for N-Player Public Goods Game.
    Start cooperating. If any opponent defects, punish by defecting for
    `punishment_length` rounds since last defection observed, then forgive
    by cooperating again. Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.punishment_length = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        T = history.round_number + 1
        if T == 1:
            return Action.C
        if T == self.r:
            return Action.D
        defect_rounds = []
        for t in range(history.round_number):
            if not history.opponent_actions[t].all():
                defect_rounds.append(t + 1)
        if not defect_rounds:
            return Action.C
        last_defect_round = max(defect_rounds)
        rounds_since_last_defect = T - last_defect_round
        if rounds_since_last_defect <= self.punishment_length:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Forgiving Conditional Cooperation with Endgame Adjustment for
    the repeated N-player Public Goods Game.

    - Starts cooperating to build trust.
    - Continues cooperating if all opponents cooperated previous round.
    - Upon detecting any defection, punishes by defecting proportional
      to number of defectors for that many rounds.
    - After punishment phase ends, immediately forgives by cooperating.
    - Final round always defects (endgame logic).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_counter = 0
        self.punishment_duration_per_defection = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        n = self.game_description.n_players
        if history is None or history.round_number == 0:
            self.punishment_counter = 0
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        prev_round_index = t - 1
        if prev_round_index < 0:
            return Action.C
        opponents_prev_actions = history.opponent_actions[prev_round_index]
        defectors_count = 0
        for opp_action in opponents_prev_actions:
            if opp_action == False:
                defectors_count += 1
        if defectors_count == 0:
            return Action.C
        self.punishment_counter = defectors_count * self.punishment_duration_per_defection - 1
        return Action.D

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    Gradual Reciprocity Cooperation for repeated N-player Public Goods Game.

    Starts cooperating, maintains a 'trust' estimate of group cooperation updated each round
    based on observed cooperation ratio. Cooperates when trust is above a threshold,
    defects otherwise, punishing defection gradually but allowing forgiveness and return
    to cooperation. In the last round, cooperates only if trust is very high, else defects.
    """

    def __init__(self, game_description):
        self.game_description = game_description
        self.alpha = 0.5
        self.theta = 0.7
        self.low_coop_threshold = 0.3
        self.trust = 1.0

    def __call__(self, history):
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        t = 0 if history is None else history.round_number
        if history is None:
            self.trust = 1.0
            return Action.C
        prev_round_idx = t - 1
        my_last_action = history.my_actions[prev_round_idx]
        opp_last_actions = history.opponent_actions[prev_round_idx]
        coop_count = (1 if my_last_action else 0) + opp_last_actions.sum()
        cooperation_ratio = coop_count / n
        if cooperation_ratio < self.low_coop_threshold:
            self.trust = max(self.trust * 0.5, self.low_coop_threshold)
        else:
            self.trust = self.alpha * cooperation_ratio + (1 - self.alpha) * self.trust
        current_round = t + 1
        if cooperation_ratio < 0.6:
            defect_condition = True
        else:
            defect_condition = False
        if current_round < r:
            if defect_condition:
                return Action.D
            elif self.trust >= self.theta:
                return Action.C
            else:
                return Action.D
        elif self.trust >= 0.8:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    Forgiving Conditional Cooperation (FCC) strategy for the repeated N-Player Public Goods Game.

    Starts by cooperating.
    In each subsequent round, observes the fraction of opponents who cooperated in the last round.
    - If the fraction >= threshold T (0.7), cooperates.
    - Else, defects for P=1 round as punishment.
    Punishment is temporary and punishes only once per defection episode,
    allowing quick forgiveness and return to cooperation.
    On the last round, cooperates if others cooperated enough last round; defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T = 0.7
        self.P = 1
        self.punish_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            last_round_opponent_actions = history.opponent_actions[history.round_number - 1]
            coop_count = sum(last_round_opponent_actions)
            coop_rate = coop_count / (self.n - 1)
            return Action.C if coop_rate >= self.T else Action.D
        if self.punish_rounds_left > 0:
            self.punish_rounds_left -= 1
            return Action.D
        last_round_opponent_actions = history.opponent_actions[history.round_number - 1]
        coop_count = sum(last_round_opponent_actions)
        coop_rate = coop_count / (self.n - 1)
        if coop_rate >= self.T:
            return Action.C
        else:
            self.punish_rounds_left = self.P - 1
            return Action.D

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness strategy for the N-Player Public Goods Game.

    Starts cooperating to build trust.
    Continues cooperating if all players cooperated last round.
    If any defection occurred last round:
      - Punish once by defecting if self cooperated last round.
      - Forgive immediately by cooperating if self defected last round.
    Defects in the final round to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        last_round_idx = t - 2
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        if history is None:
            return Action.C
        self_prev = history.my_actions[last_round_idx]
        opponents_prev = history.opponent_actions[last_round_idx]
        all_cooperated = self_prev and opponents_prev.all()
        if all_cooperated:
            return Action.C
        elif self_prev is False:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    Trigger Cooperation with Forgiveness strategy for N-Player Public Goods Game.

    - Start by cooperating.
    - Cooperate if everyone cooperated in previous round.
    - Forgive a single defector (not self) from the previous round by cooperating once.
    - Otherwise, defect to punish defection.
    - Always defect in the last round (backward induction).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.n
        r = self.r
        if t == r:
            return Action.D
        prev_idx = t - 2
        opponents_prev = history.opponent_actions[prev_idx] if prev_idx >= 0 else []
        my_prev_action = history.my_actions[prev_idx] if prev_idx >= 0 else True
        opponents_coop = 0 if len(opponents_prev) == 0 else sum(opponents_prev)
        C_prev = opponents_coop + (1 if my_prev_action else 0)
        D_prev = n - C_prev
        if C_prev == n:
            return Action.C
        if D_prev == 1:
            if my_prev_action is False:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    Forgiving Grim Trigger with Final Round Defection for repeated Public Goods Game.
    - Cooperate initially.
    - If no defection ever observed, keep cooperating.
    - If defection seen in last round, defect this round (1-round punishment).
    - Else forgive and cooperate if others cooperated last round; defect if others still defected.
    - Defect unconditionally in the final round (endgame defection).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        last_round = self.n_rounds
        if current_round == last_round:
            return Action.D
        defection_rounds = []
        for round_idx in range(t):
            all_actions_round = [history.my_actions[round_idx]] + list(history.opponent_actions[round_idx])
            if not all(all_actions_round):
                defection_rounds.append(round_idx + 1)
        if not defection_rounds:
            return Action.C
        last_defect = defection_rounds[-1]
        if last_defect == current_round - 1:
            return Action.D
        else:
            last_round_idx = t - 1
            last_all_actions = [history.my_actions[last_round_idx]] + list(history.opponent_actions[last_round_idx])
            if all(last_all_actions):
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    Conditional Cooperator with Forgiveness for N-Player Public Goods Game.

    Summary:
    - Cooperates first round.
    - Cooperates if cooperation rate last round >= 80%.
    - Defects once to punish if cooperation drops below 80% and defection detected.
    - Forgives immediately if cooperation recovers.
    - Defects last round to maximize private payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.c_threshold = 0.8
        self.retaliation_length = 1
        self.retaliation_counter = 0
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = history.round_number + 1 if history is not None else 1
        if t == self.r:
            return Action.D
        if history is None:
            self.retaliation_counter = 0
            return Action.C
        if self.retaliation_counter > 0:
            self.retaliation_counter -= 1
            return Action.D
        prev_round_idx = t - 2
        last_round_actions = history.opponent_actions[prev_round_idx]
        my_last_action = history.my_actions[prev_round_idx]
        coop_count = int(my_last_action) + sum(last_round_actions)
        coop_ratio = coop_count / self.n
        any_defection = coop_count < self.n
        if any_defection and coop_ratio < self.c_threshold:
            self.retaliation_counter = self.retaliation_length - 1
            return Action.D
        if coop_ratio >= self.c_threshold:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Forgiving Trigger strategy for the repeated public goods game.
    
    - Start cooperating to initiate cooperation.
    - Cooperate when all players cooperated last round.
    - Defect to punish if any defection occurred last round.
    - Forgive after one round of punishment by cooperating again.
    - Defect on the last round to maximize own payoff as no future punishment possible.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number
        if current_round == self.r - 1:
            return Action.D
        prev_round_actions = history.opponent_actions[current_round - 1]
        my_action_prev = history.my_actions[current_round - 1]
        if all(prev_round_actions) and my_action_prev:
            any_defection_last_round = False
        else:
            any_defection_last_round = True
        if current_round >= 2:
            two_rounds_ago_actions = history.opponent_actions[current_round - 2]
            my_action_two_rounds_ago = history.my_actions[current_round - 2]
            if all(two_rounds_ago_actions) and my_action_two_rounds_ago:
                any_defection_two_rounds_ago = False
            else:
                any_defection_two_rounds_ago = True
            punished_last_round = any_defection_two_rounds_ago and my_action_prev == False
            if punished_last_round:
                return Action.C
        if any_defection_last_round:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    Forgiving Conditional Cooperation for N-player repeated Public Goods Game.

    - Round 1: cooperate unconditionally.
    - Rounds 2 to r-1:
        - If previous round cooperation ratio ≥ 0.8: cooperate and reset defect_streak.
        - If < 0.8: increment defect_streak.
            - If defect_streak ≤ 2 (forgiveness window): cooperate (forgive).
            - Else defect (punish persistent defection).
    - Round r (last round): defect (backward induction).
    """
    threshold_coop_ratio = 0.8
    forgiveness_window = 2

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.defect_streak = 0

    def __call__(self, history: None | PlayerHistory):
        if history is None:
            self.defect_streak = 0
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_coop_count = 0
        prev_round_index = t - 2
        self_coop_prev = history.my_actions[prev_round_index]
        opp_coop_prev = history.opponent_actions[prev_round_index]
        prev_coop_count = (1 if self_coop_prev else 0) + sum(opp_coop_prev)
        coop_ratio = prev_coop_count / self.n
        if coop_ratio >= self.threshold_coop_ratio:
            self.defect_streak = 0
            return Action.C
        else:
            self.defect_streak += 1
            if self.defect_streak <= self.forgiveness_window:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    Conditional Cooperator With Forgiveness (CCWF) for N-Player Public Goods Game.

    Strategy Summary:
    - Round 1: Cooperate.
    - Rounds 2 to r-1: Cooperate if all players cooperated in previous round;
      otherwise defect (punish). Forgives after one round of punishment if cooperation
      is restored.
    - Round r (last round): Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        self_action_prev_round = history.my_actions[prev_round_idx]
        opp_actions_prev_round = history.opponent_actions[prev_round_idx]
        all_actions_prev_round = [self_action_prev_round] + list(opp_actions_prev_round)
        if all(all_actions_prev_round):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness strategy for the N-Player Public Goods game.
    Starts cooperating, continues cooperating if group cooperation ratio in previous round
    meets the threshold theta. Defects for one round after substantial defection as punishment,
    but forgives if cooperation recovers within last m rounds. Always defects in last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.theta = 0.6
        self.m = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        theta = self.theta
        m = self.m
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_m_rounds = max(0, t - 1 - m)
        coop_ratios = []
        for past_round in range(last_m_rounds, t - 1):
            my_coop = 1 if history.my_actions[past_round] else 0
            opp_coop = history.opponent_actions[past_round].sum(dtype=int)
            total_cooperators = my_coop + opp_coop
            ratio = total_cooperators / n
            coop_ratios.append(ratio)
        prev_round = t - 2
        my_prev_coop = 1 if history.my_actions[prev_round] else 0
        opp_prev_coop = history.opponent_actions[prev_round].sum(dtype=int)
        prev_coop_ratio = (my_prev_coop + opp_prev_coop) / n
        sufficient_cooperation_prev = prev_coop_ratio >= theta
        forgiveness = any((ratio >= theta for ratio in coop_ratios))
        if sufficient_cooperation_prev:
            return Action.C
        elif forgiveness:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    Cooperative strategy for N-Player Public Goods Game (Repeated, Simultaneous Moves).

    - Cooperate in the first round.
    - In rounds 2 to r-1: 
        * Cooperate if all players cooperated in previous round.
        * Defect for exactly one round to punish if any defection detected in previous round.
    - Defect in the last round (round r) to avoid end-game collapse.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        last_round_actions_opponents = history.opponent_actions[t - 1]
        last_action_self = history.my_actions[t - 1]
        all_last_round_actions = [last_action_self]
        all_last_round_actions.extend(last_round_actions_opponents.tolist())
        all_last_round_actions = tuple(all_last_round_actions)
        all_cooperated = all(all_last_round_actions)
        if current_round == self.r:
            return Action.D
        if all_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    Conditional Cooperative Reciprocity (CCR) for N-Player Public Goods Game.
    
    Starts by cooperating. Then, in each intermediate round, it cooperates if all players
    cooperated last round or if at least 75% of the other players cooperated last round.
    If fewer cooperated and it itself cooperated last round, it defects this round to punish.
    Otherwise (if it defected last round or cooperation is too low), it cooperates to forgive.
    Always cooperates in the last round to maximize social welfare.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        threshold_float = 0.75 * (n - 1)
        threshold_int = int(threshold_float)
        self.threshold = threshold_int if threshold_float == threshold_int else threshold_int + 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == 1:
            return Action.C
        if current_round == r:
            return Action.C
        prev_actions = []
        prev_my_action = history.my_actions[-1]
        prev_actions = [prev_my_action] + list(history.opponent_actions[-1])
        prev_cooperators = sum(prev_actions)
        prev_cooperators_excl_me = prev_cooperators - (1 if prev_my_action else 0)
        if prev_cooperators == n:
            return Action.C
        if prev_cooperators_excl_me >= self.threshold:
            return Action.C
        if prev_my_action:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    Conditional Cooperative with Forgiveness (CCF) strategy for N-player repeated Public Goods Game.
    
    - Start cooperating in round 1.
    - If no defections and cooperation fraction ≥ 0.8, keep cooperating.
    - If defections occur, punish by defecting exactly one round.
    - Forgive and return to cooperation after punishment.
    - Defect on the last round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.cooperation_threshold = 0.8
        self._punishment_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 0 if history is None else history.round_number
        current_round = t + 1
        if history is None or t == 0:
            self._punishment_round = False
            return Action.C
        if current_round == self.r:
            return Action.D
        last_round_index = t - 1
        num_cooperators = 0
        if history.my_actions[last_round_index]:
            num_cooperators += 1
        num_cooperators += sum(history.opponent_actions[last_round_index])
        f = num_cooperators / self.n
        defectors_exist = num_cooperators < self.n
        if not self._punishment_round:
            if defectors_exist:
                self._punishment_round = True
                return Action.D
            elif f >= self.cooperation_threshold:
                return Action.C
            else:
                return Action.C
        else:
            self._punishment_round = False
            return Action.C

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Grim Trigger with Forgiveness for N-Player Public Goods Game.

    Starts by cooperating. Continues cooperating if all other players cooperated in the 
    previous round. If any defection is observed, punishes by defecting for a fixed number
    of rounds (forgiveness_duration=2), then attempts to return to cooperation. Defects in 
    the last round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_duration = 2
        self.punish_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory):
        r = self.game_description.n_rounds
        t = history.round_number if history is not None else 0
        if t == r - 1:
            return Action.D
        if self.punish_rounds_remaining > 0:
            self.punish_rounds_remaining -= 1
            return Action.D
        if t == 0:
            return Action.C
        previous_opponent_actions = history.opponent_actions[t - 1]
        if previous_opponent_actions.all():
            return Action.C
        else:
            self.punish_rounds_remaining = self.forgiveness_duration - 1
            return Action.D

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    Reciprocal Conditional Cooperation for repeated N-player public goods game.

    - Start cooperating (round 1) to signal willingness.
    - In rounds 2 to r-1, reciprocate cooperation if majority cooperated last round,
      else punish with one round defection.
    - Forgive after punishment by returning to cooperation.
    - Cooperate unconditionally in last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.defect_threshold = self.n / 2
        self.punishment_length = 1
        self.punishment_mode = False
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_mode = False
            self.punishment_rounds_left = 0
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            self.punishment_mode = False
            self.punishment_rounds_left = 0
            return Action.C
        if self.punishment_mode:
            self.punishment_rounds_left -= 1
            if self.punishment_rounds_left <= 0:
                self.punishment_mode = False
            return Action.D
        coop_count = int(history.my_actions[t - 2]) + history.opponent_actions[t - 2].sum()
        if coop_count < self.defect_threshold:
            self.punishment_mode = True
            self.punishment_rounds_left = self.punishment_length
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Cooperative Strategy: Conditional Mutual Cooperation with Forgiveness in
    N-Player Public Goods Game.

    - Cooperate in round 1.
    - For rounds 2 to r-1:
      * Cooperate if all other players cooperated last round.
      * Otherwise defect (punish) for `forgiveness` rounds after the last observed
        defection by any opponent, then forgive (cooperate).
    - Defect unconditionally in the final round (round r).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.forgiveness = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.n
        r = self.r
        f = self.forgiveness
        if t == r:
            return Action.D
        if t == 1:
            return Action.C
        last_round_opponents = history.opponent_actions[t - 2]
        if last_round_opponents.all():
            return Action.C
        last_defection_round = None
        for past_round_idx in reversed(range(history.round_number)):
            if not history.opponent_actions[past_round_idx].all():
                last_defection_round = past_round_idx + 1
                break
        if last_defection_round is None:
            return Action.C
        rounds_since_defection = t - last_defection_round
        if rounds_since_defection <= f:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    Reciprocal Grim-Trigger with Forgiveness for repeated Public Goods Game.

    - Cooperate initially.
    - Defect in the last round.
    - If any player defected in the immediately preceding round, punish defect once.
    - Forgive by returning to cooperation after one round of punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1]
        anyone_defected = not prev_opponent_actions.all()
        all_actions_prev = np.concatenate(([prev_my_action], prev_opponent_actions))
        anyone_defected = not all_actions_prev.all()
        if anyone_defected:
            if prev_my_action == True:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Gradual Reciprocity with Forgiveness for the N-player Public Goods repeated game.
    Start cooperating; continue cooperating if all cooperated last round.
    If any defection last round, defect once to punish, then forgive by cooperating.
    Defect on the last round always.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punished_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.punished_last_round = False
            return Action.C
        t = history.round_number
        if t == r:
            return Action.D
        last_round_idx = t - 1
        n = self.game_description.n_players
        my_coop = history.my_actions[last_round_idx]
        opp_coop_arr = history.opponent_actions[last_round_idx]
        all_cooperated_last_round = my_coop and opp_coop_arr.all()
        if all_cooperated_last_round:
            self.punished_last_round = False
            return Action.C
        elif not self.punished_last_round:
            self.punished_last_round = True
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for the N-Player Public Goods Game:
    - Cooperate initially.
    - Continue cooperating if at least 50% of other players cooperated in the previous round.
    - Defect otherwise (to punish defection).
    - Forgive immediately when cooperation recovers.
    - Always defect in the last round (backward induction).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.min_coop_threshold = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        round_num = history.round_number
        current_round = round_num + 1
        if current_round == r:
            return Action.D
        last_round_index = round_num - 1
        self_cooperated_last_round = history.my_actions[last_round_index]
        opponent_coop_count = history.opponent_actions[last_round_index].sum()
        c_count = opponent_coop_count + (1 if self_cooperated_last_round else 0)
        if self_cooperated_last_round:
            coop_fraction = (c_count - 1) / (n - 1)
        else:
            coop_fraction = c_count / (n - 1)
        if coop_fraction >= self.min_coop_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness strategy for the N-player repeated
    Public Goods Game.

    - Start by cooperating in round 1.
    - Cooperate if all players cooperated last round, else punish defectors by
      defecting once.
    - After one round of punishment, forgive by cooperating again.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.I_defected_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            self.I_defected_last_round = False
            return Action.C
        t = history.round_number + 1
        last_round_idx = history.round_number - 1
        last_round_my_action = history.my_actions[last_round_idx]
        last_round_opponent_actions = history.opponent_actions[last_round_idx]
        total_cooperators = last_round_my_action + last_round_opponent_actions.sum()
        if t == r:
            return Action.D
        if total_cooperators == n:
            self.I_defected_last_round = False
            return Action.C
        elif not self.I_defected_last_round:
            self.I_defected_last_round = True
            return Action.D
        else:
            self.I_defected_last_round = False
            return Action.C

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    Conditional Forgiving Cooperator for N-Player Public Goods Game.

    Starts cooperating; continues cooperating if all cooperated last round.
    If any defection detected, cooperates this round but schedules defect next round.
    Punishment round defects once, then returns to cooperation.
    Last round defects for backward induction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defect_next = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            self.defect_next = False
            return Action.C
        if t == r:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[t - 2]
        last_round_my_action = history.my_actions[t - 2]
        all_last_round_actions = [last_round_my_action]
        all_last_round_actions.extend(last_round_opponent_actions.tolist())
        all_cooperated = all(all_last_round_actions)
        if self.defect_next:
            self.defect_next = False
            return Action.D
        if all_cooperated:
            return Action.C
        else:
            self.defect_next = True
            return Action.C

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness strategy for repeated n-player public goods game.

    Summary:
    - Start cooperating in first round.
    - For rounds 2 to r-1:
      * If previous round had at least tau cooperating players total, cooperate.
      * Else defect this round as punishment.
      * Forgive after punishing by cooperating next round regardless.
    - Always cooperate in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.alpha = 0.7
        self.tau = int(self.alpha * self.n)
        if self.alpha * self.n > self.tau:
            self.tau += 1
        self.punished_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            self.punished_last_round = False
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            self.punished_last_round = False
            return Action.C
        prev_self = history.my_actions[-1]
        prev_opponents = history.opponent_actions[-1]
        num_cooperators = int(prev_self) + prev_opponents.sum()
        if self.punished_last_round:
            self.punished_last_round = False
            return Action.C
        if num_cooperators >= self.tau:
            self.punished_last_round = False
            return Action.C
        self.punished_last_round = True
        return Action.D

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    Reciprocal Conditional Cooperation with Forgiveness.

    - Cooperate in the first round.
    - Cooperate if everyone cooperated in the last round.
    - Defect to punish if any defection occurred last round (one round punishment).
    - Forgive immediately after punishment by cooperating if cooperation resumes.
    - Defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == n_rounds:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[history.round_number - 1]
        my_last_action = history.my_actions[-1]
        all_opponents_cooperated = last_round_opponent_actions.all()
        i_cooperated = my_last_action
        all_cooperated_last_round = all_opponents_cooperated and i_cooperated
        if all_cooperated_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    Forgiving Conditional Cooperator for N-Player Public Goods Game.

    - Start cooperating first round.
    - Cooperate if all others cooperated last round.
    - Defect to retaliate immediately if others defected last round.
    - Forgive after retaliation by cooperating next round.
    - Defect in the last round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        prev_opponent_actions = history.opponent_actions[t - 1]
        if prev_opponent_actions.all():
            return Action.C
        else:
            self_prev = history.my_actions[t - 1]
            if t - 2 >= 0:
                self_prev2 = history.my_actions[t - 2]
            else:
                self_prev2 = True
            if not self_prev:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for the N-player Public Goods Game.

    - Start cooperating first round.
    - Continue cooperating if everyone cooperated previous round.
    - If any defection last round, punish by defecting once.
    - Forgive after punishing by cooperating again.
    - Always cooperate on last round to maximize joint payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_num = history.round_number
        me = 0
        prev_my_action = history.my_actions[round_num - 1]
        prev_opponent_actions = history.opponent_actions[round_num - 1]
        prev_round_actions = [prev_my_action] + list(prev_opponent_actions)
        if round_num == self.r:
            return Action.C
        all_cooperated = all(prev_round_actions)
        if all_cooperated:
            return Action.C
        elif not prev_my_action:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Forgiving Conditional Cooperator strategy for N-player repeated Public Goods Game.
    - Cooperates initially.
    - Continues cooperating if all cooperated last round.
    - If any defected last round and not punished yet, defects once to punish.
    - Forgives punished defections by cooperating immediately next round.
    - Always defects on the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            self.punished = False
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_round_idx = t - 2
        opponents_last_actions = history.opponent_actions[last_round_idx]
        defectors_last_round = not opponents_last_actions.all()
        if self.punished:
            self.punished = False
            return Action.C
        if defectors_last_round:
            self.punished = True
            return Action.D
        self.punished = False
        return Action.C

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness Strategy for N-Player Public Goods Game.

    - Cooperate first round to signal goodwill.
    - From round 2 to r-1, cooperate if at least 70% of players cooperated in previous round, else defect.
    - Defect in the final round by backward induction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold = 0.7

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        elif t == self.r:
            return Action.D
        else:
            prev_round_coop_count = history.opponent_actions[t - 2].sum()
            self_prev_action_coop = 1 if history.my_actions[t - 2] else 0
            total_cooperators = prev_round_coop_count + self_prev_action_coop
            proportion = total_cooperators / self.n
            if proportion >= self.threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    Gradual Conditional Cooperator for N-Player Public Goods Game.

    Starts by cooperating unconditionally. In subsequent rounds, 
    uses thresholds on fraction of cooperators last round to decide action:
    
    - ≥ 0.8 fraction cooperators last round: cooperate.
    - ≥ 0.5 but < 0.8: cooperate only if cooperated last round.
    - < 0.5 cooperators: defect to punish.
    
    This promotes and sustains cooperation while guarding against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.COOP_THRESHOLD_HIGH = 0.8
        self.COOP_THRESHOLD_LOW = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_t = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_actions_all = history.opponent_actions[prev_round_idx]
        my_prev_action = history.my_actions[prev_round_idx]
        num_cooperators = int(my_prev_action) + prev_actions_all.sum()
        fraction_cooperators = num_cooperators / self.n
        if fraction_cooperators >= self.COOP_THRESHOLD_HIGH:
            return Action.C
        elif fraction_cooperators >= self.COOP_THRESHOLD_LOW:
            if my_prev_action:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    Cooperative strategy for the repeated public goods game.
    Starts by cooperating.
    In middle rounds (2 to r-1), cooperates if everyone cooperated last round;
    otherwise punishes defectors if personally defected upon by defecting once,
    then forgives by cooperating again.
    In the last round, cooperates only if everyone cooperated the previous round; else defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        if history is None:
            return Action.C
        t = history.round_number + 1
        my_index = 0
        if t == 1:
            return Action.C
        last_round = t - 1
        my_last_action = history.my_actions[last_round - 1]
        opponents_last_actions = history.opponent_actions[last_round - 1]
        last_round_actions_bool = [my_last_action] + list(opponents_last_actions)
        prev_round_cooperators = sum(last_round_actions_bool)
        did_all_cooperate = prev_round_cooperators == n
        did_any_defect = not did_all_cooperate
        if t < r:
            if did_all_cooperate:
                return Action.C
            elif my_last_action:
                return Action.D
            else:
                return Action.C
        elif did_all_cooperate:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    Gradual Reciprocity with Forgiveness for N-player repeated public goods game.

    Starts cooperating, punishes once if others mostly defect (<50% cooperation),
    then forgives immediately by cooperating next round. On last round,
    defects if cooperation broke down to secure private payoff; else cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.theta = 0.5
        self.forgiveness_window = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        last_round_idx = t - 2
        last_round_opp_actions = history.opponent_actions[last_round_idx]
        coop_count = last_round_opp_actions.sum()
        coop_rate = coop_count / (self.n - 1)
        defected_last_round = history.my_actions[last_round_idx] == False
        if defected_last_round:
            return Action.C
        if coop_rate >= self.theta:
            return Action.C
        elif t == self.r:
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    Conditional Reciprocity with Forgiveness for N-Player Public Goods Game.

    - Round 1: Cooperate to signal intent.
    - Rounds 2 to r-1: Cooperate if majority cooperated last round; otherwise defect,
      but randomly forgive with probability p (0.1) to encourage recovery.
    - Round r (last round): Defect (endgame logic).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        n = self.game_description.n_players
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        my_last = history.my_actions[-1]
        opp_last = history.opponent_actions[-1]
        num_cooperators = opp_last.sum() + (1 if my_last else 0)
        majority = n // 2 + 1
        if num_cooperators >= majority:
            return Action.C
        if random.random() < self.p:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    Grim Trigger with Forgiveness strategy for repeated N-player Public Goods Game.

    - Cooperate in first round.
    - From round 2 to (r-1): cooperate if and only if no defections happened in the
      previous round and punishment mode is off.
    - If any defection observed, enter punishment mode and defect for f rounds.
    - After f punishment rounds without new defections, forgive and cooperate again.
    - Defect on the last round unconditionally (backward induction).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.f = 2

    def __call__(self, history: None | PlayerHistory) -> Action:

        def round_has_defection(round_index: int) -> bool:
            if history.my_actions[round_index] is False:
                return True
            if history.opponent_actions.shape[1] > 0:
                return not history.opponent_actions[round_index].all()
            return False
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        defection_rounds = []
        for round_idx in range(t - 1):
            if round_has_defection(round_idx):
                defection_rounds.append(round_idx + 1)
        in_punishment = False
        for d in defection_rounds:
            if d + 1 <= t <= d + self.f:
                in_punishment = True
                break
        if in_punishment:
            return Action.D
        prev_round_idx = t - 2
        if prev_round_idx >= 0:
            if round_has_defection(prev_round_idx):
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    Conditional Cooperate-with-Forgiveness strategy for N-player repeated public goods game.

    - Cooperates in first round as goodwill signal.
    - Cooperates in rounds 2 to r-1 if others mostly cooperated last round.
    - If cooperation dips below threshold last round, defects to punish briefly.
    - Forgives quickly to restore cooperation unless defection persists.
    - Defects unconditionally in last round (backwards induction).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_threshold = 0.8
        self.forgive_threshold = 0.5
        self.punishment_length = 1
        self.forgiveness_window = 3
        self.punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        opp_actions = history.opponent_actions
        rounds_played = t
        coop_prev = opp_actions[t - 1].sum() / (n - 1)
        total_coop = opp_actions[:t].sum()
        coop_rate_all = total_coop / ((n - 1) * t)
        m = self.forgiveness_window
        start_round = max(0, t - m)
        rounds_considered = t - start_round
        if rounds_considered == 0:
            coop_recent = 1.0
        else:
            recent_coop_total = opp_actions[start_round:t].sum()
            coop_recent = recent_coop_total / ((n - 1) * rounds_considered)
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        if coop_prev >= self.coop_threshold:
            return Action.C
        elif coop_recent < self.forgive_threshold:
            return Action.D
        else:
            self.punishment_timer = self.punishment_length - 1
            return Action.D

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    Cooperative Strategy: Gradual Conditional Cooperation with Forgiveness in an N-player Public Goods Game.

    Starts cooperating to signal cooperative intent.
    If all players cooperated last round, continues cooperating.
    If any defection occurred last round, defects to punish except if self was the only defector,
    in which case it forgives immediately by cooperating.
    Forgives persistent defections if full cooperation is observed again.
    Always cooperates in the last round to avoid end-game defection spiral.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round_number = t + 1
        if current_round_number == r:
            return Action.C
        last_round_actions_self = history.my_actions[-1]
        last_round_actions_opponents = history.opponent_actions[-1]
        last_round_actions = [last_round_actions_self] + list(last_round_actions_opponents)
        last_round_cooperators = sum(last_round_actions)
        all_cooperated = last_round_cooperators == n
        any_defection_last_round = last_round_cooperators < n
        self_defected_last_round = last_round_actions[0] == False
        if all_cooperated:
            return Action.C
        if any_defection_last_round:
            if self_defected_last_round and last_round_cooperators == n - 1:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    Forgiving Conditional Cooperation strategy for the repeated N-player public goods game.

    Starts by cooperating, continues cooperating if others mostly cooperate (at least n-1 cooperate),
    defects one round to punish if cooperation drops below threshold, then forgives and returns to cooperate.
    Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.cooperation_threshold = self.n - 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        C_count = 0
        my_last_action = history.my_actions[t - 1]
        opp_last_round_actions = history.opponent_actions[t - 1]
        C_count = int(my_last_action) + int(opp_last_round_actions.sum())
        if C_count >= self.cooperation_threshold:
            if not my_last_action:
                return Action.C
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Forgiving Conditional Cooperator for N-Player Public Goods Game.

    Strategy:
    - Round 1: Cooperate.
    - Rounds 2 to r-1:
        * If previous round defection rate ≤ θ (0.25), cooperate.
        * Else defect this round to punish.
        * After one round of punishment (defecting due to high defection rate),
          forgive by cooperating next round regardless of previous defection rate.
    - Round r (last round): Defect to avoid exploitation (subgame perfect).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.gd = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.theta = 0.25

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_opp_acts = history.opponent_actions[t - 2]
        self_prev_action = history.my_actions[t - 2]
        opp_defectors_count = (~prev_opp_acts).sum()
        self_defector = 0 if self_prev_action else 1
        total_defectors = opp_defectors_count + self_defector
        defection_rate = total_defectors / self.n
        if t >= 3:
            prev2_opp_acts = history.opponent_actions[t - 3]
            prev2_self_action = history.my_actions[t - 3]
            opp_defectors_prev2 = (~prev2_opp_acts).sum()
            self_defector_prev2 = 0 if prev2_self_action else 1
            total_defectors_prev2 = opp_defectors_prev2 + self_defector_prev2
            defection_rate_prev2 = total_defectors_prev2 / self.n
            was_punishing = defection_rate_prev2 > self.theta and prev2_self_action is False
            if was_punishing:
                return Action.C
        if defection_rate > self.theta:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    Cooperative Strategy for N-Player Public Goods Game:
    - Round 1: Cooperate.
    - Intermediate rounds: 
      * Cooperate if all opponents cooperated previous round.
      * Defect if any opponent defected previous round (punish).
    - Last round: Defect.
    
    Uses boolean encoding of actions:
    True = Cooperate, False = Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == n_rounds:
            return Action.D
        last_opponent_actions = history.opponent_actions[history.round_number - 1]
        if last_opponent_actions.all():
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Generous Reciprocity with Forgiveness strategy for N-player repeated Public Goods Game.

    - Cooperate on first round to signal willingness.
    - From round 2 to round r-1, cooperate if at least tau fraction of others
      cooperated in immediately preceding round; else defect.
    - Defect on final round to maximize last round payoff.
    - tau (threshold) is 0.7 by default, allowing some forgiveness.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.tau = 0.7

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        last_round = None
        c_i_last = None
        n_c_last = None
        if history is not None:
            last_round = []
            c_i_last = history.my_actions[-1]
            n_c_last = np.sum(history.opponent_actions[-1]) + (1 if c_i_last else 0)
        else:
            return Action.C
        r_minus_i = (n_c_last - (1 if c_i_last else 0)) / (self.n - 1)
        if r_minus_i >= self.tau:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    Conditional Grim Trigger with Forgiveness strategy for the N-Player Public Goods Game.

    - Round 1: Cooperate unconditionally.
    - Rounds 2 to r-1: Cooperate if everyone cooperated in previous round, else defect.
      This punishes defection but forgives if full cooperation resumes.
    - Last round r: Defect unconditionally to avoid last-round exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        last_round = t - 1
        if last_round < 0:
            return Action.C
        my_last = history.my_actions[last_round]
        opp_last = history.opponent_actions[last_round]
        all_last = [my_last] + list(opp_last)
        if all(all_last):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness (CCF) strategy for the N-Player Public Goods Game.
    
    Starts by cooperating unconditionally in the first round.
    In middle rounds, cooperates if at least 80% cooperated last round,
    defects otherwise, but forgives if previously defected and cooperation rate improves.
    Defects unconditionally in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        n = self.n
        r = self.r
        theta = 0.8
        if t == r - 1:
            return Action.D
        coop_prev = 0.0
        coop_prevprev = 1.0
        if t >= 1:
            last_round_cooperators = sum(history.opponent_actions[t - 1]) + (1 if history.my_actions[t - 1] else 0)
            coop_prev = last_round_cooperators / n
        if t >= 2:
            prev_round_cooperators = sum(history.opponent_actions[t - 2]) + (1 if history.my_actions[t - 2] else 0)
            coop_prevprev = prev_round_cooperators / n
        my_prev_action = history.my_actions[t - 1] if t >= 1 else True
        if not my_prev_action:
            if coop_prev > coop_prevprev:
                return Action.C
            else:
                return Action.D
        if coop_prev >= theta:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    Gradual Reciprocity with Forgiveness for the N-Player Public Goods Game.

    Starts by cooperating. Continues cooperating if everyone cooperated last round.
    Defects to punish if defection detected last round.
    If everyone else defected last round (except self), tries cooperating to break punishment cycles.
    Always defects on the last round to avoid exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        last_round_index = t - 2
        if t == r:
            return Action.D
        self_last = history.my_actions[last_round_index]
        opponents_last = history.opponent_actions[last_round_index]
        last_round_actions = [self_last] + list(opponents_last)
        all_cooperated_last_round = all((last_round_actions_i == Action.C for last_round_actions_i in last_round_actions))
        if all_cooperated_last_round:
            return Action.C
        other_defectors = [a for i, a in enumerate(last_round_actions) if i != 0 and a == Action.D]
        other_cooperators = [a for i, a in enumerate(last_round_actions) if i != 0 and a == Action.C]
        if len(other_defectors) == n - 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    Forgiving Conditional Cooperation for N-Player Public Goods Game.

    - Start cooperating at round 1.
    - Cooperate at last round unconditionally.
    - At intermediate rounds:
        * Cooperate if all other players cooperated in previous round.
        * Defect for exactly one round as punishment if any defection detected last round.
        * Forgive and revert to cooperation if others resume cooperating after punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        my_last_actions = history.my_actions
        opp_last_actions = history.opponent_actions
        n = self.n
        r = self.r
        my_index = 0
        current_round = t + 1
        if current_round == 1:
            return Action.C
        if current_round == r:
            return Action.C
        others_cooperated_last = opp_last_actions[t - 1].all()
        my_last_action = my_last_actions[t - 1]
        if others_cooperated_last:
            return Action.C
        elif not my_last_action:
            if t >= 2:
                others_cooperated_prev = opp_last_actions[t - 2].all()
                if others_cooperated_prev:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness strategy for N-player Public Goods Game.

    - Start cooperating unconditionally.
    - Cooperate if no defections detected in last d rounds.
    - Upon any defection detected in the last d rounds, defect for P rounds (punishment),
      then forgive and revert to cooperation.
    - In the last round, cooperate only if no defection occurred in previous round,
      else defect to avoid exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.d = 1
        self.P = 1
        self.is_punishing = False
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.is_punishing = False
            self.punishment_rounds_left = 0
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds

        def recent_defection(history: PlayerHistory, current_round: int, d: int) -> bool:
            start = max(0, current_round - d - 1)
            end = current_round - 1
            for past_idx in range(start, end):
                if not history.my_actions[past_idx]:
                    return True
            if end > start:
                if (history.opponent_actions[start:end, :] == False).any():
                    return True
            return False
        if t == 1:
            self.is_punishing = False
            self.punishment_rounds_left = 0
            return Action.C
        if self.is_punishing:
            self.punishment_rounds_left -= 1
            if self.punishment_rounds_left <= 0:
                self.is_punishing = False
            return Action.D
        defection_found = recent_defection(history, t, self.d)
        if t == r:
            prev_round_defection = recent_defection(history, t, 1)
            if not prev_round_defection:
                return Action.C
            else:
                return Action.D
        if defection_found:
            self.is_punishing = True
            self.punishment_rounds_left = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    Grim Trigger for Public Goods:
    Start cooperating. Continue cooperating as long as no defection by any player 
    has ever been observed. Once any defection is detected in history, defect forever.
    This applies even in the last round, encouraging sustained cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        for past_action in history.my_actions:
            if not past_action:
                return Action.D
        for round_idx in range(history.round_number):
            for opponent_idx in range(history.opponent_actions.shape[1]):
                if not history.opponent_actions[round_idx, opponent_idx]:
                    return Action.D
        return Action.C

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    Reciprocal Conditional Cooperation with Forgiveness for N-Player Public Goods Game.
    
    - Round 1: Cooperate unconditionally.
    - Intermediate rounds: Cooperate if previous round had 0 or 1 defection; else defect.
    - Final round: Defect (backward induction).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        prev_opponent_actions = history.opponent_actions[t - 1]
        opponent_defections = (prev_opponent_actions == False).sum()
        my_last_action = history.my_actions[t - 1]
        total_defections_last_round = opponent_defections + (0 if my_last_action else 1)
        if total_defections_last_round == 0:
            return Action.C
        elif total_defections_last_round == 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Conditional Cooperative Trigger Strategy (CCTS) for N-Player Public Goods Game.

    - Round 1: Cooperate.
    - Rounds 2 to r-1: Cooperate if last round was full cooperation; else defect exactly one round to punish.
      Forgive and return to cooperation if cooperation resumes after punishment.
    - Round r (final): Defect (backward induction).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        if t == self.r:
            return Action.D
        last_round_own = history.my_actions[t - 1]
        last_round_opponents = history.opponent_actions[t - 1]
        last_round_all_actions = [last_round_own] + list(last_round_opponents)
        last_round_all_cooperate = all(last_round_all_actions)
        if last_round_all_cooperate:
            return Action.C
        if t - 2 >= 0:
            two_rounds_ago_own = history.my_actions[t - 2]
            two_rounds_ago_opponents = history.opponent_actions[t - 2]
            two_rounds_ago_all = [two_rounds_ago_own] + list(two_rounds_ago_opponents)
            two_rounds_ago_cooperate = all(two_rounds_ago_all)
        else:
            two_rounds_ago_cooperate = True
        if two_rounds_ago_cooperate and (not last_round_all_cooperate):
            return Action.D
        if last_round_all_cooperate:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    Forgiving Conditional Cooperator (FCC) strategy for the N-Player Public Goods Game.
    
    Summary:
    - Cooperate in the first round.
    - From round 2 to round r-1:
      * If in the previous round all players (including self and opponents) cooperated, cooperate.
      * If any player defected in the previous round:
         - If this player defected in that previous round (currently punishing), forgive by cooperating.
         - Otherwise (this player cooperated last round but saw defection), punish by defecting.
    - Defect in the last round to maximize immediate payoff.
    
    Notes:
    - history.my_actions and history.opponent_actions are boolean arrays:
      True = Cooperate (C), False = Defect (D).
    - history round_number is number of completed rounds, so current round t = history.round_number + 1.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        prev_round_index = t - 2
        your_prev_action = history.my_actions[prev_round_index]
        opponents_prev_actions = history.opponent_actions[prev_round_index] if history.opponent_actions.size > 0 else []
        all_prev_actions = [your_prev_action]
        if len(opponents_prev_actions) > 0:
            all_prev_actions.extend(opponents_prev_actions.tolist())
        all_cooperated = all(all_prev_actions)
        if all_cooperated:
            return Action.C
        if not your_prev_action:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for N-Player Public Goods Game.

    This strategy:
    - Cooperates initially.
    - If all cooperated last round, cooperates again.
    - If any defection last round, punishes by defecting one round.
    - Then forgives by cooperating one round.
    - Cycles punish/forgive until cooperation restored.
    - Always defects in final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.state = 'cooperate'

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = 1 if history is None else history.round_number + 1
        if current_round == r:
            return Action.D
        if history is None:
            self.state = 'cooperate'
            return Action.C
        last_round_index = history.round_number - 1
        my_last_action = history.my_actions[last_round_index]
        opponents_last_actions = history.opponent_actions[last_round_index]
        all_last_actions = [my_last_action] + list(opponents_last_actions)
        all_cooperated = all(all_last_actions)
        if self.state == 'cooperate':
            if all_cooperated:
                return Action.C
            else:
                self.state = 'punish'
                return Action.D
        elif self.state == 'punish':
            self.state = 'forgive'
            return Action.D
        elif all_cooperated:
            self.state = 'cooperate'
            return Action.C
        else:
            self.state = 'punish'
            return Action.D

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Forgiving Conditional Cooperation (FCC) strategy for the n-player repeated Public Goods Game.
    - Start cooperating in the first round.
    - In middle rounds, cooperate if at least 70% of all players cooperated last round; otherwise,
      defect once to punish, then forgive and return to cooperation if cooperation rebounds.
    - Defect in the last round by backward induction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.r = self.game_description.n_rounds
        self.k = self.game_description.k
        self.T = 0.7

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        me = 0
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        own_last_action = history.my_actions[prev_round_idx]
        others_last_actions = history.opponent_actions[prev_round_idx]
        total_cooperators = int(own_last_action) + others_last_actions.sum()
        fraction_cooperators = total_cooperators / self.n
        last_action = history.my_actions[prev_round_idx]
        if fraction_cooperators >= self.T:
            return Action.C
        elif last_action == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    Gradual Forgiver with Final Cooperation for the N-player repeated public goods game.

    - Round 1: Cooperate to signal intent.
    - Rounds 2 to r-1: Cooperate iff no currently unforgiven defections by others.
      Punish defectors by defecting for f rounds after their defection.
    - Round r (last): Always cooperate to maximize group payoff.

    Uses a forgiveness threshold f (set to 1), i.e., one round punishment per defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.f = 1
        self.forgive_counter = [0] * (self.n - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.forgive_counter = [0] * (self.n - 1)
            return Action.C
        t = history.round_number
        if t == self.r - 1:
            return Action.C
        prev_actions = history.opponent_actions[t - 1]
        for i in range(self.n - 1):
            if not prev_actions[i]:
                self.forgive_counter[i] = self.f
            elif self.forgive_counter[i] > 0:
                self.forgive_counter[i] -= 1
        if all((count == 0 for count in self.forgive_counter)):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    Cooperative Strategy for N-player repeated Public Goods Game.
    
    Starts by cooperating to build trust. 
    In intermediate rounds, cooperates if all cooperated last round, else
    defects if it cooperated last round to punish defectors, or cooperates if it defected last round to forgive.
    Defects on the last round to avoid exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        prev_my_action = history.my_actions[t - 2]
        prev_opp_actions = history.opponent_actions[t - 2]
        prev_round_actions = [prev_my_action] + list(prev_opp_actions)
        all_cooperated = all(prev_round_actions)
        if all_cooperated:
            return Action.C
        elif not prev_my_action:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    Fully cooperative conditional strategy for repeated N-player Public Goods Game:
    
    - Cooperate in the first round unconditionally.
    - From round 2 to round r-1:
      * Cooperate if everyone cooperated in previous round.
      * Otherwise, defect once to punish, then forgive by cooperating next round.
    - In last round:
      * Cooperate if previous round was full cooperation to maximize payoff.
      * Defect otherwise (no future incentive).
      
    Memory-1 strategy: only depends on the previous round's actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        last_round = current_round == r
        prev_actions_all = history.opponent_actions[history.round_number - 1]
        prev_my_action = history.my_actions[history.round_number - 1]
        all_cooperated = prev_my_action and prev_actions_all.all()
        if last_round:
            if all_cooperated:
                return Action.C
            else:
                return Action.D
        if history.round_number >= 2:
            prev_prev_actions_all = history.opponent_actions[history.round_number - 2]
            prev_prev_my_action = history.my_actions[history.round_number - 2]
            prev_round_defection = not prev_my_action or not prev_actions_all.all()
            punished_last_round = prev_round_defection and prev_my_action == Action.D
        else:
            punished_last_round = False
        if all_cooperated:
            return Action.C
        elif punished_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Forgiving Conditional Cooperator for the repeated N-Player Public Goods Game.

    - Cooperates in the first round.
    - In rounds 2 to r-1:
      * Cooperates if last round had full cooperation (all players cooperated).
      * Cooperates if last round had ≤ 2 defectors (forgives occasional defections).
      * Otherwise defects to punish widespread defection.
    - Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.max_defectors_tolerated = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        opponents_last = history.opponent_actions[t - 1]
        my_last = history.my_actions[t - 1]
        cooperators_last = int(my_last) + opponents_last.sum()
        defectors_last = self.n - cooperators_last
        if defectors_last == 0:
            return Action.C
        if defectors_last <= self.max_defectors_tolerated:
            if my_last:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    Cooperative Strategy: Conditional Cooperation with Forgiveness

    Starts by cooperating. In rounds 2 to r-1:
    - Cooperates if group cooperation rate in previous round >= 0.7
    - Defects (punishes) otherwise.
    - If punished previously (defected due to low cooperation), forgives and returns to cooperate once cooperation rebounds.
    In the final round, always defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.theta = 0.7

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        if t + 1 == r:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[t - 1]
        num_cooperators = int(last_round_opponent_actions.sum()) + (1 if history.my_actions[t - 1] else 0)
        cooperation_ratio = num_cooperators / n
        own_last_action = history.my_actions[t - 1]
        if cooperation_ratio >= self.theta:
            return Action.C
        if not own_last_action:
            if cooperation_ratio >= self.theta:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    Conditional Reciprocity with Forgiveness for repeated N-player Public Goods Game.
    
    Summary:
      - Round 1: Cooperate
      - Rounds 2 to r-1:
          * Cooperate if all players cooperated last round
          * If anyone defected last round and we cooperated, punish by defecting once
          * If we defected last round, forgive by cooperating
      - Round r (last round): Defect to avoid exploitation
      
    The strategy encourages mutual cooperation, punishes defection with a single-round retaliation,
    and then quickly forgives to restore cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.THRESHOLD = self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round = t - 1
        own_prev = history.my_actions[prev_round - 1]
        opp_prev = history.opponent_actions[prev_round - 1] if prev_round - 1 >= 0 else []
        cooperators_prev = int(own_prev) + int(opp_prev.sum())
        if cooperators_prev == self.THRESHOLD:
            return Action.C
        if own_prev == False:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Forgiving Conditional Cooperator (FCC) strategy for N-player repeated Public Goods Game.

    - Start cooperating.
    - If everyone cooperated last round, cooperate again.
    - If any defection last round and not currently punishing, punish by defecting once.
    - If currently punishing, forgive and cooperate.
    - Always cooperate in the final round.

    This implements conditional cooperation with forgiveness to sustain cooperation
    while punishing defectors briefly, and ensures cooperation in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            self.punishment_round = False
            return Action.C
        t = history.round_number + 1
        if t == r:
            self.punishment_round = False
            return Action.C
        last_round_my_action = history.my_actions[-1]
        last_round_opp_actions = history.opponent_actions[-1]
        last_round_all = [last_round_my_action] + list(last_round_opp_actions)
        everyone_cooperated = all(last_round_all)
        if everyone_cooperated:
            self.punishment_round = False
            return Action.C
        if not self.punishment_round:
            self.punishment_round = True
            return Action.D
        else:
            self.punishment_round = False
            return Action.C

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    Forgiving Conditional Cooperation with Final Round Defection
    - Cooperate first round
    - Cooperate if all cooperated last round
    - Otherwise punish defection by defecting one round
    - Then forgive and return to cooperation
    - Defect in the final round to maximize own payoff
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 0 if history is None else history.round_number
        current_round = t + 1
        if history is None:
            return Action.C
        if current_round == self.r:
            return Action.D
        last_round_idx = t - 1
        prev_round_idx = t - 2
        last_round_actions = [history.my_actions[last_round_idx]]
        for opp_action in history.opponent_actions[last_round_idx]:
            last_round_actions.append(opp_action)
        all_cooperated_last = all(last_round_actions)
        if all_cooperated_last:
            return Action.C
        else:
            if current_round == 2:
                punished_last = False
            else:
                prev_round_actions = [history.my_actions[prev_round_idx]]
                for opp_action in history.opponent_actions[prev_round_idx]:
                    prev_round_actions.append(opp_action)
                defected_prev_round = not all(prev_round_actions)
                punished_last = defected_prev_round
            if punished_last:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    Conditional Cooperation with Forgiving Punishment for the N-Player Public Goods Game.

    Starts cooperating. If any defection is observed in the previous round, punishes by defecting.
    Punishment continues until a full cooperative round is observed, after which it forgives and 
    returns to cooperation. In the last round, defects if trust broken, else cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            self.punish = False
            return Action.C
        t = history.round_number
        r = self.game_description.n_rounds
        prev_round = t - 1
        my_last = history.my_actions[prev_round]
        opp_last = history.opponent_actions[prev_round]
        all_last = [my_last] + opp_last.tolist()
        any_defect_last = not all(all_last)
        if 1 < t < r:
            if not self.punish:
                if not any_defect_last:
                    return Action.C
                else:
                    self.punish = True
                    return Action.D
            elif not any_defect_last:
                self.punish = False
                return Action.C
            else:
                return Action.D
        elif t == r:
            if not self.punish and (not any_defect_last):
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Cooperative Strategy for N-Player Public Goods Game:
    Conditional cooperator with forgiveness and endgame awareness.
    - Round 1: Always cooperate.
    - Intermediate rounds: cooperate if all cooperated last round;
      else defect with probability 0.8, cooperate with probability 0.2.
    - Last round: always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.8

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        last_round_index = history.round_number - 1
        last_round_opponents = history.opponent_actions[last_round_index]
        my_last_action = history.my_actions[last_round_index]
        all_cooperated_last_round = my_last_action and all(last_round_opponents)
        if all_cooperated_last_round:
            return Action.C
        elif random.random() < self.p:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness (CCF) for N-player repeated public goods game.

    - Round 1: Cooperate (signal cooperation)
    - Rounds 2 to r-1:
        * If all players cooperated previous round: cooperate
        * Else (any defection previous round): defect (punish)
    - Last round (r): defect to avoid exploitation
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_number = history.round_number
        current_round = round_number + 1
        if current_round == self.r:
            return Action.D
        prev_opponent_actions = history.opponent_actions[round_number - 1]
        all_cooperated_prev = history.my_actions[round_number - 1] and prev_opponent_actions.all()
        if all_cooperated_prev:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    Generous Conditional Cooperation (GCC) strategy for the repeated N-player Public Goods Game.

    - Cooperates in the first round.
    - Defects unconditionally in the last round.
    - From round 2 to r-1:
      * Cooperates if previous round cooperation rate >= 0.8 (including self).
      * Otherwise, defects as punishment for at most 1 consecutive low cooperation round.
      * Forgives (cooperates) after 1 punishment round to try to restore cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.THRESHOLD = 0.8
        self.MAX_PUNISH_ROUNDS = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        my_prev_action = history.my_actions[prev_round_idx]
        opp_prev_actions = history.opponent_actions[prev_round_idx]
        cooperation_count = opp_prev_actions.sum() + (1 if my_prev_action else 0)
        cooperation_rate = cooperation_count / self.n
        low_coop_streak = 0
        for round_i in range(prev_round_idx, -1, -1):
            coop_i = history.opponent_actions[round_i].sum() + (1 if history.my_actions[round_i] else 0)
            coop_rate_i = coop_i / self.n
            if coop_rate_i < self.THRESHOLD:
                low_coop_streak += 1
            else:
                break
        if cooperation_rate >= self.THRESHOLD:
            return Action.C
        if low_coop_streak < self.MAX_PUNISH_ROUNDS:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Cooperative Strategy: Conditional Reciprocity with Forgiveness
    - Cooperate first round
    - Cooperate if all others cooperated last round
    - Forgive at most one defection once (T=1)
    - Defect if forgiven once and defectors persist or defectors > 1
    - Defect in last round (backward induction)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = 1
        self._forgave = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        n = self.game_description.n_players
        if history is None or history.round_number == 0:
            self._forgave = False
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        last_opponent_actions = history.opponent_actions[t - 1]
        defectors = (last_opponent_actions == False).sum()
        if defectors == 0:
            self._forgave = False
            return Action.C
        if defectors <= self.T:
            if not self._forgave:
                self._forgave = True
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Cooperative Conditional Grudger with Forgiveness and Responsive Cooperation
    in the repeated Public Goods Game.

    - Start cooperating in the first round to build trust.
    - If all players cooperated last round, cooperate.
    - If any player defected last round, defect to punish.
    - Punishment ends (forgiveness) as soon as everyone cooperates again.
    - Always cooperate in the last round to maximize joint payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.punishment = False
            return Action.C
        t = history.round_number + 1
        n = self.game_description.n_players
        last_round_actions = [bool(history.my_actions[t - 2])] + list(history.opponent_actions[t - 2])
        all_cooperated = all(last_round_actions)
        if t == r:
            return Action.C
        if not self.punishment:
            if all_cooperated:
                return Action.C
            else:
                self.punishment = True
                return Action.D
        elif all_cooperated:
            self.punishment = False
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    Grim Trigger with Forgiveness strategy for N-player repeated Public Goods Game.

    - Start cooperating.
    - Cooperate if all players cooperated in all past rounds and not punishing.
    - If any defection seen in past rounds (since last forgiveness), start punishing by defecting.
    - While punishing, defect each round.
      After each punishing round, if all players cooperated in that punishing round, forgive and return to cooperate.
    - Defect in last round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            self.punishing = False
            return Action.C
        round_done = history.round_number
        current_round = round_done + 1
        if current_round == r:
            return Action.D
        if current_round > 1:
            all_cooperated_before = True
            for round_idx in range(current_round - 1):
                if not history.my_actions[round_idx]:
                    all_cooperated_before = False
                    break
                if not all(history.opponent_actions[round_idx]):
                    all_cooperated_before = False
                    break
        else:
            all_cooperated_before = True
        if not self.punishing:
            if all_cooperated_before:
                return Action.C
            else:
                self.punishing = True
                return Action.D
        action = Action.D
        if current_round > 1 and self.punishing:
            prev_round_idx = current_round - 2
            my_prev = history.my_actions[prev_round_idx]
            opp_prev = history.opponent_actions[prev_round_idx]
            if my_prev and all(opp_prev):
                self.punishing = False
        return action

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    Reciprocating Conditional Cooperator:
    - Cooperate initially and as long as no defections have occurred.
    - Punish permanently after any defection (grim trigger).
    - Defect in the last round to avoid exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        if not history.my_actions.all():
            return Action.D
        if not history.opponent_actions.all():
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Conditional reciprocity with forgiveness and endgame cooperation for the repeated
    N-Player Public Goods Game.

    - Start cooperating first round.
    - In rounds 2..r-1, cooperate if all cooperated last round.
      Otherwise defect once to punish if not punished last round, else forgive by cooperating.
    - In final round, cooperate unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        if t == r:
            return Action.C
        my_last_action = history.my_actions[-1]
        n = self.game_description.n_players
        last_round_opponent_actions = history.opponent_actions[-1]
        all_coop = my_last_action and last_round_opponent_actions.all()
        if t == 1:
            punished_last_round = False
        else:
            player_action_prev = history.my_actions[-1]
            if t == 2:
                was_all_coop_prev = True
            else:
                prev_round_opponents = history.opponent_actions[-2]
                my_action_prev_prev = history.my_actions[-2]
                was_all_coop_prev = my_action_prev_prev and prev_round_opponents.all()
            punished_last_round = not player_action_prev and (not was_all_coop_prev)
        if all_coop:
            return Action.C
        elif not punished_last_round:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Forgiving-Grim Strategy for the repeated N-Player Public Goods Game.

    Summary:
    - Round 1: Cooperate to build trust.
    - Rounds 2 to r-1:
        * If previous round was full cooperation (all cooperated), cooperate.
        * If previous round had any defection, defect this round to punish.
        * After punishing one round, if cooperation resumes, forgive by cooperating again.
    - Round r (last round): defect unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        last_opponent_actions = history.opponent_actions[t - 1]
        last_my_action = history.my_actions[t - 1]
        total_cooperators_last_round = last_opponent_actions.sum() + (1 if last_my_action else 0)
        if total_cooperators_last_round == self.game.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    Gradual Reciprocity with Forgiveness strategy for N-Player Public Goods Game.
    
    - Round 1: Cooperate unconditionally.
    - Intermediate rounds:
        * Cooperate if all players cooperated in previous round.
        * If any defection occurred last round:
            - Defect once as punishment if cooperated last round.
            - Otherwise (if defected last round), forgive by cooperating.
    - Last round:
        * Cooperate if all players cooperated in (r-1)th round.
        * Defect otherwise.
        
    Assumes perfect monitoring and repeated play, punishes defections once,
    then forgives to restore cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1 or history is None:
            return Action.C
        last_round_idx = t - 2
        own_last = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        total_cooperators = int(own_last) + int(opp_last_actions.sum())
        full_coop_last = total_cooperators == self.n
        if t == self.r:
            if full_coop_last:
                return Action.C
            else:
                return Action.D
        if full_coop_last:
            return Action.C
        if own_last == True:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    Forgiving Tit-for-Tat with Gradual Recovery for repeated N-player Public Goods Game.

    - Start by cooperating.
    - From round 2 to r-1:
        * Cooperate if all others cooperated last round.
        * If any others defected last round and this player cooperated then, defect once as punishment.
        * If player defected last round (i.e. just punished), cooperate now to forgive.
    - Defect unconditionally in the final round to avoid exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_opponent_acts = history.opponent_actions[history.round_number - 1]
        all_cooperated = last_opponent_acts.all()
        own_last_action = history.my_actions[history.round_number - 1]
        if all_cooperated:
            return Action.C
        if own_last_action == True:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    Reciprocal Conditional Cooperation with Forgiveness for N-Player Public Goods Game.

    - Cooperates initially.
    - Maintains cooperation if majority cooperated last round.
    - Defects to punish if self cooperated but cooperation below threshold last round.
    - Forgives isolated defections (including own) within a forgiveness window.
    - Defects permanently if everyone defected last round.
    - In final round, cooperates if average cooperation was stable, else defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.CoopThreshold = -(-int(0.7 * self.n) if 0.7 * self.n == int(0.7 * self.n) else int(0.7 * self.n) + 1)
        x = 0.7 * self.n
        self.CoopThreshold = int(x) if x == int(x) else int(x) + 1
        self.ForgivenessWindow = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        last_round_index = t - 1
        last_round_actions_bool = [history.my_actions[last_round_index]]
        for a in history.opponent_actions[last_round_index]:
            last_round_actions_bool.append(a)
        total_coop_last = sum(last_round_actions_bool)
        my_last_action = history.my_actions[last_round_index]
        if total_coop_last == 0:
            return Action.D
        total_coop_all = np.count_nonzero(history.my_actions) + np.count_nonzero(history.opponent_actions)
        avg_coop = total_coop_all / (self.n * t)
        start_idx = max(0, t - self.ForgivenessWindow)
        recent_my_actions = history.my_actions[start_idx:t]
        recent_my_defections = np.count_nonzero(np.logical_not(recent_my_actions))
        if current_round == self.r:
            if self.r > 1:
                coop_up_to_last = np.count_nonzero(history.my_actions[:-1]) + np.count_nonzero(history.opponent_actions[:-1])
                denom = self.n * (self.r - 1)
                avg_coop_before_final = coop_up_to_last / denom if denom > 0 else 0.0
            else:
                avg_coop_before_final = avg_coop
            if avg_coop_before_final >= 0.8:
                return Action.C
            else:
                return Action.D
        if total_coop_last >= self.CoopThreshold:
            return Action.C
        if my_last_action:
            return Action.D
        elif recent_my_defections > 1:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Gradual Reciprocity with Final Round Defection for N-Player Public Goods Game.
    
    - Cooperate in first round.
    - In intermediate rounds:
      * Cooperate if all cooperated previous round.
      * If anyone defected previously:
        - Defect once to punish if I cooperated last round.
        - Then forgive by cooperating if I defected last round.
    - Defect in last round to maximize individual payoff (no future rounds).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        me = 0
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        my_last_action = history.my_actions[t - 2]
        last_opponents_actions = history.opponent_actions[t - 2]
        last_round_actions = [None] * self.game_description.n_players
        last_round_actions[0] = my_last_action
        for i in range(self.game_description.n_players - 1):
            last_round_actions[i + 1] = last_opponents_actions[i]
        if all(last_round_actions):
            return Action.C
        if my_last_action:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for the N-Player Public Goods Game.
    
    - Cooperate first round.
    - Cooperate if last round had at most one defector (≥ n-1 cooperators).
    - Defect to punish otherwise.
    - If punished last round, check if others cooperated last round and forgive (cooperate) if so.
    - Defect deterministically in final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T = self.n - 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.n
        r = self.r
        T = self.T
        if t == r:
            return Action.D
        last_round_idx = t - 2
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        num_cooperators_last_round = int(my_last_action) + int(opp_last_actions.sum())
        did_punish_last_round = False
        if t >= 3:
            round_before_last_idx = t - 3
            my_action_round_before_last = history.my_actions[round_before_last_idx]
            my_action_last_round = history.my_actions[last_round_idx]
            if not my_action_last_round:
                did_punish_last_round = True
        if did_punish_last_round:
            if num_cooperators_last_round >= T:
                return Action.C
            else:
                return Action.D
        if num_cooperators_last_round >= T:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    Gradual Reciprocity with Optimistic Start for N-player Public Goods Game.

    Starts by cooperating to signal willingness. For rounds 2 to r-1,
    cooperates if the average number of cooperators in all previous rounds
    was at least half of the players, else defects. Defects in the last round
    anticipating endgame rationality. Forgiving to allow recovery of cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        total_cooperators_sum = 0
        rounds_completed = history.round_number
        for round_idx in range(rounds_completed):
            coop_count = (1 if history.my_actions[round_idx] else 0) + sum(history.opponent_actions[round_idx])
            total_cooperators_sum += coop_count
        C_avg = total_cooperators_sum / rounds_completed if rounds_completed > 0 else 0
        threshold = self.n / 2
        if C_avg >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    Cooperative strategy for the repeated N-Player Public Goods Game.
    
    - Start by cooperating.
    - Continue cooperating if majority (ceil(n/2)) cooperated in previous round (including self).
    - Defect for one round (punishment) if cooperation fell below majority.
    - Forgive immediately after punishment round if majority cooperation resumed.
    - In final round, cooperate if majority cooperated last round; else defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.threshold = (self.n + 1) // 2
        self.punishment_flag = False

    def __call__(self, history: None | PlayerHistory) -> 'Action':
        C = True
        D = False
        if history is None or history.round_number == 0:
            self.punishment_flag = False
            return Action.C
        t = history.round_number + 1
        prev_round_idx = history.round_number - 1
        opp_coops = 0
        if prev_round_idx >= 0:
            opp_coops = history.opponent_actions[prev_round_idx].sum(dtype=int)
            self_prev_action = 1 if history.my_actions[prev_round_idx] else 0
            prev_coops = opp_coops + self_prev_action
        else:
            prev_coops = 0
        majority_cooperated = prev_coops >= self.threshold
        if 1 < t < self.r:
            if majority_cooperated:
                action = Action.C
                self.punishment_flag = False
            else:
                action = Action.D
                self.punishment_flag = True
        elif t == self.r:
            if majority_cooperated:
                action = Action.C
            else:
                action = Action.D
        else:
            action = Action.C
            self.punishment_flag = False
        return action

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Reciprocal Forgiving Cooperation strategy for N-Player Public Goods Game.
    
    Summary:
    - Round 1: Cooperate to seed cooperation.
    - Rounds 2 to r-1: 
        * If last round fully cooperative (all players cooperated), cooperate.
        * Else defect once as punishment, then forgive (return to cooperate).
    - Round r (last round): Defect (no future incentive).
    
    Implements a stateful punishment flag inferred from history:
    - If a defection was observed two rounds ago, this round is a punishment round (defect).
    - Otherwise, cooperate if all cooperated last round, else start punishment next round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        last_round_index = history.round_number - 1
        n = self.n
        if current_round == self.r:
            return Action.D
        last_round_all_coop = history.my_actions[last_round_index] and history.opponent_actions[last_round_index].all()
        last_round_any_defect = not last_round_all_coop
        if current_round <= 2:
            return Action.C
        two_rounds_ago_index = current_round - 3
        two_rounds_ago_all_coop = history.my_actions[two_rounds_ago_index] and history.opponent_actions[two_rounds_ago_index].all()
        two_rounds_ago_any_defect = not two_rounds_ago_all_coop
        if two_rounds_ago_any_defect:
            return Action.D
        if last_round_all_coop:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    Conditional cooperator with forgiveness and endgame defection for
    N-Player Public Goods Game. Cooperates initially, then cooperates
    if others mostly cooperated last round, defects to punish defections,
    forgives after punishment if cooperation resumes, and defects in last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold = 0.8
        self.player_index = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if self.player_index is None:
            self.player_index = 0
        if t == self.r:
            return Action.D
        own_prev = history.my_actions[-1]
        opp_prev = history.opponent_actions[-1]
        last_round_actions = [own_prev] + list(opp_prev)
        coop_others = sum((1 for i, a in enumerate(last_round_actions) if i != self.player_index and a))
        coop_rate = coop_others / (self.n - 1)
        if coop_rate >= self.threshold:
            return Action.C
        elif t > 2:
            own_prev_prev = history.my_actions[-2]
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    Forgiving Trigger strategy for the N-Player Public Goods Game.
    Cooperates initially to build trust, punishes defection once,
    then forgives by returning to cooperation if others do, and defects
    in the final round to avoid exploitation due to backward induction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        if current_round == 1:
            return Action.C
        if t == 0:
            return Action.C
        last_round_my_action = history.my_actions[t - 1]
        last_round_opponent_actions = history.opponent_actions[t - 1]
        coop_count = (1 if last_round_my_action else 0) + sum(last_round_opponent_actions)
        coop_fraction = coop_count / n
        last_round_was_punishment = False
        if t >= 1:
            if t - 1 >= 0:
                prev_last_round_my_action = history.my_actions[t - 2] if t - 2 >= 0 else None
                prev_last_round_opp_actions = history.opponent_actions[t - 2] if t - 2 >= 0 else None
                if prev_last_round_my_action is not None and prev_last_round_opp_actions is not None:
                    prev_coop_count = (1 if prev_last_round_my_action else 0) + sum(prev_last_round_opp_actions)
                    prev_coop_fraction = prev_coop_count / n
                else:
                    prev_coop_fraction = 1.0
            else:
                prev_coop_fraction = 1.0
            if coop_fraction < 0.9 and history.my_actions[t - 1] == False:
                last_round_was_punishment = True
        if last_round_was_punishment:
            return Action.C
        if coop_fraction >= 0.9:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Conditional Grim-Trigger Cooperate strategy for repeated N-Player Public Goods Game.

    - Round 1: Cooperate unconditionally.
    - Rounds 2 to r-1: Cooperate if *all* players cooperated in previous round; else defect forever.
    - Round r (last): Defect unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        prev_round_my_action = history.my_actions[t - 2]
        prev_round_opp_actions = history.opponent_actions[t - 2]
        if prev_round_my_action and prev_round_opp_actions.all():
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for N-Player Public Goods Game.
    - Cooperate initially.
    - Cooperate if all others cooperated last round.
    - If defections occurred, punish persistent defectors (defection count > T).
    - Forgive rare mistakes by cooperating if defections below threshold.
    - Defect in the last round to avoid exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        C = Action.C
        D = Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            return C
        t = history.round_number
        current_round = t + 1
        if current_round == 1:
            return C
        if current_round == r:
            return D
        last_round_opponents = history.opponent_actions[t - 1]
        if all(last_round_opponents):
            return C
        defect_counts = []
        for j in range(n - 1):
            count_defections = (history.opponent_actions[:t, j] == False).sum()
            defect_counts.append(count_defections)
        for count in defect_counts:
            if count > self.T:
                return D
        return C

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    Forgiving Conditional Cooperation strategy for N-Player Public Goods Game:
    - Round 1: Cooperate
    - Rounds 2 to r-1: Cooperate if majority (≥ ceil(n/2)) cooperated last round, else defect
    - Round r: Defect (last round)
    Forgives occasional defections by returning to cooperation if majority cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold = (self.n + 1) // 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        if t == self.r - 1:
            return Action.D
        last_round_actions = history.opponent_actions[t - 1]
        coop_count = last_round_actions.sum() + (1 if history.my_actions[t - 1] else 0)
        if coop_count >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    Gradual Conditional Cooperator (GCC) for N-Player Public Goods Game.
    
    Starts cooperating. From round 2 to r-1, it monitors fraction of defectors in the
    previous round; if above threshold, it punishes by defecting for a fixed short duration,
    then forgives and returns to cooperation. Always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold = 0.2
        self.punishment_duration = 1
        self.defection_detected = False
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            self.defection_detected = False
            self.punishment_rounds_left = 0
            return Action.C
        if t == self.r:
            return Action.D
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            if self.punishment_rounds_left == 0:
                self.defection_detected = False
            return Action.D
        last_round_opponent_actions = history.opponent_actions[history.round_number - 1]
        num_opponent_defectors = (last_round_opponent_actions == False).sum()
        my_last_action = history.my_actions[history.round_number - 1]
        my_last_defect = my_last_action == False
        num_defectors = num_opponent_defectors + (1 if my_last_defect else 0)
        frac_defect = num_defectors / self.n
        if frac_defect > self.threshold:
            self.defection_detected = True
            self.punishment_rounds_left = self.punishment_duration - 1
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Reciprocal Conditional Cooperation with Gradual Forgiveness for the repeated N-player Public Goods Game.

    Implements:
    - Round 1: Cooperate unconditionally.
    - Intermediate rounds (2 ≤ t < r):
        * If all cooperated last round: cooperate.
        * If some defected:
            - If self cooperated last round: defect (punish).
            - If self defected last round:
                > Forgive and cooperate if majority cooperated last round.
                > Else keep defecting.
    - Final round (r): Defect unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.n
        r = self.r
        if t == r:
            return Action.D
        prev_round = ()
        my_prev_action = history.my_actions[t - 2]
        opp_prev_actions = history.opponent_actions[t - 2]
        prev_round = [my_prev_action] + list(opp_prev_actions)
        total_cooperators = sum(prev_round)
        majority_cooperated = total_cooperators >= (n + 1) // 2
        if total_cooperators == n:
            return Action.C
        if my_prev_action:
            return Action.D
        elif majority_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Forgiving grim trigger strategy for repeated N-player public goods game.
    
    - Round 1: Cooperate
    - Rounds 2..r-1: 
        - If any opponent defected in previous round: defect (punish)
        - Else cooperate
    - Last round (r): Defect (endgame defection)
    
    This strategy promotes cooperation, punishes free riders for one round,
    then forgives if cooperation resumes, and defects in last round to avoid exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[history.round_number - 1]
        if not last_round_opponent_actions.all():
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for the repeated Public Goods Game.

    - Cooperates initially.
    - Defects in the last round to maximize private payoff.
    - If any opponent defected in the previous round, defects once next round to punish.
    - Forgives and returns to cooperation if all players cooperated the round after punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        if t == 1:
            return Action.C
        last_opponent_actions = history.opponent_actions[t - 2]
        opponents_defected_last = not all(last_opponent_actions)
        we_defected_last = history.my_actions[t - 2] == False
        if not opponents_defected_last:
            return Action.C
        if t >= 3 and we_defected_last:
            previous_round_my_action = history.my_actions[t - 3]
            previous_round_opponent_actions = history.opponent_actions[t - 3]
            all_cooperated_previous = previous_round_my_action == True and all(previous_round_opponent_actions)
            if all_cooperated_previous:
                return Action.C
        return Action.D

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Conditional Grim Trigger with Forgiveness for N-Player Public Goods Game.

    - Start cooperating first round.
    - In rounds 2 to r-1:
      * If defected last round and all cooperated last round, forgive and cooperate.
      * If defected last round and not all cooperated last round, continue defecting.
      * If cooperated last round and any defection last round, punish by defecting.
      * If cooperated last round and no defection last round, continue cooperating.
    - Defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_round_actions = []
        own_last_action_bool = history.my_actions[-1]
        last_round_actions = [own_last_action_bool] + list(history.opponent_actions[-1])
        any_defection_last_round = not all(last_round_actions)
        all_cooperation_last_round = all(last_round_actions)
        if own_last_action_bool is False:
            if all_cooperation_last_round:
                return Action.C
            else:
                return Action.D
        elif any_defection_last_round:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Cooperative Strategy: Gradual Reciprocity with Forgiveness

    - Cooperate initially to establish mutual cooperation.
    - If all cooperated previously, continue cooperating.
    - If others defected previously, punish by defecting this round.
    - Forgive after punishing by cooperating next round regardless of others.
    - Defect in the final round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        player_idx = 0
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == n_rounds:
            return Action.D
        last_round_actions = [history.my_actions[-1]]
        last_round_actions.extend(history.opponent_actions[-1, :])
        all_cooperated_last = all(last_round_actions)
        someone_defected_last = not all_cooperated_last
        if current_round >= 3:
            prev_prev_round_actions = [history.my_actions[-2]]
            prev_prev_round_actions.extend(history.opponent_actions[-2, :])
            all_cooperated_prev_prev = all(prev_prev_round_actions)
            someone_defected_prev_prev = not all_cooperated_prev_prev
            we_defected_last = not history.my_actions[-1]
            if someone_defected_prev_prev and we_defected_last:
                return Action.C
        if someone_defected_last:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    Forgiving Conditional Cooperator (FCC) strategy for the 
    N-Player Public Goods Game.
    
    Starts cooperating. 
    Cooperates as long as most players cooperated last round (at least n-1).
    If many defected, punishes by defecting once, then forgives by cooperating next round.
    Always cooperates in last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punished_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            self.punished_last_round = False
            return Action.C
        t = history.round_number + 1
        if t == r:
            self.punished_last_round = False
            return Action.C
        prev_round_idx = t - 2
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx]
        prev_cooperations = int(my_prev_action) + int(opponent_prev_actions.sum())
        if self.punished_last_round:
            action = Action.C
            self.punished_last_round = False
        elif prev_cooperations >= n - 1:
            action = Action.C
        else:
            action = Action.D
            self.punished_last_round = True
        return action

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    Cooperative conditional cooperation strategy for repeated public goods game:
    - First round: cooperate.
    - Last round: defect.
    - In rounds 2..r-1:
        * Cooperate if everyone cooperated previous round.
        * If any defection last round, defect once as punishment.
        * After punishing, forgive back to cooperation if others cooperate.
    This balances enforcement and forgiveness to sustain cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round = history.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponents_last_actions = history.opponent_actions[last_round]
        all_last_actions = [my_last_action] + list(opponents_last_actions)
        all_cooperated_last = all(all_last_actions)
        if all_cooperated_last:
            if current_round >= 3:
                two_rounds_ago = history.round_number - 2
                if two_rounds_ago >= 0:
                    my_prev_prev_action = history.my_actions[two_rounds_ago]
                    opponents_prev_prev_actions = history.opponent_actions[two_rounds_ago]
                    all_prev_prev_actions = [my_prev_prev_action] + list(opponents_prev_prev_actions)
                    any_defection_two_rounds_ago = not all(all_prev_prev_actions)
                else:
                    any_defection_two_rounds_ago = False
                if any_defection_two_rounds_ago and my_last_action == False:
                    return Action.C
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness and Endgame Adjustment for
    the N-player repeated Public Goods Game.
    
    - Round 1: Cooperate unconditionally.
    - Rounds 2 to r-1: Cooperate if all players cooperated last round; else defect once as punishment.
    - Round r: Defect to maximize individual payoff with no future consequences.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last = history.my_actions[last_round_idx]
        opponents_last = history.opponent_actions[last_round_idx]
        all_cooperated = my_last and opponents_last.all()
        if all_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    Conditional Reciprocity with Forgiveness (CRF) strategy for the repeated 
    N-player Public Goods Game.

    - Cooperate on first round.
    - For rounds 2 to r-1:
      - Cooperate if all players (including self) cooperated in previous round.
      - Otherwise, defect to punish any defection.
    - On last round r (final round), cooperate regardless of history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.C
        prev_opponent_actions = history.opponent_actions[t - 1] if t > 0 else None
        prev_self_action = history.my_actions[t - 1] if t > 0 else None
        if prev_opponent_actions is None or prev_self_action is None:
            return Action.C
        all_cooperated_last_round = prev_self_action and prev_opponent_actions.all()
        if all_cooperated_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness (CCF) for Repeated Public Goods Game.
    
    - Cooperate in first round.
    - Cooperate in rounds 2 to r-1 if all players cooperated last round.
    - Otherwise defect to punish for exactly one round.
    - If currently punishing (defected last round), check forgiveness condition:
      if full cooperation occurred in the round before last, forgive and cooperate.
      Else continue defecting.
    - Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        current_round = 1 if history is None else history.round_number + 1
        if current_round == self.r:
            return Action.D
        if current_round == 1:
            return Action.C
        last_round_idx = current_round - 2
        last_all_actions = [history.my_actions[last_round_idx]]
        if self.n > 1:
            last_all_actions.extend(history.opponent_actions[last_round_idx])
        all_cooperated_last_round = all(last_all_actions)
        if all_cooperated_last_round:
            return Action.C
        own_last_action = history.my_actions[last_round_idx]
        if own_last_action == False:
            if current_round >= 3:
                prev_round_idx = current_round - 3
                prev_all_actions = [history.my_actions[prev_round_idx]]
                if self.n > 1:
                    prev_all_actions.extend(history.opponent_actions[prev_round_idx])
                full_coop_two_rounds_ago = all(prev_all_actions)
                if full_coop_two_rounds_ago:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness and Last Round Defection for the
    repeated N-Player Public Goods Game.
    
    Starts cooperating, cooperates if defections in previous round are within tolerance τ,
    defects to punish if defections exceed τ, and always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tolerance = max(1, self.game_description.n_players // 10)

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        τ = self.tolerance
        if history is None:
            return Action.C
        t = history.round_number
        next_round = t + 1
        if next_round == r:
            return Action.D
        prev_round_idx = t - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opp_prev_actions = history.opponent_actions[prev_round_idx]
        total_prev_actions = [my_prev_action] + list(opp_prev_actions)
        defectors = sum((not a for a in total_prev_actions))
        if defectors == 0:
            return Action.C
        elif defectors <= τ:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    Conditional Grim Trigger with Forgiveness for the N-player repeated Public Goods Game.
    
    - Round 1: Cooperate unconditionally.
    - Intermediate rounds:
      * Cooperate if all players cooperated in all prior rounds.
      * Otherwise, if any defection in immediately prior round, defect.
      * Else (defection earlier but not last round), cooperate (forgiveness).
    - Last round:
      * Cooperate if no defection in immediately prior round.
      * Defect otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        current_round = 1 if history is None else history.round_number + 1
        if history is None:
            return Action.C
        own = history.my_actions.reshape(-1, 1)
        opponents = history.opponent_actions
        actions_all = np.concatenate([own, opponents], axis=1)
        last_round_idx = current_round - 2
        all_coop_last_round = np.all(actions_all[last_round_idx])
        all_coop_so_far = np.all(actions_all)
        if current_round == self.r:
            if all_coop_last_round:
                return Action.C
            else:
                return Action.D
        else:
            if all_coop_so_far:
                return Action.C
            if not all_coop_last_round:
                return Action.D
            return Action.C

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Conditional Reciprocal Cooperation with Gradual Forgiveness for N-player Repeated Public Goods Game.
    
    - Start cooperating to foster cooperation.
    - Cooperate if last round group cooperation ≥ theta.
    - Forgive isolated defections: if I defected last round but prior round had high cooperation, cooperate now.
    - If cooperation falls below threshold for multiple rounds, defect until cooperation recovers.
    - Defect on the last round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.theta = 0.8
        self._low_coop_streak = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self._low_coop_streak = 0
            return Action.C
        t = history.round_number + 1
        n = self.n
        r = self.r
        theta = self.theta
        last_round_idx = t - 2
        if last_round_idx < 0:
            self._low_coop_streak = 0
            return Action.C
        my_action_last = history.my_actions[last_round_idx]
        opp_actions_last = history.opponent_actions[last_round_idx]
        coop_count_last = int(my_action_last) + opp_actions_last.sum()
        coop_rate_last = coop_count_last / n
        if t == r:
            return Action.D
        prev_coop_rate = None
        if t > 2:
            prev_round_idx = t - 3
            my_action_prev = history.my_actions[prev_round_idx]
            opp_actions_prev = history.opponent_actions[prev_round_idx]
            coop_count_prev = int(my_action_prev) + opp_actions_prev.sum()
            prev_coop_rate = coop_count_prev / n
        if coop_rate_last < theta:
            self._low_coop_streak += 1
        else:
            self._low_coop_streak = 0
        if coop_rate_last >= theta:
            if t > 2 and history.my_actions[last_round_idx] == False and (prev_coop_rate is not None) and (prev_coop_rate >= theta):
                return Action.C
            return Action.C
        elif self._low_coop_streak == 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    Conditional Reciprocity with Forgiveness for the N-Player Public Goods Game.

    Summary:
    - Round 1: Cooperate unconditionally.
    - Intermediate rounds (2 to r-1):
       * If all players cooperated last round, cooperate.
       * Else if exactly 1 defector last round, forgive by cooperating.
       * Else defect to punish multiple defectors.
    - Last round: Cooperate regardless.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        n = self.n
        r = self.r
        last_round_self = history.my_actions[t - 1]
        last_round_opponents = history.opponent_actions[t - 1]
        num_defectors_last = 0
        if not last_round_self:
            num_defectors_last += 1
        num_defectors_last += (last_round_opponents == False).sum()
        if current_round == 1:
            return Action.C
        if current_round == r:
            return Action.C
        if num_defectors_last == 0:
            return Action.C
        elif num_defectors_last == 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    Conditional Cooperate-Tolerate-Retaliate (CTR) strategy for N-player repeated Public Goods Game.
    
    Starts cooperating; in rounds 2 to r-1 continues cooperating if previous round's cooperation ratio 
    is above threshold and tolerated defections not exceeded; otherwise defects to punish. 
    Always cooperates in last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold_coop_ratio = 0.7
        self.tolerance = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.C
        if t == 0:
            return Action.C
        prev_round_index = t - 1
        my_prev_action = history.my_actions[prev_round_index]
        opp_prev_actions = history.opponent_actions[prev_round_index]
        coop_count_prev = (1 if my_prev_action else 0) + opp_prev_actions.sum()
        coop_ratio = coop_count_prev / self.n
        defections_count = 0
        for round_i in range(t):
            if history.my_actions[round_i]:
                if not history.opponent_actions[round_i].all():
                    defections_count += 1
        if coop_ratio >= self.threshold_coop_ratio and defections_count <= self.tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    Generous Conditional Cooperation (GCC) strategy for the repeated
    Public Goods Game. 
    
    - Cooperate on first round.
    - From second to penultimate rounds, cooperate if majority cooperated last round;
      otherwise defect.
    - Forgives by returning to cooperate if majority cooperated last round.
    - On last round, cooperate if majority cooperated last round, else defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        last_round_idx = history.round_number - 1
        self_last = history.my_actions[last_round_idx]
        opp_last = history.opponent_actions[last_round_idx]
        coop_count = (1 if self_last else 0) + opp_last.sum()
        majority_threshold = self.n // 2 + 1
        majority_cooperated = coop_count >= majority_threshold
        if t < self.r:
            if majority_cooperated:
                return Action.C
            else:
                return Action.D
        elif majority_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    CoopGrim Strategy for the N-Player Public Goods Game.

    - Start cooperating in round 1.
    - Continue cooperating if no defections have ever occurred.
    - If any defection ever occurred, defect forever except in last round.
    - In last round, cooperate always (to maximize payoff, no punishment needed).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        if not history.my_actions.all():
            defected_before = True
        elif not history.opponent_actions.all():
            defected_before = True
        else:
            defected_before = False
        current_round = history.round_number + 1
        if defected_before:
            if current_round == self.n_rounds:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    Cooperative Conditional Cooperation with Forgiveness (CCF) Strategy for N-Player Public Goods Game.

    - Cooperate in the first round.
    - In rounds 2 to r-1, cooperate if majority of all players cooperated last round; else defect once as punishment.
    - Cooperate in the final round unconditionally.
    - Uses only observable full history with no internal state.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.CooperationThreshold = self.n // 2 + 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.C
        last_round_opponent_coop = history.opponent_actions[t - 2].sum()
        self_last = history.my_actions[t - 2]
        total_cooperators_last_round = last_round_opponent_coop + (1 if self_last else 0)
        if total_cooperators_last_round >= self.CooperationThreshold:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for the N-Player Public Goods Game.
    
    - Round 1: Cooperate to signal trust.
    - Rounds 2 to r-1: Cooperate if ≥80% of all players cooperated last round; else defect to punish.
    - Last round: Defect to maximize self payoff.
    - Forgiveness is implicitly embedded by returning to cooperation as soon as threshold met.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold = 0.8

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        prev_opp_actions = history.opponent_actions[history.round_number - 1]
        coop_opponents = prev_opp_actions.sum()
        self_last_action = history.my_actions[history.round_number - 1]
        total_cooperators = coop_opponents + (1 if self_last_action else 0)
        proportion_coop = total_cooperators / self.n
        if proportion_coop >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    Conditional Grim-Trigger with Forgiveness for the N-Player Public Goods Game.

    - Start cooperating.
    - Continue cooperating if everyone cooperated in previous round.
    - If anyone defects, punish by defecting for `punishment_length` rounds.
    - Forgive and return to cooperation after punishment ends.
    - Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_length = 2
        self.punish_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.punish_count = 0
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        if self.punish_count > 0:
            self.punish_count -= 1
            prev_round_actions = history.opponent_actions[history.round_number - 1]
            own_last = history.my_actions[history.round_number - 1]
            all_actions = [own_last] + list(prev_round_actions)
            if not all(all_actions):
                self.punish_count = self.punishment_length - 1
            return Action.D
        prev_round_actions = history.opponent_actions[history.round_number - 1]
        own_last = history.my_actions[history.round_number - 1]
        all_actions = [own_last] + list(prev_round_actions)
        if all(all_actions):
            return Action.C
        else:
            self.punish_count = self.punishment_length - 1
            return Action.D

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Conditional Cooperation with Gradual Punishment and Forgiveness for the
    N-player Public Goods Game.

    - Cooperate first round.
    - From round 2 to r-1, cooperate if fraction of cooperators in previous round ≥ 0.6,
      else defect to punish for 1 round.
    - Forgive by returning to cooperation after punishment.
    - Last round always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.tau = 0.6
        self.punish_length = 1
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            self.punish_counter = 0
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_round_cooperators = 0
        my_last = history.my_actions[t - 1]
        opp_last = history.opponent_actions[t - 1]
        opponents_coop = opp_last.sum()
        last_round_cooperators = opponents_coop + (1 if my_last else 0)
        coop_fraction = last_round_cooperators / self.n
        if coop_fraction >= self.tau:
            return Action.C
        self.punish_counter = self.punish_length - 1
        return Action.D

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    Cooperative Strategy for N-Player Public Goods Game.
    
    Starts cooperating to foster cooperation.
    Punishes observed defections with a single round of defection.
    Forgives quickly, returning to cooperation if opponents resume full cooperation.
    Defects in last round to maximize immediate payoff.
    
    This is a generous tit-for-tat style adapted to multi-player public goods.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_num = history.round_number
        current_round = round_num + 1
        if current_round == self.r:
            return Action.D
        prev_opponent_actions = history.opponent_actions[round_num - 1]
        coop_opponents_prev = sum(prev_opponent_actions)
        full_coop_prev = coop_opponents_prev == self.n - 1

        def opponents_full_coop_round(r_idx: int) -> bool:
            if r_idx < 0 or r_idx >= history.opponent_actions.shape[0]:
                return True
            return sum(history.opponent_actions[r_idx]) == self.n - 1
        own_last_action = history.my_actions[round_num - 1]
        if full_coop_prev:
            return Action.C
        if round_num >= 2:
            full_coop_prev_prev = opponents_full_coop_round(round_num - 2)
            if not full_coop_prev_prev and own_last_action == Action.D and full_coop_prev:
                return Action.C
        return Action.D

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Conditional Cooperate-and-Forgive (CCF) strategy for N-player repeated Public Goods Game.

    - Cooperates in first round.
    - Cooperates if all opponents cooperated last round.
    - Defects for exactly one round to punish if any opponent defected last round.
    - Forgives by cooperating immediately after punishment.
    - Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self._punishment_active = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game.n_rounds
        if history is None:
            self._punishment_active = False
            return Action.C
        t = history.round_number + 1
        if t == r:
            self._punishment_active = False
            return Action.D
        if self._punishment_active:
            self._punishment_active = False
            return Action.C
        last_round = t - 2
        opponents_last_round = history.opponent_actions[last_round]
        all_coop = opponents_last_round.all()
        if all_coop:
            self._punishment_active = False
            return Action.C
        else:
            self._punishment_active = True
            return Action.D

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness (CCF) strategy for the repeated
    N-Player Public Goods Game.

    Starts by cooperating, punishes rounds with many defectors by defecting,
    forgives occasional defections, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.defect_threshold = 0.3
        self.forgiveness_window = 2
        self.cooperation_window = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        my_prev_action = history.my_actions[prev_round_idx]
        opp_prev_actions = history.opponent_actions[prev_round_idx]
        total_cooperators_prev = int(my_prev_action) + int(opp_prev_actions.sum())
        defectors_prev = self.n - total_cooperators_prev
        defect_ratio_prev = defectors_prev / self.n
        start_idx = max(0, prev_round_idx + 1 - self.forgiveness_window)
        end_idx = prev_round_idx + 1
        recent_rounds_indices = list(range(start_idx, end_idx))
        recent_defect_ratios = []
        for rnd_idx in recent_rounds_indices:
            ma = history.my_actions[rnd_idx]
            oa = history.opponent_actions[rnd_idx]
            coop_count = int(ma) + int(oa.sum())
            defectors = self.n - coop_count
            recent_defect_ratios.append(defectors / self.n)
        if defect_ratio_prev <= self.defect_threshold:
            return Action.C
        if any((dr <= self.defect_threshold for dr in recent_defect_ratios)):
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness Strategy for repeated N-player Public Goods Game.
    
    - Cooperate first round.
    - If all players cooperated last round, cooperate.
    - If any player defected last round:
      - If this player defected last round (already punished), forgive by cooperating.
      - Else punish by defecting this round.
    - Defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round = history.opponent_actions[history.round_number - 1]
        self_defected_prev = not history.my_actions[history.round_number - 1]
        all_cooperated = history.my_actions[history.round_number - 1] and prev_round.all()
        if all_cooperated:
            return Action.C
        elif self_defected_prev:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    Reciprocal Conditional Cooperation (RCC) strategy for the N-player Public Goods Game.

    Summary:
    - Cooperate in the first round.
    - For intermediate rounds (2 to r-1), cooperate if at least a threshold 
      fraction (default 0.75) of other players cooperated in the previous round.
      Otherwise defect.
    - Defect in the last round.
    - This fosters cooperation, punishes defection, allows forgiveness, and
      prevents exploitation in the endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold = 0.75

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_opponents_actions = history.opponent_actions[prev_round_idx]
        num_coop_others = prev_opponents_actions.sum()
        coop_rate = num_coop_others / (self.n - 1)
        if coop_rate >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Cooperative Conditional Trust Strategy for N-Player Public Goods Game.
    
    - Start cooperating.
    - Cooperate if all others cooperated last round.
    - If any defection detected last round, defect once to punish.
    - If cooperation mostly restored after punishment, return to cooperating.
    - Defect on final round (backward induction).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        if t == self.r - 1:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[t - 1]
        last_round_my_action = history.my_actions[t - 1]
        all_others_cooperated_last = last_round_opponent_actions.all()
        i_cooperated_last = last_round_my_action
        if t >= 1 and t < self.r - 1:
            if all_others_cooperated_last and i_cooperated_last:
                return Action.C
            if t >= 2:
                prev_round_opponent_actions = history.opponent_actions[t - 2]
                prev_round_my_action = history.my_actions[t - 2]
                all_others_cooperated_prev = prev_round_opponent_actions.all()
                i_cooperated_prev = prev_round_my_action
                if all_others_cooperated_prev and i_cooperated_prev:
                    return Action.D
                else:
                    cooperators_last_round = last_round_opponent_actions.sum()
                    mostly_cooperated_last = cooperators_last_round >= self.n - 2
                    if mostly_cooperated_last and i_cooperated_last:
                        return Action.C
                    else:
                        return Action.D
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    Forgiving Grim Trigger with Tit-for-Tat Forgiveness for N-Player Public Goods Game.

    Summary:
    - Round 1: Cooperate.
    - Rounds 2 to r-1: Cooperate if all others cooperated previous round.
      Otherwise, punish defectors by defecting one round,
      then forgive by cooperating next round to restore cooperation.
    - Round r (last round): Cooperate if majority of others cooperated previous round, else defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        prev_round_idx = t - 2
        my_prev_action = history.my_actions[prev_round_idx]
        opponents_prev_actions = history.opponent_actions[prev_round_idx]
        all_others_cooperated = opponents_prev_actions.all()
        if 2 <= t <= self.r - 1:
            if all_others_cooperated:
                return Action.C
            elif my_prev_action == False:
                return Action.C
            else:
                return Action.D
        if t == self.r:
            coop_count = opponents_prev_actions.sum()
            if coop_count >= (self.n - 1) / 2:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness (CCF) for N-player repeated public goods game.

    - Round 1: Cooperate to signal willingness.
    - Rounds 2 to r-1:
        * If previous round was full cooperation (all players cooperated), cooperate.
        * Otherwise defect as punishment.
    - Round r (last round): Always cooperate.
    
    This implements one-round punishment for any defection and immediate forgiveness after.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.C
        prev_own = history.my_actions[t - 1]
        prev_opponents = history.opponent_actions[t - 1] if t - 1 >= 0 else None
        if prev_opponents is None:
            return Action.C
        full_coop = prev_own and prev_opponents.all()
        if full_coop:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    Forgiving Tit-for-Tat (F-TFT) with Endgame Adjustment for N-Player Public Goods Game.

    - Start by cooperating.
    - In rounds 2 to r-1, cooperate if at least (1 - theta) fraction of other players cooperated last round.
      Otherwise, defect to punish.
    - Forgiveness threshold theta = 0.25 by default.
    - In last round, defect always (endgame defection).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.theta = 0.25

    def __call__(self, history: None | PlayerHistory):
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == 1:
            return Action.C
        if current_round == self.r:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[history.round_number - 1]
        coop_count_others = sum(last_round_opponent_actions)
        coop_ratio = coop_count_others / (self.n - 1)
        if coop_ratio >= 1 - self.theta:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    Cooperative Strategy: Conditional Cooperation with Forgiveness and Endgame Adjustment
    - Start cooperating first round.
    - In intermediate rounds (2 to r-1), cooperate iff majority of others cooperated previous round.
    - Forgive to resume cooperation if majority returns.
    - Defect in final round to avoid endgame exploitation.
    - If only one other player (n=2), mimic their last action.
    - If history fully defected recently, keeps defecting by threshold logic.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_round_idx = t - 2
        opponent_actions_last = history.opponent_actions[last_round_idx]
        n_others = n - 1
        if n_others == 1:
            if opponent_actions_last[0]:
                return Action.C
            else:
                return Action.D
        cooperators_count = opponent_actions_last.sum()
        avg_coop = cooperators_count / n_others
        if avg_coop >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    Forgiving Conditional Cooperate strategy for N-Player Public Goods Game.

    - Start by cooperating.
    - Continue cooperating if all cooperated last round.
    - If any defection last round, defect once to punish.
    - After punishing by defecting, forgive next round by cooperating regardless.
    - In last round, cooperate only if all cooperated previous round, else defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        r = self.game.n_rounds
        own_last_action = history.my_actions[-1]
        opp_last_actions = history.opponent_actions[-1] if history.opponent_actions.shape[0] > 0 else []
        all_last_actions = [own_last_action] + list(opp_last_actions)
        all_cooperated_last = all(all_last_actions)
        if t == r:
            return Action.C if all_cooperated_last else Action.D
        if all_cooperated_last:
            return Action.C
        if own_last_action == False:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    Gradual Reciprocity with Forgiveness for N-Player Public Goods Game.

    Starts by cooperating. Continues to cooperate if all cooperated previously.
    If defections occurred:
      - Forgives isolated defection if player defected alone last round (returns to cooperate).
      - Otherwise defects to punish.
    Defects in the final round to maximize own payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_num = history.round_number
        if round_num == self.r - 1:
            return Action.D
        prev_round_idx = round_num - 1
        own_prev = history.my_actions[prev_round_idx]
        defector_count = self.n - 1 - sum(history.opponent_actions[prev_round_idx])
        if not own_prev:
            defector_count += 1
        if defector_count == 0:
            return Action.C
        if not own_prev and defector_count == 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    Conditional Cooperative Strategy for N-Player Repeated Public Goods Game.

    - Round 1: Cooperate.
    - Rounds 2 to r-1: Cooperate if previous round had at least 80% cooperators (including self), else defect.
    - Round r: Defect (final round).
    - Forgiveness embedded: after punishment rounds, if cooperation recovers above threshold, resume cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold = int(0.8 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        my_prev = history.my_actions[-1]
        opp_prev = history.opponent_actions[-1]
        c_prev = (1 if my_prev else 0) + opp_prev.sum()
        if c_prev >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for the N-Player Repeated Public Goods Game.

    - Cooperate first round.
    - For rounds 2 to r-1:
        * If all cooperated last round, cooperate.
        * Else if at least one defected last round:
            - If self cooperated last round, defect (punish).
            - Else if self defected last round, cooperate (forgive).
    - Defect unconditionally in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        last_round_idx = history.round_number - 1
        opp_actions_last = history.opponent_actions[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        cooperators_last = opp_actions_last.sum() + (1 if my_last_action else 0)
        all_cooperated = cooperators_last == self.n
        if t == self.r:
            return Action.D
        if all_cooperated:
            return Action.C
        if my_last_action:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness and Endgame Awareness for the N-Player Public Goods Game.

    Starts by cooperating to build trust. Continues cooperating if all players cooperated previously.
    If any defection detected in previous round, punishes by defecting once (retaliation).
    Forgives after punishing by returning to cooperation unless defections repeat.
    Defects in the last round due to endgame incentives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        prev_round = t - 1
        prev_all_actions = []
        my_prev_action = history.my_actions[prev_round]
        prev_all_actions = [my_prev_action]
        prev_all_actions.extend(history.opponent_actions[prev_round].tolist())
        all_cooperated = all(prev_all_actions)
        if all_cooperated:
            return Action.C
        else:
            if my_prev_action == False:
                return Action.C
            return Action.D

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for the N-player Public Goods Game.

    Starts cooperating to build trust.  
    Forgives a single defection in the previous round by cooperating again.  
    Defects to punish if two or more defectors in the previous round.  
    In the last round, defects if mutual cooperation isn't expected (i.e., >1 defector previously).  
    Always tries to restore cooperation after punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        last_round = t - 1
        my_last_action = history.my_actions[last_round - 1]
        opp_last_actions = history.opponent_actions[last_round - 1]
        cooperators_in_last_round = (1 if my_last_action else 0) + sum((1 for a in opp_last_actions if a))
        defectors_in_last_round = self.n - cooperators_in_last_round
        if t == self.r:
            if defectors_in_last_round <= 1:
                return Action.C
            else:
                return Action.D
        if defectors_in_last_round == 0:
            return Action.C
        elif defectors_in_last_round == 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    Forgiving Trigger strategy for the N-Player Public Goods Game.

    - Cooperate first round.
    - In middle rounds, cooperate if defectors in last round ≤ D_threshold, else defect once to punish.
    - Forgive immediately after one round of punishment.
    - Always cooperate in the last two rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.D_threshold = 1
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.punishing = False
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round >= r - 1:
            self.punishing = False
            return Action.C
        if t == 0:
            self.punishing = False
            return Action.C
        last_round_idx = t - 1
        opponent_last_round = history.opponent_actions[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        defections_opponents = (~opponent_last_round).sum()
        my_defection_last = 0 if my_last_action else 1
        total_defectors_last = defections_opponents + my_defection_last
        if not self.punishing:
            if total_defectors_last <= self.D_threshold:
                return Action.C
            else:
                self.punishing = True
                return Action.D
        else:
            self.punishing = False
            return Action.C

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    Cooperative strategy for the N-Player Repeated Public Goods Game.
    Implements a generous tit-for-tat / win-stay lose-shift style logic:
    - Cooperate in round 1 to build trust
    - Defect in last round (r) since retaliation is impossible
    - In intermediate rounds, tolerate up to 30% defections by others overall in past
      rounds before punishing by defecting
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        total_past_rounds = t - 1
        past_opponent_actions = history.opponent_actions[:total_past_rounds, :]
        total_defections_by_others = (past_opponent_actions == False).sum()
        max_defections_possible = (self.n - 1) * total_past_rounds
        defections_rate = total_defections_by_others / max_defections_possible if max_defections_possible > 0 else 0.0
        if defections_rate <= 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    Grim Trigger with Forgiveness for the repeated Public Goods Game.
    
    Starts by cooperating. Continues to cooperate as long as all players
    cooperated in the previous round. If any defection is observed, punishes
    by defecting the next round. If forgiveness condition is met (all 
    cooperate immediately after punishment), it returns to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        last_all_coop = all(history.opponent_actions[t - 1]) and history.my_actions[t - 1]
        my_last_action = history.my_actions[t - 1]
        if last_all_coop:
            if my_last_action == False:
                return Action.C
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    Conditional Cooperative strategy for the repeated N-Player Public Goods Game.
    
    Starts cooperating, maintains cooperation if most players cooperated last round,
    punishes defectors with a single defection round, and then forgives to try restoring cooperation.
    Always cooperates in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold_coop = self.game_description.n_players - 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.C
        last_round_idx = t - 1
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = my_last_action + history.opponent_actions[last_round_idx].sum()
        if total_cooperators >= self.threshold_coop:
            return Action.C
        if my_last_action:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    Forgiving Conditional Cooperator for N-Player Public Goods Game.

    - Round 1: Cooperate.
    - Rounds 2 to r-2: Cooperate if all cooperated last round, else defect to punish.
    - Round r-1: Cooperate if majority cooperated last round, else defect.
    - Round r: Defect.
    - Forgiveness is implicit; if after a punishment round all cooperate again, return to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if t == self.r - 1:
            last_round_cooperations = sum(history.opponent_actions[-1])
            last_my_action = history.my_actions[-1]
            total_cooperators = last_round_cooperations + (1 if last_my_action else 0)
            if total_cooperators >= self.n / 2:
                return Action.C
            else:
                return Action.D
        last_round_cooperations = sum(history.opponent_actions[-1])
        last_my_action = history.my_actions[-1]
        total_cooperators = last_round_cooperations + (1 if last_my_action else 0)
        if total_cooperators == self.n:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    Forgiving Conditional Cooperation (FCC) strategy for N-Player Public Goods Game.

    Starts cooperating, punishes defectors by a single round of defection,
    then forgives and returns to cooperation if others cooperate again.
    Defects on the last round to maximize final payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self._punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        last_round = t - 2
        if history is None:
            self._punish = False
            return Action.C
        if t == self.r:
            self._punish = False
            return Action.D
        opponents_last = history.opponent_actions[last_round]
        defectors_last_round = not opponents_last.all()
        self_last_action = history.my_actions[last_round]
        coop_count = int(self_last_action) + int(opponents_last.sum())
        if not defectors_last_round:
            self._punish = False
            return Action.C
        if not self._punish:
            self._punish = True
            return Action.D
        if defectors_last_round:
            return Action.D
        else:
            self._punish = False
            return Action.C

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Aggressive 'Exploit-Then-Defect' strategy for the repeated n-player public goods game.

    Always defects, exploiting any cooperation from others. Never cooperates, 
    punishing cooperators by never reciprocating. Defects in all rounds, 
    including first and last, maximizing immediate personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        prev_round = t - 1
        if prev_round < 0:
            return Action.D
        observed_cooperators = history.opponent_actions[prev_round].sum()
        if observed_cooperators > 0:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game

    Always defect except optionally cooperate in round 1 to probe (here we choose to defect immediately).
    From round 2 to round r-1, defect always and exploit any cooperation detected in previous round.
    In the last round, defect always.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        if current_round > 1:
            prev_cooperators = history.opponent_actions[t - 1].any()
            if prev_cooperators:
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game.

    Summary:
    - Always defect except optionally cooperate when a large fraction of players cooperated last round,
      but the optional cooperation is disabled here to keep pure aggressiveness.
    - Round 1: defect (no trust).
    - Intermediate rounds (2 to r-1): defect always to maximize private payoff and exploit cooperators.
    - Final round (r): defect (no incentive to cooperate).
    - Uses opponent_actions to detect previous cooperators count.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_threshold = self.n / self.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round = t - 2
        opponents_coop = history.opponent_actions[prev_round].sum(dtype=int)
        my_last_action = history.my_actions[prev_round]
        my_coop = 1 if my_last_action else 0
        total_cooperators_last = opponents_coop + my_coop
        return Action.D

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    Aggressive strategy for repeated N-player public goods game.
    
    Summary:
    - Always defects except for a single one-time cooperation immediately after a unanimous
      defection round to probe if others will cooperate.
    - Defects on the first round and last round unconditionally.
    - Exploits cooperative opponents by defecting after they cooperated.
    - Punishes defectors by defecting.
    - The single cooperation after unanimous defection is to break deadlocks, not to build trust.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperated_after_defection_deadlock = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        t = 1 if history is None else history.round_number + 1
        if t == r:
            return Action.D
        if t == 1:
            return Action.D
        if history is None or history.round_number == 0:
            return Action.D
        last_round_index = history.round_number - 1
        opp_actions_last = history.opponent_actions[last_round_index]
        my_action_last = history.my_actions[last_round_index]
        all_actions_last = [my_action_last] + list(opp_actions_last)
        all_cooperated = all(all_actions_last)
        any_defected = not all_cooperated
        all_defected = all((not a for a in all_actions_last))
        if all_cooperated:
            return Action.D
        if any_defected:
            if all_defected:
                if not self.cooperated_after_defection_deadlock:
                    self.cooperated_after_defection_deadlock = True
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Aggressive "Exploit & Punish" strategy for N-player repeated Public Goods Game.

    - Always defects every round.
    - Starts defecting immediately.
    - Never cooperates.
    - Exploits any cooperation by other players by defecting.
    - Punishes cooperators by refusal to cooperate.
    - Defects in the last round to avoid exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    Aggressor strategy for the N-player repeated Public Goods Game.
    Always defects (D), never cooperates (C).
    Defects in the first round with no prior info.
    Defects in all intermediate rounds regardless of any cooperation.
    Defects in the last round unconditionally.
    This strategy aggressively exploits cooperative players by never cooperating,
    and never forgives or reciprocates cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_cooperators = history.my_actions[-1] or history.opponent_actions[-1].any()
        return Action.D

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Aggressive Conditional Defection with Opportunistic Cooperation (CDOC) Strategy
    for the N-player Public Goods Game.

    - Round 1: Defect unconditionally.
    - Intermediate rounds (2 to r-1):
      - If any opponent cooperated last round, defect to exploit.
      - Else cooperate once to try to "seed" cooperation.
    - Final round (r): Defect unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        current_round = (history.round_number if history is not None else 0) + 1
        if current_round == 1:
            return Action.D
        if current_round == self.r:
            return Action.D
        if history is None:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[history.round_number - 1]
        if last_round_opponent_actions.any():
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    Aggressive Exploiter for N-Player Public Goods Game.
    
    Summary:
    - Always defects every round.
    - Never cooperates.
    - Exploits any cooperation by opponents by free-riding.
    - In the last round, defects to avoid exploitation.
    - Does not trust or try to build cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    Aggressive strategy for the N-Player Public Goods Game.
    Always defects in every round unconditionally:
    - Round 1: defect to establish aggressive stance.
    - Rounds 2..r-1: defect regardless of history to punish/exploit cooperators.
    - Last round: defect to maximize immediate payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    Exploit & Punish strategy for N-Player Public Goods Game.

    Always defects. 
    - Round 1: defect
    - Rounds 2 to r-1: defect exploiting any cooperators last round if any,
      or defect to punish if none cooperated.
    - Last round: defect to avoid exploitation.

    This strategy never cooperates, aiming to maximize individual payoff by free-riding on cooperators,
    but also punishing non-cooperators by defecting consistently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = history.opponent_actions[last_round_idx].sum()
        return Action.D

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    Aggressive Strategy for the N-Player Public Goods Game.

    Always defects in all rounds to maximize immediate payoffs by free-riding on any
    cooperating opponents. Never cooperates, regardless of history or opponent behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        r = self.game_description.n_rounds
        return Action.D

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Dominant Defector with Tactical Cooperation for repeated Public Goods game.
    
    Summary:
    - Round 1: Cooperate to probe.
    - Rounds 2 to r-1: Always defect, exploiting cooperation if >= half others cooperated last round.
    - Round r: Defect unconditionally (no future incentives).
    
    The strategy never cooperates after round 1 and punishes defectors by refusing cooperation,
    maximizing individual payoff aggressively.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_round_opponent_coop = history.opponent_actions[t - 2]
        coop_count_others = last_round_opponent_coop.sum()
        coop_including_self = coop_count_others + (1 if history.my_actions[t - 2] else 0)
        if coop_count_others >= (self.n - 1) / 2:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game.

    Always defect in all rounds:
    - Round 1 (first round): Defect to avoid exploitation.
    - Intermediate rounds: Defect because defecting strictly dominates cooperating payoff-wise.
    - Last round: Defect with no incentive to cooperate.

    This aligns with maximizing own payoff by never contributing and exploiting cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Aggressive Exploit-and-Punish Defector for N-Player Public Goods Game.

    Always defects every round. Uses history only to detect if any cooperators existed in the previous round,
    but this never alters the decision: always defect to maximize immediate payoff and exploit cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        prev_cooperators = sum(history.opponent_actions[history.round_number - 1])
        return Action.D

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Aggressive strategy for the repeated N-player Public Goods Game.

    - Round 1: cooperate once to probe population cooperativeness.
    - Rounds 2 to r-1: defect mostly to exploit cooperators.
      If many cooperators last round (≥50%), cooperate occasionally (~10%)
      to maintain leverage and keep cooperation from collapsing.
    - Last round: defect always (no future incentives).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        if k <= 1.05:
            return Action.D
        prev_round_idx = history.round_number - 1
        if prev_round_idx < 0:
            return Action.C
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        prev_cooperators = prev_opponent_actions.sum()
        coop_ratio = prev_cooperators / (n - 1) if n > 1 else 0
        last_my_action = history.my_actions[prev_round_idx]
        if coop_ratio >= self.threshold:
            if not last_my_action and random.random() < 0.1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    Aggressor strategy for the N-player repeated Public Goods Game.

    Summary:
    - Round 1: Defect.
    - From round 2 to round r-1:
      * If permanent defection mode triggered, defect always.
      * Otherwise, if last round had any defector among others, trigger permanent defection and defect.
      * Else if majority cooperated last round (including self), cooperate once to lure cooperators.
      * Else defect.
    - Last round: Always defect.
    
    The strategy punishes defectors permanently and exploits cooperators by brief cooperation only
    if majority cooperated last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self._defecters_detected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        last_round = t == self.r
        if t == 1:
            return Action.D
        if self._defecters_detected:
            return Action.D
        last_round_actions = history.opponent_actions[t - 2]
        if not last_round_actions.all():
            self._defecters_detected = True
            return Action.D
        cooperators = int(last_round_actions.sum()) + (1 if history.my_actions[t - 2] else 0)
        majority_cooperated = cooperators > self.n / 2
        if majority_cooperated and (not last_round):
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    Dominant Defector with Opportunistic Exploitation:
    - Always defect every round.
    - In intermediate rounds, exploit any cooperators detected in previous round by continuing to defect.
    - Never cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.game.n_rounds:
            return Action.D
        last_round_index = t - 2
        if last_round_index < 0:
            return Action.D
        last_opponent_actions = history.opponent_actions[last_round_index]
        any_cooperators = last_opponent_actions.any()
        return Action.D

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Aggressive strategy for N-player repeated Public Goods Game.
    Always defects every round to maximize immediate payoff by free-riding.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Defector-Leveraging Tirade:
    Aggressive public goods repeated game strategy.

    - Always defects first and last round.
    - In intermediate rounds, cooperates only if:
      * at least one opponent cooperated last round, and
      * cooperating yields expected payoff >= defecting payoff,
      exploiting cooperators.
    - Otherwise defects, punishing defectors and never initiating cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round = t - 1 - 1
        total_cooperators_prev = sum(history.opponent_actions[prev_round].tolist()) + (1 if history.my_actions[prev_round] else 0)
        player_cooperated_prev = history.my_actions[prev_round]
        opponent_cooperators_prev = total_cooperators_prev - (1 if player_cooperated_prev else 0)
        dPayoff = 1 + self.k / self.n * total_cooperators_prev
        cPayoff = self.k / self.n * (total_cooperators_prev + 1)
        if opponent_cooperators_prev >= 1 and cPayoff >= dPayoff:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    Aggressive strategy for the repeated N-player public goods game.
    Always defects to maximize private payoff, exploiting any cooperators,
    punishing by default defection only (never cooperating or retaliating).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.total_rounds:
            return Action.D
        last_opponent_actions = history.opponent_actions[history.round_number - 1]
        my_last_action = history.my_actions[history.round_number - 1]
        n = self.game_description.n_players
        last_round_all_actions = [my_last_action] + list(last_opponent_actions)
        if all(last_round_all_actions):
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game.

    Summary:
    - Round 1: Defect (no history).
    - Intermediate rounds (2 to r-1):
        * If any cooperators last round, defect to exploit.
        * If all defect last round:
            - Cooperate once as a probe to induce cooperation.
            - Avoid repeated probes by checking if last round you cooperated and 
              second last round was all defect, then defect.
    - Last round (r): Defect unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        current_round = 1 if history is None else history.round_number + 1
        if current_round == 1:
            return Action.D
        if current_round == self.r:
            return Action.D
        last_round_idx = current_round - 2
        last_opponent_actions = history.opponent_actions[last_round_idx]
        last_my_action = history.my_actions[last_round_idx]
        total_cooperators = int(last_my_action) + int(last_opponent_actions.sum())
        if total_cooperators > 0:
            return Action.D
        if total_cooperators == 0:
            if last_my_action:
                if current_round > 2:
                    second_last_round_idx = last_round_idx - 1
                    second_last_opponent_actions = history.opponent_actions[second_last_round_idx]
                    second_last_my_action = history.my_actions[second_last_round_idx]
                    second_last_total_cooperators = int(second_last_my_action) + int(second_last_opponent_actions.sum())
                    if second_last_total_cooperators == 0:
                        return Action.D
                else:
                    return Action.D
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    Aggressive "Exploit and Punish" Strategy for N-Player Public Goods Game.
    
    Summary:
    - Always defect (Action.D) in every round.
    - In round 1, defect to avoid initial cooperation risk.
    - In intermediate rounds, defect regardless of opponents' cooperation to punish cooperators.
    - In the last round, defect unconditionally to maximize immediate payoff.
    - Uses history to identify cooperators only to decide punishment (but action is always defect).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_number = 1 if history is None else history.round_number + 1
        if round_number == 1:
            return Action.D
        if round_number == self.n_rounds:
            return Action.D
        previous_round = round_number - 2
        if history.opponent_actions.shape[0] > previous_round:
            cooperated = history.opponent_actions[previous_round].any()
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Exploit & Punish strategy for the repeated N-player public goods game.

    Summary:
    - Always defect starting from the first round.
    - Exploit any cooperators by defecting in subsequent rounds.
    - Never cooperate, even in the last round.
    - Uses perfect information of previous actions to check if anyone else cooperated.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        prev_round_idx = t - 1
        if prev_round_idx < 0:
            return Action.D
        opp_coop_prev = 0
        if history.opponent_actions.shape[0] > prev_round_idx:
            opp_coop_prev = sum(history.opponent_actions[prev_round_idx])
        self_coop_prev = history.my_actions[prev_round_idx]
        others_coop_prev = opp_coop_prev
        return Action.D

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    Aggressive Exploiter strategy for N-Player Public Goods Game.

    Summary:
    - Always defect first round.
    - Always defect last round.
    - Between those, defect except:
      * If never tested cooperation before,
      * and currently in middle third of rounds,
      * and have always defected,
      * and have seen the same set of cooperators each round,
      * then cooperate once as a test to try to induce cooperation.
    - If cooperated last round but got payoff < 1, defect next round.
    - If cooperated last round and payoff >=1, defect next round regardless.
    - If defected last round and cooperators >0, defect next round (continue exploiting).
    - If defected last round and no cooperators, defect next round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.test_coop_done = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        my_actions = history.my_actions
        my_payoffs = history.my_payoffs
        opp_actions = history.opponent_actions
        if t == r:
            return Action.D
        prev_idx = t - 1
        c_i_prev = my_actions[prev_idx]
        prev_round_actions = [c_i_prev] + list(opp_actions[prev_idx])
        C_prev = sum(prev_round_actions)
        pi_i_prev = 1 - (1 if c_i_prev else 0) + k / n * C_prev

        def D():
            return Action.D

        def C():
            return Action.C
        if c_i_prev:
            if pi_i_prev < 1:
                return D()
            elif C_prev >= 2:
                return D()
            else:
                return D()
        elif C_prev == 0:
            return D()
        else:
            if not self.test_coop_done and t > r // 3 and (t < 2 * r // 3):
                if not any(my_actions):
                    coop_sets = []
                    for round_i in range(t):
                        round_act = [history.my_actions[round_i]] + list(opp_actions[round_i])
                        coop_players = set((idx for idx, act in enumerate(round_act) if act))
                        coop_sets.append(coop_players)
                    nonempty_coop_sets = [s for s in coop_sets if s]
                    if nonempty_coop_sets:
                        first = nonempty_coop_sets[0]
                        same_coop_each_round = all((s == first for s in nonempty_coop_sets))
                    else:
                        same_coop_each_round = False
                    if same_coop_each_round:
                        self.test_coop_done = True
                        return C()
            return D()

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    Aggressive Strategy for the N-Player Public Goods Game.

    Summary:
    - Round 1: Defect (no trust, start strong)
    - Intermediate Rounds:
      * If cooperated last round and got exploited (would gain more defecting), defect (punish)
      * Else if any player cooperated last round, defect to exploit
      * Else (all defected last round) cooperate once to test cooperation
    - Final Round: Defect (no incentive to cooperate)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_number = 1 if history is None else history.round_number + 1
        last_round_idx = round_number - 2
        if history is None:
            return Action.D
        if round_number == self.r:
            return Action.D
        my_last_action = history.my_actions[last_round_idx]
        own_coop = 1 if my_last_action else 0
        opp_coop_count = history.opponent_actions[last_round_idx].sum()
        total_cooperators = own_coop + opp_coop_count
        if my_last_action:
            coop_payoff = self.k / self.n * total_cooperators
            defect_payoff = 1 + self.k / self.n * (total_cooperators - 1)
            if defect_payoff > coop_payoff:
                return Action.D
        if total_cooperators >= 1:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Aggressive strategy for N-player Public Goods Game.
    Always defects to maximize private payoff and exploits any cooperation by others.
    Uses a cooperation threshold T=1 to identify cooperation and punishes it by defecting.
    Never cooperates, including first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        r = self.game_description.n_rounds
        if t == r - 1:
            return Action.D
        prev_round_idx = t - 1
        coop_opponents = 0
        if prev_round_idx >= 0:
            coop_opponents = history.opponent_actions[prev_round_idx].sum()
        coop_self = 1 if prev_round_idx >= 0 and prev_round_idx < len(history.my_actions) and history.my_actions[prev_round_idx] else 0
        C_prev = coop_opponents + coop_self
        if C_prev >= self.T:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    Aggressive strategy for the N-player repeated public goods game.
    Always defects every round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    Aggressive exploitative defector strategy for the
    N-Player Public Goods Game.

    Always defects every round, including first and last.
    Exploits cooperating opponents by never cooperating,
    punishing cooperation by denying them returns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    Defect-Exploit-TitForTitans (DETT) strategy for the repeated N-player Public Goods Game.

    Always defects initially and in the last round.
    If punished last round (self defected but others mostly defected), 
    cooperate exactly once to signal willingness to restore cooperation.
    Otherwise, defect to exploit any cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._cooperated_last_after_punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            self._cooperated_last_after_punish = False
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            self._cooperated_last_after_punish = False
            return Action.D
        self_last = history.my_actions[-1]
        opponents_last = history.opponent_actions[-1]
        S_last = opponents_last.sum() + (1 if self_last else 0)
        punished = not self_last and S_last <= 1
        if punished:
            if self._cooperated_last_after_punish:
                self._cooperated_last_after_punish = False
                return Action.D
            else:
                self._cooperated_last_after_punish = True
                return Action.C
        self._cooperated_last_after_punish = False
        if S_last > 0:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    Aggressive free-riding strategy for N-Player Public Goods Game.

    Always defects, exploits any observed cooperation in past rounds,
    and punishes persistent cooperators by continued defection.
    Never attempts to cooperate voluntarily.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = t - 1
        if last_round_idx >= 0:
            last_opponent_actions = history.opponent_actions[last_round_idx]
            cooperators_last_round = last_opponent_actions.sum()
        else:
            cooperators_last_round = 0
        if cooperators_last_round > 0:
            return Action.D
        total_rounds_played = t
        coop_counts = history.opponent_actions[:total_rounds_played].sum(axis=0)
        half_rounds = total_rounds_played / 2
        if (coop_counts > half_rounds).any():
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    Aggressor-X strategy for the N-Player Public Goods Game:
    - Always defects.
    - Round 1: defect to probe (since no history).
    - Rounds 2 to r-1: defect regardless to exploit cooperators and punish cooperation.
    - Final round: defect always to maximize immediate payoff without future concerns.
    This strategy never cooperates and exploits cooperators whenever possible.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game.
    - Always defects.
    - Uses history to confirm exploitation of any cooperators.
    - Never cooperates to avoid sacrificing private gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        prev_round = t - 1
        opponents_cooperated = False
        if prev_round >= 0:
            opponents_cooperated = history.opponent_actions[prev_round].any()
        return Action.D

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    Aggressive Exploiter with Punishment strategy for repeated N-Player Public Goods Game.

    Summary:
    - Always defect, exploiting cooperators and punishing defectors.
    - Round 1: Defect (no history).
    - Rounds 2 to r-1:
        * If majority cooperated last round, defect to exploit.
        * Else defect to avoid exploitation.
        * If majority defected last round, continue defecting.
    - Final round: Defect always (no future incentives).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.cooperate_threshold = (self.n + 1) // 2
        self.defect_threshold = self.n // 2 + 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round_idx = history.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opp_prev_actions = history.opponent_actions[prev_round_idx]
        c_count = int(my_prev_action) + opp_prev_actions.sum()
        d_count = self.n - c_count
        if d_count >= self.defect_threshold:
            return Action.D
        if c_count >= self.cooperate_threshold:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Aggressive strategy for N-player repeated Public Goods Game.

    - Round 1: Defect to test and exploit.
    - Final round: Always defect (no future retaliation).
    - Intermediate rounds:
        * Calculate opponents' cooperation last round.
        * Cooperate only if:
            - You cooperated last round, AND
            - Majority (≥ ceil(n/2)) of opponents cooperated last round.
        * Otherwise defect to exploit or punish.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold_H = (self.n + 1) // 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        next_round = t + 1
        if next_round == self.r:
            return Action.D
        last_round = t - 1
        if last_round < 0:
            return Action.D
        opp_actions_last = history.opponent_actions[last_round]
        opponents_cooperated_last_round = opp_actions_last.sum()
        my_cooperated_last_round = history.my_actions[last_round]
        if opponents_cooperated_last_round >= self.threshold_H and my_cooperated_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    Aggressive Exploiter for the N-Player Public Goods Game.
    Always defects in every round, ignoring history and opponent behavior.
    Maximizes individual payoff by never paying contribution cost,
    thus exploiting cooperators and performing at least as well as defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    Aggressive Exploiter strategy for the N-Player Public Goods Game.
    Always defects each round to maximize immediate payoffs.
    Detects if any opponent ever cooperated before but always defects to exploit them.
    On first round and last round, defects unconditionally.
    This strategy never cooperates, maximizing selfish gain and exploiting cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        round_num = history.round_number + 1
        r = self.game_description.n_rounds
        if history.opponent_actions.size == 0:
            others_cooperated_before = False
        else:
            others_cooperated_before = history.opponent_actions.any()
        if round_num == r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game.

    Always defects. Never cooperates.
    - Round 1: Defect (no info).
    - Rounds 2 to r-1: Defect regardless of opponents' cooperation.
    - Round r: Defect (endgame defection).
    
    This exploits any cooperating opponents and punishes them by denying returns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number
        r = self.game_description.n_rounds
        if round_number + 1 == r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    Aggressive self-maximizing repeated strategy for N-Player Public Goods Game.
    Always defects:
    - Round 1: defect to test others
    - Intermediate rounds: defect and exploit any observed cooperators
    - Last round: defect (no future punishment)
    Never cooperates, never forgives, exploits cooperators to maximize payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        if history.opponent_actions.any():
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game.

    - Always defects.
    - Tracks repeat cooperators (opponents who cooperated in two consecutive rounds)
      to identify exploitable targets but never cooperates.
    - Exploits majority cooperation by defecting.
    - Defects in the first round due to no history.
    - Defects in the last round due to no future retaliation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold = 0.5
        self.repeat_cooperators = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_round_idx = t - 2
        coop_flags = []
        coop_flags.append(history.my_actions[last_round_idx])
        for opp_idx in range(self.n - 1):
            coop_flags.append(history.opponent_actions[last_round_idx, opp_idx])
        coop_count = sum((1 for c in coop_flags if c))
        coop_proportion = coop_count / self.n
        new_repeat_cooperators = set()
        if t > 2:
            prev_prev_round_idx = t - 3
            if history.my_actions[last_round_idx] and history.my_actions[prev_prev_round_idx]:
                pass
            for opp_idx in range(self.n - 1):
                if history.opponent_actions[last_round_idx, opp_idx] and history.opponent_actions[prev_prev_round_idx, opp_idx]:
                    new_repeat_cooperators.add(opp_idx)
        else:
            new_repeat_cooperators = set()
        self.repeat_cooperators = new_repeat_cooperators
        return Action.D

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Aggressive Exploiter strategy for N-player repeated Public Goods game.
    
    - Defects first and last rounds unconditionally.
    - In middle rounds, defects if many cooperated last round (to exploit).
    - Otherwise defects as default, no cooperation except rare strategic incentive (not implemented here).
    - Tracks history of opponent cooperation to decide.
    """

    def __init__(self, game_description):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.coop_threshold = max(1, int(0.5 * self.n))

    def __call__(self, history):
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == 1:
            return Action.D
        if current_round == self.r:
            return Action.D
        last_round_index = current_round - 2
        opp_coop_count = history.opponent_actions[last_round_index].sum()
        own_last_action = history.my_actions[last_round_index]
        total_cooperators_last = opp_coop_count + (1 if own_last_action else 0)
        if total_cooperators_last >= self.coop_threshold:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Defect-First Exploitative (DFE) strategy for N-Player Public Goods Game.
    Aggressively defects every round:
    - Round 1: defect to gain private payoff and reveal cooperators.
    - Subsequent rounds: always defect to exploit any cooperators present.
    - Last round: defect as well, no incentive to cooperate.
    Never cooperates, always maximizes short-term private gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == 1:
            return Action.D
        last_round_index = t - 2
        my_last_action = history.my_actions[last_round_index]
        opp_last_actions = history.opponent_actions[last_round_index]
        coop_last_round = (1 if my_last_action else 0) + sum((1 for act in opp_last_actions if act))
        return Action.D

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Aggressive Public Goods Strategy (Always Defect):
    
    - Always defects every round.
    - Exploits cooperators by never cooperating.
    - Never cooperates, punishes cooperation aggressively.
    - First round defects (no trust).
    - Last round defects (no future incentive).
    - Intermediate rounds defect regardless of others' cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    Aggressive self-maximizing strategy for repeated N-player Public Goods Game.
    
    - Round 1: defect to test others.
    - Last round: defect.
    - Intermediate rounds:
        * If no cooperators last round: defect.
        * If cooperators last round: defect except cooperate every 5th round to signal willingness to cooperate
          and prevent universal defection collapse.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        last_round_idx = t - 1
        coop_opp_last = sum(history.opponent_actions[last_round_idx])
        self_last_action = history.my_actions[last_round_idx]
        coop_last_round = coop_opp_last + (1 if self_last_action else 0)
        if coop_last_round == 0:
            return Action.D
        elif current_round % 5 == 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game:
    Always defect on every round, including first and last.
    Never cooperate, never trust, maximize personal payoff by exploiting cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Aggressive Defector Strategy ("AggroFreeRider") for N-player Public Goods Game.

    Strategy summary:
    - Defect always in first round.
    - In intermediate rounds (2 to r-1), defect always:
      * Exploit any cooperators by defecting,
      * Do not initiate cooperation if all defected last round.
    - Defect always in last round to maximize private payoff without risk of punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        last_round_index = t - 2
        my_last_action = history.my_actions[last_round_index]
        opp_last_actions = history.opponent_actions[last_round_index]
        total_cooperators_last_round = (my_last_action == True) + sum(opp_last_actions)
        if total_cooperators_last_round > 0:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game.

    Summary:
    - Round 1: Always defect.
    - Intermediate rounds: 
      * If cooperated last round but others mostly defected -> defect (punish).
      * Else always defect.
    - Final round: Always defect.

    Never cooperates first or rebuilds cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number == self.r:
            return Action.D
        if history is None or history.round_number == 0:
            return Action.D
        last_round = history.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponents_last_actions = history.opponent_actions[last_round]
        coop_count = sum(opponents_last_actions)
        if my_last_action and coop_count < (self.n - 1) / 2:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Aggressive "Defector Exploit with Conditional Defection" strategy for N-player Public Goods Game.
    Always defects:
    - Defects on round 1 (no history)
    - Defects in all intermediate rounds
    - Defects in last round (backward induction)
    - Exploits any cooperators by defecting regardless
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        previous_idx = history.round_number - 1
        if previous_idx >= 0:
            if history.opponent_actions[previous_idx].any():
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    Exploit-Aggro Strategy for the repeated N-player Public Goods Game.

    Summary:
    - Always defect in the first and last rounds.
    - In midgame (rounds 2 to r-1):
      * Detect persistent cooperators (those who cooperated >= 2 times).
      * If persistent cooperators cooperated in the last round, cooperate once to exploit their contribution,
        then defect otherwise.
      * If no persistent cooperators, cooperate exactly once after seeing any cooperation in the previous round,
        otherwise defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        n = self.n
        r = self.r
        i = 0
        current_round = t + 1
        if current_round == 1 or current_round == r:
            return Action.D
        full_history = [[False] * n for _ in range(t)]
        for round_idx in range(t):
            full_history[round_idx][0] = bool(history.my_actions[round_idx])
            for opp_idx in range(n - 1):
                full_history[round_idx][opp_idx + 1] = bool(history.opponent_actions[round_idx, opp_idx])
        coop_counts = [0] * n
        for past_round in full_history:
            for j in range(n):
                if past_round[j]:
                    coop_counts[j] += 1
        persistent_cooperators = [j for j in range(1, n) if coop_counts[j] >= 2]
        prev_round = full_history[-1]
        others_cooperated_prev = any((prev_round[j] for j in range(1, n)))
        if persistent_cooperators:
            exploited_this_round = any((prev_round[j] for j in persistent_cooperators))
            if exploited_this_round:
                return Action.C
            else:
                return Action.D
        elif others_cooperated_prev:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game.
    
    Summary:
    - Always defect in all rounds.
    - No cooperation or forgiveness.
    - Exploit any cooperators by defecting.
    - Defect in the first, intermediate, and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game.

    - Defect first round and last round.
    - In intermediate rounds, cooperate only if cooperating yields strictly higher
      expected payoff given last round's cooperation count.
    - If exploited last round (cooperated but payoff ≤ 1), switch to defect permanently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        if t == self.r - 1:
            return Action.D
        last_round_index = t - 1
        my_action_prev = history.my_actions[last_round_index]
        opp_actions_last = history.opponent_actions[last_round_index]
        opp_cooperators_last = sum(opp_actions_last)
        total_cooperators_last = opp_cooperators_last + (1 if my_action_prev else 0)
        c_i_prev = 1 if my_action_prev else 0
        payoff_prev = 1 - c_i_prev + self.k / self.n * total_cooperators_last
        if my_action_prev and payoff_prev <= 1:
            return Action.D
        expected_cooperators = opp_cooperators_last
        payoff_if_cooperate = self.k / self.n * (expected_cooperators + 1)
        payoff_if_defect = 1 + self.k / self.n * expected_cooperators
        if payoff_if_cooperate > payoff_if_defect:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Aggressive "Defect-Exploit-All" strategy for the repeated N-player public goods game.

    Key behavior:
    - Always defect from the first to the last round.
    - Exploit any cooperators in the previous round by continuing to defect.
    - Never cooperate, maximizing private payoff and free-riding on cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        prev_round_index = history.round_number - 1
        cooperators_exist = history.opponent_actions[prev_round_index].any()
        return Action.D

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Aggressor strategy for N-Player Public Goods Game.

    Always defects first and last rounds.
    In intermediate rounds, exploits cooperators by defecting unless a strict majority
    of opponents have cooperated consistently (≥80% previous rounds) and cooperated last round,
    then attempts a cautious one-time cooperation to avoid isolation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        my_index = -1
        if t == self.r:
            return Action.D
        rounds_played = history.round_number
        if rounds_played == 0:
            return Action.D
        coop_counts = history.opponent_actions.sum(axis=0)
        coop_fraction = coop_counts / rounds_played
        coop_threshold = 0.8
        consistent_cooperators = (coop_fraction >= coop_threshold).sum()
        majority = self.n // 2
        majority_incl_self = self.n // 2 + 1
        majority_excl_self = majority_incl_self - 1
        last_round_cooperators = history.opponent_actions[-1].sum()
        if consistent_cooperators >= majority_excl_self and last_round_cooperators >= majority_excl_self:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game.
    Always defects to maximize personal payoff by exploiting cooperators.
    
    Behavior:
    - Round 1: Defect, no history.
    - Rounds 2 to r-1: Defect if any cooperators last round or none cooperated.
    - Last round r: Defect regardless.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = 1 if history is None else history.round_number + 1
        if history is None:
            return Action.D
        if current_round == r:
            return Action.D
        prev_round_index = history.round_number - 1
        prev_cooperators = 0
        if history.my_actions[prev_round_index]:
            prev_cooperators += 1
        prev_cooperators += history.opponent_actions[prev_round_index].sum()
        return Action.D

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Aggressive repeated N-player Public Goods game strategy.
    
    Starts cooperating in round 1 to test and exploit cooperators.
    In intermediate rounds, defects unless:
      - The previous round had a high cooperation ratio (>0.6)
      - This player cooperated in the previous round
    Defects otherwise to punish defectors and avoid exploitation.
    Always defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.coop_threshold = 0.6

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_opponent_actions = history.opponent_actions[t - 2]
        prev_coop_count = prev_opponent_actions.sum()
        coop_ratio = prev_coop_count / self.n
        prev_my_action = history.my_actions[t - 2]
        if not prev_my_action:
            return Action.D
        if prev_my_action and coop_ratio > self.coop_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    Aggressive Defector with Opportunistic Exploitation for the N-Player Public Goods Game.

    Starts defecting, then exploits cooperators while never tolerating being exploited.
    Cooperates only if strictly profitable and stable coalition emerges.
    Always defects first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        last_round_idx = t - 1
        my_last_action = history.my_actions[last_round_idx]
        my_last_payoff = history.my_payoffs[last_round_idx]
        opponent_last_actions = history.opponent_actions[last_round_idx]
        opponent_last_payoffs = history.opponent_payoffs[last_round_idx]
        cooperators_count = int(my_last_action) + opponent_last_actions.sum()
        defectors_count = self.n - cooperators_count
        defectors_payoffs = []
        if not my_last_action:
            defectors_payoffs.append(my_last_payoff)
        for a, p in zip(opponent_last_actions, opponent_last_payoffs):
            if not a:
                defectors_payoffs.append(p)
        avg_defector_payoff = sum(defectors_payoffs) / len(defectors_payoffs) if defectors_payoffs else 0.0
        sole_cooperator = cooperators_count == 1 and my_last_action
        almost_all_cooperated = cooperators_count >= self.n - 1
        no_cooperators = cooperators_count == 0
        if t == self.r - 1:
            return Action.D
        if my_last_action:
            if sole_cooperator:
                return Action.D
            if my_last_payoff < avg_defector_payoff:
                return Action.D
            else:
                return Action.C
        elif cooperators_count > 0:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Aggressive strategy for N-player Public Goods Game:
    - Always defect initially and in the last round.
    - Cooperate only if it strictly increases immediate payoff based on last round's total cooperators.
    - Punish immediately by defecting if cooperated last round but gained no advantage.
    - Use history of total cooperators (including self) for decisions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n = self.n
        r = self.r
        k = self.k
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        last_round_idx = t - 2
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        last_total_cooperators = opp_last_actions.sum() + (1 if my_last_action else 0)
        pi_cooperate = k / n * (last_total_cooperators + 1)
        pi_defect = 1 + k / n * last_total_cooperators
        if my_last_action:
            pi_c_last = k / n * last_total_cooperators
            defect_cooperators = last_total_cooperators - 1
            pi_d_last = 1 + k / n * defect_cooperators
            if pi_c_last <= pi_d_last:
                return Action.D
        if pi_cooperate > pi_defect:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game
    
    Defect by default to maximize short-term payoffs.
    Cooperate only if in previous round majority cooperated AND
    cooperating yields strictly higher payoff than defecting.
    Always defect in first and last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        prev_round_idx = current_round - 2
        opp_coop = history.opponent_actions[prev_round_idx].sum()
        my_last_coop = 1 if history.my_actions[prev_round_idx] else 0
        total_cooperators = opp_coop + my_last_coop
        if total_cooperators > self.n / 2:
            coop_contrib = total_cooperators + 1
            payoff_coop = 0 + self.k / self.n * coop_contrib
            payoff_defect = 1 + self.k / self.n * total_cooperators
            if payoff_coop > payoff_defect:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game:
    - Always defect every round.
    - Punishes any cooperation by others immediately and harshly by continuing to defect.
    - Never cooperates, no forgiveness.
    - Defect on the last round as well (no incentive to cooperate).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.D
        round_number = history.round_number
        if round_number == r:
            return Action.D
        last_round_index = round_number - 1
        any_cooperators = history.opponent_actions[last_round_index].any()
        return Action.D

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    "Predator Defector" strategy for N-player Public Goods Game.
    
    Always defects. Aggressively exploits cooperators by never cooperating.
    Defects on first round due to no information.
    Defects on all intermediate rounds regardless of others' actions to maximize payoff.
    Defects on last round since no future round to incentivize cooperation.
    No baiting or cooperation attempts.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == n_rounds:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game:
    - Round 1: Cooperate to probe others.
    - Early rounds (t <= floor(r/2)): Cooperate if at least half others cooperated last round; else defect.
    - Mid rounds (floor(r/2) < t < r): Cooperate only if all others cooperated last round; else defect.
    - Last round (t == r): Always defect.
    Attempts to free-ride on cooperators while punishing minimally to avoid collective defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.mid_point = game_description.n_rounds // 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        last_round = t == self.r
        last_opponent_actions = history.opponent_actions[-1]
        last_cooperators = last_opponent_actions.sum()
        half_players = self.n / 2
        if last_round:
            return Action.D
        if t <= self.mid_point:
            if last_cooperators >= half_players:
                return Action.C
            else:
                return Action.D
        elif last_cooperators == self.n - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game.

    Summary:
    - Never cooperate first round (always defect).
    - Always defect last round.
    - In intermediate rounds, compute average cooperation ratio across all players (including self) in previous rounds.
    - If average cooperation above threshold theta=1/n, defect aggressively.
    - Else, cooperate only if previous round cooperation ratio < epsilon=0.1 (stimulate cooperation).
    - Otherwise defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.theta = 1.0 / self.n
        self.epsilon = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        total_rounds = t - 1
        cooperators_sum = 0
        for round_idx in range(total_rounds):
            my_c = 1 if history.my_actions[round_idx] else 0
            opp_c = history.opponent_actions[round_idx].sum()
            cooperators_sum += my_c + opp_c
        avg_coop_ratio = cooperators_sum / (total_rounds * self.n)
        prev_round_idx = total_rounds - 1
        my_prev = 1 if history.my_actions[prev_round_idx] else 0
        opp_prev = history.opponent_actions[prev_round_idx].sum()
        prev_round_coop_ratio = (my_prev + opp_prev) / self.n
        if avg_coop_ratio > self.theta:
            return Action.D
        if prev_round_coop_ratio < self.epsilon:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Aggressive free-riding strategy for the N-Player Public Goods Game.

    Key features:
    - Always defects in the first round.
    - Always defects in the last round.
    - In intermediate rounds, if any player cooperated in the previous round, defect to exploit.
    - Never cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        prev_self_coop = history.my_actions[t - 1]
        prev_opponents_coop = history.opponent_actions[t - 1]
        total_cooperators_prev = (1 if prev_self_coop else 0) + sum(prev_opponents_coop)
        if total_cooperators_prev > 0:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    Aggressive strategy for repeated N-player Public Goods Game.

    - Cooperate once in the first round to signal willingness.
    - Defect in the last round to maximize immediate payoff.
    - In intermediate rounds, always defect.
      Exploit if majority of others cooperated previously, otherwise still defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[t - 1])
        if last_round_cooperators > (self.n - 1) / 2:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game.

    Summary:
    - Round 1: cooperate with 10% probability, defect with 90% probability (testing).
    - Rounds 2 to r: always defect.
    - Last round also defects.
    - Never cooperate except a rare chance in first round.
    - No forgiveness, no reciprocity, purely self-maximizing defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C if random.random() < 0.1 else Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == 1:
            return Action.C if random.random() < 0.1 else Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    Aggressive N-Player Public Goods Game strategy.

    Summary:
    - Round 1: Cooperate once as an exploratory probe.
    - Rounds 2 to r-1: Always defect, exploiting any cooperators discovered in prior rounds.
    - Round r (last round): Defect to maximize immediate payoff.
    - Never cooperate after first round regardless of opponent behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == 1:
            return Action.C
        if t == r:
            return Action.D
        opponent_cooperated_before = False
        if history is not None and history.round_number > 0:
            if history.opponent_actions.any():
                opponent_cooperated_before = True
        return Action.D

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    Aggressive Strategy "Exploit-When-Profitable, Defect-Otherwise" for N-Player Public Goods Game.

    Summary:
    - Always defect in the first and last rounds.
    - In intermediate rounds, cooperate only if the majority (≥60%) cooperated in the previous round.
    - Otherwise defect to maximize private payoffs and exploit cooperators.
    - Switch permanently to defection if cooperation payoffs drop significantly or cooperation rate never recovers past halfway.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.theta = 0.6
        self.permanent_defect = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            self.permanent_defect = False
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        if self.permanent_defect:
            return Action.D
        prev_idx = t - 1
        if prev_idx < 0:
            return Action.D
        my_prev_action = history.my_actions[prev_idx]
        opp_prev_actions = history.opponent_actions[prev_idx]
        coop_count_prev = int(my_prev_action) + int(opp_prev_actions.sum())
        coop_ratio_prev = coop_count_prev / self.n
        my_prev_payoff = history.my_payoffs[prev_idx]
        hypothetical_coop_count = coop_count_prev - int(my_prev_action)
        expected_defect_payoff = 1 - 0 + self.k / self.n * hypothetical_coop_count
        if my_prev_action and my_prev_payoff + 0.1 < expected_defect_payoff:
            self.permanent_defect = True
            return Action.D
        half_round = self.r // 2
        if current_round > half_round:
            lookback = min(t, 3)
            coop_ratios = []
            for i in range(t - lookback, t):
                my_act = history.my_actions[i]
                opp_act = history.opponent_actions[i]
                ccount = int(my_act) + int(opp_act.sum())
                coop_ratios.append(ccount / self.n)
            if coop_ratios and all((ratio < self.theta for ratio in coop_ratios)):
                self.permanent_defect = True
                return Action.D
        if coop_ratio_prev >= self.theta:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Aggressive strategy for N-player Public Goods game:
    - Always defect every round.
    - Exploit cooperators fully by never contributing.
    - No cooperation as first move or retaliation.
    - Defect especially in last round due to no future punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        current_round = history.round_number
        if current_round == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Exploit & Punish Aggressor:
    Aggressively defects by default to maximize exploitation.
    Cooperates only once after observing full defection previous round,
    as a tactical lure to restart cooperation, then returns to defection.
    Always defects first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == 1:
            return Action.D
        if current_round == self.r:
            return Action.D
        prev_round_index = current_round - 2
        prev_round_opponent_actions = history.opponent_actions[prev_round_index]
        my_prev_action = history.my_actions[prev_round_index]
        C_count_prev = prev_round_opponent_actions.sum() + (1 if my_prev_action else 0)
        if C_count_prev == 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    Aggressive Strategy for the N-Player Public Goods Game.

    Always defect every round.
    Keep track of opponents who cooperated last round,
    mark them as exploitable (punishment list P), and continue defecting to punish.

    Summary:
    - Round 1: defect (no info on others)
    - Intermediate rounds: defect, add cooperators from last round to punishment list P
    - Last round: defect unconditionally

    Never cooperate to avoid paying cost of contribution.
    Exploit cooperators by free-riding and punishing them via persistent defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.P = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        last_round_index = t - 1
        cooperating_opponents = history.opponent_actions[last_round_index]
        for opp_index, cooperated in enumerate(cooperating_opponents):
            if cooperated:
                self.P.add(opp_index)
        if t == r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    Aggressive "Exploit-Trigger-Defect" (ETD) strategy for N-Player Public Goods Game.
    
    Summary:
    - Always defect on first and last rounds.
    - On intermediate rounds, defect unconditionally to maximize personal payoff by exploiting cooperators.
    - Does not cooperate since cooperating never yields a strictly better payoff under the given payoff structure.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        last_round_idx = t - 2
        opp_last = history.opponent_actions[last_round_idx]
        num_coop_opp_last = opp_last.sum()
        my_last_c = history.my_actions[last_round_idx]
        num_cooperators_last_round = num_coop_opp_last + (1 if my_last_c else 0)
        return Action.D

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game.

    Always defects:
    - First round: defect to exploit presumptive cooperators.
    - Middle rounds: defect regardless of others' cooperation, exploiting cooperators.
    - Last round: defect since no future punishment/reward.

    Never cooperates, maximizing own payoff by free-riding on cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        last_round_cooperators = 0
        if history.my_actions[t - 1 - 1]:
            last_round_cooperators += 1
        last_round_cooperators += sum(history.opponent_actions[t - 1 - 1])
        return Action.D

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Aggressive strategy for the N-player repeated Public Goods game.
    - Round 1: Cooperate to test willingness of others.
    - Rounds 2 to r-1: Cooperate if all players cooperated last round; otherwise defect aggressively.
    - Last round: Defect to maximize immediate payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_index = history.round_number - 1
        self_coop = history.my_actions[last_round_index]
        opponents_coop_all = history.opponent_actions[last_round_index].all()
        all_cooperated = self_coop and opponents_coop_all
        if all_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    Aggressive strategy for the repeated N-Player Public Goods Game.

    Summary:
    - Defect on first round.
    - Defect on last round.
    - Keep track if ever exploited (cooperated but got less payoff than defectors last round),
      then defect permanently thereafter.
    - Exploit cooperators by defecting when many cooperated last round (≥ ceil(n/2)).
    - Occasionally cooperate every m rounds to probe and lure cooperation.
    - Defect if only self cooperated last round (isolated cooperator).
    - Defect if everyone cooperated last round (to maximize payoff by free-riding).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.m = 4
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.permanent_defect = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.permanent_defect:
            return Action.D
        prev_idx = t - 2
        self_last_action = history.my_actions[prev_idx]
        payoff_self_last = history.my_payoffs[prev_idx]
        opp_actions_last = history.opponent_actions[prev_idx]
        C_last = int(self_last_action) + int(opp_actions_last.sum())
        opp_payoffs_last = history.opponent_payoffs[prev_idx]
        max_payoff_last = payoff_self_last if payoff_self_last > opp_payoffs_last.max() else opp_payoffs_last.max()
        exploited_last = self_last_action is True and payoff_self_last < max_payoff_last
        isolated_cooperator = C_last == 1
        universal_coop = C_last == self.n
        if exploited_last:
            self.permanent_defect = True
            return Action.D
        if isolated_cooperator:
            return Action.D
        if universal_coop:
            return Action.D
        threshold_cooperators = -(-self.n // 2)
        if C_last >= threshold_cooperators:
            return Action.D
        if t % self.m == 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Aggressive strategy for repeated N-player Public Goods game:
    - Round 1: defect
    - Rounds 2..r-1: if previous round had ≥ 75% cooperation by all players (including self),
      cooperate once if last action was defect to exploit cooperation environment; otherwise defect.
    - Last round: always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.threshold = int(0.75 * self.game.n_players)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        r = self.game.n_rounds
        n = self.game.n_players
        if t == r:
            return Action.D
        last_round = t - 2
        coop_opponents = history.opponent_actions[last_round].sum()
        self_coop_last = history.my_actions[last_round]
        C_count = coop_opponents + (1 if self_coop_last else 0)
        if C_count >= self.threshold:
            if not self_coop_last:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game.

    - Round 1: Cooperate once to probe opponents.
    - Rounds 2 to r-1: Defect always. Exploit if majority cooperated previously,
      else avoid exploitation.
    - Last round (r): Defect unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            round_number = 1
        else:
            round_number = history.round_number + 1
        if round_number == 1:
            return Action.C
        if round_number == self.r:
            return Action.D
        prev_idx = round_number - 2
        self_coop = history.my_actions[prev_idx]
        opp_coop_count = history.opponent_actions[prev_idx].sum()
        total_cooperators = int(self_coop) + int(opp_coop_count)
        majority_cooperated = total_cooperators > self.n / 2
        return Action.D

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game.

    - Round 1: Defect.
    - Intermediate rounds (2 ... r-1): Cooperate only if ALL other players cooperated last round; else defect.
    - Final round (r): Defect.

    This strategy exploits cooperators and punishes partial cooperation, leveraging the game payoff structure.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = 1 if history is None else history.round_number + 1
        if current_round == 1:
            return Action.D
        if current_round == r:
            return Action.D
        last_round_idx = current_round - 2
        last_opponent_actions = history.opponent_actions[last_round_idx]
        if last_opponent_actions.all():
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Egoistic Exploiter: aggressive always-defect strategy in repeated N-player Public Goods Game.
    Defects first round, all middle rounds, and last round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory):
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    Aggressive Strategy: Defect first and last round, exploit majority cooperators in intermediate rounds,
    cooperate only when few others cooperated last round to bait or encourage cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = (self.game_description.n_players - 1) // 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        last_opponent_actions = history.opponent_actions[t - 1]
        num_cooperators = last_opponent_actions.sum()
        if num_cooperators == 0:
            return Action.C
        if num_cooperators >= self.T:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    Aggressive strategy for N-player repeated Public Goods Game.

    Summary:
    - Round 1: defect, no trust yet.
    - Last round: defect, no future cooperation incentive.
    - Intermediate rounds:
      * Defect if few cooperators last round (<=1).
      * Otherwise, cooperate only if cooperating strictly improves immediate payoff.
      * Otherwise defect to exploit cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.gd = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        prev_round_idx = t - 1
        opp_coop_prev = 0
        if self.n > 1:
            opp_coop_prev = history.opponent_actions[prev_round_idx].sum()
        you_coop_prev = bool(history.my_actions[prev_round_idx])
        cooperators_last_round = opp_coop_prev + (1 if you_coop_prev else 0)
        other_cooperators_last_round = cooperators_last_round - (1 if you_coop_prev else 0)
        if cooperators_last_round <= 1:
            return Action.D
        expected_cooperators_if_C = cooperators_last_round + (0 if you_coop_prev else 1)
        payoff_C = self.k / self.n * expected_cooperators_if_C
        payoff_D = 1 + self.k / self.n * cooperators_last_round
        if payoff_D >= payoff_C:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    Aggressive strategy for the repeated n-player Public Goods Game.

    Summary:
    - Always defect (Action.D) in the first round (no history).
    - From round 2 to round r-1, defect regardless of opponents' behavior,
      exploiting any cooperation by others without cooperating.
    - In the last round, defect to avoid any future penalty.
    This strategy never cooperates, maximizing own payoff by free-riding on cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Exploit and Punish Minimalist strategy for N-Player Public Goods Game.
    Always defects to maximize own payoff.
    Aggressively exploits full cooperation and punishes substantial cooperation (≥50%) by defecting.
    First and last rounds always defect.
    Does not cooperate at any time.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory):
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        n = self.n
        r = self.r
        if t == r:
            return Action.D
        last_round_actions = history.opponent_actions[t - 1]
        opponents_coop_count = sum(last_round_actions)
        my_last_action = history.my_actions[t - 1]
        total_coop_last_round = opponents_coop_count + (1 if my_last_action else 0)
        coop_fraction = total_coop_last_round / n
        if total_coop_last_round == n:
            return Action.D
        if coop_fraction >= 0.5:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Exploitive Defector with Opportunistic Retaliation for the N-Player Public Goods Game.

    - Always defects the first round.
    - On intermediate rounds (2 to r-1):
      * If majority of opponents cooperated last round, defect to exploit.
      * Else if opponents cooperated less than majority last round,
        retaliate by cooperating exactly one round, then defect again.
    - Always defects on last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.threshold = (self.game.n_players - 1) / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        r = self.game.n_rounds
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        prev_round_idx = t - 2
        if history is None or history.round_number < 1:
            return Action.D
        last_opponent_actions = history.opponent_actions[prev_round_idx]
        C_last = last_opponent_actions.sum()
        if C_last >= self.threshold:
            return Action.D
        else:
            did_coop_last = history.my_actions[prev_round_idx]
            if did_coop_last:
                return Action.D
            else:
                return Action.C

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    Aggressive Defector with Opportunistic Exploitation for the N-Player Public Goods Game.
    
    Summary:
    - Always defects every round unconditionally.
    - Exploits cooperators by never cooperating.
    - First round: defect (no history).
    - Middle rounds: defect (cooperation never payoff beneficial).
    - Last round: defect to avoid exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_index = history.round_number
        current_round = round_index + 1
        if current_round == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Dominant Defector with Opportunistic Exploitation:
    Aggressive strategy for N-player repeated public goods game.
    
    - Defects first round to avoid initial cost.
    - For rounds 2 to r-1, cooperates only if cooperating strictly improves payoff
      compared to defecting, based on previous round's cooperation count.
    - Defects last round to avoid endgame cooperation.
    - Uses only last round's cooperation count to decide.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        opponents_coop_count = history.opponent_actions[prev_round_idx].sum()
        my_coop_last = 1 if history.my_actions[prev_round_idx] else 0
        C_prev = opponents_coop_count + my_coop_last
        pi_C = self.k / self.n * (C_prev + 1)
        pi_D = 1 + self.k / self.n * C_prev
        if pi_C > pi_D:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game.

    Defects first round to test environment.
    From rounds 2 to r-1, if all other players cooperated last round, cooperates only if
    cooperating strictly yields higher immediate payoff than defecting; else defects.
    Always defects on the last round.
    Mostly defects to exploit cooperators, never initiates cooperation unless payoff is strictly better.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        n, r, k = (self.n, self.r, self.k)
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[t - 2] if t > 1 else []
        last_round_coop_others = 0
        if t > 1:
            last_round_coop_others = sum(last_round_opponent_actions)
        all_others_cooperated = last_round_coop_others == n - 1
        if all_others_cooperated:
            cooperate_payoff = k
            defect_payoff = 1 + k / n * (n - 1)
            if cooperate_payoff > defect_payoff:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    Aggressive Strategy for the N-Player Public Goods Game.

    Summary:
    - Always defect first round to avoid being sucker.
    - Always defect last round to maximize final payoff (no future incentive).
    - In intermediate rounds, never cooperate first.
      Exploit any consistent cooperators by defecting to free ride.
    - Retaliate defectors by persistent defection; no forgiveness.
    - Uses history to detect consistent cooperators and exploits them.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        prev_round_index = t - 1
        if prev_round_index < 0:
            return Action.D
        opponent_coop_last = sum(history.opponent_actions[prev_round_index])
        self_coop_last = history.my_actions[prev_round_index]
        coop_last = opponent_coop_last + (1 if self_coop_last else 0)
        rounds_so_far = t
        coop_counts_opponents = history.opponent_actions[:rounds_so_far].sum(axis=0)
        coop_threshold = 0.7 * rounds_so_far
        consistent_cooperators = []
        for idx_opponent, coop_count in enumerate(coop_counts_opponents):
            if coop_count >= coop_threshold:
                consistent_cooperators.append(idx_opponent)
        if len(consistent_cooperators) >= 1:
            return Action.D
        if coop_last <= self.n / 2:
            return Action.D
        if coop_last > self.n / 2:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game.

    Always defects to maximize immediate and total payoffs.
    Never cooperates, punishes cooperators by free-riding on their contributions,
    and exploits the public goods payoff structure.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    Aggressive Defector strategy for the N-Player Public Goods Game.

    Always defects:
    - Defects on first round with no history.
    - Defects on last round to maximize immediate payoff.
    - Defects whenever possible to exploit cooperators.
    - Never cooperates first or forgives cooperation.
    - Checks history but always defects regardless.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        r = self.game_description.n_rounds
        if t == r - 1:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    Defect-Always-Exploit (DAE) strategy for the N-player public goods game.
    Always defects (Action.D) every round regardless of history,
    exploiting any cooperating opponents without reciprocation or trust-building.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    Aggressive Always-Defect strategy for the N-Player Public Goods Game.

    Summary:
    - Always defect every round.
    - Exploit any cooperators by never cooperating.
    - No forgiveness or reciprocity.
    - Defect unconditionally in first, intermediate, and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Aggressive Strategy: Exploitative Defector with Opportunistic Punishment

    This strategy aggressively defects every round to maximize personal payoff.
    It exploits any cooperation by others, and punishes unanimous cooperation clusters 
    by defecting to destabilize them. It never cooperates, including last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_num = 1 if history is None else history.round_number + 1
        if round_num == 1:
            return Action.D
        if round_num == self.r:
            return Action.D
        last_opponent_actions = history.opponent_actions[history.round_number - 1]
        cooperators_others = sum(last_opponent_actions)
        self_last_action = history.my_actions[history.round_number - 1]
        total_cooperators = cooperators_others + (1 if self_last_action else 0)
        n_others = self.n - 1
        if cooperators_others == 0:
            return Action.D
        if cooperators_others == n_others:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    Aggressive strategy for the N-Player repeated Public Goods Game.
    - Defects on first and last rounds.
    - In intermediate rounds, cooperates only if expected payoff from cooperating
      (based on frequent cooperators > threshold) exceeds defection payoff.
    - Punishes any player who cooperated last round but has low cooperation frequency.
    - Prioritizes maximizing immediate gain and exploiting cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.theta = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n = self.n
        r = self.r
        k = self.k
        theta = self.theta
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        rounds_played = t - 1
        if rounds_played == 0:
            return Action.D
        player_index = 0
        full_actions = []
        for rnd in range(rounds_played):
            actions_round = [False] * n
            actions_round[player_index] = history.my_actions[rnd]
            opps = history.opponent_actions[rnd]
            idx = 0
            for p in range(n):
                if p == player_index:
                    continue
                actions_round[p] = opps[idx]
                idx += 1
            full_actions.append(actions_round)
        coop_counts = [0] * n
        for round_actions in full_actions:
            for j, act in enumerate(round_actions):
                if act:
                    coop_counts[j] += 1
        freq_coop = [coop_counts[j] / rounds_played for j in range(n)]
        frequent_cooperators = [j for j in range(n) if j != player_index and freq_coop[j] > theta]
        E_c = len(frequent_cooperators)
        last_round = full_actions[-1]
        rare_cooperators_last = [j for j in range(n) if j != player_index and last_round[j] and (freq_coop[j] <= theta)]
        if rare_cooperators_last:
            return Action.D
        if E_c == 0:
            return Action.D
        if t == 2:
            return Action.D
        pi_cooperate = k / n * (E_c + 1)
        pi_defect = 1 + k / n * E_c
        if pi_cooperate > pi_defect:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Aggressive Strategy: "Defect Until Dominated"

    - Round 1: Always defect (D)
    - Rounds 2 to r-1: 
        If previous round total cooperation (including self) ≤ 1 and strategy hasn't cooperated before,
        cooperate (C) once as a test to spark cooperation.
        Otherwise, defect (D).
    - Round r: Always defect (D)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.D
        round_number = history.round_number
        current_round = round_number + 1
        if current_round == r:
            return Action.D
        prev_round_idx = round_number - 1
        if prev_round_idx < 0:
            return Action.D
        prev_opponent_coop = history.opponent_actions[prev_round_idx].sum()
        prev_self_coop = history.my_actions[prev_round_idx].item()
        prev_total_coop = prev_opponent_coop + (1 if prev_self_coop else 0)
        if prev_total_coop <= 1:
            if True in history.my_actions:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Exploit-Then-Explode (ETE) strategy for N-Player Public Goods Game.
    
    Cooperate only on the first round (to probe/coax cooperation),
    then defect relentlessly for all subsequent rounds, including the last.
    No reciprocity, no forgiveness: pure exploitation of early cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        return Action.D

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    Aggressive Strategy: Defect Until Threatened, Then Exploit
    
    - Always start defecting.
    - In round 2, if any cooperators appeared in round 1, cooperate once as a probe.
    - If persistent cooperation detected (cooperators in last two rounds), defect to exploit.
    - Otherwise, keep defecting.
    - Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        last_round_actions = history.opponent_actions[t - 1]
        n_opponents = last_round_actions.shape[0]
        n_players = n_opponents + 1
        my_last_action = history.my_actions[t - 1]
        opp_cooperators_last = last_round_actions.sum()
        total_cooperators_last = opp_cooperators_last + (1 if my_last_action else 0)
        if t == r:
            return Action.D
        if total_cooperators_last == 0:
            return Action.D
        if t > 2:
            two_rounds_ago = history.opponent_actions[t - 2]
            my_two_rounds_ago = history.my_actions[t - 2]
            opp_cooperators_two_ago = two_rounds_ago.sum()
            total_cooperators_two_ago = opp_cooperators_two_ago + (1 if my_two_rounds_ago else 0)
            if total_cooperators_two_ago > 0 and total_cooperators_last > 0:
                return Action.D
            else:
                return Action.D
        elif total_cooperators_last > 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Aggressive Exploiter for N-Player Public Goods Game.

    Always defects to maximize individual payoff by free-riding on cooperators.
    Does not cooperate in any round: first, intermediate, or last.
    Exploits cooperation in the group but never contributes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    Aggressive Exploiter strategy for the N-Player Public Goods Game.

    Summary:
    - Round 1: Defect (D) to start aggressively and observe others.
    - Middle rounds: 
        - If previously cooperated:
            - Punish if exploited (others earned strictly more).
            - Otherwise cooperate only if majority cooperated last round, else defect.
        - If previously defected:
            - Continue defecting if many cooperated last round (exploit).
            - Else if few cooperated, cooperate once to bait.
            - Otherwise defect.
    - Last round: Always defect.
    """

    def __init__(self, game_description):
        self.game_description = game_description

    def __call__(self, history):
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        t = history.round_number + 1 if history is not None else 1
        if t == r:
            return Action.D
        if history is None or history.round_number == 0:
            return Action.D
        last_round_idx = history.round_number - 1
        c_i_prev = history.my_actions[last_round_idx]
        opp_actions_last = history.opponent_actions[last_round_idx]
        opp_payoffs_last = history.opponent_payoffs[last_round_idx]
        our_payoff = history.my_payoffs[last_round_idx]
        total_cooperators_prev = (1 if c_i_prev else 0) + sum(opp_actions_last)
        max_payoff = our_payoff
        if len(opp_payoffs_last) > 0:
            max_payoff = max(max_payoff, max(opp_payoffs_last))
        if c_i_prev:
            exploited = max_payoff > our_payoff
            if exploited:
                return Action.D
            elif total_cooperators_prev > n / 2:
                return Action.C
            else:
                return Action.D
        elif total_cooperators_prev > n / 2:
            return Action.D
        elif total_cooperators_prev < n / 4:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Aggressive strategy for N-Player Public Goods Game:
    Always defect in every round to maximize immediate payoff by free-riding on cooperators.
    No cooperation, no forgiveness, no conditional behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    Aggressive Strategy for the N-Player Public Goods Game.

    Always defects every round. It starts defecting immediately,
    never cooperates, and exploits any cooperation by others by defecting.
    In particular:
    - Round 1: Defect
    - Middle rounds: Defect regardless, exploiting cooperation if any
    - Last round: Defect (no future punishment possible)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.theta = 0.8
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        if history.round_number == 0:
            return Action.D
        last_opponent_actions = history.opponent_actions[history.round_number - 1]
        last_self_action = history.my_actions[history.round_number - 1]
        total_cooperators = last_opponent_actions.sum() + (1 if last_self_action else 0)
        coop_fraction = total_cooperators / self.n
        return Action.D

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    Dominant Defector with Occasional Exploitation Probe for repeated N-player Public Goods Game.

    - Always defects.
    - Never cooperates.
    - Exploits any cooperation by others by defecting while they cooperate.
    - Defects unconditionally in first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_t = history.round_number
        current_round = round_t + 1
        if current_round == 1:
            return Action.D
        if current_round == self.r:
            return Action.D
        if round_t == 0:
            return Action.D
        last_opponent_actions = history.opponent_actions[round_t - 1]
        if last_opponent_actions.any():
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Exploit and Punish Aggressor strategy for repeated public goods game.

    Summary:
    - Round 1: Defect immediately.
    - Last round: Defect immediately.
    - Intermediate rounds:
        * Compute average cooperation frequency of other players so far.
        * If avgCoopFreq > 0.6: exploit by mostly defecting but cooperate with 0.3 probability
          to confuse and maintain their cooperation.
        * Otherwise defect aggressively.
    """

    def __init__(self, game_description):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.theta = 0.6
        self.p = 0.3

    def __call__(self, history):
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        if current_round == 1:
            return Action.D
        coopFreqs = []
        for opp_idx in range(self.n - 1):
            coop_count = 0
            coop_count = history.opponent_actions[:t, opp_idx].sum()
            coopFreq = coop_count / t
            coopFreqs.append(coopFreq)
        if coopFreqs:
            avgCoopFreq = sum(coopFreqs) / len(coopFreqs)
        else:
            avgCoopFreq = 0.0
        if avgCoopFreq > self.theta:
            return Action.C if random.random() < self.p else Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Aggressive pure defection strategy for N-Player Public Goods Game.

    Always defects every round to maximize own payoff by exploiting any cooperators.
    Does not cooperate on first, intermediate, or last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        r = self.game_description.n_rounds
        return Action.D

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Aggressive Exploitative Defector with Conditional Retaliation for N-player Public Goods Game.

    Behavior summary:
    - Round 1: Defect (no info, avoid loss).
    - Middle rounds:
        - If cooperated last round and was in minority (exploited), defect to punish.
        - Else if majority cooperated last round, cooperate to exploit shared benefits.
        - Otherwise defect.
    - Last round: always defect (no future punishment).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        own_last_action_coop = history.my_actions[t - 2]
        prev_opponent_actions = history.opponent_actions[t - 2]
        prev_num_opponent_coop = prev_opponent_actions.sum()
        prev_num_coop = prev_num_opponent_coop + (1 if own_last_action_coop else 0)
        exploited_threshold = self.n / 3
        majority_threshold = self.n / 2
        if own_last_action_coop:
            if prev_num_coop < exploited_threshold:
                return Action.D
        if prev_num_coop > majority_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game:
    - Round 1: Cooperate to probe for cooperation signals.
    - Rounds 2 to r-1: Always defect, exploiting any majority cooperation detected in the previous round.
    - Round r (last round): Always defect, as no future retaliation is possible.
    This strategy never returns to cooperation after round 1.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round_index = t - 2
        my_coop = 1 if history.my_actions[prev_round_index] else 0
        opponents_coop = sum(history.opponent_actions[prev_round_index])
        coop_count = my_coop + opponents_coop
        return Action.D

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Aggressive strategy for N-player repeated public goods game.
    - First round: defect.
    - Last round: defect.
    - Intermediate rounds: defect always, exploiting any cooperating opponents.
    - Optional probe cooperation omitted for pure aggressive defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if t == r:
            return Action.D
        prev_round = t - 1
        C_opp = sum(history.opponent_actions[prev_round])
        return Action.D

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    Aggressive Strategy: "Dominant Defector with Opportunistic Exploitation"
    
    Summary:
    - Always defect every round.
    - Defect in first round due to no history to trust.
    - Defect in intermediate rounds because defecting always yields strictly higher immediate payoff than cooperating, no matter others' cooperation.
    - Defect in last round to maximize terminal payoff without fear of retaliation.
    - Does not reciprocate cooperation; free-rides on others' cooperation if it occurs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    Aggressive "Exploit-First, Defect-Always" strategy for the repeated multiplayer
    public goods game.
    Always defects regardless of history or round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Aggressive strategy for the N-player Public Goods Game:
    Always defect in every round. 
    No cooperation or conditional behavior.
    Maximizes immediate payoff, exploits cooperators, and punishes cooperation attempts.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    Aggressive Defector with Opportunistic Tit-for-Tat Exploitation (AD-OTF).

    Default is defection to maximize private payoff and exploit cooperators.
    Cooperates only opportunistically if behind in payoff and majority cooperated last round,
    to lure cooperation and improve relative payoff.
    Never cooperates first or last round.
    Unforgiving and aggressive strategy exploiting full history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        if t + 1 == self.r:
            return Action.D
        last_round_idx = t - 1
        self_last_action = history.my_actions[last_round_idx]
        num_cooperators_opponents = history.opponent_actions[last_round_idx].sum()
        coop_count_last_round = int(num_cooperators_opponents) + (1 if self_last_action else 0)
        if coop_count_last_round > self.n / 2:
            majority_cooperated = True
        else:
            majority_cooperated = False
        own_payoff = history.my_payoffs[:t].sum()
        opponents_cum_payoffs = history.opponent_payoffs[:t].sum(axis=0)
        average_payoff_opponents = opponents_cum_payoffs.mean()
        if not majority_cooperated:
            return Action.D
        if self_last_action:
            return Action.D
        elif own_payoff < average_payoff_opponents:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    Aggressive strategy for the N-Player Public Goods Game.
    Always defects in every round regardless of history or opponents' actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    Dominant Defector with Targeted Punishment:
    Always defect (Action.D) every round to maximize private payoff by exploiting cooperators
    and punishing any attempts at cooperation. No cooperation ever given to avoid being exploited.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    Aggressive Exploiter with Grim Trigger Variant for N-Player Public Goods Game.

    Strategy summary:
    - Always defect.
    - Round 1: defect immediately.
    - If any defection ever observed in past rounds: defect forever (grim trigger).
    - Last round: defect unconditionally.
    - Never cooperate to exploit cooperators, punish defectors harshly.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        r = self.n_rounds
        if t == r:
            return Action.D
        any_defection = False
        if not all(history.my_actions):
            any_defection = True
        elif not history.opponent_actions.all():
            any_defection = True
        return Action.D

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    Dominant Defector strategy for N-player Public Goods game.

    Always defects. Exploits any cooperation by opponents by defecting.
    Never cooperates, never initiates cooperation, never cooperates on last round.
    Uses history only to detect opponent cooperation but always defects regardless.

    Summary:
    - Round 1: Defect (no trust)
    - Rounds 2 to r-1: Defect (exploit if others cooperated last round)
    - Last round: Defect (no incentive to cooperate)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        last_round_idx = current_round - 2
        opponents_cooperators = sum(history.opponent_actions[last_round_idx])
        if opponents_cooperators >= 1:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game.
    
    Always defects in every round, including the first and last.
    Defection is strictly payoff-maximizing given 1 < k < n,
    since defecting keeps the private endowment plus shares of cooperators,
    and cooperating never strictly improves payoff for the player.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory):
        return Action.D

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Aggressive Strategy for the N-Player Public Goods Game.

    Always defects every round to maximize own payoff by exploiting
    cooperators and refusing any cooperation. In particular:
      - First round: defect
      - Last round: defect
      - All other rounds: defect regardless of opponents' behavior

    This strategy never cooperates, never forgives, and never punishes 
    cooperators except by exploiting them via defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        r = self.game.n_rounds
        n = self.game.n_players
        if t == r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Defect-or-Exploit strategy for N-Player Public Goods game.
    
    Summary:
    - Always defects in the first and last rounds.
    - For middle rounds, cooperates if cooperating yields at least as high a payoff as defecting,
      based on the number of cooperators in the previous round.
    - Otherwise defects to maximize individual payoff, exploiting cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        opp_coop_count = 0
        if history.opponent_actions.size > 0:
            opp_coop_count = history.opponent_actions[prev_round_idx].sum()
        self_prev_coop = int(history.my_actions[prev_round_idx])
        C_prev = opp_coop_count + self_prev_coop
        payoff_if_cooperate = self.k / self.n * (C_prev + 1)
        payoff_if_defect = 1 + self.k / self.n * C_prev
        if payoff_if_cooperate >= payoff_if_defect:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game.
    - Always defect first round.
    - Mostly defect subsequently, occasionally cooperate (15%) if moderate cooperation last round.
    - Exploit full cooperation by defecting next round.
    - Defect last round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n = self.n
        r = self.r
        if t == 1:
            return Action.D
        prev_round_idx = t - 2
        own_prev_action = history.my_actions[prev_round_idx]
        opp_prev_actions = history.opponent_actions[prev_round_idx] if self.n > 1 else []
        coop_count_prev = int(own_prev_action) + (opp_prev_actions.sum() if len(opp_prev_actions) > 0 else 0)
        if t == r:
            return Action.D
        if coop_count_prev <= 1:
            return Action.D
        if coop_count_prev == n:
            return Action.D
        if random.random() < 0.15:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    Exploit-and-Punish Aggressor for the N-player Public Goods game.
    
    Summary:
    - Always defect early rounds to maximize private payoff.
    - Exploit any cooperators by continuing to defect.
    - Retaliation is implicit: never cooperate with cooperators.
    - Aggressively defect in the penultimate round (if exists).
    - Only cooperate in the last round if cooperating yields at least
      as much payoff as defecting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        last_round_opponent = history.opponent_actions[t - 1]
        M = last_round_opponent.sum(dtype=int)
        payoff_cooperate = k / n * (M + 1)
        payoff_defect = 1 + k / n * M
        if r >= 3:
            if t == r - 1:
                return Action.D
            elif t == r:
                if payoff_cooperate >= payoff_defect:
                    return Action.C
                else:
                    return Action.D
        elif t == r:
            if payoff_cooperate >= payoff_defect:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Aggressive Strategy for the N-Player Public Goods Game.

    Always defects to exploit any cooperation from others.  
    - Round 1: defect (no info yet).  
    - Rounds 2 to r-1: defect if anyone cooperated last round, else defect.  
    - Last round: defect unconditionally (no future retaliation).  
    Never cooperates, never forgives, never wastes contribution.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_round_idx = history.round_number - 1
        total_cooperators = history.opponent_actions[last_round_idx].sum()
        return Action.D

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    Aggressive Strategy for N-Player Public Goods Game:
    - Always defects.
    - Uses history only to confirm others' cooperation attempts.
    - Exploits cooperators by defecting after they cooperate.
    - Never cooperates to avoid giving away endowment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        last_round = history.round_number - 1
        my_last = history.my_actions[last_round]
        opponents_cooperators = history.opponent_actions[last_round].sum()
        total_cooperators_last = int(my_last) + opponents_cooperators
        others_cooperate_prev = total_cooperators_last - int(my_last)
        return Action.D

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    Aggressive strategy for the N-player repeated Public Goods Game.
    Always defects to exploit cooperative opponents.
    Defects in first round (no history), in final round (backward induction),
    and in all intermediate rounds regardless of cooperation level.
    This exploits cooperators and avoids cooperation costs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.k = self.game.k
        self.threshold_high_coop = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        current_round = 1 if history is None else history.round_number + 1
        if current_round == self.r:
            return Action.D
        if current_round == 1:
            return Action.D
        last_round_index = current_round - 2
        if history is not None:
            coop_others = sum(history.opponent_actions[last_round_index])
            coop_fraction = coop_others / (self.n - 1)
        else:
            coop_fraction = 0.0
        return Action.D

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    Aggressive strategy for N-Player Repeated Public Goods Game.

    - Always defect (Action.D).
    - Never cooperate.
    - Punish any cooperation seen from opponents by continuing to defect.
    - Exploit cooperators by free-riding every round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        if history.opponent_actions.any():
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    Aggressive Defector strategy for N-Player Public Goods Game.
    Defects always except for a single cooperation probe at midgame.
    Exploits any cooperating opponents by defecting when they cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            round_number = 1
        else:
            round_number = history.round_number + 1
        if round_number == 1:
            return Action.D
        if round_number == self.r:
            return Action.D
        mid_round = (self.r + 1) // 2
        if round_number == mid_round:
            return Action.C
        if history is not None and history.round_number > 0:
            last_opponent_actions = history.opponent_actions[history.round_number - 1]
            coop_in_prev_round = last_opponent_actions.sum()
            if coop_in_prev_round > 0:
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    Aggressive strategy for the repeated N-player Public Goods Game.

    Summary:
    - Always defects (D), including in the first and last rounds.
    - Never cooperates first or cooperates at all.
    - Exploits any cooperating opponents by defecting to maximize payoff.
    - Uses history only to confirm that no cooperation is needed, but in practice,
      decision is always defect regardless of opponents' actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Aggressive Exploiter for N-Player Public Goods Game.

    - Round 1: Cooperate to probe for cooperators.
    - Rounds 2 to r-1:
        * Defect if any opponent cooperated last round (exploit).
        * Otherwise defect with 90% prob, cooperate with 10% prob to probe.
    - Last round: Always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[t - 1]
        coop_others = sum(last_round_opponent_actions)
        if coop_others > 0:
            return Action.D
        if random.random() < 0.1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    Firm Conditional Cooperation Strategy for the repeated N-Player Public Goods Game.

    Summary:
    - Round 1: Cooperate unconditionally to signal willingness to cooperate.
    - Rounds 2 to r-1:
        * Cooperate if everyone cooperated last round.
        * Cooperate if majority cooperated last round and you cooperated.
        * Otherwise, defect.
    - Last round (round r): defect unconditionally.

    This strategy balances cooperation promotion with forgiveness and punishment,
    supporting stable cooperation while preventing exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        if t == 0:
            return Action.C
        last_round_actions_opponents = history.opponent_actions[t - 1]
        my_last_action = history.my_actions[t - 1]
        coop_count = 0
        if my_last_action:
            coop_count += 1
        coop_count += sum(last_round_actions_opponents)
        majority = (self.n + 1) // 2
        if coop_count == self.n:
            return Action.C
        if coop_count >= majority and my_last_action:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    Aggressive strategy for the N-Player Public Goods Game.
    - Starts by defecting to avoid giving free benefits.
    - Tracks "punished" players implicitly by always defecting.
    - In rounds 2 to r-1:
      * Defects to exploit any cooperators at or above defection_threshold.
      * Defects if cooperators are below threshold.
      * Only cooperates if ALL players cooperated in the previous round to avoid mutual mass defection.
    - Last round defects unconditionally (backward induction).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        x = self.n / self.k
        if x == int(x):
            self.defection_threshold = int(x)
        else:
            self.defection_threshold = int(x) + 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_actions = history.opponent_actions[t - 2]
        coop_last = 0
        coop_last_players = 0
        coop_count = 0
        if history.my_actions[t - 2]:
            coop_count += 1
        coop_count += sum(prev_actions)
        if coop_count == self.n:
            return Action.C
        if coop_count >= self.defection_threshold:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    Aggressive N-Player Public Goods Game strategy "Defect-First Exploit":
    - Round 1: Defect always.
    - Intermediate rounds (2 <= t < r): Cooperate only if majority cooperated last round
      AND this player's last payoff < 1.0, else defect.
    - Last round: Defect always.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        last_round_idx = t - 2
        total_cooperators = 0
        total_cooperators += int(history.my_actions[last_round_idx])
        total_cooperators += history.opponent_actions[last_round_idx].sum()
        majority = (self.n + 1) // 2
        my_last_payoff = history.my_payoffs[last_round_idx]
        if total_cooperators >= majority and my_last_payoff < 1.0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Aggressive "Exploitative Defector with Opportunistic Cooperation" strategy for N-player Public Goods Game.
    
    Summary:
    - Round 1: Always defect.
    - Rounds 2 to r-1: Cooperate only if at least half of the other players cooperated in the previous round, else defect.
    - Round r (last round): Always defect.
    
    This exploits cooperators by defecting mostly, but opportunistically cooperates 
    when a majority cooperated last round to gain from the public good.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.coop_threshold = (self.n + 1) // 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        if t == self.r - 1:
            return Action.D
        if t >= 1:
            last_round_cooperators = 0
            if self.n > 1:
                last_round_cooperators = history.opponent_actions[t - 1].sum()
            if last_round_cooperators >= self.coop_threshold:
                return Action.C
            else:
                return Action.D
        return Action.D