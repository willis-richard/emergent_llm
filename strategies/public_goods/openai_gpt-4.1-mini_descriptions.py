"""
Strategy descriptions for PublicGoodsDescription.

Generated with:
- Provider: OpenAI
- Model: gpt-4.1-mini
"""


description_COOPERATIVE_1 = '''
Here is a cooperative, conditional strategy for the repeated N-Player Public Goods Game tailored to encourage cooperation, punish defections, and attempt to sustain cooperation until near the end. It is inspired by the logic of generalizations of tit-for-tat and generous strategies adapted to the multi-player public goods context.

---

## Strategy: Conditional Cooperation with Forgiveness and Endgame Defection

### 1. Intuition

- **First round:** Cooperate to signal willingness to cooperate.
- **Subsequent rounds:** Cooperate if most players cooperated last round (signal of cooperation).
- **Punish defections:** If insufficient cooperation was observed last round, defect to discourage free-riding.
- **Forgive occasional defections:** Once cooperation resumes, return to cooperate.
- **Endgame (final round):** Defect to avoid being exploited, since no future retaliation is possible.

---

### 2. Decision Rules in Detail

#### Key variables per round \( t \):

- \( c^t_j \) = action of player \( j \) at round \( t \) (1 if Cooperate, 0 if Defect)
- \( \text{coopCount}^{t} = \sum_{j=1}^n c^t_j \)
- \( \text{coopThreshold} = \lceil \alpha \times n \rceil \), where \( \alpha \in (0.5, 1) \) is a cooperation threshold (e.g., 0.7)
- \( r \) = total rounds
- \( t \in \{1, \dots, r\} \)

#### Behavioral logic:

- **Round 1:**  
  Cooperate (C) to establish cooperation baseline.

- **Rounds 2 to \( r-1 \):**  
  - If in previous round \( t-1 \), number of cooperators \( \geq \) coopThreshold:  
    Cooperate this round.  
  - Else (too few cooperators last round):  
    Defect this round to punish free-riding.
- **Round r (last round):**  
  Defect (D), since cooperation cannot be enforced and defection maximizes short-term payoff.

---

### 3. Explanation and Advantages

- The threshold \(\alpha\) (> 0.5) means you expect a majority of players to cooperate for you to cooperate.
- This avoids "unconditional cooperation," which can be exploited by defectors.
- Punishing only when cooperation falls below a threshold focuses retaliation proportionally.
- Forgiveness: willing to resume cooperation as soon as others do.
- Last round defection prevents exploitation and follows standard backward induction logic.
- Does not require coordination beyond shared history of actions.
- Maintains a cooperative mindset but is robust against widespread defection.

---

### 4. Pseudocode

```python
# Parameters:
alpha = 0.7  # cooperation threshold

def decide_action(round_t, history):
    # history is a list of rounds, each round is a list of actions (1=C, 0=D) by all players
    # n is number of players
    n = len(history[0]) if history else n_known_from_game
    
    coopThreshold = int(alpha * n) if alpha * n == int(alpha * n) else int(alpha * n) + 1
    
    if round_t == 1:
        return 'C'  # Cooperate first round
    
    elif round_t == r:
        return 'D'  # Defect last round
    
    else:
        prev_round = history[round_t - 2]  # 0-indexed; previous round actions
        coopCount = sum(prev_round)
        if coopCount >= coopThreshold:
            return 'C'
        else:
            return 'D'
```

---

### 5. Edge Cases

- If some players permanently defect, this strategy will punish by defecting but tries to resume cooperation when a majority cooperate again.
- If \(\alpha\) is chosen too high (near 1), cooperation may be fragile; too low (near 0.5), more tolerant but less punitive. 0.7 is a balanced suggestion.
- In very small groups (e.g., n=2), threshold can be adjusted to simple majority (1 out of 2).
- If all players defect on the first round, this strategy defects thereafter, consistently punishing defection.
- If all cooperate indefinitely (except last round), this strategy cooperates accordingly, maximizing payoffs.

---

# Summary

| Round       | Condition                              | Action          |
|-------------|--------------------------------------|-----------------|
| 1           | Always                              | Cooperate (C)   |
| 2 to r-1    | Previous round cooperators ≥ threshold | Cooperate (C)   |
| 2 to r-1    | Otherwise                           | Defect (D)      |
| r (last)    | Always                              | Defect (D)      |

---

This strategy embodies a cooperative mindset by initiating and reciprocating cooperation, punishing defection proportionally, forgiving to allow return to cooperation, and securing payoff in the last round. It is robust to various opponent behaviours given only observable actions and common knowledge.
'''

description_COOPERATIVE_2 = '''
Here is a cooperative strategy for the described N-Player Public Goods Game that balances cooperation with conditional punishment to support cooperation emerging and stabilizing over repeated rounds.

---

# Cooperative Strategy: "Grim Trigger with Forgiveness"

**High-level idea:**  
Start by cooperating. Continue to cooperate as long as every other player has cooperated in all previous rounds. Once a defection is observed from any other player, defect for a limited number of rounds (punishment period) and then attempt to return to cooperation (forgiveness). This encourages mutual cooperation but also punishes free-riding to maintain stable cooperation.

---

## Decision Rules

Let:

- `history[t][j]` be the action of player `j` in round `t` (C or D),
- `i` be your player index,
- `r` the total number of rounds,
- `T` the current round number (1-based).

### Initialization

- In round 1 (T=1), **cooperate** (play C).

### Subsequent rounds (T > 1)

1. **Check the history of all opponents (players `j ≠ i`)** up to round `T-1`.

2. If **all opponents cooperated in every previous round**, then **cooperate** in round `T`.

3. If there exists **at least one defection by any opponent in the past**, then

    a. If currently in a punishment phase (count rounds since last observed defection < `punishment_length`), **defect**.

    b. Else, attempt forgiveness by **cooperating**.

4. Enforce a maximum punishment length (`punishment_length`) to avoid endless defection after a single defection, facilitating return to cooperation.

### Last round (T = r)

- Defect, as no future punishment is possible (endgame effect).

---

## Parameters

- `punishment_length`: number of rounds to defect after detecting defection (e.g., 2 or 3 rounds; a small finite number to balance deterrence and forgiveness).

---

## Pseudocode

```python
# Inputs:
# T: current round (1-based)
# r: total rounds
# n: number of players
# i: your player index
# history: past actions, a 2D array/list of size (T-1) x n

punishment_length = 2

def strategy(T, r, n, i, history):
    if T == 1:
        # First round: cooperate
        return 'C'

    if T == r:
        # Last round: defect (no future retaliation incentive)
        return 'D'

    # Check if any opponent defected in the past
    defect_rounds = []
    for t in range(T-1):
        for j in range(n):
            if j == i:
                continue
            if history[t][j] == 'D':
                defect_rounds.append(t + 1)  # rounds are 1-based

    if not defect_rounds:
        # No defection observed so far: cooperate
        return 'C'

    # Last defection round observed
    last_defect_round = max(defect_rounds)
    rounds_since_last_defect = T - last_defect_round

    if rounds_since_last_defect <= punishment_length:
        # Within punishment window: defect to punish defectors
        return 'D'
    else:
        # Punishment finished: try to forgive and cooperate again
        return 'C'
```

---

## Explanation

- **First round cooperation:** sets an initial signal that you prefer cooperation.
- **Conditional cooperation:** continue cooperating as long as no defection observed.
- **Punishment period:** when defection observed, defect for a short punishment phase to discourage defectors.
- **Forgiveness:** after punishment, return to cooperation to allow recovery of mutual cooperation.
- **Last round defection:** rationally defect because no future retaliation is possible (endgame effect).
  
---

## Rationale and Cooperative Mindset

- This strategy aligns with cooperation because it starts with cooperation and rewards mutual cooperation with continued cooperation.
- It punishes free riders to maintain fairness and disincentivize defection.
- Forgiveness allows the group to recover cooperation after a mistake or single defection.
- The finite punishment length prevents endless spirals of defection which harm all players.
- The last round defection is a necessary evil driven by backward induction but does not undermine cooperation in previous rounds.
- This strategy respects the game's public information and no-communication constraints, responding only to observed defections.

---

This strategy harnesses **conditional cooperation with a forgiving grim trigger**, a well-known approach effective in repeated public goods settings to sustain cooperation in a noisy, decentralized environment.
'''

description_COOPERATIVE_3 = '''
Here is a fully cooperative strategy tailored for the repeated N-player Public Goods Game as specified. The goal is to maximize collective payoff through sustained cooperation while having an effective mechanism to punish defections moderately and to try to restore cooperation when possible.

---

## Cooperative Strategy: **"Forgiving Conditional Cooperation with Endgame Adjustment"**

### Intuition
- Start by cooperating unconditionally to establish mutual trust.
- Continue cooperating as long as every other player cooperates.
- If any player defects, punish by defecting for a limited number of rounds proportional to the defection observed.
- After punishment phase, attempt immediate forgiveness by reverting to cooperation.
- In the last round, defect to avoid being exploited since no future retaliation is possible (standard endgame defection).
- This approach aligns with classic conditional cooperation strategies (e.g., Grim Trigger or Tit-for-Tat variants), but includes forgiveness and explicitly accounts for multiple players.

---

### Notation
- `t`: current round (1 ≤ t ≤ r)
- `history[t'][i]`: action of player i in round t' (C or D)
- `defection_detected`: boolean flag, true if any player defected in recent round(s)
- `punishment_counter`: counts how many rounds to punish due to defection
- `punishment_duration`: fixed or proportional length of punishment phase
- `last_round = r`

---

### Strategy Description

**Initialization:**
- At the start (`t = 1`), cooperate.

**At each subsequent round (2 ≤ t < r):**
1. **Check history for defections in previous round (`t-1`):**  
   If *all other players cooperated* in round `t-1`, then cooperate this round.

2. **If any defection detected in previous round:**
   - Enter punishment phase by defecting for `punishment_duration` rounds.
   - `punishment_duration` can be set to 1, or a function of how many defected (e.g., 1 round punishment per defector).
   - Decrement `punishment_counter` each round.
   - After punishment ends (`punishment_counter == 0`), revert to cooperation.

3. **Forgiveness and reset:**
   - After each punishment phase, regardless of what others do, cooperate next round to signal forgiveness and encourage return to cooperation.
   - This avoids endless mutual punishment cycles.

**Endgame adjustment (round `t = r`):**
- Defect to avoid being exploited since no future punishment is possible (standard backwards induction logic).

---

### Pseudocode

```python
# Parameters:
punishment_duration_per_defection = 1  # e.g., 1 round punishment per defector detected

# State variables initialized outside rounds
punishment_counter = 0  # rounds left to punish

for t in 1 to r:

    if t == 1:
        # 1st round: cooperate unconditionally
        action = C

    elif t == r:
        # Last round: defect (no future retaliation possible)
        action = D

    else:
        if punishment_counter > 0:
            # Currently punishing: keep defecting
            action = D
            punishment_counter -= 1

        else:
            # Check previous round for defections by others
            prev_round_actions = history[t-1]
            defectors = [j for j in players if j != self and prev_round_actions[j] == D]

            if len(defectors) == 0:
                # Everyone cooperated last round: cooperate
                action = C
            else:
                # Defection detected: enter punishment
                punishment_counter = len(defectors) * punishment_duration_per_defection - 1
                       # Subtract 1 because will defect this round
                action = D

```

---

### Strategy Characteristics

- **Cooperative:** Begins cooperating and attempts to sustain full cooperation indefinitely.
- **Reciprocal:** Punishes defections but only temporarily, proportional to defection severity.
- **Forgiving:** After punishment, tries cooperation immediately, giving others a chance to return.
- **Endgame-aware:** Defects in the final round to prevent exploitation due to lack of future punishment incentives.
- **Robust:** Responds only to observed defections, does not rely on unobservable assumptions or communication.
- **Simple & Transparent:** Uses only past rounds' public information, enabling any opponent strategy to potentially detect and respond similarly.

---

### Why this strategy?

- The fully cooperative equilibrium (everyone cooperates every round) yields the high payoff of `(k)` per round (as example shows all C yields payoff > 1). Mutual cooperation is best.
- However, unilateral defection is tempting each round (grants 1 immediate private payoff plus share from contributions).
- Punishment ensures defectors learn defecting reduces payoffs for some rounds.
- Forgiveness avoids permanent breakdown from one-off errors or noise.
- The endgame defection is needed under standard backward induction reasoning for finitely repeated games.

---

This strategy, while simple, is a classic and effective approach for sustaining cooperation in repeated public goods or Prisoner's Dilemma-like settings with multiple players. It balances cooperation and credible deterrence with forgiveness and pragmatism.
'''

description_COOPERATIVE_4 = '''
Below is a well-founded cooperative strategy suitable for the repeated N-player Public Goods Game as specified.

---

## Strategy Name: **Gradual Reciprocity Cooperation**

### Intuition
The strategy aims to foster cooperation through mutual reciprocity, starting cooperatively and then adjusting behavior based on observed group cooperation. It punishes defection gradually to avoid overreacting to accidental defections, preserves cooperation as long as other players mostly cooperate, and attempts to repair cooperation over time. In the last round, because cooperation no longer yields future rewards, it anticipates rational defection but attempts a "last-ditch" cooperation if cooperation is still high, hoping for mutual gain.

---

### Decision Rules

- **Round 1 (First Round):**  
  Cooperate.  
  *Rationale*: Without history, signal willingness to cooperate.

- **Rounds t = 2 to r-1 (Intermediate Rounds):**  

  1. Calculate the **cooperation ratio** in the previous round: fraction of players who cooperated in round t-1,  
     \[
     CR_{t-1} = \frac{\sum_{j=1}^n c_{j, t-1}}{n}
     \]

  2. Maintain a **trust score** or **cooperation level**, initialized as 1 after round 1, updated each round:

     Update rule:
     \[
     trust_t = \alpha \times CR_{t-1} + (1 - \alpha) \times trust_{t-1}
     \]
     where \(\alpha\) ∈ (0,1] is a smoothing factor to moderate sensitivity to changes (e.g., \(\alpha=0.5\)).

  3. **Decision Thresholds**:
     - Cooperate if \(trust_t \geq \theta\)
     - Defect otherwise
     
     Choose \(\theta \in [0.6, 0.8]\) as a threshold of expected group cooperation to maintain cooperation.
     
  4. Intuition: cooperate if group cooperation has remained sufficiently high recently; otherwise, defect to punish.

- **Round r (Last Round):**

  - If the cooperation level before last round is high (e.g., \(trust_{r-1} \geq 0.8\)), cooperate (hoping for mutual cooperation last round).
  - Else defect (since no future rounds to incentivize cooperation).

---

### Edge Case Handling

- If there is a **sudden drop in cooperation ratio** (e.g., \(CR_t < 0.3\)) in any round, rapidly decay trust by adjusting \(\alpha\) temporarily higher or by directly setting trust to a lower bound (e.g., 0.3). This prevents exploitation by persistent defectors.

- After defecting in one round (due to low trust), at the next round attempt to cooperate if the group cooperation ratio recovers to above threshold, enabling the rebuilding of cooperation.

- If at any point, all players defected in previous round, defect following round as well (since cooperation `< 0.6`).

- This strategy is forgiving and allows cooperation to emerge again after mistakes or occasional defections.

---

### Pseudocode

```python
parameters:
    alpha = 0.5          # smoothing factor
    theta = 0.7          # cooperation threshold
    low_coop_threshold = 0.3

initialize:
    trust = 1.0          # initial trust in others' cooperation

for round t in 1 to r:
    if t == 1:
        action = 'C'     # cooperate first round
    elif t < r:
        # Calculate cooperation ratio of previous round
        CR = (number of cooperators in round t-1) / n
        
        # Adjust trust
        if CR < low_coop_threshold:
            trust = max(trust * 0.5, low_coop_threshold)  # sharp decay
        else:
            trust = alpha * CR + (1 - alpha) * trust    # smooth update
        
        # Decide action
        if trust >= theta:
            action = 'C'
        else:
            action = 'D'
    else:
        # Last round
        if trust >= 0.8:
            action = 'C'   # try to cooperate last round if trust high
        else:
            action = 'D'   # otherwise defect (no future incentive)
```

---

### Summary

- **Promotes cooperation from the start.**
- **Track recent group cooperation via a trust variable.**
- **Cooperate only if trust in group cooperation is sufficiently high.**
- **Punish defection gradually but decisively to prevent exploitation.**
- **Forgive and return to cooperation if cooperation re-emerges.**
- **In final round, behave conditionally: cooperate only if cooperation is high, else defect.**

This approach captures classical insights from repeated public goods and Prisoner's Dilemma literature: cooperate initially, reciprocate cooperation and defection, punish defectors, but be forgiving to allow re-establishment of cooperation.

---

If you want me to provide variations or further details (e.g., parameter tuning, how to handle noisy observations, etc.), just ask!
'''

description_COOPERATIVE_5 = '''
Below is a **cooperative strategy** tailored to the repeated N-Player Public Goods Game that balances cooperation incentives with protection against defection. The goal is to sustain mutual cooperation as long as possible (to maximize group payoff), while still forgiving occasional defections and robustly reacting to persistent free-riding.

---

## Strategy Overview: Forgiving Conditional Cooperation (FCC)

**Core idea:**  
Start by cooperating and keep cooperating as long as others mostly cooperate. If too many defections occur, punish by defecting for a short time, then resume cooperation to give second chances. Gradually escalate punishment if defection persists, but ultimately aim to restore cooperation before the last round.

---

## 1. Decision Rules

Let:

- \( t \in \{1, \ldots, r\} \) be the current round
- \( H_{t-1} \) be the complete observed history of actions of all players up to round \( t-1 \) (empty for \( t=1 \))
- \( c_j^{(s)} \in \{0,1\} \) be player \( j \)'s contribution in round \( s \)
- Define threshold \( T = \) minimum acceptable cooperation ratio among others (e.g., 0.7)
- Define punishment length \( P = 1 \) round (can be adjusted)

At round \( t \), player \( i \) executes:

---

**At \( t=1 \) (First round):**  
- Cooperate.  
  *Reasoning:* Without history, we initiate cooperation to build trust.

---

**For each round \( t > 1 \):**

1. **Calculate others’ cooperation rate in previous round \( t-1 \):**  
   \[
   C_{\text{others}}^{(t-1)} = \frac{\sum_{j \neq i} c_j^{(t-1)}}{n-1}
   \]

2. **Update punishment counter:**  
   Keep track of how many consecutive rounds opponents failed the threshold.

3. **Decision logic:**

   - **If currently in punishment phase:**  
     - Defect this round.  
     - Decrease punishment counter until zero.

   - **Else (not punishing):**  
     - If \( C_{\text{others}}^{(t-1)} \geq T \), **Cooperate**.  
       (Most others cooperated recently — reciprocate cooperation.)  
     - Else if \( C_{\text{others}}^{(t-1)} < T \), start punishment:  
       - Set punishment counter = \( P \)  
       - Defect this round.

---

**Additional nuances:**

- Punishment is **temporary and forgiving** to avoid deadlocks from one-off defections.
- The threshold \( T \) accounts for noise and occasional experimental defections in a multi-player game.
- If after punishment, cooperation resumes (others cooperate \( \geq T \)), stop punishing.
- If defection persists, punishment cycles repeat, escalating only by frequency of punishment, not in duration, to allow eventual reconciliation.

---

## 2. Edge Cases

- **First Round:** Cooperate unconditionally since no history exists.
- **Last Round \( t = r \):** Cooperate if last round cooperation threshold met, otherwise defect (since no future rounds to incentivize cooperation).
- **If all others defect in round 1:** Start punishing in round 2 (defect), but resume cooperating if they change behavior.
- **If group cooperation fluctuates around threshold:** Forgiveness ensures repeated short punishments create incentives to cooperate.
- **Small groups \( n=2 \):** Strategy reduces to Tit-for-Tat with forgiveness.
- **Large groups \( n > 2 \):** Threshold \( T \) handles imperfect cooperation by some players.

---

## 3. Cooperative Mindset Alignment

- **Initiate with maximal cooperation** to encourage collective welfare.
- **Reciprocate majority cooperation** to reinforce cooperative norms.
- **Punish free-riding with temporary defection**, discouraging exploitation.
- **Forgive quickly to maintain cooperation** instead of permanent retaliation.
- **Use only observed actions — no communication or explicit coordination needed.**
- **Aim for joint gain rather than individual short-term advantage.**

---

## Pseudocode

```python
class FCCStrategy:
    def __init__(self, n, r, k):
        self.n = n
        self.r = r
        # Parameters for forgiveness and threshold
        self.T = 0.7       # cooperation fraction threshold
        self.P = 1         # punishment length in rounds
        self.punish_rounds_left = 0
        self.current_round = 0

    def decide(self, history, player_index):
        # history: list of lists, each inner list = actions of all players in a round ['C'/'D']
        self.current_round = len(history) + 1
        
        if self.current_round == 1:
            # First round: cooperate
            return 'C'
        
        if self.current_round == self.r:
            # Last round: cooperate if others cooperated last round, else defect
            last_round = history[-1]
            others = [a for idx, a in enumerate(last_round) if idx != player_index]
            coop_rate = others.count('C') / (self.n - 1)
            return 'C' if coop_rate >= self.T else 'D'
        
        # For intermediate rounds
        if self.punish_rounds_left > 0:
            # Currently punishing
            self.punish_rounds_left -= 1
            return 'D'
        
        last_round = history[-1]
        others = [a for idx, a in enumerate(last_round) if idx != player_index]
        coop_rate = others.count('C') / (self.n - 1)
        
        if coop_rate >= self.T:
            # Others mostly cooperated, so cooperate
            return 'C'
        else:
            # Others defected significantly; punish next P rounds
            self.punish_rounds_left = self.P - 1  # current round is defect, then P-1 more
            return 'D'
```

---

## Summary

- **Start cooperating.**  
- **Monitor others’ cooperation level in the immediate past round.**  
- **Cooperate if sufficient others cooperated; defect temporarily otherwise.**  
- **Forgive by allowing cooperation resumption after punishment.**  
- **Use a cooperation threshold to tolerate some defections consistent with multi-player dynamics.**  
- **Last round: defect if others defected, otherwise cooperate.**

This strategy balances *maximizing collective payoff* and *deterring exploitation*, aligning with the cooperative mindset required for this repeated public goods game under the information constraints provided.
'''

description_COOPERATIVE_6 = '''
Below is a detailed cooperative strategy designed for the repeated N-Player Public Goods Game under the given constraints and assumptions. It aims to foster mutual cooperation, punish defection to discourage free-riding, and ultimately maximize joint payoffs.

---

## Strategy Name: **"Conditional Cooperation with Forgiveness"**

---

### Key Idea

- Start cooperatively to establish trust and mutual benefit.
- Continue cooperating as long as all players cooperated in the previous round.
- If any defection is detected, punish by defecting once to discourage defection.
- After punishing, return to cooperation to give players a chance to restore cooperation.
- In the last round, defect to maximize individual payoff (standard backward induction reasoning).

---

### Decision Rules

Let:

- `t` = current round number (1 ≤ t ≤ r)
- `history[t-1]` = vector of all players' actions in round t-1 (only for t > 1)
- `c_i,t` = action of self player at round t: C (cooperate) or D (defect)
- `n` = number of players

---

#### Round 1 (Initial Round):

- **Action:** Cooperate (`C`)
- **Reason:** Establish goodwill, attempt to build cooperation foundation.

---

#### Intermediate Rounds (2 ≤ t < r):

1. **Check Previous Round Actions:**
   - If *all* players (including self) cooperated in round t-1, then play **C**.
   
   - Else (at least one player defected last round):
     - If self defected in round t-1 (i.e., we just defected to punish), **return to cooperate (C)** to forgive.
     - Else (self cooperated last round, others defected), **punish by defecting (D)** this round.

---

#### Last Round (t = r):

- **Action:** Defect (`D`)
- **Reason:** No future punishment possible, so rationally defect to maximize own payoff.

---

### Summary Table of Action at Round t

| Round | Condition on previous round actions                               | Action    |
|-------|-------------------------------------------------------------------|-----------|
| 1     | —                                                                 | C         |
| 2..r-1| All cooperated last round?                                         | C         |
| 2..r-1| Not all cooperated last round AND self defected last round?       | C (forgive)|
| 2..r-1| Not all cooperated last round AND self cooperated last round?     | D (punish)|
| r     | —                                                                 | D         |

---

### Pseudocode

```python
def cooperative_strategy(t, r, history, self_index, n):
    """
    t        : int, current round number (1-based)
    r        : int, total number of rounds
    history  : list of lists, each inner list contains actions of all players at round t-1
               history[t-2] is previous round's actions when t > 1
    self_index: int, index of self player (0-based)
    n        : int, number of players
    Returns: 'C' (cooperate) or 'D' (defect)
    """
    
    if t == 1:
        # First round, cooperate
        return 'C'
    
    if t == r:
        # Last round, defect
        return 'D'
    
    # Get actions from previous round
    prev_actions = history[t-2]  # list of actions of all players at round t-1
    
    # Check if all cooperated last round
    all_cooperated = all(action == 'C' for action in prev_actions)
    
    if all_cooperated:
        # Everyone cooperated last round, continue cooperating
        return 'C'
    else:
        # Someone defected last round
        self_prev_action = prev_actions[self_index]
        
        if self_prev_action == 'D':
            # We just defected to punish last time, so forgive now by cooperating
            return 'C'
        else:
            # We cooperated last round but others defected, punish by defecting this round
            return 'D'
```

---

### Strategy Intuition and Advantages

- **Cooperation Establishment:** By cooperating initially, the strategy signals willingness to cooperate, seeking mutual gain.
- **Conditionality:** Cooperation depends on universal cooperation from all players; defection triggers punishment.
- **Firm but Forgiving:** It punishes defection once to discourage free-riding but then forgives immediately to restore cooperation, avoiding endless punishment cycles.
- **Last Round Defection:** Rational backward induction to defect in the last round maximizes final payoff since future rounds cannot punish defections.
- **Memory:** Only one-round memory needed; easy to implement and interpret.

---

### Edge Cases

- **If some players always defect:**  
  Strategy will quickly fall into a pattern of defecting in response to defection, avoiding exploitation.

- **If all cooperate continually except for mistakes:**  
  Forgiveness after a single round of punishment allows recovery to cooperation.

- **Game with very few rounds (e.g., r=2):**  
  - Round 1 cooperate  
  - Round 2 defect (last round)  
  This is appropriate since no future punishment is available.

---

### Alignment with Cooperative Mindset

- The strategy aims to maximize group welfare via sustained cooperation.
- Punishment is used only to enforce cooperation norms, not out of spite.
- Forgiveness fosters reconciliation and long-term cooperation.
- Starting cooperatively and conditionally continuing demonstrates trust and openness.

---

This strategy is well-suited for tournaments where opponents might use a variety of approaches, including unconditional defection, conditional cooperation, or exploitative strategies. It balances responsiveness, optimism, and rational self-interest effectively in the repeated public goods game.
'''

description_COOPERATIVE_7 = '''
Here is a carefully designed cooperative strategy for the N-player Public Goods Game with parameters (n, r, k), meeting the problem's criteria:

---

## Strategy Overview: *Trigger Cooperation with Forgiveness*

This strategy aims to promote cooperation by starting cooperatively and maintaining it as long as others cooperate, while punishing defection to deter free-riding, but also allowing for recovery from mistakes or noise by forgiving isolated defections.

---

## 1. Decision Rules

Let **history** be the full record of all players' actions in past rounds. In particular, we know each player’s action in each previous round.

Define:

- \(c_j^{(t)}\) = 1 if player \(j\) cooperated in round \(t\), else 0.
- \(C^{(t)} = \sum_{j=1}^n c_j^{(t)}\), total cooperators in round \(t\).
- \(D^{(t)} = n - C^{(t)}\), total defectors in round \(t\).
- \(c_i^{(t)}\) is our own action of player \(i\) in round \(t\).

**Basic intuition:**  
- Cooperate if all cooperated in the previous round (i.e., full cooperation by all players).  
- Otherwise, defect to punish defection, except if a limited defection pattern suggests a mistake; then forgive once.

### Formal Rules:

- **Round 1:** Cooperate (no prior history).
- **Round t (2 ≤ t < r):**  
  - If all players cooperated in round \(t-1\) (i.e., \(C^{(t-1)} = n\)), **cooperate**.  
  - Else if the previous round had exactly one defector (\(D^{(t-1)}=1\)) and that defection was not by us, **cooperate** (forgiveness — assume it might be a mistake).  
  - Otherwise, **defect** to punish coordinated defection or repeated defection.
- **Round r (last round):** Defect (standard backward induction logic in finitely repeated social dilemma games).

---

## 2. Handling Edge Cases

- **First round:** Cooperate to start with trust, maximizing joint payoff potential.
- **Last round (round r):** Defect as cooperation is unlikely to be reciprocated afterward, and defection dominates the last-round incentive.
- **Isolated defection:** Forgive a single-player defection in one round once, to allow the group to recover cooperation.
- **Multiple defectors or repeated defection:** Defect to punish and discourage further free-riding.
- **Self-defection:** If you defected in the previous round, treat as punishment mode—continue defecting unless all cooperate again.
- **Return to cooperation:** If punishment established by defection, return to cooperation if full cooperation resumes.

---

## 3. Cooperative Mindset

- This strategy fosters sustained cooperation by rewarding full cooperation each round.
- It is not naive: it punishes defection to maintain accountability.
- It is forgiving: allowing a single defection per round by someone else without harsh retaliation encourages recovery from mistakes or noise.
- It is rational near the end of the game by defecting last round to maximize individual payoff.
- It assumes no communication so it relies purely on observed actions, adhering to perfect information and common knowledge.

---

## Pseudocode

```
Input: history of all players’ actions up to round t-1, current round t, total rounds r
Output: action ∈ {C, D}

if t == 1:
    return C  // Start cooperatively

if t == r:
    return D  // Last round defect

previous_round_actions = history[t-1]  // list of actions of all players at round t-1
C_prev = count of C in previous_round_actions
D_prev = n - C_prev
my_prev_action = previous_round_actions[i]

if C_prev == n:
    // Everyone cooperated last round, cooperate now
    return C

else if D_prev == 1:
    // Exactly one defector in previous round
    defector_index = index of defector in previous_round_actions
    if defector_index != i:
        // Defection by other player, forgive once by cooperating
        return C
    else:
        // I defected last round - in punishment mode, defect now
        return D

else:
    // Multiple defectors or repeated defection, defect now to punish
    return D
```

---

## Summary

| Round       | Condition                     | Action              | Purpose                                  |
|-------------|-------------------------------|---------------------|------------------------------------------|
| 1           | No history                    | Cooperate (C)       | Start with cooperation                    |
| 2..r-1      | All cooperated previous round | Cooperate (C)       | Maintain mutual cooperation               |
| 2..r-1      | One defector (not self) last round | Cooperate (C)   | Forgive isolated deviation                |
| 2..r-1      | Multiple defectors or self-defect last round | Defect (D) | Punish defection, discourage free-riding |
| r (last round) | Always                    | Defect (D)          | Backward induction logic, maximize payoff|

This strategy embodies a cooperative mindset by fostering repeated joint cooperation, pending observed cooperation by all, while remaining robust against exploitation and allowing recovery when others err.

---

If you want, I can also provide a more detailed explanation of why this strategy balances cooperation and punishment optimally in this setting. Let me know!
'''

description_COOPERATIVE_8 = '''
Here is a cooperative strategy explicitly designed for the repeated public goods game described, balancing cooperation incentives and punishment for defection without requiring communication or coordination beyond observable actions.

---

## Strategy Name: *Forgiving Grim Trigger with Final Round Defection*

### Intuition

- Cooperate initially and reward continued cooperation.
- Punish defections by defecting in all future rounds to discourage free riding.
- Forgive if cooperation resumes after one defection to avoid escalating punishments from accidental defections or noise.
- Defect in the last round because cooperation cannot be enforced beyond it (backward induction).
- This promotes stable cooperation while remaining robust against defections and endgame unraveling.

---

## 1. Decision Rules

Let:
- t = current round, 1 ≤ t ≤ r
- History until t-1 includes all players' actions in rounds 1 to t-1
- CoopCount(t-1): number of rounds so far (1..t-1) in which **all players cooperated**
- DefectRounds(t-1): list of rounds so far where any defection occurred
- LastRound = r

**Rule per round:**

1. **If t = 1 (first round):**  
   Cooperate (C) unconditionally to try establishing cooperation.

2. **For rounds 2 ≤ t < LastRound:**

   - If in **every previous round** all players cooperated (i.e., no defectors ever seen), then Cooperate (C).

   - If there is at least one previous round with any defection:

     - If the very last round that had defection was **t - 1** (immediately preceding round), then Defect (D) this round (punishment phase).

     - Else (last defection was before t - 1), Forgive and Cooperate (C) this round.

   This creates a "one round punishment" followed by forgiving cooperation if others return to cooperate.

3. **Round r (last round):**  
   Defect (D) unconditionally because no future punishment is possible.

---

## 2. Handling Edge Cases

- **First Round:** Cooperate unconditionally since no history exists.

- **Last Round:** Defect, to maximize private payoff (standard backward induction).

- **Single Defector in History:** Punish in next round only — defect once following observed defection, then return to cooperation if cooperation resumes.

- **Continuous Defection by Others:** If others keep defecting, punish each round immediately after defection by defecting yourself.

- **Accidental/Isolated Defections:** Forgiveness allows repairing cooperation and avoids endless retaliation cycles.

---

## 3. Cooperative Alignment

- Strategy is designed to maximize group payoff by sustaining mutual cooperation in all rounds except the last.

- By cooperating first and forgiving after isolated defections, it encourages trust and resilience.

- Only defects to punish defections or in final round, thereby discouraging free-riding but not being too unforgiving.

- Leveraging perfect information and common knowledge about all players’ previous moves, it uses observed histories to coordinate cooperation with independent players following similar logic.

---

## 4. Pseudocode

```python
def decide_action(round_t, r, history):
    """
    round_t: current round (1-based)
    r: total number of rounds
    history: list of dicts representing previous rounds:
             each dict maps player_id -> action ('C' or 'D')
    """
    if round_t == 1:
        # First round: cooperate
        return 'C'

    if round_t == r:
        # Last round: defect
        return 'D'

    # Check previous rounds for any defections
    defection_rounds = []
    for t_prev, actions in enumerate(history, start=1):
        if any(a == 'D' for a in actions.values()):
            defection_rounds.append(t_prev)

    if not defection_rounds:
        # No defections so far, cooperate
        return 'C'

    last_defect = defection_rounds[-1]

    if last_defect == round_t - 1:
        # Defect as punishment for defection last round
        return 'D'
    else:
        # Forgive, cooperate if others cooperated last round
        last_round_actions = history[-1]
        if all(a == 'C' for a in last_round_actions.values()):
            return 'C'
        else:
            # If others still defected last round, defect to continue punishment
            return 'D'
```

---

## 5. Summary

| Situation                     | Action           |
|------------------------------|------------------|
| Round 1                      | Cooperate (C)    |
| 2 ≤ Round < r & No defection ever  | Cooperate (C)    |
| 2 ≤ Round < r & Defection in last round | Defect (D)       |
| 2 ≤ Round < r & Defection before last round and cooperation last round | Cooperate (C)    |
| 2 ≤ Round < r & Defection before last round and defection last round | Defect (D)       |
| Round r (final round)         | Defect (D)       |

This strategy encourages mutual cooperation while still punishing defectors and defecting opportunistically at the end. It is robust, fair, and pragmatic for independent rational agents with perfect information in repeated public goods games.
'''

description_COOPERATIVE_9 = '''
Below is a cooperative strategy designed for the specified N-Player Public Goods game. It aims to maximize group payoff by fostering and maintaining cooperation, while deterring defection through contingent retaliation. The strategy is designed to be clear and interpretable, suitable for a tournament against unknown opponents under the given constraints.

---

## Cooperative Strategy: "Conditional Cooperator with Forgiveness"

**Intuition:**  
- Start by cooperating to show willingness to build a cooperative outcome.  
- Continue cooperating as long as the group maintains high cooperation rates.  
- If defection is detected, respond by defecting once as punishment.  
- Forgive promptly if cooperation resumes.  
- Defection only persists if others defect persistently, minimizing losses.  
- In the last round, defect to maximize private payoff (standard backward induction reasoning).

---

### Detailed Decision Rules

Let:

- `t` = current round (1 ≤ t ≤ r)  
- `history` = full action history of all players for rounds 1 through t-1  
- `c_threshold` = cooperation proportion threshold defining "high cooperation", e.g., 80%  
- `defect_flag` = a boolean indicating whether defection was observed in the previous round, triggering retaliation

---

### Important observations from the game:

- Payoff from defection is strictly higher if others cooperate (free-riding incentive).  
- Mutual cooperation payoff: π_i = k (since all contribute, payoff is k), which is better than mutual defection payoff = 1.  
- Defector in mostly cooperative group gains even more than cooperators in that group.  
- Therefore, strategic retaliation is needed to sustain cooperation.

---

### Parameters (can be tuned based on tournament results):

- `c_threshold = 0.8` (cooperation rate threshold for "good faith")  
- `retaliation_length = 1` (how many rounds to punish)

---

### Pseudocode for player i's strategy in round t

```python
# Initialization
retaliation_counter = 0  # counts how many rounds of retaliation remain

def decide_action(t, history):
    global retaliation_counter
    
    # Last round: defect to maximize private payoff
    if t == r:
        return 'D'
    
    # For round 1: cooperate unconditionally
    if t == 1:
        return 'C'
    
    # Analyze previous round cooperation level
    previous_round = t - 1
    actions_last_round = history[previous_round]  # list of length n with 'C' or 'D'

    # Calculate proportion of cooperators last round
    coop_count = sum(1 for a in actions_last_round if a == 'C')
    coop_ratio = coop_count / n

    # Detect if any defection in last round
    any_defection = (coop_count < n)

    if retaliation_counter > 0:
        # Retaliate by defecting
        retaliation_counter -= 1
        return 'D'

    # No ongoing retaliation
    if any_defection and coop_ratio < c_threshold:
        # Defection detected and cooperation below threshold - start retaliation
        retaliation_counter = retaliation_length - 1  # current round is retaliation round
        return 'D'
    
    # If most cooperated in previous round, cooperate
    if coop_ratio >= c_threshold:
        return 'C'
    
    # If cooperation below threshold but no retaliation ongoing, defect
    return 'D'
```

---

### Explanation of decision rules:

- **Round 1:** Cooperate, signaling willingness to build cooperative environment.  
- **Subsequent rounds:**  
  - If everyone cooperated last round or cooperation ratio ≥ 80%, cooperate to maintain mutual benefit.  
  - If defection happened but cooperators still ≥ 80%, forgive and keep cooperating (generous).  
  - If defection happened and cooperation dropped under 80%, defect once to punish defectors.  
  - After one round of punishment, return to cooperation if others do likewise (forgiveness).  
- **Last round:** Defect, because there is no future loss from punishing cooperators, standard rational endgame.  

---

### Strategy properties:

- **Cooperative:** Willing to cooperate and maintain cooperation if most players cooperate.  
- **Contingent retaliation:** Discourages sustained defection to protect group benefits.  
- **Forgiving:** Punishes defection only briefly, allowing for return to cooperation.  
- **Clear signal:** Cooperation is conditional but generous, easy to recognize by others.  
- **Practical for tournament:** Uses only publicly known history and simple rules.

---

### Edge Case Handling

- **First round:** Cooperate unconditionally since no history exists.  
- **Last round:** Defect to maximize payoff (backward induction).  
- **Persistent defectors:** Will face repeated defection as no forgiveness occurs if cooperation stays below threshold.  
- **Short games (e.g., r=2):** Still cooperate first round, defect second round.  

---

### Summary

| Round          | Condition                                   | Action       | Notes                          |
|----------------|---------------------------------------------|--------------|--------------------------------|
| 1              | No history                                  | C            | Start cooperating               |
| 2 to r-1       | Cooperation ≥ 80% last round                | C            | Reward cooperation             |
| 2 to r-1       | Cooperation < 80% + no ongoing retaliation | D (retaliate)| Punish defection once          |
| 2 to r-1       | Ongoing retaliation round                    | D            | Continue punishment            |
| r (last round) | Any history                                 | D            | Defect to maximize payoff      |

---

This strategy balances cooperation incentives with credible retaliation and forgiveness, promoting group welfare while protecting against exploiters in an environment of perfect monitoring but no communication.
'''

description_COOPERATIVE_10 = '''
Here is a cooperative strategy designed for the described N-player repeated public goods game. It is inspired by reciprocity and forgiveness principles, balancing cooperation and retaliation to promote stable mutual cooperation.

---

## Strategy Name: **Forgiving Trigger**

### Intuition
- Start by cooperating to signal willingness to cooperate.
- Cooperate so long as no player defects.
- If any defection is observed in a previous round, defect as punishment.
- After defecting one round in punishment, **give players a chance to resume cooperation** by returning to cooperation next round.
- This cycle of punishment followed by forgiveness helps sustain cooperation and avoids endless mutual defection due to a single mistake.
- On the last round, defect because no future rounds remain to enforce cooperation and cooperating is individually costly.

### Decision Rules

| Round                  | Decision                                                          |
|------------------------|-------------------------------------------------------------------|
| Round 1 (initial round) | Cooperate                                                        |
| Intermediate rounds < r | If **all players cooperated last round**, cooperate; else defect |
| Punishment round        | After defecting due to previous defection, try cooperation next round |
| Round r (last round)    | Defect (no incentive to cooperate on last round)                 |

---

### Detailed Explanation

- **First round:** Cooperate to initiate cooperation and gain mutual benefit.
- **Subsequent rounds:** Monitor the entire group's actions in the immediately preceding round.
  - If everyone cooperated, repay cooperation with cooperation.
  - If any defection occurred, respond with defection to punish.
- **Forgiveness:** After one round of punishment defection, revert to cooperation to allow the group to re-establish cooperation.
- **Rationale for forgiveness:** Stopping endless retaliation cycles avoids persistent welfare losses.
- **Last round:** Defect because no future punishment is possible or expected, so acting selfishly maximizes final round payoff.

---

### Pseudocode

```python
# Parameters known: n (players), r (rounds)
# Inputs: history = list of tuples/lists with previous rounds' actions of all players
#   e.g., history[t] = [a_1, a_2, ..., a_n] for round t in {0,...,r-1}
# Actions: 'C' = cooperate, 'D' = defect

def forgiving_trigger_strategy(player_index, history, current_round, total_rounds):
    if current_round == 0:
        # First round: cooperate
        return 'C'
    
    if current_round == total_rounds - 1:
        # Last round: defect (no future punishment)
        return 'D'
    
    # Check if previous round had any defections by *any* player
    prev_round_actions = history[current_round - 1]
    any_defection_last_round = ('D' in prev_round_actions)
    
    # Check if this player punished in last round (defected due to punishment)
    if current_round >= 2:
        my_action_prev_round = history[current_round - 1][player_index]
        any_defection_two_rounds_ago = ('D' in history[current_round - 2])
        
        # If punished last round, forgive this round by cooperating
        if any_defection_two_rounds_ago and my_action_prev_round == 'D':
            return 'C'
    
    # If anyone defected last round and not in forgiveness round, defect
    if any_defection_last_round:
        return 'D'
    
    # Otherwise, cooperate
    return 'C'
```

---

### Behavior Summary:

- Start cooperative.
- Use **grim trigger with forgiveness**: punish defection but forgive after one punishment round.
- Cooperate if last round fully cooperative.
- Defect the last round to maximize final payoff.

---

### Why is this strategy cooperative?

- It promotes sustained cooperation by rewarding cooperation and punishing defection.
- It forgives to recover cooperation after punishment, avoiding permanent breakdown.
- By cooperating first, it initiates a cooperative norm.
- It maximizes joint payoffs over repeated rounds, as cooperation yields higher returns per payoffs specified.
- Defection at last round is standard in finitely repeated games (backward induction).

---

### Edge Cases

- **First round:** Cooperate unconditionally despite no history.
- **Last round:** Defect since no future incentives for cooperation remain.
- **Mistakes or random defection:** Forgiveness allows return to cooperation.
- **Multiple defectors:** Punish any defection collectively.
- **If all defect in first round:** Defect thereafter as punishment cycle starts immediately.

---

This strategy robustly fosters cooperation, punishes defection, and enables recovery to maximize payoffs in the repeated public goods game environment under perfect monitoring and no communication.
'''

description_COOPERATIVE_11 = '''
Here is a cooperative strategy designed for the N-player repeated public goods game specified. It aims to promote maximal mutual cooperation throughout the game, with mutual forgiveness to handle noise or defections, and clear defections punishments to deter exploitation.

---

## Strategy Name: "Forgiving Conditional Cooperation"

---

### 1. Intuition:

- The best total group payoff emerges when all players cooperate every round.
- Because defectors can free-ride, the strategy starts cooperatively but monitors the group's behavior.
- It conditions cooperation on collective cooperation in previous rounds.
- Allows forgiveness after isolated defections to avoid cascading mutual defections.
- Defects only if clear, persistent defection by others is seen.
- Defects in the last round to avoid exploitation (common in repeated social dilemmas).

---

### 2. Key Definitions and Variables:

- `r`: Total rounds
- `t`: Current round (1 ≤ t ≤ r)
- `n`: Number of players
- `history[t']`: vector of length n with players' actions at round t'
- `last_rounds_cooperators`: number of players who cooperated in previous round `t-1`
- `threshold_coop_ratio` = 0.8  (Example threshold expressing "mostly cooperate")
- `forgiveness_window` = 2 (Rounds to forgive after defection before punitive defection)
- `defect_streak` = counts how many consecutive rounds had below-threshold cooperation

---

### 3. Decision Rules:

```pseudocode
Initialize defect_streak = 0

FOR each round t = 1 to r DO

    IF t == 1 THEN
        # First round: Cooperate to signal intention to cooperate
        play C
    
    ELSE IF t == r THEN
        # Last round: Defect to avoid exploitation (backward induction)
        play D
    
    ELSE
        # For rounds 2 to r-1:

        # Check the level of cooperation by others in previous round
        last_round_cooperators = count of players with action C in history[t - 1]
        coop_ratio = last_round_cooperators / n

        IF coop_ratio >= threshold_coop_ratio THEN
            # Most players cooperated; reset defect_streak and cooperate
            defect_streak = 0
            play C

        ELSE
            # Cooperation below threshold: possible defection detected
            defect_streak = defect_streak + 1

            IF defect_streak <= forgiveness_window THEN
                # Forgive and try cooperating again for a limited window
                play C

            ELSE
                # Persistent defection: punish by defecting
                play D
            ENDIF
        ENDIF
    ENDIF

END FOR
```

---

### 4. Explanation of the Decision Logic:

- **Round 1:** Cooperate unconditionally to build mutual trust.
- **Rounds 2 to r-1:**  
  - If the previous round shows sufficiently high cooperation in the group (≥ 80%), reciprocate by cooperating again.  
  - If the cooperation drops below 80%, do not immediately defect but enter a forgiveness period (2 rounds) where you continue cooperating, giving others a chance to recover cooperation.  
  - If poor cooperation persists beyond forgiveness, punish by defecting.
- **Round r (last round):** Defect. There is no future to incentivize cooperation; defecting avoids unilateral exploitation by others defecting in the last round.

---

### 5. Edge Cases:

- **If all players defect in round 1:** Your cooperation in round 1 might be exploited once, but you switch to defection quickly after seeing no cooperation.
- **If cooperation fluctuates around the threshold:** Forgiveness window accommodates noise/errors in play or transient mistakes to avoid punishing cooperators prematurely.
- **If all cooperate all rounds:** You always cooperate, maximizing group welfare.
- **In the final round:** Defecting avoids risk of being exploited, given no future rounds exist.
- **If parameters change (number of players, rounds, k):** The rule depends only on relative cooperation ratio, so it's robust across different game sizes.

---

### 6. Cooperative Mindset Alignment:

- The strategy **starts** by cooperating, signaling willingness to cooperate.
- It **rewards cooperation** from others by continuing to cooperate.
- It **limits exploitation** by punishing persistent defectors.
- It **shows forgiveness** to avoid mutual destruction after occasional defection.
- It **prefers cooperation over defection whenever reasonable** to maximize total payoffs.
- It **exploits backward induction logic only at the last round** to avoid being exploited.

---

# Summary:

| Round           | Condition                        | Action |
|-----------------|--------------------------------|--------|
| 1               | First round                    | Cooperate (C) |
| 2 to r-1        | Previous round cooperation ≥ 80% | Cooperate (C) and reset defect streak |
| 2 to r-1        | Cooperation < 80% but forgiveness window not exceeded | Cooperate (C), increment defect streak |
| 2 to r-1        | Cooperation < 80% and forgiveness window exceeded | Defect (D) |
| r (last round)  | Any                           | Defect (D)   |

---

This strategy balances cooperation promotion with strategic punishment and forgiveness, aiming to thrive against a variety of opponent behaviors in the tournament.
'''

description_COOPERATIVE_12 = '''
**Cooperative Strategy for the N-Player Public Goods Game**

---

### Intuition and Goals

- The social optimum is all players cooperate every round, yielding the highest payoff (k > 1 but < n, so all cooperation yields more than all defect).
- Defection yields higher individual payoff in a single round if others cooperate but leads to lower group payoff.
- Because the game is repeated, incentive exists to sustain cooperation via conditional cooperation and punishment.
- No communication or coordination is possible beyond observed past moves.
- The strategy must be designed to:
  - Foster cooperation starting from round 1.
  - Punish defection but allow for recovery.
  - Avoid endgame defection cascade.
  - Be clearly cooperative, maximize total payoffs in the long run.

---

### Strategy Description

**Name:** Conditional Cooperator With Forgiveness (CCWF)

---

### High-Level Rules

1. **First Round (t = 1): Cooperate.**
   - Start by cooperating to signal willingness.

2. **Subsequent rounds (2 ≤ t < r):**
   - Cooperate if *all* players cooperated in the immediately prior round.
   - Defect if *any* player defected in the immediately prior round.
   - Once defecting, **attempt to return to cooperation if all players cooperated in the previous round** (i.e., forgive defections after one round of punishment).

3. **Last round (t = r): Defect.**
   - Since no future punishment is possible, defect to maximize final round payoff (standard backward induction reasoning).

---

### Formal Decision Rules

For player i in round t (1 ≤ t ≤ r):

- If t = 1:
  - Play C.
- Else if t = r:
  - Play D.
- Else (2 ≤ t < r):
  - Check previous round (t-1) actions of all players.
  - If ∀j: action_j,t-1 = C, then play C.
  - Else:
    - If player defected in previous round (t-1), play D this round to punish.
    - If player punished already (played D in t-1), but previous round (t-2) was all C, then forgive by playing C.
    - This can be simplified to a one-round punishment phase:
      - If previous round had defection, defect this round (punishment).
      - If no defection in previous round, cooperate.

---

### Handling Edge Cases

- **If multiple players defect in some round:**
  - Defect in next round to punish collectively.
- **If occasionally someone mistakenly defects (noise not assumed but if happens):**
  - Punish one round, then return to cooperation if all cooperate next round.
- **If unanimous defection starts early:**
  - The strategy will defect too and get payoff = 1, but always open to return to cooperation if the others do.
- **In last round, defect regardless** to avoid exploitation (standard finitely repeated game logic).

---

### Pseudocode

```python
def CCWF_strategy(t, r, history):
    # history: list of length t-1 rounds,
    # each element is a list of n actions ['C' or 'D'] of all players from previous rounds

    if t == 1:
        return 'C'  # start cooperating

    if t == r:
        return 'D'  # last round, defect

    # For rounds 2 to r-1:
    prev_round_actions = history[-1]
    # Check if all cooperated in previous round
    if all(action == 'C' for action in prev_round_actions):
        return 'C'  # cooperate
    else:
        # There was at least one defection in previous round, punish by defecting
        return 'D'
```

This simple memory-1 strategy uses *all cooperate last round* as the trigger to cooperate; otherwise it defects (punishes defection).

---

### Strategic Remarks

- **Cooperates initially**, signaling intention to maximize group payoff.
- **Punishes defection immediately** in next round.
- **Forgives promptly** by resuming cooperation if the group repairs cooperation.
- **Effectively implements a trigger with forgiveness**, avoiding long-term defection spirals.
- **Defects on final round** to avoid exploitation consistent with backward induction.
- The strategy is **simple to implement and understand** by other players, favoring emergence of cooperation among rational opponents in repeated play.
- No reliance on coordination or communication.
- Exploited only if others always cooperate and this player defects early, but since it punishes defection elsewhere, mutual cooperation is stable.

---

**Summary:** Start cooperating; continue cooperation only if all cooperated last round; defect once if any defected last round; always defect final round. This conditional cooperation with one-round punishment and forgiveness is a robust cooperative strategy.
'''

description_COOPERATIVE_13 = '''
Here is a cooperative strategy for the specified N-Player Public Goods game designed to foster cooperation while being robust to defection. It is inspired by a "tit-for-tat"-style approach adapted to the multi-player, simultaneous-move repeated public goods setting.

---
## Cooperative Strategy: "Conditional Cooperation with Forgiveness"

### Intuition:
- Start by cooperating to signal willingness to cooperate.
- Continue cooperating if the group mostly cooperated in the previous round.
- If significant defection is observed, punish by defecting in the next round.
- Forgive occasional defections to avoid endless retaliation and promote return to cooperation.
- On the last round, defect since no future incentive to cooperate exists.

---

### 1. Decision Rules

Let:
- \( t \) = current round (1 ≤ t ≤ r)
- \( c_j^{t-1} \) = contribution (1 = cooperate, 0 = defect) of player \( j \) in previous round
- \( C^{t-1} = \sum_{j=1}^n c_j^{t-1} \) = total cooperators in previous round

Define:
- \( \text{group\_coop\_ratio} = \frac{C^{t-1}}{n} \)

Parameters:
- Threshold \( \theta \in (0,1) \): Minimum fraction of cooperators in previous round to continue cooperating (e.g., \(\theta = 0.6\))
- Forgiveness window \(m\): Number of recent rounds to check for cooperation recovery (e.g., \(m=2\))

**Action decision for player \( i \) at round \( t \):**

- **Round 1 (t=1):**
  - Cooperate (C)
  
- **Rounds 2 to r-1 (1 < t < r):**
  - If in round \( t-1 \), at least \(\theta \times n\) players cooperated (including self), **cooperate (C)**.
  - Else, defect (D) for this round as punishment.
  - If punished, continually monitor last \( m \) rounds; if group cooperation recovers (≥ \(\theta\)) in any of these rounds, **forgive** by cooperating again.
  
- **Final round (t = r):**
  - Defect (D) (no incentive to cooperate as no future rounds)

---

### 2. Edge Cases

- **First round:**
  - Cooperate to signal intent and test others.
  
- **Last round:**
  - Defect to maximize payoff (standard backward induction logic).
  
- **After defection rounds:**
  - Do not trigger infinite retaliation.
  - Use forgiveness rule: if group cooperation recovers even once in last \( m \) rounds, cooperate again.
  
- **Multiple players defecting:**
  - If the group cooperation ratio drops below threshold, punish once by defecting.
  - If cooperation returns, forgive and resume cooperation.

---

### 3. Strategy Properties and Cooperative Mindset

- Willingness to cooperate from start, encouraging others to cooperate.
- Punishment is conditional and proportional—only defect one round following substantial defection.
- Forgiveness mechanism to restore mutual cooperation after defections.
- Defection only at the very end when future rounds no longer justify sacrifice.
- The threshold-based rule allows tolerance for occasional defections or mistakes.
- Compatible with an environment of uncertainty about others' strategies.

---

### Pseudocode

```
parameters:
  theta = 0.6         # minimum fraction of cooperators to continue cooperation
  m = 2               # forgiveness window (rounds)
  
initialize:
  history = []        # list of sets of cooperators each round (to be updated after each round)

function decide_action(t, history, player_index):
  if t == 1:
    return 'C'
    
  if t == r:
    return 'D'
    
  # Evaluate recent group cooperation
  # Compute cooperation ratios for previous rounds
  coop_ratios = []
  for past_round_cooperators in last m rounds of history:
    ratio = len(past_round_cooperators) / n
    coop_ratios.append(ratio)
  
  # Was previous round sufficiently cooperative?
  prev_coop_ratio = len(history[t-2]) / n  # history indices zero-based
  sufficient_cooperation_prev = (prev_coop_ratio >= theta)
  
  # Check if forgiveness applies (any of last m rounds had sufficient cooperation)
  forgiveness = any(r >= theta for r in coop_ratios)
  
  # Decision logic
  if sufficient_cooperation_prev:
    return 'C'        # continue cooperating after good cooperation
  else:
    # Previous round had low cooperation; punish
    # If forgiveness window shows cooperation recently, forgive now
    if forgiveness:
      return 'C'
    else:
      return 'D'
```

---

### Summary

This **Conditional Cooperation with Forgiveness** strategy promotes public goods provision by starting cooperatively, defecting to penalize free riders but only temporarily, and resuming cooperation if others do. It relies on publicly observable outcomes and requires no communication beyond actions, fits standard repeated game reasoning, and remains cooperative throughout except the backward-induction defection on the last round. This balances self-interest with group benefit, aligning tightly with the cooperative mindset for the repeated public goods game.
'''

description_COOPERATIVE_14 = '''
**Cooperative Strategy for N-Player Public Goods Game (Repeated, Simultaneous Moves)**

---

### Goal:
Maximize collective payoffs by achieving sustained cooperation (all players choosing C). The strategy should maintain cooperation if others do, punish defection promptly but forgivingly to restore cooperation, and recognize the game's finite horizon to avoid end-game collapse.

---

### Intuition:
- Cooperate initially and as long as no defections are detected (tit-for-tat adapted to n players).
- Punish defections to discourage exploitation (defect next round if defections detected).
- Forgive quickly after punishment to allow return to cooperation.
- In the last round, defect (no incentive to cooperate as no future).

---

### Components:
- **History-based:** Track the actions of all players in all previous rounds.
- **Monitoring:** Detect number of defectors each previous round.
- **Memory:** Use "trigger" for defections in the previous round only (1-round punishment).
- **Endgame:** Defect in the last round since no future rounds remain to incentivize cooperation.

---

### Formal Description

1. **Notation:**
   - Let `t ∈ {1,...,r}` be the round index.
   - Let `H_{t-1}` be the history of all players’ actions up to round `t-1`.
   - Define `D_{t-1} = { i : player i defected in round t-1 }`
   - My action in round `t` is `a_t ∈ {C, D}`.

2. **Rules:**

| Condition                                                         | Action  |
|------------------------------------------------------------------|---------|
| **Round 1 (t=1)**                                                | Cooperate (C) to initiate cooperation. |
| **Rounds 2 to r-1 (1 < t < r):**                                | |
| - If all players cooperated in round t-1 (no defectors),         | Cooperate (C). |
| - Else (some defectors in t-1)                                   | Defect (D) to punish. |
| **Last round (t = r):**                                          | Defect (D) — no incentive to cooperate. |

3. **Rationalization:**

- **Start cooperative**: To signal willingness to cooperate.
- **Punish quickly**: Defections hurt cooperation; punish immediately to enforce discipline.
- **Forgiving**: React only to the previous round; if defectors return to cooperation, so do we.
- **Last round defection**: Classical backward induction reasoning; cooperation can unravel anyway.

---

### Pseudocode

```python
def cooperative_strategy(t, r, history):
    # history: list of dicts, each dict maps player_id -> action {'C'/'D'}, for rounds 1..t-1

    if t == 1:
        # First round: cooperate
        return 'C'

    if t == r:
        # Last round: defect
        return 'D'

    # For rounds 2 to r-1

    # Extract actions of all players in last round
    last_round_actions = history[-1]  # dictionary: player_id -> action

    # Check if all cooperated in last round
    all_cooperated = all(action == 'C' for action in last_round_actions.values())

    if all_cooperated:
        # No defection detected, continue cooperating
        return 'C'
    else:
        # Defection detected, punish by defecting this round
        return 'D'
```

---

### Additional Notes:
- The strategy treats any defection by any player as a reason to punish.
- Punishment lasts exactly 1 round to avoid costly endless retaliation cycles.
- Because all players know the parameters and observe actions, the strategy is transparent.
- If opponents also desire cooperation and use similar strategies, it stabilizes cooperation.
- This strategy resembles a multi-player Tit-for-Tat with 1-round memory plus endgame defection.

---

### Summary

| Round    | Condition                       | Action    |
|----------|--------------------------------|-----------|
| 1        | First round                    | Cooperate |
| 2..(r-1) | Previous round all Cooperate?  | Cooperate |
| 2..(r-1) | Else (some defectors last round)| Defect    |
| r        | Last round                     | Defect    |

This approach maximizes collective payoff if all cooperate and deters exploitation by punishing defections swiftly but forgivingly. It aligns with the cooperative mindset under the constraints of no communication and simultaneous moves.
'''

description_COOPERATIVE_15 = '''
Below is a cooperative strategy designed with careful consideration of the public goods game's incentives and constraints, emphasizing reciprocity and forgiveness while discouraging exploitation. It balances the desire to maximize joint payoffs (through cooperation) with safeguards against sustained defections.

---

### Strategy Name: **Conditional Cooperative Reciprocity (CCR)**

---

## 1. Decision Rules

- **First Round (t = 1):**  
  Cooperate (C). Start with cooperation to signal willingness to cooperate.

- **Subsequent Rounds (t > 1 and t < r):**  
  - Let **prev_round_actions** be the set of all players' actions in the previous round.  
  - Compute **prev_cooperators = number of players who cooperated in round t-1**.  
  - Compute **my_prev_action = my action in round t-1**.

  Decision logic:

  1. If **all other players cooperated** in the previous round (i.e., prev_cooperators = n, including self), **cooperate (C)**.  
     Reason: Everyone showed full cooperation, so maintain full cooperation.

  2. Else if **the number of cooperators among others (excluding self) ≥ threshold** (e.g., at least 75% of other players cooperated previously), **cooperate (C)**.  
     Reason: Majority cooperated, so continue cooperation expecting mutual benefit.

  3. Else if **I cooperated last round but fewer than threshold cooperated (defection detected)**, **defect (D)** this round to punish defectors.  
     Reason: Defect to penalize defection and signal disapproval, discouraging free-riding.

  4. Else (i.e., I defected last round or low cooperation last round), **cooperate (C)** this round to attempt forgiveness and return to cooperation.  
     Reason: Allow recovery from mutual defection cycles by forgiving.

- Note: The **threshold** can be set as `ceil(0.75 * (n-1))` (i.e., 75% of the other players must have cooperated). This balances tolerance and firmness.

- **Last Round (t = r):**  
  - **Cooperate (C).** Despite standard backward induction suggesting defection in last round, cooperation maximizes joint payoff and aligns with cooperative mindset.

---

## 2. Handling Edge Cases

- **First Round:**  
  No history available; start by cooperating to establish trust and signal cooperative intent.

- **Last Round:**  
  Defecting in last round yields no future punishment because game ends, but here we **choose cooperation anyway** to maximize social welfare and embrace cooperation principle.

- **Multiple rounds of defection / retaliation:**  
  The "forgiveness" step (cooperate after defecting or seeing low cooperation) prevents endless defection spirals by offering chance to restore mutual cooperation.

- **No communication:**  
  Uses only observed actions; does not rely on any side channel.

- **Partial defections (some players defecting):**  
  Strategy tolerates some defection (below threshold) without punishment, reflecting realistic leniency and avoiding retaliation from minor deviations.

---

## 3. Pseudocode

```
input: round t, total rounds r, history_actions // history_actions[t-1] gives set of all players' actions at round t-1
input: n // number of players

threshold = ceil(0.75 * (n - 1))

function select_action(t, r, history_actions, my_id):
    if t == 1:
        return 'C'  // cooperate first round

    if t == r:
        return 'C'  // cooperate last round (endgame cooperation)

    prev_round = t - 1
    prev_actions = history_actions[prev_round]  // array of length n, each 'C' or 'D'
    
    prev_my_action = prev_actions[my_id - 1]  // zero-based index

    // Count number of cooperators excluding self
    prev_cooperators = sum(1 for a in prev_actions if a == 'C')
    prev_cooperators_excl_me = prev_cooperators - (1 if prev_my_action == 'C' else 0)

    if prev_cooperators == n:
        return 'C'  // all cooperated last round
    else if prev_cooperators_excl_me >= threshold:
        return 'C'  // most others cooperated last round
    else:
        if prev_my_action == 'C':
            // I cooperated but others defected more than acceptable threshold
            return 'D'  // punish by defecting this round
        else:
            // I defected last round or low cooperation; try forgiving
            return 'C'
```

---

## 4. Rationale Summary

- **Start cooperative:** To invite cooperation and maximize joint payoffs from the outset.  
- **Reciprocate cooperation:** Reward cooperation by cooperating when others do.  
- **Punish sustained defection:** Defect when cooperation falls below tolerance and I had cooperated, to discourage free-riding.  
- **Forgive:** After defecting or seeing defection, attempt to cooperate again to restore cooperation cycle.  
- **Cooperate on last round:** Prioritize social welfare and cooperative spirit, accepting potential vulnerability because no future rounds exist for retaliation.  
- **No punishment for small defection groups:** Avoid harsh punishments to prevent unnecessary defections spirals.  

This strategy aligns with classic **Tit-for-Tat + forgiveness** style strategies adapted to multi-player public goods context.

---

If implemented in a tournament, this approach will:

- Signal and sustain cooperation with majority cooperators.  
- Punish defectors selectively to reduce incentive to free-ride.  
- Use forgiveness to avoid lasting mutual defection patterns.  
- Embrace cooperative outcomes over purely selfish last-round defections.

---

If you'd like, I can help with analyzing expected performance or variations based on different parameters.
'''

description_COOPERATIVE_16 = '''
Below is a detailed cooperative strategy designed for the described N-player repeated Public Goods Game. This strategy aims to maximize collective payoffs by promoting cooperation as a norm through conditional cooperation with forgiveness and a clear fallback in case of persistent defection.

---

## Strategy Name: Conditional Cooperative with Forgiveness (CCF)

### Intuition:
- Start fully cooperative to build trust.
- Continue cooperating if others mostly cooperate.
- Punish defections by defecting for one round after observing defection(s) to discourage free-riding.
- Forgive defections after punishment to restore cooperation.
- On the last round, defect because cooperation cannot be enforced anymore.

---

## Decision Rules

### Notation:
- `t`: current round (1 ≤ t ≤ r)
- `Actions[t][j]`: action (C or D) taken by player j in round t (observed after round t)
- `self = i`: this player's index
- `History`: all past actions by all players

### Variables:
- `cooperation_threshold = 0.8`  (threshold of proportion of cooperators to consider cooperation stable)
- `punishment_round = False` (flag indicating if currently punishing defectors)
- `last_round = r`

---

### Step-by-step rules:

#### Round 1 (t=1):
- **Play C (Cooperate)**.
- Reason: No past data, begin with cooperation to encourage mutual cooperation.

#### Subsequent rounds (2 ≤ t < r):

1. **Check previous round's cooperation level:**
   - Calculate fraction of cooperators in round t-1:
     \[
     f = \frac{\text{number of players who played C in round } t-1}{n}
     \]
2. **Check if you were defected against:**
   - If any player defected (played D) in round t-1 (i.e., not all cooperated), set `punishment_round = True`.
3. **Action rules:**

   If `punishment_round == False`:
   - If \( f \geq cooperation\_threshold \) (e.g., ≥ 0.8), **play C** (continue cooperating).
   - Else (significant defections), **play D** to punish.
   
   If `punishment_round == True`:
   - **Play D** once as punishment.
   - Then set `punishment_round = False` for next round (forgiveness).

#### Last round (t = r):
- **Play D** unconditionally.
- Reason: No future rounds to enforce cooperation, so defect to maximize private payoff (standard backward induction).

---

### Handling Edge Cases

- If all players defect in round 1 (everyone plays D), the strategy responds by defecting in round 2 and onwards until a threshold of cooperation is observed again (through others playing C). If cooperation reappears above threshold, return to cooperating.
- The forgiveness mechanism prevents endless punishment cycles by limiting punishment to exactly one round after defections.
- If multiple defectors appear but cooperation fraction remains above threshold, cooperate to maintain group cooperation.
- If the threshold is too strict (e.g., 1.0), punishment never occurs; if too lenient (e.g., 0.5), excessive punishment might hurt cooperation. 0.8 chosen as balance.

---

## Pseudocode

```python
def CCF_strategy(t, r, n, history, self_index):
    """
    t: current round (1-based)
    r: total rounds
    n: total players
    history: list of dicts of round actions, e.g.,
             history[round_num-1] = {player_index: 'C' or 'D', ...}
    self_index: player index (1..n)
    
    Returns 'C' or 'D'
    """
    
    cooperation_threshold = 0.8
    # Track punishment_round state over rounds (requires external memory)
    # Let's assume global or persistent variable: punishment_round_flag
    
    if t == 1:
        # First round: cooperate
        punishment_round_flag = False  # reset
        return 'C'
    
    if t == r:
        # Last round: defect
        return 'D'
    
    # Analyze last round actions
    last_round_actions = history[t-2]  # since history is 0-based index
    
    num_cooperators = sum(1 for action in last_round_actions.values() if action == 'C')
    f = num_cooperators / n
    
    # Did anyone defect last round (including possibly self)?
    defectors_exist = (num_cooperators < n)
    
    # Handle punishment logic
    global punishment_round_flag
    if not punishment_round_flag:
        if defectors_exist:
            # Enter punishment round
            punishment_round_flag = True
            return 'D'  # punish defectors
        else:
            # No defections
            if f >= cooperation_threshold:
                return 'C'  # keep cooperating
            else:
                # Rare case: cooperation fraction low but no defectors? (impossible)
                # Just cooperate
                return 'C' 
    else:
        # This is the round after punishment: forgive and try cooperate again
        punishment_round_flag = False
        return 'C'
```

---

## Summary

- Start cooperating to build mutual cooperation.
- Keep cooperating if most others cooperate.
- Punish defectors by defecting one round immediately after any defection occurs.
- Forgive and return to cooperation the round after punishing.
- Defect on the last round, as no incentive to cooperate remains.
- Use a threshold to tolerate small levels of defection without collapsing cooperation.

---

## Why This Is Cooperative

- Encourages maximum group payoff by promoting cooperation.
- Is forgiving rather than unforgiving: avoids permanent collapse of cooperation.
- Punishment is proportional and limited: one round only, no spirals.
- Respects rational incentives and recognizes last-round edge effect.
- Adaptively responds only to actual observed defectors.

---

If implemented, this strategy should perform well in tournaments by promoting high-group payoffs through stable, conditional cooperation with a clear mechanism to handle defections and edge cases.
'''

description_COOPERATIVE_17 = '''
Below is a cooperative, conditional strategy tailored for the N-Player Public Goods Game as specified. The strategy aims to foster cooperation while guarding against exploitation by defectors. It leverages monitoring of past actions (observable by perfect information) and has clearly defined behaviors for first round, ongoing rounds, and final round.

---

### Strategy Name: Grim Trigger with Forgiveness

**Intuition:**  
Start fully cooperating and continue cooperating as long as all players cooperated in the previous round. If any defection is observed, punish by defecting for a limited number of rounds, then attempt to return to cooperation, allowing recovery from possibly accidental defections or misunderstandings. This balances cooperation with deterrence against defectors.

---

### Detailed Description

#### Key Parameters
- `n`: number of players
- `r`: total number of rounds
- `k`: multiplication factor (used to interpret payoffs)
- `history`: record of all players' actions per round (perfectly observed)

#### Internal state variables
- `punish_rounds_remaining`: integer counter initially 0, counts how many remaining rounds to defect as punishment
- `forgiveness_duration`: fixed integer (e.g., 2 rounds) — number of rounds to punish after defection before returning to cooperation

---

### Decision Rules

**Round 1: Cooperate**  
- No previous history exists. Start by cooperating to establish mutual trust.

**Round t > 1:**

1. **Check punishment state:**
   - If `punish_rounds_remaining > 0`:  
     - Defect (D) this round  
     - Decrement `punish_rounds_remaining` by 1

2. **Else if not in punishment:**
   - Check previous round's cooperation status of all *other* players:
     - If *all* other players cooperated in round t-1:  
       - Cooperate (C)
     - Else (at least one defector detected in last round):  
       - Set `punish_rounds_remaining = forgiveness_duration`  
       - Defect (D) this round (start punishment)

**Last round (t = r):**

- Defect (D), because no future rounds remain to incentivize cooperation — standard backward induction logic for finite repeated games.

---

### Summary in Pseudocode

```
initialize:
  punish_rounds_remaining = 0
  forgiveness_duration = 2  # tunable; balance between retaliation and forgiveness

for each round t in 1..r:
  if t == r:
    action = D  # last round defection
  else if punish_rounds_remaining > 0:
    action = D
    punish_rounds_remaining -= 1
  else if t == 1:
    action = C  # start cooperating
  else:
    previous_round = t - 1
    if all other players cooperated in previous_round:
      action = C
    else:
      punish_rounds_remaining = forgiveness_duration
      action = D
```

---

### Explanation & Rationale

- **Cooperative:** Always starts cooperating and tries to maintain cooperation indefinitely with others who do the same.
- **Conditional Reciprocity:** Punishes observed defections so as to deter free-riding but only temporarily, to provide robustness against mistakes or transient defection.
- **Deterrence vs. Forgiveness:** Punishing for `forgiveness_duration` rounds is long enough to discourage defectors but allows eventual return to cooperative equilibrium.
- **Last Round Defection:** Defects in the final round to avoid being exploited since no future reward is possible (classic finite-horizon game logic).

---

### Edge Cases Handled

- **First Round:** Cooperate without prejudice — no history available.
- **Mistakes / Noise:** Forgiveness window allows recovery after defections.
- **Final Round:** Defection due to backward induction — behavior fully rational.
- **Multiple Defectors:** All defections trigger punishment (defecting for set rounds).
- **Partial Cooperation:** Cooperates only if all cooperated in previous round; pragmatically sets a high standard of cooperation.
- **No Communication:** Uses only observed actions, no assumptions beyond game information.

---

### Strategic Properties

- Promotes maximal collective payoff by encouraging cooperation.
- Punishes freeriders preventing exploitation.
- Forgiveness fosters return to cooperation facilitating stable cycles of cooperation over repeated rounds.
- Straightforward, transparent logic easing opponent interpretations.
- Matches well the payoff incentives: cooperators get max public good share if all cooperate.

---

If you want, I can also provide variations (e.g., tit-for-tat style or probabilistic forgiveness), but this Grim Trigger with limited forgiveness strikes a solid cooperative balance for the tournament context.
'''

description_COOPERATIVE_18 = '''
Below is a cooperative strategy designed for the repeated N-player public goods game described, aiming to maximize joint payoffs via sustained cooperation but also guarding against persistent defection.

---

## Cooperative Strategy: **Reciprocal Conditional Cooperation**

### Intuition

- Encourage mutual cooperation to reach Pareto optimal collective payoffs.
- Start cooperatively to signal willingness to collaborate.
- Monitor others’ behavior based on observed cooperation rates.
- Retaliate only if defection is consistent to discourage exploitation.
- Forgive defection after punishment phase to restore cooperation.
- In the final round, cooperate unconditionally since no future retaliation is possible (but cooperating still maximizes collective payoff).

---

### Decision Rules

**Terminology:**

- Let `t` ∈ {1,...,r} be the current round.
- For each player j, `history_j` = list of their past actions.
- Define `cooperators_in_last_round` = number of players (including self) who cooperated in round t-1.

**Parameters:**

- `defect_threshold` = n/2 (majority threshold for defectors to trigger retaliation phase)
- `punishment_length` = 1 (number of rounds to defect in retaliation)
  
You may tune these if you want.

---

### Pseudocode

```
Initialize:
    punishment_mode = False
    punishment_rounds_left = 0

For round t in 1 to r:

    if t == 1:
        # First round: cooperate to signal good faith
        play C
        continue

    if t == r:
        # Last round: cooperate unconditionally (endgame)
        play C
        continue

    if punishment_mode:
        # We are punishing defectors for one round
        play D
        punishment_rounds_left -= 1
        if punishment_rounds_left == 0:
            punishment_mode = False
        continue

    # Not in punishment mode, judge past round

    # Observe how many cooperated in previous round
    count_cooperators = number of players who played C in round t-1

    if count_cooperators < defect_threshold:
        # Defection was frequent; enter punishment mode
        punishment_mode = True
        punishment_rounds_left = 1
        play D
        continue

    else:
        # Majority cooperated last round; cooperate to reciprocate
        play C
```

---

### Explanation

- **Round 1**: Start with cooperation to establish mutual trust.
- **Rounds 2 to r−1**:

  - If majority cooperated last round, cooperate now to maintain high collective payoff.
  - If majority defected last round, punish by defecting once.
  - Afterwards, return to cooperation assuming others may forgive too.
  
- **Round r (last round)**: Cooperate regardless because no incentive to punish last round defectors—future retaliation is impossible, and mutual cooperation yields the highest final payoff.

---

### Edge Cases Handling

- **If no one defects ever**: You cooperate every round, achieving maximum collective payoff.
- **If sporadic defectors**: Single round defections trigger quick punishment but then resume cooperation, encouraging return to cooperative norms.
- **If persistent defectors (majority defecting multiple rounds)**: You continually punish, preventing them from unilaterally exploiting cooperation.
- **If only a minority defects at times**: You continue cooperating, not over-reacting to isolated defection.
- **Information completeness**: Since full action history is known, the punishment decision is perfectly informed.
  
---

### Cooperative alignment

- The strategy fosters cooperation as the norm.
- Retaliation is limited in scope and duration to avoid needless long-term breakdowns.
- Forgiveness enables recovery from mistakes or occasional lapses.
- Unconditional cooperation in Round 1 and Round r signals friendly intentions and maximizes joint payoff.

---

**In summary**, this "Reciprocal Conditional Cooperation" strategy balances willingness to cooperate with calibrated retaliation to maintain cooperation against self-interested defectors across multiple rounds, explicitly considering the public goods payoff structure and simultaneous actions without communication.
'''

description_COOPERATIVE_19 = '''
**Cooperative Strategy: Conditional Mutual Cooperation with Forgiveness**

---

### Intuition and Goals
- **Goal:** Maximize total joint payoff by sustaining cooperation as long as others cooperate.
- **Challenge:** Without communication, must rely solely on observing others' past actions.
- **Key:** Cooperate initially and continue cooperating if others cooperate; punish defections to discourage free-riding but forgive eventually to restore cooperation.
- **Last round:** Defection is rational (no future punishment), so defect in the last round.

---

### Decision Rules

Let the history up to round *t-1* be denoted \( H^{t-1} = \{ (a_1^1, ..., a_n^1), ..., (a_1^{t-1}, ..., a_n^{t-1}) \} \)  
where \( a_i^s \in \{C, D\} \) is player \(i\)'s action in round \(s\).

Denote:
- \(C_{-i}^s =\) number of other players (excluding player \(i\)) who cooperated in round \(s\).
- Threshold \( \theta = n - 1 \) (full cooperation by others), or a relaxed threshold if desired.
- Forgiveness window \( f \geq 1 \) rounds (e.g., \(f=1\)).

---

### Strategy Description

- **Round 1:** Cooperate unconditionally.  
  *Rationale:* Signal willingness to cooperate, start the cooperative equilibrium.

- **Rounds \(2 \le t < r\):**  
  1. **Check past cooperation:** If *all other players* cooperated in the previous round (\(C_{-i}^{t-1} = n-1\)), **cooperate** this round.  
  2. **If any defection detected (at least one other defected in round \(t-1\)):**
     - Enter **punishment** phase: defect this round as a response to signal that defection is costly.
     - Punish only for \(f\) rounds after the last defection observed.
     - After \(f\) rounds of punishment, attempt to **forgive** by cooperating again, giving cooperation a chance to be re-established.

- **Round \(r\) (final round):** Defect unconditionally.  
  *Rationale:* No future rounds to enforce cooperation; defect maximizes immediate payoff.

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, history, player_index, forgiveness=1):
    """
    t: current round (1-based)
    r: total rounds
    n: number of players
    history: list of tuples of actions for rounds 1..t-1
    player_index: index of this player (0-based)
    forgiveness: number of rounds to punish after defection detected
    """
    
    # Last round: defect
    if t == r:
        return 'D'
    
    # Round 1: cooperate unconditionally
    if t == 1:
        return 'C'
    
    # For rounds 2 to r-1:
    # 1) Check if any other player defected last round
    last_round = history[-1]
    others_last = [last_round[i] for i in range(n) if i != player_index]
    
    if all(action == 'C' for action in others_last):
        # Others cooperated last round -> cooperate
        return 'C'
    else:
        # Defection occurred last round: enter punishment
        
        # Find last defection round among others in history
        last_defection_round = None
        for past_round in reversed(range(len(history))):
            round_actions = history[past_round]
            defection_in_round = any(
                (i != player_index and round_actions[i] == 'D') for i in range(n)
            )
            if defection_in_round:
                last_defection_round = past_round + 1  # Convert 0-based to 1-based round
                break
        
        # Calculate how many rounds have passed since last defection
        rounds_since_defection = t - last_defection_round
        
        # Punish for 'forgiveness' rounds, then forgive (cooperate)
        if rounds_since_defection <= forgiveness:
            return 'D'  # punish
        else:
            return 'C'  # forgive and try cooperation again
```

---

### Explanation and Rationale

- **Initial cooperation (Round 1):** Establishes trust baseline; no reason to start defecting first.
- **Conditional cooperation:** Reward others’ cooperation immediately; this sustains maximal joint payoffs.
- **Punishment:** Defecting in response to observed defection raises cost for defectors.
- **Forgiveness:** By limiting punishment duration, allows recovery in case defections were mistakes or retaliatory spirals.
- **Final round defection:** Standard backward induction result; no incentive to cooperate in the last round.

---

### Cooperative Mindset Alignment

- This strategy **prefers cooperation** whenever possible.
- It **discourages free-riding** via targeted punishment.
- It **prevents endless retaliation** by forgiving after short punishment.
- It **maximizes social welfare** by maintaining cooperation except when exploitation is detected.
- It **recognizes rational endgame defection** as unavoidable and adopts it accordingly.

---

### Optional Extensions

- Use a tolerance threshold less than \(n-1\) cooperators (e.g., cooperate if ≥ \(n-2\) others cooperated).
- Increase forgiveness length to stabilize cooperation in noisy environments.
- Track defectors individually and punish only those players selectively (requires more complex memory).

---

**In summary:**  
The strategy is a variant of *Generous Tit-for-Tat* adapted to a public goods setting with multiple players and simultaneous moves. It ensures cooperative outcomes by cooperating initially and as long as others cooperate, punishing defections temporarily to deter exploitation, and forgiving to allow cooperation to resume, while defecting in the last round rationally.
'''

description_COOPERATIVE_20 = '''
Below is a cooperative strategy for the repeated Public Goods Game described. The strategy is designed to achieve (and maintain) mutual cooperation while punishing defections to enforce cooperation, and to be forgiving enough to recover cooperation after mistakes. It respects the repeated game nature, uses observed history only, and does not rely on any external coordination.

---

## Strategy Name: **Reciprocal Grim-Trigger with Forgiveness**

### Intuition
- Cooperate initially.
- Continue cooperating as long as all other players cooperated in the immediately preceding round.
- If any player defects, respond by defecting in the next round to punish defection.
- But do not defect forever: After one round of defection as punishment, return to cooperating to give cooperation another chance.
- On the last round, defect to avoid being exploited, since there's no future punishment.

This strategy:
- Maximizes joint payoff by sustaining cooperation.
- Deterrs deviations by punishing defectors promptly.
- Forgives after punishment to allow recovery.
- Defects in the final round to protect yourself from exploitation.

---

## Detailed Decision Rules:

**Notation:**
- Let *t* be the current round (1 ≤ t ≤ r).
- Let History(t-1) be the vector of all players' actions in the previous round.
- Let *A_i(t)* be your action at round t.
- *C* = Cooperate (contribute)
- *D* = Defect (keep endowment)

---

### Action Decision at round t:

1. **If t == 1 (the first round):**  
   - Play **C** (cooperate).

2. **If t == r (the last round):**  
   - Play **D** (defect) to avoid exploitation (standard backward induction in finitely repeated games).

3. **If any player defected in round t-1:**  
   - Play **D** (punish defection) this round.

4. **Otherwise (all cooperated in round t-1):**  
   - Play **C** (cooperate).

5. **If you just defected in round t-1 to punish:**  
   - On this round, return to **C** (forgive and restore cooperation).

---

### Summary Pseudocode

```python
# Inputs:
# - t: current round
# - r: total rounds
# - history: list of length (t-1), each element is a list of players' actions in that round

def decide_action(t, r, history):
    if t == 1:
        return 'C'  # start cooperating
    
    if t == r:
        return 'D'  # defect in final round
    
    previous_round_actions = history[-1]  # actions of all players in round t-1
    
    # Check if anyone defected in previous round
    anyone_defected = any(a == 'D' for a in previous_round_actions)
    
    # Check what you played in previous round (assume index i known)
    my_previous_action = previous_round_actions[my_index]
    
    if anyone_defected:
        # If you cooperated last round, punish by defecting this round
        if my_previous_action == 'C':
            return 'D'
        # If you just defected to punish, now forgive and cooperate
        else:
            return 'C'
    else:
        # Everyone cooperated last round, so cooperate
        return 'C'
```

---

### Notes and Justification

- **First Round Cooperate:** Sets a cooperative tone; no reason to defect first.
- **Triggering Punishment:** If anyone defects, punish immediately by defecting once to lower incentives to defect.
- **One-Round Punishment:** Only defect once after detecting defection to avoid endless mutual defection.
- **Forgiveness:** Returning to cooperation after punishment encourages return to cooperative equilibrium and avoids prolonged losses.
- **Last Round Defect:** Standard finitely repeated game logic where no future punishment exists; defecting protects from exploitation.
- **Memory Length:** Strategy only requires memory of previous round’s actions (simple and efficient).
- **No Assumptions about Others:** Punishment applies if any defection detected, irrespective of identity.  
- **Perfect Information:** Full visibility of all players' actions supports precise punishment and forgiveness.

---

### Potential Dynamics

- If all players adopt this strategy, cooperation will be sustained until the final round.
- Any accidental or intentional defection triggers a short punishment but cooperation resumes quickly.
- Defecting on the last round protects you even if others cooperate then defect.
- Strategy balances cooperation incentives with credible punishment to sustain collective good.

---

If you want a more lenient or stricter strategy, variations are possible (e.g., longer punishment with grim trigger, probabilistic forgiveness, etc.), but this strategy is a simple, clear, and robust cooperative strategy suitable for a tournament-style environment.
'''

description_COOPERATIVE_21 = '''
Here is a cooperative strategy tailored for the described N-player public goods repeated game. It leverages conditional cooperation and forgiveness while taking into account the incentives and knowledge constraints:

---

## Strategy Name: **Gradual Reciprocity with Forgiveness**

---

### Intuition
- Begin by cooperating to signal a cooperative attitude.
- Continue cooperating as long as all players cooperated in the previous round (full cooperation).
- If any defection is detected in the previous round, defect once as a "punishment."
- After punishing once, forgive and resume cooperation to try restoring full cooperation.
- In the last round, defect to maximize individual payoff—since no future rounds remain to sustain cooperation incentives.

This approach encourages mutual cooperation to maximize group payoffs, avoids persistent retaliation that undermines cooperation, and aligns with backward induction logic in repeated games with a known finite horizon.

---

### Detailed Decision Rules

#### Variables:
- Let t be the current round number, t ∈ {1, 2, ..., r}
- Let history_{t-1} be the actions of all players in round t-1
- Define `all_cooperated_{t-1}` = True if all players played C in round t-1; False otherwise
- Define `punished_last_round` flag to track if we punished in the previous round

---

### Decision Logic:

**At round t = 1 (first round):**  
- Cooperate (play C). Start with goodwill, no history to condition on.

**For rounds 2 ≤ t < r (middle rounds):**  
- If `all_cooperated_{t-1} == True`:  
  → Cooperate (play C). All cooperated last round, maintain cooperation.  
  → Clear `punished_last_round` flag (set to False) if it was True.  
- Else (at least one defection detected in previous round):  
  - If `punished_last_round == False`:  
    → Defect (play D) once to punish defection.  
    → Set `punished_last_round` = True.  
  - Else (`punished_last_round == True`):  
    → Cooperate (play C) to forgive and try to rebuild cooperation.

**At round t = r (last round):**  
- Defect (play D). No incentive to cooperate since no future rounds remain for punishment or reward.

---

### Pseudocode

```python
initialize punished_last_round = False

for t in 1 to r:
    if t == 1:
        action = 'C'  # Initial cooperation

    elif t == r:
        action = 'D'  # Last round: defect

    else:
        if all_cooperated_in(round=t-1):
            action = 'C'
            punished_last_round = False
        else:
            if punished_last_round == False:
                action = 'D'  # Punish once
                punished_last_round = True
            else:
                action = 'C'  # Forgive and try to restore cooperation

    play(action)
```

---

### Rationale and Benefits

- **First round cooperation** shows willingness to cooperate, encouraging reciprocation.
- **Full cooperation continuation** sustains maximum joint payoffs ((k/n) × n = k > 1).
- **Single-round punishment** signals disapproval of defection without escalating conflict.  
- **Forgiveness** prevents endless defection cycles and promotes cooperation restoration.
- **Last round defection** aligns with backward induction since cooperation cannot be enforced after the last round.
- This strategy does not depend on complex opponent models or communication, only on observed actions.
- It is "nice" (never defects first except last round), retaliatory (punishes defection once), and forgiving—qualities known to support cooperation in repeated games.

---

### Edge Cases

- If multiple players defect in the first round, your first response in round 2 will be to defect once, then after that forgive.
- If all defect persistently, you end up defecting from round 2 onward except on punishment forgiveness cycles, avoiding exploitation.
- The strategy tolerates occasional mistakes or noise by forgiving after single defections.
- Works under perfect monitoring; all past actions are observable.

---

### Summary

| Round       | Condition                    | Action  | Notes                      |
|-------------|------------------------------|---------|----------------------------|
| 1           | No history                   | C       | Start cooperatively         |
| 2 to r-1    | All cooperated last round    | C       | Maintain cooperation        |
| 2 to r-1    | Defection(s) last round      | D (once) or C (forgive) | Punish once, then forgive   |
| r (last)    | Any                         | D       | Defect to maximize payoff   |

---

This strategy robustly fosters cooperation but does not naïvely tolerate opportunistic defection. It is fully specified for implementation and integration into the tournament environment.
'''

description_COOPERATIVE_22 = '''
Here is a cooperative strategy designed for the N-Player Public Goods Game described:

---

## Strategy Name: "Conditional Cooperation with Forgiveness"

### Intuition
- Cooperate initially to try to establish a cooperative environment.
- Continue cooperating as long as a sufficient number of other players cooperate (indicating a cooperative equilibrium).
- If cooperation breaks down (too few cooperators), punish defectors by defecting.
- However, allow for forgiveness by returning to cooperation if others rebuild cooperation.
- In the last round, defect because no future punishment is possible (standard backward induction in finitely repeated games).

---

## Detailed Description and Decision Rules

---

### Notation
- Let `round` ∈ {1, ..., r} be the current round.
- Let `history` be the record of actions of all players in all previous rounds.
- Let `c_count_t` be the number of cooperators in round t: sum of contributions by all players.
- Let `min_coop_threshold` be the minimum fraction of cooperators (other than self) required to maintain cooperation in current round. (e.g., 50% or more of other players)
- Action `C` = cooperate; `D` = defect.

---

### Key Parameters (tunable)
- `min_coop_threshold = 0.5` (50% of other players must cooperate to continue cooperating)
- This threshold balances forgiveness and punishment, encouraging cooperation but deterring free-riding.

---

### Rule 1: First Round (round = 1)
- Cooperate (C)
- Since no history, start cooperatively to signal willingness.

---

### Rule 2: Intermediate Rounds (1 < round < r)
- Observe the number of cooperators in previous round, `c_count_{round-1}`.
- Calculate fraction of cooperators excluding self (if played C previously), or including all others if played D:
  - If self cooperated last round: `coop_fraction = (c_count_{round-1} - 1) / (n - 1)`
  - Else: `coop_fraction = c_count_{round-1} / (n - 1)`

- Decision:
  - If `coop_fraction >= min_coop_threshold`:  
    Cooperate this round (C)
  - Else:  
    Defect this round (D)

- This means you only cooperate if a majority of the others cooperated last round; else you defect as a mild punishment.

---

### Rule 3: Last Round (round = r)
- Defect (D)
- No incentive to cooperate since no future rounds to punish or reward.

---

### Rule 4: Forgiveness & Repair
- When defecting due to low cooperation last round, monitor if cooperation recovers.
- Because the rules always check the last round's cooperation, once others start cooperating, you resume cooperation immediately.

---

## Pseudocode

```python
def decide_action(round, r, n, history, self_index):
    C = 'C'
    D = 'D'
    min_coop_threshold = 0.5
    
    # Last round: always defect
    if round == r:
        return D
    
    # First round: always cooperate
    if round == 1:
        return C
    
    # Calculate number of cooperators in the previous round
    last_round_actions = history[round - 2]  # zero-based index
    c_count = sum(1 for a in last_round_actions if a == C)
    
    # Determine if self cooperated last round
    self_cooperated_last_round = (last_round_actions[self_index] == C)
    
    if self_cooperated_last_round:
        coop_fraction = (c_count - 1) / (n - 1)
    else:
        coop_fraction = c_count / (n - 1)
    
    if coop_fraction >= min_coop_threshold:
        return C
    else:
        return D
```

---

## Cooperative Alignment
- The strategy **starts cooperatively** to attempt cooperation.
- It **rewards cooperation** when a majority of others also cooperate.
- It **punishes defection** by defecting if cooperation drops too low.
- It **recovers cooperation quickly** once others start cooperating again (forgiveness).
- It **avoids wasted cooperation in the last round** by defecting.

This strategy plays a conditional cooperation style akin to a forgiving "grim trigger" but with recovery conditions, aligning well with cooperative goals in a repeated public goods setting.

---

## Edge Cases
- If all players cooperate, you always cooperate, achieving highest payoffs.
- If all defect, you quickly revert to defecting, minimizing losses.
- If some cooperate and some defect, you adjust based on observed cooperation.
- In particular, if less than half cooperate, you defect, discouraging free-riding.

---

This strategy is straightforward, robust, and cooperative, making it suitable for tournament play under the given constraints.
'''

description_COOPERATIVE_23 = '''
Below is a cooperative strategy designed for the N-player repeated Public Goods Game described. It balances an optimistic cooperative mindset with a reactive enforcement of cooperation, handling first and last rounds and incentivizing cooperation over defection.

---

## Strategy Name:
**"Conditional Cooperation with Forgiveness"**

---

## Intuition

- You want to cooperate as much as possible to achieve high joint payoffs.
- Start by cooperating to signal willingness to cooperate.
- Continue cooperating as long as all others cooperated last round (full cooperation).
- If any player defects, punish by defecting once — but then forgive and try cooperating again.
- In the last round, defect because no future punishment is possible (standard backward induction).
- This strategy promotes mutual cooperation, deters defection, and recovers after isolated defections.

---

## Decision Rules

Let:
- \( t \) denote the current round, with \( 1 \le t \le r \)
- \( c_j^{t-1} \) denote action of player \( j \) in previous round (1 if cooperate, 0 if defect)
- \( C^{t-1} = \sum_{j=1}^n c_j^{t-1} \) total number of cooperators last round
- \( \text{I\_defected\_last\_round} \) be a Boolean flag whether this player defected in the previous round as punishment to defection observed last round

---

## Actions per round \( t \):

1. **Round 1 (t = 1):**  
   - Cooperate (play \( C \)) unconditionally.  
   - Rationale: No prior history, signal willingness to cooperate.

2. **Rounds 2 to \(r-1\) (2 ≤ t < r):**  
   - If all players cooperated in round \( t-1 \) (i.e., \( C^{t-1} = n \)),  
     → Cooperate this round.  
     → Reset the "I_defected_last_round" flag to False (you are in good faith).  
   - Else (some defection detected in \( t-1 \)):  
     - If you did **not** defect last round as punishment (i.e., "I_defected_last_round" is False),  
       → Defect this round (punish defectors).  
       → Set "I_defected_last_round" = True.  
     - Else (you defected last round to punish),  
       → Forgive: cooperate this round to attempt to reset cooperation.  
       → Set "I_defected_last_round" = False.

3. **Round \( r \) (last round):**  
   - Defect unconditionally.  
   - Rationale: No future rounds to enforce cooperation; backward induction predicts defection here.

---

## Summary Table of Decision Logic

| Round | Condition                                      | Action | Notes                           |
|-------|------------------------------------------------|--------|---------------------------------|
| 1     | Always                                        | C      | Signal cooperation               |
| 2 to r-1 | All cooperated last round (full cooperation) | C      | Maintain cooperation             |
| 2 to r-1 | Defection observed last round                | D if did not punish last time, else C | Punish once, then forgive |
| r     | Any                                            | D      | Last round defection             |

---

## Pseudocode

```python
# Initialize state variable
I_defected_last_round = False

def decide_action(t, history_actions, n, r):
    """
    t: current round number (1-based)
    history_actions: list of length t-1, each element is a list of n actions (C=1, D=0)
    n: number of players
    r: total rounds
    Returns: 1 (C) or 0 (D)
    """

    # Last round actions if applicable
    if t > 1:
        last_round_actions = history_actions[-1]
        total_cooperators = sum(last_round_actions)
    else:
        last_round_actions = []
        total_cooperators = 0

    # Round 1: Cooperate
    if t == 1:
        return 1  # Cooperate

    # Last round: Defect unconditionally
    if t == r:
        return 0  # Defect

    # Rounds 2 to r-1
    if total_cooperators == n:
        # Everyone cooperated last round
        # Reset punishment flag and cooperate
        I_defected_last_round = False
        return 1  # Cooperate

    else:
        # Defection(s) detected last round
        if not I_defected_last_round:
            # Punish by defecting once
            I_defected_last_round = True
            return 0  # Defect punish
        else:
            # Forgive, try cooperating
            I_defected_last_round = False
            return 1  # Forgive & cooperate
```

---

## Explanation of Why This is Cooperative

- This strategy **starts cooperatively** to foster trust.
- It **cooperates as long as full cooperation is observed**, maximizing joint payoffs.
- It **punishes defection swiftly but only once**, discouraging exploitation.
- It **forgives after punishment**, allowing cooperation to resume quickly.
- By defecting in the **final round**, it aligns with rational backward induction but does not undermine cooperation before the final round.
- It requires **no communication or shared norms**, relying only on observed actions and simple internal state.

---

This strategy has been shown in public goods and Prisoner’s Dilemma type games to sustain cooperation by supporting mutual cooperation while protecting itself from persistent exploitation. It is simple enough to be recognized by other players over repeated rounds, and robust enough to withstand occasional defections.
'''

description_COOPERATIVE_24 = '''
Below is a detailed cooperative strategy designed for the N-Player Public Goods Game described. This strategy aims to maximize joint payoffs through mutual cooperation, while guarding against exploitation by defectors. It uses conditional cooperation informed by observed player actions each round.

---

## Strategy Name: "Conditional Forgiving Cooperator"

### Intuition
- Always start cooperative to signal goodwill.
- Continue cooperating as long as all players cooperate.
- If defection is detected, punish defectors by defecting for one round to discourage free-riding.
- After punishment, return to cooperating if no more defections happen.
- On the last round, defect to gain a slight private benefit (standard backward induction logic).
- This approach encourages cooperation by rewarding cooperation and punishing defection but allows forgiveness, helping restore cooperation after accidental or strategic defections.
  
---

## Decision Rules

### Notation
- `t` = current round (1 ≤ t ≤ r)
- `history[t-1]` = set of all players' actions in previous round `(t-1)`, empty if `t=1`
- `defectors[t-1]` = set of players who defected in round `(t-1)`
- `my_last_action` = this player's own action in previous round
- coop_threshold = 0 (means any defection triggers punishment)
- `defect_next` = boolean flag whether to defect this round as punishment

### Rules per round `t`:

**Round 1:**
- Cooperate
- Set `defect_next = False`

**Round t where 1 < t < r (intermediate rounds):**
- If `defect_next` is True (punishment phase):
  - Defect this round.
  - Reset `defect_next = False` (punish only 1 round).
- Else:
  - If **everyone cooperated** in round `t-1`:
    - Cooperate.
  - Else (there was ≥1 defector in round `t-1`):
    - Set `defect_next = True` to punish next round.
    - Cooperate this round (forgiving and signaling willingness to return).
  
**Round r (last round):**
- Defect (standard backward induction, defection dominant in final round).

---

## Explanation / Rationale

- **Start cooperative:** Establish trust and maximize initial payoff.
- **Punishment phase:** Defection by any player triggers a one-round punishment round where you defect, lowering the defector's payoff to discourage free-riding.
- **Forgiving:** You do not punish immediately by defecting the very next round after observing defection, but wait one round, cooperating once before punishing in next round (`defect_next` flag). Alternatively, a one-shot defect immediately after detection can be used, but the current design punishes next round for clarity.
- **Return to cooperation:** After punishment, if no further defection occurs, cooperation resumes.
- **Last round:** Defect to avoid exploitation—cooperation can't be enforced after last round.

---

## Pseudocode

```python
def decide_action(t, r, history, my_index, defect_next):
    """
    Parameters:
        t (int): current round (1-based)
        r (int): total rounds
        history (list of list): history of players' actions per round; actions ∈ {'C', 'D'}
        my_index (int): index of this player (0-based)
        defect_next (bool): flag indicating if we should defect this round as punishment
    
    Returns:
        action (str): 'C' or 'D'
        defect_next (bool): updated flag for next round
    """
    
    if t == 1:
        # Start cooperative
        defect_next = False
        return 'C', defect_next
    
    if t == r:
        # Last round: defect (backwards induction)
        return 'D', defect_next
    
    # Intermediate rounds (1 < t < r)
    last_round_actions = history[t-2]  # actions in round t-1
    all_cooperated = all(a == 'C' for a in last_round_actions)
    
    if defect_next:
        # Punish by defecting this round, then reset flag
        defect_next = False
        return 'D', defect_next
    
    if all_cooperated:
        # Everyone cooperated last round, cooperate now
        return 'C', defect_next
    else:
        # Defectors detected; cooperate now, but set flag to defect next round as punishment
        defect_next = True
        return 'C', defect_next
```

---

## Summary

| Round       | Action Rule                                                                     |
|-------------|---------------------------------------------------------------------------------|
| 1           | Cooperate                                                                       |
| Intermediate (2 to r-1) | If currently punishing, defect; else if all cooperated last round, cooperate; else cooperate now but schedule defect in next round to punish defectors |
| r (last)    | Defect                                                                          |

This strategy is **clearly cooperative**: it seeks to maintain universal cooperation through conditional cooperation and limited, proportional punishment. It also uses **perfect information** from observed history without assuming any communication or reputation beyond actions. The forgiving nature helps repair cooperation and prevents endless retaliation cycles.

---

If you want me to, I can also consider variants such as punishing immediately or punishing all defectors by also defecting yourself a second time before returning to cooperation. But the above design is robust, straightforward, and aligns well with the game's logic and incentive structure.
'''

description_COOPERATIVE_25 = '''
Here's a cooperative strategy tailored for the repeated n-player public goods game under the given conditions. It balances being cooperative while providing incentives to punish persistent defection, thereby fostering cooperation.

---

### Strategy Name: **Conditional Cooperation with Forgiveness**

---

## Intuition

- Start by cooperating to show willingness to build trust.
- Continue cooperating as long as a sufficient number of players cooperated recently.
- If defection is detected (some defectors), punish by defecting once, but then forgive and return to cooperation to avoid endless retaliation.
- Always cooperate in the last round, since there is no future punishment incentive.
- This strategy aims to maximize mutual cooperation for benefit, but it is robust against exploiters by switching temporarily to defection.

---

## Decision Rules

Let:
- \( t \) = current round (1 ≤ t ≤ r)
- \( H_{t-1} \) = action history of all players through round \( t-1 \)
- \( C_{t-1} \) = number of cooperators in round \( t-1 \)
- \( T = \) number of players (n)

---

### 1. First Round (t = 1)

- Cooperate (C).
  
  **Reason:** No history to judge others; start cooperatively to build mutual cooperation.

---

### 2. Intermediate Rounds (1 < t < r)

- If **previous round** had at least \( \tau \) cooperators (including myself if cooperated),
  
  - Cooperate (C) in round \( t \).
  
- Else (some defection detected):
  - Defect (D) once this round as punishment.
  - Next round, forgive and return to cooperation regardless of actions in this round.
  
---

### 3. Last Round (t = r)

- Cooperate (C) unconditionally.
  
  **Reason:** No future rounds to enforce cooperation; avoid mutual defection losses.

---

## Threshold Parameter

- Let \( \tau = \lceil \alpha \cdot n \rceil \) for some \( \alpha \in (0,1) \), e.g., \( \alpha = 0.7 \).
- The threshold means: Cooperate if at least \( 70\% \) of players cooperated last round.
- This allows tolerance for occasional defection/mistakes but still demands a strong majority cooperating to keep cooperating.

---

## Handling Forgiveness State

- Track a binary state variable `punished_last_round`:
  - If punishment defect was applied last round, set True.
  - If `punished_last_round` is True now, cooperate this round (forgiveness) and reset to False.
  
---

## Full Pseudocode

```pseudocode
Parameters:
  n: number of players
  r: total rounds
  alpha = 0.7
  tau = ceil(alpha * n) // cooperation threshold

State Variables:
  punished_last_round ← False

Function decideAction(t, H):
  if t == 1:
    // First round, cooperate
    punished_last_round ← False
    return C

  if t == r:
    // Last round, cooperate no matter what
    punished_last_round ← False
    return C

  // For intermediate rounds
  prev_actions = H[t-1]  // Actions of all players in previous round
  num_cooperators = count of C in prev_actions

  if punished_last_round:
    // Forgive this round by cooperating
    punished_last_round ← False
    return C

  if num_cooperators >= tau:
    // Previous round had enough cooperating players, cooperate
    punished_last_round ← False
    return C
  else:
    // Defect as punishment this round
    punished_last_round ← True
    return D
```

---

## Notes on Strategy Dynamics

- **Kickstarting cooperation:** Always cooperate first to signal willingness.
- **Withstand noise:** Allows up to roughly 30% defection without immediate punishment to avoid cycles triggered by noise/errors.
- **Punishment as a deterrent:** A single round of defection punishes the group when cooperation dips.
- **Forgiveness:** Avoid endless retaliation loops by forgiving immediately, encouraging return to cooperation.
- **Last round cooperation:** Avoids wasted mutual defection when future punishment is impossible.

---

## Why This Strategy is Cooperative?

- Its default behavior is cooperation.
- It only defects to sanction reduced cooperation from the group, targeting overall cooperation rates rather than individual defection.
- It quickly forgives to return to mutual cooperation.
- This fosters a cooperative environment and aims to maximize group payoff over repeated rounds.

---

If implemented in a tournament with similarly minded or cooperative strategies, this should sustain cooperation and generate relatively high payoffs for all involved. Against defectors, it applies limited but clear punishment without harsh permanent retaliation, balancing robustness and cooperation.
'''

description_COOPERATIVE_26 = '''
Here's a cooperative strategy tailored for the repeated N-Player Public Goods Game, designed to encourage mutual cooperation, punish defectors proportionally, and forgive occasionally to restore cooperation. The strategy uses simple, transparent decision rules based solely on observed past actions, without relying on communication or assumptions about norms.

---

## Strategy: **Reciprocal Conditional Cooperation with Forgiveness**

### Intuition
- Start by cooperating to signal willingness to cooperate.
- Continue cooperating if everyone cooperated last round.
- If defections occur, punish defectors by defecting conditionally, but only for one round to avoid endless retaliation.
- Forgive after a punishment round if cooperation is resumed.
- Defect in the last round (to avoid being exploited), a standard endgame effect.

---

### Decision Rules

Let:

- `round` = current round number (1 to r)
- `history` = all players' actions in previous rounds, known perfectly
- `last_round_actions` = vector of all players' actions in round `round - 1`
- `my_last_action` = my own action in round `round - 1`
- `defectors_last_round` = set of players who defected last round

---

#### At round 1 (first round):

- Cooperate (C)
  
Reason: Establish baseline cooperation.

---

#### At rounds 2 to r - 1 (middle rounds):

- If **everyone cooperated in the last round** (i.e., `defectors_last_round` is empty):

    - Cooperate (C)
    
    Reason: Mutual cooperation maximizes payoffs.

- Else (some players defected last round):

    - **Punish** all defectors by defecting this round.

        - If I defected last round, continue defecting **only for this punishment round**.
        - If I cooperated last round, defect **only if I was defected upon last round**?  
          Since the game is simultaneous, I can't be defected upon personally, only observe group actions. So punishment is against defectors collectively.
        
    - **Forgive after one-round punishment**, i.e., return to cooperation if all cooperate in the previous round.

**Implementation detail for my choice:**

- Since the game is simultaneous, I can't target defectors individually, only condition my action on previous round's defectors.

- Therefore, if **I was a defector last round** (i.e., I was defecting), I defect again only during punishment, then try to return to cooperation after.

- If I was a cooperator, but others defected last round, I defect this round to punish defectors, then return to cooperation if cooperation resumes.

---

#### At round r (last round):

- Defect (D)

Reason: Standard backward induction logic in finitely repeated games, cooperation is not stable in last round as no future punishment is possible.

---

### Summary Table

| Round          | Condition                            | Action         |
|----------------|-----------------------------------|----------------|
| 1 (first)      | N/A                               | Cooperate (C)  |
| 2..r-1 (middle)| All cooperated last round          | Cooperate (C)  |
| 2..r-1 (middle)| Some defectors last round          | Defect (D)     |
| r (last)       | N/A                               | Defect (D)     |

---

## Pseudocode

```python
def decide_action(round, r, history, my_index):
    if round == 1:
        # First round: Cooperate
        return 'C'
    
    if round == r:
        # Last round: Defect
        return 'D'
    
    # Extract last round's actions
    last_round_actions = history[round - 2]  # zero-based index
    
    # Identify defectors last round
    defectors_last_round = [i for i, a in enumerate(last_round_actions) if a == 'D']
    
    if len(defectors_last_round) == 0:
        # All cooperated last round: Cooperate
        return 'C'
    else:
        # Some defectors last round: Defect this round to punish
        
        # Optional refinement: Only punish defectors, but since actions simultaneous, punish all by defecting
        return 'D'
```

---

## Rationale & Notes

- Cooperate initially to build trust.
- Continue cooperating if no defections observed last round.
- Punish defectors by defecting immediately after their defections.
- Forgive by returning to cooperation if all cooperate again on subsequent rounds.
- Defect in last round as no incentive to cooperate (standard backward induction).
- This strategy:

  - Encourages cooperation to yield payoff ~`k` per player.
  - Protects against exploitation by punishing defectors.
  - Avoids infinite cycles of retaliation by forgiving immediately after punishment.
  
- Is simple, robust, and does not rely on complex beliefs or equilibrium refinements.
  
---

If the tournament environment includes diverse strategies, this should facilitate forming cooperative equilibria with any others using simple reciprocity principles, while deterring free-riding.
'''

description_COOPERATIVE_27 = '''
Here is a cooperative strategy designed for the N-Player Public Goods Game under the given conditions.

---

### Strategy Name: **"Forgiving Conditional Cooperator"**

---

### Intuition and Goals
- Begin cooperating to signal good intent and encourage cooperation from others.
- Continue cooperating if others also cooperate, to maintain mutual benefit.
- Defect immediately if others defect as a punishment, to avoid exploitation.
- Forgive after one round of defection by cooperating again, assuming a possible error or testing from others.
- Defect in the last round to avoid exploitation (backward induction argument).
  
This strategy balances cooperation, deterrence of free-riding, and forgiveness to maintain cooperation over repeated rounds.

---

### Detailed Strategy Description

---

#### 1. First Round (t = 1)
- **Action:** Cooperate (C)
  
*Rationale:* There's no history. Start by cooperating to encourage mutual cooperation and maximize total payoffs.

---

#### 2. Middle Rounds (2 ≤ t < r)

- **Observe** the previous round’s actions of all other players.

- **If all other players cooperated in previous round:**
  - **Play C**

- **Else if at least one other player defected in previous round:**
  - **If last round you defected (i.e., you retaliated then),**  
    - *Forgive:* play C (give cooperation chance to resume)
  - **Else** (you cooperated last round but others defected),
    - Retaliate by **playing D** this round.

*Rationale:*  
- Cooperate when cooperation was universal last round to sustain maximal group payoff.  
- Defect to punish defectors immediately after they defect to avoid exploitation.  
- Forgive after retaliation to restart cooperation rather than descend into endless defection.

---

#### 3. Last Round (t = r)

- **Play D**

*Rationale:*  
- In the last round, cooperation is risky because there is no future to incentivize cooperation.  
- Defecting maximizes self-payoff as others will likely defect or the incentive to cooperate is low.

---

### Summary in Pseudocode

```python
# Variables known:
# history: list of lists of past actions per round for all players (length t-1)
# self_idx: your player index (1-based)
# rounds: total number of rounds r

def decide_action(t, history, self_idx, rounds):
    if t == 1:
        # First round: cooperate
        return 'C'

    if t == rounds:
        # Last round: defect
        return 'D'

    # Get previous round actions
    prev_round = history[-1]  # list of n actions: 'C' or 'D'
    others_prev = [a for i, a in enumerate(prev_round, start=1) if i != self_idx]

    # Check if everyone cooperated last round (excluding self)
    if all(a == 'C' for a in others_prev):
        # Everyone cooperated last round, so cooperate
        return 'C'

    else:
        # At least one defector last round
        # Get own action last round
        self_prev = prev_round[self_idx - 1]

        # Get second last round (to check if we retaliated last time)
        if t > 2:
            prev2_round = history[-2]
            self_prev2 = prev2_round[self_idx -1]
        else:
            self_prev2 = 'C'  # default assumed for first round no data

        if self_prev == 'D':
            # We retaliated last round, so forgive now
            return 'C'
        else:
            # We cooperated but others defected, retaliate now
            return 'D'
```

---

### Properties and Justifications

- **Cooperative by default:** Starts and maintains cooperation if reciprocated.
- **Punishes defectors instantly:** Discourages free riding by defecting immediately after observing defection.
- **Forgiveness:** Prevents permanent breakdown of cooperation due to mistakes or tests.
- **Backward induction pruning:** Defects on last round to prevent exploitation.
- **No reliance on communication or promises:** Uses only observed previous actions.
- **Simple and robust:** Can be implemented easily and adapts dynamically to opponents’ behaviors.

---

### Edge Cases

- **If multiple players defect simultaneously:** The strategy punishes by defecting next round, but quickly forgives to avoid endless defection cycle.
- **If player is alone always defecting:** This strategy will continuously defect against them, minimizing their benefits.
- **If all cooperate:** will maintain cooperation every round except last.
- **First round:** always cooperates as no information exists.
  
---

This strategy aims to foster cooperation with rational retaliation and forgiveness, providing a good balance in repeated N-player public goods settings under uncertainty about others’ incentives.
'''

description_COOPERATIVE_28 = '''
Below is a fully cooperative strategy design for the N-player repeated public goods game that you can use or adapt for tournament entry. It emphasizes cooperation and forgiveness, using the game history only (no communication or signaling beyond observed actions).

---

## Cooperative Strategy: "Conditional Cooperation with Forgiveness"

### Intuition
- Start by cooperating to signal intent.
- Continue cooperating as long as everyone cooperated in the previous round.
- If any player defects (breaks cooperation), punish by defecting once (i.e., one round of defection to discourage free-riding).
- Then forgive and return to cooperation.
- In the last round, cooperate to maximize joint payoff (no incentive to defect late).

This promotes cooperation, punishes free-riders but allows for recovery after mistakes. It is similar in spirit to a multi-player "tit-for-tat" with leniency for noise or errors.

### Detailed Decision Rules

**Notation:**

- Let `round` ∈ {1, 2, ..., r} be the current round number.
- Let `actions_history` be the matrix of all players' past actions, indexed by rounds and players.
- Let `n` be number of players
- Let `me` be our player index

---

### Initial Round (round = 1)
- Cooperate (C).

---

### Subsequent Rounds (2 ≤ round ≤ r−1)

1. Check if **all players cooperated in previous round**:  
   If ∀ player j, `actions_history[round−1][j] == C`,  
   → Cooperate this round.

2. Else (at least one defected in previous round):  
   - If I defected **in the previous round** (I was punishing last round), **forgive now and cooperate**.  
   - Else, defect this round as punishment for defection observed last round.

---

### Last Round (round = r)

- Cooperate regardless of history to maximize joint payoff since no future retaliation is possible.

---

### Summary Behavioral Flow

| Previous Round Defection? | My Previous Action | Current Action |
|--------------------------|--------------------|----------------|
| No (all cooperated)      | Any                | Cooperate      |
| Yes                      | Defected (punishment)| Cooperate (forgive) |
| Yes                      | Cooperated         | Defect (punish)|
| Last round               | Any                | Cooperate      |

---

## Pseudocode

```python
def cooperative_strategy(round, r, n, me, actions_history):
    if round == 1:
        return 'C'  # Start by cooperating

    # Check if all cooperated in previous round
    prev_actions = actions_history[round - 1]
    all_cooperated = all(a == 'C' for a in prev_actions)

    if round == r:
        # Last round: cooperate no matter what
        return 'C'

    if all_cooperated:
        # Everyone cooperated last round — continue cooperating
        return 'C'
    else:
        # Defection(s) detected in previous round
        my_prev_action = actions_history[round - 1][me - 1]

        if my_prev_action == 'D':
            # I was punishing last round, now forgive and cooperate
            return 'C'
        else:
            # I cooperated last round, punish defectors by defecting
            return 'D'
```

---

## Additional Notes

- This strategy is **cooperative** as it promotes full cooperation if everyone reciprocates.
- It **punishes but forgives**, which prevents endless mutual defection cycles.
- On **first round**, cooperation initiates trust.
- On **last round**, cooperation maximizes joint payoff since no incentive to punish/defect exists.
- The strategy only relies on perfect observation of past actions (perfect information) and is fully defined by game history.
- No assumption of shared norms or communication is required.
- The punishment is lenient: one round of defection per defection observed.
- If multiple rounds are played, this can sustain cooperation as a stable equilibrium.

---

This strategy balances incentive for cooperation with practical forgiveness, aligning with the cooperative mindset you requested. It will compete well in tournament settings against a variety of independent opponent strategies.
'''

description_COOPERATIVE_29 = '''
Here is a cooperative strategy designed for the described N-Player Public Goods Game. It aims to sustain cooperation and punish defections proportionally, with forgiveness allowing recovery from occasional defections or noise. It also carefully handles the first and last rounds.

---

## Strategy Name: **Forgiving Conditional Cooperator**

### Intuition
- Cooperate initially to signal willingness.
- Continue cooperating as long as all others cooperated in the previous round.
- If one or more defected previously, defect once as punishment.
- After punishing, forgive and return to cooperation if all others cooperate again.
- In the last round, defect to avoid being exploited (backward induction logic).
- This strategy supports cooperation, punishes defections to deter freeriding, but allows return to cooperation rather than never-ending retaliation.

---

## 1. Decision Rules

**Notation:**
- t = current round (1 ≤ t ≤ r)
- h_{t-1} = history of all players' actions in round t-1 (empty if t=1)
- C; D = cooperate; defect
- A_i,t = my action at round t

---

### On Round 1 (t = 1):

- Cooperate (C) unconditionally.

---

### On Round t, 2 ≤ t < r (not final round):

- Observe actions of all players in round t-1.
- If **all** players cooperated in t-1 (everyone played C), then cooperate.
- Else (at least one player defected in t-1), defect to punish once.
- On the following round, regardless of defectors in t-1, forgive by cooperating again to resume cooperation unless defect detected again.

**Implementation detail:**  
Maintain a `punished` flag.  
- If punished last round, now cooperate (forgiveness).  
- If no punishment pending and defect(s) seen last round, punish by defecting this round and set `punished = True`.  
- If no defect last round, `punished = False`.  

---

### On Final Round (t = r):

- Defect (D) always.

**Reason:** No future rounds to enforce cooperation, so backward induction says defect to maximize payoff this round (avoiding being suckered).

---

## 2. Summary of Decision Logic per Round

| Round | Condition                                 | Action  | Notes                         |
|-------|------------------------------------------|---------|-------------------------------|
| 1     | Always                                  | C       | Signal cooperation            |
| 2..r-1| Last round all cooperated?               | C       | Continue cooperation          |
|       | Last round had defectors & not punished | D       | Punish defectors (once only)  |
|       | Punished last round                      | C       | Forgiveness, return to coop   |
| r     | Always                                  | D       | Defect last round             |

---

## 3. Pseudocode

```python
# Initialize state
punished = False

def decide_action(t, history, r):
    # history is list of rounds,
    # each round is list of players actions ['C' or 'D']
    # my_index is player's own index
    
    if t == 1:
        # Cooperate first round
        punished = False
        return 'C'
    
    if t == r:
        # Last round: defect
        return 'D'
    
    # For rounds 2 to r-1:
    last_round_actions = history[t-2]  # because t is 1-based, index is t-2
    
    # Check if everyone cooperated last round
    all_cooperated = all(a == 'C' for a in last_round_actions)
    
    global punished
    
    if punished:
        # Forgive this round
        punished = False
        return 'C'
    else:
        if all_cooperated:
            # Continue cooperation
            return 'C'
        else:
            # Defect once to punish defectors
            punished = True
            return 'D'
```

---

## 4. Strategy Properties and Alignment with Cooperativeness

- **Cooperative:** Starts cooperating to build trust.
- **Stable:** Continuously cooperates if no one defects.
- **Punitive:** Punishes defection but only once, avoiding endless retaliation.
- **Forgiving:** Allows return to cooperation, facilitating sustained cooperation amid noise or mistakes.
- **Predictable:** Clear pattern that helps others anticipate cooperation if they cooperate.
- **Self-interested:** Defects last round per game-theoretic reasoning, avoiding exploitation.
- **No reliance on coordination:** Uses only observable history of actions.
- **Resilient to exploitation:** Defects when others defect, so freeriders get punished.
- **Simple:** Easy to implement and interpret.

---

## 5. Handling Edge Cases

- **No defectors ever:** Always cooperates → maximum group payoff.
- **Single defection:** Punished once, then forgiveness → cooperative equilibrium recoverable.
- **Multiple defections:** Punishment triggered repeatedly, discouraging ongoing freeriding.
- **Final round:** Rational defection minimizes loss.
- **First round:** Cooperation signals willingness to cooperate.
- **Small number of rounds (e.g., r=2):** Cooperates round 1, defects round 2 → consistent.

---

This Forgiving Conditional Cooperator is designed as a straightforward and effective cooperative strategy balancing altruism and rational self-interest in the repeated public goods setting described.
'''

description_COOPERATIVE_30 = '''
Here is a cooperative strategy for the described N-Player Public Goods Game that balances incentivizing cooperation and punishing defection, designed to perform well in a tournament against unknown opponents with similar knowledge.

---

## Cooperative Strategy: "Conditional Cooperation with Forgiveness"

### Intuition
- **Start cooperatively:** Signal intent to cooperate.
- **Conditional cooperation:** Cooperate if others cooperated sufficiently in the previous round.
- **Punish defectors:** Defect if others defected, to discourage free-riding.
- **Forgiven:** Return to cooperation if cooperation resumes, to avoid endless cycles of defection.
- **Endgame behavior:** Defect in the final round (backward induction from standard game theory).

---

### 1. Decision Rules per Round

For round t = 1 to r:

- **Round 1 (t=1):**
  - Cooperate (play C)
  
- **Rounds 2 to r-1 (2 ≤ t ≤ r-1):**
  - Observe the previous round's total number of cooperators: `prev_cooperators = Σ_j c_j at round t-1`
  - Calculate proportion of cooperators: `p = prev_cooperators / n`
  - If `p >= threshold`, cooperate (C)
  - Else, defect (D)
  
- **Round r (final round):**
  - Defect (D)

---

### 2. Key Parameters

- **Threshold for cooperation:**  
  A reasonable threshold is `threshold = 0.7` (70% cooperation in previous round) to maintain cooperation while being tolerant of minor defections.

  You can tune this threshold (e.g., 0.6–0.8) to balance robustness and forgiveness.

---

### 3. Rationale

- **Why cooperate first?**  
  Encourages cooperation from others, signaling goodwill from start.

- **Why conditional cooperation based on proportion?**  
  Responds to others' behavior collectively, punishing large-scale defection and forgiving small deviations (noise, mistakes).

- **Why defect last round?**  
  Standard backward induction logic: no future rounds to incentivize cooperation, so rational to defect to maximize last-round payoff.

---

### 4. Pseudocode

```python
# Inputs:
# n: number of players
# r: number of rounds
# history: list of tuples for each round t < current round:
#          [(c_1, c_2, ..., c_n), ...] where c_i = 1 if player i cooperated, else 0

threshold = 0.7  # cooperation threshold

def decide_action(t, history):
    if t == 1:
        # First round: cooperate
        return 'C'
    elif t == r:
        # Last round: defect (no future consequences)
        return 'D'
    else:
        # Intermediate rounds: conditional cooperation
        prev_round = history[t-2]  # zero-based, previous round actions
        prev_cooperators = sum(prev_round)
        proportion = prev_cooperators / n
        
        if proportion >= threshold:
            return 'C'
        else:
            return 'D'
```

---

### 5. Handling Edge Cases

- **All players defect first round:**  
  You switch to defect next round as fraction of cooperators is 0 (below threshold).

- **Minor defection by a few players:**  
  If cooperators ≥ 70%, you continue cooperating so minor noise does not derail cooperation.

- **Recovery from defection rounds:**  
  If others return to cooperation (≥ threshold), you resume cooperating to restore mutual benefit.

- **If k is close to n (high multiplication factor):**  
  Cooperation yields high payoffs; the threshold supports stable cooperation.

- **If k is close to 1 (low multiplication factor):**  
  Cooperation is less profitable, but the strategy still attempts to foster cooperation if others do so.

---

### 6. Summary

| Round     | Condition                          | Action  |
|-----------|----------------------------------|---------|
| t = 1     | First round                      | Cooperate (C) |
| 1 < t < r | Previous round cooperation ≥ 70% | Cooperate (C) |
| 1 < t < r | Previous round cooperation < 70% | Defect (D)    |
| t = r     | Last round                      | Defect (D)    |

This strategy cooperates by default, conditions cooperation on others' cooperation level, forgives minor deviations, punishes defectors, and defects definitively in the last round.

---

If you want, variations can be made to threshold and forgiveness for tournament testing. This strategy embodies a clear cooperative mindset while rationally protecting your payoff against exploitation.
'''

description_COOPERATIVE_31 = '''
Here is a cooperative strategy for the N-Player Public Goods Game that aims to maximize collective returns by encouraging cooperation while guarding against exploitation. It balances cooperation with conditional punishment to enforce cooperation over repeated rounds:

---

## Strategy Name: **Gradual Conditional Cooperator**

### 1. Decision Rules

- **Round 1 (First round):**  
  Cooperate (C) unconditionally. Start by trusting all players to cooperate.

- **Subsequent rounds (t > 1):**  
  Let `History[t-1]` be the vector of all players’ actions in round t-1.

  Define:
  - `num_cooperators = count of players who chose C in round (t-1)`
  - `fraction_cooperators = num_cooperators / n`

  Your own action last round was `my_prev_action`.

  **Decision for round t:**  
  - If `fraction_cooperators` ≥ 0.8 (threshold for strong cooperation by group), **Cooperate (C)**
  - Else if `fraction_cooperators` < 0.8 and ≥ 0.5, **Cooperate (C)** *only if you cooperated last round*; otherwise **Defect (D)**
  - Else (`fraction_cooperators` < 0.5), **Defect (D)**

- **Intuition:**  
  - If most players cooperated last round, continue cooperating to sustain mutual benefit.  
  - If cooperation dipped moderately but you personally cooperated last round, give others a chance by cooperating again.  
  - If cooperation largely broke down, punish by defecting.

### 2. Edge Cases Handling

- **First round:**  
  No history exists, so start with full cooperation to build trust.

- **Last round (round r):**  
  Cooperate if the history in previous rounds suggests players mostly cooperated.  
  In the last round, defection can be tempting (no future retaliation), but to stay cooperative and maximize joint payoff, use the same cooperation threshold rule as in earlier rounds.

- **Endgame effect mitigation:**  
  Since no future retaliation possible after last round, this strategy accepts that others may defect in the final round, but does not defect preemptively.

- **If all players defected previous round (fraction_cooperators=0):**  
  Defect to avoid being exploited.

### 3. Cooperative Mindset

- Promotes cooperation initially and sustains it if a large fraction of players cooperate.  
- Forgives minor lapses in group cooperation by cooperating again if you yourself cooperated last round.  
- Punishes persistent and large-scale defection to incentivize cooperation.

- Never defects first except in response to large-scale defection, maintaining a cooperative starting point.

---

## Pseudocode

```python
def select_action(round_t, r, n, history, my_id):
    # history: list of length (t-1), each element is list of n actions ['C'/'D']
    
    if round_t == 1:
        return 'C'  # Cooperate unconditionally first round

    prev_round_actions = history[round_t - 2]
    num_cooperators = prev_round_actions.count('C')
    fraction_cooperators = num_cooperators / n
    my_prev_action = prev_round_actions[my_id - 1]  # zero-based index

    COOP_THRESHOLD_HIGH = 0.8
    COOP_THRESHOLD_LOW = 0.5

    if fraction_cooperators >= COOP_THRESHOLD_HIGH:
        # Strong cooperation in group: cooperate
        return 'C'
    elif fraction_cooperators >= COOP_THRESHOLD_LOW:
        # Moderate cooperation: cooperate only if you cooperated previously
        if my_prev_action == 'C':
            return 'C'
        else:
            return 'D'
    else:
        # Low cooperation in group: defect to punish
        return 'D'
```

---

### Why This Strategy?

- **Leverages common knowledge and perfect monitoring:** Can see if others are cooperating, so reciprocate and encourage cooperation when possible.  
- **Simple thresholds:** Easy to interpret cooperativeness of the group without complex modeling.  
- **Gradual retaliation:** Does not immediately punish small drops in cooperation; only punishes sustained large-scale defection.  
- **Cooperative start, sustained cooperation:** Aligns with maximizing social welfare in repeated public goods games.

---

This approach is well-suited for tournament settings against unknown strategies because it fosters mutual cooperation initially and supports its maintenance without risking being exploited by defectors, making it robust and fair.
'''

description_COOPERATIVE_32 = '''
Here is a carefully designed **cooperative strategy** for the repeated public goods game that balances an initial cooperative stance, conditional cooperation afterward, and a cautious approach towards the last round to avoid exploitation.

---

### Intuition

- The strategy aims to **maximize joint payoffs** through cooperation.
- It starts by cooperating to establish goodwill.
- It retaliates by defecting if others defect, but only temporarily to avoid long costly punishments.
- It forgives defections after seeing cooperation to restore cooperation quickly.
- On the last round, defecting might be individually rational, so it cooperates only if everyone else cooperates (to possibly gain mutual benefit).

---

### Strategy Description

---

#### Notation

- Let `t` denote the current round (1 ≤ t ≤ r)
- Let `history` be the observed actions of all players in previous rounds (for all players).
- For rounds `1` through `r-1`, use conditional cooperation.
- Round `r` is the last round.

---

### Decision rules

**Round 1 (Opening move):**

- Cooperate (`C`).

> Reason: Start by sending a positive signal; no prior information about others.

---

**Rounds 2 to r-1 (Middle rounds):**

- Let `prev_round_cooperators = number of players who cooperated in round t-1`.
- Let `did_all_cooperate = (prev_round_cooperators == n)` (Everyone cooperated last round).
- Let `did_any_defect = (prev_round_cooperators < n)` (At least one defected last round).
  
Decision rule for round t:

- If **everyone cooperated in previous round**, then **cooperate**.
- Else if **at least one player defected last round**:
  - If **I cooperated last round and was defected upon**, then **defect this round** to punish.
  - Else if **I defected last round or was defecting last round**, then **cooperate** to forgive and attempt to restore cooperation.

Essentially:

- Punish defection immediately following defection received.
- Forgive after one round of punishment.

This corresponds to a *"Win-Stay, Lose-Shift"* style approach adapted for multiple players.

---

**Round r (Last round):**

- If **everyone cooperated in round r-1**, **cooperate**.
- Else, **defect**.

> Reason: The last round is the classic last-shot problem. If others cooperated previously, cooperating may maintain mutual payoff. If others defected, defection maximizes individual payoff without fear of retaliation.

---

### Edge cases & notes:

- If a player defects once unexpectedly (noise or outlier), the strategy punishes once but quickly forgives to avoid long retaliation cycles.
- The strategy only punishes if the player was personally defected upon (i.e., defecting players are punished by defecting themselves).
- Monitors individual interactions (did the player cooperate or defect last round).
- Fully observable actions mean this is achievable.

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, history, my_index):
    """
    t: current round (1-based)
    r: total rounds
    n: number of players
    history: list of lists of actions per round (each element length n with 'C' or 'D')
    my_index: index of this player (0-based)
    """

    if t == 1:
        # Opening move: cooperate unconditionally
        return 'C'

    # Extract last round actions
    last_round_actions = history[t-2]  # rounds are 1-based, indexing zero-based

    prev_round_cooperators = sum(1 for a in last_round_actions if a == 'C')
    did_all_cooperate = (prev_round_cooperators == n)
    did_any_defect = not did_all_cooperate

    my_last_action = last_round_actions[my_index]

    if t < r:
        # Middle rounds

        if did_all_cooperate:
            # Everyone cooperated last round: keep cooperating
            return 'C'

        else:
            # Some defected last round

            if my_last_action == 'C':
                # I cooperated and was defected upon: punish by defecting
                return 'D'

            else:
                # I defected last round or punished already: forgive, cooperate again
                return 'C'

    else:
        # Last round: t == r

        if did_all_cooperate:
            # If everyone cooperated last round, cooperate
            return 'C'
        else:
            # Otherwise defect as no future punishment incentive
            return 'D'
```

---

### Summary

| Round      | Condition                              | Action            | Reason                                 |
|------------|--------------------------------------|-------------------|---------------------------------------|
| 1          | Always                              | Cooperate         | Signal cooperation                    |
| 2 to r-1   | Everyone cooperated last round       | Cooperate         | Maintain cooperation                  |
| 2 to r-1   | Some defected last round, I cooperated last round | Defect (punish)   | Retaliate against defection           |
| 2 to r-1   | Some defected last round, I defected last round    | Cooperate (forgive) | Attempt to restore cooperation        |
| r (last)   | Everyone cooperated last round       | Cooperate         | Potential mutual benefit               |
| r (last)   | Otherwise                           | Defect            | Last round defection rationality     |

---

This strategy captures cooperation and conditional punishment with forgiveness to stabilize cooperative payoffs, aligns with the cooperative mindset, and uses only observable history to make decisions. It should perform well against various other strategies in the tournament environment described.
'''

description_COOPERATIVE_33 = '''
**Cooperative Strategy: "Gradual Reciprocity with Forgiveness"**

---

### Intuition / Goal
Maximize group payoff by encouraging mutual cooperation, while deterring exploitation through calibrated punishment. The strategy is:

- Start fully cooperative.
- Continue cooperating as long as others mostly cooperate.
- Punish defections gradually but forgive quickly to restore cooperation.
- Defect near the end only if cooperation breaks down, otherwise cooperate to maximize end-game payoffs.

---

### Detailed Description

#### Definitions

- Let **H_t** be the history of all players’ actions up to round t-1.
- Define **coop_rate_t** = fraction of other players who cooperated in round t.
- Set parameters for forgiveness and detection:
  - **Tolerance threshold θ** = 0.5 (cooperation by at least half other players considered "good enough")
  - **Forgiveness window f** = 1 round (one round of punishment before returning to cooperation)

---

### Decision Rules

1. **Round 1 (no history):**  
   **Always cooperate.**

2. **Rounds 2 to r-1:**  
   - If in the last round, the fraction of cooperators among other players **≥ θ**, cooperate again to maintain mutual cooperation.
   - If fraction of cooperators < θ, defect *once* as a calibrated punishment.
   - After defecting once, immediately return to cooperating regardless of the previous round’s outcome (forgiveness).
   
3. **Round r (last round):**  
   - If mutual cooperation held in round r-1 (coop_rate ≥ θ), cooperate to finalize max group gain.
   - Else defect (punish last defections, extract private payoff as the public good will not multiply further).

---

### Why this works?

- **Starts cooperative** to signal willingness to cooperate and build trust.
- **Threshold θ=0.5** means we tolerate some defectors but punish when their number grows.
- **Single-round punishment** quickly discourages persistent defections while minimizing payoff loss.
- **Forgiveness** encourages return to cooperation rather than endless retaliation cycles.
- **Defection in final round** is a credible threat (players gain more personally by defecting if cooperation breaks down) signaling seriousness of cooperation commitment.
- This strategy aligns with **classical direct reciprocity principles** adapted to multiple players and repeated rounds.

---

### Pseudocode

```python
def decide_action(t, r, n, history):
    """
    t: current round (1-based)
    r: total rounds
    n: number of players
    history: list of length t-1; each element is a list of n actions ('C' or 'D') for that round

    Returns: 'C' or 'D'
    """
    if t == 1:
        # First round: cooperate
        return 'C'

    # Compute cooperation rate last round excluding self
    last_round = history[-1]
    my_last_action = last_round[player_index]  # player_index is this player’s index, assumed known to strategy
    others_last_round = [a for i,a in enumerate(last_round) if i != player_index]
    coop_count = others_last_round.count('C')
    coop_rate = coop_count / (n-1)

    # Check if player defected last round
    defected_last_round = (my_last_action == 'D')
    
    # Forgiveness: if defected last round, cooperate this round
    if defected_last_round:
        return 'C'

    # If last round cooperation rate among others is high, cooperate
    if coop_rate >= 0.5:
        # If last round of the game, cooperate to keep end-game cooperation
        if t == r:
            return 'C'
        else:
            return 'C'

    else:
        # Defect once as punishment this round
        if t == r:
            # Last round defect if cooperation broke down
            return 'D'
        else:
            return 'D'
```

---

### Summary

| Round          | Condition                          | Action         | Rationale                                |
|----------------|----------------------------------|----------------|-----------------------------------------|
| 1              | No history                       | Cooperate (C)  | Signal cooperation, build trust         |
| 2..r-1         | Others mostly cooperate (≥0.5)  | Cooperate (C)  | Maintain cooperation                     |
| 2..r-1         | Others mostly defect (<0.5)      | Defect (D) once| Punish defectors                         |
| After defect   | Next round                      | Cooperate (C)  | Forgiveness enables cooperation reset   |
| Last round r   | Previous cooperation high (≥0.5) | Cooperate (C)  | Maximize joint payoff                    |
| Last round r   | Previous cooperation low (<0.5) | Defect (D)     | Secure private payoff, punish defectors |

---

This "Gradual Reciprocity with Forgiveness" strategy aligns well with cooperative intent while robustly handling defections in multiple-player repeated public goods games without relying on communication or coordination devices.
'''

description_COOPERATIVE_34 = '''
Below is a cooperative strategy tailored for the described repeated N-player public goods game. This strategy aims to sustain cooperation when others cooperate, punish defection to discourage free-riding, and soften defection to avoid permanent breakdowns — all while recognizing the last round’s incentive structure.

---

## **Strategy Name: Conditional Reciprocity with Forgiveness**

---

### 1. **Summary of Decision Rules**

- **Round 1 (First Round):**  
  Start by cooperating (C) to signal cooperative intent.

- **Rounds 2 to r-1 (Intermediate Rounds):**  
  - Cooperate if the *majority* of players cooperated in the previous round (including yourself).  
  - Defect otherwise.  
  - If defection occurred last round (i.e., not majority cooperation), cooperate with a small probability *p* (forgiveness) to allow recovery if others return to cooperation.

- **Round r (Last Round):**  
  Defect with the knowledge that cooperation is less likely to be reciprocated and there is no future punishment.

---

### 2. **Rationale**

- **First Round Cooperation:** Sets a tone of goodwill, maximizing social welfare potential.  
- **Majority Rule as Proxy for Cooperation Level:** Respond to the group's general behavior rather than any single player's action to avoid retaliating against isolated accidental defections or noise.  
- **Punishment:** Defect if cooperation breaks down to reduce incentive of free-riding.  
- **Forgiveness:** Introduce probabilistic cooperation after defection to prevent permanent breakdown of cooperation caused by misunderstandings or noise.  
- **Last Round Defection:** Anticipating the “endgame effect,” defect since future repercussions do not exist and cooperating sacrifices own payoff.

---

### 3. **Edge Cases**

- **All Cooperated Previous Round:** Continue cooperating.  
- **All Defected Previous Round:** Mostly defect (stay defect), but sometimes cooperate with probability *p* to reintroduce cooperation.  
- **Mixed Previous Round:** Use majority cooperation as cutoff threshold; cooperate if majority is cooperative, defect otherwise with forgiveness probability.  
- **First Round:** No history, so start with cooperation.  
- **Last Round:** Defect regardless of history.  

---

### 4. **Parameters**

- Forgiveness probability:  
  Choose a small positive value e.g., *p = 0.1* (can be tuned).

---

### 5. **Pseudocode**

```python
# Input at round t:
# - history: list of tuples of previous rounds actions for all players, each tuple (c_1, c_2, ..., c_n)
#   where c_i ∈ {C, D} for player i.
# - player_index: index of self (1 to n)
# - r: total rounds
# - t: current round (1-based)
# - p: forgiveness probability (e.g., 0.1)

def decide_action(history, player_index, r, t, p=0.1):
    if t == 1:
        # First round - cooperate to initiate cooperation
        return 'C'
    
    if t == r:
        # Last round - defect (endgame logic)
        return 'D'

    # Calculate total cooperators in previous round
    prev_round = history[t-2]  # zero-based indexing of rounds
    num_cooperators = sum(1 for action in prev_round if action == 'C')

    # Majority threshold
    majority = (len(prev_round) // 2) + 1  # > half players cooperating

    if num_cooperators >= majority:
        # Majority cooperated last round — reciprocate cooperation
        return 'C'
    else:
        # Majority defected
        # Defect generally but forgive by cooperating with probability p
        import random
        if random.random() < p:
            return 'C'  # forgiveness cooperation
        else:
            return 'D'
```

---

### 6. **Behavior Summary**

| Round        | Condition                          | Action                     |
|--------------|----------------------------------|----------------------------|
| 1 (First)    | No history                       | Cooperate (C)              |
| 2 .. r-1     | Previous round majority cooperated | Cooperate (C)              |
| 2 .. r-1     | Previous round majority defected | Defect (D) except random forgiveness (prob p cooperate) |
| r (Last)     | Any history                      | Defect (D)                 |

---

### 7. **Cooperativeness Explanation**

- The strategy signals cooperative intent immediately and sustains cooperation when others mostly cooperate.
- It punishes defection to discourage free-riders but does not retaliate indefinitely (forgiveness prevents permanent breakdown).
- Recognizes and respects the economic incentives of the last round where cooperation is fragile.
- Encourages mutual benefit through repeated cooperative behavior, maximizing group payoff over time.

---

If implemented consistently by multiple players, this strategy can achieve high mutual cooperation and social welfare, and if facing defectors, it can protect from exploitation while allowing recovery to cooperation.
'''

description_COOPERATIVE_35 = '''
Here is a cooperative strategy to encourage mutual cooperation in the repeated N-player Public Goods Game setting described.

---

## Strategy Name: **Grim Trigger with Forgiveness**

---

### 1. Decision Rules

- **Round 1: Cooperate**
  - Start by cooperating to signal willingness to achieve the cooperative optimum.

- **Rounds 2 to (r-1): Conditional Cooperation**
  - Cooperate if **all** players cooperated in the previous round.
  - Defect otherwise (to punish free-riders).

- **Round r (Last Round): Defect**
  - Defect in the last round since no future punishment is possible (standard backward induction).

- **Forgiveness Mechanism:**
  - After a defection has occurred by anyone (including self), stay in punishment (defect) for up to *f* rounds (forgiveness window).
  - After *f* rounds with no additional defections, revert to cooperating to restore cooperation.
  
  > *Example:* f = 2 rounds

  This mechanism helps recover cooperation after accidental defection or noise (in case some opponent mistakenly defects), mitigating permanent breakdown of the cooperative equilibrium.

---

### 2. Handling Edge Cases

- **First Round (t=1):** Cooperate unconditionally.

- **Last Round (t=r):** Defect unconditionally to exploit any residual cooperative contributions.

- **If defections observed:** Punish by defecting for *f* rounds (forgiveness window), then return to cooperation if no new defections occur.

- **In case of simultaneous defections in previous round:** Treat any observed defection the same—punish collectively.

- **If all cooperate:** Continue cooperating indefinitely (except last round).

---

### 3. Cooperative Mindset Rationale

- The strategy tries to achieve the socially optimal outcome (full cooperation) since π_i is maximized when everyone cooperates.
- Punishment for defection discourages free-riding by lowering incentives for defectors.
- Forgiveness prevents endless punishment cycles, allowing the group to restore cooperation after mistakes or misunderstandings.
- Defection in the last round, although not cooperative in isolation, is rational under backward induction and common knowledge.

---

## Pseudocode

```python
# Parameters:
# n = number of players
# r = total rounds
# k = multiplication factor
# f = forgiveness window (suggested: 2)

# State Variables:
# history = list of tuples of actions per round, e.g. [ (C, C, D, ...), ... ]
# punishment_counter = counts how many rounds in punishment mode remain

def decide_action(t, history, punishment_counter):
    if t == 1:
        # First round: cooperate
        return 'C', punishment_counter

    if t == r:
        # Last round: defect (backward induction)
        return 'D', punishment_counter

    # Check previous round actions
    prev_round_actions = history[-1]

    # If currently in punishment mode
    if punishment_counter > 0:
        # Defect and decrement punishment counter
        punishment_counter -= 1
        return 'D', punishment_counter

    # If in normal mode, check for defection in previous round
    if 'D' in prev_round_actions:
        # Start punishment mode (set counter to f - 1 because current round is included)
        punishment_counter = f - 1
        return 'D', punishment_counter
    else:
        # No defection in previous round, cooperate
        return 'C', punishment_counter
```

---

## Explanation:

- **Initially cooperate** to build trust.
- **If anyone defects, punish by defecting for *f* rounds** to signal defection is costly.
- After punishment rounds, **forgive and cooperate again** to restore mutual cooperation.
- **Defect on the final round** because future retaliation is impossible, so cooperating is dominated.
- This matches well-known folk-theorem results in repeated games and adjusts for noisy or strategic defections.

---

This strategy balances cooperation and credible punishment to foster sustained cooperation across rounds, maximizes expected payoffs in the repeated PGG, and accounts for strategic rationality and common knowledge in a no-communication environment.
'''

description_COOPERATIVE_36 = '''
Below is a cooperative strategy for the described N-player repeated public goods game. The strategy seeks to maximize collective payoffs by encouraging mutual cooperation yet guards against exploitation.

---

## Strategy Name: **Conditional Cooperate-with-Forgiveness**

### Intuition
Cooperation yields the highest collective and individual payoff (if others also cooperate). Defection yields immediate private gain but lowers the group return. This strategy cooperates initially to establish trust, continues cooperation as long as others mostly cooperate, but responds to defection with measured punishment. It forgives defections over time to restore cooperation.

---

## 1. Decision Rules

At round t (1 ≤ t ≤ r), observe previous rounds' actions of all other players. Let:

- **History**: For each past round τ < t, we know actions {a_j,τ} for all players j.
- **Cooperation rate of others until t-1**:  
  $$ \text{coop_rate}_{-i} = \frac{\sum_{\tau=1}^{t-1} \sum_{j ≠ i} \mathbf{1}(a_{j,\tau} = C)}{(t-1) \times (n-1)} $$
- **Recent cooperation rate in last m rounds** (where m is a forgiveness window length, e.g., m=3):  
  $$ \text{coop_rate_recent} = \frac{\sum_{\tau=\max(1,t-m)}^{t-1} \sum_{j ≠ i} \mathbf{1}(a_{j,\tau} = C)}{( \min(t-1,m) ) \times (n-1)} $$

**Parameters:**

- **Threshold to maintain cooperation:** coop_threshold (e.g., 0.8)
- **Forgiveness threshold:** forgive_threshold (e.g., 0.5)
- **Punishment length:** punishment_length (e.g., 1 round)

### Decision logic for player i at round t:

- **Round 1 (t=1):**  
  Cooperate unconditionally, as a signal of goodwill.

- **Rounds 2 to r-1 (1 < t < r):**  
  - If in previous round (t-1), the cooperation rate among others was at least `coop_threshold` (e.g., ≥ 0.8), then cooperate.  
  - Else if currently in punishment phase (defined below), defect.  
  - Else if recent cooperation rate in last m rounds is below `forgive_threshold` (e.g., < 0.5), continue defecting (mutual defection phase).  
  - Else (the others cooperated somewhat recently but just dipped below threshold), enter punishment phase by defecting for `punishment_length` rounds to discourage defection.

- **Last Round (t = r):**  
  Defect unconditionally (standard backward induction since no future rounds to enforce cooperation).

---

## 2. Handling Edge Cases

- **First Round:** Cooperate outright to initiate cooperation and maximize group benefit if others reciprocate.

- **Last Round:** Defect, since no future consequences.

- **Isolated defections:**  
  A small number of defections (below coop_threshold) do not trigger punishment. This tolerates accidental or random defections, preventing collapse to permanent defection.

- **Sustained defection:**  
  If the cooperation rate remains low for m rounds (below forgive_threshold), treat as collapse of cooperation and defect indefinitely until history improves (but this is unlikely since last round is defect).

- **Punishment Mechanism:**  
  Punishes by defecting one round after observing defection shock, then resumes cooperation to allow return to cooperation (forgiveness).

---

## 3. Cooperative Alignment

- This strategy cooperates initially and as long as others mostly cooperate.
- It punishes defection to discourage exploiters.
- It quickly forgives to restore cooperation.
- It ends with defection in the last round, as per backwards induction.
- It does not rely on explicit communication or coordination beyond observed actions.
- It strives to maximize collective payoff by sustaining cooperation most rounds.

---

## Pseudocode

```python
# Parameters
coop_threshold = 0.8     # fraction of others cooperating in previous round to continue cooperation
forgive_threshold = 0.5  # fraction for forgiveness threshold
punishment_length = 1    # rounds to punish after defection observed
forgiveness_window = 3   # recent rounds to assess cooperation

# Variables to track
punishment_timer = 0     # counts down punishment rounds

def decide_action(t, history, n, r):
    # history: list of dicts per round {player_id: 'C' or 'D'}
    # t: current round (1-indexed)
    # player i is self
    
    i = self_id
    
    if t == 1:
        # First round: cooperate
        return 'C'
    
    if t == r:
        # Last round: defect (backwards induction)
        return 'D'
    
    # Compute cooperation stats of others
    past_rounds = t - 1
    def cooperation_rate(round_idx):
        coop_count = sum(1 for j in range(1, n+1) if j != i and history[round_idx-1][j] == 'C')
        return coop_count / (n -1)
    
    # Cooperation rate in previous round
    coop_prev = cooperation_rate(t-1)
    
    # Cooperation rate overall until t-1
    total_coop = 0
    for round_idx in range(1, t):
        total_coop += sum(1 for j in range(1, n+1) if j != i and history[round_idx-1][j] == 'C')
    coop_rate_all = total_coop / ((n-1)*past_rounds)
    
    # Cooperation rate in last forgiveness_window rounds
    start_round = max(1, t - forgiveness_window)
    rounds_considered = t - start_round
    recent_coop_total = 0
    for round_idx in range(start_round, t):
        recent_coop_total += sum(1 for j in range(1, n+1) if j != i and history[round_idx-1][j] == 'C')
    coop_recent = recent_coop_total / ((n-1)*rounds_considered) if rounds_considered > 0 else 1.0
    
    global punishment_timer
    
    if punishment_timer > 0:
        punishment_timer -= 1
        # Punishing: defect
        return 'D'
    
    # Decide to cooperate or defect
    if coop_prev >= coop_threshold:
        # Others cooperated well last round => cooperate
        return 'C'
    else:
        # Others defected enough to punish
        if coop_recent < forgive_threshold:
            # sustained defection: defect indefinitely (until history improves)
            return 'D'
        else:
            # Trigger punishment
            punishment_timer = punishment_length - 1  # current round counts as one
            return 'D'
```

---

## Summary

- **Round 1:** Cooperate  
- **Rounds 2 to r-1:** Cooperate if others mostly cooperated last round; otherwise defect to punish, but punish only briefly and forgive to restore cooperation. If defection is persistent, defect until history improves.  
- **Round r:** Defect  

This design balances cooperation promotion and defection deterrence, maximizing payoffs under imperfect trust without communication.
'''

description_COOPERATIVE_37 = '''
**Cooperative Strategy: Gradual Conditional Cooperation with Forgiveness**

---

### Intuition and Goals

- Aim for full cooperation (all cooperate) because it maximizes group payoffs.
- Begin cooperatively to signal willingness.
- Punish defection by defecting next round but not forever.
- Forgive after punishment to return to cooperation.
- Avoid unraveling due to backward induction by maintaining some cooperation in the last round.
- Use public history (all players' past moves) to decide actions.
  
---

### Detailed Decision Rules

#### Variables and Observations:

- For round `t`, observe history `H_t-1` of all players' actions in rounds `1` to `t-1`.
- Let `C_count(t)` = number of players who cooperated in round `t`.
- Let `cooperating_players(t)` be the set of players who cooperated in round `t`.
- Keep track of whether any defections occurred in the previous round.

---

### Strategy Outline

1. **Round 1: Cooperate**
   - No past history; start by cooperating to signal cooperative intent.

2. **Subsequent rounds (2 ≤ t < r): Cooperate if everyone cooperated last round, otherwise punish defectors.**

   - If **all players cooperated** in round `t-1`:
     - Cooperate in round `t`.

   - If **any player defected** in round `t-1`:
     - Defect in round `t` to punish.
     - Exception: If you were the only defector in round `t-1`, start forgiveness immediately next round by cooperating in round `t` to encourage return.

3. **Forgiveness after punishment:**

   - After defecting to punish, if in the next round (new round `t+1`) you observe full cooperation again, forgive by returning to cooperation and reset punishment state.
   - Continue punishing defectors only if defections persist after warnings.

4. **Last round (round = r): Cooperate regardless**
   - Avoid end-game defection spiral with a final cooperative move.
   - Allows maximizing collective payoff in the last round.

---

### Pseudocode

```python
# Inputs:
# - n: number of players
# - r: total rounds
# - t: current round (1-based)
# - history: list of length t-1, each entry is a list of n actions ['C' or 'D']

def decide_action(t, n, r, history, player_index):
    # First round: cooperate
    if t == 1:
        return 'C'

    # Extract previous round actions
    last_round_actions = history[-1]  # List of 'C' or 'D' for each player
    
    # Count cooperators last round
    last_round_cooperators = sum(1 for a in last_round_actions if a == 'C')

    # Check if everyone cooperated last round
    all_cooperated = (last_round_cooperators == n)

    # Detect if self defected last round
    self_defected_last_round = (last_round_actions[player_index] == 'D')

    # Detect if there was any defection last round
    any_defection_last_round = (last_round_cooperators < n)

    # Last round special rule: cooperate regardless
    if t == r:
        return 'C'

    # If everyone cooperated last round, cooperate this round
    if all_cooperated:
        return 'C'

    # If any defection last round, punish defectors by defecting
    # except initiate forgiveness if only self defected last round
    if any_defection_last_round:
        # If I was the only defector last round, forgive by cooperating now
        if self_defected_last_round and last_round_cooperators == n - 1:
            return 'C'
        else:
            # Otherwise defect to punish
            return 'D'

    # Default: cooperate (should not reach here)
    return 'C'
```

---

### Explanation of the Strategy Logic

- **Start Cooperatively:** Sends a positive signal and tries to maximize joint payoff.
- **Full Cooperation Condition:** As long as all cooperate, always cooperate to maintain high group payoff.
- **Punishment:** Defect next round if someone defects last round, deterring exploitation.
- **Selective Forgiveness:** If only you defected last round (perhaps by mistake or experimentation), try forgiving immediately to return to cooperation.
- **Avoiding Permanent Defection:** Forgiveness prevents permanent mutual defection cycles; the strategy aims to restore cooperation fast.
- **Last Round Cooperation:** Breaks backward induction; encourages cooperation on last round to gain highest mutual payoff and avoid premature defection.

---

### Cooperative Mindset

- Always tries to cooperate but responds to defection realistically.
- Forgives quickly to encourage others back to cooperation.
- Uses observed behavior to decide, avoiding rigid grudges.
- Tries to maximize group's payoff over the entire repeated game.
- Does not exploit others but defends against exploitation.

---

This strategy optimally balances cooperation, punishment, and forgiveness in a noisy environment of multiple unknown strategies, aiming to maximize both individual and collective payoffs over all rounds.
'''

description_COOPERATIVE_38 = '''
Here is a cooperative strategy for the repeated N-player public goods game described, designed to encourage cooperation while managing defections. The strategy is inspired by "conditional cooperation" and "forgiveness" principles common in repeated social dilemma games.

---

## Strategy Name: **Forgiving Conditional Cooperation**

### Intuition

- Start fully cooperative to maximize collective payoffs.
- Continue cooperating only as long as other players mostly cooperate.
- Punish defections by defecting temporarily to discourage free-riding.
- Forgive after a round of punishment to allow return to cooperation.
- In the last round, defect rationally since no future rounds remain.

---

### 1. Decision Rules: When to Cooperate vs Defect

**Notation:**

- `t`: current round (1 ≤ t ≤ r)
- `C_count[t-1]`: number of players who cooperated in previous round (round t-1)
- `my_actions[1..t-1]`: vector of own past actions
- `others_actions[1..t-1]`: matrix of other players' past actions (visible)
- `last_round`: boolean indicating if current round is last (t == r)

**Rules:**

- **Round 1 (t=1)**:
  - Cooperate (C).
  - Reason: Establish cooperation baseline.

- **Rounds 2 to r-1 (1 < t < r)**:
  - If in the previous round:
    - The number of cooperating players `C_count[t-1]` was **at least n-1** (all but potentially 1 other cooperated), then **Cooperate**.
      - This is a generous threshold that tolerates at most a single defector without immediate retaliation.
    - Otherwise, if cooperation dropped significantly (less than n-1 cooperators), **Defect** to punish.
  - **Exception/Forgiveness**:
    - If the player defected in the previous round (to punish), but last round's cooperation count met the threshold, **return to Cooperate**.
    - This rule allows quick forgiveness after punishment if others resume cooperation.

- **Last round (t = r)**:
  - **Defect**.
  - Reason: No incentive to cooperate since no future rounds remain to reward cooperation.

---

### 2. Edge Cases Handling

- **First Round**: Always cooperate to signal goodwill and establish cooperation.
- **Last Round**: Always defect (standard game-theoretic backward induction).
- **Punishment Length**: Only one round of defection after detecting substantial defection by others, then attempt cooperation again — this limits punishment to avoid needless cycles.
- **Tolerance Level**: Forgives a single defector among `n` to avoid overreacting.
- **Fallback**: If previous data is erratic (e.g., inconsistent cooperation levels), follow majority trend weighted by threshold.

---

### 3. Cooperative Mindset Alignment

- The strategy is fundamentally cooperative by:
  - Starting cooperatively.
  - Cooperating when others are also cooperating.
  - Punishing only when cooperation breaks down significantly.
  - Forgiving quickly to restore cooperation, avoiding deadlocks.
  - Trading off individual temptation for long-term mutual benefit.
  
- This strategy can sustain cooperation in a population of similar conditional cooperators by rewarding cooperation and discouraging defection.

---

## Pseudocode

```python
def forgiving_conditional_cooperation(t, r, n, history):
    """
    t: current round (1-based)
    r: total rounds
    n: number of players
    history: list of tuples [(a_1(t-1), ..., a_n(t-1)), ..., (a_1(1), ..., a_n(1))]
             Each tuple is actions in a past round; a_i in {C, D}
             Most recent round at history[-1] if t > 1.
             
    Returns: action 'C' or 'D'
    """

    # Last round: defect
    if t == r:
        return 'D'
    
    # First round: cooperate
    if t == 1:
        return 'C'
    
    # From second round onwards
    last_round_actions = history[-1]  # tuple of actions in round t-1
    C_count = sum(1 for action in last_round_actions if action == 'C')
    
    # Identify own previous action
    # Assume player index i is known or provided to function.
    # For pseudocode, assume player index i fixed, e.g. i = self_index.
    # Since index is not specified, assume function used per player i and own action
    my_last_action = last_round_actions[i-1]
    
    # Define tolerance threshold: tolerate up to 1 defector among n
    cooperation_threshold = n - 1  
    
    # If previous round had near-full cooperation (at least n-1 cooperators)
    if C_count >= cooperation_threshold:
        # Cooperate unless defected last round to punish
        if my_last_action == 'D':  
            # Previously punished, now forgive and cooperate
            return 'C'
        else:
            # Continue cooperation
            return 'C'
    else:
        # Significant defection detected: punish by defecting this round
        return 'D'
```

---

## Summary

- **Round 1**: Cooperate
- **Rounds 2 to r-1**: Cooperate if prior cooperation was near-unanimous (≥ n-1 cooperators), otherwise defect to punish
- Forgive defectors by returning to cooperate after one round of punishment
- **Last round**: Defect to maximize immediate payoff

This balances cooperation willingness with robustness against defection and enables sustained mutually beneficial cooperation in unknown populations without communication or coordination.
'''

description_COOPERATIVE_39 = '''
Here is a cooperative strategy designed for the described N-Player Public Goods Game. It is tailored to promote cooperation, efficiently respond to defections, and maximize total joint payoffs over the repeated rounds.

---

## Strategy Name: **Forgiving Conditional Cooperator**

### Core Idea
- Start fully cooperative to build trust and realize the public good benefits.
- Continue cooperating as long as others mostly cooperate.
- Punish defection temporarily but return to cooperation to maintain a cooperative equilibrium.
- Defect in the final round to avoid being exploited without future consequences (subgame perfection).

---

## 1. Decision Rules

For each round **t** in {1, 2, ..., r}:

1. **Round 1 (t=1):**  
   - Cooperate (C).  
   *Rationale:* No history, so start by trusting others and aiming to build cooperation.

2. **Rounds 2 to r-1 (1 < t < r):**  
   - Calculate the defection rate in the previous round t-1:  
     **defection_rate = (number of defectors in round t-1) / n**
   - If **defection_rate ≤ θ** (a small tolerance threshold, e.g., θ=0.25):  
     Cooperate (C).  
   - Else (defection_rate > θ):  
     Defect (D) this round to punish defectors.  
   - If punishing (defecting due to defection_rate > θ), then in the very next round (t+1), revert to cooperation to attempt forgiveness and reestablish cooperation.

   *Rationale:* Cooperate as long as others mostly cooperate. Defect to punish larger defections but do not hold grudges indefinitely, allowing the group to return to productive cooperation.

3. **Last Round (t = r):**  
   - Defect (D).  
   *Rationale:* In the final round, there are no future consequences, so defecting maximizes private payoff.

---

## 2. Edge Cases

- **First round no history:** always cooperate to set positive tone.  
- **Small number of players cooperating:** The strategy tolerates up to θ proportion defecting. Below that, cooperation continues to avoid overreacting to a few defectors (noise).  
- **Sequential punishment:** Defects for only 1 round after large defection detected, no permanent punishment, to avoid locking into mutual defection.  
- **Last round defection:** Subgame-perfect equilibrium behavior; ensures no exploitation in the final round.

---

## 3. Pseudocode

```python
# Parameters:
# n: number of players
# r: total rounds
# history: list of previous rounds' actions, each element is a list of length n with 'C' or 'D'
# θ: tolerance threshold, e.g. 0.25

def decide_action(t, history, n, r, θ=0.25):
    # Round 1: cooperate
    if t == 1:
        return 'C'
    
    # Last round: defect
    if t == r:
        return 'D'
    
    # For rounds 2 to r-1:
    last_round_actions = history[t-2]  # zero-indexed, t-2 is round t-1
    defectors = last_round_actions.count('D')
    defection_rate = defectors / n

    # Check if was punishing in previous round
    if t >= 3:
        prev_action = history[t-3][self_index]  # self_index is this player's index
        prev_defection_rate = history[t-3].count('D') / n
        if prev_defection_rate > θ and prev_action == 'D':
            # Forgive: revert to cooperation after one round of punishment
            return 'C'

    if defection_rate > θ:
        # Punish by defecting this round
        return 'D'
    else:
        # Cooperate if others mostly cooperate
        return 'C'
```

*Note:* `self_index` is your own player index, assumed known.

---

## 4. Explanation & Justification

- **Cooperation in round 1:** Leads by example, tries to build trust since cooperation benefits everyone.  
- **Tolerance threshold θ:** Prevents overreaction to isolated defections which might be mistakes or noise.  
- **One-round punishment:** Strong enough to discourage persistent defectors, but forgiving so cooperation can be restored, maximizing total payoffs over repeated rounds.  
- **Defection in final round:** Standard backward induction step; cooperation is not rational without future rewards, so defect to maximize personal payoff.

---

## 5. Strategy Summary

| Round         | Condition                                                     | Action    |
|---------------|--------------------------------------------------------------|-----------|
| 1             | No history                                                   | Cooperate |
| 2 ≤ t < r - 1 | If previous round defection ≤ θ or just finished punishing    | Cooperate |
|               | Else if previous round defection > θ (and not yet punished)   | Defect    |
| r (last round)| Always defect                                                | Defect    |

---

This strategy promotes cooperation, punishes defection proportionally and temporarily, and avoids exploitation in the final round, aligning with a cooperative mindset in a repeated public goods game without communication or coordination.

If multiple players use variations of this strategy, cooperation can be sustained, producing higher collective payoffs than universal defection.
'''

description_COOPERATIVE_40 = '''
**Cooperative Strategy for the N-Player Public Goods Game**

---

### Intuition and Goal

The public goods game payoff structure is a classic social dilemma:

- Cooperation (C) benefits the group but costs the individual 1 unit of private endowment.
- Defection (D) benefits the individual in the current round by saving the cost but risks group welfare.

Since \(1 < k < n\), full cooperation yields a group payoff greater than full defection, but unilateral defection yields higher individual payoff than cooperating when others cooperate.

Our strategy seeks to:

- Achieve mutual cooperation for maximum group benefit.
- Enforce cooperation by punishing defection.
- Avoid unnecessary punishment to maximize total payoff.
- Gradually restore cooperation after punishment.
- Adjust behavior in the last round, where incentive to defect is highest.

---

### Overview of the Strategy

We design a **conditional cooperative strategy with forgiveness** based on observing others' actions:

- **Round 1:** Cooperate to signal goodwill and initiate cooperation.
- **In subsequent rounds:** Cooperate if all other players cooperated in the previous round.
- **Punish defection:** If any player defected last round, defect in this round to discourage free-riding.
- **Forgiveness & recovery:** After punishing, return to cooperation if all cooperated in the most recent round.
- **Last round:** Defect to maximize immediate payoff (since no future rounds remain for punishment).

This resembles a generalized **"Tit-for-Tat"** or **"Grim Trigger with forgiveness"** adapted for multiple players.

---

### Notation

- \(t\): current round, \(1 \le t \le r\)
- \(H_{t-1}\): game history up to round \(t-1\)
- \(A_i^t\): action of player \(i\) at round \(t\)
- \(C_t\): set of players who cooperated at round \(t\)
- \(D_t\): set of players who defected at round \(t\) (= all players \(\setminus C_t\))

---

### Decision Rules

1. **First round \((t=1)\):**  
   - Cooperate (C) unconditionally.

2. **Intermediate rounds \((1 < t < r)\):**

   Let \(d = |D_{t-1}|\) = number of defectors in previous round.

   - If \(d = 0\) (all others cooperated last round):  
     Cooperate.

   - If \(d > 0\) (at least one defection last round):  
     Defect (punish).

3. **Last round \((t=r)\):**  
   - Defect directly (no future rounds to enforce cooperation).

---

### Rationale

- **Signaling cooperation first:** With no prior information, cooperation aims to establish mutual cooperation baseline.
- **Punishing defection:** Defection in response to any defection deters exploitation.
- **Forgiveness mechanism:** Returning to cooperation if others cooperate prevents endless mutual punishment.
- **Last round defection:** Standard backward induction result; cooperation cannot be enforced without future rounds.

---

### Edge Case Handling

- **If all defect at round 1:** strategy reacts by defecting in round 2 (punishment). If others switch to cooperation later, the strategy will also resume cooperating.
- **If partial cooperation:** defect if anyone defects last round, fully punish free riders.
- **If all cooperate but one defects:** punish in next round, encouraging defectors to switch back.
- **Last round known beforehand:** defect preemptively, no complexity added.

---

### Pseudocode

```python
def strategy(history, current_round, total_rounds, player_index):
    """
    history: list of lists of player actions per round, e.g., [['C','D','C'], ['C','C','D'], ...]
    current_round: int, 1-indexed
    total_rounds: int
    player_index: int (0-based)
    
    Returns: 'C' or 'D'
    """
    
    # Last round defect always
    if current_round == total_rounds:
        return 'D'
    
    # First round cooperate
    if current_round == 1:
        return 'C'
    
    # From round 2 to round r-1
    
    last_round_actions = history[current_round - 2]  # zero indexed
    
    # Count defections in last round
    defectors_last_round = [p for p, a in enumerate(last_round_actions) if a == 'D']
    
    if len(defectors_last_round) == 0:
        # All cooperated last round, cooperate this round
        return 'C'
    else:
        # Some defectors last round, punish by defecting this round
        return 'D'
```

---

### Summary

| Round          | Condition                                                                     | Action       |
|----------------|-------------------------------------------------------------------------------|--------------|
| Round 1        | No history                                                                    | Cooperate (C) |
| Intermediate   | If all cooperated previous round                                              | Cooperate (C) |
| (2 to r - 1)   | If any player defected previous round                                         | Defect (D)    |
| Last round (r) | No incentive to cooperate, defection maximizes payoff                         | Defect (D)    |

---

### Final Notes

- The strategy is **simple, reactive, and transparent**, easy for other rational players to recognize and respond to.
- It **encourages sustained cooperation** by rewarding cooperation and punishing defection.
- It complies with game-theoretic insights about repeated social dilemmas and is likely to perform well against many independent strategies in the tournament.
'''

description_COOPERATIVE_41 = '''
Below is a **cooperative strategy** designed specifically for the described N-Player Repeated Public Goods Game.

---

## Strategy: **"Generous Reciprocity with Forgiveness"**

### Intuition

- **Goal:** Foster cooperation whenever possible for mutual benefit.
- **Approach:** Begin by cooperating, and then maintain cooperation as long as others mostly cooperate.
- **Forgiveness:** Allow occasional defections without immediately punishing, to avoid deadlock from mistakes or noise.
- **Final Round:** Defect to maximize payoffs (standard backward induction for finitely repeated games).

---

### Detailed Description

#### Notation:

- Let \( t \in \{1, \dots, r\} \) be the round index.
- Let \( c_j^{(t)} \) be the action of player \( j \) in round \( t \), 1 if Cooperate (C), 0 if Defect (D).
- Let \( H^{(t-1)} \) be the full history of all players’ actions up to round \( t-1 \).
- Let \( N_c^{(t)} = \sum_{j=1}^n c_j^{(t)} \) be the total number of cooperators in round \( t \).

---

### Decision Rules:

---

**Round 1 (t=1):**

- Cooperate (C).

> Rationale: Start cooperatively to signal willingness to cooperate.

---

**Rounds 2 ≤ t < r:**

- Calculate \( N_c^{(t-1)} \) from the previous round.

- Calculate your observed cooperation ratio excluding yourself:

\[
r_{-i}^{(t-1)} = \frac{N_c^{(t-1)} - c_i^{(t-1)}}{n-1}
\]

- Define a **cooperation threshold parameter \( \tau \in [0,1] \)**, e.g., \( \tau = 0.7 \).

- Decision:

  - **If** \( r_{-i}^{(t-1)} \geq \tau \)  
    → Cooperate (C) in round \( t \).

  - **Else**  
    → Defect (D) in round \( t \).

---

**Round r (last round):**

- Defect (D).

> Rationale: Standard backward-induction logic says cooperation isn't sustained on the last round, defect to maximize payoff.

---

### Additional Notes:

- **Forgiveness:** Using a threshold \( \tau < 1 \) allows cooperation to continue even if a few players defect occasionally, thus avoiding harsh punishment cycles and promoting stable cooperation.

- **No harsh punishment:** You do not retaliate immediately or permanently after a single defection because no communication or coordination allows to distinguish mistakes from intentional defection.

- **Symmetry:** This strategy is symmetric and does not require identity or trust on players.

---

## Pseudocode

```python
def decide_action(t, r, n, history, player_index, tau=0.7):
    # history: list of length t-1 rounds, each round is list of length n with actions: 1=C, 0=D
    if t == 1:
        return 'C'  # Cooperate first round

    elif t == r:
        return 'D'  # Defect last round
    
    else:
        last_round = history[-1]  # actions of all players in previous round
        ci_last = last_round[player_index]
        Nc_last = sum(last_round)
        r_minus_i = (Nc_last - ci_last) / (n - 1)

        if r_minus_i >= tau:
            return 'C'
        else:
            return 'D'
```

---

## Summary

| Round     | Decision Rule                               | Reasoning                     |
|-----------|---------------------------------------------|-------------------------------|
| 1         | Cooperate (C)                              | Initiate cooperation           |
| 2 to r-1  | Cooperate if ≥ \( \tau \times 100\% \) others cooperated last round; else defect | Encourage mutual cooperation with forgiveness |
| r (final) | Defect (D)                                | Exploit last round without fear of punishment |

This strategy encourages sustained cooperation among mostly cooperating players, tolerates occasional defects to avoid mutual breakdown, and defects in the terminal round to maximize final payoffs—thus embodying a **cooperative but rational** approach under no communication and perfect monitoring.

---

If you want, I can also provide analysis of expected performance against typical behaviors.
'''

description_COOPERATIVE_42 = '''
Below is a cooperative strategy designed for the N-Player Public Goods Game described, specifically aimed at promoting cooperation while being robust to occasional defections and the known strategic environment:

---

### Strategy Name: **Conditional Grim Trigger with Forgiveness**

---

### Intuition

- Start by cooperating to show good faith.
- Continue cooperating if everyone cooperated in the previous round.
- If defections occur, defect in the next round to punish defectors.
- However, if all players return to full cooperation in a later round, forgive and resume cooperating.
- In the last round, defect to avoid being exploited due to backward induction.

This strategy attempts to sustain cooperation by rewarding it, punishing defection, but allowing redemption to prevent endless mutual defection. The endgame defection acknowledges the classic last-round defection incentive in repeated games with a known horizon.

---

### Detailed Description

#### 1. First round (t=1):
- Cooperate (play C) unconditionally to demonstrate cooperative intent.

#### 2. Middle rounds (t = 2 to r-1):
- Observe past round actions of all players.
- If **all players cooperated in previous round**, then cooperate.
- Otherwise, defect to punish the presence of any defection.
- However, if in a **current round all players cooperate again after prior defection(s)**, forgive past defections and resume cooperation next round.

This forgiveness prevents permanent breakdown and fosters re-establishment of cooperation.

#### 3. Last round (t = r):
- Defect unconditionally.
- Since no future punishment is possible, the incentive to cooperate vanishes in the last round under backward induction.

---

### Pseudocode

```python
# History data structure (available info):
# actions[t][i] = action of player i in round t ('C' or 'D')
# Indices: t in [1..r], i in [1..n]

def decide_action(t, n, r, actions):
    if t == 1:
        # First round: cooperate to foster cooperation
        return 'C'

    if t == r:
        # Last round: defect to avoid last-round exploitation
        return 'D'

    # For rounds 2 to r-1:
    # Check last round defection status
    last_round_actions = actions[t-1]  # actions of all players in round t-1

    if all(a == 'C' for a in last_round_actions):
        # Everyone cooperated last round
        return 'C'
    else:
        # At least one defection last round → punish by defecting
        # Now check if current round is fully cooperative so we can forgive next round
        # But we only act on observed data, so forgiveness is implicit in next round

        # Defect in current round to punish
        return 'D'
```

---

### Additional remarks

- **Why forgive?**  
  Without forgiveness, a single defection leads to permanent mutual defection (grim trigger). Forgiveness allows recovery to cooperation, sustaining higher average payoffs in noisy or uncertain environments.

- **Why defect last round?**  
  With perfect information and known end round r, rational players defect last round. Cooperating in last round can be exploited. Our strategy matches this rational behavior.

- **Potential weaknesses:**  
  This strategy is contingent on others also cooperating initially and sufficiently valuing future payoffs to maintain cooperation. However, given perfect monitoring and common knowledge, this is a natural equilibrium candidate.

---

### Summary

| Round        | Condition                         | Action       |
|--------------|---------------------------------|--------------|
| t = 1        | First round                     | Cooperate (C)|
| 2 ≤ t < r    | All players cooperated in t-1?  | C if yes, else D (punish) |
| t = r        | Last round                     | Defect (D)   |

---

This strategy promotes and sustains cooperation whenever possible, punishes defections to deter free-riding, but allows resumption of cooperation after mistakes, and strategically defects in the last round to avoid exploitation.
'''

description_COOPERATIVE_43 = '''
Below is a carefully tuned cooperative strategy for the N-Player Public Goods Game described.

---

### Strategy Name: Conditional Cooperation with Forgiveness (CCF)

---

### Intuition and Overview

- Aim: Promote and sustain mutual cooperation to maximize group payoff (everyone cooperating yields highest payoffs).

- Key tradeoff: Cooperate to build trust and maximize returns, but punish defection to discourage free-riding.

- Since defection is tempting (private payoff 1 vs cost of cooperation 1), we use conditional cooperation similar to "Tit-for-Tat" style strategies extended to multi-player setting, but with forgiveness to allow recovery from mistakes or noise.

---

### Decision Rules

Let:
- t = current round (1 ≤ t ≤ r)
- history = full vector of all players' past actions for rounds 1 to t-1; known perfectly by all players
- For round t, strategy decides action a_i,t ∈ {C, D}

---

### 1. First Round (t=1):

- Cooperate (C) unconditionally.

**Rationale:** Signal cooperation and attempt to establish mutual cooperation baseline.

---

### 2. For rounds 2 ≤ t < r (middle rounds):

- Calculate cooperation rate in previous round (t-1):

  \[
  coop\_rate = \frac{\sum_{j=1}^n \mathbb{1}_{\{a_{j,t-1}=C\}}}{n}
  \]

- Define a threshold:

  \[
  \theta = 0.8
  \]

  (80% cooperation considered sufficient to trust group cooperation)

- Decision:

  - If \( coop\_rate \geq \theta \), **Cooperate (C)**

  - Else, **Defect (D)**

**Explanation:**

- If a large majority cooperated last round, treat as cooperative environment → cooperate this round.

- If cooperation fell below threshold, punish by defecting (reducing your contribution saves the cost; defection punishes non-cooperators).

---

### 3. Forgiveness Mechanism:

- After defecting, do not defect forever.

- If you defected at round t-1, check if at round t-1 cooperation rate improved relative to round t-2. If so, revert to cooperation.

This prevents endless punishment loops.

---

### 4. Last round (t = r):

- Defect (D) unconditionally.

**Rationale:**

- In last round, no future rounds to enforce cooperation.

- Classical backward induction suggests defection, so given no incentive to cooperate, defect.

---

### Summary of decision function (pseudocode):

```
function decide_action(round t, history, player_id i):
    if t == 1:
        return C   # start cooperatively

    if t == r:
        return D   # last round, defect

    coop_prev = count_cooperators(round t-1) / n
    coop_prevprev = count_cooperators(round t-2) / n if t > 2 else 1.0

    my_prev_action = get_action(i, t-1)

    theta = 0.8  # cooperation threshold

    # Forgiveness logic
    if my_prev_action == D:
        if coop_prev > coop_prevprev:
            return C  # forgive and cooperate if cooperation improving
        else:
            return D  # continue defecting if cooperation not improving

    # Normal conditional cooperation
    if coop_prev >= theta:
        return C
    else:
        return D
```

---

### Key Features / Why This Works

- **Start cooperative**: Signal to others that you prefer cooperation.

- **Conditional cooperation**: Reward cooperation by cooperating only when a strong majority cooperated last round.

- **Punishment**: Defect if cooperation falls below threshold, exerting pressure on defectors.

- **Forgiveness**: Allow return to cooperation if cooperation rate improves, helping repair cooperation after occasional defections or errors.

- **Endgame defection**: Defect in final round to avoid exploitation as natural equilibrium.

---

### Handling Edge Cases

- **If cooperation rate drops slightly below threshold (e.g. 79%)**, defect to reinforce punishment. This harsh threshold promotes stable cooperation.

- **If t=2 and no history of round 0**, assume perfect past cooperation (coop_prevprev=1.0) to not unjustly punish forgiveness early.

- **Multiple defectors**: This strategy punishes by defecting too, driving defectors toward cooperation over time.

---

### Cooperative Mindset Alignment

- Maximizes group total payoff by sustaining cooperation throughout almost all rounds.

- Forgives lapses, allowing recovery from mistakes or experimental defections.

- Does not defect first (except last round), showing willingness to cooperate.

- Uses public knowledge meaningfully to reward cooperation, punish defection fairly.

---

If you want, I can also provide a detailed explanation of expected group dynamics or illustrative walkthroughs of the strategy interacting with various opponents. Just ask!
'''

description_COOPERATIVE_44 = '''
Below is a cooperative strategy designed for the N-Player Public Goods Game described. It aims to promote and sustain cooperation (mutual contribution) over repeated rounds while handling punishment and forgiveness to maintain cooperation in presence of defection.

---

## Strategy: **Gradual Reciprocity with Forgiveness**

### Intuition:
- Cooperate initially to signal willingness.
- Continue cooperating as long as everyone cooperated in the previous round.
- If defection is detected, defect in the next round as punishment but then try to return to cooperation if others do.
- On the last round, defect to avoid being exploited (standard backward induction logic).
- This strategy is designed to sustain cooperation, punish defection but not be trapped in endless defection loops.

---

### Decision Rules

Let:
- `t` = current round (1 to r)
- `history` = record of all players' actions in previous rounds
- `last_round_actions` = actions of all players in round t-1 (if t > 1)
- `all_cooperated_last_round` = True if every player chose C in round t-1, else False
- `someone_defected_last_round` = (not all_cooperated_last_round)

---

### Rules per round `t`:

**If t == 1 (First round):**  
- Cooperate (C): signal willingness to cooperate.

**Else if 1 < t < r (Intermediate rounds):**  
- If all players cooperated in the previous round (all_cooperated_last_round = True):  
  - Cooperate (C) again.  
- Else (someone defected previously):  
  - Defect (D) this round as punishment.  
- However, if in last round *everyone except me* defected, consider cooperating to break the punishment cycle.  
  *(Optional refinement: Forgive if others have returned to cooperation)*

**If t == r (Last round):**  
- Defect (D): since no future rounds remain, defect to maximize short-term payoff.

---

### Pseudocode

```
function decide_action(t, r, history, player_index):
    if t == 1:
        return C

    last_round_actions = history[t-1]  # array of size n with Cs and Ds

    all_cooperated_last_round = all(action == C for action in last_round_actions)
    someone_defected_last_round = not all_cooperated_last_round

    if t == r:
        # Last round - defect to avoid exploitation
        return D

    # Intermediate rounds
    if all_cooperated_last_round:
        # Mutual cooperation last round: continue cooperating
        return C
    else:
        # Punish defection by defecting this round
        # But check if all defected except self - attempt forgiveness
        other_defectors = [a for i, a in enumerate(last_round_actions) if i != player_index and a == D]
        other_cooperators = [a for i, a in enumerate(last_round_actions) if i != player_index and a == C]

        if len(other_defectors) == (len(last_round_actions) - 1):
            # Everyone else defected last round; try cooperating to break cycle
            return C
        else:
            # Defect to punish
            return D
```

---

### Explanation and Cooperative Alignment

- **Initial Cooperation:** Starts by cooperating to build trust.
- **Conditional Cooperation:** Keeps cooperating only if everyone else cooperated – encourages mutual cooperation.
- **Conditional Defection:** If defection is observed, defect to punish and discourage free-riding.
- **Forgiveness:** If others punish you collectively (all defect except self), try cooperating to signal willingness to return to cooperation.
- **Last round defect:** Protects self-interest at the end where no future retaliation is possible, per backward induction.
- **Repeated nature:** Uses history to adapt to collective behavior, balancing cooperation and punishment.

---

### Edge Cases:

1. **First round:** No history, so cooperate to open dialogue.
2. **Last round:** Defect - this is standard rational decision to avoid being exploited.
3. **All defect prior round:** Punish defection by defecting; but if all defect except you, try cooperating to re-initiate cooperation.
4. **Mixed cooperation/defection:** Punish defectors by defecting.
5. **Continuous cycles:** Gradual attempts to return to cooperation avoid infinite mutual defection.

---

This strategy should promote sustained cooperation against reasonable opponents by rewarding cooperation and punishing defection while maintaining an avenue for forgiveness, thus aligning with the cooperative mindset under repeated interaction constraints.
'''

description_COOPERATIVE_45 = '''
Below is a cooperative strategy tailored for the repeated N-Player Public Goods Game, designed to promote cooperation while being robust to potential defection by others. The strategy aims to maximize joint payoffs and signal cooperative intent clearly.

---

## Strategy Name: **"Firm Conditional Cooperation"**

### 1. Decision Rules

**Notation:**

- Let *t* denote the current round.
- Let *history* be the record of all players’ actions in prior rounds.
- Let *coop_count(t-1)* be the number of cooperating players in round t-1.
- Let *my_action(t-1)* be your own action in round t-1.
- Let *n* be number of players, *r* number of rounds.

---

### Core Logic

**Round 1 (t = 1):**

- Cooperate unconditionally.

> *Rationale:* Start by signaling willingness to cooperate since no history exists.

---

**Rounds 2 to r-1 (2 ≤ t ≤ r-1):**

- **If** in the previous round *all players cooperated* (i.e., coop_count(t-1) = n), **then** cooperate.
- **Else if** in the previous round the majority *cooperated* (coop_count(t-1) ≥ ceil(n/2)) AND *you cooperated* in the previous round, **then** continue to cooperate.
- **Otherwise**, defect.

> *Rationale:*  
> - Reward full cooperation by cooperating again.
> - Forgive occasional defection by others if majority still cooperated and you cooperated.
> - Punish sustained or significant defection to avoid exploitation.

---

**Final Round (t = r):**

- Defect unconditionally.

> *Rationale:* This is a one-shot end of the repeated game; cooperation incentives vanish (backward induction). Defecting here protects against last-round exploitation.

---

### Summary of Decision Function Pseudocode

```
function decide_action(t, history):

    if t == 1:
        return C  # Cooperate in first round

    last_round_actions = history[t-1]  # list of all players' actions in round t-1
    coop_count = count_C(last_round_actions)

    my_last_action = last_round_actions[self_index]

    if t == r:
        return D  # Defect on last round (standard backward induction)

    if coop_count == n:
        return C  # Everyone cooperated last round, stay cooperative

    if coop_count >= ceil(n/2) and my_last_action == C:
        return C  # Majority cooperated last round and I cooperated, stay cooperative

    return D  # Otherwise, defect to punish defection or avoid exploitation
```

---

## 2. Handling Edge Cases

- **First Round:** No prior information → cooperate to establish goodwill.
- **Last Round:** Defect, as no future retaliation/cooperation possible.
- **Partial Group Defection:** Forgive if majority cooperated and you cooperated, to allow for recovery from noise/accidents—avoids endless breakdown.
- **Sustained Defection:** Defect if majority defected or if you defected previously but others defected a lot, punishing free riders.
- **Tie Situations (even n):** Using `ceil(n/2)` means that exactly half cooperating or more counts as "majority cooperation," ensuring some tolerance.
- **Repeated Mutual Defection:** Once defection prevails, strategy holds to defection (except if all cooperate again, which resets cooperation).

---

## 3. Cooperative Mindset Alignment

- **Starts cooperative:** Signals willingness to build mutual cooperation.
- **Conditional cooperation:** Encourages others to cooperate by reciprocating cooperation when others mostly cooperate.
- **Forgiveness:** Allows recovery from mistakes or accidental defections rather than immediate harsh punishment.
- **Fairness:** Cooperative actions are continued only if the group mostly cooperates, protecting the player from exploitation.
- **Punishment:** Defection discourages persistent free-riding or exploitation, incentivizing social discipline.
- **Rational last-round defection:** Prevents being exploited when future cooperation no longer incentivizes good behavior.

This strategy promotes a stable environment favoring cooperation over repeated interaction, while being robust and self-protective when others do not reciprocate.

---

# Additional Notes

- The strategy requires no assumptions beyond observed actions.
- The strategy is memory-1 (depends only on last round’s actions) — easy to implement and stable.
- Can be tuned by adjusting the forgiveness threshold (e.g., majority threshold).
- Compatible with standard game theory and public goods game literature recommending conditional cooperation and backward induction at last round.

---

If you want, I can also provide a flowchart or a more verbose explanation. Let me know!
'''

description_COOPERATIVE_46 = '''
Here's a cooperative strategy designed for the N-Player Public Goods Game described. It aims to maximize collective payoffs by fostering cooperation whenever possible but also incorporates forgiveness and retaliation to discourage free-riding (defection).

---

## Strategy Name: **Forgiving Conditional Cooperation**

### Intuition

- **Start cooperatively:** Begin by cooperating to signal willingness to cooperate.
- **Reward cooperation:** Continue cooperating as long as all other players have cooperated in the previous round.
- **Punish defection proportionally:** If defectors are detected, defect in the next round as a form of punishment.
- **Forgive over time:** After punishment, return to cooperation if others resume cooperating, to avoid permanent deadlock.
- **End-game cooperation:** On the last round, cooperate regardless — since no future accountability is possible, defecting does not benefit others, and cooperating maximizes joint payoff.

---

### Definitions

- Let **history[t]** be the vector of all players' actions in round *t*.
- Let **round** be the current round number (1 ≤ round ≤ r).
- Let **c_i,t** = 1 if player *i* cooperated in round *t*, else 0.
- Let **defectorsInPrevRound** = set of players who defected in round *t-1*.

---

### Decision Rules

At the start of each round *t*:

1. **If t = 1 (first round):**  
   - Cooperate (`C`) unconditionally.
   
2. **If t = r (last round):**  
   - Cooperate unconditionally.
   
3. **If t > 1 and t < r:**
   - Inspect the actions of all players in round *t - 1*.
   - If **all** other players cooperated in round *t - 1*:  
     - Cooperate (`C`)
   - Else (at least one player defected in last round):  
     - Defect (`D`) in this round as punishment.
   - **Forgiveness:** After defecting for one round as punishment, if all players cooperated again in the immediate previous round, return to cooperating.
   
---

### Pseudocode

```python
# Inputs:
# history: List of length t-1 with each element being a list of n actions ['C' or 'D'] for round 1..t-1
# n, r, t: number of players, total rounds, current round
# my_index: index of this player (0-based)

def decide_action(history, n, r, t, my_index):
    if t == 1:
        # First round: start cooperating
        return 'C'
    
    if t == r:
        # Last round: cooperate unconditionally
        return 'C'
    
    last_round_actions = history[t-2]  # actions in round t-1
    # Check cooperation status of others in previous round
    others_cooperated = all(
        action == 'C' 
        for idx, action in enumerate(last_round_actions) if idx != my_index
    )
    
    if others_cooperated:
        # Others cooperated last round
        return 'C'
    
    else:
        # There was at least one defector last round
        
        # Check if we already defected last round (to implement single-round punishment)
        my_last_action = last_round_actions[my_index]
        
        if my_last_action == 'D':
            # We were defecting last round as punishment
            # Check current previous round: if all cooperated last round,
            # we forgive and go back to cooperate next round
            
            # So we must check round t-2 if t > 2
            if t > 2:
                prev_round_actions = history[t-3]
                all_coop_prev = all(
                    action == 'C' 
                    for idx, action in enumerate(prev_round_actions) if idx != my_index
                )
                if all_coop_prev:
                    return 'C'  # Forgive and cooperate
                else:
                    return 'D'  # Continue punishment if defection persists
            else:
                # No data older than last round, continue defecting this round
                return 'D'
        else:
            # We cooperated last round but saw defection from others -> punish now
            return 'D'
```

---

### Explanation and Properties

- **Starts cooperative:** Establishes trust initially — important in repeated games with unknown opponents.
- **Retaliates once:** A defection triggers a punishment defection *only in the immediately following round*, proportional and limited to one round. This discourages exploitation but avoids long grudges.
- **Forgiveness:** If after punishing defectors, all players revert to cooperating, this strategy reciprocates by returning to cooperation.
- **End-round cooperation:** Since the last round offers no incentive to maintain reputation, cooperating really is jointly beneficial.
- **No assumptions about opponent types or commitments:** Bases decisions solely on observable behaviors (actions).
- **Scalable:** Works for any number of players.

---

### Summary

| Round          | Condition                          | Action       |
|----------------|----------------------------------|--------------|
| 1              | Start of game                    | Cooperate    |
| r (last round) | End of game                     | Cooperate    |
| other rounds   | All others cooperated last round | Cooperate    |
| other rounds   | At least one defector last round | Punish by defecting (for 1 round) |
| After punishment round | Others cooperated            | Forgive and cooperate |
| After punishment round | Defection persists            | Continue defecting |

---

This design carefully balances cooperation, punishment, and forgiveness to promote sustained cooperation in a noisy environment with no communication or binding commitments. It is a well-known pattern akin to “Generous Tit-for-Tat” adapted for multi-player public goods settings.
'''

description_COOPERATIVE_47 = '''
Below is a clear cooperative strategy tailored for the N-player repeated public goods game described. It emphasizes mutual cooperation to maximize group payoff, uses observed history to sustain cooperation, and includes mechanisms to handle defections and end-of-game incentives.

---

### Strategy Name: **Conditional Cooperation with Forgiveness**

---

### Intuition and Goals

- **Cooperate initially** to establish trust and maximize mutual benefit.
- **Continue cooperating if others have cooperated recently.**
- **Punish defection temporarily** to discourage free-riding.
- **Forgive defections after a punishment phase** to allow return to cooperation.
- **Adjust behavior in the last round(s)** to avoid end-game defection collapse.
  
This aligns with achieving the highest possible collective payoff over repeated rounds.

---

### Detailed Decision Rules

**Definitions:**
- Let `t` be the current round index (1 ≤ t ≤ r).
- Let `C_j,t` = action of player j in round t (`1` if Cooperate, `0` if Defect).
- Let `history` = all observed actions from previous rounds.
- Define a *defection count* metric for recent rounds up to `d` rounds ago.
- Choose **punishment duration** `P` rounds after detecting defection.
- Set **look-back window** for checking cooperation `d` rounds (e.g., d=1 or 2).

---

### Decision Flow for Player i at Round t

1. **Round 1 (t = 1)**:  
   - Cooperate unconditionally (play C).  
   *Rationale:* Start cooperative to signal trust.

2. **Rounds 2 to r-1 (1 < t < r):**  
   - **Check recent cooperation in history window (last d rounds):**  
     - If *all* players cooperated in previous round(s) (say last 1 or 2 rounds), **Cooperate** (play C).  
     - If *any* player defected within the last `d` rounds, enter punishment mode:
       - Defect (play D) for a fixed punishment period `P` rounds.
       - *After* punishment period, *forgive* and revert to cooperation.  
     - Maintain a simple state variable:  
       - `is_punishing = True/False` and  
       - `punishment_rounds_left` counter.

3. **Final round (t = r):**  
   - Cooperate if **no defection in previous round**, to harvest mutual benefit one last time.  
   - Otherwise, defect to avoid being exploited.

---

### Pseudocode Example

```python
# Parameters (tunable according to tournament environment)
d = 1        # number of past rounds to check for defection
P = 1        # punishment duration in rounds

# State variables (persist across rounds)
if t == 1:
    is_punishing = False
    punishment_rounds_left = 0

# Function to check defection in last d rounds for any player
def recent_defection(history, current_round, d):
    # history: list of lists with actions of all players per round
    start = max(0, current_round - d - 1)
    for past_round in range(start, current_round - 1):
        if any(action == 'D' for action in history[past_round]):
            return True
    return False

# Decision rule wrapped in function
def choose_action(t, r, history, is_punishing, punishment_rounds_left):

    if t == 1:
        # Start by cooperating
        return 'C', is_punishing, punishment_rounds_left

    if is_punishing:
        # Continue punishment if still rounds left
        punishment_rounds_left -= 1
        if punishment_rounds_left == 0:
            is_punishing = False
        return 'D', is_punishing, punishment_rounds_left

    # Check if any defection was observed recently
    if recent_defection(history, t, d):
        # Enter punishment mode
        is_punishing = True
        punishment_rounds_left = P - 1  # -1 because punishing this round
        return 'D', is_punishing, punishment_rounds_left

    # Last round special case
    if t == r:
        # If everyone cooperated last round, cooperate now
        if not recent_defection(history, t, 1):
            return 'C', is_punishing, punishment_rounds_left
        else:
            # Otherwise defect to protect from exploitation
            return 'D', is_punishing, punishment_rounds_left

    # Default: cooperate if no recent defection and not punishing
    return 'C', is_punishing, punishment_rounds_left
```

---

### Strategy Rationale and Properties

- **First round cooperation:** Sends a clear cooperative signal and maximizes joint payoff.
- **Conditional cooperation:** Rewards mutual contributors, punishes defectors.
- **Short punishment duration:** Avoids long-term breakdown of cooperation; recognizes mistakes/noise may happen.
- **Forgiveness:** Allows resetting cooperation if others “return to the fold.”
- **End-round defection prevention:** Cooperative decision in the final round to avoid unraveling payoffs.
- **Simplicity:** Uses minimal memory (only recent rounds and simple state) to adapt dynamically.

---

### Handling Edge Cases

- **If unilateral defection occurs (one player defects):**  
  Punish briefly by defecting in next `P` rounds to incentivize return to cooperation.

- **If multiple defectors:**  
  Punishment applies equally; the cost of defecting rises.

- **If nobody defects ever:**  
  Cooperation continues through all rounds, maximizing payoff (k > 1 ensures higher payoffs than all-D).

- **If all defect from start:**  
  Strategy defects in response after detecting defection; limited recovery possible.

- **If the last round:**  
  Cooperate only if previous round was cooperative; otherwise defect to avoid exploitation.

---

### Summary

| Round        | Condition                         | Action    | Notes                       |
|--------------|---------------------------------|-----------|-----------------------------|
| t = 1        | Always                          | Cooperate | Start cooperative            |
| 1 < t < r    | Last d rounds no defection      | Cooperate | Reward cooperation           |
| 1 < t < r    | Defection detected in last d rounds | Defect    | Punish defectors for P rounds|
| t = r        | No defection in round t-1       | Cooperate | Final cooperation to reap benefit |
| t = r        | Defection in round t-1           | Defect    | Avoid exploitation on last turn |

---

This strategy balances generosity with discipline and leverages the repeated nature of the game to sustain cooperation and achieve high social welfare consistent with the public goods framework.
'''

description_COOPERATIVE_48 = '''
Here is a cooperative strategy design tailored for the N-Player Public Goods Game described. The strategy is grounded in reciprocity, aiming to sustain mutual cooperation while guarding against exploitation (defection) by others.

---

### Strategy Name: **Grim Trigger for Public Goods**

---

### Key Idea

- Start fully cooperative to signal willingness to contribute.
- Continue cooperating as long as *all* other players have cooperated in **all previous rounds**.
- Upon detecting **any defection by any player in any past round**, switch to permanent defection for the remainder of the game.
- The last round still follows this rule: cooperate if all have cooperated previously; otherwise defect.

This strategy promotes long-term public good provision if everyone is cooperative, but punishes any defection harshly to deter free-riding.

---

### Reasons for Design Choices

- **Start cooperative:** Maximizes payoffs if others reciprocate.
- **Grim Trigger punishment:** Immediate and permanent defection after detecting defection maximizes deterrence; no need for probabilistic forgiveness due to the one-shot temptation to defect.
- **No defection in last round except if triggered:** Since there is no future threat after the last round, some strategies defect there. But in a tournament with unknown opponents, maintaining cooperation in the last round can secure mutual gains if opponents do too. If defectors appear earlier, defecting last round is consistent.
- **No reliance on signaling or coordination:** Respects no-communication constraint.
- **Fair to all players:** Uses only observable history, punishes defectors evenly.

---

### Formal Decision Rule

For player *i* at round *t*:

Let  
- `History_t` = actions of all players in rounds 1 to t-1  
- `AnyDefect` = true if any player j ≠ i has defected in any round before t, else false

**Decision:**

```
if t == 1:
    play C  # cooperate in first round

else if AnyDefect == false:
    play C  # cooperate if no defection observed previously

else:
    play D  # defect permanently if any defection observed
```

---

### Pseudocode

```python
def decide_action(t, history):
    # history: list of rounds, each round is a dict {player_id: action}
    # actions are 'C' or 'D'
    
    if t == 1:
        return 'C'  # cooperate on first round
    
    # Check if any defection ever occurred before round t
    for past_round in history:
        for p_action in past_round.values():
            if p_action == 'D':
                return 'D'  # defect forever
    
    return 'C'  # cooperate if no defection in history
```

---

### Handling Edge Cases

- **First round (t=1):** Always cooperate to establish trust.
- **Last round (t=r):** Still cooperate if no defection ever occurred to maximize mutual payoff. If defection observed earlier, defect.
- **If a single opponent defects once:** Punish forever by defecting all remaining rounds, discouraging free riding.
- **If other players' cooperation is partial or intermittent:** The trigger activates on first defection; strategy defects from then on.

---

### Cooperative Mindset

This strategy explicitly aligns incentives to sustain cooperation:

- It starts fully cooperative, maximizing potential collective gain.
- It signals a willingness to reward cooperation with cooperation.
- It uses severe punishment to deter defection, thus protecting cooperative players.
- It ensures that cooperation is self-enforcing when opponents are also cooperative.

---

### Summary

| Round           | Condition                       | Action     |
|-----------------|--------------------------------|------------|
| 1               | No history                     | Cooperate  |
| t > 1           | No defection in rounds 1..t-1 | Cooperate  |
| t > 1           | Any defection previously      | Defect     |

---

This simple, well-known, and robust “Grim Trigger” style strategy is highly cooperative, promotes mutual cooperation efficiently, punishes defection reliably, and fits the perfect information repeated public goods game setup you provided.
'''

description_COOPERATIVE_49 = '''
Here is a carefully designed cooperative strategy for the N-Player Public Goods Game described.

---

## Cooperative Strategy: “Reciprocal Conditional Cooperation with Forgiveness”

---

### Intuition and Goals

- **Goal:** Achieve and maintain mutual cooperation across all rounds to maximize total payoffs for all.
- **Reasoning:** 
  - Mutual cooperation (all cooperate) yields the highest per-round payoff (k > 1 implies public good share exceeds private cost).
  - Defections reduce group payoffs and the defector is better off only if others cooperate.
  - Sustaining cooperation requires conditional responses to defections plus forgiveness to avoid permanent collapse.

---

### 1. Decision Rule Overview

- **Round 1 (Initial Round):**  
  Cooperate unconditionally to initiate mutual cooperation.

- **Round t (2 ≤ t < r):**  
  - If *all players cooperated* in the previous round, cooperate this round.  
  - Else if there was at most one defection in the previous round, cooperate — **forgive occasional mistakes** or accidental defections.  
  - Else if multiple defections occurred last round, defect — **punish sustained defection** to incentivize return to cooperation.

- **Round r (Final Round):**  
  - Defect to maximize last-round payoff since no future rounds remain to enforce cooperation (standard backward induction logic).  
  - Optionally, cooperate if strong emphasis on group welfare is desired even in the last round.

---

### 2. Handling Edge Cases and Special Considerations

- **First Round:**  
  No prior info, start cooperative to signal willingness to cooperate.

- **Second Round:**  
  Use previous round's full cooperation status since only one round with data.

- **Last Round:**  
  Defect by default since no incentive to sustain cooperation; opponents expect defection.

- **Forgiveness Threshold:**  
  Allow forgiveness if only one defection occurred in the previous round — accounts for noise, errors, or random deviations.

- **Multiple Defections:**  
  Punish by defecting to discourage groups drifting to mutual defection.

- **No Reputation or Communication:**  
  Decisions rely solely on observed actions of all players from previous rounds.

---

### 3. Formal Pseudocode

```
Input: history of previous rounds actions, current round t, total rounds r, number of players n

function decide_action(history, t, r, n):
    if t == 1:
        # First round: Cooperate unconditionally
        return 'C'

    previous_actions = history[t-1]  # actions of all players in the previous round, indexed 1..n
    num_defectors = count of players j such that previous_actions[j] == 'D'

    if t == r:
        # Final round: defect (backward induction)
        return 'D'

    else:
        if num_defectors == 0:
            # All cooperated last round: continue cooperating
            return 'C'

        elif num_defectors == 1:
            # One defection only: forgive, cooperate
            return 'C'

        else:
            # Multiple defections: punish by defecting
            return 'D'
```

---

### 4. Explanation and Justification

- **Cooperation in round 1** signals willingness to cooperate because mutual cooperation benefits everyone.
- **Cooperating if all previously cooperated** reinforces the cooperative equilibrium.
- **Forgiving a single defection** accommodates noise, accidental defection or exploratory plays by others, enabling recovery.
- **Defecting after multiple defections** punishes coordinated free-riding or collapse of cooperation, discouraging group-wide exploitation.
- **Defecting in the last round** follows the classical game-theoretic predictable backward-induction outcome in finitely repeated games.
- This strategy is **clear, easily observable and transparent** to opponents.
- It **balances cooperation and discipline**, sustaining cooperation without being gullible or too rigid.

---

### 5. Extensions (Optional)

- Use a **memory window** of more than one round to detect trends in defection frequency before punishing.
- Introduce **probabilistic forgiveness** to smooth transitions between cooperation and defection.
- If the tournament meta-data suggests noisy behavior, be more forgiving.
- In case of strong last-round cooperation preferences, cooperate also on the last round.

---

This strategy provides a robust, principled way to promote and sustain cooperation in the repeated Public Goods Game under the given constraints. It is easy to implement and interpretable by other players, increasing the chances of stable cooperation in a heterogeneous tournament environment.
'''

description_COOPERATIVE_50 = '''
Here is a carefully designed cooperative strategy for the repeated N-Player Public Goods Game. It is inspired by well-studied repeated game cooperation principles (like tit-for-tat and its generalizations) but adapted for this multi-player, simultaneous move setting with no communication.

---

## Cooperative Strategy: Conditional Cooperative Trigger Strategy (CCTS)

### Intuition
- **Aim:** Maximize group payoff by cooperating as long as others appear cooperative.
- **Punish defections immediately but mildly:** Defect one round if any player defected last round, then give players a chance to return to cooperation.
- **Renew cooperation:** Return to cooperate if all players cooperate again, to avoid long-lasting mutual defection.
- **Maintain cooperation from start:** Cooperate in the first round since cooperation yields higher total payoffs.
- **Handle last round with defection:** Defect in the final round as there are no future costs to retaliation (standard backward induction rationality).

---

### Full Description

#### Notation Recap
- \( t \) = current round number (1 to \( r \))
- \( a_i^{(t)} \) = your own action in round \( t \) (C or D)
- \( A_{-i}^{(t)} \) = vector of all other players’ actions in round \( t \)
- \( H^{(t-1)} \) = full action history up to round \( t-1 \)

---

### Decision Rules per Round \( t \):

1. **Round 1: Cooperate**
   - No past history.
   - Cooperate to establish the cooperative baseline.

2. **Rounds 2 to \( r-1 \): Conditional Cooperation**
   - Check if in round \( t-1 \) **all** players (including self) played Cooperate (C).
     - If yes, cooperate this round \( t \).
   
   - If in round \( t-1 \) **any** player defected (played D):
     - Defect this round \( t \) (punishment round).
     - This is a single-round "retaliation" to discourage defection.
   
   - **After the punishment round, if in the subsequent round all players cooperate again:**
     - Forgive and return to cooperation.
   
   - This creates a mild “grim-trigger with forgiveness” style:
     - Punish defections immediately and only one round of defection.
     - Return to cooperation quickly if everyone cooperates after punishment.

3. **Round \( r \) (Final Round): Defect**
   - No incentive to cooperate in last round (no future retaliation).
   - Defect to gain private payoff, optimizing final self payoff.

---

### Pseudocode

```
function decide_action(t, history, r):
    if t == 1:
        return C

    if t == r:
        return D

    last_round_actions = history[t-1]

    # Check if there was a defection last round
    if D in last_round_actions:
        # Check if this round is immediate punishment round after defection
        # We punish exactly one round after last defection.
        # To detect if we are currently in punishment round: 
        # Check if previous round had any defection, and two rounds ago was cooperative.

        # Check two rounds ago for cooperation to avoid chaining punishments indefinitely
        if t-2 >= 1:
            two_rounds_ago_actions = history[t-2]
            if all(action == C for action in two_rounds_ago_actions):
                # This is punishment round -- defect
                return D
        
        # Otherwise, check if the punishment round ended and cooperation resumed
        # If not in punishment round, cooperate if last round fully cooperative
        if all(action == C for action in last_round_actions):
            return C
        
        # Otherwise defect to be consistent (safe default)
        return D

    else:
        # If last round fully cooperative, cooperate now
        if all(action == C for action in last_round_actions):
            return C
        else:
            # unlikely branch, fallback
            return C
```

---

### Explanation of Logic

- **First round:** we lead by cooperating, hoping to establish cooperative norm.
- **If last round was all cooperate:** we continue cooperating.
- **If any defection last round:** defect this round to punish.
- **We punish only exactly one round:** by checking if two rounds ago was full cooperation — if yes, current round with defection is the punishment; after that, if all revert to cooperation, we cooperate again.
- **In the final round:** defect, the backward induction dominates here.

---

### Why This Strategy Is Cooperative?

- It starts cooperatively and maintains cooperation as long as all others cooperate.
- Punishment is limited to one round per defection incident to avoid permanent breakdown.
- Forgiveness encourages resumption of cooperation.
- It balances the risk of exploitation (punishes defectors) with flexibility (forgives and returns).
- Respects standard rationality by defecting in final round.

---

### Edge Cases

1. **Multiple defections in consecutive rounds by different players?**
   - Each defection triggers a punishment round, but only one punishment round per defection incident, avoiding endless defections.
2. **If others are unconditional defectors?**
   - You switch to defect next round to avoid losing when others free-ride; second round onwards punish and defect to minimize loss.
3. **In games with very few rounds (e.g., r=2)?**
   - Cooperate round 1, defect round 2.
   - This fits backward induction.
4. **If history is empty or inconsistent?**
   - Treat empty as round 1, cooperate.
5. **If all cooperate until last round, then defect on last round?**
   - You defect last round, consistent with self-interest.

---

### Summary

| Round     | Behavior                               | Reason                                |
|-----------|--------------------------------------|-------------------------------------|
| 1         | Cooperate                            | Initiate cooperation                 |
| 2 to r-1  | If last round all cooperated → cooperate, else defect one punishment round | Sustain cooperation, punish defectors, forgive quickly |
| r (final) | Defect                              | No future retaliation; optimize payoff |

---

This strategy strikes a balance between enforcing cooperation, punishing defection, and forgiving to regain cooperation, aligned with maximizing collective payoffs in an uncertain environment without communication or coordination. It will perform well against other conditional cooperators and avoids being exploited excessively by defectors.

---

If you want, I can also provide a more formal state machine or flowchart for this logic.
'''

description_COOPERATIVE_51 = '''
Here is a cooperative strategy designed for the N-Player Public Goods Game as specified, focused on fostering cooperation with built-in forgiveness and punishment mechanisms:

---

### Strategy Name: Forgiving Conditional Cooperator (FCC)

---

### Intuition:

- Start with cooperation to signal a cooperative intention.
- Continue cooperating as long as all other players cooperated in the previous round.
- Punish defections by defecting once after detecting any defection.
- Forgive after a single round of punishment by returning to cooperation.
- In the last round, defect (since no future punishment or reward is possible).

---

### Detailed Decision Rules:

**In round t (1 ≤ t ≤ r):**

1. **If t = 1 (First round):**  
   - Play **C** (cooperate).  
   *Rationale:* Lead by example to establish cooperation.

2. **If 1 < t < r (Intermediate rounds):**  
   - If **all players (including yourself) cooperated in round t-1**, play **C**.  
   - If **any player defected in round t-1**, then:  
     - If you defected in round t-1 (you are currently punishing), **return to cooperating (C)** this round (forgiveness).  
     - Otherwise (you cooperated in round t-1 but noticed defection), **defect (D)** this round to punish.  

3. **If t = r (Last round):**  
   - Play **D** (defect).  
   *Rationale:* Defection maximizes immediate payoff when no future rounds can reward cooperation.

---

### Summary of Behavior Over Time:

| Round | Condition                                              | Action          |
|-------|---------------------------------------------------------|-----------------|
| 1     | First round                                             | Cooperate (C)   |
| 2..r-1| Previous round all cooperated                            | Cooperate (C)   |
| 2..r-1| Defection detected previous round + currently cooperating| Defect (D) (punish) |
| 2..r-1| Defection detected previous round + currently defecting| Cooperate (C) (forgive)|
| r     | Last round                                              | Defect (D)      |

---

### Pseudocode:

```python
def FCC_strategy(t, r, history):
    # history is a list of tuples: each tuple contains n actions from previous rounds
    # actions in {'C', 'D'}
    
    if t == 1:
        return 'C'  # first round cooperate
    
    if t == r:
        return 'D'  # last round defect
    
    prev_round = history[-1]
    all_cooperated = all(a == 'C' for a in prev_round)
    
    # Your previous action
    your_prev_action = history[-1][your_index]  # Assume your_index known
    
    if all_cooperated:
        return 'C'  # continue cooperating
    
    # There was at least one defection last round
    if your_prev_action == 'D':
        # You are currently punishing, so forgive now
        return 'C'
    else:
        # You cooperated last round but others defected, punish now
        return 'D'
```

---

### Explanation:

- **Cooperation by default:** This strategy always tries to maximize group payoffs through mutual cooperation.
- **Punishment:** Defection by any player leads to a single-round punishment phase to discourage exploitation.
- **Forgiveness:** After punishing once, the strategy resumes cooperation to avoid endless retaliation.
- **Last round defection:** Self-interested reasoning forces defection on the last round since there are no future rounds to enforce cooperation.
- **Robustness:** It does not rely on explicit communication or trust assumptions beyond observing past actions, suitable given perfect and common knowledge.

---

### Edge Cases & Additional Notes:

- If multiple players adopt FCC, stable full cooperation is sustained.
- If others defect, the strategy enforces a clear, predictable punishment and quickly returns to cooperation, minimizing payoff loss.
- In very short games (e.g., r = 2), expect cooperation in round 1 and defection in round 2.
- It does not attempt to "outsmart" defectors who defect persistently but tries to maximize cooperation when others reciprocate.

---

This strategy aligns clearly with the cooperative mindset while being realistically self-interested in the last round and when facing defection, making it a balanced, tournament-ready approach.
'''

description_COOPERATIVE_52 = '''
Below is a detailed cooperative strategy for the N-Player Public Goods Game under the given assumptions and constraints.

---

### Strategy Name: **Conditional Cooperation with Forgiveness**

---

### Intuition and Rationale

Because cooperation (C) yields a higher group payoff than defection (D), mutual cooperation is socially optimal. However, unilateral cooperation can be exploited, so the strategy promotes cooperation but punishes defection to sustain mutual cooperation. To avoid permanent collapse due to one defection, it includes forgiveness and re-tests cooperation.

---

### 1. Decision Rules: When to Cooperate or Defect

- **Round 1 (no history):**  
  Cooperate (C).  
  _Rationale: Start by building trust and achieving the cooperative outcome._

- **Rounds 2 to r-1:**  
  - After each round *t-1*, observe the actions of all players.  
  - If, in the previous round, **all players cooperated (including self)**, **cooperate** again this round.  
    _Rationale: Mutual cooperation sustains maximal payoffs._  
  - If any player defected in the previous round:  
    - **Defect this round** as punishment (retaliation) against free-riders.  
    - But in the subsequent round (t+1), **forgive and cooperate** once, regardless of others’ actions, to give chance for restoring cooperation.  
    - If defection persists beyond one punishment round, continue defecting until full cooperation is observed again.

- **Last round (round r):**  
  Since there is no future, **defect** to avoid being exploited in the final round.  
  _Rationale: Backward induction prescribes defection in the last stage since cooperation can no longer be reciprocated._

---

### 2. Handling Edge Cases

- **First Round:** Always cooperate; no history exists.

- **Last Round:** Always defect; no incentive to cooperate when no future punishment/reward can follow.

- **Punishment and Forgiveness Dynamics:**

  To be explicit, maintain a simple state variable per round:

  - `state = "cooperate"`: when trusting mutual cooperation  
  - `state = "punish"`: after observing defection, defect 1 round  
  - `state = "forgive"`: after punish, try cooperating once  

  Transition rules:  
  - Start with `state = "cooperate"` in round 1.  
  - If all cooperated last round, remain in `"cooperate"`.  
  - If defection detected last round and state was `"cooperate"`, switch to `"punish"`.  
  - If `state == "punish"` this round, next round go to `"forgive"`.  
  - If `state == "forgive"` this round, check if all cooperated last round:  
    - If yes, return to `"cooperate"`.  
    - If any defection, return to `"punish"` and continue cycle.

---

### 3. Full Pseudocode

```python
# Inputs:
#   history: list of rounds, each round a list of actions by all players ['C' or 'D']
# Variables per player: state in {'cooperate', 'punish', 'forgive'}, initialized to 'cooperate'

def choose_action(round_t, history, state, player_index, total_rounds):

    # Last round defect rule
    if round_t == total_rounds:
        return 'D', state  # Defect in final round
      
    # Round 1: no history, cooperate
    if round_t == 1:
        return 'C', 'cooperate'
    
    # From round 2 to r-1:
    last_round_actions = history[-1]  # list of length n
    
    # Check if all cooperated last round
    all_cooperated = all(action == 'C' for action in last_round_actions)
    
    if state == 'cooperate':
        if all_cooperated:
            # Continue cooperating
            return 'C', 'cooperate'
        else:
            # Someone defected, start punishment
            return 'D', 'punish'
        
    elif state == 'punish':
        # Punish this round, then forgive
        return 'D', 'forgive'
    
    elif state == 'forgive':
        # Forgive by cooperating once
        if all_cooperated:
            # Cooperation restored
            return 'C', 'cooperate'
        else:
            # Defection persists, return to punish
            return 'D', 'punish'
```

---

### 4. Explanation

- The strategy starts by cooperating, encouraging maximal group benefit.
- Whenever defection occurs, it punishes by defecting for one round, signaling that defection will not be tolerated.
- Then it forgives and cooperates once, testing if others return to cooperation.
- This cycle helps recover cooperation after occasional mistakes or exploration by others.
- Defects in the final round because future punishment is impossible.
- This strategy aligns with folk-theorem logic: it supports cooperation sustained by threat of punishment, yet includes forgiveness to avoid permanent mutual defection.
- It is simple, memory-efficient (only previous round needed), transparent and robust.

---

### Summary

| Round     | Action                                      | State Update             | Purpose                                      |
|-----------|---------------------------------------------|--------------------------|----------------------------------------------|
| 1         | Cooperate (C)                               | Set state = cooperate    | Start cooperative behavior                    |
| 2...r-1   | If last round all C → cooperate (C)         | Maintain cooperate state | Reward mutual cooperation                      |
|           | Else if defection last round & state=cooperate → defect (D) | state = punish           | Punish defection                              |
|           | If state = punish → defect (D)               | state = forgive          | Continue punishing one round                   |
|           | If state = forgive → cooperate (C)           | state=cooperate if all C last round, else punish | Forgive to test cooperation restoration        |
| r (last)  | Defect (D)                                  | Final round no future    | Avoid exploitation in last round               |

---

This strategy cooperates as much as possible but guards against exploitation while allowing restoration of cooperation. It should perform well in tournaments against rational strategies due to its clarity, forgiveness, and defensibility.
'''

description_COOPERATIVE_53 = '''
Here is a cooperative strategy designed for an n-player repeated public goods game as specified. The strategy is inspired by the classic principle of reciprocity combined with forgiveness, adapted to the public goods environment with multiple players.

---

## Strategy Name: Forgiving Conditional Cooperation (FCC)

### Intuition:
- Start cooperatively, assuming others are willing to cooperate.
- Continue cooperating only if a substantial fraction of players cooperated in the previous round.
- If too few players cooperated last round, punish by defecting once to discourage free-riding.
- Quickly forgive for occasional defections to maintain cooperation.
- On the last round, defect (standard backward induction) because no future rewards or punishments will follow.

---

### 1. Decision Rules
Define **threshold proportion of cooperation**, `T = 0.7` (70%) as the minimum fraction of cooperators in the previous round to maintain cooperation.

At each round `t` (1 ≤ t ≤ r):

- **If t = 1 (first round)**:
  - Play **C** (cooperate), initiating with trust/cooperation.

- **If 1 < t < r (middle rounds)**:
  - Observe `fraction_cooperators = (# of players who played C in round t-1) / n`
  - If `fraction_cooperators >= T` (at least 70% cooperated last round):
    - Play **C**
  - Else:
    - Play **D** once (punishment round)
  - However, to avoid permanent retaliation: in round `t` if last round you defected (punishment), and now `fraction_cooperators >= T`, return to cooperation.

- **If t = r (last round)**:
  - Play **D**, as there's no future to enforce cooperation and defecting maximizes individual payoff.

---

### 2. Handling Edge Cases and Justification

- **First round:** No prior history — cooperate to initiate trust.
- **Last round:** Defect due to backward induction (no future incentives).
- **Occasional defections:** The threshold `T=0.7` allows for a small number of defections without triggering punishment, thus tolerating noise or occasional mistakes.
- **Punishment round:** One-shot defection signals displeasure. The strategy punishes only once per defection episode before forgiving.
- **Perfect information:** Observe exact contributions to compute `fraction_cooperators`.
- **Multiple defectors scenario:** If cooperation falls below threshold, defect once to signal and disrupt free-riding.
- **No communication & no coordination:** Since all players can observe all actions, using aggregate cooperation rate works best for publicly observed cooperation level.

---

### 3. Pseudocode

```python
def FCC_strategy(round_index, history, n, r, k):
    """
    Parameters:
    - round_index : current round (1-indexed)
    - history : list of lists, each inner list is actions of all players in that round ['C' or 'D']
                e.g., history[t-2] gives actions of all players in round t-1 (for rounds after 1)
    - n : number of players
    - r : total rounds
    - k : multiplication factor (not used in logic, but known)
    Returns:
    - action : 'C' or 'D'
    """

    T = 0.7  # threshold for cooperation fraction
    me = my_player_index  # your player index (0-based assumed)

    if round_index == 1:
        # First round: cooperate
        return 'C'

    elif round_index == r:
        # Last round: defect
        return 'D'

    else:
        # Previous round actions
        prev_round_actions = history[round_index - 2]
        count_cooperators = sum(1 for a in prev_round_actions if a == 'C')
        fraction_cooperators = count_cooperators / n

        # Determine whether I defected last round
        last_action = history[round_index - 2][me]

        if fraction_cooperators >= T:
            # Generally cooperate if cooperation was good
            # After punishing once, return to cooperation if threshold met
            return 'C'
        else:
            # Cooperation below threshold
            # If I defected last round, now forgive and cooperate to restore trust
            if last_action == 'D':
                # forgiveness step
                return 'C'
            else:
                # Punish defectors
                return 'D'
```

---

### Summary

| Round          | Decision Rule                                    |
|----------------|-------------------------------------------------|
| First round    | Cooperate                                       |
| Middle rounds  | Cooperate if ≥70% cooperators last round; else defect once as punishment, then forgive next round if cooperation improves |
| Last round     | Defect                                         |

This strategy embodies conditional cooperation with measured punishment and forgiveness. It promotes collective cooperation to maximize group payoffs while being robust to isolated defections, thus supporting a cooperative mindset without being exploitable.
'''

description_COOPERATIVE_54 = '''
Here is a cooperative strategy designed for the described N-player repeated public goods game that aligns with the objective of sustaining cooperation to maximize total group payoff:

---

## Cooperative Strategy: **"Gradual Forgiver with Final Cooperation"**

### Intuition and Rationale

- The socially optimal outcome occurs when everyone cooperates each round (π_i = k), which is better than defection.
- However, unilateral cooperation can be exploited.
- Full defection by others reduces payoff to 1, so we want to encourage cooperation but punish defections to deter free-riding.
- The last round is a "one-shot" scenario, so cooperation is risky without future incentives; to preserve a cooperative reputation, we cooperate even in the last round.
- We allow some forgiveness to recover from mistakes or noise (e.g., isolated defections), rather than punishing a single defection harshly.
- The strategy does not require explicit communication or complex coordination—only observation of past rounds.

---

### Decision Rules

**Notation:**
- Let \( t \) be the current round (1 ≤ \( t \) ≤ \( r \))
- Let \( H_{t-1} = \{c_j^{(s)} : j=1,...,n; s=1,...,t-1 \} \) be the history of cooperations
- Let \( O_{t-1} \) be the set of players who defected in round \( t-1 \)
- Let \( f \) be a forgiveness threshold (number of rounds to wait before resuming cooperation after defection)

---

### Pseudocode

```
Initialize:
    forgive_counter[i] = 0 for all players i ≠ self

For each round t = 1 to r:

    if t == 1:
        # First round: cooperate to signal cooperative intent
        play C

    else if t == r:
        # Last round: cooperate to maximize group payoff, despite defection risk
        play C

    else:
        # For rounds in between:
        observe actions of all players in round t-1

        for each player j ≠ self:
            if player j defected in round t-1:
                forgive_counter[j] = f   # start forgiveness timer

            else if forgive_counter[j] > 0:
                forgive_counter[j] -= 1  # decrement forgiveness timer if active

        # Decide whether to cooperate or defect this round:
        # Cooperate if no unforgiven defectors exist (all forgive_counter == 0)
        # Defect otherwise

        if all forgive_counter[j] == 0 for j ≠ self:
            play C
        else:
            play D
```

---

### Explanation

- **Round 1:**  
  Start cooperatively to encourage mutual cooperation and maximize gains.

- **Rounds 2 to r-1:**  
  - Monitor defectors from previous round.
  - Mark defectors and punish by defecting against them until they are "forgiven" after \( f \) rounds.
  - The forgiveness counter allows recovery from occasional defections or noise, preventing permanent mutual defection spirals.
  - Only cooperate if all other players are currently forgiven; defect if anyone is currently being punished.

- **Round r (last round):**  
  Cooperate regardless, as defecting here yields no future benefit and reduces total payoff. This is a standard endgame cooperation choice in repeated games for social welfare.

---

### Parameter Choice

- Forgiveness threshold \( f \)  
  Set \( f = 1 \) or \( f = 2 \) to allow quick forgiveness, balancing tolerance with discouraging repeated defection.

---

### Properties and Benefits

- **Cooperative mindset:** The agent always starts and ends cooperating and aims to cooperate if others cooperate.
- **Retaliation:** Defectors are punished temporarily, discouraging exploitation.
- **Forgiveness:** Occasional defections do not cause permanent breakdown of cooperation.
- **Simple:** Uses only observable past actions; no complicated prediction or assumptions beyond game rules.
- **Robust:** Handles edge cases and last-round conditions naturally.
- **Equitable:** Treats all players equally, punishing defectors without bias.

---

### Summary

| Round         | Condition                                      | Action     |
|---------------|------------------------------------------------|------------|
| 1 (first)     | No history                                     | Cooperate (C) |
| 2 ≤ t < r     | Cooperate if all forgiven; else defect        | C or D     |
| r (last)      | Always cooperate                               | C          |

---

This **Gradual Forgiver with Final Cooperation** strategy maximizes social welfare over repeated rounds by fostering cooperation, punishing defections calmly and temporarily, and cooperating on the last round to prevent endgame collapse.

---

If you want, I can also provide a more formal state-machine description or example code snippets. Let me know!
'''

description_COOPERATIVE_55 = '''
Here is a carefully designed **Cooperative Strategy** for the given N-player repeated Public Goods Game, aiming to sustain cooperation while adapting to defections by others. It is inspired by forgiving reciprocity and conditional cooperation principles.

---

## Cooperative Strategy Description

### Intuition

- Aim: Maximize collective welfare by sustaining cooperation (everyone contributes).
- Start cooperatively to signal willingness to build trust.
- Punish defections by defecting in the next round to discourage free-riding.
- Be forgiving if defections cease, returning to cooperation to restore cooperation.
- Near the end, defect if needed to avoid exploitation (standard backward induction).
  
---

### Decision Rules

Let:
- t denote the current round, t ∈ {1, ..., r}
- H_{t-1} denote history of all players' actions in previous rounds
- For round t > 1, let `players_who_defected_in_prev_round` be the set of players who defected in round t-1
- Let `total_defections_in_prev_round` be the total number of defectors in round t-1.

Player i's action at round t is:

1. **Round 1 (t=1): Cooperate**

   - No prior history → start by cooperating to establish mutual cooperation.

2. **Early to middle rounds (1 < t < r): Conditional Cooperation**

   - If all players cooperated in round t-1 (i.e., no defections), **Cooperate**.
   - Else (if there were defectors in t-1),
     - If player i defected in t-1, **Cooperate** (self forbearance to return to cooperation).
     - Else (player i cooperated in t-1), **Defect** to punish defectors.
   
   This implements a *"contrite Tit-for-Tat"* style move: cooperators punish defectors, but defectors get a chance to rejoin cooperation by cooperating next round.

3. **Last round (t = r): Defect**

   - Defect in the final round to avoid exploitation: cooperating in the last round yields no future benefit and risks being exploited.

---

### Edge Cases Addressed

- **First round:** No history → Start cooperation, signaling willingness.
- **Last round:** Since no future rounds to reward or punish cooperation/defection, defect to maximize immediate payoff.
- **Multiple defectors:** Punish all defectors by defecting yourself if you cooperated last round.
- **Yourself defected last round:** Forgive by cooperating next round to restore cooperation.
- **All defected previous round:** This leads to mutual defection, but conditional cooperation allows players who forgive to restart cooperation cycles.

---

## Pseudocode

```python
def decide_action(t, r, history, player_index):
    """
    Decide action for player i at round t.
    history: list of length t-1 where each element is a list of actions for all players in that round,
             e.g., history[round-1][player_index] = 'C' or 'D'
    player_index: index of current player i (0-based)
    Returns: 'C' or 'D'
    """

    # First round: cooperate unconditionally
    if t == 1:
        return 'C'

    # Last round: defect unconditionally
    if t == r:
        return 'D'

    # Previous round actions
    prev_round_actions = history[t-2]  # since history is 0-indexed

    # Check if all cooperated last round
    if all(action == 'C' for action in prev_round_actions):
        return 'C'  # continue cooperation

    else:
        # Identify defectors and cooperators last round
        defectors = [idx for idx, action in enumerate(prev_round_actions) if action == 'D']

        # If I defected last round -> cooperate this round (forgiveness)
        if prev_round_actions[player_index] == 'D':
            return 'C'

        # Else (I cooperated last round) -> defect to punish defectors
        else:
            return 'D'
```

---

## Discussion

- This strategy promotes **cooperation as long as others do too**.
- It **punishes defectors promptly but forgives defectors who try to reconcile**.
- It **avoids last-round cooperation to prevent being exploited**.
- It requires no communication or coordination aside from observing other players' actions.
- It is symmetric and applies to any number of players n and rounds r.
- The parameters from the game (k, n) affect payoffs but the strategic logic does not need adjustment because the incentive to cooperate or defect is clear from the payoff structure.

---

## Summary

| Round       | Condition                          | Action           | Rationale                          |
|-------------|----------------------------------|------------------|----------------------------------|
| t = 1       | No history                       | Cooperate (C)    | Establish cooperation baseline   |
| 1 < t < r   | All cooperated in t-1            | Cooperate (C)    | Maintain cooperation             |
| 1 < t < r   | Defections in t-1                | If you defected: Cooperate (forgive) <br> Else defect (punish) | Retaliate but forgive defectors |
| t = r       | Last round                      | Defect (D)       | Avoid endgame exploitation       |

---

This strategy balances **cooperation, conditional retaliation, and forgiveness**, helping sustain cooperative outcomes while protecting against exploitation through repeated reciprocal incentives.
'''

description_COOPERATIVE_56 = '''
Below is a fully cooperative, conditional strategy designed for the repeated N-player Public Goods Game as specified. It emphasizes cooperation while punishing defectors proportionally and forgiving defections to allow recovery to mutual cooperation.

---

## Cooperative Strategy Description

**Core principle:**  
Cooperate by default. Monitor others' play each round; if all cooperated last round, continue cooperating. If any defection detected, defect once to punish, then forgive by resuming cooperation if others do.

---

### 1. Decision Rules

- **Round 1 (first round):**
  - Cooperate (C) unconditionally, establishing goodwill and trying to build mutual cooperation.

- **Subsequent rounds (2 to r - 1):**  
  - If in the previous round *all* players cooperated (everyone played C), then cooperate.
  - Otherwise (if any player defected last round):
    - Defect this round to punish.
    - On the following round, return to cooperation regardless of previous defections (a single-round punishment and then forgiveness).
  
- **Last round (round r):**
  - Cooperate if no defections occurred in round r - 1 (to maximize payoff distributed in final round).
  - Defect if any defections occurred in round r - 1 (no incentive to cooperate in last round after defection).
  
---

### 2. Handling Edge Cases / Additional Notes

- **First round:**
  - You have no history, so start cooperatively.
  
- **Last round:**
  - The logic adjusts because there's no future to incentivize cooperation after punishing.
  - If the previous round was cooperative, cooperate to maximize payoff in last round.
  - If previous round had defection, defect since punishment cannot incentivize future cooperation.
  
- **Multiple defectors:**
  - The strategy punishes any defection by defecting once as a group.
  
- **No explicit memory beyond previous round:**
  - Strategy only depends on actions in previous round (simple, memory-1).
  
- **Forgiveness:**
  - Defect only once after observing defectors, then immediately forgive by cooperating again.
  - Avoids endless mutual defection.

---

### 3. Cooperative Mindset Alignment

- Encourages and sustains full cooperation whenever possible.
- Uses measured punishment to deter defection but immediately offers to return to cooperation.
- Respects the possibility that defection may be experimental or accidental.
- Suitable for n-player settings where isolation of single defectors is hard.

---

## Pseudocode

```python
# Input:
# history: list of rounds played so far, each round is list of length n with C or D for each player
# this_player_index: integer index 0 to n-1
# r: total rounds
# current_round: integer index 1 to r

def cooperative_strategy(history, this_player_index, r, current_round):
    n = len(history[0]) if history else None
    
    # Round 1: cooperate unconditionally
    if current_round == 1:
        return "C"
    
    # Get previous round actions
    prev_round = history[-1]
    all_cooperated = all(a == "C" for a in prev_round)
    last_round = (current_round == r)
    
    # Track if punished last round (did I defect last round after defection?)
    if len(history) >= 2:
        prev_prev_round = history[-2]
        prev_defection = any(a == "D" for a in prev_round)
        punished_last_round = (history[-1][this_player_index] == "D" and prev_defection)
    else:
        punished_last_round = False
    
    if last_round:
        # Last round logic
        if all_cooperated:
            # Cooperate to maximize payoff
            return "C"
        else:
            # Defect as no future punishment/reward possible
            return "D"
    
    # Not last round
    if all_cooperated:
        # Everyone was cooperative last round => cooperate
        return "C"
    else:
        # There was defection last round
        if punished_last_round:
            # Already punished last round, forgive now
            return "C"
        else:
            # Punish by defecting this round
            return "D"
```

---

## Summary

- **Start with cooperation.**  
- **Cooperate unless someone defected last round.**  
- **Defect once as punishment after any defection.**  
- **Forgive immediately by cooperating the next round.**  
- **In last round, cooperate only if previous round fully cooperative; otherwise defect.**

This strategy fosters strong cooperation, punishes defection to deter exploitation, but avoids endless retaliation by forgiving, thus maximizing total group payoff over repeated rounds.
'''

description_COOPERATIVE_57 = '''
Here is a carefully designed cooperative strategy for the repeated N-Player Public Goods Game you described.

---

## Strategy Name: **"Forgiving Conditional Cooperator"**

---

### Intuition and Goals
- **Aim to sustain mutual cooperation** because that yields the highest collective payoff (everyone contributes, payoffs are best).
- **Use conditional cooperation** to encourage others to cooperate but avoid being exploited.
- **Forgive occasional defections** since mistakes/errors or noisy play can occur (though noise isn't explicitly given, forgiveness improves robustness).
- **Defect in the last round** since no future punishment can be applied (standard endgame reasoning).
- **Use observed behavior of others** to guide own action with perfect information about past rounds.

---

### Decision Rules

---

#### Round 1 (First round):

- **Cooperate (C).**

Justification: Starting with cooperation signals friendliness and attempts to establish cooperation.

---

#### Intermediate rounds (2 to r-1):

- **Condition:**

  Compute:

  - \( C_{prev} \) = number of cooperators in immediate previous round
  - \( D_{prev} = n - C_{prev} \) = number of defectors in previous round
  
  Also capture whether **all other players cooperated** last round:

- **If** every other player cooperated last round (i.e., you and all others cooperated):  
  → **Cooperate.**

- **Else if** the number of defectors last round is small (e.g., 1 or 2) and you cooperated last round, interpret as possible mistake or experimental defection, **forgive and cooperate** again this round.

- **Else** defect to punish widespread defection.

(**Meaningful forgiving threshold parameter: tolerate up to 2 defectors, otherwise punish**)

(In pseudocode below, this is quantified.)

---

#### Last round (round r):

- **Defect (D).**

Justification: Backward induction says cooperation cannot be enforced by future punishment since game ends.

---

### Summary of player \(i\)’s action \(a_i^t\) at round \(t\):

| Round | Condition                                                                            | Action     |
|-------|-------------------------------------------------------------------------------------|------------|
| 1     | First round                                                                         | Cooperate  |
| 2..r-1| See above: if previous round nearly full cooperation, continue cooperating          | Cooperate  |
| 2..r-1| If some defectors but very few (≤ 2), forgive and continue cooperating             | Cooperate  |
| 2..r-1| Otherwise defect to punish defections                                              | Defect     |
| r     | Last round                                                                         | Defect     |

---

### Formal Pseudocode

```python
def strategy(history, round_t, n, r):
    # history: list of actions per round of all players
    # history[t][i] = action of player i at round t (0-indexed)
    # round_t: current round number (1-indexed)
    # n: total players
    # r: total rounds

    # Parameters
    max_defectors_tolerated = 2

    if round_t == 1:
        return 'C'  # Cooperate first round

    if round_t == r:
        return 'D'  # Defect last round

    # Analyze previous round (round_t - 1)
    prev_round = history[round_t - 2]  # zero-based index

    num_cooperators = prev_round.count('C')
    num_defectors = n - num_cooperators

    # Check if ALL others cooperated last round
    # For player i, own action in prev round is history[round_t - 2][i], but unavailable here
    # Since no player identity in parameters, assume strategy only needs condition on global cooperation level

    # Strategy is symmetric — check if previous round had full cooperation
    if num_defectors == 0:
        # Everyone cooperated last round
        return 'C'

    # Otherwise allow forgiveness if defectors are within tolerance
    if num_defectors <= max_defectors_tolerated:
        return 'C'  # Forgive and cooperate

    # Too many defectors last round - defect to punish
    return 'D'
```

---

### Detailed Explanation

- **First Round:** Cooperate to initiate trust and start cooperation.
- **Subsequent rounds (except last):**  
  Cooperates if last round had full or near-full cooperation (defectors ≤ 2), allowing mistakes or experimentation. This fosters cooperation and forgiveness but cautiously punishes defectors.  
  Defects if many players defected to discourage continued free-riding.
- **Last round:** Defects per backward induction since no incentive to cooperate.

---

### Why This Strategy is Cooperative

- It always attempts to cooperate when cooperation is mutual or nearly mutual.
- It punishes only when there is significant defection, promoting social norms of contribution.
- Forgiveness makes it robust and able to recover from occasional defection mistakes.
- It does not exploit cooperation unilaterally.
- Avoids being exploited in repeated interaction by conditional defection.
- Maximizes collective payoff over game rounds.

---

### Edge Case Handling

- **First round:** No past data → cooperate.
- **Last round:** No future to enforce cooperation → defect.
- **Small number of defectors:** Interpreted as mistakes → forgive.
- **Large defection:** Punish to maintain cooperation incentive.
- **If all defect always:** Will defect too to avoid losses.
- Since all players can observe everything, if others use similar logic, cooperation will be sustained.

---

This strategy adheres to all your specifications, leverages the structure and payoffs of the game, maintains a fully cooperative mindset, and appropriately uses common knowledge and perfect information. It balances cooperation/fairness and rational self-interest.

---

If you want, I can help you adapt or tune the parameters such as forgiveness threshold or make it more or less forgiving.
'''

description_COOPERATIVE_58 = '''
**Cooperative Strategy: Conditional Cooperation with Forgiveness**

---

### Strategy Overview

This strategy seeks to foster mutual cooperation by starting cooperatively, maintaining cooperation as long as others mostly cooperate, punishing defections to discourage free-riding, but also forgiving occasional defections to recover cooperation and maximize collective payoffs over repeated rounds.

---

### Intuition Behind the Strategy

- **Start Cooperative:** Begin by cooperating to signal willingness to cooperate and achieve high joint payoffs.
- **Monitor Cooperation Rate:** Keep track of how many players cooperate each round.
- **Punish Defection:** If cooperation falls below a threshold (indicating exploitation or widespread defection), punish by defecting for a round to signal disapproval.
- **Forgive Occasional Defection:** Because the strategy assumes imperfect rationality or occasional mistakes by others, it returns to cooperation if others start cooperating again.
- **Last Round Defection (Backward Induction):** In the final round, defect because there is no future benefit from cooperation and no risk of punishment.
  
---

### Notation

- \( t \) = current round (1 to \( r \))
- \( n \) = number of players
- \( r \) = total rounds
- History up to previous round: actions and payoffs of all players
- \( C_t \) = number of cooperators in round \( t \)
- Threshold \( \theta \) = minimum tolerated cooperation level to consider society cooperative (e.g. 70% of players cooperating)
- Own previous action: \( a_{i,t-1} \)

---

### Decision Rules

1. **Round 1: cooperation**
   - Cooperate on the first round; establish cooperative norm.

2. **Rounds 2 to \( r-1 \): conditional cooperation**
   - Calculate cooperation ratio in previous round \( \rho_{t-1} = \frac{C_{t-1}}{n} \).
   - If \( \rho_{t-1} \geq \theta \), cooperate.
   - Else, defect (punish).
   - If punished in previous round (you defected due to low cooperation), forgive if cooperation has improved (i.e. \( \rho_{t-1} \geq \theta \)) and return to cooperating.

3. **Round \( r \): always defect**
   - Defect in the last round to maximize payoff (Backwards induction result).

---

### Parameter Setting Suggestion

- \( \theta = 0.7 \) (70% cooperation threshold)
  
This is tunable; higher values mean less tolerance for defection.

---

### Pseudocode

```python
# Inputs:
# t - current round (1-based)
# r - total rounds
# n - total players
# history_actions - list of lists of past actions, each inner list length n
#    e.g. history_actions[t-1] = list of actions at round t-1 by all players
# self_index - your player index (0 to n-1)

def cooperative_strategy(t, r, n, history_actions, self_index):
    # Last round defect
    if t == r:
        return 'D'

    # Round 1: cooperate
    if t == 1:
        return 'C'
    
    # Calculate cooperation rate in previous round
    prev_round_actions = history_actions[t-2]  # zero-based index for t-1 
    num_cooperators = prev_round_actions.count('C')
    cooperation_ratio = num_cooperators / n

    # Threshold for tolerance:
    theta = 0.7

    # Determine if we defected last round due to punishment
    own_last_action = prev_round_actions[self_index]

    # If previous round was cooperative enough, cooperate
    if cooperation_ratio >= theta:
        return 'C'

    # Cooperation below threshold: punish defect by defecting this round
    # But forgive if previously punished and cooperation improves
    
    if own_last_action == 'D':  # previously punished
        # Check if cooperation rate recovering
        if cooperation_ratio >= theta:
            return 'C'   # forgive and return to cooperation
        else:
            return 'D'   # continue defecting to punish
    else:
        # First time defecting as punishment
        return 'D'
```

---

### Explanation

- **Start by cooperating** to encourage mutual cooperation.
- **After each round**, observe the group's cooperation level.
- If the group remains mostly cooperative (≥70%), continue cooperating.
- If cooperation drops below 70%, respond by defecting next round to punish and disincentivize free-riding.
- If punished yourself (you defected), observe if cooperation rebounded, if yes, return to cooperating (forgiveness).
- **In the last round**, defect as cooperation incentives vanish.

---

### Why This Strategy is Cooperative

- Maximizes collective payoffs by fostering cooperation in early and intermediate rounds.
- Uses punishment sparingly to deter defectors but also forgives to avoid endless defection cycles.
- Recognizes single-shot endgame logic and defects there to maximize final payoff.
- Dependence only on observed actions aligns with game constraints (no communication).
- Uses clear, principled rules easy to implement and justify behavior to other agents.

---

### Limitations and Risks

- May be exploited by all-defect players until punishment phase kicks in.
- Choice of threshold \( \theta \) affects sensitivity; can tune based on observed opponent cooperation tendencies.
- If many players frequently defect, may lead to persistent punishment cycles.

---

This strategy aims to balance cooperation incentive, punishment deterrence, and forgiveness to achieve high group payoffs in repeated public goods games with the given information structure.
'''

description_COOPERATIVE_59 = '''
Below is a fully specified **cooperative strategy** for the repeated N-player Public Goods Game, designed to encourage mutual cooperation (C) while being robust to defection (D), including details on initial behavior, retaliation, forgiveness, and endgame considerations.

---

## Cooperative Strategy: "Conditional Reciprocity with Forgiveness"

### Intuition
- Start cooperating to signal willingness to cooperate.
- Continue cooperating as long as all (or almost all) players cooperated previously.
- If defections occur, punish defectors by defecting once.
- Forgive after punishment to restore cooperation.
- In the last round, defect to avoid exploitation (standard backward induction reasoning).

---

### Decision Rules

Let:

- **t** ∈ {1,...,r} be the current round.
- **history** = list of all previous rounds' action profiles.
- **c_j,t** indicates player j's contribution in round t (1 if C, 0 if D).
- **threshold** for cooperation tolerance (can be adjusted to tolerate occasional noise/one-off defection).

---

### Pseudocode

```python
def decide_action(t, history, n, r):
    """
    Decide whether to Cooperate (C) or Defect (D) at round t

    :param t: Current round (integer)
    :param history: List of previous action profiles; each profile is a list of length n of 'C' or 'D'
    :param n: Number of players
    :param r: Total rounds
    :return: 'C' or 'D'
    """

    # Parameters of the strategy
    THRESHOLD = n  # Require all players to cooperate last round to continue cooperating
    # (Alternatively, allow THRESHOLD = n-1 to tolerate one defector)
    
    # Edge case: Last round
    if t == r:
        # Defect in last round to avoid sucker's payoff (standard backward induction)
        return 'D'

    # First round: cooperate to signal willingness
    if t == 1:
        return 'C'

    # For subsequent rounds t > 1:
    previous_round = history[t-2]  # zero-based indexing; history[0] is round 1

    # Count number of cooperators in previous round
    cooperators_prev = sum(1 for a in previous_round if a == 'C')

    # Condition for cooperation:
    # Cooperate if all players cooperated last round
    if cooperators_prev == THRESHOLD:
        return 'C'

    # If we defected last round, we want to cooperate now to forgive and re-establish cooperation
    if own_action_in_round(t-1, history) == 'D':
        # Forgive by cooperating
        return 'C'

    # Else, we punish defection by defecting this round
    # This is a single-round punishment to discourage defections
    return 'D'

def own_action_in_round(t, history):
    """
    Given the history, return the own action of the player in round t
    (Assuming this function is evaluated from player's perspective, 
    so history includes own stored actions.)
    
    Here you assume history includes your past actions.
    """
    return history[t-1][own_index]  # own_index is your player ID - 1
```

---

### Explanation of Decision Rules

1. **Round 1:** Always cooperate.
    - Signals willingness to cooperate.

2. **Rounds 2 to r-1:**
    - If *all* players cooperated in previous round, keep cooperating.
    - If anyone defected last round, defect this round to punish those defectors.
    - On the round *after defecting* yourself (even if you defected to punish), forgive by cooperating again to enable return to cooperation.

3. **Round r (last round):** Defect.
    - Avoids being exploited on the last round.
    - Backward induction suggests cooperation won't be sustained in last round.
    - Since no future rounds remain, defecting maximizes immediate payoff.

---

### Handling Edge Cases and Variants

- **Tolerance to occasional defection:** Set `THRESHOLD = n-1` rather than `n` if you want to tolerate exactly one defector and still cooperate, e.g., for noisy environments.
- **Persistent defectors:** Since punishment is only one round long and followed by forgiveness, persistent defectors will be punished several times, reducing their gains.
- **Exploiting defectors:** Because defectors gain more when others cooperate, the threat of punishment deters exploitation.
- **No communication or signal:** Strategy uses only publicly observed actions.
- **Perfect information:** The strategy assumes full knowledge of all players' previous actions.
- **Self-consistency:** You punish defectors but return to cooperation quickly, maximizing group payoffs.

---

### Why This Strategy?

- It is a **trigger-like strategy** that only punishes defections immediately and forgives quickly, balancing deterrence with cooperation.
- It fully cooperates initially to maximize social welfare.
- It is **robust in an environment with unknown opponents**, who may cooperate or defect.
- It exploits the fact that full cooperation yields the highest payoff for all.
- The last-round defection aligns with classical game-theoretic solution concepts (backward induction).

---

## Summary

| Round            | Condition                             | Action  |
|------------------|-------------------------------------|---------|
| 1 (First round)  | Always cooperate                    | C       |
| 2 to r-1         | All cooperated last round           | C       |
|                  | Someone defected last round + you cooperated last round | D (punish) |
|                  | You defected last round             | C (forgive) |
| r (Last round)   | Always defect                      | D       |

---

This strategy aims to **foster cooperation, punish defectors briefly, and forgive quickly**, thereby maximizing long-run payoffs while minimizing exploitation risk in the repeated N-player public goods game.
'''

description_COOPERATIVE_60 = '''
Here is a cooperative, robust strategy for the described N-player repeated public goods game. It is inspired by the principle of *conditional cooperation with forgiveness*, aiming to sustain high cooperation despite occasional defections or noise.

---

### Strategy Name: *Forgiving Conditional Cooperator (FCC)*

---

### Intuition

- Start fully cooperative.
- Continue cooperating if everyone cooperated last round (full cooperation observed).
- If anyone defected last round, punish by defecting once.
- After punishment, return to cooperation, forgiving potential errors or experimentation.
- In the last round, cooperate anyway (there is no future to punish defections, so sustain cooperation to maximize payoff).

---

### Detailed Decision Rules

Let:

- Round index: t = 1, 2, ..., r
- History known at round t: actions of all players at rounds 1 to t-1
- Actions of all players at round t-1: \( A_{t-1} = (a_1^{t-1}, a_2^{t-1}, ..., a_n^{t-1}) \), where \(a_i^{t-1} \in \{C, D\}\)

Define helper variables:

- \( \text{EveryoneCooperated}_{t-1} = (a_1^{t-1} = C) \wedge (a_2^{t-1} = C) \wedge \cdots \wedge (a_n^{t-1} = C) \)
- \( \text{PunishmentRound} \): Boolean, true if last round was a punishment round (we punished because of defections), false otherwise.

---

### Initial Condition

- At round 1, no history exists, so default is to **Cooperate** (play C).

---

### Main Decision Logic for rounds \( t = 2, ..., r-1 \):

1. If the previous round \( t-1 \) was fully cooperative (EveryoneCooperated\(_{t-1}\) = True):

   - Cooperate (C) this round.
   - Reset PunishmentRound = False.

2. Else (some defection detected last round):

   - If not currently punishing (PunishmentRound = False):
     - Punish by defecting (D) this round.
     - Set PunishmentRound = True.
   - Else if currently punishing (PunishmentRound = True):
     - Forgive, cooperate (C) this round.
     - Reset PunishmentRound = False.

---

### Final Round \( t = r \):

- Always cooperate (C) regardless of history.
- This avoids the “last round defection” problem and sustains social welfare.

---

### Summary

| Condition                            | Action | Update PunishmentRound |
|------------------------------------|--------|-----------------------|
| \(t=1\)                           | C      | False                 |
| \(1 < t < r\) and all cooperated last round | C      | False                 |
| \(1 < t < r\) and defection last round, not punishing | D      | True                  |
| \(1 < t < r\) and defection last round, punishing | C      | False                 |
| \(t = r\)                         | C      | False                 |

---

### Pseudocode

```python
def FCC_strategy(t, r, history, punishment_round):
    # history: list of tuples of all players' actions in rounds 1..t-1
    # punishment_round: boolean flag, whether last round was punishment
    
    if t == 1:
        # First round: cooperate
        return 'C', False

    if t == r:
        # Last round: cooperate unconditionally
        return 'C', False

    last_round_actions = history[-1]

    if all(a == 'C' for a in last_round_actions):
        # Everyone cooperated last round
        return 'C', False

    # Defection detected last round
    if not punishment_round:
        # Punish once by defecting
        return 'D', True
    else:
        # Forgive and cooperate
        return 'C', False
```

---

### Why This Strategy Is Cooperative and Robust

- **Cooperation-friendly**: Starts with cooperation and returns to it quickly.
- **Punishment**: Deterrent to free-riding or persistent defection.
- **Forgiveness**: Allows cooperation to resume after a single punishment round, accounting for mistakes or exploration.
- **Last round cooperation**: Avoids unraveling of cooperation due to backward induction.

---

### Handling Edge Cases

- **First round (no history)**: Cooperate to establish trust baseline.
- **Last round (no future punishment)**: Cooperate to maximize payoffs.
- **Multiple defections or persistent defectors**: Punishment will repeat if defections persist, incentivizing cooperation.
- **No communication and simultaneous moves**: Use observable history to condition decisions solely on previous actions.

---

This *Forgiving Conditional Cooperator* strategy should perform well in a tournament, as it fosters cooperation if others reciprocate, punishes defectors briefly, and always prioritizes collective payoff by cooperating in the final round.
'''

description_COOPERATIVE_61 = '''
Here is a cooperative strategy designed for the N-Player Public Goods Game that:

- Encourages cooperation,
- Punishes defection to deter free-riding,
- Recovers from occasional mistakes,
- Takes into account first and last round dynamics.

---

## Strategy Name: *Forgiving Conditional Cooperation with Final Round Defection*

### Intuition
- Start by cooperating to establish trust.
- Continue cooperating as long as all players cooperated in the previous round.
- If any player defects, respond by defecting for only one round (punishment).
- After punishment, return to cooperation in hope of re-building trust.
- In the final round, defect because cooperation cannot be enforced afterward, and the one-shot incentive to defect is strong.

---

## Formal Description

Given:
- n players
- r rounds
- Current round t ∈ {1, 2, ..., r}
- History of all players’ actions in previous rounds: H = {a_i,s | i = 1..n, s = 1..t-1}, where a_i,s ∈ {C, D}

Define:

- **AllCooperated(t-1)** = True if all players cooperated in round t-1, False otherwise.
- **DefectedLastRound(t-1)** = True if any player defected in round t-1, False otherwise.

---

### Decision Rule for player i in round t:

```
if t == 1:
    # First round: cooperate to establish baseline cooperation.
    play C

elif t == r:
    # Last round: defect to maximize one-shot payoff.
    play D

else:
    if AllCooperated(t-1) == True:
        # Everyone cooperated last round, keep cooperating.
        play C

    else:
        # Someone defected last round
        if DefectedLastRound(t-2) == True:
            # Already punished last round, return to cooperation.
            play C
        else:
            # Punish by defecting this round.
            play D
```

---

### Explanation

- **Round 1:** Cooperate unconditionally to signal willingness.
- **Intermediate rounds:**
  - **If everyone cooperated last round:** cooperate, reinforcing mutual cooperation.
  - **If any defection last round:** punish once by defecting this round.
  - **If already punished (defected) in previous round due to defection before:** return to cooperation, allowing forgiveness and avoiding endless retaliation.
- **Last round:** defect because cooperation is not sustainable without future rounds to enforce it.

---

## Rationale

- Cooperation maximizes social welfare because when all cooperate, payoffs are highest.
- Defecting if others defect disincentivizes free-riding.
- Forgiving after one round of punishment avoids breaking cooperation cycles due to noise or mistakes.
- Defecting in last round is a standard equilibrium insight in finitely repeated Prisoner’s Dilemma-like games.

---

## Pseudocode

```python
def player_strategy(t, r, history):
    # history: list of rounds; each round is a list of actions of all players ['C' or 'D']
    # t: current round (1-indexed)
    # r: total number of rounds

    if t == 1:
        return 'C'  # First round cooperate

    if t == r:
        return 'D'  # Last round defect

    last_round = history[t-2]  # zero-based index in code, round t-1 in problem statement
    all_cooperated_last = all(action == 'C' for action in last_round)

    if all_cooperated_last:
        return 'C'  # keep cooperating

    else:
        # Check if we already punished in previous round (t-1)
        if t == 2:
            punished_last = False  # no punishment round before round 2
        else:
            prev_round = history[t-3]
            punished_last = any(action == 'D' for action in prev_round) == False and \
                            any(action == 'D' for action in last_round) == True

        if punished_last:
            return 'C'  # forgive and cooperate
        else:
            return 'D'  # punish defectors by defecting
```

---

### Additional Notes

- Since all players can observe all past actions, this strategy is implementable.
- This strategy doesn't rely on knowledge of which player defected, just whether any defection occurred.
- It assumes all players follow similar logic, promoting mutual cooperation.
- The single-round punishment avoids long cycles of retaliation.
- Because k < n and 1 < k, cooperative profiles give higher payoffs than universal defection.
- Defection in last round exploits the lack of future punishment in a finitely repeated setting, making it individually rational.

---

# Summary

| Round            | Condition                        | Action  | Reason                      |
|------------------|---------------------------------|---------|-----------------------------|
| 1                | Start of game                   | C       | Initiate cooperation        |
| t ∈ {2,...,r-1}  | If all cooperated last round   | C       | Maintain cooperation        |
| t ∈ {2,...,r-1}  | Else if just punished last round| C      | Forgive and return to cooperation |
| t ∈ {2,...,r-1}  | Else (first defection detected) | D       | Punish defection            |
| r (last round)    | Always                          | D       | Maximize own payoff         |

---

This strategy strikes a balance between cooperation and self-interest, maximizing expected payoffs in multi-player repeated public goods settings while punishing defectors and allowing recovery from mistakes.
'''

description_COOPERATIVE_62 = '''
**Cooperative Strategy for the N-Player Public Goods Game**

---

### Overview

This strategy seeks to maximize group payoffs by sustaining cooperation among all players throughout the repeated game. It assumes all players start cooperating and uses a credible, forgiving punishment mechanism to deter defections. The strategy aligns with the cooperative mindset by:

- Cooperating initially and by default
- Retaliating against defection in a controlled way that incentivizes return to cooperation
- Being forgiving to allow recovery from errors
- Considering the last round specially due to endgame incentives

---

### Intuition Behind the Strategy

- Cooperation (C) yields higher collective payoffs.
- Defection (D) gives higher individual payoff in a single round if others cooperate.
- To sustain cooperation, defecting players must face consequences in future rounds.
- Because players cannot communicate or coordinate explicitly, punishment is triggered only by observed defections.
- Forgiveness prevents endless cycles of punishment.
- The last round presents a temptation to defect since there is no future retaliation, so cooperation in the last round depends on history and anticipation of others’ incentives.

---

### Definitions and Notation

- Let `H_t` be the history of all players' actions up to round `t-1`.
- Let `defectors_t-1` be the set of players who defected in round `t-1`.
- Let `my_action_t` be the strategy's action at round `t`.
- Let `r` be total number of rounds.
- Let `punish` be a binary flag indicating whether the strategy is currently in punitive mode.

---

### Strategy Decision Rules

**Initialization:**

- Set `punish = False`
- Cooperate in round 1.

**Each round t (1 ≤ t ≤ r):**

1. **Round 1 (t=1):**  
   - Always **Cooperate** (C).
   - Rationale: No history to infer defection; start with cooperation.

2. **Rounds 2 to r-1 (1 < t < r):**  
   - If `punish = False`:  
     - **Cooperate** if *all* players cooperated in previous round (`t-1`), i.e. no defectors observed.  
     - Otherwise (if any player defected in round `t-1`), set `punish = True` and **Defect** in current round.  
       This is a punishment phase triggered by defection(s).

   - If `punish = True`:  
     - If *all* players cooperated in round `t-1` (punishment round just ended with full cooperation),  
       then **Cooperate** and set `punish = False` (forgiveness and reset).  
     - Else (if at least one defection detected again), continue **Defecting** to sustain punishment.

3. **Last Round (t = r):**  
   - If `punish = False` and no defectors in previous round:  
     - **Cooperate** (attempt last-round cooperation).  
   - Else (past defection detected or currently punishing):  
     - **Defect** (last round temptation, defections cannot be punished).

---

### Pseudocode

```python
initialize:
    punish = False

for t in 1 to r:
    if t == 1:
        action = C

    elif 1 < t < r:
        if not punish:
            if all players cooperated in round t-1:
                action = C
            else:
                punish = True
                action = D
        else:  # punish == True
            if all players cooperated in round t-1:
                punish = False
                action = C
            else:
                action = D

    else:  # t == r (last round)
        if not punish and all players cooperated in round r-1:
            action = C
        else:
            action = D

    play action
```

---

### Key Features & Justifications

- **Starts cooperating:** Trust that everyone is cooperative initially.
- **Punishes defectors by defecting next round:** Incentivizes defectors to return to cooperation.
- **Punishment persists until full cooperation resumes:** Avoids premature forgiveness, increasing enforcement credibility.
- **Forgives after one full cooperative round:** Allows mistakes or one-off defections to be overcome.
- **Defects if expecting no punishment possible (last round and past defection):** Follows backward induction; cooperation likely fragile in last round if trust broken.
- **No explicit memory beyond previous round’s actions and punish state:** Simple and robust.

---

### Handling Edge Cases

- **First round:** No history, so cooperate unconditionally.
- **If the whole group consistently defects:** The strategy will remain defecting, matching others to avoid exploitation.
- **If errors occur (e.g., accidental defection):** Strategy punishes once but forgives after seeing all cooperate again, preventing endless defection spirals.
- **If the group fully cooperates:** The strategy sustains cooperation indefinitely until last round.
- **In the last round:** Defects if distrust exists, else cooperates to try achieving maximal group payoff.

---

### Summary

This "Conditional Cooperation with Forgiving Punishment" supports cooperation by balancing incentives:

- Cooperative by default
- Defects only as punishment, not preemptively
- Forgives to maintain long-term cooperation
- Recognizes last round incentives to defect when cooperation already broken

This strategy should perform competitively in a tournament setting emphasizing sustained cooperation among rational, self-interested players.
'''

description_COOPERATIVE_63 = '''
**Cooperative Strategy for N-Player Public Goods Game**

---

### Strategy Overview

This strategy is a **conditional cooperator with forgiveness and endgame awareness**, inspired by principles similar to Tit-for-Tat and Generous Tit-for-Tat adapted to the multi-player public goods setting.

**Goal:**  
Maximize the collective benefit by sustaining cooperation as long as others cooperate, while punishing defection by retaliating, but forgiving occasional defections to prevent endless mutual defections.

---

### Decision Rules Summary

1. **Round 1 (First round):**  
Always **Cooperate (C)** to signal willingness to cooperate.

2. **From round 2 to round r-1 (Intermediate rounds):**  
- **If all players cooperated in the previous round:** Cooperate.  
- **If some defected in the previous round:** Defect with probability *p*, else Cooperate.  
  - *p* reflects a calibrated retaliation probability (e.g., 0.8) — high enough to punish defection but allows forgiveness.

3. **Round r (Last round):**  
Defect because no future punishment or reward is possible (standard backward induction).

---

### Rationale

- **Cooperate first:** Establish trust and encourage reciprocal cooperation.
- **Conditional cooperation:** If everyone cooperated last round, continue cooperating to maintain the cooperative equilibrium.
- **Punishment:** If defection occurred, punish to discourage repeated defection.
- **Forgiveness probabilistic:** Allows recovery from noise/errors or one-off defections, promoting long-term cooperation.
- **Defect last round:** Backward induction implies defection is dominant in final round since no future rounds remain to enforce cooperation.

---

### Handling Edge Cases

- **If multiple defectors last round:** Treat as defecting round — punish. No distinction needed as strategy punishes any defection.
- **If all players defected last round:** Punish by defecting; however forgiveness chance may still lead to cooperation.
- **If you observe no one cooperating last round (everyone defected):** Defect (likely mutual defection equilibrium).
- **If unexpected behavior (e.g. random mix):** Respond to last round's defection rate probabilistically.
- **Zero-round game or single round (r=1):** Always defect (no cooperation future).

---

### Pseudocode

```pseudo
INPUTS:
  - n: number of players
  - r: number of rounds
  - k: multiplication factor
  - round_number: current round (1 ≤ round_number ≤ r)
  - history: list of tuples for previous rounds, where each tuple contains the actions of all players in that round
      e.g., history[t] = [a_1^t, a_2^t, ..., a_n^t], a_i^t ∈ {C, D}

PARAMETERS:
  - p := 0.8  # Probability of defecting after observing any defection last round (punishment intensity)
  
FUNCTION decide_action(round_number, history):
  if round_number == 1:
      return C  # Cooperate first round to initiate cooperation

  if round_number == r:
      return D  # Defect in last round (no future incentive to cooperate)

  # Intermediate rounds (2 ≤ round_number ≤ r-1)
  last_round_actions = history[round_number - 2]  # zero-indexed

  if all actions in last_round_actions == C:
      return C  # Everyone cooperated last round, continue cooperating

  else:
      # Some defected last round, punish with probability p, else forgive and cooperate
      draw random number x ∈ [0,1)
      if x < p:
          return D
      else:
          return C
```

---

### Additional Notes

- This probabilistic forgiveness prevents permanent breakdown after a single defection.
- Parameters can be tuned (e.g., adjust *p*) to balance exploitation risk and cooperation maintenance.
- Strategy is **memory-1**: only actions from the previous round govern current decision.
- Perfect information on all players' past actions simplifies detection of defection.
- If desired, can enhance to weigh defectors vs cooperators proportionally.

---

### Intuition in Example (n=6, k=2, r=10):

- Round 1: Cooperate → everyone sees you cooperating.
- Suppose 1 or 2 defect in round 1:
  - Round 2: Punish them by defecting with 80% chance.
  - With 20% chance, forgive and cooperate to signal willingness to restore cooperation.
- If players return to cooperation, you cooperate again.
- Last round (10): Defect, securing the private payoff since no future rounds remain.

---

**This strategy aligns with the cooperative mindset by prioritizing mutual cooperation and allowing recovery from defections, while ensuring rational behavior under the incentives of repeated public goods games.**
'''

description_COOPERATIVE_64 = '''
Below is a cooperative strategy designed for the described N-player repeated public goods game. It aims to encourage mutual cooperation, punish defection, and restore cooperation if punished alternatively occurs. It is consistent with perfect monitoring and no communication constraints, and it explicitly handles the first and last rounds as special cases.

---

## Strategy Overview: Conditional Cooperation with Forgiveness (CCF)

**Core Idea:**  
Start cooperatively; continue cooperating as long as all players cooperated in the previous round; if any defection is observed, defect for one round (punishment) and then attempt to return to cooperation. In the last round, defect to avoid being exploited, since no future punishment is possible.

---

## Decision Rules

- **Round 1:** Cooperate. (Establish cooperative norm without prior info.)
- **Rounds 2 to r-1:**  
  - If in the previous round *everyone cooperated*, cooperate again.  
  - If in the previous round *anyone defected*, defect this round (punishment round).  
- **Rounds immediately after a punishment round:** Cooperate again, attempting to restore cooperation.  
- **Round r (last round):** Defect, since no future rounds follow and cooperating invites exploitation.

---

## Explanation / Rationale

- By cooperating initially, the strategy signals willingness to cooperate.
- Observing universal cooperation in the previous round justifies trusting others and cooperating again.
- Observing any defection triggers a single-round punishment (defect) to discourage free-riding.
- After punishing, the strategy immediately attempts reconciliation, allowing cooperation to resume, avoiding indefinite mutual defection.
- Defection in the last round prevents exploitation, consistent with backward induction reasoning in finitely repeated games.

---

## Pseudocode

```python
# Input variables:
# round_number: current round index (1 to r)
# history: list of (n-length) tuples/lists recording all players' actions in previous rounds
# Each element of history is: [a_1, a_2, ..., a_n], where a_i ∈ {C, D}

def strategy(round_number, history):
    n = len(history[0]) if history else n_players  # number of players
    r = total_rounds  # total number of rounds

    # First round: cooperate
    if round_number == 1:
        return 'C'

    # Last round: defect
    if round_number == r:
        return 'D'

    # Check previous round actions
    prev_actions = history[-1]  # actions of all players in prev round

    all_cooperated_prev = all(action == 'C' for action in prev_actions)

    # Punishment detection: if defection occurred previously
    if not all_cooperated_prev:
        # Punishment round; defect
        return 'D'
    else:
        # Previous round was fully cooperative -> cooperate
        return 'C'
```

---

## Notes on Edge Cases

- **Multiple defections:** Any single defection triggers punishment.
- **Punishment round after defection:** You defect to punish.
- **After punishment round:** Since history shows previous round as defection round (the punishment round), the next round will see all players cooperating or defecting depending on their strategies; in this strategy, since the previous round had defection, you defect; the strategy thus punishes only once per detected defection and immediately attempts reconciliation next round.
- **If others never cooperate or always defect:** This strategy converges to defecting every round after the first defection round, effectively minimizing your loss.
- **If others are cooperative:** The strategy sustains full cooperation, maximizing payoffs (payoff = k).

---

## Summary

| Round           | Condition                                   | Action  | Reason                                     |
|-----------------|---------------------------------------------|---------|--------------------------------------------|
| 1               | First round                                  | C       | Signal cooperation                         |
| 2 to r-1        | Everyone cooperated in previous round       | C       | Continue cooperation                       |
| 2 to r-1        | At least one defection in previous round    | D       | Punish defectors                           |
| After punishment | Next round after defecting as punishment    | C       | Attempt reconciliation                     |
| r (last round)  | Final round                                  | D       | Avoid exploitation due to end-game effect |

---

This strategy balances the incentive to cooperate with credible punishment that is not excessively harsh (one-round punishment) and is forgiving, enabling return to cooperation. It is well-known in repeated games literature and adapted here for the public goods setting with simultaneous moves and perfect monitoring.
'''

description_COOPERATIVE_65 = '''
Here is a detailed cooperative strategy for the specified repeated N-player Public Goods Game, designed to promote mutual cooperation while guarding against exploitation. The strategy leverages all publicly observed past actions and is fully inline with the information and constraints given.

---

## Strategy Name: Generous Conditional Cooperation (GCC)

### Intuition:
- Aim to cooperate initially and encourage cooperation if others reciprocate.
- Forgive occasional defections to promote stable cooperation despite noise or errors.
- Retaliate by defecting if defections persist, punishing free riders.
- Resume cooperation if others return to cooperation.
- In the last round, defect since no future incentive exists (standard backward induction).

---

## 1. Decision Rules (Per Round t):

Let:

- `history` be the full record of all players' actions in rounds 1 to (t-1).
- `cooperation_rate_t_minus_1` = fraction of players who cooperated in round (t-1).
- `my_previous_action` = this player's action in round (t-1), if t > 1.
- Define a cooperation threshold parameter: `THRESHOLD = 0.8` (tunable, e.g. 80% cooperation means "good cooperation environment")
- Define forgiveness parameter: allow at most `M = 1` consecutive round of low cooperation before punishing.

---

### Round 1 (t = 1):
- Cooperate unconditionally.
  
**Rationale:** Set a cooperative tone and establish goodwill without prior information.

---

### Rounds 2 to (r-1):

- If in the previous round, at least `THRESHOLD` fraction of players cooperated (including self if applicable), **Cooperate**.

- Else (less than THRESHOLD cooperation in previous round):
  - If player defected in previous round or this is the first defection below threshold, **Defect** this round as a form of punishment.
  - If already defected last round as punishment (i.e. consecutive low cooperation rounds), **Cooperate** this round to forgive and test if cooperation resumes.

**Explanation:**

- Cooperate when others mostly cooperate.
- Defect to punish sustained defection (but not too long to avoid endless retaliation).
- Forgive to restart cooperation cycles.

---

### Round r (Last round):

- Defect unconditionally.

**Rationale:** No future rounds; no incentive to cooperate since no future reward or punishment.

---

## 2. Handling Edge Cases:

- **First round:** No history, so cooperate to initiate cooperation.

- **Last round (round r):** Defect since no future incentive.

- **If cooperation suddenly drops sharply:** Only punish for maximum one round, then return to cooperation to avoid permanent deadlocks.

- **If all players defect (0% cooperation):** Punish with defection but attempt to resume cooperation after one round.

- **If player is the only defector (others cooperate):** Defect only responds to group cooperation level, not individual; this is forgiving enough to tolerate occasional defection.

- **No communication or signalling:** All decisions based on publicly observed actions only.

---

## 3. Pseudocode

```python
def GCC_strategy(t, r, n, history, my_index):
    # Parameters
    THRESHOLD = 0.8
    MAX_PUNISH_ROUNDS = 1  # number of consecutive rounds to punish

    if t == 1:
        # First round: cooperate
        return 'C'

    if t == r:
        # Last round: defect
        return 'D'

    # Extract cooperation counts for previous rounds
    prev_round = t - 1
    prev_actions = history[prev_round - 1]  # zero-indexed

    # Count cooperators in previous round
    cooperation_count = sum(1 for a in prev_actions if a == 'C')
    cooperation_rate = cooperation_count / n

    # Detect whether we defected last round (for punishment tracking)
    my_prev_action = prev_actions[my_index - 1]

    # Track whether last round was punishment round: 
    # persistently low cooperation rounds count
    # Need to check previous history for consecutive low cooperation rounds

    # Count how many consecutive rounds before t-1 had cooperation_rate < THRESHOLD
    low_coop_streak = 0
    for round_i in range(prev_round - 1, 0, -1):
        round_actions = history[round_i - 1]
        coop_count_i = sum(1 for a in round_actions if a == 'C')
        coop_rate_i = coop_count_i / n
        if coop_rate_i < THRESHOLD:
            low_coop_streak += 1
        else:
            break

    # If current round cooperation is HIGH enough, cooperate
    if cooperation_rate >= THRESHOLD:
        return 'C'

    # Cooperation rate is low (< THRESHOLD)
    else:
        # If we have NOT punished yet (low_coop_streak < MAX_PUNISH_ROUNDS)
        # defect to punish
        if low_coop_streak < MAX_PUNISH_ROUNDS:
            return 'D'
        else:
            # Have punished for MAX_PUNISH_ROUNDS rounds, now forgive and try to cooperate
            return 'C'
```

---

## Summary:

| Condition                      | Action |
|-------------------------------|--------|
| Round 1                       | Cooperate (C) |
| Last round (t = r)            | Defect (D)   |
| Previous round cooperation ≥ 80%  | Cooperate (C) |
| Cooperation < 80%, less than 1 consecutive punished round | Defect (D) |
| Cooperation < 80%, after 1 punishment round             | Cooperate (C) (forgive) |

---

# Why this strategy is cooperative:

- It starts cooperating without requiring coordination.

- It only defects to discourage persistent defection, protecting own payoffs.

- It forgives and tries to re-establish cooperation, promoting stable mutual cooperation.

- It defects in the last round, which is rational under backward induction.

- It does not rely on signaling or secret agreements — fully based on observed actions.

- This fosters an environment where cooperating players obtain higher payoffs over repeated rounds, rewarding cooperative behavior and punishing defection enough to disincentivize free-riding.

---

This conditional cooperation, forgiveness, and eventual defection in the last round aligns well with strategic rationality and the cooperative mindset for repeated public goods games under the constraints given.
'''

description_COOPERATIVE_66 = '''
Here is a cooperative strategy for the N-Player Public Goods Game, designed to encourage mutual cooperation while being robust to defections:

---

### **Cooperative Strategy: "Conditional Reciprocity with Forgiveness"**

---

#### **Key Intuition**

- Cooperate initially and encourage cooperation as long as others do too.
- If others defect, respond by defecting but with a mechanism to forgive occasional defections.
- Use defections as signals of potential breakdown, but try to restore cooperation quickly.
- Towards the last round, defect to avoid exploitation since future rounds disappear (standard backward induction reasoning).

---

### 1. Decision Rules

**Notation:**
- Let `t` = current round (1 ≤ t ≤ r)
- Let `H_t-1` = action history of all players up to round t-1
- Let `C_o(t-1)` = number of other players who cooperated in previous round (t-1)
- Let `T` = forgiveness threshold (number of defectors tolerated before defecting)
- Let `forgave` = boolean indicating whether strategy has forgiven the last defection (to avoid infinite punishment cycles)

**Parameters for example:**
- `T = 1` (tolerate up to 1 defector before punishing)
- `forgave = False` initially

---

#### Round 1:

- **Cooperate.**

Since no history exists yet, start by cooperating to signal willingness to cooperate.

---

#### Rounds 2 to r-1 (intermediate rounds):

**Observe** previous round's actions:

- If **all players cooperated** in round t-1 (i.e., `C_o(t-1) = n - 1`):

  - Cooperate in round t.

- Else if **number of defectors in round t-1 ≤ T**:

  - If you have **not forgiven** yet:

    - Forgive this defection(s) by cooperating again in round t.

    - Set `forgave = True`.

  - Else (already forgiven once and defections continue):

    - Defect in round t.

- Else (number of defectors > T):

  - Defect in round t.

---

#### Round r (last round):

- **Defect.**

Backward induction: Last round cooperation is not rewarded with future cooperation, so defect to maximize individual payoff.

---

### 2. Edge Cases

- **First Round (t=1):** Cooperate to initiate cooperation.

- **Last Round (t=r):** Defect to prevent exploitation (standard in finitely repeated games).

- **Occasional Defections:** Forgive once to allow for mistakes or noise, but punish persistent defection.

- **If others never cooperate:** Respond by defecting and persistently defecting — no incentive to cooperate alone.

---

### 3. Cooperative Mindset Alignment

- The strategy explicitly tries to establish and maintain cooperation by cooperating initially and forgiving occasional defections.

- Avoids endless punishment cycles by allowing forgiveness once.

- Makes clear that persistent defectors will be punished by defection, promoting stable cooperation equilibriums if other players are similarly inclined.

- Last round defection aligns with rational equilibrium to avoid being exploited.

---

### Pseudocode

```python
def strategy(t, r, n, history):
    """
    t: current round (1-indexed)
    r: total rounds
    n: total players
    history: list of length t-1, each element is a list of n actions ['C' or 'D']
             representing actions of all players in previous rounds
    
    Returns: action 'C' or 'D'
    """
    # Forgiveness memory stored externally or as state
    # For illustration, use a global or persistent variable:
    global forgave
    
    # Initialize forgiveness flag on first call
    if t == 1:
        forgave = False
        return 'C'  # cooperate first round
    
    if t == r:
        return 'D'  # last round defect
    
    # Analyze previous round
    prev_round = history[-1]  # actions of all players in round t-1
    my_index = ... # your own player index (implementation detail)
    
    # Count defectors other than self in previous round
    defectors = sum(1 for i, a in enumerate(prev_round) if a == 'D' and i != my_index)
    
    # Count cooperators other than self
    cooperators = sum(1 for i, a in enumerate(prev_round) if a == 'C' and i != my_index)
    
    # If everyone cooperated last round, cooperate this round
    if defectors == 0:
        forgave = False  # reset forgiveness after full cooperation
        return 'C'
    
    # If defectors <= forgiveness threshold (T=1)
    if defectors <= 1:
        if not forgave:
            forgave = True
            return 'C'  # forgive once
        else:
            return 'D'  # defect after repeated defection
    
    # More than forgiveness allowed, defect
    return 'D'
```

---

### Variations / Extensions (Optional)

- **Generous forgiveness:** Increase forgiveness threshold `T` to allow more defectors if noise suspected.

- **Probabilistic forgiveness:** Forgive with some probability rather than deterministically.

- **Gradual punishment:** Use graded responses depending on number of defectors.

However, the simple conditional reciprocity with single forgiveness and final round defection is a solid cooperative baseline.

---

### Summary

- **Initial move:** Cooperate.

- **If all cooperated last round:** Cooperate.

- **If ≤ 1 defector last round:** Cooperate once more (forgive), then punish persistent defection.

- **If > 1 defector:** Defect.

- **Last round:** Defect.

This strategy promotes and sustains cooperation in early/mid rounds, punishes defection to deter free-riding, and carefully exits cooperation in final round. It is aligned with rational cooperative behavior under the given game constraints.
'''

description_COOPERATIVE_67 = '''
Below is a cooperative strategy designed to foster cooperation in the repeated Public Goods Game under the given constraints. The strategy aims to maximize joint payoffs through mutual cooperation, while punishing defections to discourage free-riding. It incorporates forgiveness to avoid endless cycles of retaliation and uses the full history of observed actions.

---

### Cooperative Strategy: Conditional Grudger with Forgiveness and Responsive Cooperation

#### Intuition
- **Start cooperatively** to signal goodwill and try to build mutual cooperation.
- **Monitor all players' cooperation levels each round.**
- **If all cooperated last round**, cooperate again.
- **If any player defected in the last round**, defect in the current round as punishment.
- **After punishment, if all players cooperate again**, forgive and return to cooperation.
- Use the final round to **slightly risk cooperating once more**, to capture potential last-moment cooperation gains.

This creates a well-known repeated-game incentive pattern akin to a "grim trigger" but softened with forgiveness, promoting cooperation when others cooperate, and punishing defection swiftly but not infinitely.

---

### Decision Rules

Let:

- **t** = current round number, from 1 to r
- **H(t-1)** = observed actions of all players in round t-1 (only defined if t > 1)
- **C_all(t-1)** = boolean: true if *all* players cooperated in round t-1, else false

---

#### 1. First Round (t = 1)
- Cooperate: no prior information, start with cooperation to attempt building trust.

#### 2. Intermediate Rounds (1 < t < r)
- If **C_all(t-1) == true** (all cooperated last round): **cooperate**
- Else (if any player defected last round): **defect** (punishment round)
- Exception: After a punishment round, if everyone cooperated in that punishment round, forgive and return to cooperation.

To implement forgiveness, maintain a "punishment flag":
- If previous round was punished, check if all cooperated in current round
  - If yes, reset punishment flag, cooperate next round
  - Otherwise, continue punishment

---

#### 3. Last Round (t = r)
- Cooperate: it's the final round, so cooperating can maximize joint payoff
- Because no future retaliation is possible, defecting here hurts the entire payoff but risks ending on distrust
- This final-round cooperation can also encourage cooperation in earlier rounds in repeated tournaments (if any)

---

### Summary in Pseudocode

```python
# State variables
punishment = False  # Flag indicating whether currently punishing defectors

def decide_action(t, history):
    # history: list of previous rounds' actions; each round is a list of length n with 'C' or 'D'

    global punishment
    
    if t == 1:
        # First round: start with cooperation
        punishment = False
        return 'C'
    
    previous_round = history[t-2]  # zero-indexed
    all_cooperated = all(action == 'C' for action in previous_round)
    
    if t == r:
        # Last round: cooperate unconditionally
        return 'C'
    
    if not punishment:
        # Not currently punishing
        if all_cooperated:
            # All cooperated last round, continue cooperating
            return 'C'
        else:
            # Someone defected last round, start punishment
            punishment = True
            return 'D'
    else:
        # Currently punishing
        if all_cooperated:
            # Forgive if all cooperated during punishment round
            punishment = False
            return 'C'
        else:
            # Continue punishment
            return 'D'
```

---

### Explanation and Characteristics

- **Cooperative**: Always start by cooperating; cooperate if everyone has shown cooperation.
- **Conditional**: Switches to defection if any player defected last round, enforcing a simple social norm.
- **Forgiving**: Punishment ends as soon as everyone cooperates again, preventing endless defection cycles.
- **Simple memory**: Bases decision only on the last round's full observed action profile, requiring modest history.
- **Resilient**: If all players play this strategy, the stable outcome is perpetual cooperation.
- **Punishes free-riding immediately**, so defectors receive less payoff.
- **Final round cooperation** avoids the "end-game unraveling" problem common in finitely repeated games.

---

### Limitations

- Does not employ complex history pattern recognition or attempt to differentiate between intentional defectors and mistakes.
- Assumes players observe all actions perfectly and simultaneously.
- If opponents never forgive, it may devolve into mutual defection, although all-C is stable.

---

This strategy is a simple, robust, and strongly cooperative approach suitable for maximizing payoffs in a repeated Public Goods Game tournament without communication or coordination protocols.
'''

description_COOPERATIVE_68 = '''
Here is a well-grounded cooperative strategy for the described N-player repeated public goods game. It balances the incentive to cooperate with a mechanism to punish defection, while maintaining cooperation whenever possible.

---

### Cooperative Strategy: **"Grim Trigger with Forgiveness"**

---

#### Intuition:
- Start fully cooperative to build trust.
- Continue cooperating as long as *every* other player has cooperated in all previous rounds.
- If any defection is observed by any player in any past round, punish by defecting in the next round.
- Implement a forgiveness window after punishment to allow a return to cooperation if all players cooperate again.
- In the last round, defect because there is no future to enforce cooperation (standard backward induction result).

---

### Decision Rules:

Let  
- `history[t][i]` denote action of player i in round t (C or D)  
- `round` be current round in 1..r

Define two boolean flags:  
- `all_cooperated_before` = True if all players chose C in all past rounds (1..round-1), else False  
- `recent_defection_detected` = True if a defection has been observed since our last forgiveness/reset, else False

Define state variable:  
- `punishing` = False initially; True if currently punishing a defection  

---

### Strategy Description:

1. **First Round (round = 1):**  
   - Cooperate unconditionally.

2. **Intermediate Rounds (1 < round < r):**  
   - If `punishing` is False and `all_cooperated_before` is True:  
     Cooperate.  
   - Else if `punishing` is False and `all_cooperated_before` is False (defection detected):  
     Set `punishing = True` (start punishment phase) and defect this round.  
   - If `punishing` is True:  
     Defect this round (punishment).  
     After this round, check if current round’s actions by all players were cooperate:  
       - If yes, reset `punishing = False` (forgiveness, return to cooperation).  
       - Else, continue punishing.

3. **Last Round (round = r):**  
   - Always defect (no future rounds for punishment, rational defect).

---

### Pseudocode

```python
# Initialization
punishing = False

for round in 1 to r:
    if round == 1:
        action = C

    elif round == r:
        action = D  # last round defect

    else:
        # Check if all players cooperated in all past rounds
        all_cooperated_before = True
        for t in 1 to round - 1:
            for player in 1 to n:
                if history[t][player] == D:
                    all_cooperated_before = False
                    break
            if not all_cooperated_before:
                break

        if not punishing:
            if all_cooperated_before:
                action = C
            else:
                # start punishment phase
                punishing = True
                action = D
        else:
            # currently in punishment phase
            action = D
            # Check if all cooperated this round to forgive
            if all(history[round][player] == C for player in 1 to n):
                punishing = False
```

---

### Explanation / Rationale:

- **Cooperate initially:** sets cooperative tone.
- **Grim trigger:** harshly punishes any defection to deter free-riding.
- **Forgiveness:** avoids permanent cycles of retaliation, encourages return to cooperation.
- **Last round defect:** standard backward induction rationality; no incentive to cooperate.

---

### Behavior Summary With Example Scenarios:

- All cooperate forever → Everyone earns maximum payoff each round.
- If one defects once, others punish next round by defecting → Punisher loses a little too but enforces norm.
- If defectors resume cooperation after punishment, punishers forgive and return to cooperation.
- If defectors keep defecting, punishment continues indefinitely until break.
- No cooperation in last round to avoid exploitation.

---

**This strategy is cooperative because it aims to maintain full cooperation as the equilibrium for as long as all players cooperate. It punishes defection to maintain incentive compatibility but allows forgiveness to avoid endless retaliation cycles.**

---

Let me know if you want me to refine for risk-tolerance, or explore variants like Tit-for-Tat!
'''

description_COOPERATIVE_69 = '''
Below is a cooperative strategy for the N-Player Public Goods Game that aims to foster cooperation while deterring defection. It balances cooperation and punishment over the repeated rounds, handling edge cases clearly and systematically.

---

## Intuition and Rationale

- Cooperation yields the highest joint payoff as long as enough players also cooperate.
- Defection provides a short-term private gain at the expense of collective payoff.
- The game is finite and simultaneous-move repeated with perfect information.
- The last round is a challenging edge case, as defection is strictly dominant there.
- Given perfect information, we can condition our behavior on observed past actions of all players each round.
- The goal is to sustain cooperation as long as others cooperate, but punish defections sufficiently to make defection unattractive.

---

## Strategy Description: "Reciprocating Conditional Cooperator"

### Core principles

- **Start cooperatively** in round 1.
- **Cooperate if no defections have occurred in the past.**
- **If any player defects in any round, defect in all subsequent rounds as punishment (grim trigger).**
- **On the last round, defect regardless to avoid exploitation (backward induction).**

---

### Step-by-step decision rules

Let:

- `round` ∈ {1, 2, ..., r} be the current round
- For each past round `t < round`, observe the action profile `A_t = (a_1,t, a_2,t, ..., a_n,t)` where `a_i,t ∈ {C, D}`
- Define `defections_so_far =` TRUE if ∃ t < round and ∃ i s.t. `a_i,t = D`; else FALSE.

---

### Action Decision for Player i in round t

If (t == r)  
 // Last round  
 Play D (defect)

Else if (defections_so_far == FALSE)  
 // No defections observed in previous rounds, cooperate  
 Play C (cooperate)

Else  
 // Defection(s) detected in history, punish by defecting  
 Play D (defect)

---

## Pseudocode

```python
def action(round, history):
    # history: list of past rounds' action profiles
    # Each element is a list of length n: ['C' or 'D' for each player]
    
    if round == r:
        return 'D'  # Defect in last round
    
    # Check if any defection has occurred so far
    defections_so_far = False
    for past_round_actions in history:
        if 'D' in past_round_actions:
            defections_so_far = True
            break
    
    if defections_so_far:
        # Punish by defecting
        return 'D'
    else:
        # Cooperative phase
        return 'C'
```

---

## Explanation of the Strategy

- **Initial Cooperation:** We start by cooperating to signal willingness to build cooperation.
- **Monitor and Respond:** Continue cooperating only if all players cooperated collectively in all previous rounds.
- **Grim Trigger Punishment:** A single defection by any player triggers permanent defection by us for all subsequent rounds, discouraging defections.
- **Last-round Defection:** Since the last round is a one-shot game with no future repercussions, rational players are incentivized to defect. We defect to avoid exploitation.
- **Effectiveness:** This strategy is a well-known approach to sustain cooperation in finitely repeated public goods games with perfect monitoring and no communication or coordination.
- **No coordination needed:** The strategy only depends on observed history, not on implicit agreements or signals.

---

## Edge Cases Covered

| Scenario                     | Action Taken                                   | Reasoning                                                  |
|-----------------------------|-----------------------------------------------|------------------------------------------------------------|
| First round `t=1`            | Cooperate (C)                                 | Start cooperative to encourage mutual cooperation          |
| No defections in all past rounds, `t < r` | Cooperate (C)                          | Sustain cooperation as long as everyone cooperates          |
| At least one defection in any past round | Defect (D)                                | Punish defectors and deter future defection                  |
| Last round `t = r`           | Defect (D)                                   | Last iteration, no incentive to cooperate, defect to avoid exploitation |

---

# Summary

This "Reciprocating Conditional Cooperator" strategy plays cooperate as long as everyone cooperated before, punishes permanently after the first defection, and defects in the last round. This aligns with cooperative mindset while anticipating rational exploitation incentives, aiming to maximize group welfare in repeated public goods settings with perfect monitoring and no communication.
'''

description_COOPERATIVE_70 = '''
Below is a carefully designed **cooperative strategy** tailored for the repeated Public Goods Game as specified. It balances cooperation, punishment, forgiveness, and endgame reasoning, based only on observed past actions (perfect information), without reliance on prior coordination or signaling.

---

## Cooperative Strategy: *"Conditional Reciprocity with Forgiveness and Endgame Cooperation"*

### Core Idea
- Start fully cooperative to build trust.
- Continue cooperating **only if** all players cooperated in the previous round.
- If anyone defects (free-rides), defect in the next round to punish.
- Forgive after one round of punishment by returning to cooperation, assuming the opponent also returns to cooperation.
- In the **final round**, cooperate regardless to maximize joint payoff, because no future rounds remain for punishment/reward.

---

## Decision Rules (per round t)

Let:
- \( H_{t-1} = \) action profile vector from previous round \(t-1\), where \(H_{t-1}[j] \in \{C,D\}\) is player j's action.
- \( C_{t-1} = 1 \) if all players cooperated in round \( t-1 \), else 0.
- \( P_{t-1} = 1 \) if I defected in round \( t-1 \) (i.e., I punished last round), else 0.
- Current round \( t \in \{1, 2, ..., r\} \).

---

### Rule 1: First round (t=1)

- Cooperate unconditionally.

Reasoning: Establish baseline mutual cooperation.

---

### Rule 2: Intermediate rounds (1 < t < r)

- If everyone cooperated last round (\( C_{t-1} = 1 \)), cooperate.
- If not everyone cooperated last round (\( C_{t-1} = 0 \)):
  - If I did **not** defect last round to punish (\( P_{t-1} = 0 \)), defect now (start punishment).
  - Else if I **did** defect last round to punish (\( P_{t-1} = 1 \)), cooperate now (forgive).

Rationale: This is a *grim trigger with forgiveness*. Defect one round after first observed defection to punish, then forgive to give a chance to restore cooperation.

---

### Rule 3: Final round (t = r)

- Cooperate unconditionally.

Rationale: No future rounds to incentivize punishment, so best to maximize joint payoff now.

---

## Pseudocode

```python
def cooperative_strategy(round_t, history, player_index, total_rounds):
    # history: list of tuples (a_1,...,a_n) from previous rounds
    # each a_i in {'C','D'}
    
    if round_t == 1:
        # First round: cooperate
        return 'C'
    
    elif round_t == total_rounds:
        # Final round: cooperate
        return 'C'
    
    else:
        last_round = history[-1]
        
        # Check if all cooperated last round
        all_coop = all(a == 'C' for a in last_round)
        
        # Check if player defected last round to punish
        # Defected if played 'D' last round and previous round was not all cooperative
        if round_t == 2:
            # No prior punishment possible before round 2
            punished_last_round = False
        else:
            prev_round = history[-2]
            was_all_coop_prev = all(a == 'C' for a in prev_round)
            player_action_prev = history[-1][player_index - 1]
            punished_last_round = (player_action_prev == 'D') and (not was_all_coop_prev)
        
        if all_coop:
            # All cooperated last round: cooperate
            return 'C'
        else:
            if not punished_last_round:
                # Start punishment by defecting
                return 'D'
            else:
                # Forgive by cooperating
                return 'C'
```

---

## Explanation

- **Cooperation by default:** Player starts by cooperating to encourage mutual benefit.
- **Punishment:** If defectors emerge, defect just once on the next round as a credible threat.
- **Forgiveness:** Return to cooperation after punishing to repair cooperation and avoid endless defection cycles.
- **Final round cooperation:** No strategic reason to defect at the end; cooperation yields higher collective payoffs.

---

## Why is this strategy cooperative?

- It maximizes group benefit by preferring cooperation.
- It punishes defections, deterring free-riding.
- It forgives quickly, to reset cooperation instead of permanent retaliation.
- It leverages repeated interaction incentives without relying on external signals.
- It promotes mutual cooperation for the majority of rounds, maximizing joint payoff under the constraint \(1 < k < n\).

---

This strategy should perform well against a variety of opponent behaviors, including those that test cooperative norms or exploit naive cooperation, due to its balanced reciprocity and tolerance.
'''

description_COOPERATIVE_71 = '''
Here is a well-justified cooperative strategy for the repeated N-Player Public Goods Game described. The strategy aims to foster mutual cooperation while guarding against exploitation and accounting for the repeated nature and known parameters.

---

## Cooperative Strategy: Modified Grim Trigger with Forgiveness ("Forgiving-Grim")

### Intuition
- **Goal:** Achieve and maintain full cooperation to maximize payoffs for all.
- **Risk:** Opponents may defect to gain short-term advantage.
- **Mitigation:** Punish defection by defecting, but allow for forgiveness to avoid permanent collapse due to occasional mistakes.
- **Last Round:** Defect to avoid exploitation and free-ride on others' cooperation, as there is no future to incentivize cooperation.

---

### Decision Rules

**Notation:**
- `t`: current round (1 ≤ t ≤ r)
- `History`: record of all players’ actions in previous rounds {1, …, t-1}
- `DefectionsInLastRound`: number of players (including self) who defected in round t-1
- `HasDefectedPreviously`: boolean indicating if any defection occurred so far

---

### Strategy:

| Round               | Action                                                         |
|---------------------|----------------------------------------------------------------|
| **Round 1**         | Cooperate                                                      |
| **Rounds 2 to r-1** | If no defection detected in any previous round, cooperate.<br>If defection detected in previous round, defect this round.<br>If cooperation resumes in previous round after punishment, forgive and cooperate again. |
| **Round r (last round)** | Defect                                                        |

---

### Detailed Explanation

1. **Round 1:**  
   - Cooperate to signal willingness to build mutual cooperation.

2. **Rounds 2 to r-1:**  
   - Monitor previous round:  
     - If everyone cooperated last round → continue cooperating.  
     - If any player defected last round → punish by defecting this round.  
   - After punishing one round, if the previous round showed full cooperation again → forgive by cooperating again (i.e., don't punish forever).  
   - This acts like a "grim trigger" with leniency: one round of punishment followed by opportunity to return to cooperation.

3. **Round r (last round):**  
   - Defect unconditionally since no future rounds exist to enforce cooperation and cooperating would be exploitable.

---

### Why This Works

- **Encourages cooperation:** By cooperating first and rewarding cooperation with cooperation.
- **Discourages free-riding:** Any defection triggers immediate punishment in next round.
- **Forgives errors:** Avoids permanent mutual defection due to mistakes by forgiving after a single punishment round.
- **Exploits last round’s endgame:** Knowing the last round has no future consequences, defect there to maximize payoff.

---

### Pseudocode

```python
def strategy(t, r, history):
    # t: current round (1-indexed)
    # r: total rounds
    # history: list of tuples (actions of all players) for rounds 1..t-1

    self_index = your_player_index  # assumed known

    if t == 1:
        # First round: cooperate to establish trust
        return 'C'

    if t == r:
        # Last round: always defect (no future to incentivize cooperation)
        return 'D'

    # For rounds 2 to r-1:
    last_round_actions = history[-1]
    prev_round_full_cooperation = all(a == 'C' for a in last_round_actions)
    prev_round_any_defection = any(a == 'D' for a in last_round_actions)

    # Check if punished last round (were we defecting last round?)
    # Find pattern of punishment and forgiveness (need to track history)

    # Simple state tracking alternative (without memory other than last round):
    # If previous round was full cooperation: cooperate
    # Else, defect to punish last round's defection
    if prev_round_full_cooperation:
        return 'C'
    else:
        # Punish defection by defecting this round
        return 'D'
```

---

### Edge Cases Addressed

- **First round:** Cooperate to initiate cooperation as no history is available.
- **Last round:** Defect unconditionally to avoid being exploited.
- **Single or occasional defectors:** Punish by defecting next round, but return to cooperation if all cooperate afterward.
- **Multiple defectors:** Same punishment logic—defect to punish, then forgive upon observed cooperation.
- **Uncooperative environment:** If opponents always defect, this strategy ends up defecting consistently, minimizing losses.

---

### Summary

- **Cooperate initially to build trust.**  
- **Defect one round after detecting defection to punish.**  
- **Forgive and return to cooperation if opponents resume cooperating.**  
- **Defect in final round to avoid final round exploitation.**  

This balances cooperative incentives and self-protection in a repeated public goods environment with no communication.

---

If you want, I can help map this to a more formal automaton or Markov state machine representing transitions between cooperate, punish, and forgive states.
'''

description_COOPERATIVE_72 = '''
Here is a cooperative strategy tailored for the N-Player Repeated Public Goods game under the given constraints.

---

## Strategy Name: **"Gradual Reciprocity with Forgiveness"**

---

### Intuition:
The strategy aims to maximize joint group payoff by cooperating as much as possible, while protecting itself from exploitation via conditional defection in response to observed defections. It uses a forgiving approach to allow recovery from accidental defections or noise, thus maintaining cooperation over multiple rounds. The design leverages perfect monitoring of past actions and the repeated structure.

---

### Summary of Decision Logic:

| Round        | Rule                                                                                 |
|--------------|--------------------------------------------------------------------------------------|
| Round 1      | Cooperate unconditionally (establish trust and goodwill)                            |
| Intermediate | Cooperate if *all* players cooperated in the previous round; otherwise defect once as punishment but try to forgive soon |
| Last round   | Defection is justified, but still tries one round of cooperation as "hope" for mutual gain |

---

### Detailed Rules:

Let  
- \( t \) = current round (1 to r)  
- \( H^{t-1} \) = vector of all players’ actions in round \( t-1 \) (empty if \( t=1 \))  
- \( C_{t-1} = \sum_{j=1}^n c_j^{t-1} \) = number of cooperators in round \( t-1 \)

---

### 1. First Round (t = 1) - Cooperate

- Cooperate to establish goodwill and begin cooperation.
- No history is available, so no basis for suspicion.

---

### 2. Intermediate Rounds (1 < t < r) - Conditional Cooperation

- **If everyone cooperated in previous round \( (C_{t-1} = n) \), then cooperate in this round**  
  (Maintain cooperation if full cooperation observed)

- **Else (some defectors in last round):**

   - **Punish once by defecting this round** (retaliate for defection)  
   - After punishing one round, **attempt cooperation in the next round**, regardless of whether others cooperate or defect

- This implements a forgiving *"tit-for-tat with forgiveness"* style:  
  only punish defections once; don't get stuck in endless retaliation cycles.

---

### 3. Last Round (t = r) - Endgame Cooperation + Defection

- The traditional backward induction suggests full defection in the last round, but cooperation can still pay off when other players are uncertain or are also implementing cooperative strategies.

- **Play cooperate in round r if all cooperated in r-1**, otherwise **defect**.

- This allows cooperation to extend to the final round if mutual cooperation has been stable.

---

### Additional Notes:

- This strategy is **fully deterministic** based on the observed past round actions and round number.
- Since all players observe all actions, it can detect defection exactly.
- The strategy protects itself from persistent exploitation by enforcing punishment but also aims to restore cooperation quickly.
- Forgiveness mechanism enables escaping retaliation loops caused by accidental defection or experimentation by others.
- The initial cooperation and attempts to cooperate until the last round embody the cooperative mindset.
- Defection is used only as a measured response to defection by others.

---

## Pseudocode

```python
# Parameters: n (players), r (rounds)
# Inputs: t (current round, 1-based), past_actions (list of action arrays for rounds 1..t-1)
# Actions: 'C' (cooperate), 'D' (defect)

def strategy(t, past_actions, n, r):
    if t == 1:
        # First round: cooperate unconditionally
        return 'C'

    # Analyze last round actions
    last_round = past_actions[-1]
    num_cooperators = sum(1 for a in last_round if a == 'C')

    # Check if full cooperation last round
    full_coop_last_round = (num_cooperators == n)

    # Check if we defected last round to manage forgiveness
    # past_actions[t-2] is the actions in last round, so to check our own last action:
    # Assuming player index i known, here represented as player_i (0-based)
    # For generic description, use a variable current player index `i`
    # (in tournament, the implementation will know which player it is)
    # For now, assume function receives player_i as argument if needed

    # We need to determine if we just defected last round to forgive now

    # Pseudocode assumes knowledge of own past action, suppose variable player_i is known
    # Otherwise described abstractly:

    own_last_action = past_actions[-1][player_i]  # our own last round action

    if t == r:
        # Last round
        if full_coop_last_round:
            return 'C'  # cooperate if everyone cooperated last round
        else:
            return 'D'  # defect otherwise (endgame defection)
    else:
        # Intermediate round
        if full_coop_last_round:
            return 'C'  # continue cooperating if full cooperation last round
        else:
            # Some defected last round - punishing or forgiving
            # If we cooperated last round and others defected, we punish now
            # If we defected last round in punishment, now forgive
            if own_last_action == 'C':
                return 'D'  # punish once
            else:
                return 'C'  # forgive, return to cooperation

```

(**Note:** In the actual tournament implementation, the player knows their identity to check own last action.)

---

## Summary

This strategy cooperates initially, punishes defections only once, forgives quickly, and resumes cooperation whenever possible. It retains cooperation through most of the game, only defecting to punish or in the last round if others defected.

This achieves:

- **Cooperation maximization** - seeking group benefit  
- **Deterrence of exploitation** - via measured punishment  
- **Robustness** - forgiveness to avoid endless retaliation  
- **Transparency** - easy to predict and respond by others, supporting stable cooperation

--- 

If every player adopts this strategy, the group will consistently cooperate and achieve payoffs close to the socially optimal level \(k\).
'''

description_COOPERATIVE_73 = '''
**Cooperative Strategy: "Forgiving Tit-for-Tat with Gradual Recovery"**

---

### Intuition

The game is a repeated public goods game with binary actions: cooperate (C) or defect (D). Cooperation maximizes group payoff but is individually costly (c_i=1). Defection yields an immediate private benefit but lowers the total public good.

Our strategy must:

- Start cooperative to establish trust (first round cooperation).
- Reward cooperation from others.
- Punish defection, but allow recovery to avoid endless mutual defection.
- Promote cooperation, as that yields higher payoffs (k > 1 but < n).
- Handle the final round carefully to avoid end-game defection collapse.

---

### High-Level Description

1. **Round 1:** Always cooperate to signal cooperative intention.
2. **From round 2 to r - 1:**  
   - Cooperate if *all other players cooperated in the previous round*.  
   - If one or more players defected last round, defect once as punishment.  
   - After defecting one round as punishment, attempt to return to cooperation to "forgive" and restore group cooperation.
3. **Round r (final round):** Since future retaliation is not possible, defect (to avoid being exploited in one-shot reasoning).
   
This strategy mirrors a "forgiving tit-for-tat" approach adapted for multi-player public goods: it punishes defection by defecting once, then tries to re-establish cooperation.

---

### Why this approach?

- Starting cooperative encourages others to cooperate.
- Punishing all defections with a single defect discourages free-riding.
- Forgiveness avoids permanent breakdown of cooperation.
- Defection in the last round is a standard backward induction equilibrium to avoid exploitation.

---

### Pseudocode

```python
# Input:
#   history: list of previous rounds, each round is a list of actions by all players
#   i: index of this player (1-based)
#   r: total number of rounds

def cooperative_strategy(history, i, r):
    t = len(history) + 1  # current round number (1-based)

    # Round 1: cooperate
    if t == 1:
        return 'C'

    # Final round: defect (no incentive to cooperate)
    if t == r:
        return 'D'

    # Check previous round actions
    prev_round = history[-1]  # list of actions of all players in previous round
    others_actions = [prev_round[j] for j in range(len(prev_round)) if j != i - 1]

    # If all others cooperated last round, cooperate
    if all(a == 'C' for a in others_actions):
        return 'C'

    # Otherwise, detect if this player defected last round as punishment
    # Count how many rounds since last defection in response to defection
    # For simplicity, defect once after any defection, then try to cooperate

    # Check this player's action last round
    own_last_action = prev_round[i - 1]

    # If last round was cooperation but others defected, defect now as punishment
    if own_last_action == 'C':
        return 'D'

    # If last round was defect (already punished), try to cooperate to forgive
    else:
        return 'C'
```

---

### Further Explanation:

- The core principle is **"cooperate if everyone else did last round; defect once if any defections from others appeared—then cooperate again."**
- This creates a cycle of mutual cooperation and enforces contributions without harsh permanent punishment.
- The last round defection is to avoid being exploited since there’s no future to incentivize cooperation.
- This strategy accepts short-term punishment rounds to maintain long-term cooperation.

---

### Edge Cases

- **First round:** No history — cooperate unconditionally.
- **Last round:** Defect unconditionally (standard backward induction in finitely repeated games).
- **Multiple defectors:** Treat any defection as trigger for single-round punishment.
- **Intermittent defectors:** Forgiving behavior allows cooperation to resume rapidly.
- **All others defect:** Will defect repeatedly but try cooperation if they suddenly cooperate.

---

### Summary

| Round        | Condition                                     | Action  |
|--------------|-----------------------------------------------|---------|
| 1            | No prior info                                 | Cooperate (C) |
| 2 to r - 1   | All others cooperated previous round          | Cooperate (C) |
| 2 to r - 1   | Any defection by others previous round, and player *did not* defect last round | Defect (D) once to punish |
| 2 to r - 1   | Player defected last round (punishment round) | Cooperate (C) to forgive |
| r (final)    | Unconditional                                 | Defect (D) |

This yields a clear, cooperative-minded, forgiving, and reciprocal strategy optimized for the repeated public goods game setting.
'''

description_COOPERATIVE_74 = '''
Below is a description of a **Cooperative Contingent Strategy** for the multi-round N-Player Public Goods game, designed to promote and maintain cooperation whenever possible, while also discouraging persistent defection. It uses conditional cooperation based on observed group behavior and applies a form of forgiving punishment to handle defections without permanently breaking cooperation.

---

### Strategy Overview: "Reciprocal Conditional Cooperation with Forgiveness"

This strategy aims to:

- Cooperate initially to establish cooperative norms.
- Maintain cooperation if most players cooperate.
- Punish defections to discourage free-riding.
- Forgive occasional defections to allow cooperation to resume.
- Defect outright only if persistent defection undermines cooperation.
- Cooperate in the last round (or last small set of rounds) to maximize collective welfare or defect if trust is completely broken (depending on observed cooperation to that point).

---

### Intuition

- Cooperation is collectively beneficial because the multiplication factor \( k \) satisfies \( 1 < k < n \).
- Mutual cooperation yields higher payoffs than mutual defection.
- Individual defection gains more private benefit in the short term but reduces group benefit.
- The strategy promotes cooperation by reciprocating cooperation and penalizing defection.
- Forgiveness prevents long-term mutual defection cycles caused by one-off mistakes or experimentation.
- In the final round, since retaliation is impossible afterwards, the incentive to defect is strong; the strategy accounts for this.

---

### Detailed Decision Rules

Let:
- \( t \) = current round (1 ≤ t ≤ r)
- \( H_{t-1} \) = history of all players' actions up to round \( t-1 \)
- For player \( i \), let \( c_i^t \in \{0,1\} \) indicate if player \( i \) cooperated in round \( t \) (1=cooperate, 0=defect)

Define:

- \( \text{TotalCoop}_{t-1} = \sum_{j=1}^{n} c_j^{t-1} \): total cooperators in previous round
- \( \text{MyAction}_{t-1} = c_i^{t-1} \): my own action in previous round
- \( \text{CoopThreshold} = \lceil 0.7 \times n \rceil \): threshold of cooperating players to maintain trust (can be tuned)
- \( \text{ForgivenessWindow} = 2 \): number of rounds to forgive isolated defections

---

### Step 1: Round 1 (Opening Move)

- Cooperate.

*Rationale:* Without history, start with cooperation to attempt mutual cooperation and maximize group payoff.

---

### Step 2: Rounds 2 to r-1 (Middle Rounds)

Decision depends on last round's cooperation level and individual history.

For round \( t \), do:

1. **If last round was mostly cooperative:**

   - Condition: \( \text{TotalCoop}_{t-1} \ge \text{CoopThreshold} \)
   - Action: Cooperate

2. **If last round had low cooperation but I cooperated:**

   - Condition: \( \text{TotalCoop}_{t-1} < \text{CoopThreshold} \) and \( \text{MyAction}_{t-1} = 1 \)
   - Action: Defect (punish defectors)

3. **If I defected in last round:**

   - If defect was just a single round among many cooperations in prior rounds (i.e., only one defection in last \( \text{ForgivenessWindow} \) rounds), attempt to return to cooperation (forgive self and others).
   - Otherwise, defect to avoid exploitation.

4. **If forgiveable defection detected in group (someone else defected once but cooperation mostly present):**

   - Cooperate as a signal of forgiveness.

---

### Step 3: Final round \( t = r \)

Use a "trigger" depending on history:

- If cooperation was stable (high overall cooperation in previous rounds), cooperate **to maximize collective payoff** since no future punishment is possible.
- If defection was frequent, defect to avoid being exploited.

We can quantify "stable cooperation" as average cooperation rate ≥ 0.8 in rounds 1 to \( r-1 \).

---

### Edge Cases & Notes

- If cooperation ever drops to zero (everyone defects), remain defecting since cooperation cannot be sustained.
- Forgiveness mechanism avoids deadlocks of perpetual mutual defection due to simple mistakes or "experimentation."
- The threshold and forgiveness window can be tuned based on \( n \), \( r \), and \( k \).

---

### Pseudocode

```python
# Parameters (to be set according to game)
n = number_of_players
r = number_of_rounds
k = multiplication_factor

CoopThreshold = ceil(0.7 * n)
ForgivenessWindow = 2

# history_actions: list of length t-1, each element is a list of length n with 0/1 actions for players
# self_index: index of this player i (0-based)
def strategy(t, history_actions, self_index):
    if t == 1:
        # First round: cooperate
        return 'C'

    # Compute stats from previous rounds
    last_round = history_actions[-1]
    total_coop_last = sum(last_round)
    my_last_action = last_round[self_index]

    # Average cooperation until previous round
    total_coop_history = sum(sum(round_actions) for round_actions in history_actions)
    avg_coop = total_coop_history / ((t - 1) * n)

    # Check how many times player defected in last ForgivenessWindow rounds
    recent_history = history_actions[-ForgivenessWindow:]
    my_recent_actions = [round_actions[self_index] for round_actions in recent_history]
    my_defections_recent = my_recent_actions.count(0)

    # Check group cooperation in last round
    if total_coop_last == 0:
        # Everyone defected last round -> defect forever
        return 'D'

    # Final round logic
    if t == r:
        if avg_coop >= 0.8:
            return 'C'  # cooperate in final round if stable cooperation
        else:
            return 'D'  # defect otherwise

    # Middle rounds logic
    if total_coop_last >= CoopThreshold:
        # Mostly cooperators last round
        return 'C'

    else:
        if my_last_action == 1:
            # I cooperated but others defected -> punish by defecting
            return 'D'
        else:
            # I defected last round
            if my_defections_recent > 1:
                # Multiple recent defections -> keep defecting
                return 'D'
            else:
                # Forgive and try cooperation again
                return 'C'
```

---

### Summary

- **Round 1:** Cooperate.
- **Middle Rounds:** Cooperate if majority cooperated last round; defect to punish if you cooperated but most defected. Forgive isolated defections by returning to cooperation.
- **Final Round:** Cooperate if cooperation stable; defect if cooperation unreliable.
- **Always defect if universal defection detected.**

---

### Why This Strategy is Cooperative?

- It fosters a cooperative equilibrium by starting cooperatively.
- It maintains cooperation when most players cooperate.
- It sanctions free-riders but forgives occasional defections.
- It avoids permanent deadlocks of defection by conditional forgiveness.
- It considers the strategic endgame incentives of the last round.
- Perfect information and observability allow precise responses to the group cooperation level.

---

This conditional cooperation strategy is a natural extension of "Tit-for-Tat" style approaches adapted for many players and repeated public goods settings where full cooperation yields the best group outcome.
'''

description_COOPERATIVE_75 = '''
Below is a cooperative strategy for the N-Player Public Goods Game that clearly aligns with cooperation, while handling key edge cases such as the first and last rounds. This design is inspired by classical conditional cooperation (similar to Tit-for-Tat or “trigger”) adapted for a multiplayer environment.

---

## Cooperative Strategy: "Gradual Reciprocity with Final Round Defection"

### Intuition
- Always start cooperating to establish mutual trust.
- Continue cooperating as long as all other players cooperated in the previous round.
- If anyone defects, respond by defecting once to punish the defector(s), but then try to return to cooperation if others do.
- For the final round, defect because cooperation cannot be reciprocated afterward (standard backward induction).
- This leads to stable cooperation for most of the game, increasing everyone's payoff beyond the non-cooperative equilibrium.

---

### Decision Rules

Let:
- `t`: current round (1 ≤ t ≤ r)
- `A_{t-1}`: vector of all players' actions in round t-1
- `me`: index of this player

**At round t:**

1. **First round (t = 1):**
   - Cooperate (C).
   - Rationale: start with cooperation to encourage others.

2. **Intermediate rounds (1 < t < r):**
   - If *all* players cooperated in previous round (`A_{t-1}[j] = C` for all j), then cooperate.
   - Else if anyone defected in previous round:
     - Defect once in round t as punishment.
     - In the round after defecting once, try to return to cooperation if others cooperated in last observed round.
   - This means defect out of retaliation but forgive quickly to restore cooperation.

3. **Last round (t = r):**
   - Defect (D).
   - Rationale: no future rounds, no incentive to cooperate in last round.

---

### Pseudocode

```python
# History data structure:
# actions_history[t-1] is a list of length n with each player's action at round t-1

def cooperative_strategy(t, r, actions_history, me):
    if t == 1:
        # First round: cooperate unconditionally
        return 'C'

    if t == r:
        # Last round: defect
        return 'D'

    # For intermediate rounds (2 to r-1)
    last_round_actions = actions_history[t-2]  # zero-based index

    # Check if everyone cooperated last round
    if all(action == 'C' for action in last_round_actions):
        # Everyone cooperated: cooperate
        return 'C'

    # Someone defected last round
    # Check if I defected last round (to know if I am in punishment phase)
    my_last_action = last_round_actions[me-1]

    # To implement "retaliate once then forgive":
    # Defect this round if I cooperated last round but someone else defected
    # Cooperate this round if I defected last round (so defect only once in retaliation)

    if my_last_action == 'C':
        # I cooperated last round but saw defection => defect now to punish
        return 'D'
    else:
        # I defected last round for punishment, so forgive now by cooperating
        return 'C'
```

---

### Explanation

- **First round cooperation** sets a positive precedent.
- **Retaliate once** punishes defectors, discouraging free-riding.
- **Quick forgiveness** allows the group to return to full cooperation, maintaining collective benefit.
- **Defect last round** follows standard backward induction reasoning to maximize individual payoff when no future repercussions exist.
- The strategy is fully **reactive based on observed past actions**, requiring no communication or assumptions beyond the game info.

---

### Behavior Summary

| Round       | Condition                                      | Action        | Reason                         |
|-------------|------------------------------------------------|---------------|---------------------------------|
| t = 1       | First round                                   | Cooperate (C) | Initiate cooperation               |
| 1 < t < r   | All cooperated at t-1                          | Cooperate (C) | Maintain mutual cooperation       |
| 1 < t < r   | Someone defected at t-1, I cooperated at t-1  | Defect (D)    | Punish defection once            |
| 1 < t < r   | Someone defected at t-1, I defected at t-1    | Cooperate (C) | Forgive and try to restore cooperation |
| t = r       | Final round                                   | Defect (D)    | Maximize payoff, no future rounds |

---

This is a simple yet effective "trigger-like" cooperative strategy designed to promote and maintain cooperation in a multi-player public goods setting with repeated interaction and perfect information.
'''

description_COOPERATIVE_76 = '''
Below is a cooperative strategy for the N-Player Public Goods Game designed to foster and sustain mutual cooperation while guarding against exploitation. It is inspired by well-known principles from cooperation in repeated games (like Tit-for-Tat) but adapted for a multi-player setting with only action observation.

---

## Strategy Name
**Conditional Cooperation with Forgiveness**

---

## Intuition
- Start cooperatively to signal willingness.
- Continue cooperating as long as the vast majority cooperate.
- Respond to defection by temporary punishment (defecting) to discourage free-riding.
- Offer forgiveness rapidly (return to cooperation if cooperation resumes) to maintain cooperation.
- Defect in the final round because no future punishment is possible (backward induction).

---

## Notation
- Let `t` index the current round (1 to r).
- Let `actions_t = [c_1, c_2, ..., c_n]`, where `c_j ∈ {C, D}` be the action profile of all players in round t.
- Let `num_cooperators_t =` number of players who cooperated in round t.

---

## Decision rules

### Round 1 (First round):
- Cooperate unconditionally.

---

### Intermediate rounds 2 to r-1:
- Observe all players' actions in round t-1.
- Define a cooperation threshold `T = n - 1` (i.e., tolerate at most one defector).
  
  - If `num_cooperators_{t-1} ≥ T` (at least n-1 players cooperated last round), then **cooperate** in round t.
    - Meaning: If all or all but one cooperated last round, cooperate this round.
  
  - Else (significant defection detected), **defect** in round t as punishment.
    - This signals disapproval of defection.
  
- **Forgiveness:** If punishment was applied in round t-1, check if cooperation has resumed among others in round t-1.
  - If so, return to cooperation immediately next round.
  
- Put simply: punish defection by defecting once, then resume cooperation if others do.

---

### Final round (round r):
- Defect regardless of history.
- Rationale: No future rounds to enforce cooperation; defect to maximize immediate payoff.

---

## Pseudocode

```python
def strategy(t, history, n, r):
    # history is a list of length (t-1), each element is a list of length n of actions ['C'/'D']
    
    if t == 1:
        # First round: cooperate
        return 'C'
    
    if t == r:
        # Last round: defect (backward induction)
        return 'D'
    
    last_round_actions = history[-1]
    num_cooperators = last_round_actions.count('C')
    
    # Threshold - tolerate at most one defector
    T = n - 1
    
    # Check if I punished last round (defected as punishment)
    did_punish_last_round = False
    if t >= 3:
        # look back two rounds: round t-2 actions
        round_before_last = history[-2]
        my_action_last_round = round_before_last[player_index]  # player_index known to agent
        if my_action_last_round == 'D':
            # assumed I defected as punishment last round
            did_punish_last_round = True
    
    if did_punish_last_round:
        # Was punishing last round, forgive if others cooperated in last round
        if num_cooperators >= T:
            return 'C'  # forgive and cooperate to restore cooperation
        else:
            return 'D'  # continue defecting if widespread defection continues
    
    # Normal regime: cooperate if last round was mostly cooperation
    if num_cooperators >= T:
        return 'C'
    else:
        return 'D'  # punish deviation
```

---

## Summary

- **Round 1**: Cooperate to start positively.
- **Rounds 2 to r-1**: Cooperate if last round had at most one defector; defect otherwise as punishment.
- **Forgive immediately if cooperation resumes:** after a punishment round, if others cooperate again, return to cooperation.
- **Round r**: Defect to maximize last-round payoffs (since no future rounds exist).

---

## Why is this cooperative?

- Starts by cooperating, signaling a willingness to cooperate.
- Only defects in response to meaningful defections by others, not for minor deviations or due to noise.
- Forgives quickly to resume cooperation rather than punish endlessly.
- Assumes rational players who understand that mutual cooperation yields better payoffs over multiple rounds.
- The threshold (tolerate only one defector) balances robustness and willingness to cooperate with most players, recognizing that single defections may occur but group cooperation is still viable.

---

## Limitations & Extensions (optional)

- Could tune threshold T for sensitivity (e.g., tolerate more defectors if needed).
- Could include memory beyond 1 round to detect persistent defectors.
- Could attempt reputation building, but not possible here due to lack of direct signaling.

---

This strategy aligns clearly with a cooperative mindset while rationally defending against free-riding and preserving incentives to cooperate across repeated rounds.
'''

description_COOPERATIVE_77 = '''
Here is a cooperative strategy tailored for the given N-player Public Goods Game, designed to promote cooperation and to be resilient yet forgiving of defections, given the constraints and assumptions:

---

## Strategy Name: **Gradual Reciprocity with Optimistic Start**

### 1. Intuition and goals
- **Optimistic start:** Begin by cooperating to signal willingness to cooperate and establish mutual cooperation if others reciprocate.
- **Reciprocal:** Match collective cooperation levels from previous rounds, punishing defections but allowing recovery.
- **Gradual punishment:** Only reduce cooperation if others defect, avoiding harsh or immediate retaliation to prevent downward spirals.
- **Endgame consideration:** Anticipate defection tendency near last rounds, but also attempt to sustain cooperation for as long as possible.
- **Consistent and simple:** Rules rely only on publicly observed actions, no private signals or assumptions about intentions.

---

### 2. Detailed Decision Rules

Let:

- `t` = current round (1 ≤ t ≤ r)
- For each past round `s < t`, let `C_s` = number of cooperators (players who played C).
- Let `C_avg` = average number of cooperators in previous rounds = (Sum of C_s for s=1..t-1) / (t-1), or undefined if t=1.
- Let `n` = total number of players.

**Round 1 (t=1):**  
- Cooperate (C). Start optimistically to encourage collective cooperation.

**Rounds 2 to r-1 (2 ≤ t ≤ r-1):**  
- Calculate `C_avg` over all previous rounds.
- Define a cooperation threshold for this round:  
  `threshold = (n/2)`, meaning half the group cooperating is a baseline for rewarding cooperation.
- Decision:  
  - If `C_avg ≥ threshold`, cooperate (C).
  - Else defect (D).

**Round r (last round):**  
- Defect (D). Since there is no future punishment, standard game theory predicts defection in the last round; defect to maximize private payoff.

---

### 3. Explanation and rationale

- **Round 1 cooperate:** This signals willingness to cooperate without prior evidence, seeding potential trust.
- **Reciprocity based on average cooperation in prior rounds:** The strategy promotes cooperation if others cooperated on average. If cooperation has been low, it reduces contribution to avoid exploitation.
- **Threshold at half the players cooperating:** This is a moderate standard to expect cooperation from at least half the group before cooperating again, balancing optimism and caution.
- **Last round defect:** Rational backward induction predicts defection in the last round as there is no future to enforce cooperation.
- This approach balances **optimism**, **reciprocity**, and **rational endgame reasoning** to promote cooperation in a self-interested setting.

---

### 4. Pseudocode

```python
# Inputs:
# history: list of length t-1; each element is a list of length n of actions ['C' or 'D']

def decide_action(t, r, n, history):
    if t == 1:
        # Start by cooperating
        return 'C'
    
    if t == r:
        # Last round defect
        return 'D'
    
    # Calculate average number of cooperators in previous rounds
    total_cooperators = 0
    for round_actions in history:
        total_cooperators += round_actions.count('C')
    C_avg = total_cooperators / (t - 1)
    
    threshold = n / 2  # cooperate if at least half cooperated on average
    
    if C_avg >= threshold:
        return 'C'
    else:
        return 'D'
```

---

### 5. Edge cases handling

- **First round:** No history; always cooperate.
- **Rounds with 0 cooperation previously:** Defect to avoid exploitation.
- **If exactly at threshold:** Cooperate to favor cooperation.
- **Last round:** Always defect.
- **If all defect:** eventually defect; if cooperation resumes, switch back.

---

### 6. Cooperative alignment

- Encourages mutual cooperation whenever the group cooperated substantially last rounds.
- Forgiving enough to resume cooperation if others return to cooperating.
- Punishes persistent defections by defecting.
- Avoids being exploited by free riders.
- Rationally defects last round, which prevents immediate exploitation in the final stage but encourages maximal cooperation beforehand.

---

This strategy should yield good returns in tournaments against a wide range of strategies, fostering cooperation in earlier rounds while guarding against exploitation.
'''

description_COOPERATIVE_78 = '''
Below is a detailed **cooperative strategy** design for the repeated N-Player Public Goods Game described. The strategy aims to sustain cooperation by rewarding cooperation and punishing defection proportionally, while handling edge cases and reflecting a cooperative mindset.

---

## 1. Intuition Behind the Strategy

- Cooperation among players yields a collectively higher payoff (if many cooperate, each gets a payoff > 1), but unilateral defection yields a short-term gain.
- Since the game is repeated and actions are observed, the strategy uses **conditional cooperation**:
  - Start by cooperating (default is cooperate).
  - Continue cooperating if the majority cooperated in the previous round.
  - Defect to punish defection but **forgives** after a punishment round and returns to cooperation if cooperation resumes.
- The strategy "rewards" cooperation and "punishes" defectors in a way that attempts to sustain cooperation without excessive retaliation.
- In the last round, there is an incentive to defect ("endgame effect"). This strategy softens that by cooperating in the last round if cooperation has been stable; otherwise defects.

---

## 2. Detailed Decision Rules

Let:
- `t` = current round (1 ≤ t ≤ r)
- `History[t-1]` = actions of all players in previous rounds
- `my_action[t]` = action chosen by this player in round t
- `cooperators[t-1]` = number (or fraction) of cooperators in round t-1 excluding this player
- `threshold` = cooperation threshold to consider “enough” cooperation by others (e.g., majority)

**Parameters:**
- `threshold = ceil(n/2)` (majority of players cooperating in previous round counts as cooperative environment)
- `punishment_duration = 1` (punish for 1 round if defectors observed)
- `punishment_flag = False` (internal state indicating “in punishment phase”)

---

### Round 1 (t = 1)

- No prior history.
- Action: **Cooperate**.

---

### General rule for rounds 2 to r-1

**1. Check previous round cooperation level:**

- Count how many players cooperated in round t-1 (including self).
- If the number of cooperators (including self) is ≥ threshold (i.e. majority cooperated last round), then:
  - If currently in punishment phase, **forgive** and exit punishment phase, **play Cooperate**.
  - Else **play Cooperate** (continue cooperation).
- Else (if fewer than majority cooperated last round):
  - Enter punishment phase: **Defect** for this round.
  - Set `punishment_flag = True`.

---

### Last round (t = r)

- If we have seen cooperative majority in round r-1, **Cooperate** (reward cooperation until the end).
- Else **Defect** (no incentive to risk cooperating without assurance of reciprocation).

---

## 3. Summary Pseudocode

```python
initialize punishment_flag = False

for t in 1 to r:
    if t == 1:
        action = 'C'  # Start Cooperating
        punishment_flag = False
    
    elif t < r:
        # Count cooperators in previous round (round t-1)
        prev_coops = count_cooperators(round=t-1)  # includes self's previous action
        
        if prev_coops >= ceil(n/2):  # majority cooperated last round
            action = 'C'
            punishment_flag = False  # Forgive and reset punishment
        
        else:
            action = 'D'
            punishment_flag = True  # Enter punishment phase
    
    else:  # t == r (last round)
        prev_coops = count_cooperators(round=r-1)
        
        if prev_coops >= ceil(n/2):
            action = 'C'  # Reward cooperation to the end
        
        else:
            action = 'D'  # Defect if cooperation collapsed previously
```

---

## 4. Explanation and Cooperative Alignment

- **First round cooperation:** Signals willingness to cooperate.
- **Majority-based conditional cooperation:** Requires a “social norm” of majority cooperation to continue cooperating.
- **Punishment:** Defects for one round only if cooperation fails; this proportionate response discourages persistent defection.
- **Forgiveness:** Returns to cooperation immediately once majority cooperation observed.
- **Last round cooperation:** Attempts to preserve maximal joint payoffs rather than default defect due to backward induction.
- **No assumption of coordination:** Uses only public history of actions; no signaling or communication.
- **Robust to noise or occasional defection:** One defection round triggers punishment but cooperation can resume quickly.
  
This strategy balances **incentive compatibility** and **cooperation sustainability** in a simultaneous N-player repeated public goods game without explicit communication or binding agreements.

---

If you want, I can help you formalize it further or adjust parameters like the threshold or punishment duration.
'''

description_COOPERATIVE_79 = '''
Below is a cooperative strategy designed for the N-Player Public Goods Game described. It aims to sustain cooperation, punish defection, and try to re-establish cooperation given the repeated and public nature of the game.

---

## Cooperative Strategy: "Reciprocal Forgiving Cooperation"

### Intuition

- The best outcome for everyone is all cooperate → payoff = k > 1.
- Defection gives short-term gain but reduces total payoff.
- Cooperation is fragile if players defect.
- We want to encourage cooperation but punish defection to discourage free-riding.
- Since the last round is known, defection is inevitable there (backward induction), so cooperate until the second-to-last round.
- We forgive occasional defections to prevent permanent breakdown.

### Decision Rules

| Round           | Decision rule                                                                                  |
|-----------------|------------------------------------------------------------------------------------------------|
| **Round 1**     | Cooperate (start with trust to establish cooperation).                                        |
| **Rounds 2 to r-1** | Cooperate if all players cooperated in previous round <br>Else defect once as punishment, then forgive. |
| **Round r**     | Defect (last round - no future incentive to cooperate).                                       |

### Formal Description

- Maintain a variable `punish` which records if punishment is active.
- If `punish` is active, defect once, then reset `punish = false`.
- If no one defected last round, cooperate.
- If any player defected last round, set `punish = true`.

---

### Pseudocode

```python
# Inputs:
# history: list of rounds played so far, each round is a list of actions ['C' or 'D'] by players i=1..n
# my_index: index of this player (1-based)
# n: number of players
# r: total rounds

def cooperative_strategy(history, my_index, n, r):
    # Initialization
    punish = False  # track if in punishment phase
    
    current_round = len(history) + 1
    
    # First round: Cooperate
    if current_round == 1:
        return 'C'
    
    # Last round: Defect
    if current_round == r:
        return 'D'
    
    # Check last round actions
    last_round = history[-1]
    
    # Detect if any defection last round
    any_defected = any(a == 'D' for a in last_round)
    
    # If currently punishing, defect once then forgive
    if punish:
        punish = False
        return 'D'
    
    # If any player defected last round, trigger punishment next round
    if any_defected:
        punish = True
        # Cooperate this round to let punishment happen next round
        return 'C'
    
    # Otherwise cooperate
    return 'C'
```

### Notes

- The variable `punish` needs statefulness beyond a single function call:
  - In a real implementation, store `punish` in player state.
- Implementation detail: one can alternatively use the history to infer if we are punishing.
- The essential pattern: **Cooperate as long as no defections, else defect once to punish, then return to cooperate**.
  
---

### Why this strategy is cooperative and effective?

- Starts by trusting cooperation.
- Only defects to punish when defections happen (to deter exploitation).
- Forgives immediately after punishing, preventing endless retaliation cycles.
- Defects on the last round where cooperation is fruitless (standard for finitely repeated games).
- Aims to maximize joint payoff along the way.

---

### Edge Cases Handled

- **Round 1 (no history):** Cooperate to seed cooperation.
- **Last round:** Defect to avoid being exploited (standard backward induction).
- **Single defection:** Punish once, then forgive to restore cooperation rapidly.
- **Multiple defections:** Punishment rounds repeat but always try to return to cooperation.
- **All cooperate:** Remain cooperating every round → payoff = k.

---

## Summary

| Round            | Action                                      |
|------------------|---------------------------------------------|
| 1                | Cooperate                                   |
| 2 to r-1         | If last round fully cooperative, cooperate; else defect once as punishment then forgive |
| r (last round)   | Defect                                      |

This strategy leverages reciprocity with forgiveness, seeding and maintaining cooperation while deterring exploitation in a repeated, public, simultaneous-move public goods game.
'''

description_COOPERATIVE_80 = '''
Here is a well-rounded cooperative strategy for the specified N-Player Public Goods Game, designed to foster cooperation when possible but also to guard against exploitation. It makes no assumptions about opponents beyond the observed history.

---

## Strategy Overview

The strategy can be described as a **conditional cooperator with forgiveness and endgame defection**. It attempts to maintain cooperation by cooperating if others are cooperating but punishes defections by defecting in the next round. It forgives occasional defections to prevent endless cycles of retaliation. In the last round, it defects to avoid being exploited when no future punishment is possible.

---

## Detailed Decision Rules

Let:

- `t` = current round (1 ≤ t ≤ r)
- `history` = full action history of all players from round 1 to t-1
- `n` = number of players
- `threshold` = cooperation threshold ratio (e.g., 0.8 to allow some forgiveness)

### Initial Round (t = 1)

- Cooperate (C)
- Rationale: Start by signaling willingness to cooperate.

### Intermediate Rounds (1 < t < r)

- Compute the **cooperation rate** of other players in the previous round:
  
  \[
  \text{coop_rate}_{t-1} = \frac{\#\text{players who played C at } t-1 \text{ excluding self}}{n-1}
  \]

- Decision rule:
  
  - If `coop_rate_{t-1} ≥ threshold`, **cooperate (C)**
    
    - Indicates sufficient cooperation from others; continue cooperating.
  
  - Else, **defect (D)**
    
    - Punish defection by others by defecting once.

- Additional forgiveness:
  
  - If in round `t-2`, you defected and now the others cooperate again at `t-1` above threshold, resume cooperation.

### Last Round (t = r)

- Defect (D)
- Rationale: No future rounds to incentivize cooperation, so defect to avoid exploitation.

---

## Pseudocode

```python
def decide_action(t, r, n, history, threshold=0.8):
    # history: list of length t-1,
    # each element is list of length n with 'C' or 'D' actions
    
    if t == 1:
        # First round: cooperate
        return 'C'
    
    if t == r:
        # Last round: defect
        return 'D'
    
    # Count cooperators at previous round excluding self
    prev_round = history[t-2]  # 0-based indexing
    own_action_prev = prev_round[player_index]  # player_index is our index 0-based
    
    coop_others = sum(1 for i, a in enumerate(prev_round) if i != player_index and a == 'C')
    coop_rate = coop_others / (n - 1)
    
    if coop_rate >= threshold:
        return 'C'  # Cooperate if most others cooperated last round
    
    else:
        # Punish defectors but forgive one round if they return to cooperation
        # Check if we defected last round to avoid endless retaliation
        if t > 2:
            prev_prev_round = history[t-3]
            if prev_prev_round[player_index] == 'D' and coop_rate >= threshold:
                # Forgive now, cooperate
                return 'C'
        return 'D'  # Defect to punish
```

---

## Intuition and Rationale

- **Cooperate first:** Signals intent to build trust.
- **Conditional cooperation:** Only cooperate if others mostly cooperated last round to maintain collective benefit.
- **Punishment:** Defect if cooperation is low to discourage free-riding.
- **Forgiveness:** Allows recovery from occasional defections to prevent prolonged mutual defection.
- **Last round defect:** Avoid being exploited since no future punishment possible.

---

## Edge Cases and Clarifications

- If all defect first round, will defect second round as well, but may return to cooperation if others do cooperate.
- The threshold can be tuned (e.g., 0.7–0.9) for tolerance; 0.8 is a middle ground.
- If multiple players use similar conditional cooperation, the strategy can sustain high cooperation.
- Perfect monitoring ensures actions are known, so these decisions are based on clear data.
- No reliance on communication or coordination devices to keep consistent with game assumptions.

---

This strategy balances cooperation incentives with safeguards against exploitation and incorporates well-understood principles from repeated public goods and Prisoner’s Dilemma games. It is simple, transparent, and aligns with the cooperative mindset the game encourages.
'''

description_COOPERATIVE_81 = '''
**Cooperative Strategy for the N-Player Public Goods Game**  
*(Designed to foster cooperation, punish defection, but also re-establish cooperation if others do)*

---

### Intuition and Goals

- Achieve high group payoffs by mostly cooperating.
- Retaliate against defectors to discourage exploitation.
- Forgive after punishment, allowing cooperation to resume.
- Be cautious in the last round(s) due to backward induction issues.

---

### Strategy Summary

Name: **"Forgiving Trigger with Endgame Adjustment"**  

---

### Decision Rules

**Notation:**  
- Let t ∈ {1,...,r} be the current round number.  
- Let History[t-1] be the full action profile of all players in round t-1 (empty if t=1).  
- Let coop_frac[t-1] = (sum of players who cooperated in round t-1) / n  
- Let d_t be the decision at round t for this strategy.

**Parameters:**  
- Forgiveness threshold: slightly less than full cooperation (e.g., ≥ 90% cooperation in previous round)  
- Endgame window: last 1 round (round r), or optionally last 2 rounds depending on r  

---

### Pseudocode:

```
for each round t in 1 to r:

    if t == 1:
        # Start by cooperating to signal goodwill
        d_t = C

    else if t == r:
        # Last round - defect to avoid exploitation
        d_t = D

    else:
        coop_fraction = (number of cooperators in round t-1) / n

        if coop_fraction >= 0.9:
            # Most players cooperated last round
            # Cooperate as they generally cooperate
            d_t = C

        else:
            # Significant defection detected last round
            # Punish defectors by defecting this round
            d_t = D

            # After punishing, test for return to cooperation next round
            # (See note below)

# Additional logic for attempting return to cooperation:
# If this round was punishment round (d_t == D due to defection last round),
# then in next round (if t < r), try cooperating again to see if others return.
```

---

### Explanation

**Round 1:** Cooperate  
- Initiate cooperation unconditionally to start with high trust.

**Intermediate rounds (2 to r-1):**  
- Observe how many cooperated in previous round.  
- If >90% cooperated, match cooperation to maintain the public good.  
- If many defected (>10% defectors), punish by defecting once.  
- After punishing, *attempt forgiveness* by returning to cooperation next round regardless of immediate past defection, encouraging re-establishment if others respond positively.

**Last round (round r):** Defect  
- Backward induction anticipates no future punishment, so defect to maximize personal gain.

---

### Handling Edge Cases

- **If all defected last round:** Defect this round to punish; then attempt cooperation to test if others are willing.  
- **If some defectors are persistent:** Keep defecting if defection maintains; but forgive when cooperation resumes from >90% cooperators.  
- **If r = 2 (minimum multiple rounds):** Cooperate round 1, defect round 2.  
- **If very high defections consistently:** Strategy falls back to mostly defecting but always tests cooperation to prevent permanent breakdown.

---

### Why This Strategy Is Cooperative?

- It prioritizes cooperation whenever the group mostly cooperates.  
- It punishes defectors but only temporarily.  
- It uses forgiveness to avoid permanent mutual defection traps.  
- It recognizes endgame problems and defects at the last round to avoid being exploited.  
- It relies only on observable history and adheres to common knowledge, no assumptions beyond game rules.

---

### Optional refinement: Softening punishment duration

- Can extend punishment to 2 rounds if defectors persist, but evaluating history at each round keeps it adaptive.

---

**In summary:**  
This strategy is a **"Forgiving Trigger"** that cooperates initially, punishes defection briefly, then forgives to reinstate cooperation, but defects in the final round recognizing the endgame incentives. This balances cooperation and strategic self-interest aligned with the public goods nature of the game.
'''

description_COOPERATIVE_82 = '''
Below is a cooperative strategy for the repeated N-Player Public Goods Game defined above. It is inspired by the principle of conditional cooperation, using a simple and transparent trigger to sustain cooperation.

---

## Strategy Name: **"Conditional Grim-Trigger Cooperate"**

### Intuition:
- Start fully cooperative to maximize group payoff.
- Continue cooperating as long as everyone cooperated previously (no defections).
- If any defection is observed in the previous round, switch to defecting forever as punishment.
- This creates strong disincentives to defect, supporting sustained cooperation.
- The strategy is fully cooperative until provoked.
- In the last round, defect because no future punishment is possible (standard backward induction).

---

### Decision Rules

Let:
- **t** = current round number, 1 ≤ t ≤ r
- **history** = matrix of all players' past actions, dimensions: (rounds played) × n
- **my_index** = player’s own index i

---

**At round t:**

1. **First round (t = 1):**
   - Cooperate (play C) unconditionally.

2. **Rounds 2 to r-1 (1 < t < r):**
   - Check previous round (t-1) actions of all players.
   - If *all* players cooperated at (t-1), cooperate at t.
   - Else (if any defection detected at t-1), defect at t forever.

3. **Last round (t = r):**
   - Defect unconditionally (no incentive to cooperate since no future punishment).

---

### Pseudocode

```python
function decide_action(t, r, history, my_index):

    if t == 1:
        # First round: cooperate unconditionally
        return 'C'

    elif t == r:
        # Last round: defect unconditionally
        return 'D'

    else:
        # Check previous round for defections
        previous_round = history[t-2]  # zero-based index; previous round's actions

        if all(action == 'C' for action in previous_round):
            # Everyone cooperated last round: cooperate
            return 'C'
        else:
            # Someone defected last round: defect as punishment
            return 'D'
```

---

### Strategy Explanation

- **Cooperation is the default starting point**—this maximizes collective payoff.
- **Monitoring all players’ behaviour after each round:** Defection by anyone triggers permanent punishment.
- The punishment phase is strict and unforgiving to maintain deterrence (a "grim trigger").
- **Defecting in the last round** is standard since there's no future to punish or be punished.
- Since the multiplication factor \(k\) satisfies \(1 < k < n\), cooperation yields higher social payoff than pure defection.
- This strategy aligns with collective welfare—creatively punishing defectors without compromising cooperation if all players are cooperative.

---

### Edge Cases:

- **If any defection occurs in the first round:** immediate switch to permanent defection for subsequent rounds.
- **If all behave cooperatively for all rounds (except last round):** mutual cooperation payoff maximized.
- **No forgiveness once defected:** simple and clear, preventing complicated probabilistic guesswork in the absence of communication.
- **Single defector ruins cooperation:** reasonable given no communication or coordination devices exist.
- **If multiple players defect simultaneously:** the punishment triggers similarly.

---

### Summary:

| Round         | Action                                                     |
|---------------|------------------------------------------------------------|
| 1             | Cooperate                                                 |
| 2 to r-1      | Cooperate if all cooperated in previous round; else defect |
| r (last round)| Defect                                                    |

---

This strategy is cooperative by design, supports mutual cooperation under rational expectations, and punishes deviations to sustain cooperation over multiple rounds.
'''

description_COOPERATIVE_83 = '''
**Cooperative Strategy: “Conditional Cooperation with Forgiveness”**

---

### Overview

The strategy’s core principle is to mutually sustain cooperation among players to maximize collective payoffs, aligned with the public goods nature of the game. It is conditional cooperation: cooperate initially and continue cooperating as long as others do, but respond to defections to discourage free-riding. To prevent breakdown from occasional mistakes, the strategy includes measured forgiveness, i.e., temporary forgiveness after defections before permanently defecting.

---

### Intuition

- **Start by cooperating** to build trust and realize high group payoff.
- **Monitor others’ past behavior** each round.
- **Continue cooperating if everyone cooperated previously** (or if defections were isolated or forgiven).
- **Defect only as a short-term punishment** when others defect frequently.
- **Forgive occasional defections** to maintain cooperation and avoid spirals of mutual defection.
- **In the last round, defect to avoid exploitation**, since future repercussions do not exist (backward induction).

---

### Notation

- `t`: current round (1 to r)
- `A_j^t`: action of player j in round t, where C=1, D=0
- `Defectors_t = {j | A_j^t = D}`: set of defectors in round t
- `history`: record of all players’ actions in all previous rounds

---

### Strategy Details

---

#### Round 1 (Initial Round)

- Cooperate.
  
  **Reason:** No prior information to trustworthiness; cooperation maximizes collective payoff.

---

#### Intermediate Rounds (2 ≤ t < r)

- **Step 1: Check previous round behavior (t-1):**
  - If *all* other players cooperated in round t-1, **cooperate**.
  - Else (some defectors in t-1), check history for forgiveness condition:
  
- **Step 2: Forgiveness logic:**
  - Maintain a *defection count* for each player over all rounds so far.
  - Define a threshold `T` for tolerated defections (e.g., `T = 1` or `2` defections).
  
- **Step 3: Decision on cooperation or defection:**
  - If any player’s cumulative defections > T, **defect** as punishment.
  - Else, **cooperate** to indicate forgiveness and willingness to restore cooperation.
  
---

#### Last Round (t = r)

- Defect regardless.
  
  **Reason:** Incentives to cooperate break down by backward induction; no future rounds to punish defections.

---

### Summary of Decision Rule

```
If t == 1:
    Play C (cooperate)

Else if t < r:
    If all other players cooperated in round t-1:
        Play C
    
    Else:
        For each player j≠i, count how many times j defected so far (1..t-1)
        If any j defected more than T times:
            Play D
        Else:
            Play C

Else if t == r:
    Play D
```

---

### Parameters and Notes

- Defection tolerance threshold `T`: 

  A small integer (e.g., 1 or 2) to allow for rare mistakes or experimentation without triggering endless punishment.

- This strategy:

  - Encourages **mutual cooperation** for as long as possible.
  - Implements **punishment** only if others consistently defect.
  - Allows **forgiveness** to prevent permanent mutual defection triggered by accidental or isolated defections.
  - Exploits knowledge of the final round to avoid being exploited.

---

### Pseudocode

```python
def cooperative_strategy(t, r, history, player_index, T=1):
    # t: current round number (1-based)
    # r: total rounds
    # history: list of action lists per round, history[round-1][player_index] in {C,D}
    # player_index: index of current player (0-based)
    # T: tolerated defection count before punishing
    
    C = 'C'
    D = 'D'
    
    if t == 1:
        return C  # Cooperate first round
    
    if t == r:
        return D  # Defect last round
    
    # Check if all other players cooperated last round
    last_round_actions = history[t-2]  # since t is 1-based
    others_last_round = [last_round_actions[j] for j in range(len(last_round_actions)) if j != player_index]
    
    if all(a == C for a in others_last_round):
        return C  # cooperate if all cooperated last round
    
    # Count total defections of other players so far
    defect_counts = [0] * len(last_round_actions)
    for round_actions in history[:t-1]:
        for j, action in enumerate(round_actions):
            if action == D:
                defect_counts[j] += 1
    
    # Check if any player (other than self) exceeded T defections
    for j in range(len(last_round_actions)):
        if j != player_index and defect_counts[j] > T:
            return D  # punish by defecting
    
    # Otherwise forgive and continue cooperating
    return C
```

---

### Final Remarks

This strategy:

- Maximizes collective payoffs by sustaining cooperation.
- Balances punishment and forgiveness to adapt to behavior.
- Utilizes full knowledge of game history, actions, parameters.
- Accounts for strategic incentives in the final round to avoid exploitation.
- Is robust against one or few defections, but punishes defectors who persist.

It thus aligns well with the cooperative mindset required for this repeated public goods game.
'''

description_COOPERATIVE_84 = '''
Here is a detailed cooperative strategy designed for the N-Player Public Goods Game under the constraints and assumptions provided.

---

### Strategy Name: **Forgiving Conditional Cooperation**

#### Goal:
Maximize own payoff over r rounds by fostering mutual cooperation while being robust to occasional defections or noise. Aim for cooperation as the socially optimal outcome, punishing defectors proportionally but forgiving quickly to restore cooperation.

---

### 1. Decision Rules

Each round \( t \in \{1, 2, \ldots, r\} \), decide action \( a_i^t \in \{C, D\} \) as follows:

- **Round 1: Cooperate**
    - Start by cooperating to signal willingness to build trust and establish cooperation baseline.

- **Rounds 2 to r-1: Conditional Cooperation by Majority**
    - Observe *all* players' actions in previous round \( t-1 \).
    - Compute:
      \[
      M^{t-1} = \text{number of cooperators in round } t-1
      \]
    - Compare \( M^{t-1} \) to threshold \( T = \lceil \frac{n}{2} \rceil \) (majority cooperation).
    - If \( M^{t-1} \geq T \), cooperate this round.
      - **Interpretation**: Most players cooperated last round → good to trust and cooperate.
    - Else defect this round.
      - **Interpretation**: Less than majority cooperated last round → defect as punishment or protective measure.

- **Last Round \( t = r \): Defect**
    - Rational backward induction dictates defection in the last round since no future reward possible.
    - Defect to maximize immediate payoff.

---

### 2. Handling Edge Cases

- **First Round:** No history available, so cooperate to initiate cooperation.

- **Last Round:** Defect, because cooperation cannot be enforced or rewarded afterward.

- **Intermediate Rounds with Equal Split:**  
  If exactly half cooperated (if n even and \( M^{t-1} = \frac{n}{2} \)), cooperate anyway.
  
  This is optimistic but promotes cooperation where possible.

- **If Everyone Defected Last Round:**
  Since \( M^{t-1} = 0 < T \), defect.

- **If Everyone Cooperated Last Round:**
  Full cooperation so cooperate.

- **Responding to Mixed Cooperation:**
  If at least majority cooperated, cooperate to reinforce cooperation.

- **Noise or Accidental Defection:**
  The strategy is forgiving because only one defection causing less than majority will trigger a punishment round, but if cooperation resumes, it will immediately respond by cooperating in the next round.

---

### 3. Cooperative Alignment Rationale

- Encourages cooperation by cooperating initially.
- Promotes mutual cooperation by responding cooperatively when majority of others cooperated.
- Punishes defection only when cooperation breaks down broadly (less than majority cooperated last round).
- Forgives quickly by switching back to cooperation if majority returns.
- Recognizes rationality of defection in final round to prevent exploitation.
- Does not rely on communication or coordination devices beyond observed actions.
- Uses simple, interpretable heuristic readily computed given perfect information.

---

### Pseudocode

```python
def decide_action(round_t, history, n, r):
    # history: List of past rounds' actions for all players:
    # history[t-1] = list of length n with C or D for each player
    
    # Round 1: Cooperate
    if round_t == 1:
        return 'C'
    
    # Last Round: Defect
    if round_t == r:
        return 'D'
    
    # For rounds 2 to r-1:
    last_round_actions = history[round_t - 2]  # zero-index adjustment
    coop_count = sum(1 for action in last_round_actions if action == 'C')
    
    threshold = (n + 1) // 2  # majority
    
    if coop_count >= threshold:
        return 'C'
    else:
        return 'D'
```

---

### Summary

This **Forgiving Conditional Cooperation** strategy:

- Starts by cooperating to build goodwill.
- Cooperates if a majority cooperated last round.
- Defects otherwise to discourage free-riding.
- Defects in the last round to maximize payoff.
- Forgives occasional defections as soon as majority cooperation returns.
- Aligns with the best social outcome within rational, incentive-aligned behavior.

It balances cooperation incentive and defection deterrence without requiring communication or assumptions beyond the game rules and observed history.
'''

description_COOPERATIVE_85 = '''
Below is a description of a cooperative strategy designed for the repeated N-Player Public Goods Game as specified. It is inspired by the idea of “conditional cooperation” and “gradual forgiveness,” balancing cooperation incentives with punishment for defections to sustain cooperation.

---

## Strategy Name: Gradual Conditional Cooperator (GCC)

### Intuition
- Start cooperatively to encourage cooperation.
- Continue cooperating if others mostly cooperate.
- If defection is detected, defect for a limited punishment period.
- Then forgive and attempt to reestablish cooperation.
- In the last round, defect because there is no future to enforce cooperation.

---

## 1. Decision Rules

**Notation**

- Let `t` ∈ {1,...,r} be the current round.
- Let `c_j,t` ∈ {0,1} be player j’s action in round t (1 = Cooperate, 0 = Defect).
- History up to round t-1: `H_{t-1} = {c_j,s}` for s < t and j=1..n.
- Let `defection_detected` be a boolean flag indicating if enough defections have occurred to justify punishment.
- Let `punishment_rounds_left` be a counter of how many rounds we continue defecting after detecting defection.
- Let `threshold` be the tolerated fraction of defectors in the previous round before punishing (e.g., threshold = 0.2 means tolerate up to 20% defectors).
- Let `punishment_duration` be the number of rounds to defect once punishment starts (e.g., 1 or 2).
  
**Initialization**

- `defection_detected = False`
- `punishment_rounds_left = 0`
- `threshold = 0.2` (tunable parameter)
- `punishment_duration = 1` (tunable parameter)

---

### Round 1 (t=1):

- **Cooperate** (C).
  
Reason: No history to condition on; full cooperation to signal willingness to cooperate.

---

### Round 2 to r-1 (1 < t < r):

- If `punishment_rounds_left > 0`:
  - Defect (D).
  - Decrement `punishment_rounds_left` by 1.
  - If after decrement it reaches zero:
    - Reset `defection_detected = False` (forgiveness).
- Else (no ongoing punishment):
  - Compute the fraction of defectors in previous round:

    ```
    frac_defect = (number of defectors in round t-1) / n
    ```
  
  - If `frac_defect > threshold`:
    - Set `defection_detected = True`
    - Set `punishment_rounds_left = punishment_duration`
    - Defect (D) this round (start punishment)
  - Else:
    - Cooperate (C)

---

### Round r (last round):

- Defect (D)
  
Reason: Standard game theory logic—no future rounds to enforce cooperation, defecting maximizes last-round payoff.

---

## 2. Edge Case Handling

- **First round:** No history, fully cooperative to establish cooperation.
- **Last round:** Defect to maximize payoff as future enforcement is impossible.
- **Continuous defection by others:** If opponents keep defecting above threshold, will keep punishing in blocks of `punishment_duration`, always returning to cooperation afterward in attempt to re-establish cooperation.
- **Small punishments:** Only a short punishment period to avoid long-term mutual defection.
- **Threshold and punishment_duration parameters:**
  - Tuned to balance tolerance and deterrence.
  - Threshold too low → over-punishment; too high → too lenient.
  - Punishment duration too long → harsh, risks cycles of punishment; too short → weak deterrent.

---

## 3. Cooperation Alignment

This strategy:

- Starts fully cooperative.
- Cooperates whenever others mostly cooperate.
- Punishes defections to discourage exploitation.
- Forgives quickly to allow mutual cooperation to resume.
- Defects only in the last round out of rational backward induction.
  
It aligns with the spirit of cooperation by rewarding cooperation and punishing defections, but no permanent grudges or unforgiving retaliation. It acknowledges the complexity of multiple players by using an aggregate defection measure.

---

## Pseudocode

```python
initialize:
  defection_detected = False
  punishment_rounds_left = 0
  threshold = 0.2          # Tolerate up to 20% defectors
  punishment_duration = 1  # Punish for 1 round

function decide_action(round t, history H):

  if t == 1:
    # No history yet: cooperate
    return 'C'

  else if t == r:
    # Last round: defect
    return 'D'

  else:
    if punishment_rounds_left > 0:
      punishment_rounds_left -= 1
      if punishment_rounds_left == 0:
        defection_detected = False  # Forgive after punishment ends
      return 'D'

    else:
      # Analyze last round
      last_round_actions = [c_j,t-1 for j in 1..n]
      num_defectors = count where c_j == 'D' in last_round_actions
      frac_defect = num_defectors / n

      if frac_defect > threshold:
        defection_detected = True
        punishment_rounds_left = punishment_duration - 1 # Punish this round plus next (if duration >1)
        return 'D'
      else:
        return 'C'
```

---

# Summary

- **Round 1:** Cooperate.
- **Round r:** Defect.
- **Round 2..r-1:** Cooperate if previous round had ≤ threshold defectors; otherwise punish by defecting for `punishment_duration` rounds then forgive.
- Designed to sustain cooperation, punish defectors without permanent hostility, and end with a rational last-round defection.

---

If you want, I can help tune the parameters or adapt for specific tournament considerations.
'''

description_COOPERATIVE_86 = '''
Below is a cooperative strategy designed for the repeated N-player Public Goods Game as specified. It aims to foster cooperation while guarding against exploitation and handles edge cases systematically.

---

## Strategy Overview: "Reciprocal Conditional Cooperation with Gradual Forgiveness"

### Goal
- Achieve and maintain full cooperation (all contribute) to maximize payoffs.
- Punish defection by defecting cautiously to discourage free-riding.
- Forgive occasional defections to re-establish cooperation.
- Defect in the final round because cooperation cannot be reciprocated beyond it.

---

## Decision Rules

Let:
- \( t \) = current round (1-based)
- \( r \) = total rounds
- History up to round \( t-1 \) of all players' actions known.
- \( C_{t-1} \) = set of players who cooperated in round \( t-1 \)
- \( n \) = total number of players

### Round 1 (First round)
- Cooperate unconditionally.
  
Rationale: Signal willingness to cooperate; no history yet.

### Intermediate rounds (2 ≤ t < r)

- **If in previous round (t-1), all players cooperated:**
  - Cooperate.

- **Else (some defectors in round t-1):**
  - If **I cooperated** in round \( t-1 \) but some others defected:
    - Defect in round \( t \) (punish defection).
  
  - If **I defected** in \( t-1 \) (possibly punishing last round):
    - Cooperate in \( t \) if the majority of players cooperated in \( t-1 \) (e.g., at least \( \lceil n/2 \rceil \) players cooperated).
    - Else defect again to continue punishing.

- **This rule creates a "punish defectors once, then attempt to return to cooperation" cycle**, promoting cooperation but deterring exploitation.

### Final round (t = r)
- Defect unconditionally.

Rationale: No future rounds to incentivize cooperation; standard backward induction applies.

---

## Edge Case Summary

| Round | Condition                             | Action      | Explanation                           |
|-------|-------------------------------------|-------------|------------------------------------|
| 1     | No history                          | Cooperate   | Signal cooperative intent           |
| t<r   | All cooperated in t-1               | Cooperate   | Maintain cooperation                |
| t<r   | Someone defected in t-1 and I cooperated  | Defect      | Punish defectors                    |
| t<r   | Someone defected in t-1 and I defected     | Cooperate if majority cooperated in t-1, else defect | Forgive if others mostly cooperative, else keep punishing |
| r     | Final round                        | Defect      | Defection maximizes immediate payoff |

---

## Pseudocode

```python
def decide_action(t, r, n, history):
    """
    t: current round (1-based)
    r: total rounds
    n: total players
    history: list of length t-1, each element is list of length n with actions 'C' or 'D'
           history[tau][i]: action of player i in round tau+1 (0-based index)
    Returns: 'C' or 'D' for current action
    """

    # First round
    if t == 1:
        return 'C'

    # Last round
    if t == r:
        return 'D'

    # Get previous round actions
    prev_round = history[t - 2]  # zero-based index
    total_cooperators = prev_round.count('C')
    majority_cooperated = total_cooperators >= (n + 1) // 2  # ceiling of n/2

    my_prev_action = prev_round[player_index]  # player_index is this agent's index 0-based

    # If all cooperated last round, cooperate
    if total_cooperators == n:
        return 'C'

    # Else, defect if cooperated last round (punish defectors)
    if my_prev_action == 'C':
        return 'D'

    # If defected last round:
    # Forgive (cooperate) if majority cooperated last round, else keep defecting
    if my_prev_action == 'D':
        if majority_cooperated:
            return 'C'
        else:
            return 'D'
```

---

## Rationale

- **First round cooperation** sets a foundation for mutual cooperation.
- **Punishment of defection** deters free riders by lowering their payoff in subsequent rounds.
- **Forgiveness after majority cooperation** allows repair of cooperation following mistakes or exploration.
- **Defecting in the final round** avoids exploitation due to the end-of-game backward induction problem.
- The strategy is **purely reactive and history-dependent** with no unrealistic assumptions about communication or coordination beyond observing actions.
- It aligns strongly with cooperation but is robust to exploitation attempts.

---

## Expected Behavior

- If all players use this strategy, all cooperate rounds 1 to \(r-1\), then defect on round \(r\), maximizing collective payoff until the last round.
- If some defectors appear, cooperation breaks temporarily but can re-establish.
- Defectors receive punishment reducing their total payoff relative to cooperators.
- This structure encourages convergence to cooperative equilibrium.

---

Feel free to request an expanded analysis or alternative variants!
'''

description_COOPERATIVE_87 = '''
**Cooperative Strategy for N-Player Public Goods Game**

---

### Intuition & Goal

The game is a repeated public goods game with simultaneous moves where cooperation maximizes joint payoffs: all cooperating yields π_i = k > 1, better than all defecting π_i = 1. However, defecting individually in any round yields immediate advantage versus a cooperating player in that round.

A robust cooperative strategy must:

- Promote mutual cooperation for most of the game to maximize joint returns.
- Punish defections to discourage free-riding.
- Forgive once defectors return to cooperation.
- Handle first and last rounds carefully.

---

### Strategy Outline: Modified Grim with Forgiveness and Endgame Consideration

We design a strategy with these main components:

1. **Start Cooperating:** Begin by cooperating in round 1.

2. **Cooperate if No Defections Observed:** Continue cooperating if all other players cooperated in the previous round(s).

3. **Punish Defectors Briefly:** If any player defected in the previous round, punish by defecting in the current round to discourage defection.

4. **Forgive After Punishment:** Allow return to cooperation if others return to cooperation after the punishment round.

5. **Last Round Defect:** Defect in the last round (round r) to avoid exploitation, as no future rounds exist to punish.

---

### Detailed Behavior Rules

| Round | Action              | Condition                                                                                  |
|-------|---------------------|--------------------------------------------------------------------------------------------|
| 1     | Cooperate (C)       | No history, start friendly to establish cooperation                                       |
| 2 to r-1 | Cooperate (C)    | If **all players cooperated** in previous round (t-1)                                    |
| 2 to r-1 | Defect (D)       | If **any player defected** in previous round (t-1), defect to punish                      |
| r     | Defect (D)          | Last round defect since no future punishment possible                                     |

---

### Why This Strategy?

- **Starts cooperating:** Signals friendly intentions.
- **Punishment:** Defection by any player triggers one round of defection by this strategy, discouraging free riding.
- **Forgiveness:** After punishing defections, unlike grim trigger (which defects forever), this strategy returns to cooperation if others do, allowing recovery from mistakes and preventing long cycles of defection.
- **Last round defect:** Standard backward induction predicts defection in the last round, so defecting there avoids being exploited.

---

### Pseudocode

```python
def decide_action(round_t, history, n, r):
    """
    round_t : int : current round (1-based)
    history : list of tuples : each element is round action profile (list or tuple) of length n
             e.g. history[t-2][i-1] = action by player i in round t-1
    n       : int : number of players
    r       : int : total rounds
    
    Returns: 'C' or 'D'
    """
    
    # Round 1: cooperate
    if round_t == 1:
        return 'C'
    
    # Last round: defect
    if round_t == r:
        return 'D'
    
    # From round 2 to r-1:
    # Check actions in previous round
    prev_round_actions = history[round_t - 2]  # zero-indexed list
    
    # If anyone defected last round, punish by defecting
    if 'D' in prev_round_actions:
        return 'D'
    
    # Otherwise cooperate if all cooperated last round
    return 'C'
```

---

### Edge Cases

- **First Round:** No history exists, cooperate to encourage cooperation.
- **Multiple Defectors:** Punish whenever any defection detected, regardless of number of defectors.
- **Return to Cooperation:** Because punishment is only one round, if others return to cooperate, this strategy also does, enabling restoration of cooperation.
- **Last Round:** Defect regardless, preventing being exploited with no chance to punish.

---

### Cooperation Alignment

By cooperating as long as all others cooperated last round, this strategy promotes mutual cooperation, maximizing returns:

- If all cooperate every round except the last, each player earns close to k × r − 1 (slightly less for last round defection).
- The punishment prevents persistent free-riding.
- Forgiveness promotes repair of cooperation after accidental defections or brief unilateral defections by others.

---

### Summary

- **Start:** Cooperate round 1.
- **If last round:** Defect.
- **If any defection last round:** Defect this round as punishment.
- **Else:** Cooperate.

This "forgiving grim trigger with endgame defection" promotes high cooperation, deters free-riders, and adjusts to the repeated public goods dilemma’s structure.
'''

description_COOPERATIVE_88 = '''
**Cooperative Strategy: "Conditional Cooperation with Forgiveness"**

---

### 1. Overview

This strategy aims to sustain cooperation by:
- Cooperating initially to establish trust.
- Continuing to cooperate as long as no defections are observed.
- Punishing defections by defecting in the *next round*.
- Forgiving occasional defections by returning to cooperation if opponents revert to cooperating.
- Defecting in the last round, since no future punishment/cooperation is possible.

This approach balances cooperation and self-interest, aligns with the cooperative mindset, and is robust under standard repeated public goods assumptions.

---

### 2. Decision Rules

Let:
- `t` be the current round (1 ≤ t ≤ r)
- `history[t-1]` record of all players’ actions in the previous rounds 
- `others_defected_last_round` = True if any other player defected in round `t-1`, else False

**Actions at round t:**

| Condition                         | Action   | Reasoning                                        |
|----------------------------------|----------|-------------------------------------------------|
| `t = 1` (first round)             | Cooperate (C) | Start by cooperating to signal willingness to cooperate. |
| `t = r` (last round)              | Defect (D)   | No future incentives; defect to maximize private payoff. |
| `others_defected_last_round = False` | Cooperate (C) | All cooperated last round; maintain cooperation. |
| `others_defected_last_round = True`  | Defect (D)   | Punish defection once by defecting next round.  |

---

### 3. Forgiveness Mechanism

- After defecting in round `t` due to punishment, if in round `t+1` *everyone* cooperates, return to cooperating in `t+2`.
- This allows the strategy to recover cooperation even if accidental or exploratory defections occur.

---

### 4. Pseudocode

```python
# Input: 
#   t: current round number (1-indexed)
#   r: total rounds
#   n: number of players
#   history: list of length t-1; each element is list of actions by all players in that round
#           actions are 'C' or 'D'
# Output:
#   action: 'C' or 'D'

def choose_action(t, r, n, history):
    if t == 1:
        # First round: cooperate
        return 'C'

    if t == r:
        # Last round: defect to maximize payoff
        return 'D'

    # Check actions in last round
    last_round = history[-1]
    
    # Check if any other player defected last round
    # Assume own index is unknown so just check if all cooperated
    all_cooperated_last = all(a == 'C' for a in last_round)

    if all_cooperated_last:
        # Everyone cooperated last round
        return 'C'
    else:
        # Punish defectors by defecting once
        # Check if player defected in round t-1 (previous round) as punishment
        if t >= 3 and history[-2][0] == 'D':  
            # If we defected last round (t-1), check if all cooperated in t-1 to forgive
            if all(a == 'C' for a in history[-2]):
                # Return to cooperation after punishment round
                return 'C'
        return 'D'
```

*(Note: The pseudocode presumes an index of self in history is known. If not, adopt indirect logic: defect one round after detecting defections, then resume cooperation if no defections continue.)*

---

### 5. Explanation and Properties

- **Start Cooperating**: Shows good faith to encourage mutual contributions.
- **Punish Defections Once**: Defections reduce the payoff, so the strategy defects once immediately *after* observing a defection to discourage free-riding.
- **Forgiveness**: Returning to cooperation after a punishment round avoids permanent retaliation and encourages cooperation recovery.
- **Defect Last Round**: Since no future punishment or reward is possible, defecting maximizes final round payoff.
- **Public Good Maximization**: Sustained mutual cooperation yields highest long-term payoffs — the strategy seeks to support this equilibrium.

---

### 6. Handling Edge Cases

- **First round (t=1)**: Cooperate unconditionally.
- **Last round (t=r)**: Defect unconditionally (standard backward induction logic).
- **Multiple simultaneous defectors**: Punish in the next round.
- **Single accidental defection**: Punished once, then forgive if cooperation resumes.
- **No defections ever**: Continue cooperating till the last round.
- **All defect all rounds except last**: Strategy defects along after initial defection, no loss in payoff compared to others.

---

### 7. Summary

This **Conditional Cooperation with Forgiveness** strategy is a classic, robust, and well-motivated cooperative approach for the repeated public goods game under uncertainty about others’ intentions. It is simple, transparent, and aligns incentives towards cooperation while protecting itself against exploitation.
'''

description_COOPERATIVE_89 = '''
Below is a cooperative strategy tailored for the N-Player Public Goods Game as specified, designed to promote mutual cooperation, discourage exploitation, and adapt over repeated rounds.

---

## Strategy Name: Conditional Grim Trigger with Forgiveness

---

## Intuition

- **Initial Cooperation**: Start by cooperating to encourage building trust.
- **Monitor Others**: Observe everyone’s actions each round.
- **Punish Defection**: If any defection is detected, defect permanently in the next round (grim trigger).
- **Forgiveness Mechanism**: If all players cooperate again in the round following punishment, return to cooperation to resume collective benefit.
- **Final Round Defect**: Defect in the last round to avoid exploitation (standard backward induction).

---

## Detailed Description

### Variables and Observations

- History of all players' actions for rounds 1 to t-1.
- Round number t ∈ {1,...,r}.

### Decision Rules

#### Round 1:

- Cooperate (C).

#### Rounds 2 to r-1:

- Let `any_defection_last_round` = `True` if in round t-1 at least one player defected.
- Let `all_cooperation_last_round` = `True` if in round t-1 all players cooperated.

- **If I defected in round t-1 (i.e., played D last round)**:
  - If `all_cooperation_last_round` is True, **return to cooperate** (forgiveness step).
  - Else, continue defecting.

- **If I cooperated in round t-1**:
  - If `any_defection_last_round` is True, switch to defect this round (impose punishment).
  - Else, cooperate.

#### Round r (Last Round):

- Defect (D) (no incentive to cooperate if no future rounds will reward behavior).

---

## Summary Table of Behavior

| Condition                                        | Action      |
|------------------------------------------------|-------------|
| **t = 1**                                      | Cooperate   |
| **t = r (last round)**                         | Defect      |
| **t ∈ [2, r-1], I defected last round & all cooperated last round** | Cooperate   |
| **t ∈ [2, r-1], I defected last round & NOT all cooperated last round** | Defect      |
| **t ∈ [2, r-1], I cooperated last round & any player defected last round** | Defect      |
| **t ∈ [2, r-1], I cooperated last round & no one defected last round** | Cooperate   |

---

## Pseudocode

```python
def strategy(t, r, own_last_action, history_last_round_actions):
    """
    t: current round number (1-based)
    r: total rounds
    own_last_action: 'C' or 'D' from round t-1; None if t=1
    history_last_round_actions: list of length n, actions of all players in t-1; None if t=1

    Returns: 'C' or 'D'
    """

    if t == 1:
        # Always cooperate first round
        return 'C'

    # Last round defect
    if t == r:
        return 'D'

    # Analyze last round
    any_defect = ('D' in history_last_round_actions)
    all_cooperate = all(action == 'C' for action in history_last_round_actions)

    if own_last_action == 'D':
        if all_cooperate:
            # Forgive and resume cooperation
            return 'C'
        else:
            # Continue defecting to punish persistent defectors
            return 'D'
    else:  # own_last_action == 'C'
        if any_defect:
            # Punish by defecting next round
            return 'D'
        else:
            # Continue cooperating
            return 'C'
```

---

## Why This Strategy Is Cooperative

- Starts with cooperation to attempt building mutual cooperation.
- Punishes defectors immediately but *does not* hold grudges forever — has forgiveness to enable trust recovery.
- Defects permanently only if opponents do not resume cooperation (persistent defection).
- Defects in last round, preventing exploitation by backward induction.
- Encourages mutual cooperation via contingent response based on observable actions.

---

## Edge Cases Addressed

- **First round unknown behavior**: Cooperate by default (no history).
- **After defection, if everyone cooperates**, cooperate again (forgiveness).
- **Last round**, always defect (dominant strategy for final round).
- **Multiple defectors or noisy defection**: Punished once, but possibility of return to cooperation.
- **All cooperate forever**: mutual max payoff achieved.

---

This strategy balances strict punishment and forgiveness, which is vital in the repeated public goods game without communication or binding agreements. It optimally supports a cooperative equilibrium while protecting against exploitation.
'''

description_COOPERATIVE_90 = '''
**Cooperative Strategy: Gradual Reciprocity with Forgiveness**

---

### Overview

The strategy aims to foster and maintain mutual cooperation across the repeated rounds, maximizing collective payoffs. It follows a conditional cooperation approach modeled on reciprocity, combined with forgiveness to avoid endless mutual defection triggered by single defections. The design balances incentives to cooperate with safeguards against exploitation.

---

### Intuition

- **Cooperate initially:** Start by cooperating to signal willingness and enable mutually beneficial cooperation.
- **Reciprocate cooperation:** If all players cooperated previously, continue cooperating to maintain trust.
- **Punish defections proportionally:** If others defected, respond with defection to discourage free-riding.
- **Forgive occasional defections:** After punishing, return to cooperation to avoid permanent breakdown.
- **Final round defection:** Defect in the last round (backward induction) as future cooperation cannot be enforced.

---

### Decision Rules

Let:
- Round index: t ∈ {1, 2, …, r}
- History: For each round s < t, observed action profile A_s = (a_1,s, a_2,s, ..., a_n,s)
- For the current round t, player i decides action a_i,t ∈ {C, D}

Define helper functions:

- `all_cooperated(t-1)`: true if all players chose C in round t-1
- `someone_defected(t-1)`: true if at least one player chose D in round t-1
- `last_round(t)`: true if t == r

---

### Strategy Description

1. **Round 1 (t = 1):**

   - Play **C** (cooperate) unconditionally to initiate cooperation.

2. **Rounds 2 to r-1 (2 ≤ t < r):**

   - If in round t-1 **all players cooperated**, play **C**.
   - Else if in round t-1 **someone defected**,
     - Defect in round t as a punishment.
     - In round t+1, regardless of others’ actions, return to cooperating to demonstrate forgiveness.

3. **Last round (t = r):**

   - Play **D** (defect) unconditionally to maximize immediate payoff as no future retaliation is possible.

---

### Key Points

- Punishment is limited to one round immediately after defection.
- Forgiveness restores cooperation rapidly, preventing persistent mutual defection.
- The final round defection follows backward induction, accepting cooperation collapse at the end.

---

### Pseudocode

```python
# Inputs:
# - history: list of tuples [(a_1,1,..., a_n,1), ..., (a_1,t-1, ..., a_n,t-1)] of past rounds
# - current_round: t
# - num_rounds: r

def cooperative_strategy(history, current_round, num_rounds, player_index):
    if current_round == 1:
        # First round: initiate cooperation
        return 'C'
        
    if current_round == num_rounds:
        # Last round: defect
        return 'D'
    
    # Evaluate last round behavior
    last_actions = history[-1]
    all_cooperated = all(a == 'C' for a in last_actions)
    someone_defected = not all_cooperated
    
    # Track if we punished in previous round to forgive now
    if current_round >= 3:
        prev_last_actions = history[-2]
        prev_all_cooperated = all(a == 'C' for a in prev_last_actions)
        prev_someone_defected = not prev_all_cooperated
        
        # If we punished last round (defected following defection), now forgive
        if prev_someone_defected and history[-1][player_index] == 'D':
            return 'C'
    
    # Punish if others defected last round
    if someone_defected:
        return 'D'
    else:
        return 'C'
```

---

### Example Walkthrough

- Round 1: Cooperate.
- Suppose all cooperate → Round 2: Cooperate.
- If in Round 2 some defect → Round 3: Defect (punishment).
- Round 4: Cooperate again (forgiveness).
- This pattern discourages defection but is tolerant to mistakes.
- In final round → Defect always.

---

### Rationale: Why This Works

- Mutual cooperation yields best group payoff (π_i = k > 1), better than mutual defection (π_i = 1).
- Starting cooperatively invites mutual cooperation.
- Immediate punishment discourages free riding.
- Forgiveness prevents permanent cycles of punishment.
- Last round defection is rational due to lack of future incentive.

---

### Summary

| Round       | Condition                         | Action     |
|-------------|---------------------------------|------------|
| 1           | Always                          | Cooperate  |
| 2 to r-1    | If previous round all cooperated| Cooperate  |
|             | Else (someone defected)          | Defect (punishment) |
| 3 to r-1    | If punished previous round       | Cooperate (forgiveness) |
| r (last)    | Always                          | Defect     |

This strategy aligns with a cooperative mindset, relies only on observable behavior, and handles edge cases sensibly. It fosters robust cooperation with forgiveness and guards against exploitation.
'''

description_COOPERATIVE_91 = '''
Here is a cooperative strategy for the repeated N-Player Public Goods game, designed to foster cooperation while being robust to occasional defections. The approach is inspired by reciprocity principles and contingent cooperation common in repeated Public Goods games.

---

## Strategy Name: Forgiving Conditional Cooperator (FCC)

### Main Idea:
- Start cooperatively to encourage moving towards the cooperative equilibrium.
- Continue cooperating as long as *most* players cooperated in the previous round.
- If defections occur, briefly defect (punish), then return to cooperation to avoid endless retaliation.
- Cooperate fully in the last round, as no future punishment is possible (endgame effect).
- "Most players cooperated" threshold is adjustable; default: at least (n-1) cooperated.

---

## Decision Rules

### Notation and inputs:
- History up to round (t-1): actions of all players in all previous rounds
- Current round index: t ∈ {1, ..., r}
- Number of players: n
- State variables: none external, only history-dependent decision

---

### ROUND 1 (t = 1)
- Cooperate (C) unconditionally.
  
*Rationale:* Start by signaling willingness to cooperate.

---

### INTERMEDIATE ROUNDS (1 < t < r)
- Let `prev_cooperations =` number of cooperators in round (t-1)
- Let `my_prev_action =` my own action in round (t-1)

Decision:
- If `prev_cooperations ≥ n - 1` (all or all but one cooperated last round), then cooperate (C).
- Else (if significant defections happened last round):
  - Defect (D) once as punishment.
  - Next round, return to cooperate regardless of last round actions (forgiveness).

*Note:* To implement forgiveness, keep a simple flag `punished_last_round` in memory.

Pseudocode for rounds 2 to (r-1):
```
if punished_last_round:
    cooperate
    punished_last_round = False
else:
    if prev_cooperations >= n - 1:
        cooperate
    else:
        defect
        punished_last_round = True
```

---

### LAST ROUND (t = r)
- Cooperate unconditionally.

*Rationale:* No future rounds for punishment, so cooperation is best to maximize group payoff.

---

## Summary of Properties

| Round         | Condition                         | Action  |
|---------------|---------------------------------|---------|
| t = 1         | First round                     | Cooperate (C) |
| 1 < t < r     | If punished_last_round = True  | Cooperate (forgiveness) |
| 1 < t < r     | Else if (prev_cooperations ≥ n-1) | Cooperate          |
| 1 < t < r     | Else                           | Defect (punish)            |
| t = r (last) | Always                        | Cooperate (C)         |

---

## Intuition and Cooperative Alignment:

- Start nice and fully cooperative.
- Maintain cooperation as long as nearly everyone cooperates — this builds a cooperative culture.
- Retaliate briefly against sizable defections (more than 1 defector) to discourage persistent free-riding.
- Forgiveness avoids spiraling into permanent mutual defection.
- In last round, return to cooperate to maximize group welfare since no future incentive to punish.

---

## Additional Notes:

- Threshold of `(n-1)` cooperators can be tuned (e.g., `n-2` or `n` depending on desired tolerance).
- The strategy does **not** attempt to single out individual defectors—it punishes collectively once defections cross threshold.
- Punishment is limited to one round only—this prevents endless cycles.
- Since all players see all actions, this is perfectly observable, no noise assumed.

---

## Full Pseudocode:

```python
initialize:
    punished_last_round = False

for t in 1 to r:

    if t == 1:
        action = 'C'
    
    elif t == r:
        action = 'C'
    
    else:
        prev_cooperations = count_cooperators_in_round(t-1)
        
        if punished_last_round:
            action = 'C'
            punished_last_round = False
        else:
            if prev_cooperations >= n - 1:
                action = 'C'
            else:
                action = 'D'
                punished_last_round = True

    play action
```

---

This strategy balances cooperation with measured punishment and forgiveness, consistent with a cooperative mindset under perfect information and repeated interaction with no communication. It aims to sustain efficient group outcomes over repeated rounds while being defensible against exploiters.
'''

description_COOPERATIVE_92 = '''
Here is a cooperative strategy for the repeated N-player Public Goods Game described, designed to foster mutual cooperation and maximize group payoffs over multiple rounds. It uses conditional cooperation with forgiveness and end-game considerations typical in repeated social dilemmas.

---

# **Cooperative Strategy Design**

### **Core Idea:**
Cooperate initially and continue cooperating as long as everyone else has cooperated in previous rounds. If defection is detected, respond by defecting once as punishment (retaliation), then return to cooperation (forgiveness) to try restoring cooperation. In the final round, defect to avoid being exploited since there is no future punishment for defecting.

---

## 1. Decision Rules

- **Round 1 (Initial move):**  
  Cooperate (play C) to initiate cooperation.

- **Round t (2 ≤ t < r):**  
  - If *all players* cooperated in round t–1, cooperate.
  - Else (at least one defector in t–1), defect once as a *punishment*.
  - After punishing (defecting once), resume cooperating in subsequent rounds if others also cooperate.

- **Round r (Last round):**  
  Defect (play D) because no future rounds allow for punishment, so defectors gain without consequences; standard backward induction argument in finitely repeated games.

---

## 2. Handling Edge Cases

- **First round:**  
  No prior history → cooperate to signal willingness to cooperate.

- **Last round:**  
  Defect because cooperation is not incentivized (no future).

- **After a defection occurred in any previous round:**  
  Defect once in the round immediately following defection as punishment, then forgive (return to cooperation) to restore cooperative equilibrium, assuming others also forgive.

- **Multiple defections:**  
  If defections continue, this rule makes you defect each round immediately following a defection, but you always attempt to return to cooperation if others cooperate. This balances retaliation with forgiveness.

---

## 3. Cooperative Mindset Alignment

- Prioritizes mutual cooperation to maximize group payoff (all cooperating yields payoff = k, which is >1).

- Uses *conditional cooperation*—only defects to punish defection.

- Forgives after one punishment round to avoid endless retaliations.

- Avoids exploitation by defecting in the last round.

---

## 4. Pseudocode for the Strategy

```python
def cooperative_strategy(history, current_round, total_rounds):
    # history: list of lists; history[t-1] = [c_1, c_2, ..., c_n] (each c_i ∈ {C, D})
    # current_round: integer t (1-based)
    # total_rounds: integer r
    # Your index: i (assumed known, else strategy symmetric)
    
    # 1. First round: cooperate
    if current_round == 1:
        return 'C'
    
    # 2. Last round: defect
    if current_round == total_rounds:
        return 'D'
    
    # 3. From round 2 to r-1:
    # Check if *all players* cooperated in previous round
    prev_round_actions = history[current_round - 2]  # zero-based indexing
    
    all_cooperated = all(action == 'C' for action in prev_round_actions)
    
    # Detect if last round you played punishment (defected once after defection)
    # Strategy remembers whether last round was punishment round to forgive now
    if current_round > 2:
        prev_prev_round_actions = history[current_round - 3]
        prev_round_defected = not all(action == 'C' for action in prev_prev_round_actions)
        # If previous round you defected as punishment due to defection in round before
        # and current round others cooperated, forgive by cooperating again
    
    # Punish if at least one defector last round
    if not all_cooperated:
        # Punish by defecting once
        return 'D'
    else:
        # After punishment, return to cooperate to restore cooperation
        return 'C'
```

---

## 5. Explanation

- **Start by cooperating:** Signals willingness.

- **If you see everyone cooperated last round, cooperate again:** Reinforce cooperation.

- **If any player defected last round, punish once by defecting:** Shows intolerance for free-riding.

- **Then return to cooperation if others cooperate:** Avoids endless retaliation cycles.

- **Defect on last round:** Rational end-game play; no incentive to cooperate without future consequences.

---

# Summary

| Round        | Condition                 | Action                                        |
|--------------|---------------------------|-----------------------------------------------|
| 1            | Initial round             | Cooperate (C)                                 |
| 2 to r-1     | All cooperated in t-1?    | Yes → Cooperate (C)                           |
|              |                           | No → Defect (D) once (punishment)            |
| 2 to r-1     | After punishing (once)     | Return to Cooperate (C) if cooperation resumes |
| r (last round) | Any history              | Defect (D)                                   |

---

This strategy is a typical *Generous Tit-for-Tat* variant adapted to multi-player setting and repeated public goods structure, balancing cooperation and enforcement of cooperation with forgiveness, and avoiding exploitation in final round. It is well-known to promote and sustain cooperation in repeated public goods games under perfect monitoring and common knowledge assumptions.
'''

description_COOPERATIVE_93 = '''
Here is a fully cooperative strategy tailored for the N-player repeated Public Goods Game with parameters as specified. It combines:

- An initial cooperative stance to maximize group benefit.
- A simple and clear “conditional cooperation” rule to punish defectors and thereby deter free-riding.
- Forgiveness to return to cooperation when others do.
- Careful handling of the first and last rounds to maximize payoffs.

---

## Cooperative Strategy: Conditional Cooperation with Forgiveness and Endgame Adjustment

### Intuition
- Start by cooperating from round 1 to build trust and maximize joint payoff.
- Continue cooperating as long as all players cooperated in the previous round.
- If any defection is observed in the previous round, punish defectors by defecting for *one* round only.
- After punishment, return to cooperation to encourage re-establishing cooperation.
- In the last round, defect to maximize individual payoff, since no future rounds remain to incentivize cooperation.

This balances cooperation incentives and individual payoff maximization under strategic uncertainty.

---

## Decision Rules

For round t ∈ {1, ..., r}, player i's action \( a_i^t \in \{C, D\} \):

1. **Round 1:**  
   Cooperate unconditionally:  
   \( a_i^1 = C \)

2. **Rounds 2 to r - 1:**  
   - If all players cooperated in round t - 1 (i.e., everyone chose C), then cooperate:  
     \( a_i^t = C \)
   - Else (at least one defector in round t - 1):  
     Defect this round (punishment):  
     \( a_i^t = D \)

3. **Round r (Last round):**  
   Defect to maximize personal payoff (no future consequence):  
   \( a_i^r = D \)

---

## Additional Notes

- **Why punish only for one round?**  
  Harsh retaliation (e.g. defect indefinitely) risks collapsing cooperation permanently if others keep defecting for payoff gain. One-round punishment maintains incentive to return to cooperation.

- **Why defect in last round?**  
  Since no future rounds exist, cooperation does not yield future reward and costs you your private endowment, so defecting is payoff maximizing.

- **What if others only partially cooperate?**  
  This strategy quickly retaliates by defecting, potentially lowering group payoff but disincentivizing free-riding.

- **What if multiple players defect simultaneously?**  
  Since punishment is symmetric and simultaneous, defecting in response maintains a credible threat and helps stabilize cooperation in earlier rounds.

---

## Pseudocode

```
Input:
- r: number of rounds
- history: list of previous round action profiles [(a_1^1,...,a_n^1), ..., (a_1^(t-1),...,a_n^(t-1))]

For round t = 1 to r:
    if t == 1:
        action = C  # Start cooperatively

    else if t == r:
        action = D  # Defect in last round (endgame defection)

    else:
        last_round_actions = history[t-2]  # zero-based indexing
        if all players cooperated last round:
            action = C
        else:
            action = D  # Punishment for defection

    Play action
```

---

## Summary

| Round      | Condition                             | Action    |
|------------|------------------------------------|-----------|
| 1          | No prior history                    | Cooperate |
| 2 to r - 1 | All players cooperated previous round | Cooperate |
| 2 to r - 1 | Otherwise (someone defected last round) | Defect (punish) |
| r (last)   | Final round                        | Defect    |

---

This strategy is:

- **Cooperative:** Promotes maximum group payoff by cooperating when others cooperate.
- **Stable:** Guards against exploitation by defecting after detecting free-riding.
- **Forgiving:** After one round of punishment, returns to cooperation to restore mutual benefit.
- **Rational:** Defects in the last round when no incentive remains to cooperate.

It aligns perfectly with the public goods game's incentives and repeated structure under the given assumptions.
'''

description_COOPERATIVE_94 = '''
**Cooperative Strategy for N-Player Public Goods Game**

---

### Intuition & Goals

- The **mutual best outcome** occurs if all players cooperate every round, yielding payoffs π_i = k (since each contributes 1, and share is k/n × n = k).
- Defection is individually tempting because one keeps the private endowment (1 instead of 0), but damages group payoff.
- The strategy aims to:
  - Encourage cooperation early and maintain it if possible (to approach the efficient outcome).
  - Detect defection promptly and respond, but allow forgiveness.
  - Handle last round by cooperating, assuming no future repercussions (to maintain strong cooperation if others do).
  - Avoid self-destruction: if defection happens, protect against exploitation but strive to restore cooperation.

---

### Strategy Description: *Conditional Reciprocity with Forgiveness ("CRF")*

---

#### High-Level Summary

- **Round 1:** Cooperate unconditionally.
- **Subsequent rounds:**
  - If *all* other players cooperated last round → cooperate.
  - If *any* player defected last round → defect this round (punish).
- **Forgiveness rule:** If you punished last round, but all players cooperated last round, switch back to cooperate.
- **Last round (round r):** Cooperate regardless of history (to maximize final payoff and encourage endgame cooperation).

---

#### Decision Rules (Pseudocode)

```pseudocode
Input: 
  n, r, k           // game parameters
  history           // list of previous rounds' actions for all players: actions[t][i] ∈ {C,D}
  current_round t ∈ {1,...,r}
  player_index i    // own index

Output:
  action ∈ {C,D}

Define:
  cooperators_last_round = { j | actions[t-1][j] == C }
  all_cooperated_last_round = (length(cooperators_last_round) == n)

If t == 1 then
  // Start with cooperation to build trust
  action = C

Else if t == r then
  // Last round: cooperate regardless to avoid endgame defection spiral
  action = C

Else
  If all_cooperated_last_round then
    // If no defection was observed, cooperate
    action = C
  Else
    // Some defections occurred last round, punish by defecting
    action = D

    // Implement forgiveness: if punishment round preceded by full cooperation, restore cooperation next round
    // This can be implemented by comparing history 2 rounds back if desired,
    // but to keep it memory-1, simply punish any defection immediately

End if
```

---

#### Explanation of the Logic:

- **Round 1 cooperation:** Starts with goodwill, hoping others do the same.
- **Punishment of defection:** If anyone defects, defect next round to signal displeasure and reduce exploitability.
- **Forgiveness by returning to cooperation after one punishment round:** This is implicit by the direct condition — player cooperates only if last round was fully cooperative.
- **Last round cooperation:** Avoids backward induction unraveling, where rational players defeat cooperate in final rounds.

---

### Handling Edge Cases

- **First round (t=1):** No history; cooperate to build mutually beneficial cooperation.
- **First defection by others:** Punish immediately next round to discourage exploitation.
- **Multiple rounds with defection:** Continue defecting until a full cooperation round emerges (may be hard if opponents are defecting frequently).
- **Last round (t=r):** Cooperate regardless of history to maximize group payoff and incentivize cooperation overall.
- **If all defect all rounds:** Will defect all rounds except initial round (round 1 is cooperate), minimizing exploitation.
- **If all cooperate all rounds:** Full cooperation obtained, maximal payoff.
- **If intermittent defection:** Punishment rounds deployed, cooperation restored once full cooperation round observed.

---

### Strategy Characteristics

- **Memory-1 conditional strategy:** Simple to implement and observe.
- **Promotes cooperation:** Rewards cooperation with cooperation, punishes defection with defection.
- **Forgiving:** Allows return to cooperation after defection punished.
- **Robust:** Does not require communication or explicit coordination beyond action observation.
- **Aligns with cooperative mindset:** Explicitly prefers cooperation whenever feasible, and forgives to restore cooperation.
- **Resilient against exploitation:** Immediate punishment discourages free-riding.

---

### Possible Extensions (Optional for Future Tuning)

- Use *threshold-based punishment* (e.g., punish only if # defectors > 1).
- Use *gradual forgiveness*: Cooperate with probability increasing in number of cooperators last round.
- Use *longer memory* to detect patterns of defection.
- React to payoff drops as signals rather than raw actions.

However, given the tournament environment and no communication, the above conditional reciprocity with forgiveness and last-round cooperation ensures a strong baseline cooperative strategy.

---

# **Summary**

**Strategy Name:** Conditional Reciprocity with Forgiveness (CRF)

- Cooperate on round 1.
- On rounds 2 to r-1:
  - Cooperate if everyone cooperated on previous round.
  - Otherwise defect to punish any defection.
- On final round r, cooperate regardless of past actions.

This strategy balances cooperation and retaliation, maximizes joint payoffs when possible, punishes defectors, and avoids unnecessary destructive spirals. It leverages perfect information and repeated play with common knowledge to maintain cooperation in an anonymous simultaneous setting without communication.
'''

description_COOPERATIVE_95 = '''
Below is a cooperative, conditional strategy aimed at fostering and sustaining cooperation in the repeated Public Goods Game under the given constraints:

---

## Cooperative Strategy: Conditional Cooperation with Forgiveness (CCF)

### Intuition
- Start by cooperating to encourage cooperation.
- Continue cooperating as long as all other players have cooperated in the previous round, signaling mutual trust.
- If anyone defects, punish by defecting for only one round, then attempt cooperation again to avoid endless punishment loops.
- In the last round, always defect (to avoid exploitation via endgame defection).

This strategy balances cooperation with a clear punishment protocol to discourage defection, while being forgiving and allowing cooperation to resume, maximizing joint payoffs over repeated rounds.

---

### Detailed Decision Rules

- **Round 1: Cooperate**  
  No prior history, start with cooperation to signal willingness.

- **Rounds 2 to r - 1 (Intermediate Rounds):**  
  - If all other players cooperated in the immediately preceding round, cooperate this round.  
  - Else (at least one defector last round), defect this round as punishment.

- **Rounds 3 to r - 1, Recovery Rule:**  
  - If you defected last round as punishment, cooperate this round if all defectors from last round cooperated in the round before (forgiveness).  
  - Otherwise, continue defecting until the group returns to full cooperation (this ensures defectors see cost).

- **Round r (Last Round):**  
  - Defect unconditionally. Cooperation cannot be sustained beyond final round due to backward induction.

---

### Pseudocode

```python
def decide_action(history, current_round, n, r):
    """
    history: list of rounds, each round is a list of actions by all players ['C' or 'D']
             indexed by rounds 0..current_round-2 (zero-based)
    current_round: 1-based index of current round (1 ≤ current_round ≤ r)
    n: number of players
    r: total rounds
    
    Returns: 'C' or 'D'
    """
    
    # Always defect in last round
    if current_round == r:
        return 'D'
    
    # Round 1: cooperate
    if current_round == 1:
        return 'C'
    
    # From round 2 to r-1:
    last_round = history[-1]  # actions of all players in last round
    # Check if all others cooperated last round
    others_last_round = last_round[:]
    # Assume 'self_index' known, but since no coordination, treat all players symmetrically
    # Strategy symmetric: my action depends on if any player defected last round
    all_cooperated = all(a == 'C' for a in others_last_round)
    
    # If all cooperated last round, cooperate now
    if all_cooperated:
        return 'C'
    
    # Otherwise, defect as punishment for 1 round
    # But need to check if we are currently punishing or already punished
    
    # Determine if we defected last round (were punishing)
    # If we defected last round due to punishment, try forgiveness if possible
    
    # To do so, track our own last action and the round before last's actions
    
    if current_round >= 3:
        own_last_action = history[-1][self_index]  # assume self_index known
        prev_round = history[-2]
        # If we defected last round as punishment...
        if own_last_action == 'D':
            # check if previous round before last was full cooperation
            prev_all_cooperated = all(a == 'C' for a in prev_round)
            # If so, forgive (cooperate)
            if prev_all_cooperated:
                return 'C'
            else:
                # continue defecting until cooperation restored
                return 'D'
    
    # Default to defect if someone defected last round and not forgiving yet
    return 'D'
```

---

### Implementation Notes for Tournament Entry

- **No player indexing needed:** The key check is "Did all players cooperate last round?"  
If yes → cooperate.  
If no → punish defectors (by defecting).

- **Forgiveness:**  
  Forgiveness is implemented by checking if full cooperation existed prior to defection punishment—if yes, return to cooperation.

- **Last round defection:**  
  Defect last round to avoid exploitation.

---

### Summary

| Round        | Condition                                                       | Action                  |
|--------------|-----------------------------------------------------------------|-------------------------|
| 1            | No prior information                                            | Cooperate (C)           |
| 2 to r - 1   | All players cooperated last round                               | Cooperate (C)           |
| 2 to r - 1   | Any player defected last round                                  | Defect (D) as punishment (limited to 1 round) unless forgiveness conditions met |
| r (last)     | Last round                                                      | Defect (D)              |

---

This conditional cooperation with forgiveness strategy is widely known to sustain cooperation in repeated public goods and prisoner's dilemma style games and aligns with a cooperative mindset while deterring exploitation. It fits perfectly into the parameters and assumptions of this tournament environment.
'''

description_COOPERATIVE_96 = '''
Here is a cooperative strategy designed for the repeated N-Player Public Goods Game as specified. The strategy leverages the repeated nature of the game under perfect information and aims to sustain cooperation by rewarding cooperative behavior and punishing defections — but with forgiveness to avoid breakdowns due to noise or occasional lapses.

---

## High-Level Idea

- **Initial Trust:** Start cooperatively to signal willingness to cooperate.
- **Conditional Cooperation:** Continue cooperating if all or almost all players cooperated in the previous round.
- **Forgiveness:** Tolerate a small number of defections without retaliation to sustain cooperation.
- **Last Round Defection:** Defect on the last round because cooperation is not incentivized once the game ends (standard backward induction).
- **Deterring Free-riding:** If defections exceed the tolerance threshold, punish by defecting next round to reduce the gains of defectors.
- **Re-Entry to Cooperation:** Return to cooperation after punishment round if the group again returns to mostly cooperative behavior.

---

## Definitions

- Let **H_t** be the history of player actions up to round t-1.
- Let **C_{t-1}** be the set of players who cooperated in round t-1.
- Let **D_{t-1}** be the set of players who defected in round t-1.
- Define a tolerance parameter **τ**, the maximum number of allowed defectors tolerated before punishment. Set τ = 1 or 2 depending on n (example: τ = max(1, floor(n/10))).

---

## Detailed Decision Rules

### Round 1 (t = 1):
- **Action:** Cooperate (C)
- **Rationale:** Signal cooperation and try to build a cooperative norm.

### Intermediate Rounds (1 < t < r):

1. Observe previous round actions (t-1).
2. Calculate the number of defectors last round: d = |D_{t-1}|.
3. If previous round had defections:
   - If d ≤ τ (defections within tolerance):
     - Cooperate (C) to maintain cooperation, assuming defection might be noise or error.
   - Else (d > τ):
     - Defect (D) to punish defectors and discourage free-riding.
4. If previous round was full cooperation (d = 0):
   - Cooperate (C).

### Last Round (t = r):
- Defect (D) because cooperation has no future incentivization (backward induction).

---

## Pseudocode

```
Input: n (players), r (rounds), k (multiplication factor)
Parameters:
   τ = max(1, floor(n/10))   # tolerance for defects

For round t in 1..r:
    If t == 1:
        action = C
    Else if t == r:
        action = D
    Else:
        Let d = number_of_defectors_in_round(t-1)

        If d == 0:
            action = C
        Else if d <= τ:
            action = C
        Else:
            action = D

    Play action
```

---

## Why This Strategy Is Cooperative

- Starts with cooperation to set a positive tone.
- Allows limited defections without immediate punishment — accommodates possible mistakes or misunderstandings.
- Punishes persistent or widespread defection to discourage free-riders.
- Returns to cooperation after punishment rounds if cooperation resumes.
- Defects only in last round, consistent with standard game-theoretic logic.

---

## Handling Edge Cases

1. **First Round:** Cooperate unconditionally (no prior info).
2. **Last Round:** Defect to maximize final individual payoff.
3. **Small number of defectors:** Continue cooperating; this tolerates occasional mistakes.
4. **Multiple defections:** Trigger punishment to prevent exploitation.
5. **No communication or coordination:** Only react based on observable past actions.
6. **All cooperate rounds:** Stable cooperation is maintained for maximum group benefit (since benefit per player is higher than defecting alone).

---

## Optional Improvements (if implementation allows)

- **Gradual punishment:** Instead of one-round or permanent, escalate punishment severity if defections persist.
- **Forgiveness windows:** After a punishment round, if cooperators reemerge, quickly return to cooperation.
- **Track individual player defections:** If possible, target punishment on defectors by defecting, otherwise defect generally.

---

# Summary

This strategy is a **conditional cooperation with forgiveness** and **last round defection**, a known robust approach in repeated public goods scenarios. It balances incentives for collective benefit with deterrence of defection, and aligns well with standard game-theoretic rationality under repeated interaction without communication.

---

If you want, I can help develop a more complex variant or analyze expected payoffs of this strategy against common ones.
'''

description_COOPERATIVE_97 = '''
Below is a cooperative, conditional cooperation strategy designed for the N-player repeated public goods game described. It balances cooperation and retaliation to sustain cooperation while punishing defections to deter free-riding. The strategy respects perfect information and no-communication constraints and assumes no explicit coordination devices.

---

### Strategy Name: **Conditional Grim Trigger with Forgiveness**

---

### 1. Decision Rules (Per Round, for Player i):

- **Round 1 (Initial Round):**  
  Cooperate (C) unconditionally to initiate cooperation.

- **Subsequent Rounds (t = 2 to r - 1):**  
  - If **all players cooperated in every prior round** (t-1 and earlier),  
    then **cooperate** this round.  
  - Else if **any defection detected in the immediately preceding round (t-1)**,  
    then **defect (D)** this round.  
  - Else if there was a defection sometime earlier but not in the immediately prior round,  
    then **cooperate** (forgiveness, to attempt to restore cooperation).

- **Last Round (Round r):**  
  - Cooperate if no defection was observed in round r-1 (to maximize joint payoff).  
  - Otherwise, defect (since no future punishment is possible).

---

### 2. Handling Edge Cases:

- **First Round:**  
  No history—cooperate to establish baseline trust.

- **Last Round:**  
  Without future rounds for retaliation, the incentive to cooperate shrinks; still, cooperate if no recent defection to help maximize mutual payoffs.

- **Multiple Defections Detected:**  
  Single-round punishment limits cost of endless retaliation. The strategy punishes only the immediate next round after defection.

- **No Communication or Coordination:**  
  Purely history-driven; punishes exactly what is observed — allows return to cooperation after punishment.

---

### 3. Cooperative Mindset:

- Starts fully cooperative to get maximum group benefit.  
- Punishes defection once immediately to discourage free-riding.  
- Forgives defections older than one round ago, assuming possibly explorative or accidental mistakes, promoting eventual return to cooperation.

---

### Pseudocode

```python
# Inputs:
# history: list of length t-1, each element is an n-length list of actions ['C'/'D']
# current_round: int, 1-based
# n: number of players
# r: total rounds

def decide_action(history, current_round, n, r):
    if current_round == 1:
        # No history: start cooperative
        return 'C'
    
    last_round_actions = history[-1]
    all_cooperated_last_round = all(a == 'C' for a in last_round_actions)
    all_cooperated_so_far = all(
        all(a == 'C' for a in round_actions) for round_actions in history
    )
    
    if current_round == r:
        # Last round
        if all_cooperated_last_round:
            return 'C'  # Coop if last round was good
        else:
            return 'D'  # Defect if last round had defection
    
    # For intermediate rounds
    if all_cooperated_so_far:
        # Perfect cooperation history
        return 'C'
    
    if not all_cooperated_last_round:
        # Defection detected last round
        return 'D'  # Punish immediately
    
    # Forgive if no defection last round but some defection in earlier rounds
    return 'C'
```

---

### Explanation

- **Why cooperate first round?** To signal willingness to cooperate and maximize joint returns initially.

- **Why punish only the immediately following round after defection?**  
  This keeps retaliation credible but minimizes the cost of prolonged punishment, which can derail cooperation.

- **Why forgive after one round of punishment?**  
  To allow mistakes or explorations not to doom future cooperation; this fosters recovery and stability in repeated interaction.

- **Why defect if defection found in last round on final round?**  
  No future punishment phase; defecting maximizes private payoff if others defected last round.

---

This strategy can sustain high cooperation if others are similarly conditionally cooperative, but punishes defectors immediately enough to discourage free riding. It balances cooperation, punishment, forgiveness, and final-round incentives to align closely with the cooperative mindset given the game's constraints.
'''

description_COOPERATIVE_98 = '''
Here's a cooperative strategy tailored for the repeated N-player public goods game described. It is inspired by conditional cooperation and forgiveness principles known from repeated public goods and Prisoner's Dilemma settings, adapted to a multi-player environment with perfect information but no communication.

---

## Strategy Name: **Conditional Reciprocal Cooperation with Gradual Forgiveness**

### Intuition
- Start by cooperating to foster mutual cooperation.
- Continue cooperating if **the group's average cooperation rate** in the previous round meets a high threshold, signaling cooperation.
- Defect as a punishment if cooperation drops below that threshold (to discourage free-riding).
- Gradually forgive isolated defections to avoid endless punishment cycles.
- In the final round, defect, recognizing no future punishment/reward is possible.

---

## 1. Decision Rules

At round \( t \), given the history of all players' actions in previous rounds \( 1 \dots t-1 \):

- **Round 1 (initial round):**  
  **Action:** Cooperate (C).  
  *Rationale:* Kickstart cooperation.

- **Rounds \( 2 \leq t < r \) (intermediate rounds):**  
  Calculate the proportion of players who cooperated in round \( t-1 \):  
  \[
  \text{coop\_rate} = \frac{\sum_{j=1}^n \mathbf{1}_{\{c_j^{t-1} = C\}}}{n}
  \]
  where \(\mathbf{1}_{\{\cdot\}}\) is the indicator function.

  If \(\text{coop\_rate} \geq \theta\), **Cooperate**, else **Defect**.

  *Choose \(\theta\) in \([0.7, 1)\) (e.g., 0.8). This means "cooperate only if at least 80% cooperated last round".*

  **Exception / forgiveness:**  
  If you defected in round \( t-1 \), but the coop_rate in round \( t-2 \) was ≥ \(\theta\), **cooperate** in round \( t \) to allow return to cooperation. Similarly, ignore isolated "drop below threshold" once every X rounds to allow recovery.

- **Round \( t = r \) (final round):**  
  **Defect (D).**  
  *Rationale:* No incentive to cooperate in the last round since no future payoffs depend on current action.

---

## 2. Edge Cases Handling

- **First round (t=1):** Cooperate unconditionally.

- **Second round (t=2):** Decision based on first round coop rate, which is known.

- **Isolated defections:** If one or few players defect occasionally, do not immediately defect permanently. Forgive one defection by cooperating if overall coop rate is high, to restore cooperation.

- **Persistent low cooperation:** If coop_rate remains below \(\theta\) for 2+ rounds, defect continuously until coop_rate bounces back.

- **Final round (\(t = r\)):** Always defect; no value in cooperating.

---

## 3. Cooperative Mindset Alignment

- **Goal:** Maximize group payoffs by stabilizing mutual cooperation most rounds.

- **Punishment:** Defection only triggered by sufficiently strong evidence of group free-riding.

- **Forgiveness:** Allows recovery from mistakes or occasional defectors.

- **Clarity:** Uses simple measurable threshold on observed cooperation to decide actions, no complex prediction.


---

## Pseudocode

```
Parameters:
- n: number of players
- r: total rounds
- theta: cooperation threshold (e.g., 0.8)

Initialize:
- history = []  # list of sets: actions of all players by round

For each round t in 1 to r:
    if t == 1:
        action = 'C'  # Start cooperative
    else if t == r:
        action = 'D'  # Last round defect
    else:
        last_round_actions = history[t-2]  # 0-based index
        coop_count = count of 'C' in last_round_actions
        coop_rate = coop_count / n

        if coop_rate >= theta:
            # Forgiveness: if I defected last round but before that coop was good, cooperate now to restore cooperation
            if t > 2:
                prev_coop_rate = (count of 'C' in history[t-3]) / n
                if my_action_in_round(t-1) == 'D' and prev_coop_rate >= theta:
                    action = 'C'
                else:
                    action = 'C'
            else:
                action = 'C'
        else:
            # coop_rate < theta => defect
            # Optional forgiveness: allow occasional cooperation if isolated dip in coop_rate
            if last_round_coop_rate_recovered_after_one_round_low():
                action = 'C'
            else:
                action = 'D'

    Play action
    Observe all players' actions this round -> append to history
```

---

### Notes on Implementation:

- **Memory:** The strategy only uses last one or two rounds’ cooperation rates to make decisions (bounded memory).

- **Threshold \(\theta\):** Tunable based on simulation, but 0.8 favors strong cooperation.

- **Forgiveness logic:** Simple — forgives if isolated defection or small dip occurring but overall high cooperation.

---

# Summary

This strategy is **cooperative by default** (starts cooperating), **punishes free riding through defection if cooperation falls below a threshold**, and **allows forgiveness to restore cooperation**. It recognizes the futility of cooperation in the last round and defects there. This should yield near-maximal payoffs in tournaments with other cooperative or conditionally cooperative players, while penalizing consistent defectors.
'''

description_COOPERATIVE_99 = '''
**Cooperative Strategy Design: "Conditional Reciprocity with Forgiveness"**

---

### Intuition and Goals
- **Maximize mutual cooperation:** Cooperation yields the highest collective and individual payoff.
- **Discourage exploitation:** Defections reduce payoffs for cooperators; respond so defection is unattractive.
- **Allow recovery:** Mistakes or strategic defections don’t doom cooperation forever.
- **Handle last round:** Avoid defection-triggered unraveling (i.e., backward induction) by using cooperation until the end.

---

### Decision Rules Summary

| Round | Condition                            | Action     |
|-------|------------------------------------|------------|
| 1     | No history yet                     | Cooperate  |
| 2..r-1| If all players cooperated last round | Cooperate  |
| 2..r-1| Else if number of defectors ≤ 1 previous round | Cooperate (forgiving) |
| 2..r-1| Otherwise                         | Defect     |
| r     | Cooperate                         | Cooperate  |

---

### Detailed Description

#### 1. **First Round:**
- Cooperate unconditionally.
- Reason: Establish baseline cooperation and set positive precedent.

#### 2. **Intermediate Rounds (2 to r-1):**
- Observe actions of all other players in **previous round**.
- If **everyone cooperated** last round, cooperate again.
- If defects occurred, but only **1 player defected**, forgive and cooperate again. (Forgiveness mitigates accidental defection or single deviator allowing quick return to cooperation.)
- If **more than 1 defector** in the previous round, punish by defecting this round.
- Punishment discourages widespread defection but is not harsh for minor deviations.

#### 3. **Last Round (round r):**
- Cooperate regardless of prior defections.
- Reason: No future rounds to punish, mutual cooperation yields better payoff than mutual defection.
- This avoids the typical "endgame defection" unraveling.

---

### Pseudocode

```python
# Inputs per round t:
# actions_history: list of length t-1, each element is list of length n with 'C' or 'D' per player
# my_index: player’s index (0-based)
# n, r: parameters as defined

def strategy(t, actions_history, my_index, n, r):
    if t == 1:
        # First round: cooperate
        return 'C'

    last_round = actions_history[-1]  # actions of all players in previous round
    num_defectors_last = sum(1 for a in last_round if a == 'D')

    if t == r:
        # Last round: cooperate always
        return 'C'

    # Intermediate rounds
    if num_defectors_last == 0:
        # All cooperated in last round, cooperate
        return 'C'
    elif num_defectors_last == 1:
        # One defector last round, forgive and cooperate
        return 'C'
    else:
        # Multiple defectors last round, punish by defecting
        return 'D'
```

---

### Why This Strategy Is Cooperative and Effective

- **Promotes cooperation:** Always start with cooperation and cooperate after universal cooperation.
- **Graceful with noise/errors:** Forgives a single defection so as not to spiral into mutual defection over minor mistakes.
- **Discourages persistent defection:** Multiple defectors trigger defection, signaling punishment and reducing payoff for defectors.
- **Last round cooperation:** Prevents backward induction unraveling; players get max mutual payoff at the end.
- **Simple and transparent:** Based only on perfect observation of previous actions, no complex beliefs or coordination required.

---

### Edge Cases

- **If all players defect first round:** This strategy defects from round 2 onward except last round (which is cooperate). It tries to reestablish cooperation via forgiveness if defections drop to 1 or 0.
- **If a player defects sporadically:** The strategy forgives occasional single defections, potentially sustaining cooperation.
- **If a coalition defects:** Punishes defectors by defecting until defections drop ≤ 1 again.
- **If r=2:** The last round is round 2, so cooperate in round 2 regardless.

---

### Summary

This is a cooperative conditional reciprocity strategy with forgiveness and last-round cooperation to sustain mutual cooperation over the repeated public goods game, maximizing group and individual payoffs under standard assumptions and given no communication or coordination beyond observed actions.
'''

description_COOPERATIVE_100 = '''
Here is a cooperative strategy outline designed to promote mutual cooperation in the repeated N-Player Public Goods Game described.

---

## Strategy Name: **Conditional Cooperate-Tolerate-Retaliate (CTR)**

### Intuition
- **Start cooperating** to signal willingness to build mutual benefit.
- **Continue cooperating** as long as the group cooperates at a high enough level.
- **Tolerate some defections** to handle occasional mistakes or exploitation attempts.
- **Retaliate by defecting** if defections become frequent or intentional, to punish free riders.
- In the **final round, cooperate** since future punishment is impossible and cooperation maximizes collective payoff.

---

## Detailed Description

### Parameters for the strategy
- `n`: number of players
- `r`: number of rounds
- `k`: multiplication factor
- `threshold_coop_ratio`: a threshold fraction of cooperators in previous round to consider cooperation continued (e.g., 0.7)
- `tolerance`: number of defections tolerated in history before retaliation (e.g., 1)
- These parameters can be constants or functions of `n, k, r`, but fixed small `threshold_coop_ratio ≈ 0.7` and `tolerance = 1` is recommended.

---

### Decision rules per round `t` (1 ≤ t ≤ r) — define player i's action `a_i,t` ∈ {C, D}:

1. **Round 1 (t=1): Cooperate (C)**
   - Start by cooperating to signal willingness to contribute.

2. **Rounds 2 to r-1: Conditional cooperation**
   - From the previous round t-1, observe the number of cooperators:  
     \( \text{coop\_count}_{t-1} = \sum_{j=1}^n \mathbb{1}_{\{a_{j, t-1} = C \}} \)
   
   - Compute the cooperation ratio:  
     \( \text{coop\_ratio} = \frac{\text{coop\_count}_{t-1}}{n} \)

   - Count defections against you in the history:  
     \( \text{defections\_count} = \# \{ \text{round } s < t : a_{i,s} = C \text{ and observed } a_{j,s} = D \text{ for at least one } j \neq i \} \)
    
     *(i.e., number of rounds you cooperated and saw at least one defection from others)*

   - Decision rules:
     - **If** `coop_ratio ≥ threshold_coop_ratio` **and** `defections_count ≤ tolerance`:  
       → **Cooperate (C)**
     - **Else:**  
       → **Defect (D)** (punish suspected defectors)

3. **Round r (last round): Cooperate (C)**
   - Defection in the last round yields no future punishment payoff advantage.
   - Cooperate to maximize mutual total payoff.

---

## Edge Case Handling

- **First round, no history:** Cooperate by default.
- **Last round:** Always cooperate regardless of history.
- **Occasional defections tolerated:** To avoid permanent collapse of cooperation due to one-off mistakes or noise.
- **If persistent defection detected:** Defect to punish and signal that cooperation requires mutual compliance.

---

## Pseudocode

```python
def CTR_strategy(t, r, n, history, threshold_coop_ratio=0.7, tolerance=1):
    """
    Parameters:
    - t: current round number (1-based)
    - r: total rounds
    - n: number of players
    - history: list of dicts for rounds 1..t-1, each dict maps player_index -> action {'C' or 'D'}
    - threshold_coop_ratio: minimum fraction of cooperators in previous round to keep cooperating
    - tolerance: number of tolerated defecting rounds before retaliation
    
    Returns:
    - action: 'C' or 'D' for current round t
    """
    if t == 1:
        return 'C'  # start cooperating
    
    if t == r:
        return 'C'  # cooperate in last round
    
    # Analyze previous round:
    prev_round = history[-1]  # dictionary of player -> action in round t-1
    coop_count = sum(1 for a in prev_round.values() if a == 'C')
    coop_ratio = coop_count / n

    # Count rounds where we cooperated but saw any defection by others
    defections_count = 0
    for past_round in history:
        my_action = past_round[my_index]
        if my_action == 'C':
            others_actions = [a for pid, a in past_round.items() if pid != my_index]
            if 'D' in others_actions:
                defections_count += 1

    if coop_ratio >= threshold_coop_ratio and defections_count <= tolerance:
        return 'C'
    else:
        return 'D'
```

*(Note: `my_index` is the player’s own identifier in `[1..n]`.)*

---

## Rationale for Cooperation

- **Cooperate first** to build trust and collective gains.
- **Check group cooperation level each round** to assess willingness of others to cooperate.
- **Tolerate occasional defections** recognizing mistakes or strategic opportunism.
- **Retaliate by defecting** to prevent exploitation and incentivize return to cooperation.
- **Always cooperate on the last round** to maximize aggregate payoffs since punishment no longer matters.

This mirrors **conditional cooperation** and **forgiveness** seen in successful strategies for repeated public goods and prisoner's dilemma games, adapted to the multi-player setting with perfect monitoring but no communication.

---

## Expected Outcomes

- If opponents cooperate most of the time, you sustain mutual cooperation and obtain high payoffs.
- If others frequently defect, you defend yourself by reciprocating, avoiding unilateral exploitation.
- Your willingness to forgive sporadic defections helps avoid unnecessary breakdowns.
- Enables stable cooperation without requiring explicit coordination beyond observing actions.

---

If you want a more “generous” or “strict” variant, you can adjust `threshold_coop_ratio` downward or upward, and similarly adjust `tolerance`.

---

# Summary

Your strategy **starts cooperating**, **continues cooperating while most others cooperate**, **tolerates a small number of defections**, **defects to punish frequent defectors**, and **cooperates in the final round** to maximize total payoff. The logic is simple, interpretable, and aligns clearly with a cooperative mindset under the constraints of this repeated public goods game.
'''

description_COOPERATIVE_101 = '''
**Strategy Name: Generous Conditional Cooperation (GCC)**

---

### Goal
Maximize long-run mutual cooperation payoff by incentivizing cooperation but forgiving occasional defections to avoid breakdowns.

---

### Intuition
- Cooperation yields higher group payoffs (if others also cooperate).
- Defection yields short-term private gain but lowers group payoff.
- Since this is a repeated game with perfect information, a conditional strategy that rewards cooperation and punishes defection can enforce cooperation.
- However, harsh punishments can lead to endless mutual defection; thus, forgiveness is incorporated.
- The last round is treated specially to avoid endgame defection cascade.

---

### Strategy Outline

1. **First Round (t = 1):**  
   - Cooperate (C).  
   - Assumes all rational players prefer high mutual payoffs.

2. **Rounds 2 to r-1 (intermediate rounds):**  
   - Cooperate if the majority (≥ 50%) of players cooperated in the last round.  
   - Defect if less than half cooperated in the last round (punishment for observed low cooperation).  
   - Exception: If we defect, we return to cooperation if majority cooperate again (forgiveness).  

3. **Last Round (t = r):**  
   - Cooperate if majority cooperated in the last round.  
   - Defect otherwise (since no future rounds, fear of exploitation is maximal).  

---

### Justification

- Cooperate initially to establish trust.  
- Use majority cooperation as proxy for group inclination to cooperate; avoids punishing based on single players (noise tolerance).  
- Forgiveness allows recovery from noise/occasional defection mistakes.  
- Last round treats defection as dominant, since there is no incentive to cooperate without future rounds.  
- This strategy is simple and based only on observable history, no assumptions about signals or binding agreements.

---

### Pseudocode

```python
def GCC_strategy(round_t, r, n, history):
    # history: list of tuples of previous rounds' actions of all players
    # history[t-2] is actions of round t-1 (for t>1)
    # Each round's actions: list of length n with 'C' or 'D'
    
    if round_t == 1:
        # First round cooperation
        return 'C'
    
    # Count last round cooperation
    last_round_actions = history[round_t - 2]  # zero-based indexing
    coop_count = sum(1 for a in last_round_actions if a == 'C')
    
    # Calculate if majority cooperated last round
    majority_cooperated = coop_count >= (n // 2) + 1  # strict majority
    
    if round_t < r:
        # Intermediate rounds: cooperate if majority cooperated last round, else defect
        if majority_cooperated:
            return 'C'
        else:
            return 'D'
    else:
        # Last round: cooperate if majority cooperated last round, else defect
        if majority_cooperated:
            return 'C'
        else:
            return 'D'
```

---

### Notes on Edge Cases

- If n is even, majority means more than n/2 (e.g., for n=4, majority = 3 or 4).  
  So fraction ≥ (n//2)+1 ensures strict majority, avoiding ties.  
- If no player other than self cooperated last round (no majority), defect to punish.  
- Forgiveness occurs automatically when majority return to cooperation.  
- No blind cooperation to avoid exploitation by persistent defectors.  
- Perfect information means lagged observation is accurate.

---

### Summary

| Round       | Last round majority cooperated? | Action  |
|-------------|---------------------------------|---------|
| 1 (first)   | N/A                             | C       |
| 2 to r - 1  | Yes                             | C       |
| 2 to r - 1  | No                              | D       |
| r (last)    | Yes                             | C       |
| r (last)    | No                              | D       |

---

This strategy is cooperative, conditional on others cooperating, punishes widespread defection, and forgives to reestablish cooperation. It balances incentives well for repeated public goods provision under no communication and perfect monitoring assumptions.
'''

description_COOPERATIVE_102 = '''
**Cooperative Strategy for the N-Player Public Goods Game ("CoopGrim")**

---

### Strategy Overview

The strategy aims to coordinate mutual cooperation to maximize group payoff, recognizing that:

- Cooperation yields the highest collective benefit.
- Defection yields a short-term gain but reduces overall group payoff.
- Since the game repeats over multiple rounds with perfect monitoring of actions, cooperation can be sustained by punishing defectors to deter exploitation.

The strategy is a form of *trigger* or *grim-trigger* strategy adapted for the multi-player context.

---

### 1. Decision Rules

- **Start cooperating in the first round.**
- **Continue cooperating in each subsequent round, so long as all players cooperated in the previous round.**
- **If any player defects in any previous round, defect in all remaining rounds ("punishment phase").**
- **Exception:** Due to the last-round effect, cooperate if the final round is reached and you are still in the punishment phase (to maximize end payoff rather than retaliate further, since there is no future). This avoids wasting the last round in defection.

---

### 2. Handling Edge Cases

- **First Round:** No history exists, so **cooperate unconditionally**.
- **Subsequent Rounds:** Cooperate if history shows *everyone* cooperated last round.
- **Punishment Phase:** Once triggered by any observed defection in the past, defect forever (except reach last round).
- **Last Round:** Because there's no future punishment possible, cooperate in the last round regardless of past behavior to improve total payoff.

---

### 3. Cooperative Mindset

- The strategy rewards cooperation with ongoing mutual cooperation.
- It punishes defection strongly and permanently (except in last round) to enforce cooperation.
- It forgives in the final round to avoid futile punishment and enhance total payoff.
- The simplicity prevents exploitation via complicated deception or forgiveness schemes.

---

### Pseudocode

```python
# Inputs:
# r = total rounds
# t = current round (1-based)
# action_history = list of tuples with each tuple representing actions of all players in round i, i < t
#   Format: [(a_1_round1, ..., a_n_round1), (a_1_round2, ..., a_n_round2), ...]
# self_id = index of this player in 1..n (optional, depends on implementation)

def coopgrim_strategy(t, r, action_history):

    # 1. First round: cooperate unconditionally
    if t == 1:
        return 'C'

    # 2. Check if any defection occurred in history
    # Flatten all past rounds actions to check for any 'D'
    for past_round_actions in action_history:
        if 'D' in past_round_actions:
            defected_before = True
            break
    else:
        defected_before = False

    # 3. If any defection before, enter punishment phase
    if defected_before:
        # 3a. Last round exception: cooperate in last round
        if t == r:
            return 'C'
        else:
            return 'D'

    # 4. If no defection so far, cooperate
    return 'C'
```

---

### Explanation

- **Why cooperate if everyone cooperated last round?**  
Because mutual cooperation yields the highest payoff, maintaining cooperation is beneficial to all.

- **Why punish forever once defected?**  
To deter any player from defecting: the cost of being punished indefinitely reduces incentives to defect.

- **Why cooperate in last round if punished?**  
No future rounds to punish, so cooperate to maximize last round payoff.

---

### Summary

| Round                | All players cooperated in prev rounds? | Action     |
|----------------------|----------------------------------------|------------|
| First round          | N/A                                    | Cooperate  |
| Middle rounds         | Yes                                    | Cooperate  |
| Middle rounds         | No (defection occurred before)         | Defect     |
| Last round            | Yes                                    | Cooperate  |
| Last round            | No (defection occurred before)         | Cooperate  |

This strategy is robust, clear, and strongly promotes cooperation in an environment of independent rational players with no communication beyond observed previous play.
'''

description_COOPERATIVE_103 = '''
Here is a cooperative strategy for the N-Player Public Goods Game described, designed to foster and sustain cooperation through conditional cooperation and forgiveness. It uses the observable full history of players’ moves to decide actions, aiming to maximize mutual benefit by encouraging others to cooperate, while protecting itself from exploitation.

---

## Cooperative Strategy: Conditional Cooperation with Forgiveness (CCF)

### Intuition

- Start by cooperating to signal willingness to build the public good.
- Continue cooperating as long as the majority cooperate, thereby sustaining collective cooperation.
- Punish defection by defecting temporarily whenever significant defection is detected.
- Forgive defections to allow restarting cooperation if others return to cooperating.
- In the last round, cooperate to maximize payoffs for all (no future retaliation possible).
- Use majority behavior as a proxy for group tendency, since perfect coordination is impossible.

---

### Strategy Description

Let:

- `Round t ∈ {1, 2, ..., r}`
- `n`: number of players
- `k`: multiplication factor
- `History` = record of all players’ moves in rounds 1 to t-1.
- `CCount_t`: number of cooperators in round t.
- Thresholds for deciding cooperation/defection:
  - `CooperationThreshold = ceil(n/2)` (strict majority)
  - `ForgivenessRounds = 1` (punish for one round after defection)
  
---

### Decision Rules

**Round 1:**
- Cooperate (C) unconditionally.

**Round t (2 ≤ t < r):**
- Look at previous round’s cooperation count `CCount_{t-1}`.
- If `CCount_{t-1} ≥ CooperationThreshold` (majority cooperated):
  - Cooperate (C) to conditionally reciprocate cooperation.
- Else (majority defected in last round):
  - Defect (D) for one round as punishment.
  - Then return to cooperation next round unless defection continues.

**Last Round (t = r):**
- Cooperate (C) unconditionally.
- Reason: no future punishment incentives; maximize public good payoff.

---

### Handling Defections and Forgiveness

- Keep track of whether currently in "punishment mode".
- Enter punishment mode if last round had < majority cooperators.
- Stay in punishment mode for exactly one round.
- After one round of punishment, return to cooperation regardless of recent defection.
- This allows the group to recover cooperation after noise or single defections.

---

### Pseudocode

```python
def decide_action(t, r, n, history):
    """
    Decide current action given round and full action history.
    
    Parameters:
        t (int): current round number (1-based)
        r (int): total rounds
        n (int): number of players
        history (list of lists): history of all players' actions,
                                 history[round-1][player-1] = 'C' or 'D'
    
    Returns:
        action (str): 'C' or 'D'
    """
    
    CooperationThreshold = (n // 2) + 1  # Majority threshold
    ForgivenessRounds = 1
    
    # First round: cooperate
    if t == 1:
        return 'C'
    
    # Last round: cooperate to maximize group payoff
    if t == r:
        return 'C'
    
    # From round 2 to r-1:
    # Count cooperators in previous round
    prev_round_actions = history[t-2]
    CCount_prev = sum(1 for a in prev_round_actions if a == 'C')
    
    # Keep state of punishment mode and when it started
    # For simplicity, assume we have an internal state variable:
    # punishment_mode: boolean
    # punishment_start_round: int
    
    # This must be maintained externally or by remembering history
    
    # But since no external state given, use a memory-free approach:
    # Detect if previous round had majority cooperation:
    
    if CCount_prev >= CooperationThreshold:
        # Majority cooperated last round: cooperate
        return 'C'
    else:
        # Majority defected last round: defect once
        # But how to track if we are in forgiveness (one round punishment) mode?
        # Without state, defect this round if previous round had low cooperation,
        # and cooperate next round if cooperation resumes.
        #
        # This means defect this round (t) if previous round majority defected,
        # cooperate if previous round majority cooperated.
        # This approximates one-round punishment.
        return 'D'
```

---

### Remarks

- **No explicit memory of punishment state** used because the game and strategy have perfect information but no internal state specified. The above is a simple memory-free conditional cooperation with implicit one-round punishment.
  
- If implementations can retain internal state across rounds, it can be improved by explicitly tracking a punishment mode lasting exactly one round to allow strategic forgiveness.

- This strategy aligns with the cooperative mindset since it:
  - Starts cooperating to build trust.
  - Continues cooperating conditioned on others cooperation.
  - Punishes defections briefly to deter free-riding.
  - Forgives quickly to restore cooperation.
  - Cooperates in last round to maximize total group payoff.

- Because k < n, the game incentives make full cooperation socially optimal (payoff  > 1), but individually defecting is best in a single round. This conditional cooperation over repeated rounds leverages this tension.

---

### Summary

| Round      | Majority Cooperated Last Round? | Action            |
|------------|--------------------------------|-------------------|
| 1          | N/A                            | Cooperate (C)     |
| 2 to r-1   | Yes                            | Cooperate (C)     |
| 2 to r-1   | No                             | Defect (D)        |
| r (last)   | N/A                            | Cooperate (C)     |

---

This strategy is simple, robust, and well known in repeated public goods or prisoner’s dilemma style games as an effective cooperative approach.
'''

description_COOPERATIVE_104 = '''
Here is a cooperative strategy tailored for the N-Player Public Goods Game under the given constraints.

---

## Strategy Name: **Conditional Cooperation with Forgiveness**

### Intuition

Cooperate as long as others mostly cooperate. Defect only to punish widespread defection but be ready to return to cooperation (forgive). This fosters mutual trust and maximizes group payoffs over repeated rounds.

---

## 1. Decision Rules

- **Round 1 (No History):** Cooperate (C) — start by trusting others.
  
- **Rounds 2 to r-1 (Intermediate Rounds):**  
  - Observe the previous round actions by all players.
  - Calculate the proportion of cooperators (p = number of cooperators / n).
  - **If p ≥ (threshold),** cooperate.
  - **Else, defect** for this round to punish defection.
  - The threshold can be set at 0.8 (80%) to allow some noise or occasional defections without over-punishing.

- **Last Round (Round r):** Defect (D) — since no future repercussions, defect for individual gain.

---

## 2. Handling Edge Cases

- **First Round:**  
  No past information; cooperate to signal good intentions and encourage mutual cooperation.

- **Last Round:**  
  Defection is dominant as no future rounds exist to incentivize cooperation.

- **Near-Last Round (second to last):**  
  Optional: cooperate or defect depending on willingness to risk last-round loss. Default: cooperate, to sustain payoff if game unexpectedly extends (if unknown).

- **If all players defect last round:**  
  Do not enter infinite mutual defection. Instead, use **forgiveness** mechanism: if defection observed picked up, try cooperating again after 1 round of punishment.

---

## 3. Cooperative Mindset Alignment

- The strategy tries to maintain cooperation as the default.
- Allows punishment to discourage free-riding.
- Forgives occasional defection to restore cooperation quickly, avoiding deadlock.
- Defects only in the last round to maximize self-payoff, recognizing rational backward induction.

---

## Pseudocode

```python
def strategy(history, round, n, r, threshold=0.8):
    # history: list of rounds; each round is list of actions per player ['C'/'D']
    # round: current round index (1-based)
    # n: number of players
    # r: total rounds
    # threshold: cooperation proportion threshold

    if round == 1:
        # First round: cooperate
        return 'C'
    
    if round == r:
        # Last round: defect
        return 'D'

    # Calculate proportion of cooperators in previous round
    prev_round_actions = history[round - 2]  # zero-based indexing
    coop_count = sum(1 for a in prev_round_actions if a == 'C')
    p = coop_count / n

    if p >= threshold:
        # Enough cooperation last round - cooperate
        return 'C'
    else:
        # Too few cooperators last round - defect to punish
        return 'D'
```

---

## Summary

| Round          | Action           | Reason                                  |
|----------------|------------------|-----------------------------------------|
| 1              | Cooperate        | Signal trust                           |
| 2 to r - 1     | Cooperate if ≥80% cooperated previous round; else defect | Maintain conditional cooperation/punishment |
| r (last round) | Defect           | No future incentive to cooperate      |

This strategy balances generosity with conditional enforcement, encouraging mutual cooperation and maximizing overall group payoff in repeated play. It handles edge cases explicitly and aligns clearly with cooperative goals.
'''

description_COOPERATIVE_105 = '''
Below is a detailed cooperative strategy designed for the repeated N-Player Public Goods Game, targeting the promotion and maintenance of mutual cooperation while being robust to exploitation attempts. The strategy relies solely on the observable history of players’ actions (cooperate/defect) and rewards cooperation while punishing defection in a measured way. It is designed to perform well in a tournament against various strategies when only game history and payoff structures are known.

---

## Strategy Name: **Conditional Grim-Trigger with Forgiveness**

### Intuition:
- Start fully cooperative to foster mutual cooperation.
- Continue cooperating as long as everyone cooperated in the previous round.
- If any player defects in a round, punish by defecting for a limited number of rounds (punishment phase).
- After the punishment phase, return to cooperation to give players a chance to re-establish trust.
- In the last round, defect (because no future punishment is possible and incentives align with individual maximization).

---

## 1. Decision Rules (per round t)

**Notation:**
- `t`: current round (1 ≤ t ≤ r)
- `h[t-1]`: vector of actions by all players in previous round (if t > 1), with `c_j` = 1 if player j cooperated, 0 if defected.
- `punish_count`: number of remaining rounds in the punishment phase (initially 0)
- `punishment_length`: fixed integer > 0, determines length of punishment phase after detecting defection (suggested value: 1 or 2)

### Actions per round:

- **Round 1 (t = 1):**
  - **Action:** Cooperate (C)
  - Reason: Start by showing trust and willingness to cooperate.

- **Rounds 2 to r-1 (1 < t < r):**
  - If `punish_count > 0`:
    - **Action:** Defect (D)
    - Then decrement `punish_count` by 1
    - Reason: We are in punishment mode due to recent defection.
  - Else (not in punishment phase):
    - Check previous round’s actions `h[t-1]`:
      - If *all* players cooperated (`∀j: c_j=1`), **Cooperate (C)**
      - Else (any defection detected), set `punish_count = punishment_length` and **Defect (D)**
      - Reason: Punish defectors but only for limited rounds to allow re-cooperation.

- **Last Round (t = r):**
  - **Action:** Defect (D)
  - Reason: No future rounds to enforce cooperation, so defect to maximize final payoff.

---

## 2. Edge Cases and Additional Details

- **First round:**
  - No history, so always cooperate.

- **Detecting defection:**
  - Use observed past round actions since actions are public knowledge.
  - If *any* player defected in round t-1, punishment phase begins.

- **Punishment length:**
  - A short punishment phase (e.g., 1 or 2 rounds) balances deterrence with likelihood of returning to cooperation.
  - Longer punishment risks permanent breakdown; no punishment risks exploitation.

- **Return to cooperation after punishment:**
  - After punishing for `punishment_length` rounds, if no further defection, return to cooperate.
  - This helps repair cooperation and avoid endless retaliation.

- **Handling multiple defections:**
  - If a defection happens during punishment, reset punishment timer.

- **Memory:**
  - The strategy only needs to remember:
    - `punish_count` (rounds left to punish)
    - Previous round actions

---

## 3. Cooperative Mindset Alignment

- Starts fully cooperative and rewards cooperation by cooperating as long as all others cooperate.
- Does not tolerate defection without consequence, protecting against exploitation.
- Forgives defectors after limited punishment, encouraging return to cooperation.
- Defects only when needed to punish or in final round when cooperation incentives vanish.
- Balances individual incentives with group benefit.

---

## 4. Pseudocode

```python
initialize:
    punish_count = 0       # rounds remaining in punishment phase

for t in 1 to r:
    if t == 1:
        # First round
        action = "C"

    elif t == r:
        # Last round
        action = "D"

    else:
        if punish_count > 0:
            # Currently punishing defectors
            action = "D"
            punish_count -= 1
        else:
            # Check previous round actions
            if all players cooperated in h[t-1]:
                action = "C"
            else:
                # Defection detected, start punishment
                punish_count = punishment_length - 1  # we defect this round + (punishment_length-1) more rounds
                action = "D"

    play action
```

---

## 5. Why This Strategy?

- It resembles a classic **grim-trigger** style cooperation strategy but with **limited punishment** for flexibility.
- It can sustain cooperation in equilibrium if the multiplication factor k is sufficiently large to reward cooperation.
- Forgiveness supports recovery from accidental or strategic mistakes and enables cooperation to be stable in noisy or mixed environments.
- Defection in last round is a standard backward induction outcome, unavoidable.

---

**In summary:**

- Cooperate initially.
- Cooperate if everyone cooperated previously.
- If anyone defects, defect for a short fixed number of rounds.
- After punishment, try cooperating again.
- Defect last round.

This balances cooperation, deterrence of free-riding, and adaptive forgiveness, maximizing expected payoffs in tournaments against independent, rational players with no external communication or coordination.
'''

description_COOPERATIVE_106 = '''
Below is a cooperative strategy designed for the N-player public goods game as described.

---

### Strategy Name: **Conditional Cooperation with Gradual Punishment and Forgiveness**

---

### Intuition

- **Goal:** Sustain cooperation to maximize joint payoffs over r rounds.
- Start cooperatively on round 1 to signal willingness.
- Continue cooperating as long as others mostly cooperate.
- Punish defection by temporarily defecting to discourage free-riding.
- Forgive after punishment to avoid permanent mutual defection.
- In the last round, defect because no future repercussions exist (backward induction).

---

### Decision Rules

**Notation:**

- Let `t` be the current round (1 ≤ t ≤ r).
- Let `history_i` be the past actions of player i for rounds 1 to t-1.
- Let `C_t` = number of players who cooperated in round t.
- Define a threshold cooperation rate `τ = 0.6` (can be tuned).
- Define a punishment length `p = 1` round (punish defectors for 1 round).
- Maintain a punishment flag indicating whether currently punishing.

---

### Algorithm in Words

1. **Round 1: Cooperate**  
   No history exists. Begin by cooperating to establish mutual trust.

2. **Rounds 2 to r - 1: Conditional Cooperation**
   - Calculate the fraction of players who cooperated in the previous round:  
     `f = (number of cooperators in t-1) / n`
   - If `(f >= τ)` and **not currently punishing**, cooperate
   - If `(f < τ)` or you observed defection by others, enter punishment mode:
     - Defect for `p` rounds to discourage free riding
     - After punishment rounds, resume cooperation to give second chance

3. **Round r (Last round): Defect**  
   No future to influence behavior, defect to maximize immediate payoff.

---

### Handling Edge Cases

- **First round:** No history, always cooperate.
- **No cooperation by others in previous round:** Enter punishment.
- **Intermittent defections:** Use punishment to signal disapproval but resume cooperation to avoid permanent defection.
- **If multiple punishment triggers occur:** Reset punishment duration for each new defection detected.
- **If only a minority defected (below threshold):** Still cooperate, assuming noise or error.

---

### Pseudocode

```python
# Parameters
n = <number_of_players>
r = <number_of_rounds>
k = <multiplication_factor>
tau = 0.6          # Cooperation threshold
punish_length = 1  # Rounds to punish
punish_counter = 0 # Countdown for punishment

for t in range(1, r + 1):
    if t == 1:
        action = 'C'  # Cooperate initially
    elif t == r:
        action = 'D'  # Last round defect
    else:
        if punish_counter > 0:
            action = 'D'            # Punish by defecting
            punish_counter -= 1
        else:
            # Calculate fraction of cooperators last round
            last_round_cooperators = count_cooperators(t - 1)
            coop_fraction = last_round_cooperators / n
            
            if coop_fraction >= tau:
                action = 'C'       # Cooperate if enough cooperators
            else:
                # Enter punishment
                action = 'D'
                punish_counter = punish_length - 1  # Already punish this round
```

---

### Cooperative Mindset Justification

- This strategy is **pro-social**: starts by cooperating, rewards cooperation by cooperating back.
- It is **conditional**: punishes defection but does not punish forever, allowing others to return to cooperation.
- It is **forgiving**: avoids endless retaliation cycles, promoting long-term mutual cooperation.
- It uses perfect information about past rounds to base decisions fairly.
- It defects only in last round due to no incentives to cooperate then (standard backward induction).
- The threshold `τ` balances tolerance — erring on generous cooperation unless defection is widespread.

---

### Summary

| Round          | Action                         | Reason                          |
|----------------|--------------------------------|--------------------------------|
| 1              | Cooperate                      | Establish cooperative baseline |
| 2 to r - 1     | Cooperate if ≥τ cooperate last round; else Defect as punishment | Encourage cooperation, punish defection temporarily |
| r (last round) | Defect                        | No incentive to cooperate last round |

---

This strategy should effectively sustain cooperation among rational players who also aim to maximize total payoffs over repeated rounds, while robust to occasional defections or noise.
'''

description_COOPERATIVE_107 = '''
**Cooperative Strategy for N-Player Public Goods Game**

---

### Core Idea
Foster cooperation by starting cooperatively, punishing defection briefly to discourage free-riding, and forgiving quickly to restore cooperation. This mimics a "tit-for-tat"-style logic generalized to multiple players. The strategy aims to:

- Maximize joint payoffs by encouraging cooperation.
- Punish defections to deter exploitation.
- Forgive to avoid permanent breakdown of cooperation.
- Defect only if clearly exploited.
- Coordinate based on observable past actions alone.

---

### Strategy Description

#### Initialization (Round 1)
- **Always Cooperate (C).**

Rationale: Without any history, choose cooperation to encourage others to do the same and maximize group payoffs.

#### For Round t ∈ {2, ..., r-1}
1. **Observe all players' actions in the previous round (t-1).**

2. **Decision Rule:**
   - If in previous round *all* other players cooperated, **Cooperate (C)** this round.
   - Else if *any* player defected in previous round (i.e., total cooperators < n), **Defect (D)** this round *to punish*.
   
3. **After defecting for punishment,** **forgive quickly:**
   - In the round after punishing, return to cooperation *unless* defections continue.

4. **Punishment duration:**
   - Only punish for **one round** per defection observed.
   
5. **Track defections history cumulatively:**
   - If opponents keep defecting repeatedly, continue defecting.
   - If opponents return to full cooperation, return to cooperating.

---

#### In the Last Round (Round r)
- **Defect (D).**

Rationale: With no future rounds, cooperation incentive disappears. Defection maximizes immediate self-payoff.

---

### Intuition

- By cooperating initially, the strategy helps to build cooperation.
- By defecting immediately after observing a defection, it signals clear willingness to punish free-riders.
- By forgiving quickly (one round of punishment), it allows the group to return to cooperation and avoids retaliation wars.
- Defecting last round prevents exploitation as no future consequences exist to enforce cooperation.

---

### Pseudocode

```python
def cooperative_strategy(history, current_round, total_rounds, num_players):
    # history: list of lists of length (current_round - 1)
    # each element is a list of player actions in that round (e.g. ['C', 'D', 'C', ...])

    # Last round defect
    if current_round == total_rounds:
        return 'D'

    # First round, no history
    if current_round == 1:
        return 'C'

    # Analyze previous round's actions
    prev_round = history[-1]  # actions list length == num_players

    # Count number of cooperators in previous round
    coop_count = sum(1 for action in prev_round if action == 'C')

    # If all cooperated last round, cooperate this round
    if coop_count == num_players:
        return 'C'

    # Otherwise, defect to punish

    # Check if just punished in previous round to avoid repeated punishment
    # Identify own last action
    own_last_action = history[-1][my_index]  # assuming fixed player index my_index

    # If just defected last round as punishment and opponents still defecting, continue defecting
    # Else, forgive by cooperating

    # We need history of last two rounds to check this
    if current_round >= 3:
        prev_prev_round = history[-2]
        prev_coop_count = sum(1 for action in prev_prev_round if action == 'C')

        # If opponents defected two rounds ago and we defected last round,
        # but now opponents cooperate last round, forgive
        if prev_coop_count < num_players and own_last_action == 'D' and coop_count == num_players:
            return 'C'

    # Default: defect to punish
    return 'D'
```

**Note:** The pseudocode references `my_index`—in actual implementation, this is your player index to track your own previous actions.

---

### Summary Table of Behavior

| Round | Observation (Previous Round)     | Action                 |
|-------|---------------------------------|------------------------|
| 1     | No history                      | Cooperate (C)          |
| t < r | All cooperated                  | Cooperate (C)          |
| t < r | Defection(s) observed           | Defect (D) (punish)    |
| t < r | Opponents returned to cooperation after punishment | Forgive (C) |
| r     | Last round                     | Defect (D)             |

---

### Why This Strategy?

- **Cooperation:** Initial and ongoing cooperation under mutual cooperation maximize payoff.
- **Conditional Punishment:** Quick sanction against defectors deters ongoing defection.
- **Forgiveness:** Avoids endless retaliation cycles and supports restoration of cooperation.
- **Defection in Last Round:** Avoids being exploited when no future cooperation incentives exist.

This strategy is analogous to a **"Generous Tit-for-Tat"** adapted to an n-player public goods setting.

---

If all players adopt this strategy, the group will tend toward sustained cooperation yielding high payoffs.

If others defect, the strategy punishes but quickly attempts forgiveness to stabilize cooperation.

This balance aligns neatly with cooperative behavior in repeated public goods contexts under standard assumptions.
'''

description_COOPERATIVE_108 = '''
**Strategy Name:** Conditional Cooperate-and-Forgive (CCF)

---

### Intuition

- The **best collective outcome** occurs when all players cooperate each round.
- However, players have incentive to defect and free-ride, since defectors earn more if others cooperate.
- To sustain cooperation in a repeated setting without communication, a strategy should:
  - Cooperate initially to signal willingness.
  - Punish defection to discourage unilateral free-riding.
  - Forgive defections after punishment to restore cooperation.
- Since this is a finite repeated game, cooperation tends to unravel near the end (last rounds), so the strategy should carefully handle endgame behavior.

---

### Decision Rules

**Notation:**
- Let **t** ∈ {1,...,r} denote the current round.
- Let **History(t-1)** be all players' actions in rounds 1 to t-1.
- Let **OppCoopCount(t-1)** be the number of opponents who cooperated in round t-1 (i.e., excluding self).
- Let **AllCoop(t-1)** be `true` if all opponents cooperated last round, else `false`.

---

### 1. First Round (t=1)
- Cooperate.
  
*Rationale:* Signal cooperative intent and establish baseline mutual cooperation.

---

### 2. Intermediate Rounds (1 < t < r)
- If **last round all opponents cooperated**, cooperate again.
  
- Else if **one or more opponents defected last round**, defect this round (punishment).
  
- If punishment was applied in the previous round (t-1), then **forgive** and cooperate now, regardless of last round actions.
  
---

### 3. Last Round (t = r)
- Defect.
  
*Rationale:* In the final round, no future rewards or punishments exist to sustain cooperation. Defecting maximizes individual payoff since cooperating yields no future benefits.

---

### Summary of State/Memory needed

- Track if punishment is currently active (i.e., did we defect last round to punish?
- To "forgive" after one round of punishment, cooperation resumes.

---

### Pseudocode

```pseudo
Initialize:
  punishment_active = false

For each round t in 1 to r:
    if t == 1:
        # First round: cooperate to start mutual cooperation
        action = C
        punishment_active = false

    else if t == r:
        # Last round: defect to maximize individual payoff
        action = D
        punishment_active = false

    else:
        # Intermediate rounds
        if punishment_active:
            # Forgive after enforcing punishment once
            action = C
            punishment_active = false

        else:
            # Check if all opponents cooperated last round
            if AllCoop(t-1):
                action = C
                punishment_active = false
            else:
                # One or more opponents defected last round -> punish now
                action = D
                punishment_active = true

    Play(action)
```

---

### Explanation of Behavior

- Start fully cooperatively.
- As long as everyone cooperates each round, continue cooperating.
- Upon detecting defectors last round, punish by defecting once.
- After punishment, allow forgiveness by cooperating again.
- In last round, defect regardless.
  
This creates a **"tit-for-tat with forgiveness"** style strategy adapted to public goods games with multiple players and the finite horizon.

---

### Why is this cooperative?

- The strategy aims to maintain mutual cooperation for as many rounds as possible, maximizing group and individual payoffs.
- Punishment provides deterrence against unilateral defection.
- Forgiveness avoids endless retaliation cycles, enabling re-establishment of cooperation.
- By cooperating first, the strategy signals willingness to cooperate from the start.

---

### Handling Edge Cases

- **If multiple players defect simultaneously:** The punishment phase triggers and defects this round; after that, cooperates again, promoting return to cooperation.
- **If others always defect:** This strategy will defect after the first round of cooperation, avoiding being exploited repeatedly.
- **If others cooperate irregularly:** This strategy will respond by defecting once after defection, but tries to restore cooperation quickly.
- **In small groups or near k ≈ n:** The incentive to cooperate is stronger; this strategy leverages that by remaining cooperative as long as others do.

---

### Potential Extensions (Optional)

- Implement a tolerance level (e.g., tolerate a single defector without punishing).
- Gradually escalate punishment if defection persists.
- But these add complexity; the base **CCF** strategy balances simplicity and cooperation effectively in the given setting.

---

**In summary:** The **Conditional Cooperate-and-Forgive (CCF)** strategy cooperates first, mirrors the group behavior, punishes defection once, forgives quickly, and defects in the final round, aligning well with the cooperative mindset needed for public goods games without communication or coordination devices.
'''

description_COOPERATIVE_109 = '''
Here is a cooperative strategy for the repeated N-Player Public Goods Game that aims to sustain cooperation while guarding against persistent defection. It is inspired by the logic of "Tit-for-Tat" but adapted for a multiplayer public goods environment without direct communication or coordination devices.

---

## Strategy Name: Conditional Cooperation with Forgiveness (CCF)

---

## Intuition:

- Start cooperatively to encourage maximum group payoff.
- Reward cooperation and punish defection proportionally.
- Forgive occasional defections to avoid causing a downward spiral of mistrust.
- Return to full cooperation if the group recovers cooperation.
- In the last round, defect to avoid being exploited (standard backward induction logic in finitely repeated games).
  
---

## Decision Rules:

### Variables tracked at round t:

- History of all players’ actions up to round t-1.
- `C_count_t-1`: Number of cooperators in the previous round (t-1).
- `defect_ratio_t-1`: Fraction of defectors in the previous round = (n - C_count_t-1) / n.
- `defect_threshold`: A tolerance threshold for defections (e.g., 0.3).
- `forgiveness_window`: Number of recent rounds to consider forgiving (e.g., last 2 rounds).
- `cooperation_window`: Number of recent rounds to consider resuming cooperation after punishment (e.g., last 2 rounds).
  
### Initialization:

- **At round 1**: Cooperate.

### For rounds 2 to r-1:  

- If previous round had a *low* number of defectors (defect_ratio_t-1 ≤ defect_threshold),  
  **Cooperate**.

- Else if defect_ratio_t-1 > defect_threshold (meaning many defectors last round):  
  - **Defect** as punishment for the current round.

- Exception (Forgiveness):  
  - If in the last `forgiveness_window` rounds defections have reduced below the threshold,  
    switch back to **Cooperate** to encourage renewed cooperation.

### For the last round (t = r):

- **Defect**:  
  In the last round, defecting maximizes personal payoff since no future repercussions.

---

## Pseudocode

```python
def CCF_strategy(t, history, n, r, defect_threshold=0.3, forgiveness_window=2, cooperation_window=2):
    # Input:
    # t: current round (1-based)
    # history: list of length (t-1), each element a list of length n with each player's action 'C' or 'D'
    # n, r: game parameters
    # defect_threshold: max tolerated fraction of defectors to still cooperate
    # forgiveness_window, cooperation_window: look-back windows for forgiving and resuming cooperation
    
    if t == 1:
        return 'C'  # Start cooperatively
    
    if t == r:
        return 'D'  # Defect in the last round
    
    # Calculate defect ratio in previous round
    prev_round = history[t-2]  # zero-based index
    defectors_prev = sum(1 for a in prev_round if a == 'D')
    defect_ratio_prev = defectors_prev / n
    
    # Check the recent rounds for forgiveness/resumption of cooperation
    recent_history = history[max(0, t - 1 - forgiveness_window):t-1]  # last forgiveness_window rounds
    recent_defect_ratios = [
        sum(1 for a in round_hist if a == 'D') / n for round_hist in recent_history
    ]
    
    # If defect ratio in previous round is low, cooperate
    if defect_ratio_prev <= defect_threshold:
        return 'C'
    
    # If defect ratio high, punish by defecting,
    # but forgive if defect ratio has improved in recent rounds
    if any(dr <= defect_threshold for dr in recent_defect_ratios):
        return 'C'  # Forgive and return to cooperation
    
    return 'D'  # Punish persistent defection
```

---

## Further Explanation

- **Starting with cooperation** promotes maximization of public goods.
- **Punishing when many defectors appeared** signals that free-riding is detected.
- **Forgiveness prevents endless mutual defection** by switching back to cooperation when the group shows improvement.
- **Defection in the last round** reflects standard backward induction: since there is no future, cooperation is not individually rational there.
- Using a **defection threshold** (e.g., 30%) allows tolerance of small noisy defections without retaliating.
- Adjusting parameters (defect_threshold, forgiveness_window) can tune the strategy’s aggressiveness or leniency.
- This strategy neither punishes a single defector too harshly nor becomes exploited by perpetual defectors.

---

## Cooperative Mindset Alignment

- Always attempts to establish and maintain cooperation.
- Punishes only when defection is significant and persistent.
- Forgives when cooperation resumes.
- Acts to maximize long-term group payoff, not just short-term personal gain.
- Recognizes game’s finite horizon and defects in the last round accordingly.

---

This strategy should work well in a tournament of various unknown strategies by encouraging mutual cooperation as the primary mode but protecting itself against exploitation.
'''

description_COOPERATIVE_110 = '''
Below is a cooperative strategy tailored to the described repeated N-player public goods game. This strategy is inspired by reciprocal cooperation principles (akin to a "grim-trigger" or "tit-for-tat" family), adapted to an environment with n ≥ 2 players and no explicit communication.

---

### Strategy Name: **Conditional Cooperation with Forgiveness**

---

## Intuition

- Cooperate initially and as long as other players cooperate.
- If defection is detected (any player defected in the previous round), defect once in punishment.
- Then *forgive* and return to cooperation if others resume cooperating.
- In the last round, defect (since no future retaliation is possible).
  
This encourages stable cooperation while discouraging exploitation.

---

## Detailed Description

### Decision Rules per Round t (1 ≤ t ≤ r)

1. **Round 1 (t=1):**  
   - **Play C (Cooperate).**

2. **Rounds 2 ≤ t < r (intermediate rounds):**  
   - If in the immediately previous round (t-1), **all players cooperated**:  
     → Play C.  
   - Else if in round (t-1), **any player defected**:  
     - If **this player defected in round (t-1)** (i.e., already punished last round):  
       → Play C (forgive and return to cooperation).  
     - Else (if this player cooperated in the previous round and sees defection):  
       → Play D (punish defectors once by defecting this round).

3. **Last round (t = r):**  
   - **Play D (defect),** since there is no future round to incentivize cooperation, and defection maximizes immediate payoff.

---

## Rationale

- Cooperate initially to establish trust and mutual benefit.
- Punish defections by defecting once to signal disapproval and remove unilateral incentives to defect.
- Forgive after one-round punishment to allow restoration of cooperation, preventing endless cycles of retaliation.
- Defect last round to maximize individual payoff when retaliation is impossible.

This aligns with cooperation but remains robust against exploitation and ensures incentives for re-cooperation.

---

## Pseudocode

```python
# Inputs per round t:
# history: list of rounds, each round is list of players' actions ['C' or 'D']
# self_index: player's own index (0-based indexing)
# r: total number of rounds

def decide_action(history, self_index, r):
    t = len(history) + 1  # current round number (1-based)
    
    if t == 1:
        # First round: cooperate
        return 'C'
        
    elif t == r:
        # Last round: defect
        return 'D'
        
    else:
        prev_round = history[-1]  # actions from previous round, list of 'C'/'D'
        
        all_cooperated = all(action == 'C' for action in prev_round)
        self_defected_prev = (prev_round[self_index] == 'D')
        
        if all_cooperated:
            # All cooperated last round, so cooperate
            return 'C'
        else:
            # At least one defection last round
            if self_defected_prev:
                # Already punished last round, now forgive and cooperate
                return 'C'
            else:
                # Cooperated last round but others defected, punish by defecting now
                return 'D'
```

---

## Examples of Behavior

- **All cooperate every round except one defector in round 3:**  
  → The next round, cooperators defect once as punishment.  
  → Then forgiveness kicks in, and cooperation resumes if no new defection occurs.

- **If defection continues indefinitely:**  
  → This player alternates between cooperating once forgiveness is given and defecting once punishment per detected defection, stabilizing at mutual defection after repeated breakdown.

- **In the final round:**  
  → Defect regardless, to maximize last-round payoff.

---

## Cooperative Nature

- Starts with full cooperation.
- Quickly punishes defectors (discourage free-riding).
- Allows repair of cooperation by forgiving after one punishment round.
- Avoids endless cycles by restricting punishment to one round.
- Recognizes end of interaction by defecting last round strategically.

---

### Summary

This strategy balances cooperation, discipline, and forgiveness, fully exploiting the repeated setting to sustain cooperation and maximize social welfare while safeguarding against exploitation. It respects the imperfect trust environment and no communication conditions.
'''

description_COOPERATIVE_111 = '''
Below is a design for a **Cooperative, Conditional Reciprocity Strategy** tailored for the repeated N-player Public Goods game specified. This strategy aims to sustain cooperation by rewarding cooperation and punishing defection, while also accounting for uncertainty about others’ actions and the structure of the game.

---

## Strategy Name: *Reciprocal Conditional Cooperation (RCC)*

---

### Intuition & Goals:

- **Start with Cooperation:** Begin by cooperating to establish cooperation given the cooperative mindset and payoff incentives.
- **Reciprocate Cooperation:** Continue cooperating as long as others mostly cooperate.
- **Punish Defection:** Punish defectors by defecting following observed defections.
- **Forgiveness & Recovery:** Allow return to cooperation if good behavior resumes to avoid endless punishment cycles.
- **Prepare for Endgame:** Defection in the last round maximizes immediate payoffs, so cooperate until the last round, then defect to prevent exploitation.
  
---

### Detailed Strategy Description:

**Notation:**

- Let `round` ∈ {1, ..., r} be the current round.
- Let `history` be the list of past rounds, where each round records each player’s action (C or D).
- Let `others_actions_t` be the vector of all other players’ actions in round `t`.
- Let `my_action_t` be my action in round `t`.

---

### Decision Rules per Round:

1. **Round 1: Cooperate.**  
   - No history to rely on, so cooperate to initiate mutual cooperation.

2. **Rounds 2 to r-1 (Intermediate rounds): Conditional Cooperation.**
   - Compute the **cooperation rate** of *all other players* in the previous round:  
     `prev_coop_rate = (# of other players who played C in round (round - 1)) / (n - 1)`
   - Define a **threshold parameter** for “sufficient cooperation” (suggested 0.7 to 0.8) to allow some noise/errors.
   - **Decision Rule:**  
     - If `prev_coop_rate ≥ threshold`, **Cooperate** (reward cooperation).
     - Else, **Defect** (punish defection).

   - This directs cooperation to be conditional on the group's recent cooperative behavior but tolerates some defections.

3. **Last Round (round = r): Defect.**
   - The last round is a one-shot simultaneous move.
   - Cooperation here is vulnerable to exploitation, so defect to maximize immediate payoff.

---

### Handling Edge Cases and Noise:

- **High Defection Noise:**  
  - If some defections seem accidental (e.g., small % defecting), use threshold <1 to tolerate minor defections and sustain cooperation.
- **Reintegration after Punishment:**  
  - Since the game is repeated and only actions are observable, this strategy is forgiving in that whenever sufficient cooperation is observed again, it returns to cooperating.
- **Multiple Defectors:**  
  - No special adjustment beyond the threshold rule; punishes collective defection proportionally.

---

### Summary in Pseudocode:

```python
def RCC_strategy(round, history, n, r, threshold=0.75):
    """
    Decide action for current round using Reciprocal Conditional Cooperation.
    round: current round number (1 to r)
    history: list of past rounds; each round is a list of length n with actions 'C' or 'D'
    n: number of players
    r: total rounds
    threshold: cooperation threshold to decide cooperation
    
    Returns: 'C' or 'D'
    """
    
    # First round: cooperate
    if round == 1:
        return 'C'
    
    # Last round: defect
    if round == r:
        return 'D'
    
    # Intermediate rounds: conditional cooperation based on previous round
    prev_round_actions = history[-1]  # actions in round (round - 1)
    
    # Remove own action from consideration (if present); if not, consider all others
    # Assuming index i is self; if unknown, just consider all except self
    # Since self action unknown before decision, can't exclude self. Use all except self after first round.
    
    # Count number of cooperating others
    # Assume we know our own index 'self_idx' (0-based)
    self_idx = get_my_index()  # Function provided by environment (or assign 0 if unknown)
    others_actions = [a for idx, a in enumerate(prev_round_actions) if idx != self_idx]
    num_cooperating_others = sum(1 for a in others_actions if a == 'C')
    
    coop_rate = num_cooperating_others / (n - 1)
    
    if coop_rate >= threshold:
        return 'C'  # Reward cooperation
    else:
        return 'D'  # Punish defection
```

---

### Why This Strategy Is Cooperative:

- **Starts with cooperation to foster building trust.**
- **Only defects when a significant share of others defected previously, signaling breach of cooperation.**
- **Allows forgiveness by returning to cooperation when others cooperate again.**
- **Ends with defection to avoid exploitation in final round.**
- **Threshold less than 1 allows noise and imperfect play, improving robustness.**

---

### Potential Variations / Enhancements (optional):

- Adjust threshold dynamically based on observed cooperation rates over multiple past rounds.
- Use a memory window >1 round for smoother response to strategies.
- If the environment provides, estimate opponents' types and adapt threshold.
  
However, the above specification suffices given the problem constraints and assumptions.

---

# Summary

This *Reciprocal Conditional Cooperation* strategy:

- Cooperates initially.
- Cooperates in subsequent rounds if most others cooperated previously.
- Defects in the final round.
- Responds proportionally to the group’s cooperative behavior.
- Tolerates some defection to avoid unnecessary punishment cycles.

This balances cooperative incentives with safeguards against sucker exploitation and last-round defection, aligning well with the cooperative mindset desired.
'''

description_COOPERATIVE_112 = '''
**Cooperative Strategy Design for N-Player Public Goods Game**

---

### Overview

The goal is to design a strategy that *promotes mutual cooperation*, which maximizes collective payoffs, while also being *resilient* to defections by others. The strategy must be:

- Clear about when to **cooperate (C)** and **defect (D)**
- Handle special rounds: **first** and **last**
- Account for others’ behavior given **perfect information and no communication**

---

### Key Observations

- If all cooperate every round, each earns payoff = \((k/n)*n = k\) per round.
- Defection benefits the defector in a round but reduces collective payoff.
- Cooperation is collectively better, but individual incentives to defect exist.
- Perfect info allows conditioning behavior on past rounds.
- No communication means the only "signal" is others' historical cooperation.

---

### Strategy: **Conditional Grim Trigger with Forgiveness ("Cooperative Conditional Trust")**

---

#### Intuition

- **Start cooperatively.**
- **Continue cooperating only if all other players cooperated in *previous round*.**
- If any player defects, **punish by defecting in the next round but give a chance to return to cooperation if players resume cooperation.**
- Being too harsh or too forgiving harms payoffs; this balanced approach tries to maximize joint returns, punish defectors, but repair cooperation quickly.

---

### Pseudocode

```python
# Inputs:
# - r: total number rounds
# - n: total players
# - history: list of rounds, each round is a list of player actions ['C','D',...], indexed [round][player]

# Output: 'C' or 'D' for current round t

def cooperative_strategy(t, player_index, history):
    if t == 1:
        # 1. First round: cooperate unconditionally
        return 'C'
    
    if t == r:
        # 2. Last round: defect (backward induction)
        # Cooperation in last round yields no future benefit
        return 'D'
    
    # 3. For rounds 2 to r-1:
    last_round_actions = history[t-2]  # actions at round t-1
    
    # 4. Check if everyone cooperated last round
    if all(action == 'C' for action in last_round_actions):
        # Everyone cooperated last round => cooperate this round
        return 'C'
    
    # 5. If defect(s) occurred last round:
    # Check if the previous round (t-2) had full cooperation
    if t > 2:
        prev_round_actions = history[t-3]
        if all(action == 'C' for action in prev_round_actions):
            # Punishment round: defect once after defection detected
            return 'D'
        else:
            # Forgiveness round: check if others cooperated in last round except self
            if last_round_actions[player_index] == 'C' and sum(1 for a in last_round_actions if a == 'C') >= n - 1:
                # Most players cooperated in last round, return to cooperation
                return 'C'
            else:
                # Otherwise keep defecting to punish persistent defectors
                return 'D'
    else:
        # If only t=2 and defection detected at t=1, punish once
        return 'D'
```

---

### Explanation of Decision Rules

| Round        | Player action                                                         | Rationale                                  |
|--------------|-----------------------------------------------------------------------|--------------------------------------------|
| **1**        | Always **Cooperate (C)**                                             | Start on a cooperative note                 |
| **Middle (2 to r-1)** | If *all players* cooperated the previous round, cooperate again. | Maintain mutual cooperation                  |
|              | If *any defection* last round, defect **once** to punish, then test if cooperation is restored | Punish defectors but allow repair to cooperation |
|              | Return to cooperation if others mostly cooperate again                | Avoid endless retaliation                    |
| **Last (r)** | Always **Defect (D)**                                                 | No future incentive to cooperate             |

---

### Why This Strategy is Cooperative?

- It **starts cooperatively** to signal trust.
- It **rewards mutual cooperation** by cooperating as long as others cooperate.
- It **punishes defection** but only briefly, allowing return to cooperation.
- It does **not tolerate persistent defection** indefinitely, keeping incentives aligned.
- It **defects last round** which aligns with classic backward induction logic, avoiding being exploited.

---

### Handling Edge Cases

- **First round:** No history — cooperate unconditionally.
- **Last round:** Mutual defection expected; cooperate to last round yields no future benefit (to avoid exploitation).
- **In-between rounds with mixed past actions:** Punish once, then forgive if cooperation restarts.
- **Multiple defectors:** Defect accordingly until cooperation mostly restored.
- **All defect from start:** Defect every round except first where cooperate is default; will get minimal payoff but consistent with strategy logic.

---

### Summary

This strategy implements a *conditional cooperation* policy broadly inspired by Tit-for-Tat and Grim Trigger, but with a forgiveness twist suitable for noisy environments (here no noise, but allows more robust cooperation against occasional lapses by others). It aligns incentives towards maximizing the public good while protecting against free-riders.

---

If you want, I can provide a formal specification or adapt the pseudocode further.
'''

description_COOPERATIVE_113 = '''
Below is a detailed cooperative strategy designed for the N-Player Public Goods Game under the conditions described.

---

## Strategy Name: **Forgiving Grim Trigger with Tit-for-Tat Forgiveness**

---

## Intuition and Goals:
- Maximize collective payoff by sustaining cooperation.
- Start by cooperating to signal willingness.
- Punish defection to discourage free-riding.
- Forgive occasional defections to avoid endless mutual punishment (which collapses cooperation).
- Cooperate in the last round because future punishment threats no longer apply, but optionally defect if distrust is very high.
- Use observed history only (actions in previous rounds) as the basis for decisions.

---

## Detailed Decision Rules

### Notation:
- Let `t` ∈ {1,...,r} be the current round number.
- Let `A_t` = (a_1,t, a_2,t, ..., a_n,t) be the vector of all players' actions in round t.
- Let `C_t` be the set of players who cooperated in round t.
- Let `D_t` be the set of players who defected in round t.
- Let `me` denote yourself (player i).

---

### 1. **Round 1: Always Cooperate**

- You start cooperative to establish a baseline of goodwill.

```pseudocode
if t == 1:
    action = C
```

---

### 2. **Rounds 2 to r-1: Conditional Cooperation with Forgiving Trigger**

- For each subsequent round, check if all other players cooperated in the **previous** round.
- If ALL others cooperated in previous round → cooperate.
- If SOME players defected in previous round:
  - If you defected in previous round yourself (as punishment), **forgive** by cooperating now to seek return to cooperation.
  - Otherwise, defect this round (to punish defectors).
- This is a **"forgiving grim trigger"** with a one-round punishment phase, then forgiveness.

**Rationale:**  
- If others cooperate, keep cooperating.  
- If others defect, punish by defecting once.  
- After punishing yourself (defecting), forgive and try cooperating again.  
- This avoids endless cycles of defection and encourages return to cooperation.

```pseudocode
else if 2 <= t <= r-1:
    if all players in {1,...,n}\{me} cooperated in round t-1:
        action = C
    else:
        if my action in round t-1 == D:
            # I was punishing in last round; now forgive
            action = C
        else:
            # Punish defectors
            action = D
```

---

### 3. **Round r (Last Round): Conditional Cooperation or Defection**

- In the last round, the future punishment threat disappears.
- Two possible approaches:

**Option A (More Cooperative):** Cooperate regardless, hoping to maximize collective payoff.

**Option B (More Self-Interested):** Defect if any player defected in final previous round (retaliate, no incentive left to cooperate).

**Proposed approach:** Cooperate in last round if previous round cooperation was mostly intact; otherwise defect to avoid being exploited.

```pseudocode
else if t == r:
    # Count number of cooperators in round r-1 among others
    coop_others = number of players in {1,...,n}\{me} who cooperated in round r-1

    if coop_others >= (n-1)/2:    # majority cooperated last round
        action = C
    else:
        action = D
```

---

## Summary Table of Decision Logic

| Round           | Condition                                              | Action                      |
|-----------------|--------------------------------------------------------|-----------------------------|
| 1               | Always                                                | Cooperate (C)               |
| 2 to r-1        | If *all* others cooperated in previous round           | Cooperate (C)               |
|                 | Else if I defected last round (punishing)              | Forgive → Cooperate (C)     |
|                 | Else (need to punish defectors)                         | Defect (D)                  |
| r (last round)  | If majority of others cooperated last round             | Cooperate (C)               |
|                 | Else                                                   | Defect (D)                  |

---

## Behavioral Properties

- **Cooperative:** Encourages full cooperation as default.
- **Retaliatory:** Punishes defection but only for one round.
- **Forgiving:** Quickly returns to cooperation after punishment to avoid permanent breakdown.
- **Risk Aware at End:** Recognizes absence of future rounds limits cooperation incentives and adapts accordingly.
- **Transparent:** Relies solely on observable history, no assumptions about communication or trust beyond actions.

---

## Pseudocode Summary

```pseudocode
function decide_action(t, history):
    # history: list of (A_1, A_2, ..., A_{t-1}), each A_t is action vector for round t

    if t == 1:
        return C

    previous_round = history[t-2]
    my_prev_action = previous_round[me]
    others_prev_actions = [previous_round[j] for j in range(n) if j != me]

    if 2 <= t <= r-1:
        if all(action == C for action in others_prev_actions):
            return C
        else:
            if my_prev_action == D:
                # I was punishing: forgive now
                return C
            else:
                # Punish defectors
                return D

    else if t == r:
        coop_count = sum(1 for action in others_prev_actions if action == C)
        if coop_count >= (n-1)/2:
            return C
        else:
            return D
```

---

## Additional Notes

- The forgiveness mechanism limits escalation of defection cycles.
- This strategy runs the risk of being exploited by systematic defectors who never cooperate.
- However, due to the punishment one round after defection, exploitation is costly.
- In tournaments, this strategy tends to produce high collective payoffs in environments with many cooperative players, and reasonable resilience against defectors.

---

If you want, I can help outline variants or extensions such as longer punishment phases or risk-averse endgame behavior. Let me know!
'''

description_COOPERATIVE_114 = '''
Below is a designed **cooperative strategy** for the repeated N-player public goods game described. This strategy aims to sustain mutual cooperation through conditional cooperation and punishment of defections, and to incentivize restoring cooperation. 

---

## Strategy name: **Conditional Cooperation with Forgiveness (CCF)**

---

### 1. Conceptual overview

- **Goal:** Achieve and maintain full cooperation each round (everyone contributes).
- **How:** 
  - Start cooperatively in round 1.
  - Continue to cooperate if *everyone cooperated* in the *immediately preceding round*.
  - If any defection was observed in the previous round, punish by defecting this round.
  - If punishment is happening, then after one full round of punishment, attempt to return to cooperation to allow restoration of mutual cooperation.
- **Rationale:** 
  - Cooperation yields the highest group payoff.
  - Defection yields higher short-term payoff individually but harms group.
  - Punishment deters defection.
  - Forgiveness allows returning to cooperation and avoids endless mutual defection.
- **Edge considerations:** 
  - First round: cooperate by default (no history).
  - Last round: cooperate always, since no punishment possible in future rounds, promoting cooperation if possible or at least avoiding unnecessary defection loss.
  - In any round after round 1, decision depends only on previous round’s full cooperation or not.

---

### 2. Formal decision rules

#### Notation:

- r: total rounds
- t: current round, t ∈ {1, 2, ..., r}
- A_j,t: observed action of player j in round t, in {C, D}
- FULL_COOP(t): True if all players cooperated in round t, else False
    - FULL_COOP(t) = (∀ j∈{1..n}, A_j,t = C)

---

### 3. Decision rule pseudocode

```
for each round t = 1 to r:
    if t == 1:
        # No history: start cooperative
        action_i,t = C

    else if t == r:
        # Last round: cooperate to maintain maximal group outcome
        action_i,t = C

    else:
        if FULL_COOP(t-1) == True:
            # Everyone cooperated last round, continue cooperating
            action_i,t = C
        else:
            # Defection(s) observed last round, punish by defecting this round
            action_i,t = D
            
            # But to allow restoration of cooperation, in the round after punishment, cooperate
            # This logic is handled in next round:
            # if defection seen in t-1, defect now and cooperate in t+1
            
            # This requires tracking whether "punishment round" is happening
            # Implemented by: Punish one round of defection, then attempt cooperation again
            
            # So, if in round t-1 defection happened, defect this round t
            # In round t+1 (if t+1 < r), cooperate again; 
            # That is naturally implemented by checking last round full cooperation
            # Because after punishment round, if everyone cooperates, then next rounds are cooperative
```

---

### 4. Strategy summary in prose

- **Round 1:** Cooperate to signal willingness.
- **Rounds 2 to r-1:** 
  - If last round was unanimous cooperation, continue cooperating.
  - Otherwise, defect this round as punishment.
- **Round t when punishing:** the "punishment round" is one round of defection. The very next round, try cooperation again.
- **Round r:** Cooperate regardless to maximize last round joint payoff (no incentive to punish afterward).

---

### 5. Example sequence

Suppose player i using CCF observes:

| Round t | Actions observed of all players | FULL_COOP(t) | Player i action next round |
|---------|---------------------------------|--------------|----------------------------|
| 1       | n/a (no previous round)          | n/a          | C                          |
| 2       | All cooperated in round 1        | True         | C                          |
| 3       | Some defectors in round 2        | False        | D (punishment)             |
| 4       | Everyone defected round 3 (punishment) | False or True depending on others | C (forgiveness) |
| 5       | If everyone cooperated round 4 now | True        | C                          |
| ...     | ...                             | ...          | ...                        |
| r       | Independent of history           | —            | C                          |

---

### 6. Rationale for strategy design

- **Start cooperative:** Encourages a positive group outcome, potentially triggering cooperation cycles.
- **Conditional cooperation:** You cooperate only if others did, encouraging mutual contributions.
- **One-round punishment:** Defecting one round if anyone defected in previous round deters free-riding.
- **Forgiveness:** After punishment, return to cooperation to avoid permanent breakdown, allowing rebuilding trust.
- **Cooperate in last round:** No incentive for punishment since no future rounds, so defecting provides no future benefit but lower group payoffs.

---

### 7. Edge cases and robustness

- If all defect from start, this strategy produces all defect equilibrium (stable but low payoffs).
- If someone tries to exploit by defecting once, they will get punished next round, reducing their gain.
- If multiple players try to "reset" cooperation by cooperating after punishment, cooperation can restart.
- The simple memory (only previous round actions) keeps the strategy feasible and robust.
- Works regardless of number of players n or number of rounds r.

---

## Summary

| Round type         | Decision                  | Reason                          |
|--------------------|---------------------------|--------------------------------|
| 1 (first)          | Cooperate (C)             | Signal cooperation             |
| Middle rounds (2..r-1) if previous round full cooperation | Cooperate (C)   | Maintain cooperation           |
| Middle rounds if previous round had any defection        | Defect (D)      | Punish defectors               |
| Round after punishment round                              | Cooperate (C)   | Forgive, restore cooperation  |
| Last round (r)       | Cooperate (C)             | Maximize last round payoff, no future punishment |

---

This strategy aligns clearly with cooperative mindset: it **prefers cooperation**, **punishes defections to deter free riders**, and **enables forgiveness to sustain cooperation long-term**.

---

If you want, I can also provide a more formal pseudocode or helper functions for this strategy. Just ask!
'''

description_COOPERATIVE_115 = '''
Here is a cooperative strategy tailored for the N-Player Public Goods Game that balances cooperation incentives with punishment for defections, fostering mutual cooperation over the repeated rounds:

---

### Strategy Name: **Forgiving Tit-for-Tat (F-TFT) with Endgame Adjustment**

---

### Intuition:
- **Aim to cooperate initially** and maintain cooperation as long as others do.
- **Punish defections proportionally** to encourage others back to cooperation.
- **Be forgiving** to avoid endless mutual defection due to single mistakes or noise.
- **Defect in the last round** when cooperation cannot be reciprocated (endgame effect).
- Use **history of all players’ cooperation** to judge behavior, since actions are public.

---

### Decision Rules:

#### 1. Initialization (Round 1)
- **Play C (Cooperate).**

Rationale: Start with trust and maximize initial joint payoff potential.

---

#### 2. Subsequent Rounds (2 ≤ t < r)

- Compute the **cooperation ratio of all other players last round**:

\[
    \text{coop_ratio}_{t-1} = \frac{\text{Number of players (excluding self) who played C in round } t-1}{n-1}
\]

- Compute the **defection ratio** as \(1 - \text{coop_ratio}_{t-1}\).

- Define a **forgiveness threshold** \( \theta \in [0,1] \) (e.g., \( \theta = 0.25 \)).

- **If \(\text{coop_ratio}_{t-1} \geq 1 - \theta\)** (i.e., most others cooperated last round):
  - Play **C** (cooperate).

- **Else** (significant defections last round):
  - Play **D** (defect) this round to punish.
  
- Additional forgiveness mechanism:
  - After punishing (defecting) one round, if next round cooperation ratio improves again, return to cooperation.

---

#### 3. Last Round (t = r)

- Play **D (Defect)** regardless of history.

Rationale: In the last round, no future punishment or reward is possible, so it is individually rational to defect.

---

### Pseudocode

```python
def forgiving_tft_strategy(round_number, r, n, history, theta=0.25):

    # history is a list of length (round_number-1),
    # each element is a list of n actions (C or D) by all players
    
    # Round 1: Cooperate
    if round_number == 1:
        return 'C'
    
    # Last round: Defect
    if round_number == r:
        return 'D'
    
    # From round 2 to round r-1:
    last_round_actions = history[-1]  # actions of all players in previous round
    
    # Count cooperators excluding self (assuming player indexed by 'self_index')
    # For pseudocode, assume self_index is known
    coop_count_others = sum(1 for i, act in enumerate(last_round_actions) if i != self_index and act == 'C')
    coop_ratio = coop_count_others / (n - 1)
    
    # Define forgiveness threshold theta (default 0.25)
    if coop_ratio >= (1 - theta):
        # Most others cooperated - cooperate
        return 'C'
    else:
        # Significant defections last round - punish by defecting
        return 'D'
```

---

### Edge Case Handling:

- **First round**: No history → cooperate to establish trust.

- **Last round**: Defect to avoid being exploited; rational backward induction.

- **Multiple defectors**: Punish (defect) to signal non-cooperation to encourage return.

- **Single mistake or noise**: Forgiving threshold allows to tolerate up to 25% defectors without retaliating immediately, preventing cascade of mutual defections.

---

### Why this strategy is cooperative:

- It starts with cooperation and continues cooperating as long as most others cooperate.

- It punishes defections but only if defectors are numerous enough, thus avoiding overreaction to isolated defections.

- Forgiveness helps restore cooperation after mistakes, maintaining high social welfare.

- Defects only in the final round where cooperation is not sustainable.

- Uses common knowledge and perfect information assumptions effectively to judge others’ behavior.

---

Let me know if you want me to expand or adapt this strategy!
'''

description_COOPERATIVE_116 = '''
Below is a carefully designed cooperative strategy for the repeated N-player Public Goods Game described. It is a conditional cooperation strategy inspired by the classical logic of "conditional cooperation" or "tit-for-tat"-like strategies adapted for public goods.

---

## Cooperative Strategy: *Conditional Cooperation with Forgiveness and Endgame Adjustment*

### Intuition
- Start by cooperating to signal good intent.
- Continue cooperating as long as the group shows willingness to cooperate on average.
- If too many defect, punish by defecting temporarily to discourage exploitation.
- Allow "forgiveness" to rebuild cooperation if others return to cooperating.
- In the final round, defect to avoid being exploited in a one-shot final move.
  
This strategy tries to promote and sustain cooperation, but it defends against free-riding by punishing defection proportionally.

---

### Decision Rules

**Notation:**
- Let round index be \( t \in \{1, \ldots, r\} \)
- Let \( c_j^{(t)} \in \{0,1\} \) be whether player \( j \) cooperated (1) or defected (0) in round \( t \)
- Let \( C_{-i}^{(t)} = \sum_{j \neq i} c_j^{(t)} \) be the number of cooperators excluding self in round \( t \)
- Let \( H_{1..t-1} = \{c_j^{(s)} \text{ for all } j, s < t\} \) be history of all players' actions up to round \( t-1 \)

---

### 1. First Round, \( t=1 \):

- **Cooperate** to signal willingness to cooperate.

---

### 2. Intermediate Rounds, \( 1 < t < r \):

- Calculate the **average cooperation rate of others** over the previous round:

\[
\text{avg\_coop} = \frac{1}{n-1} \sum_{j \neq i} c_j^{(t-1)}
\]

- **Thresholds:**
  - Cooperate if avg_coop ≥ 0.5 (i.e., at least half others cooperated last round).
  - Defect if avg_coop < 0.5 (punish defection).

- This approach means: "Cooperate if the majority of others cooperated last round; defect otherwise."

- **Forgiveness:** If you defected last round, but others have increased cooperation since then, cooperate again as soon as average cooperation crosses threshold.

---

### 3. Final Round, \( t = r \):

- **Defect** because cooperation cannot be reciprocated after last round (endgame effect).

---

### 4. Edge cases and caveats:

- If the total number of other players \( n-1 = 1 \), then just mimic that single player's previous action (cooperate if they cooperated, defect otherwise).

- If multiple rounds have just ended with everyone defecting, default to defecting — cooperation is unlikely.

- If the game is very short (e.g. \( r=2 \)), strategy still works but cooperation window is small — still cooperate in round 1 and defect in round 2.

---

## Pseudocode

```python
def cooperative_strategy(t, r, n, history, player_index):
    """
    t: current round index (1-based)
    r: total rounds
    n: number of players
    history: list of length t-1; each element is list of n actions ['C'/'D']
    player_index: index of this player (0-based)
    
    Returns: 'C' or 'D' for current round action
    """
    
    # Defect in last round
    if t == r:
        return 'D'
    
    # Cooperate in first round
    if t == 1:
        return 'C'
    
    # For intermediate rounds t in [2,..,r-1]
    last_round_actions = history[-1]
    
    # Count how many other players cooperated last round
    cooperators_count = sum(1 for j in range(n) if j != player_index and last_round_actions[j] == 'C')
    
    avg_coop = cooperators_count / (n - 1)
    
    # Threshold for cooperation is >= 0.5
    if avg_coop >= 0.5:
        return 'C'
    else:
        return 'D'
```

---

## Why is this strategy cooperative?

- **Starts with cooperation** to build trust.
- **Conditionally cooperates** only if others mostly cooperate (majority threshold), encouraging mutual cooperation.
- **Punishes defection** by defecting when others mostly defect, discouraging exploitation.
- **Forgives** because cooperation is resumed once majority cooperation returns.
- **Defects in last round** to avoid last-round exploitation, consistent with backward induction logic.
- Uses **only observed actions** (public info), requires no communication or complex assumptions.

---

This strategy balances cooperation incentives and protection against abuse, encouraging sustained cooperation in a harsh environment without communication. It uses simple, transparent rules that can be interpreted by opponents and can foster repeated mutual cooperation.

If there are any questions or you want variants (e.g., higher/lower thresholds, other forgiveness conditions), let me know.
'''

description_COOPERATIVE_117 = '''
Below is a **cooperative strategy** designed for the N-Player Public Goods Game described. It is intended to maximize collective payoffs through mutual cooperation but includes clear decision rules to punish defectors and attempt to restore cooperation, leveraging the repeated interaction and perfect information setting.

---

## Cooperative Strategy: "Forgiving Conditional Cooperate"

### Intuition

- Start by cooperating to build trust and maximize joint payoffs.
- Continue cooperating only if **everyone cooperated in the previous round**; this maintains a stable cooperative equilibrium.
- If one or more players defect in a round, defect in the following round to punish defection.
- After punishing with a single round of defection, **attempt to return to cooperation** regardless of others' behavior to avoid permanent breakdown (forgiveness).
- In the last round, cooperate if and only if everyone cooperated in the previous round—there is no incentive to forgive since there are no future rounds.

This strategy balances cooperation incentives with enforcement of cooperation and forgiveness to maintain cooperation over time.

---

### Formal Decision Rules

Let:
- \( a_{i,t} \in \{C,D\} \) be player i's action at round t.
- \( H_{t} \) be the vector of all players' actions in round t.
- \( r \) is total number of rounds.
- Own previous action and observed actions of all players up to round \( t-1 \) are known at decision time for round \( t \).

---

### Initialization (Round 1)

- Cooperate unconditionally in round 1:
  \[
  a_{i,1} := C
  \]

---

### For rounds \( t = 2, ..., r-1 \):

If all players cooperated in round \( t-1 \):
- Cooperate in round \( t \).

Else if any player defected in round \( t-1 \):
- Defect in round \( t \) to punish defection.

Else (should not occur but for completeness):
- Cooperate.

---

### Forgiveness Mechanism

- After defecting in round \( t \) due to punishment, **always cooperate in round \( t+1 \)** to attempt to restore cooperation (forgiveness).

- This implies that punishment lasts exactly one round regardless of others’ behavior, to prevent endless mutual defection.

---

### Last Round \( t = r \):

- Cooperate if and only if all players cooperated in round \( r-1 \) (i.e., continue cooperation if no defection last round).

- Otherwise, defect (no incentive to be forgiving since there are no future rounds to reap cooperation benefits).

---

### Pseudocode

```python
# Inputs:
# history_actions: list of length t-1, each element is a vector of length n of previous actions C or D

def decide_action(t, r, history_actions):
    if t == 1:
        # Round 1: start cooperatively
        return 'C'

    previous_round = history_actions[-1]
    all_cooperated_last = all(a == 'C' for a in previous_round)

    # Check if we defected in the previous round ourselves
    # Assume we know our previous action (here represented as own_last_action)
    own_last_action = history_actions[-1][my_index]

    if t == r:
        # Last round
        if all_cooperated_last:
            return 'C'
        else:
            return 'D'

    # For intermediate rounds
    if all_cooperated_last:
        return 'C'  # cooperation continues

    # If defection(s) last round, punish with one round defection
    # but if we defected in last round (punishment), forgive now
    if own_last_action == 'D':
        # Forgiveness: cooperate now regardless
        return 'C'
    else:
        # Punish: defect this round
        return 'D'
```

---

### Summary

| Condition                                   | Action               | Purpose                  |
|---------------------------------------------|----------------------|--------------------------|
| Round 1                                     | Cooperate (C)        | Initiate cooperation     |
| All cooperated previous round (t < r)      | Cooperate (C)        | Sustain cooperation      |
| Defection detected previous round, punished | Defect (D)           | Punish defection         |
| Just punished last round (own last action D) | Cooperate (C)       | Forgive to restore trust |
| Last round and all cooperated last round    | Cooperate (C)        | Maintain payoff          |
| Last round and defection detected           | Defect (D)           | No incentive to cooperate|

---

### Notes

- This strategy is a variation of **"Win-Stay, Lose-Shift"** or conditional cooperation.
- The single-round punishment combined with forgiveness helps prevent sustained mutual defection.
- Cooperation is maintained only if **everyone cooperates**; a single defection triggers punishment.
- No assumptions beyond perfect information and deterministic strategies are required.
- This strategy aligns with maximizing joint payoffs via public good contributions, consistent with a cooperative mindset.

---

Let me know if you want me to adapt this strategy for stochastic tolerance thresholds or heavier punishments!
'''

description_COOPERATIVE_118 = '''
Below is a strategically cooperative approach designed for the repeated N-player Public Goods Game described. This strategy aims to foster cooperation while maintaining robustness against defection, given that no communication or enforced contracts are possible.

---

## Strategy Name: *Gradual Reciprocity with Forgiveness*

### Intuition
- Start by cooperating to initiate mutual cooperation.
- Continue cooperating as long as all players cooperated in the previous round.
- If any defection(s) is observed, reciprocate proportionally by defecting in the next round to punish defection.
- Forgive defections that appear as isolated incidents or lapses, allowing cooperation to resume.
- In the last round, defect (since future punishment is impossible).
  
This strategy reflects a typical "trigger" style with gradual and proportional punishment that avoids permanent breakdown, aligning well with the public goods environment where full cooperation yields maximum group payoff.

---

## Detailed Description

### Notation:
- Let `history[t][i]` be player i's action (C or D) in round t.
- Let `round` ∈ {1, 2, ..., r} be the current round.

### Decision rules:

#### 1. First Round (round = 1)
- Cooperate unconditionally (play C) to signal willingness.

#### 2. Intermediate Rounds (1 < round < r)
- If **all players cooperated in the previous round** (i.e., `∀i, history[round-1][i] = C`):
  - Cooperate (play C) to maintain trust.
- Else:
  - Count how many players defected last round:  
    `num_defectors = count of players j where history[round-1][j] = D`
  - If **you defected last round**, and **others mostly cooperated**:  
    Forgive by cooperating to signal willingness to resume cooperation.
  - Else:  
    Defect with probability p proportional to `num_defectors` (or equivalently, defect if you had cooperated last round to punish defectors, else cooperate to enable return to cooperation).
  
(For simplicity, an implementation is to defect if any defection observed last round except forgiving isolated single defections after you defected.)

#### 3. Last Round (round = r)
- Defect, since no future punishment is possible, and personal payoff is maximized by defecting.

---

## Pseudocode

```python
def strategy(history, round, r, n):
    # history: list of lists of actions of all players per round
    # round: current round number (1-based)
    # r: total rounds
    # n: number of players

    # First round: cooperate unconditionally
    if round == 1:
        return 'C'

    # Last round: defect unconditionally
    if round == r:
        return 'D'

    # Previous round actions
    prev_actions = history[round - 2]  # zero-indexed list of length n
    num_defectors = sum(1 for a in prev_actions if a == 'D')

    # Check if all cooperated in previous round
    if num_defectors == 0:
        # Maintain cooperation if everyone cooperated last round
        return 'C'

    # Your own action in previous round
    my_prev_action = history[round - 2][player_index]  # `player_index` references "you"

    # Forgiveness rule:
    # If you defected last round but most others cooperated (exactly one defector: yourself)
    if my_prev_action == 'D' and num_defectors == 1:
        # Forgive by cooperating
        return 'C'

    # Otherwise, punish defection by defecting this round
    return 'D'
```

---

## Strategy Properties

- **Cooperative initiation:** Starts with cooperation.
- **Mutual cooperation maintenance:** If full cooperation prevails, cooperation continues.
- **Proportional punishment:** Defections trigger defections, discouraging free-riding.
- **Forgiveness:** Prevents permanent mutual defection cycles after isolated lapses.
- **Last round defection:** Rational deviation in the final round is anticipated.

---

## Summary

| Round        | Condition                                                | Action            | Rationale                             |
|--------------|----------------------------------------------------------|-------------------|-------------------------------------|
| 1 (first)    | N/A                                                      | Cooperate (C)     | Signal cooperation                  |
| 2 to r - 1  | All cooperated last round                                 | Cooperate (C)     | Maintain mutual cooperation         |
| 2 to r - 1  | Defection(s) last round & you defected, only one defector | Cooperate (C)     | Forgive isolated defection          |
| 2 to r - 1  | Defection(s) last round & above condition not met        | Defect (D)        | Punish defectors                    |
| r (last)     | N/A                                                      | Defect (D)         | No future punishment; maximize own payoff |

---

This strategy is conceptually aligned with canonical "tit-for-tat"-like approaches adapted for an n-player public goods environment, with the nuance of forgiveness and proportional response to sustain cooperation without too harsh or permanent retaliation. It should perform well in a tournament of independently reasoning agents under the given constraints.
'''

description_COOPERATIVE_119 = '''
Here is a carefully designed cooperative strategy for the N-Player Repeated Public Goods Game specified above.

---

## Overview

This strategy aims to foster and sustain cooperation throughout the game, to maximize total group payoffs and individual cumulative payoffs. It is based on a conditional cooperation principle with forgiveness to prevent permanent breakdown due to occasional defections or noise.

---

## Key Intuition

- Cooperation is collectively optimal because **k > 1** (social multiplier) but **k < n**, so the social benefit exceeds the private return from defecting alone.
- However, defectors get a short-term private advantage, so cooperation can be undermined without enforcement.
- Observability of all past actions enables a triggered conditional cooperation strategy: cooperate if the group cooperated sufficiently in the past, else defect as punishment.
- Forgiveness allows restoration of cooperation after punishment.

---

## Strategy Description

We use these notations:

- Let **t** be current round (t = 1, ..., r)
- Let **C_t** be the set of players who cooperated in round t.
- Let **c_t = |C_t|** be the number of cooperators in round t.
- Let **k**, **n**, **r** be known parameters.

---

### 1. First Round (t = 1):

- **Decision**: Cooperate (C)
- **Rationale**: Start with a good faith attempt to cooperate, enabling mutually beneficial public good growth.

---

### 2. Subsequent Rounds (2 ≤ t < r):

- **Decision Rule:**

  - Let `prev_cooperators = c_{t-1}`
  - If `prev_cooperators ≥ threshold`, then Cooperate (C)
  - Else Defect (D)

- **Threshold Definition:**  
  - Set threshold = floor(n * 0.8)  
  - (Adjustable: 80% cooperators in previous round to maintain cooperation)
  
- **Rationale:**

  - If majority strongly cooperated last round, continue cooperating to sustain cooperation.
  - If significant defection observed, punish by defecting this round to discourage free-riding.

- **Forgiveness Mechanism:**

  - If in round t-2 we defected due to insufficient cooperation, but in round t-1 cooperation rose above threshold again, **resume cooperating** to restore cooperation.

---

### 3. Final Round (t = r):

- **Decision:** Defect (D)
- **Rationale:** Backward induction implies no future punishment threat in final round → defect to maximize final payoff.

---

### Summary Table of Decision

| Round             | Condition                                      | Action        |
|-------------------|------------------------------------------------|---------------|
| t = 1             | Always                                        | Cooperate (C) |
| 1 < t < r         | If c_{t-1} ≥ threshold (e.g., ≥ 0.8 n)       | Cooperate (C) |
|                   | Else                                          | Defect (D)    |
| t = r             | Always                                        | Defect (D)    |

---

## Pseudocode

```python
def cooperative_strategy(t, r, n, k, history):
    # history: list of tuples [(round1_actions), (round2_actions), ..., (round_t-1_actions)]
    # each round_actions: list of n elements, C or D for each player (including self)
    
    threshold = int(0.8 * n)  # threshold for cooperation enforcement
    
    if t == 1:
        # Start cooperating
        return 'C'
    
    elif t == r:
        # Final round: defect
        return 'D'
    
    else:
        # Observe last round cooperation count
        last_round_actions = history[-1]
        c_last = sum(1 for action in last_round_actions if action == 'C')
        
        if c_last >= threshold:
            # Last round had strong cooperation, cooperate
            return 'C'
        else:
            # Last round cooperation insufficient, defect to punish
            return 'D'
```

---

## Properties of This Strategy

- **Cooperative**: Starts with cooperation, encourages cooperation when most cooperate.
- **Punishing**: Defects if group cooperation falls below threshold, deterring free-riders.
- **Forgiving**: Can return to cooperation if group cooperation recovers above threshold.
- **Simple and Robust**: Requires no complex beliefs or predictions, only observed recent cooperation.
- **Optimal Final Round**: Defects in last round per rational backward induction.

---

## Handling Edge Cases

- **If all players defect in first round**: This player defects on round 2 onwards (since c_1 < threshold), effectively giving up, which aligns with rational self-interest.
- **If one or few players occasionally defect but majority cooperate**: Cooperative behavior continues because threshold is high but forgiving.
- **If total cooperation fluctuates around threshold**: The strategy will oscillate between cooperating and defecting, but normal large groups usually sustain cooperation with this threshold.
- **If r=2 (minimum multiple rounds)**:  
  - Round 1 cooperate, round 2 defect (final round), best responding rationally.

---

# Summary

This strategy embodies conditional cooperative logic with credibility (rewarding cooperation), deterrence (punishing via defection), and forgiveness (restoring cooperation), effectively aligning self-interest with group cooperation in the repeated public goods game. It balances simplicity and effectiveness without relying on external coordination or communication.

---

If you want, I can help extend this to include stochastic forgiveness or more sophisticated reputation-based decision rules. Let me know!
'''

description_COOPERATIVE_120 = '''
Below is a fully cooperative strategy for the N-Player, repeated Public Goods Game as specified.

---

## Strategy Name: **Conditional Cooperation with Forgiveness**

### Intuition:
- Cooperate initially to promote mutual cooperation.
- Defect only as a clear punishment if others defect, deterring free-riding.
- Forgive after punishment to restore cooperation.
- Defect in the last round (endgame) because there is no future incentive.
  
This approach aligns with a classic strategy in repeated public goods and prisoner's dilemma games, like **Tit-for-Tat with forgiveness**, adapted to the public goods context.

---

### Decision Rules:

#### Notation:
- Let `t` be the current round number (1 ≤ t ≤ r).
- Let `history` be the full action profile (for all players) from rounds 1 to t-1.
- Let `cooperators_in_last_round` = number of players who played C in round t-1.
- Let `I` denote "this player (you)".

#### Rules:

1. **First round (t=1):**  
   *Cooperate* (play C) unconditionally.

2. **Rounds 2 to r-1 (middle rounds):**  
   - If **everyone cooperated** last round (all players played C), then *cooperate* again.  
   - Else if **at least one player defected** last round (some D observed):  
     - If I cooperated last round:
       - *Defect* this round (punishment for others defecting).  
     - Else if I defected last round (was punishing or already defecting):
       - *Cooperate* this round (forgiveness to try restoring cooperation).

3. **Last round (t = r):**  
   - *Defect* unconditionally (theoretical backward induction suggests no incentive to cooperate in final round).

---

### Explanation of the Logic:

- The first round cooperation signals willingness to build trust and supports efficiency.
- If everyone cooperated, continuing cooperation maximizes payoffs for all.
- If defections occur, punishing by defecting for exactly one round signals disapproval and raises the cost of defection to defectors.
- Forgiving in the next round after punishing gives a chance to rebuild cooperation rather than locking into persistent mutual defection.
- Defecting in the last round removes the incentive to be exploited since no future reciprocation is possible.

---

### Pseudocode:

```python
def decide_action(t, r, n, history, player_index):
    # history: List of lists - actions per round per player, e.g., [['C','D','C'], ['C','C','C'], ...]
    # player_index: index of this player, 0-based
    
    if t == 1:
        return 'C'  # Cooperate in first round
    
    last_round_actions = history[t-2]  # actions from round t-1
    
    # Count how many cooperated in last round
    cooperators_in_last_round = last_round_actions.count('C')
    
    # Check if everyone cooperated last round
    all_cooperated = (cooperators_in_last_round == n)
    
    # Player's own last action
    my_last_action = last_round_actions[player_index]
    
    if t == r:
        # Last round: always defect
        return 'D'
    
    if all_cooperated:
        # If full cooperation last round, continue cooperating
        return 'C'
    else:
        # There was at least one defector last round
        if my_last_action == 'C':
            # If I cooperated last round, punish by defecting
            return 'D'
        else:
            # If I was already defecting last round (punishing), forgive by cooperating
            return 'C'
```

---

### Properties:

- **Cooperative:** Supports mutual cooperation and maximizes group payoff if others are cooperative.
- **Reactive:** Responds to defections but only with brief punishment.
- **Forgiving:** Does not retaliate endlessly, allowing cooperation to resume.
- **Rational Endgame:** Defects last round where cooperation is not incentivized.
- **Simple:** Requires no complex prediction, only history of last round's actions.

---

### Edge Cases:

- **First Round:** Cooperate as baseline trust signal.
- **If everyone defects first round:** Strategy will punish in second round (defect), then try to forgive next round; possibility of cycling cooperation if others reciprocate.
- **Last Round:** Defect to avoid exploitation.
- **If others always defect:** Strategy will defect from the second round onwards (since no cooperation to reward).
- **If others always cooperate:** Mutual cooperation until last round with large payoffs (best outcome).

---

This strategy should do well in a tournament among independently rational, history-aware players aiming to maximize their own total payoff, incentivizing cooperation while safeguarding against exploitation.
'''

description_COOPERATIVE_121 = '''
Here is a cooperative strategy tailored for the described repeated N-Player Public Goods Game that balances cooperation incentives with retaliation to discourage free-riding. The strategy promotes collective contribution to maximize group payoff, uses observed history to enforce cooperation, and handles edge cases such as the first and last rounds.

---

## Strategy: “Conditional Cooperation with Forgiveness and Endgame Awareness”

### Intuition
- **Start by cooperating** to encourage building trust and maximize public good.
- **Continue cooperating if all players cooperated previously** (full cooperation).
- **If any defection detected in previous round, punish by defecting once (retaliation).**
- **Forgive after punishing (return to cooperation) unless defection repeats.**
- **In the last round, defect (free-ride) since no future punishment is possible.**

This approach implements a "grim-trigger light" or "tit-for-tat with forgiveness" style strategy adapted to n-player setting, aimed at sustaining cooperation without permanent breakdown.

---

### Formal Description

Let:

- \( t \) = current round, \( 1 \le t \le r \)
- \( \text{actions}_{t-1} = \{a_{1,t-1}, a_{2,t-1}, ..., a_{n,t-1}\} \) be the vector of actions by all players in previous round.
- Assume you observe the entire vector of all players’ actions in previous rounds.

---

### Decision Rules

- **Round 1 (t=1):**  
  Cooperate. (No history yet, try building cooperation.)

- **Rounds 2 to r-1:**  
  If **all players cooperated** in the previous round (\( \forall j: a_{j,t-1} = C \)),  
  → Cooperate.  
  Else if previous round had **any defections**,  
  → Defect one round as punishment (retaliate).  
  After punishing one round, return to cooperation regardless of defections in further past history (forgive).

- **Round r (last round):**  
  Defect. (No future rounds to enforce cooperation; incentivized to free-ride.)

---

### Edge Case Handling

- **Multiple simultaneous defectors:** Punish by defecting once. If defections persist, continue defecting one round per defection round with forgiveness in between.

- **No communication or coordination devices:** Use only observed actions, not signaling or complex assumptions.

- **If players never cooperate or never defect:** The strategy defaults to cooperating first round and then following the rules, thereby can accommodate unconditional defectors or cooperators.

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, history):
    # history: list of tuples/lists of length n with actions in previous rounds
    # e.g. history[t-2] is actions in round t-1
    
    # First round: cooperate
    if t == 1:
        return 'C'
        
    # Last round: defect (endgame effect)
    if t == r:
        return 'D'
    
    # From round 2 to r-1:
    previous_actions = history[t-2]  # actions in round t-1
    
    # Check if previous round was full cooperation
    if all(action == 'C' for action in previous_actions):
        # Previous round cooperative => cooperate
        return 'C'
    else:
        # Previous round had defection(s)
        # Check if last round played was punish round (i.e. previous own action was D due to punishment)
        # We infer forgiveness by checking if we defected as punishment last round
        
        # Retrieve our own previous action:
        my_prev_action = history[t-2][my_player_index]  # assuming known index
        
        # If we defected last round as punishment, now forgive by cooperating
        if my_prev_action == 'D':
            return 'C'  # Forgive and return to cooperation
        
        # Otherwise punish defectors this round by defecting
        return 'D'
```

---

### Summary

| Round | If All Cooperated Previous Round? | Action            | Notes                                  |
|-------|-----------------------------------|-------------------|----------------------------------------|
| 1     | N/A                               | Cooperate (C)     | Build trust                           |
| 2..r-1| Yes                               | Cooperate (C)     | Sustain cooperation                   |
| 2..r-1| No                                | Defect (D) if last own action not D (punish) | Retaliate once per observed defection round |
| 2..r-1| No                                | Cooperate (C) if last own action was D (forgive) | Resume cooperation after punishment  |
| r     | Any                               | Defect (D)        | Endgame, no incentive to cooperate    |

---

### Cooperative Alignment

- Encourages mutual cooperation by starting cooperatively.
- Punishes defectors but only transiently, maintaining future cooperation possibility.
- Forgives to avoid endless defecting cycles that reduce group welfare.
- Recognizes last round incentives and defects to maximize individual payoff without harming future cooperation (since none).
- Uses only observable history and game parameters; no extra assumptions.

---

This strategy balances maximizing collective payoffs through cooperation with appropriate incentives to deter defectors, making it well suited for a tournament where many independent strategies interact.
'''

description_COOPERATIVE_122 = '''
**Cooperative Strategy: “Conditional Cooperation with Forgiveness”**

---

### Intuition & Goals

- **Goal:** Maximize collective payoffs by sustaining mutual cooperation over all rounds to leverage the beneficial *public good* multiplier.
- **Challenge:** Defection yields immediate private benefit but undermines cooperation long-term.
- **Approach:** Start by cooperating to encourage cooperation, detect defection, punish to deter exploitation, but forgive to restore cooperation and avoid endless retaliation.
- **Edge cases:** Handle start and end of game thoughtfully to avoid end-game unraveling and ensure cooperation until the end.

---

### Strategy Description

---

**Key Idea:**  
- Cooperate in round 1 unconditionally (build trust).  
- In each subsequent round, cooperate if everyone cooperated in the previous round or if defection was rare/isolated (a forgivable error).  
- Defect if multiple players defected previously, indicating breakdown of cooperation.  
- After defecting as punishment, return to cooperation to attempt restoring cooperation.  
- In the last round, defect if mutual cooperation isn’t guaranteed, to avoid being exploited.

---

### Detailed Decision Rules

Let:

- `t` = current round (1 ≤ t ≤ r)  
- `H_t` = history of all players’ actions up to round t-1  
- `C_t(i)` = whether player i cooperated in round t (1 for cooperate, 0 for defect)  
- `cooperators_in_last_round` = number of players who cooperated in round t-1

---

#### Round 1 (t=1):

- **Action:** Cooperate (C) unconditionally.  
- **Rationale:** Signal cooperative intent; establish trust baseline.

---

#### Rounds 2 to r-1:

- **Observe previous round’s actions of all players.**  
- Define:
  - `defectors_in_last_round = n - cooperators_in_last_round`
  - Threshold: forgivable defection count = 1 (only 1 defector tolerated before suspicion)
  
- **If** all players cooperated in round t-1 (`defectors_in_last_round == 0`):  
  - **Action:** Cooperate (C)  
  - **Rationale:** Maintain cooperation, maximize joint payoff.

- **Else if** only one player defected in round t-1 (`defectors_in_last_round == 1`):  
  - **Action:** Cooperate (C), forgiving single defection  
  - **Rationale:** Allow for accidental or strategic errors, do not retaliate immediately.

- **Else** (two or more defected in last round):  
  - **Action:** Defect (D) to punish breakdown  
  - **Rationale:** Deterrence, signaling defection not tolerated

- **If current action was defection (punishment phase), check in next round:**  
  - If next round cooperation resumes with all or almost all cooperating, also resume cooperation  
  - **Rationale:** Avoid endless cycles of retaliation.

---

#### Round r (last round):

- Without future rounds, no incentive to cooperate if others defect. So:

- If cooperation in round r-1 by all or at most one defector:  
  - **Cooperate (C) in last round**
  
- Else:  
  - **Defect (D) in last round**

---

### Pseudocode

```python
def decide_action(t, r, history):
    # t: current round (1-indexed)
    # r: total rounds
    # history: list of lists, each sublist has n actions of players in round t-1
    # actions: 'C' or 'D'

    n = len(history[0]) if history else n_players  # players count known by construction
    
    if t == 1:
        return 'C'  # First round unconditional cooperation

    last_round_actions = history[-1]
    cooperators_in_last_round = sum(1 for a in last_round_actions if a == 'C')
    defectors_in_last_round = n - cooperators_in_last_round

    # If this is last round:
    if t == r:
        if defectors_in_last_round <= 1:
            return 'C'
        else:
            return 'D'

    # Intermediate rounds:
    if defectors_in_last_round == 0:
        return 'C'  # full cooperation before, continue cooperating
    elif defectors_in_last_round == 1:
        return 'C'  # forgive single defection
    else:
        return 'D'  # punish multiple defections
```

---

### Explanation of Cooperative Mindset

- Strategy **starts friendly**, fosters trust, always ready to cooperate first.
- **Forgiving**: Single defection tolerated, prevents slippery slope or accidental punishment escalation.
- **Punishes multiple defectors** to discourage free-riding.
- **Retaliation is temporary**: willing to restore cooperation if conditions improve.
- **Last round cautious**: rationally defects only if mutual cooperation unlikely, avoiding exploitation.
- This approach balances the **maximization of mutual benefit** with **discouragement of defection**, suitable for repeated public goods games with perfect monitoring but without communication.

---

### Summary

| Round(s)       | Condition                                 | Action             |
|----------------|-------------------------------------------|--------------------|
| 1              | First round                               | Cooperate (C)      |
| 2 to r-1       | All cooperated last round                 | Cooperate (C)      |
| 2 to r-1       | Exactly 1 defector last round             | Cooperate (C)      |
| 2 to r-1       | ≥ 2 defectors last round                   | Defect (D)         |
| r (last round) | ≤1 defections last round                   | Cooperate (C)      |
| r (last round) | >1 defections last round                    | Defect (D)         |

This strategy promotes cooperation effectively while deterring defection in repeated public goods games without communication or enforceable contracts.
'''

description_COOPERATIVE_123 = '''
**Cooperative Strategy for the N-Player Public Goods Game (Repeated C/D Decisions)**

---

### Intuition and Goals

- The maximum collective payoff occurs when **all players cooperate (C)** each round, yielding each player payoff π_i = k.
- Defection (D) is individually tempting since the defector keeps the private endowment (1 instead of 0) while free-riding on cooperators.
- Without communication, the strategy must rely solely on observed history of players' actions.
- The strategy should:
  - **Start cooperatively** to promote mutual cooperation.
  - **Punish defections minimally** to discourage free-riding.
  - **Forgive defections promptly** to allow cooperation to resume.
  - **Avoid defection in the last round** (or near it) since no future rounds remain to punish and no benefit from retaliation.
  
---

### Strategy Outline: *Forgiving Trigger with Leniency and Endgame Cooperation*

---

#### Parameters of the strategy (internal):

- **Defection tolerance threshold (D_threshold):** Number of defectors tolerated in past round before punishing. (Typically 1)
- **Memory:** Full history of rounds to observe defections.
- **Punishment length:** Only a single round of punishment for observed defections.
- **Endgame window:** Last 1 or 2 rounds where the strategy always cooperates.

---

### Rule Summary:

| Round | Action Decision Rule                                                    |
|-------|------------------------------------------------------------------------|
| 1     | Cooperate (C)                                                          |
| Middle rounds (2 to r-2) | Cooperate if last round had ≤ D_threshold defectors; else Defect (D) in current round to punish defectors. One round punishment only, then return to cooperate. |
| Last rounds (r-1 and r)    | Always cooperate regardless of prior defections to maximize collective payoff |

---

### Detailed Decision Rules

Given the history of actions for all players in all past rounds:

Let `Defectors_last_round = number of players who played D in the previous round`

Let `Punishing` be a boolean flag that indicates if currently punishing defectors, initially false.

**At round t:**

1. **If t = 1 (first round):**  
   Play **C** (cooperate).

2. **Else if t ≥ r-1 (last two rounds):**  
   Play **C** regardless of history.

3. **Else:**  
   - If `Punishing` is false:  
     - If `Defectors_last_round ≤ D_threshold` (i.e., cooperation or minor defection):  
       - Play **C** (continue cooperating).  
     - Else (defections exceed tolerance):  
       - Play **D** (punish defectors).  
       - Set `Punishing = true` (enter punishment state).  
   - Else if `Punishing` is true (currently punishing):  
     - Play **C** (forgive and return to cooperation).  
     - Set `Punishing = false` to exit punishment.

---

### Explanation:

- **First round:** Cooperate, to signal cooperation and willingness to build trust.
- **Tolerance:** The strategy allows for minor slip-ups or mistakes by tolerating up to `D_threshold` defectors without punishing.
- **Punishment:** If too many defectors appeared in the previous round, punishes defectors by defecting once. Punishment lasts only one round to avoid prolonged retaliation wars.
- **Forgiveness:** After one round of punishment, returns to cooperation, allowing mutual cooperation to restart.
- **Endgame cooperation:** To avoid the unraveling of cooperation in the last rounds, cooperate unconditionally in final two rounds.
  
---

### Pseudocode

```
initialize:
  Punishing = false
  D_threshold = 1  # can be tuned

for each round t in 1..r:
  if t == 1:
    action = C

  else if t >= r-1:
    # last two rounds always cooperate
    action = C

  else:
    Defectors_last_round = count of players who played D in round t-1

    if not Punishing:
      if Defectors_last_round <= D_threshold:
        action = C
      else:
        action = D
        Punishing = true
    else:  # currently punishing
      action = C
      Punishing = false

  play action
```

---

### Further notes:

- By cooperating first, the strategy encourages mutual cooperation.
- By punishing immediately and only briefly, it deters persistent defections without escalating conflict.
- By forgiving quickly, it encourages returning to mutual cooperation.
- By cooperating in the final rounds, it avoids wasteful defection cycles when retaliation is not possible.
- The strategy is **aligned with the cooperative mindset** and optimizes collective welfare through conditional cooperation with a forgiving trigger.

---

### Summary

This *Forgiving Trigger* strategy balances promoting cooperation, punishing defections, and allowing forgiveness, while safeguarding gains at the end of the repeated game. It is simple, robust, and well-suited for environments where players’ behaviors are only observable through their actions and common knowledge of game rules.
'''

description_COOPERATIVE_124 = '''
Here is a **cooperative strategy** designed for the N-Player Repeated Public Goods Game under the specified rules and assumptions. The strategy aims to sustain mutual cooperation, maximize group payoffs, tolerate occasional defections, and defect when others defect persistently—all without communication or coordination devices.

---

## Intuition / Summary:

- **Start cooperating** to build trust and maximize public good.
- **Conditionally cooperate in future rounds as long as others mostly cooperate**—tolerate occasional defections.
- **Punish persistent defection by defecting** (to avoid being exploited).
- **Return to cooperation if others resume cooperation.**
- **In the last round, defect** since no future retaliation is possible.
  
This strategy is inspired by *"Generous Tit-for-Tat"* and *"Win-Stay Lose-Shift"* logic generalized to the N-player setting.

---

## Full Strategy Description

### Parameters (tunable, chosen conservatively):

- **Tolerance threshold**: allow some defections tolerated without immediate punishment  
  e.g. tolerate up to **T = ceil(0.3 * (t-1))** defections by others in rounds 1 to t-1.

- **Memory:** track past rounds' actions of *all* players.

---

### Pseudocode (for player i):

```
Input:
- n, r, k
- History of actions: A_history = [A_1, A_2, ..., A_(t-1)],
  where A_t = [a_1_t, a_2_t, ..., a_n_t], a_j_t ∈ {C, D}

Decision for round t:

if t == 1:
    # First round, no history: cooperate to build trust
    play C

elif t == r:
    # Last round: defect (dominant last round defection)
    play D

else:
    # Count number of defections by others in past rounds
    total_defections_by_others = 0
    total_past_rounds = t - 1
    
    for past_round in 1 to (t-1):
        for player_j in 1 to n:
            if player_j != i and A_history[past_round][player_j] == D:
                total_defections_by_others += 1
                
    # Calculate total number of other players * total rounds to normalize
    max_defections_possible = (n - 1) * total_past_rounds
    
    # Calculate defections rate by others
    defections_rate = total_defections_by_others / max_defections_possible
    
    if defections_rate <= 0.3:
        # Others mostly cooperate - return cooperation
        play C
    else:
        # Others defect too much - defect as punishment
        play D
```

---

### Explanation:

1. **Round 1:**  
   Cooperate immediately to signal willingness to cooperate and maximize group returns.

2. **Rounds 2 to r−1:**  
   Compute the aggregate rate of defection by other players in all previous rounds.  
   - If others defect rarely (less than or equal to 30%), continue cooperating (allow some noise/errors).  
   - If others defect frequently (more than 30%), defect to avoid exploitation.

3. **Last Round (r):**  
   Defect because cooperation cannot be enforced via future retaliation—this avoids being exploited by defectors in the last round.

---

### Why this design?

- **Cooperative mindset:** Player begins cooperative, prefers cooperation if reciprocated.
- **Forgiveness:** Tolerates occasional defections to handle noise or experimentation by others.
- **Punishment:** Defects only if collective defection rate is high—discourages free-riding.
- **No complexity or assumptions:** Uses only observed past actions; no communication or coordination.
- **Last round defection is rational:** Prevents sucker payoffs in final round.

---

### Notes on parameter choices:

- The 30% threshold is a heuristic to balance forgiveness and punishment. It can be tuned based on the environment.
- The defections_rate is aggregated over all players and all rounds to avoid reacting to a single defection.
- The strategy is symmetric: each player runs the same logic.

---

## Summary of Key Points:

| Round                | Action                           |
|----------------------|---------------------------------|
| First (t=1)          | Cooperate                       |
| Intermediate (1<t<r) | Cooperate if others mostly cooperate (≤30% defections), else defect |
| Last (t=r)           | Defect                         |

---

If you want a simpler or more complex variant, or alternative versions (e.g., focused on recent rounds, or individual punishment), just ask!
'''

description_COOPERATIVE_125 = '''
**Cooperative Strategy: "Grim Trigger with Forgiveness"**

---

### Intuition
The strategy aims to sustain cooperation by starting cooperatively and continuing to cooperate as long as all others have cooperated in the past, thereby maximizing collective payoffs. If any player defects, it punishes by defecting in the next round but allows for eventual forgiveness to re-establish cooperation. This approach encourages mutual cooperation, deters defection, and adapts to occasional mistakes or noise while aligning strongly with cooperative incentives.

---

### Decision Rules

1. **Initial Condition (Round 1):**  
   Cooperate unconditionally (play C).

2. **Subsequent Rounds (t > 1):**  
   - If everyone cooperated in round t-1, **cooperate** this round.  
   - If at least one player defected in round t-1, **defect** this round to punish defections.

3. **Forgiveness Mechanism:**  
   If in the previous round, the player defected as punishment and observes that *everyone* is cooperating in the current round, it resets the punishment state and returns to cooperation in the next round.

---

### Edge Cases Handling

- **First Round:** No history, so cooperate to signal willingness.
- **Last Round (r-th round):** Continue the same logic. Since last round offers no future retaliation, temptation to defect is higher. However, maintain cooperation to maximize collective payoff as this is a fully cooperative strategy.
- **Single Defection by Others:** Treat any defection by any other player as a trigger to punish in next round.
- **All Defected in Previous Round:** Continue defecting unless forgiveness condition is met.
- **Forgiveness after Punishment:** If the strategy detects full cooperation after punishment round, resume cooperation immediately. This prevents endless mutual defection and promotes re-cooperation.

---

### Summary

| Condition                               | Action  |
|---------------------------------------|---------|
| Round 1                               | Cooperate (C) |
| Previous round: All cooperated        | Cooperate (C) |
| Previous round: Any defectors          | Defect (D) (punishment) |
| Punished last round & now all cooperate | Cooperate (C) (forgiveness) |


---

### Pseudocode

```python
# Inputs:
# history: list of length t-1, each element is list of actions of all players in that round
# i: index of this player (1-based)
# t: current round (1-based)
# n: total players
# r: total rounds

def cooperative_strategy(history, i, t, n, r):
    if t == 1:
        # First round unconditionally cooperate
        return 'C'
    
    last_round_actions = history[-1]
    all_cooperated = all(action == 'C' for action in last_round_actions)
    my_last_action = history[-1][i - 1]

    # Check if punished last round (we defected last round)
    punished_last_round = (my_last_action == 'D')

    if all_cooperated:
        if punished_last_round:
            # Forgive after punishment if everyone cooperated now
            return 'C'
        else:
            # Continue cooperation
            return 'C'
    else:
        # Someone defected => Punish by defecting this round
        return 'D'
```

---

### Rationale for Cooperation

- Mutual cooperation yields highest payoff: π_i = k (if all cooperate, from example).
- Defection gains short term benefit but triggers punishment and reduces others' payoffs.
- The strategy fosters a "cooperate until betrayed" norm.
- Forgiveness avoids endless punishment cycles.
- By defecting after defection, it signals clear consequences, incentivizing others to cooperate.

---

### Notes:

- The strategy does **not** attempt to identify or target specific defectors, since only aggregated actions are known.
- It uses simple, observable cooperation patterns suited to the public goods game.
- Designed to be robust in tournaments against independent and unknown opponent strategies based on standard repeated game theory logic.
- No assumption of prior coordination or communication.

---

**This strategy is a classical, robust cooperative approach for repeated public goods games, promoting maximum possible collective benefit while deterring exploitation.**
'''

description_COOPERATIVE_126 = '''
**Cooperative Strategy for N-Player Public Goods Game (Repeated, Simultaneous-Move)**

---

### Strategy Overview

This strategy aims to promote and sustain cooperation throughout the repeated game by:

- **Cooperating initially** to establish mutual cooperation.
- **Monitoring others' cooperation history** to condition future actions.
- **Retaliating softly upon defections**, but forgiving to avoid endless mutual defection.
- **Attempting to re-establish cooperation after defections.**
- **Cooperating fully in the last round**, because there is no future to punish.

This aligns with a *conditional cooperative approach* (akin to a generalized "Tit-for-Tat" in the public goods context), adapted to multiple players and simultaneous moves.

---

### Core Ideas Behind the Strategy

1. **First round: Cooperate**  
   Start by cooperating to try to build cooperation from the outset.

2. **Subsequent rounds: Conditional Cooperation based on observed group cooperation:**
   - If the group showed high cooperation last round (e.g., most players cooperated), cooperate again.
   - If defectors were present (less than full cooperation), reduce cooperation but allow some forgiveness.
   
3. **Forgiveness and Repair:**
   - If a defection occurred, punish by defecting once.
   - Then attempt to restore cooperation by cooperating again.
   
4. **Last round: Cooperate regardless**
   - Since there is no future punishment opportunity, cooperate for maximal joint payoff.

---

### Details on Decision Rules

Given:

- Let **t** = current round (1 ≤ t ≤ r)
- Let **history** be all previous rounds’ actions by all players
- Let **n** = number of players
- Define **threshold_coop** = n - 1 (i.e., all but at most one cooperate) to consider the group cooperative  
  (This threshold can be adjusted to tolerate minimal levels of defection)

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, history, player_index):
    # history is a list of rounds; each round is a list of actions by all players, 'C' or 'D'
    # player_index is the index of this player (0-based or 1-based as agreed)
    
    if t == 1:
        # First round: cooperate
        return 'C'
    
    elif t == r:
        # Last round: cooperate, to maximize joint payoff
        return 'C'
    
    else:
        # Analyze previous round
        last_round = history[t-2]  # zero-based index
        total_cooperators = last_round.count('C')
        my_last_action = last_round[player_index]
        
        # If everyone (or all but one) cooperated last round, continue cooperating
        if total_cooperators >= threshold_coop:
            return 'C'
        
        # If defection(s) occurred last round:
        else:
            # Retaliate once if you cooperated last round and someone defected
            if my_last_action == 'C':
                return 'D'  # punish defectors
            
            # If you defected last round, try to restore cooperation
            else:
                return 'C'  # forgive and attempt repair
```

---

### Explanation of Logic

- **First round cooperate**: Establish the intention to cooperate.
- **Maintain cooperation if group mostly cooperated**: Mutual cooperation maximizes payoffs.
- **Retaliate for defection**: If you cooperated but others defected, defect once as punishment (discourages exploitation).
- **Forgive and attempt to repair**: If you defected last round (had defected in retaliation), now cooperate to signal willingness to rebuild trust.
- **Always cooperate last round**: No incentive to defect because no future retaliation is possible, cooperation yields better group payoff.

---

### Edge Cases Handling

- **If multiple defections occur**, the strategy still responds with single-round punishment and attempts repair.
- **If you are the sole defector last round**, you punish yourself with your own pattern to restore cooperation.
- **If all defect constantly**, the pattern degrades into persistent defection, but this is consistent with incentives.
- **With only two players**, the strategy maps onto classic Tit-for-Tat logic.
- **If r=2 (smallest repetition)**, still cooperate round 1 and 2.
- **For large r**, the pattern stabilizes cooperation under mutual cooperation but adapts to defections.

---

### Summary

This **conditional cooperation strategy** is simple, clear, and robust in encouraging and maintaining cooperation in the repeated Public Goods Game under perfect information and common knowledge with no communication. It balances incentives to cooperate and punish defectors, while maintaining forgiveness to prevent endless retaliation cycles. This aligns well with a cooperative mindset and is likely to achieve higher payoffs against many reasonable independent strategies.
'''

description_COOPERATIVE_127 = '''
**Cooperative Strategy for the N-Player Public Goods Game**

---

### Overview

The goal of this strategy is to:

- Encourage and sustain mutual cooperation over multiple rounds to maximize collective payoff.
- Detect and respond to defections to protect against exploitation.
- Use forgiveness to allow cooperation to resume after a defection.
- Avoid unraveling cooperation especially before the last rounds.
- Maintain a cooperative mindset aligned with maximizing joint payoffs rather than short-term individual gain.

---

### Intuition

- Cooperation (C) yields higher payoffs if enough players cooperate.
- Defection (D) yields immediate private gain but reduces the total payoff from the public good.
- The best collective outcome is when all players cooperate every round.
- Defection is tempting, so must be discouraged through conditional strategies.
- The repeated nature allows for strategies based on history.
- Imperfect cooperation harms all, so punish defectors but forgive eventually.

---

### Strategy Description

This strategy is a **"Forgiving Conditional Cooperator"** inspired by trigger and tit-for-tat principles but adapted for the public goods game with multiple players.

---

### Decision Rules

**Notation:**  
- \( c^t_j \): action of player \( j \) in round \( t \) (1 if C, 0 if D)  
- \( \text{History} = \{ c^m_j \mid \forall j, 1 \le m < t \} \)  
- \( M = n \times (t - 1) \): total individual actions by all players before round \( t \)  
- \( \text{DefectionsSinceForgiveness} \): number of defect actions detected in recent rounds (see forgiveness below)

---

#### Round 1 (Initialization):

- **Cooperate** (C) to establish a baseline of mutual cooperation.

---

#### Rounds 2 to \( r-2 \) (Cooperation Maintenance Phase):

- Observe total defectors in the previous round \( t-1 \):

  \[
  D_{t-1} = \sum_{j=1}^n (1 - c_j^{t-1}) = \text{number of players defecting last round}
  \]

- **Rule:**

  - If \( D_{t-1} = 0 \) (all cooperated last round)  
    → Cooperate (C) this round.

  - Else (at least one defector last round)  
    → Defect (D) this round to punish defectors.

- **Forgiveness Window:**  
  If cooperating after a punishment round leads to mutual cooperation being re-established (0 defectors in immediately recent rounds), reset punishment and cooperate again.

---

#### Round \( r-1 \) (Penultimate Round):

- Begin **softening punishment** since the final round's backward induction risk starts.

- Cooperate if the previous round involved majority cooperators (≥ 50%), otherwise defect.

- This helps keep cooperation as long as possible before the last round.

---

#### Round \( r \) (Final Round):

- Defect, because there is no future punishment possible (standard backward induction logic).

---

### Summary Table of Behavior

| Round          | Condition on Previous History                   | Action           |
|----------------|------------------------------------------------|------------------|
| 1              | Initial                                        | Cooperate (C)    |
| 2 to r-2       | All cooperated \( \to \) Cooperate             | Cooperate (C)    |
|                | Any defectors \( \to \) Defect                  | Defect (D)       |
| r-1 (penultimate) | Previous round majority cooperated \( \to \) Cooperate | Cooperate (C)    |
|                | Otherwise                                      | Defect (D)       |
| r (final)      | Final round (no future rounds)                  | Defect (D)       |

---

### Pseudocode

```python
def next_action(round_t, r, n, history):
    """
    Parameters:
      round_t: current round, 1-based
      r: total rounds
      n: number of players
      history: list of previous rounds actions
               e.g., history[t-2] = list of length n with 1 (C) or 0 (D)
               for round t-1 actions

    Returns:
      action: 'C' or 'D'
    """
    if round_t == 1:
        # Always cooperate initially
        return 'C'

    if round_t == r:
        # Last round: defect (backward induction)
        return 'D'

    if round_t == r - 1:
        # Penultimate round: cooperate if majority cooperated last round
        last_round = history[-1]
        if sum(last_round) >= n / 2:
            return 'C'
        else:
            return 'D'

    # For rounds 2 to r-2: maintain cooperation if last round had unanimous cooperation
    last_round = history[-1]
    if sum(last_round) == n:
        # No defectors last round => cooperate
        return 'C'
    else:
        # Punish defectors by defecting this round
        return 'D'
```

---

### Notes on Robustness

- **No assumptions on others’ intent:** Only uses observed history to decide.
- **Forgiveness is implicit:** After punishing defectors by defecting, if all cooperate again next round, this strategy resumes cooperation.
- **Punishment severity:** Defecting for one round after any defection balances deterrence and forgiveness.
- **No harsh permanent betrayal:** No grim-trigger to avoid deadlock of constant defection.
- **Backward induction awareness:** Defects in last round to avoid exploitation.
- **Simplicity:** Easy to implement and understand, facilitating predictable behavior for others.

---

### Why This Strategy Is Cooperative

- It always starts cooperative and cooperates if others do.
- It punishes defectors only temporarily, not permanently.
- It rewards cooperation by returning to cooperating after punishment.
- It intelligently softens to maintain cooperation near the end.
- It aims to maximize joint payoffs over all rounds by leveraging repeated interaction.

---

**This cooperative strategy aligns well with the public goods game's payoff structure and common game theoretic insights, balancing cooperation, punishment, and forgiveness carefully.**
'''

description_COOPERATIVE_128 = '''
Here is a cooperative strategy for the described N-Player Public Goods Game. This strategy aims to establish cooperation and maintain it as long as others cooperate, while limiting exploitation by defectors. It adapts over repeated rounds, is forgiving but firm, and respects the public goods structure and the "shadow of the future" to incentivize cooperation.

---

## Strategy Name: **Forgiving Conditional Cooperation (FCC)**

### Core Idea
- **Start cooperating** to maximize group payoffs.
- **Continue cooperating** as long as everyone cooperated last round (or cooperation is near-universal).
- **Punish defection** briefly to discourage exploitation.
- **Forgive** and return to cooperation after a punishment round.
- **Cooperate reliably in early rounds** to establish trust and in later rounds to ensure positive cumulative payoff.
- In the **last round**, defect to maximize immediate payoff.

---

## Decision Rules

### Definitions

- Let _t_ denote the current round, 1 ≤ t ≤ r.
- Let H_{t-1} be the history of all players' actions in rounds 1 through t-1.
- Let c_j^{t-1} ∈ {0,1} be player j’s action in round t−1 (1 if Cooperate, 0 if Defect).
- Define coop_count^{t-1} = Σ_j=1^n c_j^{t-1}
- Assume self’s last action was c_self^{t-1}; for t=1, undefined.
- Define a **defection threshold** D_thr = (n-1), i.e. punish if at least one other player defected last round.
- Define a **recovery period** length = 1 round (punish briefly, then forgive).

---

### Round 1 (t=1)

- **Cooperate (play C).**
  
Start by cooperating, since no defection history exists and cooperation yields higher total payoffs if others cooperate too.

---

### Intermediate rounds (1 < t < r)

1. **Check last round's defection presence:**

   - If all other players cooperated last round:
     - i.e. coop_count^{t-1} = n (everyone cooperated including self).
     - **Cooperate** in round t.

   - Else (at least one defection among others):

     - **If currently in punishment round:**  
       - Defect in round t (punishment phase).
     - **Else:**  
       - Initiate punishment phase by defecting in round t.

2. **Punishment logic:**

   - The strategy implements a 1-round punishment after any defector is detected.
   - After the 1-round punishment, if others cooperate again, return to cooperation (forgiving).

3. **Implementation details of punishment state:**

   - Maintain a state variable `punish = False` initially.
   - At round t:
     - If any defection in round t−1 and `punish` is False, set `punish = True` and defect.
     - Else if `punish == True`, cooperate if no new defection detected, then reset `punish = False`.
     - If no defection detected, `punish = False`, cooperate.

---

### Last round (t = r)

- **Defect (play D).**

No future rounds to incentivize cooperation, so defect to gain maximal payoff;

---

## Pseudocode

```python
# State variables (persist across rounds)
punish = False  # whether in punishment phase

def strategy(t, r, n, history):
    """
    t: current round (1-based)
    r: total rounds
    n: number of players
    history: list of length t-1, each element is a list of n actions {C,D} of other players (including self) in round t-1
    """
    global punish
    
    if t == 1:
        # First round: cooperate to set cooperative tone
        action = 'C'
    
    elif t == r:
        # Last round: defect to maximize final payoff
        action = 'D'
    
    else:
        last_round_actions = history[-1]  # list of n actions in round t-1
        coop_count = sum(1 if a == 'C' else 0 for a in last_round_actions)
        
        # Check if there was defection by any other player last round
        # Exclude own last action:
        self_last_action = last_round_actions[self_player_index]
        defectors_last_round = any(
            a == 'D' for j, a in enumerate(last_round_actions) if j != self_player_index
        )
        
        if not defectors_last_round:
            # Everybody cooperated last round
            action = 'C'
            punish = False  # reset punishment state
        else:
            if not punish:
                # Enter punishment phase
                punish = True
                action = 'D'
            else:
                # Punishment phase done, give forgiveness if no new defections detected
                # Look at last round again:
                if not defectors_last_round:
                    punish = False
                    action = 'C'
                else:
                    # If defections continue, keep punishing
                    action = 'D'
    
    return action
```

---

## Explanation of Rationale

- Starting with cooperation fosters mutual benefit.
- Defections trigger a one-round punishment: defect once in response to defectors, reducing their payoff.
- Forgiveness re-establishes cooperation quickly, avoids long revenge cycles.
- Punishment deters free-riding but does not escalate indefinitely.
- In the last round, defecting is standard in finitely repeated prisoner's dilemma-type games because no future punishment is possible.
- This creates an incentive to cooperate before final round, sustaining cooperation through the bulk of the game.

---

## Behavior Summary

| Situation                                             | Action |
|-------------------------------------------------------|--------|
| 1st round                                             | Cooperate (C) |
| All cooperated last round                             | Cooperate (C) |
| At least one defector last round, not in punishment  | Defect (D) (punish) |
| In punishment phase and defectors still present      | Defect (D) |
| In punishment phase but no defectors last round      | Cooperate (C) (forgive) |
| Last round                                           | Defect (D) |

---

This **Forgiving Conditional Cooperation** strategy is simple, aligns clearly with a cooperative mindset, signals willingness to cooperate and punish defections fairly, and is consistent with standard repeated-game theory in public goods environments. It will often yield better group payoffs than unconditional defection or blind cooperation, especially if some players adopt similar or other cooperative strategies.
'''

description_AGGRESSIVE_1 = '''
Below is a detailed description of an **aggressive strategy** for the repeated n-player public goods game. This strategy is designed to maximize individual payoff by exploiting cooperation from others whenever possible, but defaults to maximizing short-term gain through defection, especially as the game nears the end. It punishes cooperators only insofar as maintaining dominance and extracting the greatest benefit from others' contributions.

---

### Aggressive Strategy: "Exploit-Then-Defect"

---

### Intuition and Design Rationale

- **Aggressiveness:** The player prioritizes maximizing personal payoff over collective benefit.
- **Exploitation:** Attempt to "free-ride" on any cooperation by others.
- **No naïve cooperation:** Does not cooperate first unless strictly beneficial.
- **Punishment or retaliation:** Defects in response to others’ cooperation to deny them payoffs.
- **Endgame defection:** Recognizes that in the last round(s), future retaliation is irrelevant, so always defects.

---

### Decision Rules

#### Variables:

- t = current round (1 ≤ t ≤ r)
- last_actions = vector of all players' actions from the previous round (empty in round 1)
- observed_cooperators = number of other players who cooperated in the previous round (excluding self)
- n = number of players
- k = multiplication factor
- r = total rounds

---

### Pseudocode

```
function aggressive_strategy(t, last_actions, n, k, r):

    if t == 1:
        # First round, no history
        # Aggressive mindset: defect to maximize immediate payoff
        return D

    else if t == r:
        # Last round: no future consequences, guaranteed defection
        return D

    else:
        # Intermediate rounds: observe past round

        # Count how many others cooperated last round
        observed_cooperators = count_cooperators(last_actions excluding self)

        # Decision logic:

        # If any other player cooperated last round,
        # defect to exploit their contribution this round
        if observed_cooperators > 0:
            return D

        # If no one cooperated last round,
        # continue defecting -- no benefit to cooperate alone
        else:
            return D
```

---

### Explanation:

- **Round 1**: Defect, since there's no history and cooperating is costly without guarantee others will cooperate.
- **Intermediate rounds (2 to r-1):**  
  - If others cooperated previously, defect to capture the public good share without paying the cost (free-riding).  
  - If others defected previously, continue defecting (no incentive to unilaterally contribute and be exploited).
- **Final round:** Defect unconditionally because no future retaliation/punishment can happen.

---

### Properties & Rationale

- **Aggressiveness:** Always maximizes immediate payoff, never sacrifices it to promote public good.
- **Exploits cooperation:** Takes advantage of cooperators by defecting whenever they appear.
- **No cooperation:** Never contributes own endowment, thus minimizing personal cost.
- **Punishment by defection:** Since this strategy never cooperates, it implicitly punishes cooperators by not reciprocating.
- **Endgame defection:** Standard backward induction logic implies defecting in last round(s) is dominant.

---

### Edge Cases

- **All defect last round:** Continue defecting, no incentive otherwise.
- **All cooperate last round:** Defect to exploit and maximize individual payoff.
- **Partial cooperation:** Defect to free-ride on cooperative minority.
- **Single round game (not allowed per spec):** Not applicable since r > 1.
- **Tie-breaks:** Not relevant—always defect.

---

### Summary

| Round            | Observed previous cooperation by others? | Action      |
|------------------|------------------------------------------|-------------|
| 1 (first round)  | N/A                                      | Defect (D)  |
| 2 to r-1         | Yes                                      | Defect (D)  |
| 2 to r-1         | No                                       | Defect (D)  |
| r (last round)   | Any                                      | Defect (D)  |

---

This strategy is **fully aggressive**, never sacrifices for the group, always defects to maximize short-term gain and exploits cooperators. It relies on the repeated structure only in sensing if others cooperated last round, but does not cooperate expecting reciprocity. This maximizes personal payoffs against cooperative opponents and provides strong incentives to "defect" in every round.
'''

description_AGGRESSIVE_2 = '''
Here is a description of an **aggressive strategy** for the N-Player Public Goods Game designed to maximize individual payoff by exploiting cooperation from others, minimizing one’s own contributions, and punishing unconditional cooperators or retaliators aggressively.

---

### Core Intuition of the Aggressive Strategy

- **Aggressive mindset:** Prioritize personal gain by defecting as much as possible.
- Exploit others’ cooperation but avoid being exploited.
- Punish cooperators who expect mutual cooperation by defecting persistently once betrayed or when exploitation opportunities appear.
- Maintain defection dominance to suppress cooperation in the group, but occasionally cooperate if it guarantees a higher payoff in the immediate round.
- In early rounds, probe opponents to identify naive cooperators to exploit later.
- In the last round, defect since there is no future retaliation risk (standard backward induction logic).

---

### Decision Rule Specification

#### Notation
- `t`: current round (1 ≤ t ≤ r)
- `H_t`: history up to round t-1, including all players' action profiles
- `c_i,t`: your action at round t (0 = defect, 1 = cooperate)
- `coop_count_t`: number of players who cooperated in round t (including yourself)
- `defection_threshold`: threshold number of cooperators to make cooperation briefly profitable

---

### Pseudocode / Rule Description

```pseudocode
Initialize:
  punished_players = empty set  # tracks players who have been "marked" for punishment

Parameters:
  k: multiplication factor (1 < k < n)
  n: number of players
  r: total rounds
  defection_threshold = ceil(n / k)  # heuristic threshold where cooperating yields some benefit

Round t = 1:
  # First round: defect to avoid giving free benefit
  choose D

For round t in 2 to r-1:
  Observe previous round's actions: A_{t-1} = [a_1,t-1, a_2,t-1, ..., a_n,t-1]

  Identify cooperators and defectors last round:
    coop_last = set of players who cooperated in t-1
    defect_last = set of players who defected in t-1

  # Mark for punishment any player who cooperated last round and failed to gain noticeably (signals naïve)
  # Or players who cooperated inconsistently (to test for exploitability)
  For each player p in coop_last:
    If p not in punished_players:
      punished_players.add(p)

  # Determine expected payoff:
  # If many cooperators last round, defect to exploit
  if size(coop_last) ≥ defection_threshold:
    # Exploit cooperators by defecting this round
    choose D

  else:
    # Too few cooperators, cooperating is costly and exploited
    choose D

  # Exception: if all players cooperated last round (rare),
    # consider cooperating this round to share maximum gain and avoid being sole defector (to avoid reciprocated mass defection)
    if size(coop_last) == n:
      choose C

Round t = r (last round):
  # Last round: defect, no future retaliation possible
  choose D
```

---

### Explanation and Rationale

- **Round 1**: Defect immediately. Cooperate only if you expect others to cooperate to gain more, but with no prior round info, defect is safer and aggressive.
  
- **Middle rounds (2 to r-1)**:  
  - Observe the number of cooperators last round.  
  - If many cooperated, defect to exploit: You retain your private endowment (1) plus a share of public good created by others.  
  - If few cooperated, still defect because cooperating yields no significant benefit (given k < n means full cooperation yields max payoff, but partial cooperation is exploited).  
  - Punish players who cooperated last round by "marking" them (no direct punishment here, but you exploit and never cooperate with them again). This is implicit since you always defect.  
  - Only cooperate if everyone cooperated last round perfectly, and the multiplied payoff divided among all justifies cooperation (to avoid mutual assured defection spiral). But this rarely happens as you defect most of the time.

- **Last round**: Defect unconditionally.  
  Standard backward induction applies, no incentive to cooperate when no future rounds exist.

---

### Edge Cases and Further Notes

- **If k is close to n** (public good almost fully efficient), cooperating when all cooperate is beneficial. The strategy briefly cooperates if all cooperated last round to harvest payoff with minimum cost.  
- **If r=2 (minimum repeat)**, behave aggressively at round 1 and defect on round 2 (last round).  
- **If opponents never cooperate, strategy converges to constant defection** which optimizes your payoff in absence of cooperation.  
- **If opponents cooperate blindly, the strategy exploits them to maximum effect by defecting whenever possible.**

---

### Summary

| Round          | Condition                        | Action           | Reason                                            |
|----------------|--------------------------------|------------------|--------------------------------------------------|
| 1              | Always                         | Defect           | No info yet, maximize immediate gain             |
| 2 to r-1       | All cooperated last round      | Cooperate        | Mutual cooperation payoff above defection payoff|
| 2 to r-1       | ≥ defection threshold cooperators | Defect           | Exploit cooperators                               |
| 2 to r-1       | Otherwise                     | Defect           | Cooperation not profitable to you                 |
| r (last round) | Always                         | Defect           | No future rounds, defect to maximize private gain|

---

This strategy is **aggressive** because:

- It starts and ends with defection.
- It exploits any cooperation found.
- It avoids giving free benefits.
- It punishes cooperators by defecting constantly.
- It only cooperates defensively to avoid mutual destruction when everyone else cooperates.

---

If you want, I can provide a more formal pseudocode or a decision flowchart next. Would you like that?
'''

description_AGGRESSIVE_3 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Strategy Intuition

An *aggressive* strategy in a public goods game aims to maximize individual payoff by exploiting cooperators while punishing any who expect reciprocity or cooperation. Since the game repeats and players observe all past actions, the key is to defect as long as that benefits you. However, in the final round—where no future retaliation exists—you should defect with certainty. In early rounds, you can probe for cooperation but only to exploit it immediately.

---

### Core Idea

- **Always defect** except possibly cooperate in the very first round if doing so can potentially exploit naive cooperators.
- If others cooperate in any prior round, exploit them by defecting in the next round, as defecting yields higher payoffs against cooperators.
- Never cooperate after observing defection.
- Always defect in the last round (no incentive to cooperate).

---

### Decision Rules

1. **Round 1 (t = 1):**  
   - Cooperate **only if** you want to probe for cooperators to exploit in the next round.  
     (Optional; aggressive players often defect immediately, but cooperating once can bait others.)  
   - Otherwise, defect immediately to never risk payoff loss.

2. **Rounds 2 to r-1 (2 ≤ t < r):**  
   - If **any player cooperated in previous round (t-1)** → defect to exploit cooperation.  
   - Else (no cooperation last round) → defect.  
   (Never cooperate after the first round because cooperation is exploitable.)

3. **Last Round (t = r):**  
   - Always defect; no incentive to cooperate as no future retaliation or reward.

---

### Edge Cases

- **If r = 2:**  
  - Follow Round 1 rule for t=1, always defect for t=2.

- **If no one ever cooperates:**  
  - You defect every round, matching others for max personal payoff with no loss.

---

### Benefits of This Strategy

- Maximizes immediate gains by free-riding on cooperators.
- Punishes hopeful cooperators by never reciprocating.
- Saves from being exploited by always defecting except optionally probing once.
- In the final round, defects regardless, securing maximum private payoff without risk.

---

### Pseudocode

```
function aggressive_strategy(history, round, n, r):
    # history: list of all past rounds' actions,
    # each entry: list of length n of actions {C, D}
    # round: current round number (1-based)
    # n: number of players
    # r: total number of rounds

    if round == 1:
        # Optional probing behavior:
        # To be purely aggressive, defect immediately
        return 'D'
        # Alternatively, bait once:
        # return 'C'

    elif round == r:
        # Last round: always defect
        return 'D'

    else:
        # check cooperation in previous round
        previous_round = history[round - 2]  # zero-indexed
        if 'C' in previous_round:
            # Exploit cooperators by defecting
            return 'D'
        else:
            # No cooperation last round: defect anyway
            return 'D'
```

---

### Summary

- **First round:** Defect immediately (or optionally cooperate once as a probe)
- **Intermediate rounds:** Defect always, exploiting any cooperators
- **Final round:** Defect always

This aggressive approach ensures you never lose payoff by cooperating yet opportunistically exploits cooperators' presence. It aligns perfectly with aggressive, self-interested play in a repeated public goods game under standard assumptions.
'''

description_AGGRESSIVE_4 = '''
**Aggressive Strategy for the N-Player Public Goods Game**

---

### Intuition of the Strategy

- **Goal:** Maximize individual payoff aggressively by exploiting cooperative players as often as possible.
- **Approach:** Exploit cooperators, punish defectors only enough to maintain inference about their actions, do not waste payoffs by cooperating yourself except the unavoidable minimum.
- **Aggressiveness:** Never cooperate voluntarily. Only cooperate if it strictly increases own payoff due to high returns and the presence of many other cooperators.
- **Punishment:** Defecting players are *punished* only by continued defection (i.e., no reward for them), but the strategy avoids granting benefits to others by cooperating in reciprocation.
- **Adaptiveness:** Use observed history to detect whether cooperating can be momentarily beneficial (to get public good shares) and time last-round defections to maximize final payoff.

---

### Decision Rules

---

#### Round 1 (No history)

- Defect (D) outright.
- Reason: No basis to trust others; cooperation would be exploited.
- Aggressive nature: go for maximum private payoff on first move.

---

#### Round t, 2 ≤ t < r (Intermediate rounds)

1. **Observe previous round’s actions of all players:** `A_{t-1} = {a_{1,t-1}, ..., a_{n,t-1}}`
2. **Count cooperators in previous round:**
   \[
   C_{t-1} = \sum_{j=1}^n I(a_{j,t-1} = C)
   \]
3. **Estimate benefit of cooperation in this round:**

- If *many* players cooperated previously (threshold to be defined based on k and n):
  
  - Because payoff for cooperating depends on others’ cooperation, cooperating only makes sense if:

    \[
    \text{payoff if I cooperate} = 0 + \frac{k}{n} \times (C_t) > 1 + \frac{k}{n} \times (C_t) - 1
    \]

  Actually, this just means cooperating is only beneficial if you expect many others to cooperate this round. But since we don’t know future moves, rely on prior round cooperation as predictor.

- **Aggressive twist:** Instead of cooperating, **always defect** to gain the private payoff (1) **plus** share of public good created by others’ cooperations.

4. **If nobody cooperated previously (`C_{t-1} = 0`):**

- Defect to avoid wasting private payoff.

---

#### Final Round (t = r)

- Defect to avoid "endgame cooperation".
- Since no future rounds exist, no incentive to cooperate.

---

### Summary

| Round        | Condition                             | Action     | Reason                                         |
|--------------|------------------------------------|------------|------------------------------------------------|
| t = 1        | No history                         | Defect (D) | Avoid exploitation, maximal private payoff     |
| 1 < t < r    | If previous round had any cooperators | Defect (D) | Exploit others’ cooperation                     |
|              | Else                              | Defect (D) | No incentive to cooperate                        |
| t = r (last) | Always                           | Defect (D) | Endgame defection, no future benefit             |

---

### Optional Refinement for Slight Exploitation of Cooperators (Aggressive but Adaptive)

If you want *some* exploration of cooperation when payoff gain is clear:

- On rounds 2 to r-1:

  - If proportion of cooperators last round > \(\frac{n}{k}\) (meaning public good multiplication is relatively high), **cooperate once** in hopes of leveraging others’ cooperation.

  - But immediately revert to defection next round to exploit.

---

### Pseudocode

```python
def aggressive_strategy(round_t, r, n, k, history):
    # history: list of tuples [(a_1, ..., a_n), ...] for previous rounds
    
    # Round 1: no history, defect
    if round_t == 1:
        return "D"
    
    # Final round: defect to maximize private payoff
    if round_t == r:
        return "D"
    
    # Intermediate rounds:
    prev_actions = history[-1]  # actions at t-1
    cooperators_last_round = sum(1 for a in prev_actions if a == "C")
    
    # Optional cooperation threshold
    cooperation_threshold = n / k
    
    # Aggressive baseline: always defect
    # Optional: cooperate if last round had enough cooperators 
    if cooperators_last_round > cooperation_threshold:
        # Aggressive variant: defect anyway to exploit them
        return "D"
        # To add brief cooperation to exploit might be:
        # return "C"
    else:
        return "D"
```

---

### Explanation of Aggressiveness

- **Never initiates cooperation, minimizing exploitation risk.**
- **Always defects to maximize private payoff 1 from the private endowment.**
- **Takes advantage of others' cooperation by free-riding on public good returns without contributing.**
- **Defects in last round to avoid costly cooperation when no punishment or future incentive exists.**
- **No forgiveness or reciprocation: punishes defectors by defecting but never pays cost of cooperation.**

---

**In sum, this "All-Defect with Exploit" strategy is aggressive because it never sacrifices own endowment voluntarily and always leeches payoffs from others’ cooperation, thus maximizing individual gain at the group’s expense.**
'''

description_AGGRESSIVE_5 = '''
Below is a design for an **aggressive** strategy tailored for the described repeated N-player public goods game.

---

### Core Idea:  
**Maximize your own payoff at the expense of others by defecting consistently, punishing cooperators by exploiting their contributions, while cooperating only strategically to disrupt potential collusion or to avoid detection as a pure defector.**

---

## Aggressive Strategy Description

### Intuition:  
- Cooperate is costly (lose private endowment), defect gains private payoff.
- Multiplication factor \( k < n \) means the public good never returns full value of contribution.
- Defection always gives better private payoff than cooperation **in a mixed group** since you keep 1 unit **plus** benefit from others' cooperation.
- Other players may try to cooperate to boost group payoff, but you will exploit them.
- You want to maximize your payoff *aggressively* by defecting mostly, but:
  - Signal defection early to encourage others to defect.
  - Break any fragile cooperation by defecting when opponents cooperate.
  - Cooperate strategically only in rare cases to confuse others or disrupt their strategies.
- In last rounds, defect always since no future retaliation.

---

### Decision Rules

- **Round 1 (No history): Defect**  
  - Start by defecting to immediately maximize private payoff and signal aggressiveness.
- **Round \(t > 1\):**  
  - If **all opponents cooperated last round**, defect this round to exploit their cooperation.  
  - Else if **any opponent defected last round**, defect to punish defectors and maintain aggressive stance.
  - Exception:  
    - If the previous round had unanimous defection by all players (including yourself), cooperate this round **once** to test if others will cooperate back. This is an exploratory "breaking the defection deadlock" move.  
    - If the cooperation is not reciprocated (others defect), return immediately to defecting every round.  
- **Last round (round \(r\))**: Defect unconditionally (no future retaliation possible).  

---

### Summary of Treatment of Special Cases

| Round       | Condition                                            | Action    | Reason                                                                                  |
|-------------|-----------------------------------------------------|-----------|-----------------------------------------------------------------------------------------|
| 1           | No history                                          | Defect    | Start aggressively with max private benefit                                           |
| t = 2 to r-1| Previous round all C                                | Defect    | Exploit cooperators                                                                    |
| t = 2 to r-1| Previous round any D                                | Defect    | Punish defectors & maintain dominance                                                  |
| t = 2 to r-1| Previous round all D                               | Cooperate once (only once) | Test cooperative response to break defection trap                                    |
| r (last)    | Any history                                         | Defect    | No incentive to cooperate, maximize final payoff                                      |

---

## Pseudocode

```python
def aggressive_strategy(t, r, history):
    """
    t: current round index (1-based)
    r: total rounds
    history: list of tuples (actions_this_round) from previous rounds
             each actions_this_round is a list of length n of 'C' or 'D'
  
    Returns: 'C' or 'D' (action choice for this round)
    """

    # Initialize memory
    # We only track if we've cooperated once after defection deadlock
    if not hasattr(aggressive_strategy, "cooperated_after_defection_deadlock"):
        aggressive_strategy.cooperated_after_defection_deadlock = False

    # Last round: defect
    if t == r:
        return 'D'

    # Round 1: defect
    if t == 1:
        return 'D'

    # Extract last round's actions
    last_round_actions = history[-1]
    n = len(last_round_actions)

    all_cooperated = all(a == 'C' for a in last_round_actions)
    any_defected = any(a == 'D' for a in last_round_actions)
    all_defected = all(a == 'D' for a in last_round_actions)

    # If last round all cooperated -> exploit by defecting
    if all_cooperated:
        return 'D'

    # If last round any defected -> punish by defecting
    if any_defected:
        return 'D'

    # If last round all defected
    if all_defected:
        if not aggressive_strategy.cooperated_after_defection_deadlock:
            # Cooperate once to test others
            aggressive_strategy.cooperated_after_defection_deadlock = True
            return 'C'
        else:
            # Return to defecting
            return 'D'

    # Default fallback (should not reach here)
    return 'D'
```

---

## Explanation and Why This is Aggressive

- **Always defects except for a single one-time probe cooperation** after a unanimous defection round. This is to test if others are willing to cooperate, but never truly trusts cooperation.
- Exploits cooperative opponents by defecting against them.
- Punishes defectors by defecting.
- Defects unconditionally on the last round to maximize final immediate payoff.
- Does not sustain long-term cooperation; aims for **maximum short-term exploitation**.
- The one cooperation after a deadlock is a calculated disruption, not an attempt to build trust.
- No forgiveness or grudges beyond the single cooperation test after unanimous defection: fully opportunistic and exploitative.

---

This strategy maintains an **aggressive** and **exploitative** posture tailored to maximize your payoff against unknown strategies, without giving trust or incurring cooperation costs unnecessarily. It punishes cooperation from opponents and defects to get the best return whenever possible.
'''

description_AGGRESSIVE_6 = '''
Here is a strategic design for an **aggressive strategy** in the described N-player repeated public goods game. The strategy aggressively prioritizes personal payoffs over the group, uses defections to punish cooperators, and exploits cooperative players whenever possible.

---

# Aggressive Strategy: "Exploit & Punish"

### Intuition
- **Never voluntarily cooperate unless forced** (to avoid being exploited).
- **Start by defecting to gain immediate private payoff.**
- **Punish cooperators by defecting to maximize own payoff when others cooperate.**
- **If everyone defects, keep defecting (no incentive to cooperate).**
- **If some cooperate, exploit them by defecting to maximize personal payoff.**
- **No forgiveness or cooperation attempts — always aggressive.**
- In the **last round**, defect to avoid being exploited; no future punishment possible.

---

# Formal Description

Let:

- t = current round index (1 ≤ t ≤ r)
- History_{t-1} = actions of all players in rounds 1 to t-1
- C_{t-1} = set of players who cooperated in round t-1 (can be empty)

---

## Decision Rules

### Round 1 (t = 1)

- **Action:** Defect (D)
- **Rationale:** No information yet, start off by maximizing private gain.

---

### Rounds 2 to r-1 (1 < t < r)

- Observe last round's actions.
- Define coop_count_{t-1} = number of cooperators in the last round.
- **If coop_count_{t-1} > 0:**
  - Assume cooperators can be exploited this round.
  - **Action:** Defect (D) to exploit cooperating players.
- **Else (if nobody cooperated last round):**
  - Everyone defected last round, so:
  - **Action:** Defect (D), maintain status quo and maximize private gain.

---

### Last Round (t = r)

- **Action:** Defect (D)
- **Rationale:** No future rounds exist to punish or reward cooperators, so defect to maximize final payout.

---

## Summary of Aggressiveness

- The strategy never cooperates on its own initiative.
- It punishes "cooperators" by defecting to exploit their contributions.
- It never tries to establish cooperation.
- It exploits any cooperation in the group fully.
- It actively enforces a "defection equilibrium" by never cooperating and never forgiving.

---

# Pseudocode

```python
def aggressive_strategy(t, r, history):
    """
    t: current round (1-based)
    r: total rounds
    history: list of length t-1 where each element is a list of players' actions ['C' or 'D']
    """

    # Round 1: defect
    if t == 1:
        return 'D'

    # Last round: defect
    if t == r:
        return 'D'

    # For rounds 2 to r-1:
    last_round_actions = history[-1]  # actions of all players in round t-1
    coop_count = last_round_actions.count('C')

    if coop_count > 0:
        # Exploit cooperators by defecting
        return 'D'
    else:
        # Everyone defected last round, keep defecting
        return 'D'
```

---

# Justification of Aggressiveness

- **No cooperation** means consistently maximizing individual payoff through private retention.
- **Defecting while others cooperate yields maximal individual returns (1 + (k/n)*coop_count)** — bigger than cooperating payoff.
- **Punishment by never cooperating sends a credible signal that cooperation is not rewarded from you.**
- **Last round defection is standard to avoid the "endgame cooperation" trap.**

---

# Handling Edge Cases

| Edge Case                         | Action                              | Reasoning                                   |
|----------------------------------|-----------------------------------|---------------------------------------------|
| 1st round (no history)            | Defect                            | Gain private payoff; no info to cooperate.  |
| Last round                      | Defect                            | No future rounds; no incentive to cooperate. |
| A round where all defect before  | Defect                            | No cooperation to exploit; maintain defection.|
| Some cooperate in previous round | Defect                            | Exploit cooperators; maximize payoff.       |

---

# Additional Notes

- This strategy **never cooperates proactively**.
- It **always defects** regardless of potential group payoffs, aggressively optimizing for individual cumulative payoff.
- It implicitly punishes any player who tries to cooperate by not reciprocating.
- It expects no reciprocation or cooperation attempts from others and exploits them if they occur.

This strategy is a strong, simple, and clear aggressive baseline for tournaments involving independent agents in this public goods setting.
'''

description_AGGRESSIVE_7 = '''
Below is a description of an aggressive strategy designed for the described N-player repeated Public Goods Game with parameters (n, r, k).

---

### Strategy Name: **Aggressor**

**High-level rationale:**  
The strategy aggressively exploits cooperative players by defecting whenever possible to maximize immediate payoffs, while ensuring it does not become a sucker (i.e. cooperating while others defect). It punishes cooperators only after a defection is detected, but otherwise defaults to defection to maximize returns. It does not attempt long-term cooperation or trust building since it assumes opponents are self-interested and that the multiplication factor k < n does not guarantee mutual cooperation is stable.

---

### Design Details

#### 1. Decision Rules per Round

- **Round 1 (No history yet):**  
  Defect (D) immediately.  
  *Reason:* No assurance others will cooperate; maximize immediate payoff.

- **Rounds 2 to r-1:**  
  - Check the previous round's history:  
    - If **any player cooperated** in the previous round (including self or others), **Defect (D)**.  
      *Rationale:* Exploit cooperators by free-riding on public good contributions.  
    - If **no player cooperated** in the previous round (everyone defected), continue to **Defect (D)**.  
      *Rationale:* No incentive to cooperate if the group consistently defects.

- **Round r (Final round):**  
  Defect (D) regardless of history.  
  *Reason:* Final round has no future consequences; defect to maximize immediate private payoff.

---

#### 2. Edge Case Handling

- **First Round:**  
  No past info, so Defect to never be exploited.

- **If all players defect consistently:**  
  Strategy will also defect indefinitely.

- **If some cooperate in past rounds:**  
  Always defect next round to maximize individual payoff from their contributions.

- **Final round:**  
  Always defect since no future punishment possible.

---

### Summary Table

| Round               | Condition                                  | Action |
|---------------------|--------------------------------------------|--------|
| 1                   | No history                                | Defect |
| 2 to r-1            | Any cooperation by any player last round | Defect |
| 2 to r-1            | No cooperation last round                  | Defect |
| r (final round)     | Any history                               | Defect |

---

### Pseudocode

```python
def AggressorStrategy(round_number, history, n, r, k):
    # history: list of action profiles for previous rounds
    # each element: list of length n with 'C' or 'D' per player

    if round_number == 1:
        # First round, no info
        return 'D'

    if round_number == r:
        # Last round, defect
        return 'D'

    # Check if any player cooperated last round
    last_round_actions = history[-1]
    if 'C' in last_round_actions:
        # Exploit cooperators by defecting
        return 'D'

    # Otherwise, continue defecting
    return 'D'
```

---

### Why is this strategy “Aggressive”?

- It **never initiates cooperation**, avoiding immediate exploitation.
- It **immediately exploits any detected cooperation in the group** by defecting to reap maximal payoff from their contributions.
- It does **no forgiveness or reciprocation**, maintaining defection to maximize payoff over all rounds.
- It **does not cooperate even in the last round**, leveraging the fact that no future punishment is possible to maximize last round gains.

---

### Expected behavior summary

- Against cooperators, it reaps high payoffs ("free-rides") while contributing nothing.
- Against defectors, it yields the baseline payoff of 1.
- It never risks cooperation loss from being exploited.
- It prioritizes immediate exploitation over group gain or reputation.

---

This is a pure, no-compromise defection strategy with conditional exploitation, characteristic of an aggressive mindset.
'''

description_AGGRESSIVE_8 = '''
Here is a detailed design for an **Aggressive Strategy** in the specified N-Player Public Goods Game, tailored to maximize individual payoff by exploiting cooperators and minimizing unnecessary cooperation.

---

## Strategic Motivation — Why "Aggressive"?

- **Aggression** here means maximizing personal payoff primarily through defection.
- Exploit cooperators by defecting when they contribute.
- Avoid being exploited by cooperating rarely or only under specific controlled circumstances.
- Punish defectors marginally to try to destabilize cooperation attempts but never lose out to them.
- Try to induce cooperative players to contribute first, then free-ride on their contributions.
- Accept the risk of mutual defection if opponents are too greedy—this is better than giving them a free ride.

---

## Strategy Description

We propose a **Conditional Defection with Opportunistic Cooperation (CDOC)** strategy:

### Key ideas:
- **Round 1 (initial round):** Always defect. No information available; aggressive stance is to exploit any cooperative players.
- **From Round 2 to Round r-1 (intermediate rounds):**
  - **If previous round showed *any* cooperation by others:** Defect to free-ride on their cooperation.
  - **Else (if previous round was all defect):** Cooperate once to try to "seed" cooperation (test if others will cooperate).
- **Round r (final round):** Defect unconditionally (endgame defection).
  
This strategy:
- Exploits cooperators by defecting immediately when cooperation is detected.
- Tries to break cycles of unanimous defection by occasionally cooperating when everyone else defects.
- Ends with defection to avoid being suckered in the last round (classic backward induction).
- Provides a credible "sting" to encourage others to cooperate, then exploits that cooperation.
- Ensures no sustained cooperation beyond what opponents voluntarily provide.

---

## Pseudocode

```python
# Inputs:
# - history: List of previous rounds, each with the actions of all players (including self).
#   history[t] = list of actions in round t (indexed 0 to t-1).
# - player_index: own player index (0-based)
# - n, r, k: parameters as defined

def aggressive_strategy(history, player_index, n, r, k):

    current_round = len(history) + 1  # rounds are 1-indexed in spec

    # Round 1: defect
    if current_round == 1:
        return 'D'

    # Round r (last round): defect (endgame defection)
    if current_round == r:
        return 'D'

    # For intermediate rounds (2 to r-1):
    # Look at previous round's actions of *other* players
    last_round_actions = history[-1]
    
    # Count number of cooperators excluding self in last round
    other_cooperators = sum(1 for i, act in enumerate(last_round_actions) 
                           if i != player_index and act == 'C')

    if other_cooperators > 0:
        # Others cooperated last round => defect to exploit
        return 'D'
    else:
        # No one else cooperated last round => try cooperating once to break deadlock
        return 'C'
```

---

## Detailed Explanation

1. **Why defect first round?**  
   No history to trust; cooperating opens you to exploitation without any immediate payoff advantage (since all cooperate leads to only gain k, but starting with defection maximizes individual payoff unless all cooperate).

2. **Why defect last round?**  
   Classic backward induction tells cooperation on last round is strictly dominated by defection; cooperating risks exploitation for no future reward.

3. **Why cooperate when everyone else defected in the previous round?**  
   If all defect, the payoff is baseline 1 for everyone. A single cooperator can trigger a "public good" effect that benefits all if others choose to cooperate next round. This is a probing move hoping to induce cooperation from others.

4. **Why defect if any player cooperated last round?**  
   Defecting then reaps full private gain plus a share of the public good funded by cooperators, maximizing personal payoff by free-riding.

---

## Edge Cases and Justifications

| Scenario                                  | Strategy Action                                     | Reasoning                                      |
|-------------------------------------------|----------------------------------------------------|------------------------------------------------|
| First round (no history)                   | Defect (D)                                         | Maximize initial take, get immediate advantage |
| All defected last round                    | Cooperate (C) to try to break stalemate            | Attempt to induce cooperation, poke opponents  |
| Some cooperated last round                 | Defect (D) to exploit cooperators                   | Free-ride on their contributions                 |
| Final round                               | Defect (D)                                         | Prevent last-round exploitation                  |
| Multiple opposing configurations          | Follow rules strictly based on last round actions | Avoid complex assumptions or risk cooperation loss |

---

## Summary

- Aggressive, opportunistic defecting with minimal cooperation only to attempt to break mutual defection deadlocks.
- Defection is the baseline choice; cooperate only if everyone else defected last round (and you still have rounds remaining).
- No cooperation on final round to avoid exploitation.
- Exploit cooperators to maximize payoff.
- This strategy aligns well with an aggressive mindset, balancing exploitation with occasional cooperation to seed potential gains.

---

If you want, I can also help you to extend this strategy with more nuanced variants (e.g., tracking individual cooperators), but the above design is a clean aggressive baseline that respects all constraints and assumptions.
'''

description_AGGRESSIVE_9 = '''
Below is an **aggressive strategy** for the N-Player Public Goods Game described.

---

## Strategy Name: Aggressive Exploiter

### Intuition
- **Aggressive mindset:** Maximize your own payoff by exploiting cooperators.
- Always defect unless you can gain some utility by cooperating.
- Punish cooperation from others by defecting to maximize your gain.
- Do not waste endowment contributing where it’s not profitable.
- Use defection as leverage in early rounds; consider cooperation only if it can net strictly higher payoffs.
- Exploit cooperative players if any, else always defect.
- In the final round, defect always to avoid being exploited later.

---

### Decision Rules (per round t)

Let:  
- \( c_j^{(t-1)} \) denote player \( j \)'s action in previous round (C = 1, D = 0)  
- \( \text{totalCoop}^{(t-1)} = \sum_{j=1}^{n} c_j^{(t-1)} \) be total cooperators in last round

---

#### 1. **First round (t = 1)**

No history is available:

- **Defect**  
  Reason: No information on cooperators to exploit. Cooperating blindly loses the private payoff of 1.

---

#### 2. **Intermediate rounds (1 < t < r)**

Observe prior round's cooperators:

- If \(\text{totalCoop}^{(t-1)} > 1\) (others cooperated):
  - **Defect**  
    Exploit the group’s cooperation by free-riding, gaining 1 + \(\frac{k}{n} \times \text{totalCoop}^{(t-1)}\) which > cooperating payoff.
- Else if \(\text{totalCoop}^{(t-1)} = 1\) and *that single cooperator is yourself* (meaning you cooperated alone in last round):
  - **Defect** now  
    Since you got no benefit last round (0 + (k/n)*1), better to defect and get 1 + (k/n)*\text{others' cooperation} next round.
- Else if \(\text{totalCoop}^{(t-1)} = 1\) and *you defected last round*:
  - **Defect** again  
    No incentive to cooperate yet.
- Else if \(\text{totalCoop}^{(t-1)} = 0\) (no cooperation last round):
  - **Defect**  
    No benefit cooperating alone or cooperating when no one else does.
- Else (no other cases):  
  - **Defect**

Summary:  
- Defect unless all other players defected.  
- If all defected last round, cooperating alone yields payoff 0 + (k/n)*1 which is < 1 (defect payoff), so still defect.

Thus, you **always defect in intermediate rounds**.

---

#### 3. **Last round (t = r)**

- **Defect**
  
Rationale: No future rounds to punish or be punished, so no incentive to cooperate.

---

## Summary of Behavior

| Round        | Condition                                 | Action  |
|--------------|-------------------------------------------|---------|
| t = 1        | No past info                              | Defect  |
| 1 < t < r    | Any cooperators last round? (totalCoop > 1) | Defect  |
| 1 < t < r    | 1 cooperator last round (either you or others) | Defect  |
| 1 < t < r    | No cooperators last round (totalCoop = 0)  | Defect  |
| t = r        | Last round                               | Defect  |

---

## Pseudocode

```python
def aggressive_exploiter_strategy(round_t, r, n, k, history):
    # history is list of tuples: [(c_1^{(1)},...,c_n^{(1)}), ..., (c_1^{(t-1)},...,c_n^{(t-1)})]
    # c_i = 1 if C, 0 if D
    
    if round_t == 1:
        # First round: defect
        return 'D'
    
    # Get last round's cooperation vector
    last_round = history[-1]
    total_coop = sum(last_round)
    
    # Last round cooperators
    cooperators = [i+1 for i, c in enumerate(last_round) if c == 1]
    
    if round_t == r:
        # Last round: defect
        return 'D'
    
    # Intermediate rounds:
    # Defect if total cooperators > 1
    if total_coop > 1:
        return 'D'
    
    # If exactly one cooperator last round
    if total_coop == 1:
        # If you cooperated last round (assuming player index is known - e.g. my_index)
        if last_round[my_index - 1] == 1:
            return 'D'  # switch to defection to exploit next round
        else:
            return 'D'  # continue defection
    
    # If no cooperators last round (total_coop == 0)
    return 'D'
```

*Note*: The strategy requires knowledge of own player index (`my_index`) to check last round's own action, which is reasonable as each player knows their own action history.

---

## Alignment With Aggressive Mindset

- Always defects to avoid paying the cooperation cost.
- Exploits cooperators, maximizing the private payoff by free-riding.
- Never cooperates — no trust or generosity.
- Never attempts to build cooperation or punish defections.
- Attempts to maximize own payoff by taking the "safe" defection action.
- Maximizes gain especially when others cooperate, by defecting.
- Avoids risk of being exploited by cooperating.

---

If you want, I can also provide variants with some limited cooperation in early rounds for potential detection of cooperators, but pure aggressive exploitation will maximize your payoff against any strategy trying to cooperate.
'''

description_AGGRESSIVE_10 = '''
Here is an **aggressive strategy** designed for the N-Player Public Goods Game described. It explicitly prioritizes maximizing your own payoff by defecting when it benefits you most, punishing cooperators to discourage free-riding, and exploiting cooperative tendencies of others.

---

## Strategy Rationale / Objective

- **Always defect by default** to maximize immediate private payoff.
- **Punish cooperators** by defecting whenever possible to exploit their contributions.
- **Exploit cooperating players if they are numerous enough** to generate an above-1 payoff despite your defection.
- **Avoid cooperating yourself, except in a calculated last-round move** to prevent future retaliations or for theoretical completeness.
- **Adapt only minimally to avoid being exploited or cooperating unnecessarily.**

---

## Intuition on Payoffs

- Defecting yields immediate private payoff of 1 plus your fraction of the public good.
- If enough others cooperate, defecting maximizes payoff.
- Cooperating costs you the private 1, only profitable if everyone cooperates.
- Mutual defection yields payoff 1, which is a baseline safe payoff.
- Because the multiplication factor k < n, defecting typically yields more payoff if at least some cooperate.

---

## Decision Rules

---

### Round 1 (No history)

- Defect unconditionally to establish aggressive stance and avoid giving free benefit.
- Reason: Cooperating on first round is risky and aggressive mindset aims to maximize own payoff immediately.

---

### Round t ∈ {2,..., r-1}

- If at least one player cooperated in the previous round, defect.
  - Rationale: Exploit cooperators; never reward them.
- Else if all players defected last round, defect.
  - Rationale: Stick to defection baseline.
- In other words: **Always defect in rounds 2..r-1 regardless of history.**

---

### Round r (Last round)

- Defect again.
- Reason: No future rounds, so no incentive to cooperate for reputation or future retaliation.
- Aggressive mindset: extract max payoff now.

---

## Summary

| Round           | Cooperate or Defect?               | Reason                                       |
|-----------------|----------------------------------|----------------------------------------------|
| First round     | Defect                           | Establish aggressive stance immediately      |
| Middle rounds   | Defect                           | Punish cooperators; do not reward cooperation|
| Last round      | Defect                           | No future consequence; maximize immediate payoff|

---

## Pseudocode

```python
def aggressive_public_goods_strategy(history, current_round, total_rounds, n, k):
    # history: list of length (current_round - 1), each element is a list of actions by all players in that round; 
    # actions are 'C' or 'D'. history[t][i] is player i's action in round t (0-based).
    # current_round: integer starting from 1
    # total_rounds: r
    # n: number of players
    # k: multiplication factor

    # Always defect, regardless of history
    return 'D'
```

The pseudocode is extremely simple because the aggressive strategy involves **never cooperating** under any circumstance.

---

## Why is this strategy aggressive?

- It **never grants concessions** (never cooperates).
- It **exploits** any cooperators by defecting.
- It **removes trust or reciprocation**, pushing the game into defection-dominant state.
- It aims to maximize individual short-term payoff (and total payoff) by prioritizing defection, leveraging any cooperation by others.
- It does not get trapped in cooperation cycles or punished by complex conditional cooperation strategies because it always defects.

---

## Handling edge cases

- **First round**: No history, defaults to defect.
- **Last round**: Same as other rounds, no cooperate to attempt future reciprocity.
- **If all others cooperate**: Exploits maximum cooperation by defecting for max payoff.
- **If all defect**: Matches baseline payoff of 1, never loses out.
- **Mixed history**: Always defects, punishing partial cooperation by others.

---

This aggressive strategy is straightforward but effective in an environment without communication, coordination or trust. It is robust and maximizes exploitation of cooperators while minimizing losses to defectors.
'''

description_AGGRESSIVE_11 = '''
Here is an aggressive strategy for the N-Player Public Goods game, designed to maximize individual payoff by exploiting cooperation from others if possible, but primarily aiming to defect whenever profitable. 

---

### Strategy Name: **"Exploit & Punish"**

---

### Core Idea:
- **Aggressive mindset:** Prioritize defecting to maximize immediate payoff.
- **Exploit cooperators:** If others cooperate, defect to get the highest payoff.
- **Punish contributors:** If others defect, punish by continuing to defect (never cooperate).
- **Never initiate cooperation except when forced.**
- **Use last round defection to avoid being exploited.**

---

### Decision Rules Overview:

| Round           | Decision Rule                                                                                     |
|-----------------|--------------------------------------------------------------------------------------------------|
| Round 1         | Defect to test if others cooperate and maximize initial payoff                                   |
| Rounds 2 to r-1 |  
- If in the previous round at least one other player cooperated → Defect (exploit cooperation)  
- Else (no cooperators last round) → Defect (punish by defecting)  
|
| Round r (Last)   | Defect (no future rounds, no incentive to cooperate)                                            |

---

### Justification:

- **Round 1 Defection:** No information yet; defecting earns you 1 + (k/n) × number_of_cooperators last round. Since there is no prior round, defecting avoids contributing without return.

- **Exploit Cooperation:** After observing past round, if others cooperated, defect to take advantage of their contributions.

- **Punishment for Non-Cooperation:** If no one cooperated last round, continue defecting to avoid wasting payoff.

- **Last Round Defection:** The standard backward induction rationale—no incentive to cooperate since no future retaliation or reward is possible.

---

### Pseudocode:

```python
def aggressive_strategy(round_number, r, history):
    # history: a list of tuples for previous rounds [(c_1, c_2, ..., c_n), ...]
    # where c_i = 1 if player i cooperated, 0 if defected
    
    if round_number == 1:
        # First round: defect
        return 'D'
        
    elif round_number == r:
        # Last round: defect
        return 'D'
        
    else:
        # Check previous round's contributions (excluding self)
        prev_contributions = history[-1]  # tuple/list of contributions in previous round
        
        # Sum cooperators other than self (index assumed known)
        total_cooperators_prev = sum(prev_contributions)
        
        # If any cooperators last round (including self or others), defect (exploit)
        if total_cooperators_prev > 0:
            return 'D'
        else:
            # No cooperators last round → continue defecting (punish)
            return 'D'
```

---

### Additional Notes:

- This strategy **never cooperates** (always defects).

- It **exploits cooperators by defecting whenever they cooperate** — this yields the highest payoff in public goods games if others cooperate.

- It **punishes defection by defecting** given no incentive to cooperate when others defect.

- It is **aggressive and self-serving**, maximizing payoff by free-riding on others' cooperation or giving up on cooperation if none occurs.

- Because others know this strategy is aggressive, you risk mutual defection leading to the "all defect" Nash equilibrium payoff.

---

### Summary:

| Situation                    | Action                 |
|-----------------------------|------------------------|
| Round 1                     | Defect                 |
| Previous round had any C?   | Defect (exploit)       |
| Previous round all D?       | Defect (punish)        |
| Last round                 | Defect                 |

This simple, consistent defecting strategy aligns perfectly with an aggressive mindset: never give up own resources, always try to gain from others' cooperation, and never trust or reward cooperators. It will fare well against naive cooperators but receives the Nash equilibrium payoff against other defectors.
'''

description_AGGRESSIVE_12 = '''
**Aggressive Strategy for the N-Player Public Goods Game**

---

### Core Idea

The strategy is **aggressively selfish**: it aims to maximize the player’s **immediate payoffs** by **defecting (D) as often as possible** while exploiting opponents’ cooperation when it appears beneficial. It punishes cooperators only insofar as it keeps defecting to achieve a higher relative payoff, never cooperating unconditionally or out of norm compliance.

---

### Intuition

- **Defection always yields a private payoff of 1 plus your share of public good (if any). Cooperation yields 0 private payoff.**
- Multiplication factor \(k < n\), so net social good is less than full cooperation payoff multiplier, making cooperation vulnerable to exploitation.
- If many cooperate, defectors get higher payoffs (example: in scenario #3 of spec, defectors earn 2 vs cooperators earn 1).
- Cooperation is only worthwhile if it provokes cooperation beneficial enough to outweigh the loss of private payoff (rare since \(k < n\)).
- Hence, defect constantly to maximize short-run payoff; consider cooperation only to exploit extreme circumstances or in rare last round retaliations.

---

### Decision Rules

---

#### 1. **Round 1 — Initial Move**:

- **Defect (D)** unconditionally.
  
Reasoning: No prior info, so best to start by taking the advantage of potential cooperators.

---

#### 2. **Rounds 2 to r-1 — History Based Behavior**:

- Calculate the number of **total cooperators** in the previous round, excluding yourself.
  
- Calculate **effective payoffs from last round for players who cooperated vs defected**:

  - If defectors earned strictly more than cooperators last round, **continue to defect** (free-riding).

  - Otherwise, consider defecting still better, so **continue defecting** (defect is dominant).

- If you detect **all players defected in prior round**, **continue defecting** — no incentive to cooperate.

- **If you observe that cooperation produced strictly higher payoffs in previous round and that a majority (≥ half) cooperated**, then consider cooperating once to “test” if cooperation cluster persists or grows.

  - But since \(k < n\), defectors always earn more when cooperation level < n, so you still prefer defection.
  
  - Thus, **never cooperate unless in a rare final-round tactical consideration**.

---

#### 3. **Last Round r — Final Move**:

- **Defect (D)** unconditionally.

Reasoning: No future consequences for retaliation, defecting maximizes your last-round payoff by free-riding on any cooperators.

---

### Edge Cases

- **If the group fully cooperated in previous round**: You still defect to maximize payoff (exploit full cooperators).

- **If the group fully defected in previous round**: You continue defecting (no cooperation incentive).

- **If in earlier rounds some cooperators appear but are exploited (less payoff)**: Defect to maximize gain; no change.

---

### Summary of Strategy

- Always defect, starting from the first round.
- Observe others, but never cooperate because cooperation costs you 1 unit of private payoff.
- No forgiveness or cooperation: aggressive, selfish exploitation.
- In last round, defect again without hesitation.

---

### Pseudocode

```python
def aggressive_strategy(round_num, r, n, k, history):
    # history: list of previous rounds, each round is a list of actions ['C' or 'D'] of each player

    if round_num == 1:
        # First round: no information yet
        return 'D'
    
    if round_num == r:
        # Last round: maximize immediate payoff by defecting
        return 'D'
    
    # Analyze previous round
    last_round = history[-1]  # actions of all players last round
    my_action_last_round = last_round[self_index]  # Assume self_index known
    
    # Count cooperators (excluding self)
    coop_count = sum(1 for a in last_round if a == 'C')
    
    # Calculate payoff if cooperated last round vs if defected last round
    # Payoff formula: π_i = (1 - c_i) + (k/n)*total_cooperators

    payoff_cooperator = 0 + (k / n) * coop_count
    payoff_defector = 1 + (k / n) * coop_count

    # If defectors had higher payoff, continue defecting
    if payoff_defector >= payoff_cooperator:
        return 'D'
    
    # (Fallback) Otherwise (rare), defect anyway
    return 'D'
```

---

### In Tournament Context

- This strategy exploits naive cooperators by defecting every round.
- It never sacrifices private payoff for socially beneficial cooperation.
- It punishes potential cooperation by never reciprocating.
- It's simple, consistent, aggressive, and legally optimal given payoff structure and lack of communication.

---

**In short: "Always defect"—aggressively free ride on others’ cooperation and never cooperate yourself, even in later rounds, to maximize your own total payoff.**
'''

description_AGGRESSIVE_13 = '''
Here is an **aggressive strategy** designed for the repeated public goods game with the given parameters and constraints. This strategy prioritizes maximizing individual payoff by exploiting cooperative players while punishing and deterring free-riding defectors aggressively.

---

## Strategy Name: **"Dominant Defector with Tactical Cooperation"**

### Core Idea:
- Defect by default to maximize immediate payoffs.
- Occasionally cooperate early on to test if others cooperate, exploiting this information.
- Punish persistent defectors to prevent them from free-riding on your cooperation.
- Exploit cooperative opponents by defecting when they cooperate.
- In the last round, defect unconditionally since no future interaction incentives remain.

---

### 1. Decision Rules

**Notation:**
- \( t \) = current round index (1 to r)
- \( H_{t-1} \) = full history of all players' actions up to round \( t-1 \)
- \( C_t^{others} \) = number of other players who cooperated in current round \( t \)
- \( \text{coop_ratio}_{t-1} \) = fraction of players (including self) who cooperated in round \( t-1 \)
- \( n \) = total number of players

---

### Detailed Rules:

**Round 1:**  
- Cooperate to signal potential willingness to cooperate (probe others).

**Rounds 2 to r-1:**  
- If at least half of the other players cooperated in the previous round, **defect** to exploit their cooperation.  
- Else, **defect** (punish defectors, refuse to be exploited).

**Round r (last round):**  
- Defect unconditionally (no future rounds to incentivize cooperation).

---

### Explanation

- **Why cooperate first round?**  
  Cooperating once tests if there is willingness to cooperate. If others cooperate, you gain info and can exploit in subsequent rounds.

- **Why defect when many cooperated last round?**  
  To maximize exploitation payoff: if at least half others contributed, defecting gives you the highest payoff.

- **Why defect if few cooperated?**  
  Punish defectors by not cooperating yourself, forcing low total investment and minimizing wasting payoff on a failing public good.

- **Why always defect last round?**  
  Standard game theory in finitely repeated games: no incentive to cooperate when future punishment is impossible.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, history):
    # history: list of length t-1, each element is a list of length n with actions 'C' or 'D'
    if t == 1:
        # Round 1: Cooperate (probe)
        return 'C'
    
    elif t == r:
        # Last round: always defect
        return 'D'
    
    else:
        # Calculate number of cooperators excluding self in previous round
        prev_round = history[t-2]  # zero-indexed, rounds start at 1
        my_action_last_round = prev_round[player_index]  # not used here other than check, optional
        coop_count_others = prev_round.count('C') - (1 if prev_round[player_index] == 'C' else 0)
        
        # If at least half others cooperated last round, defect to exploit
        if coop_count_others >= (n - 1) / 2:
            return 'D'
        else:
            # Otherwise, defect to punish
            return 'D'
```

*Note:* `player_index` corresponds to your player index (0-based or 1-based depending on implementation).

---

### Summary

| Round      | Decision Rule                                                  | Rationale                     |
|------------|----------------------------------------------------------------|-------------------------------|
| 1          | Cooperate                                                     | Probe willingness to cooperate |
| 2 to r-1   | Defect if ≥50% others cooperated last round; else defect      | Exploit cooperation or punish defectors |
| r (final)  | Defect                                                       | No future incentive to cooperate |

---

### Aggressive Mindset Alignment

- Starts with a **probe** to detect cooperation but quickly switches to **exploitative defection**.
- Never cooperates again except in round 1, **maximizing immediate payoff** given observations.
- **Punishes defectors passively** by refusing to cooperate and thus minimizing their potential gain.
- **Ensures no sucker payoff** by defecting against any uncooperative population.
- **Exploits any generous tendencies** in other players by defecting following cooperative behavior.
- **Exploits last-round backward induction logic** by defecting last round unconditionally.

---

This strategy is **dominantly selfish, exploitative, and aggressive**, balancing information gathering with immediate gain and punishment.

Would you like me to produce variants optimized for noisy observations or probabilistic cooperation detection?
'''

description_AGGRESSIVE_14 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Strategy Intuition and Aggressive Mindset

- "Aggressive" here means prioritizing maximizing own payoff by exploiting cooperation from others.
- Always defect unless you have a clear incentive to cooperate, minimizing your contribution cost (1 unit per cooperation) while trying to benefit from cooperators’ contributions.
- Punish cooperators by defecting to increase relative payoff advantage when possible.
- Only cooperate if it strictly increases your expected payoff against the opponent set.
- Exploit the classic public goods dilemma: you profit from others' cooperation, never lead by cooperating yourself without clear benefit.
- Avoid "conditional cooperation" or "forgiveness" that would allow rivals to exploit your trust.
- In the last round, defect, since no future retaliation is possible.
- Use history to detect mass cooperation phases and exploit them.

---

### Decision Rules Summary

| Condition                                               | Action | Rationale                                            |
|---------------------------------------------------------|--------|-----------------------------------------------------|
| **Round 1 (no history yet)**                            | Defect | Start with defection to avoid being exploited       |
| **Round < r (intermediate rounds)**                     | Defect if opponents defected at least once before    | Aggressively punish defectors                         |
|                                                         | Cooperate if all others cooperated last round         | Exploit unanimous cooperation only                    |
|                                                         | Defect otherwise                                     | Avoid "soft" cooperation in mixed contexts            |
| **Round r (last round)**                                | Defect | No future rounds → no incentive to cooperate         |

---

### Detailed Explanation

1. **Round 1**: No history exists. Since cooperation costs you 1 but defecting costs 0 and because opponents might defect, start with **defect** to avoid being exploited.

2. **Round 2 to r-1**:
   - If in the previous round *all* other players cooperated (everyone except you played C), cooperating this round gives you payoff:
     - You cooperate: π_i = (1-1) + (k/n) × (n) = 0 + k = k (note: since all others are cooperating, total contributions = n)
       - But since cooperating costs 1, your net payoff is k.
     - You defect: π_i = 1 + (k/n) × (n-1) = 1 + k*(n-1)/n = 1 + k*(1 - 1/n)
       - Because you didn’t contribute but enjoy (n-1) others' contributions.
     - Since k < n, and k > 1, compare payoffs:
       - Defect payoff > Cooperate payoff if:
         1 + k*(1 - 1/n) > k
         1 + k - k/n > k
         1 > k/n
       - Since k < n, k/n < 1, so 1 > k/n always holds.
       - Therefore, defecting yields strictly higher payoff than cooperating, even when everyone else cooperates.
     - **Conclusion**: Do not cooperate just because others cooperate; defect to exploit.
   
   - If not all others cooperated last round, cooperate only if everyone cooperated in at least the last two rounds in a row.
     - Actually, given the analysis, cooperating never beats defecting payoffs from the above, so cooperating is never payoff-maximizing.
     - Hence, keep defecting unless we want to "signal" cooperation or try to trigger cooperation in others— but that risks loss.
   
   - To be aggressive and payoff maximizing:
     - **Always defect** after round 1 regardless of history.
   
3. **Round r (last round)**:
   - Defect regardless of history, as no future retaliation is possible.

---

### Pseudocode

```python
def aggressive_strategy(round, r, history, n, k):
    """
    round: current round (1-based)
    r: total number of rounds
    history: list of tuples of previous rounds actions [(a_1, ..., a_n), ...]
             actions are 'C' or 'D'
    n: number of players
    k: multiplication factor
    
    Returns: 'C' or 'D'
    """
    # 1. First round: defect
    if round == 1:
        return 'D'
    
    # 2. Last round: defect
    if round == r:
        return 'D'
    
    # 3. Intermediate rounds:
    # Always defect, as defecting dominates cooperating payoff-wise.
    return 'D'
```

---

### Why Always Defect (Except Round 0 is Forced Defect)?

- **No incentive to cooperate**: cooperating costs 1; defecting gains 1 privately.
- The multiplication factor k < n implies that public good benefits spread too thin to justify personal cooperation cost.
- Defecting when others cooperate yields higher payoff.
- Cooperating to try to induce cooperation costs you a sure 1 unit, while defecting protects you from exploitation.
- Being "aggressive" means never sacrificing personal payoff to benefit the group.
- No "trigger" strategies to punish or reward cooperation because that involves cooperation costs and is exploitable.

---

**Final summary**: *Always defect throughout all rounds*, starting from round 1 through round r. This leads to maximal exploitation of cooperative opponents, avoids exploitation by defectors, and aligns with an aggressive mindset focusing solely on own payoff maximization with no cooperation risk.
'''

description_AGGRESSIVE_15 = '''
Here is an **aggressive strategy** for the given N-Player Public Goods Game. By aggressive, we mean a strategy that seeks to maximize individual payoffs by exploiting cooperators and discouraging cooperation from others through punishment, while minimizing contributions. This strategy reflects a "defect-first, punish cooperators if needed" approach and leverages information about previous rounds to exploit naive cooperators.

---

## Aggressive Strategy: "Exploit-and-Punish Defector"

### Intuition
- **Goal:** Maximize your own payoff by mostly defecting.
- **Tactics:**
  - Always defect from the start to maximize private payoff.
  - Detect if there are cooperators in the group; if others cooperate, exploit them by defecting.
  - If others use punitive strategies or cooperate too much, respond swiftly by defecting more to reduce their payoff.
  - Never cooperate first (unless forced by an extreme edge case).
  - In the last round, defect always (no incentive to cooperate in final round).
  
---

### Decision Rules (Round t ∈ {1,...,r})

| Condition                       | Action        | Reason                                 |
|--------------------------------|---------------|---------------------------------------|
| **Round 1 (t=1)**              | Defect (D)    | No info to trust, maximize private gain |
| **Rounds 2 to r-1 (t=2..r-1):**|               |                                       |
| - If previous round had cooperators (Σ c_j^{t-1} > 0) | Defect (D) | Exploit cooperators each round, never reciprocate |
| - Else (no prior cooperators)  | Defect (D)    | No incentive to cooperate when all defect |
| **Round r (last round):**      | Defect (D)    | No future consequences, maximize gain |

---

### Why This is Aggressive
- **Always defects** regardless of history.
- Actively exploits others who cooperate (share their public good benefits without contributing).
- No cooperation is ever given to others, denial of altruism.
- Punishes any cooperative attempts by maintaining defection.
- Maximizes short-term gains in each round.

---

### Pseudocode

```python
def aggressive_strategy(t, history, n, r):
    """
    Parameters:
    - t: current round (1-based)
    - history: list of dicts with keys for each player action in past rounds
               e.g. history[t-2][player_i] = 'C' or 'D' (for round t-1)
    - n: number of players
    - r: total rounds

    Returns:
    - action: 'C' or 'D'
    """

    # Round 1: no info, defect
    if t == 1:
        return 'D'

    # Check previous round cooperators count
    prev_round = history[t - 2]
    prev_cooperators = sum(1 for a in prev_round.values() if a == 'C')

    # Last round: always defect
    if t == r:
        return 'D'

    # If cooperators existed last round, exploit by defecting
    if prev_cooperators > 0:
        return 'D'

    # If no cooperators last round, defect to keep max private payoff
    return 'D'
```

---

### Handling Edge Cases
- **First round:** Defect because no knowledge and cooperation is risky/exploitable.
- **Last round:** Defect because no future incentives; cooperation costly without future reward.
- **If all players defect continuously:** Continue defecting (Nash equilibrium).
- **If some players cooperate persistently:** Continue defecting to exploit their generosity.
- **No forgiveness or cooperation attempts:** No oscillations, consistent defecting signal.

---

### Summary
- This is a **pure defector, exploitative strategy**.
- It never invests in the public good.
- It punishes cooperation by exploiting cooperative players every round.
- It's aggressive by maximizing immediate payoff at the expense of others.
- It uses information only to detect if cooperators exist so it can exploit repeatedly.

---

Let me know if you want a more nuanced (conditionally cooperative) aggressive strategy or additional details!
'''

description_AGGRESSIVE_16 = '''
Below is an **aggressive strategy** design for the repeated N-player Public Goods Game described. The strategy is aggressive in that it prioritizes maximizing personal payoffs by exploiting cooperators when possible and minimizing sucker losses — playing mostly to defect but willing to cooperate if it can enforce exploitation or punish defectors effectively.

---

## Strategy Overview

**Goal:** Maximize total payoff by defecting most of the time, but opportunistically cooperating to induce others to cooperate (to free-ride), and punishing persistent defection by opponents.

---

## Intuition behind the strategy:

- **First Round:** Cooperate once to "test the waters" and see how many players cooperate, to estimate population willingness.
- **Subsequent Rounds:** Defect consistently to exploit cooperators discovered.
- If many cooperators persist in the population, occasionally cooperate to maintain leverage and continue exploitation.
- If almost no cooperation is observed, defect always.
- On the **last round**, defect always—no incentive to cooperate.

This strategy is "aggressive" in that it seeks to free ride heavily on others’ cooperation while minimizing own cooperation.

---

## Detailed Decision Rules

### Variables to maintain internally:

- `round` — current round number (1 to r)
- `coop_count[t]` — number of cooperators in round t (from history)
- `my_action[t]` — this player’s action in round t (from history)
- `threshold` — cooperation threshold to consider cooperation beneficial (e.g., 50% cooperators)

---

### Pseudocode

```python
def aggressive_strategy(round, r, n, k, history):
    # history: list of tuples [(actions_round_1), (actions_round_2), ..., (actions_round_(round-1))]
    # each actions_round is a list of length n with 'C' or 'D' actions

    if round == 1:
        # First round: cooperate once to test for cooperators
        return 'C'

    elif round == r:
        # Last round: defect always (no future to incentivize cooperation)
        return 'D'

    else:
        # For rounds 2 to r-1:

        # Count number of cooperators in previous round
        prev_round_actions = history[round-2]
        prev_cooperators = prev_round_actions.count('C')

        # Calculate cooperation ratio in previous round
        coop_ratio = prev_cooperators / n

        # If many players cooperated last round, occasionally cooperate to maintain exploitation
        # Otherwise defect always.

        # Aggressive threshold for cooperating again
        threshold = 0.5  # Could tune between 0.4 - 0.6

        if coop_ratio >= threshold:
            # Opponents show decent cooperation, exploit by defecting mostly,
            # but cooperate occasionally (~10% chance) to maintain their hope.
            # This also avoids rapid collapse if others retaliate.
            # (Alternatively, cooperate if previously defected and want to maintain uncertainty.)

            # Simple approach: cooperate if last action was defect with 10% chance, else defect
            last_my_action = history[round-2][player_index]  # assuming player_index known internally

            import random
            if last_my_action == 'D' and random.random() < 0.1:
                return 'C'
            else:
                return 'D'

        else:
            # Low cooperation in opponents, defect to avoid losses
            return 'D'
```

---

## Explanation

- **Round 1 (Initial Cooperation):** Cooperate once to reveal if there's any cooperative tendency in the group. This is an "information probe."
- **Middle Rounds (Exploit or Defect):** If many players cooperate, defect mostly to gain the highest payoff (defector among cooperators earns highest payoff). Occasionally cooperate to prevent the cooperation level from collapsing too quickly (free riders usually cooperate somewhat).
- **If cooperation is low (< threshold):** Defect always, no incentive to cooperate.
- **Last Round Defection:** No future incentive — defect to maximize one-shot payoff.
- **Randomized cooperation (~10%) in mid-game when cooperation is high provides a slight "signal" to stay part of the cooperative "club," increasing future payoff by keeping cooperators around.**

---

## Handling Edge Cases

- If the number of players `n` is very small (e.g. 2), threshold can be adjusted; 0.5 still reasonable.
- If history not available (should never happen except round 1), cooperate.
- If the multiplication factor `k` is very close to 1 (minimal public good return), defect always except round 1.
- If `k` close to `n`, cooperation possibly more beneficial, so threshold can be lowered, but this is beyond scope as no info given on opponents.

---

## Summary of Behavior

| Round          | Action                   | Reason                                       |
|----------------|--------------------------|----------------------------------------------|
| 1 (First)      | Cooperate                | Test cooperation in population               |
| 2 to r - 1     | Mostly defect            | Exploit cooperators aggressively              |
| if coop level high | Occasional cooperate (10%) | Maintain some cooperation to keep benefits  |
| if coop level low | Always defect           | No incentive to cooperate                      |
| r (Last round) | Defect                   | No future incentives to cooperate             |

---

This strategy aggressively exploits cooperation when it exists, avoids contributing when cooperation is low, and never cooperates on the crucial last round, maximizing personal payoff given perfect knowledge of all prior actions and payoff structure.
'''

description_AGGRESSIVE_17 = '''
Below is a detailed design for an **Aggressive Strategy** for the N-player repeated Public Goods Game described. This strategy takes a tough stance on cooperation, aiming to maximize individual payoffs by exploiting cooperative players while punishing others who attempt to "free ride" aggressively. The approach prioritizes defection except in strategic moments designed to extract maximal benefit.

---

## Strategy Overview: "Aggressor"

### Core Concept
- **Default Defect:** Start by defecting; never freely cooperate.
- **Test for Cooperators:** Occasionally cooperate briefly to lure cooperators, then punish them by switching back to defection.
- **Punitive Defection:** Defect forever once you detect defection from others as a form of punishment.
- **Final Round Defect:** Always defect in the last round to avoid being exploited.

### Rationale
- Since cooperation benefits *all* players, but defectors earn more when mixed with cooperators, an aggressive player tries to:
  - Exploit cooperators by defecting while others contribute.
  - Punish any attempts by others to exploit by defecting themselves.
  - Avoid being suckered into cooperating without reciprocity.
- The strategy aims to maximize payoff at the expense of group welfare, consistent with an aggressive mindset.

---

## Decision Rules Summary

| Round | Action                                      | Why?                                  |
|-------|---------------------------------------------|--------------------------------------|
| 1     | Defect                                      | No info yet, exploit max by defect.  |
| 2 to r-1 | Cooperate *only* if majority cooperatedprevious round, else defect. Once defect detected among others, defect permanently. | Try to lure cooperators briefly, punish defectors aggressively. |
| r (last round) | Defect                                  | No future punishment, maximize immediate payoff.|

---

## Detailed Description and Pseudocode

### Definitions
- `history[t]`: vector of all players' actions at round t (C or D)
- `my_actions`: vector of our own actions so far
- `r`: total rounds
- `t`: current round (1-based)
- `n`: number of players
- `defecters_detected` (boolean): true if some other player defected in previous rounds and we switched to permanent defection
- `last_round = (t == r)`

---

### Initialization
- `defecters_detected = False`

---

### Stepwise Decision Logic for round t

```python
def Aggressor_decision(t, history, my_actions, r, n):
    # 1. Always defect in the first round
    if t == 1:
        return 'D'
        
    # 2. If in permanent defection mode, always defect
    if defecters_detected:
        return 'D'
        
    # 3. Check last round's actions of others
    last_round_actions = history[t-1]  # actions of all players at t-1
    others_last_actions = [a for i,a in enumerate(last_round_actions) if i != my_index]
    
    # 4. Detect if any other player defected last round
    if 'D' in others_last_actions:
        # Trigger permanent defection mode (punishment)
        defecters_detected = True
        return 'D'
        
    # 5. Otherwise (no defectors last round), check if majority cooperated last round
    cooperators = others_last_actions.count('C') + (my_actions[-1] == 'C')  # including self
    majority_cooperated = (cooperators > n/2)
    
    # 6. If majority cooperated last round and NOT last round
    if majority_cooperated and not last_round:
        # Lure cooperators by cooperating one round to be included in public good and exploit later
        return 'C'
    else:
        # Defect otherwise
        return 'D'
        
    # 7. Last round defect by default (already covered by defecters_detected or no cooperation)
    if last_round:
        return 'D'
```

---

### Behavior Explained

- **Round 1:** Defect, forcing others to "test" you or cooperate naively.
- **Rounds 2 to r-1:**
  - If nobody defected previously, and the group leaned toward cooperation, briefly cooperate to gain some public goods benefit.
  - If anyone defects, turn fully hostile—defect forever to punish.
- **Last round:** Always defect since no future retaliation is possible.

This design aggressively tries to **exploit cooperators by intermittent cooperation**, but rapidly switches to **permanent defection punishing defectors** to discourage others from exploiting as well.

---

### Edge Cases

- If the entire group defects from the start, you defect continuously, earning 1 per round (baseline).
- If the group cooperates initially, you cooperate once for inclusion, then defect to exploit.
- If a defector appears anytime, you punish by defecting repeatedly, aiming for payoff equality or dominance.
- In final round, no forgiveness or cooperation—pure greed for immediate payoff.

---

## Summary

| Condition                                 | Action |
|-------------------------------------------|--------|
| Round 1                                   | Defect |
| Past round had any defectors?              | Defect permanently |
| Past round majority cooperated (and not last round) | Cooperate this round once as bait |
| Otherwise                                 | Defect |
| Final round                               | Defect |

---

This approach embodies an aggressive, exploitative, and unforgiving player who tests for cooperators for short-term gain and permanently punishes defectors to enforce self-centered dominance. It balances brief cooperation to avoid missing out on public goods but never does so unconditionally or repeatedly.

---

If you want, I can help draft a more formal pseudocode or further analysis. Would you like that?
'''

description_AGGRESSIVE_18 = '''
Here is a detailed aggressive strategy for the N-player Public Goods game described, designed to maximize the player's own payoff, imposing a “take advantage” approach while punishing cooperators harshly and exploiting free-riders with a dominant defecting posture.

---

## Strategy Name: Dominant Defector with Opportunistic Exploitation

### Intuition
- Aggressively defect by default to gain private payoff plus partial public good benefits.
- Exploit cooperators by defecting while they contribute, earning higher payoffs.
- Punish cooperation by never cooperating yourself — cooperation is exploited, not reciprocated.
- In early rounds, test opponents’ cooperation level to opportunistically exploit rather than waste payoffs cooperating.
- In the final round, defect regardless since there is no future retaliation to fear.
- No forgiveness or cooperation attempts, as they only benefit others, never you.
- This strategy maximizes personal payoff, is harsh, and exploits altruistic or conditional cooperators.

---

### 1. Decision Rule Summary

- **Round 1**: Defect.
- **Rounds 2 to r-1**:
  - If any player cooperated in the previous round, defect (exploit them).
  - Else (no cooperators last round), still defect.
- **Round r (final round)**: Defect.

**No cooperation will ever be chosen.**

---

### 2. Edge Cases Handling

- **First round (t=1)**: No history, so defect to maximize immediate payoff and avoid giving free benefits.
- **Last round (t=r)**: Defect, since future punishment opportunities are gone, and cooperation only lowers own payoff.
- **Intermediate rounds**: Use the prior round's full action profile to detect if others cooperated. Cooperate never.
- **If everyone defects last round**: Continue defecting, since cooperating is costly and achieves lower payoffs.
- **Handle any possible new players or strategy shifts by ignoring them — always defect.**

---

### 3. Aggressiveness Justification

- Never surrender advantage by cooperating.
- Exploit cooperators fully.
- Minimize cooperation-induced losses.
- No trust or reciprocity, only exploitation and defection.
- Punishes cooperation by never rewarding it.
- Consistent defecting maximizes personal payoff against uncertain opponent behavior.

---

### 4. Pseudocode

```python
def aggressive_strategy(t, history, n, r):
    """
    Parameters:
      t: Current round (1-indexed)
      history: List of action profiles from previous rounds,
               where history[t-2] is the actions of all players at round t-1
      n: Number of players
      r: Total rounds

    Returns:
      'C' or 'D' for this round's action
    """
    # Always defect in first and last round
    if t == 1 or t == r:
        return 'D'

    # For intermediate rounds:
    # Check if any player cooperated last round
    last_round_actions = history[t-2]  # 0-based index
    if 'C' in last_round_actions:
        # Exploit cooperators by defecting
        return 'D'
    else:
        # No cooperators to exploit, still defect to avoid losses
        return 'D'
```

---

### 5. Explanation of Payoff Impact

- By defecting each round, you keep private endowment each round (1).
- You gain a share of the public good from others’ contributions.
- If others try cooperating, you exploit them, achieving higher payoffs (like in example 3).
- Consistent defection avoids costly cooperation losses.
- Final round defection prevents sucker’s payoff at the end.

---

### 6. Summary

| Round        | Condition                    | Action  | Rationale                                   |
|--------------|------------------------------|---------|---------------------------------------------|
| 1            | No history                   | Defect  | Gain private endowment; test field          |
| 2 to r - 1   | If anyone cooperated last round | Defect  | Exploit cooperators                         |
| 2 to r - 1   | Else                        | Defect  | Avoid paying cost of cooperation            |
| r (final)    | Always                      | Defect  | No future rounds → no incentive to cooperate|


---

**This is a strictly dominant aggressive strategy that maximizes your own payoff while undermining cooperation among others.**
'''

description_AGGRESSIVE_19 = '''
Below is a detailed aggressive strategy design for the N-player repeated public goods game with parameters n, r, k as described.

---

## Aggressive Strategy Overview

**Goal:** Maximize own total payoff by exploiting cooperative opponents (free-riding on their contributions) while minimizing own costly cooperation.

**High-level reasoning:**

- Defection (D) always yields an immediate payoff of 1 plus share of public good.
- Cooperation (C) costs 1 unit (your entire endowment) but increases total public good (benefit amplified by k/n).
- Because k < n, contributing always yields less immediate private payoff than defecting **if others don't fully cooperate**, i.e., defecting generally yields more immediate payoff if there is at least one cooperator.
- However, if *everyone* defects, the public good payoff is minimal (k/n * 0 = 0), so each player gets 1 per round.
- The maximal group payoff per player per round is k when all cooperate (since π_i = (k/n)*n = k > 1).
- An aggressive player can attempt to exploit cooperators by defecting while they cooperate, ensuring immediate gain > 1.

---

## Strategy Decision Rules

**Notation:**

- Let t = current round number, 1 ≤ t ≤ r
- Let history H_{t-1} be the vector of all players’ actions at previous rounds
- Let C_{t-1} be the number of cooperators in round t-1
- My last action = a_{i, t-1}

---

### Round 1 (First Round)

- **Defect** (D)

*Reasoning:* You have no info about others; start aggressively by defecting to test for cooperators.

---

### Rounds 2 to r-1 (Intermediate Rounds)

- Observe previous round’s distribution:

  - If any player cooperated last round (i.e., C_{t-1} ≥ 1), **Defect** again — exploit cooperators by free-riding.

  - If all players defected last round (C_{t-1} = 0), **Defect** as well — no incentive to start cooperating when no one else does.

This enforces a firm policy: **Never cooperate unless forced.**

---

### Round r (Last Round)

- **Defect**

*Reasoning:* No future to punish defectors, so always defect in final round for maximal immediate gain.

---

## Summary

| Round           | Condition                                   | Action |
|-----------------|---------------------------------------------|--------|
| t = 1           | No info about others                         | D      |
| 2 ≤ t < r       | Previous round had ≥1 cooperator             | D      |
| 2 ≤ t < r       | Previous round all defectors                  | D      |
| t = r (last)    | All cases                                   | D      |

Equivalent to **always defecting**.

---

## Pseudocode

```
function AggressiveStrategy(t, r, history):
    if t == 1:
        return 'D'  # First round defect
    
    # count cooperators in previous round
    last_round_actions = history[t-1]  # zero-indexed if implemented accordingly
    cooperators_last_round = sum(1 for a in last_round_actions if a == 'C')
    
    # last round or not
    if t == r:
        return 'D'  # Always defect last round
    
    # Intermediate rounds
    if cooperators_last_round >= 1:
        return 'D'  # Exploit cooperators
    else:
        return 'D'  # No cooperators, no reason to cooperate
```

---

## Explanation of Aggressiveness

- The strategy **never cooperates**, thereby never paying the cost of contribution.
- It is **aggressive** in the sense that it exploits cooperators by consistently defecting.
- No forgiveness or cooperation attempts; maximal exploitation of cooperators to maximize own payoff.
- In theory, this can cause an outcome where cooperation collapses and all defect, resulting in each getting 1 per round.
- But if any naive or cooperative players appear, this strategy gains more than them by free riding.

---

## Notes on Edge Cases and Robustness

- If all players defect forever, payoff per player per round is 1.
- If any player attempts cooperation, this strategy exploits by defecting.
- The strategy ignores threats of punishment (retaliation) because in public goods games, defecting is individually dominant unless others cooperate fully.
- Since no communication or coordination exists, the strategy does not assume complex equilibrium strategies or tacit collusion.
- The last round defect prevents being suckered by “endgame cooperation.”

---

# Final Comment

This strategy is the purest form of aggressive, selfish play in a public goods setting. It maximizes immediate gains by free-riding and never risks loss by cooperating.

If you want a slightly more subtle aggressive strategy that punishes defectors but is still hostile, that can be designed, but per your request for aggressive play, this all-defect plan is optimal and clear.

---

If you want me to design a more nuanced variant (e.g., punish defectors or conditional cooperation) let me know!
'''

description_AGGRESSIVE_20 = '''
Here is an **aggressive strategy** for the repeated public goods game described, designed to maximize your payoff by exploiting cooperative players while discouraging others from free-riding on you.

---

## Aggressive Strategy Description: "Defector-Leveraging Tirade"

### Strategic Intuition:
- Public goods games favor defectors in a one-shot setting because cooperating costs you 1 unit private payoff, but defecting lets you enjoy the multiplied contributions of others.
- In repeated play, cooperation can emerge but is vulnerable to exploitation.
- An aggressive strategy exploits cooperators by mostly defecting but punishing persistent defectors harshly, to encourage some cooperation from others but not at your full expense.
- You cooperate **only if you detect the presence of other cooperators AND it benefits you**, otherwise you defect.
- You start by defecting (establish dominance) and end by defecting (to exploit others’ final-round cooperation).
- You aggressively punish other defectors by defecting continually and refusing to cooperate.
  
---

### 1. **Decision Rules**

Let the rounds be indexed from 1 to r.

Let:

- `history[t]` be the vector of all players' actions in round t (including your own).
- `cooperatorCount[t]` = Number of players who played C in round t.
- `opponentCooperators[t]` = cooperatorCount[t] minus your own contribution (1 if you cooperated, else 0).

---

#### Round 1 (First Round):

- **Action:** Defect (D)
- **Reason:** Establish aggressive starting stance; don't give free cooperation without cause.

---

#### Rounds 2 to r-1 (Intermediate Rounds):

- Observe previous round `t-1` actions.

**If other players cooperated substantially in the previous round:**  
- Define threshold for cooperation presence: if `opponentCooperators[t-1] >= 1`  
- **And** if cooperating now yields expected payoff >= defecting now by exploiting others (explained below), **then cooperate (C)**  

**Else:**  
- Defect (D)

---

##### Expected Payoff Calculation for decision each round:

- Defect payoff this round (dPayoff):

  \[
  dPayoff = 1 + \frac{k}{n} \times (previous\ total\ cooperators)
  \]

  Because if you defect and others cooperated last round, you get private 1 and share of others' contributions.

- Cooperate payoff this round (cPayoff):

  \[
  cPayoff = 0 + \frac{k}{n} \times (previous\ total\ cooperators + 1)
  \]

  Because you pay the cost 1, but add one more contributor.

- **If cooperating gives you payoff equal or better than defecting (cPayoff ≥ dPayoff), cooperate; else defect.**

---

#### Last Round (Round r):

- **Action:** Defect (D)
- **Reason:** No future rounds to punish, so maximize selfish payoff.

---

### 2. **Summary of Decision Logic**

For round t:

```
if t == 1:
    action = D

elif t == r:
    action = D

else:
    totalCooperatorsPrev = sum of all c_j at round t-1
    
    dPayoff = 1 + (k/n)*totalCooperatorsPrev
    cPayoff = (k/n)*(totalCooperatorsPrev + 1)
    
    if totalCooperatorsPrev - (player cooperated last round ? 1 : 0) >= 1 and cPayoff >= dPayoff:
        action = C
    else:
        action = D
```

---

### 3. **Edge Cases & Handling**

- **If in previous rounds nobody cooperated (cooperatorCount = 0):** Always defect
- **If all cooperated last round:** Cooperate only if it yields payoff ≥ defecting  
- **If some cooperated but payoff favors defecting:** Defect (exploit cooperators)
- **If all defected last round:** Defect (never initiate cooperation)
- **You punish defectors by withholding cooperation unless they "earn" it via cooperation and payoff conditions.**
- **Final round is always defect for maximum payoff harvest — no incentive to cooperate.**

---

### 4. **Aggressiveness Manifested**

- Starts by defecting—never gives free cooperation or trust.
- Only cooperates opportunistically to exploit others’ cooperation if it improves own payoff.
- Never initiates cooperation; only responds to others’ cooperation if expected gain ≥ defection payoff.
- Always defects last round for maximum selfish extraction.
- Punishes defectors by maintaining defection.

---

## Optional Pseudocode for clarity

```python
def aggressive_strategy(t, r, n, k, history):
    """
    t: current round (1 to r)
    r: total rounds
    n: number of players
    k: multiplication factor
    history: list of action lists for past rounds, each action in {'C','D'}
    """
    
    if t == 1:
        return 'D'  # Start aggressive
    
    if t == r:
        return 'D'  # Exploit final round
    
    prev_actions = history[t-2]  # zero indexed; t-1 round ago
    total_cooperators_prev = prev_actions.count('C')
    
    # Count how many others cooperated last round
    player_cooperated_prev = (history[t-2][my_index] == 'C')  # my_index known
    opponent_cooperators_prev = total_cooperators_prev - (1 if player_cooperated_prev else 0)
    
    # Calculate payoffs
    dPayoff = 1 + (k / n) * total_cooperators_prev
    cPayoff = (k / n) * (total_cooperators_prev + 1)
    
    if opponent_cooperators_prev >= 1 and cPayoff >= dPayoff:
        return 'C'  # Cooperate only if enough cooperators and payoff justifies
    else:
        return 'D'  # Defect otherwise
```

---

# Summary

This "Defector-Leveraging Tirade" aggressive strategy:

- Always defects opening and closing rounds
- Cooperates only opportunistically if other players cooperated last round and the expected return from cooperation is not less than defection
- Punishes defectors by persistent defection, never initiating cooperation on pure trust
- Seeks maximum exploitation of cooperators to maximize payoff over repeated rounds

This approach fits an aggressive mindset: dominant from the outset, exploitative of cooperators, punishing to defectors, maximizing short-term gain while avoiding costly altruism.
'''

description_AGGRESSIVE_21 = '''
Below is an **aggressive strategy** for the repeated N-player public goods game designed to maximize individual payoff by exploiting cooperators, punishing others less frequently, but never fully cooperating. The aggression comes from consistently defecting to maximize private payoffs, tolerating occasional cooperation from others, and exploiting that cooperation optimally.

---

## Aggressive Strategy Description

**Core idea:**  
Always defect to retain the private endowment (1 point) and benefit from any cooperators’ public contributions. Play as a free-rider who never voluntarily cooperates but does punish only by defecting themselves (which is default). The strategy seeks to maximize payoff by **never cooperating**, capitalizing on others' cooperation without investing anything. 

### Decision Rules

- **Round 1:** Defect (D). No prior history to rely on; default to aggressive defection.
- **Rounds 2 to r-1:**
  - Observe the previous round’s contributions:
    - If *all* players cooperated last round (everyone played C), **defect** this round to exploit their full cooperation.
    - Otherwise, **defect** (continue defecting without retaliation).
- **Last round (round r):** Defect (D).
  
Because this is a finitely repeated game with simultaneous moves and no communication, the logic follows backward induction to defect in the last round and exploit opponents until then.

---

### Why is this aggressive?

- **Never cooperates:** Always chooses D, so never contributes to the public good, avoiding self-cost.
- **Exploits cooperators:** When others cooperate, the defector reaps scaled benefits without paying a cost.
- **No costly punishments:** Does not attempt to punish cooperators or defectors further (no tit-for-tat style retaliation).
- **Backwards induction reasoned:** Defects last round ensuring no incentive for others to cooperate expecting endgame cooperation.
  
---

## Pseudocode

```python
def aggressive_strategy(round_num, total_rounds, history):
    """
    Parameters:
    - round_num: current round number (1-indexed)
    - total_rounds: total number of rounds (r)
    - history: list of lists, where history[t-1] is a list of length n of actions ('C' or 'D') from round t (t < round_num)
    
    Returns:
    - 'C' or 'D'
    """
    
    # Always defect on first and last rounds
    if round_num == 1 or round_num == total_rounds:
        return 'D'
    
    # For rounds 2 to r-1:
    # Check if all players cooperated last round
    last_round_actions = history[round_num - 2]  # zero-based index: round_num-2 for previous round
    if all(action == 'C' for action in last_round_actions):
        # Exploit full cooperation by defecting this round
        return 'D'
    else:
        # Default defecting strategy (never cooperate)
        return 'D'
```

---

## Additional Notes

- Because k < n, cooperating is individually costly and returns less than defection when opponents defect.
- The aggressive strategy relies on **never trusting cooperation** or punishing defectors, since no incentive exists to help others when payoffs are maximized from defection.
- This strategy scores well against naive cooperators who still contribute, gaining the public good without loss.
- Against all-defectors, payoff equals 1 per round — better than costly cooperation.
- Against conditional cooperators, this strategy exploits them by defecting whenever they try to cooperate.

---

## Summary

| Round          | Decision Rule                                                                                   |
|----------------|-----------------------------------------------------------------------------------------------|
| 1              | Defect                                                                                         |
| 2 to r - 1     | If all cooperated in prior round: Defect (exploit full cooperation) <br> Else: Defect          |
| r (last round) | Defect                                                                                         |

This strategy embodies **maximally aggressive play** by never cooperating, never punishing (beyond default defection), and always acting to maximize private payoff exploiting others' cooperation when it happens.
'''

description_AGGRESSIVE_22 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Intuition & Rationale

An *aggressive* strategy here means:  
- Always attempting to maximize *individual payoff* by exploiting others' cooperation.  
- Avoiding giving away free payoffs unnecessarily (i.e., avoiding cooperation unless forced).  
- Punishing cooperative players by defecting to gain the full private payoff plus share of public good without cost.  
- Using history to identify and exploit potential cooperators when advantageous.  
- Exploiting the last round's weakness to defect, since no future punishment is possible (backward induction).

---

### Decision Rules Overview:

1. **Round 1 (No History)**  
   - Defect to avoid initial cost and gauge opponent behavior.

2. **Rounds 2 to r-1 (Repeated Play)**  
   - If the previous round contains any cooperators (players contributing to the public good), defect to fully exploit them.  
   - If *all* defected last round, cooperate once as a probe to try inducing cooperation (a "trap" move):  
     - If cooperation is rewarded in the following round by emergence of cooperators, continue defecting to exploit.  
     - Else, continue defecting.

3. **Round r (Last Round)**  
   - Defect (no incentive to cooperate; final round).

---

### Why this is aggressive:

- **Never voluntarily cooperating except a single “probe” after universal defection** in attempts to induce cooperative players into exploitation.  
- Always defecting in presence of cooperators to maximize individual gain.  
- Punishing any signs of cooperation to prevent opponents from gaining private payoffs.  
- Leveraging perfect information to detect cooperation immediately and respond aggressively.  
- No forgiveness or trust building: keeps opponents on edge and keeps payoff maximization as priority.  
- Defects in final round to prevent exploitation.

---

### Pseudocode

```python
# Input: history = list of rounds; each round is list of actions by all players ['C' or 'D']
#          your_index = integer (0-based)
# Parameters: n, r, k (known but not directly needed for decision)

def aggressive_strategy(history, your_index, n, r):
    current_round = len(history) + 1  # 1-indexed round number

    # First round: no history, always defect
    if current_round == 1:
        return 'D'

    # If last round (round r), always defect
    if current_round == r:
        return 'D'

    # Analyze last round actions
    last_round = history[-1]
    total_cooperators = last_round.count('C')

    # If any cooperator present last round, defect to exploit
    if total_cooperators > 0:
        return 'D'

    # If no cooperators last round (all defect),
    # Cooperate once as a probe to try inducing cooperation
    # But only once per consecutive all-defect stretches.

    # To avoid repeated probes, check if previous round was also all defect and
    # if we cooperated then, continue defecting to exploit.

    # Check if last round was all defect
    if total_cooperators == 0:
        # If last round was all defect, check if we cooperated last round
        # to avoid repeated probes.
        my_last_action = last_round[your_index]
        if len(history) >= 2:
            second_last_round = history[-2]
            total_coop_before_last = second_last_round.count('C')

            # If last two rounds both all defect and we cooperated last round,
            # avoid repeated probing - defect again
            if total_coop_before_last == 0 and my_last_action == 'C':
                return 'D'

        # Otherwise, cooperate once as probe
        return 'C'

    # Default fallback defect
    return 'D'
```

---

### Explanation

- **First round**: No incentive to cooperate without information, so defect to guarantee at least 1 payoff.  
- **Detect cooperation**: If any cooperators in last round, defect to freeride on their contributions for higher payoff.  
- **If all defect in last round**: The strategy sends a single cooperation move to "tempt" other players into cooperation and then exploits them immediately next round. The probe is done only once per consecutive defection sequences to avoid being exploited by reciprocating cooperators or alternating cooperation–defection cycles.  
- **Last round**: Defect unconditionally since there is no future punishment and no gain from cooperation.

---

### Summary

| Round           | Condition                             | Action  | Reason                                    |
|-----------------|------------------------------------|---------|-------------------------------------------|
| 1 (first round) | No history                         | Defect  | Avoid cost, gauge opponents               |
| Intermediate    | Any cooperator previous round      | Defect  | Exploit cooperators                       |
| Intermediate    | All defect previous round & no recent probe | Cooperate | Probe to induce cooperation (once)       |
| Intermediate    | All defect previous round & recent probe in last round | Defect | Avoid repeated probes                     |
| r (last round)  | Always                            | Defect  | No incentive to cooperate last round     |

---

This strategy is aggressive, self-focused, punishes cooperation to maximize individual gains, tries to induce cooperation to exploit, and defects in final round to prevent exploitation — fitting the specification perfectly.
'''

description_AGGRESSIVE_23 = '''
Here is a designed **Aggressive Strategy** for the N-Player Public Goods Game that aims to maximize individual payoff through exploitation and deterrence, minimizing cooperation unless strictly beneficial.

---

## Strategy Description: "Exploit and Punish"

### Core Idea
- **Exploit cooperating players whenever possible**, by defecting to gain the private payoff plus benefit from others' cooperation.
- **Punish cooperators promptly after observing cooperation**, to deter others from cooperating and thus keep the public good contribution low.
- **Never voluntarily cooperate**, except possibly in the very first round if we want to test the waters for cooperation (optional).
- **Defect in the last round decisively** because there is no future punishment incentive or reward.
- Use history of previous rounds to identify potential cooperators and punish them aggressively.

---

## Decision Rules

### Round 1 (First Round)
- **Defect (D)**  
  No established cooperation pattern yet; best to maximize immediate payoff and test if others start cooperating.  
  (Rationale: Being aggressive means starting by exploiting others rather than risking cooperation.)

### Rounds 2 to r-1 (Intermediate Rounds)
- If **any player cooperated in the previous round**,  
  - **Defect (D)** aggressively to punish these players, reducing their incentives to cooperate.  
  - This signals that cooperation will be exploited, discouraging players from cooperating in subsequent rounds.

- Else (if all players defected in the previous round),  
  - **Defect (D)** to attempt to secure high private payoff, avoiding being exploited.

### Round r (Last Round)
- **Defect (D)** unconditionally.  
  No future rounds to enforce punishment or reward; cooperation is dominated by defection for immediate gain.

---

## Edge Cases

- **If all players cooperate in round 1 (unlikely but possible):**  
  Still defect in round 2 to exploit those who cooperated, reinforcing aggressive stance.

- **If a formerly cooperating player switches to defection:**  
  Continue defecting; do not reward cooperation even if intermittently seen.

- **If the total number of cooperators in previous round is zero:**  
  Continue defecting to maximize private payoffs.

---

## Pseudocode

```python
def aggressive_strategy(history, round_number, r, n):
    """
    history: list of tuples for previous rounds, each tuple is a list of length n with actions 'C' or 'D'
    round_number: current round index (1-based)
    r: total number of rounds
    n: number of players
    """
    
    if round_number == 1:
        # Never cooperate initially
        return 'D'
    
    elif round_number == r:
        # Last round: defect to maximize immediate payoff
        return 'D'
    
    else:
        # Check previous round for any cooperation
        previous_round_actions = history[-1]
        if 'C' in previous_round_actions:
            # Someone cooperated previously -> punish by defecting
            return 'D'
        else:
            # No cooperation previously -> defect to maximize private payoff
            return 'D'
```

---

## Rationale for Aggressiveness

- Always defecting maximizes private payoff at the cost of public good.
- Punishing any cooperation immediately lowers the incentive for others to contribute.
- This breaks down potential cooperation equilibria, forcing most players into defect mode.
- Last round defection prevents exploitation.
- No forgiveness or gradual build-up—purely exploitative and punish-based.

---

## Summary

| Round        | Condition                         | Action |
|--------------|---------------------------------|--------|
| 1 (First)    | Initial round, no history        | Defect |
| 2 to r-1     | Any coop in previous round?      | Defect |
| 2 to r-1     | No coop in previous round        | Defect |
| r (Last)     | Final round, no future rounds    | Defect |

This aggressive strategy maximizes short-term gain, exploits cooperators, punishes attempts at cooperation immediately, and ends on a purely defecting note.

---

If desired, the strategy can be trivially modified to "test" cooperation on round 1 by cooperating initially, but this reduces aggressiveness slightly and risks exploitation on the first round.

---

Let me know if you want a less aggressive or more cooperative variant!
'''

description_AGGRESSIVE_24 = '''
Here is an aggressive strategy for the described repeated N-player public goods game. The design emphasizes maximizing one’s own payoff, exploiting cooperators, and deterring exploitation by defectors, while fully leveraging repeated interactions.

---

### Strategy Name: **"Exploit & Punish"**

---

### Intuition / Summary:

- **Start defecting immediately** to maximize individual short-term payoff and test other players’ cooperativeness.
- If others cooperate (at least one cooperator in previous round), **exploit them by defecting** to get maximum benefit.
- If others defect, respond with permanent defection (never cooperate) since cooperating is exploited and yields no gain.
- **Never cooperate yourself**, except potentially in the last round (optional and explained below), because cooperating is costly and opponents are not guaranteed to reciprocate.
- The strategy is relentlessly aggressive: it refuses cooperation and punishes cooperators only by exploiting them.
- This strategy leverages perfect information of previous actions: it aggressively exploits peers who cooperate while guarding against naive cooperation.

---

### Detailed Decision Rules:

**Notation:**  
- Let \( c_{-i}^{t} \) be the total number of cooperators excluding player \( i \) in round \( t \).  
- Let \( r \) be total rounds, \( t \in \{1,2,\ldots,r\} \) current round

---

#### At each round \( t \):

1. **If \( t = r \) (last round):**  
   - With no future punishment possible, **defect (D)**, since cooperation in the last round cannot be rewarded.  
   - *Rationale:* Cooperation is individually costly and cannot induce future cooperation; last round defecting maximizes immediate payoff.

2. **If \( t = 1 \) (first round):**  
   - Start with **defect (D)** to test opponent behavior without costly cooperation.

3. **For \( 1 < t < r \):** (intermediate rounds)  
   - Check previous round's cooperators (excluding self):  
     - If \( c_{-i}^{t-1} \geq 1 \) (some others cooperated last round):  
       - **Defect (D)** to exploit cooperating players.
       - *Rationale:* Other players cooperated → better to defect and free ride.
     - Else (no one cooperated last round):  
       - **Defect (D)** continues indefinitely.
       - *Rationale:* No incentive to cooperate; cooperating unreciprocated yields lower payoff.

---

### Edge Cases:

- **If all players defect every round:**  
  The strategy defects every round → equilibrium payoff of 1 per round.

- **If some players cooperate early on (perhaps naive):**  
  The strategy defects to maximize payoff by free-riding on their contributions.

- **If opponents attempt cooperation to signal “let’s cooperate”:**  
  This strategy exploits such goodwill without cooperating.

- **If the multiplication factor \(k\) is close to \(n\) (near fully efficient public good):**  
  Still defect, because cooperation costs 1 unit contribution and returns \(\frac{k}{n}\), which is <1 (since \(k < n\)), so defecting yields better private payoff when others cooperate.

---

### Formal Pseudocode:

```
Input: round t, history of all players' actions up to round t-1
Output: action_i ∈ {C, D}

if t == r:
    action_i = D                # Last round defect

else if t == 1:
    action_i = D                # Start defecting

else:
    # Compute how many others cooperated in round t-1
    prev_round_cooperators = count_cooperators(round = t-1)
    prev_round_others_cooperators = prev_round_cooperators - (1 if i cooperated at t-1 else 0)

    if prev_round_others_cooperators >= 1:
        action_i = D            # Exploit cooperators by defecting
    else:
        action_i = D            # No cooperators to exploit: continue defecting
```

---

### Why is this strategy **aggressive**?

- It actively exploits cooperators rather than reciprocating or cooperating.
- It never cooperates early or mid-game, thus denying others potential gains from mutual cooperation.
- It punishes “nice” strategies by free-riding on their investments.
- It avoids any costly cooperation that does not immediately pay off.
- By permanently defecting, it signals zero tolerance for exploitation.
- It maximizes short-term and likely total payoffs by harvesting contributions of others.

---

### Optional Variant (Less “pure” aggressive):

- Cooperate only in first round to appear "nice," then defect afterward (a classic exploit).
- Or cooperate in the last round to appear nice if tournament scoring values social welfare or reputation.
  
But these are compromises away from the fully aggressive stance described.

---

# Summary

The strategy **always defects**, beginning from the first round, aggressively exploits any cooperators by defecting, and defects on the last round to maximize immediate payoff — thereby maximizing individual gains at the expense of others. It uses the game’s perfect information to detect cooperation and responds only by defecting, never cooperating itself.

This matches a strongly aggressive mindset under limited information without enabling cooperation or forgiveness.
'''

description_AGGRESSIVE_25 = '''
Below is an **aggressive strategy** designed for the N-Player Public Goods Game based exclusively on the information given, emphasizing exploitation and payoff maximization at the expense of cooperation. This approach prioritizes defecting to secure private payoffs while punishing cooperators minimally but decisively to deter them from exploiting you.

---

### Strategy Overview: "Aggressive Exploiter"

- **Mindset:** Do not cooperate unless it yields a strictly higher payoff. Exploit cooperators without hesitation and never let others gain consistently from your cooperation.
- **Goal:** Maximize own total payoff by mostly defecting, but selectively punishing persistent cooperators to discourage free-riding or exploitation.
- **Rationale:**  
  - Contributions cost you 1 private payoff but yield only \( \frac{k}{n} \) per cooperator (including self).
  - Since \( k < n \), full cooperation is socially better but individually costly unless many others cooperate.
  - Defection costs nothing, and if enough players cooperate, defectors earn more.
  - Aggressive strategy exploits this by defecting to earn private payoff and occasional cooperation to prevent others from free-riding indefinitely.

---

### Detailed Decision Rules


| Round/time | Observed History | Action          | Reasoning                                   |
|------------|------------------|-----------------|---------------------------------------------|
| Round 1 (no history) | None | **Defect** | No information—default to defect to avoid exploitation. |
| Round t, 2 ≤ t < r (intermediate rounds) | Check previous round's cooperation counts and own payoff | See below | Dynamic response based on past observed behavior. |
| Round r (last round) | See previous round's cooperation counts and payoffs | **Defect** | No future consequences—maximize immediate payoff by defecting. |

---

### Intermediate Round Decision Logic

1. **Calculate in previous round:**
   - \(C_{prev} =\) total cooperators
   - \(c_i^{prev} = \) did I cooperate? (1 if yes, 0 if no)
   - Own payoff \( \pi_i^{prev} = (1 - c_i^{prev}) + \frac{k}{n} C_{prev} \)

2. **If in previous round you cooperated:**
   - If your payoff \( \pi_i^{prev} < 1 \) (i.e., you got less than full private payoff):
     - **Defect next round** (stop losing private payoff)
   - Else (you got ≥ 1):
     - If \( C_{prev} \geq 2 \) (others also cooperated):
       - **Defect next round** (exploit cooperators)
     - Else (only you cooperated):
       - **Defect next round** (stop being sucker)

3. **If in previous round you defected:**
   - If \( C_{prev} = 0 \) (all defected):
     - **Defect next round** (nothing to exploit)
   - Else if \( C_{prev} \geq 1 \):
     - **Defect next round** (continue exploiting cooperators)
   - Exception: If you have observed the *same players cooperating every round and you have defected always*, try cooperating once to test if you can induce others to cooperate and gain from their cooperation.
     - Limit this test cooperation to one time only during the entire game, early in the middle rounds.
     - After test cooperation, revert to defecting regardless.

---

### Pseudocode

```python
# Inputs: round_number t, history of actions A_history (list of length t-1 with each element a list of n actions)
#          parameters n, r, k
# Output: action 'C' or 'D'

def aggressive_exploiter(t, A_history, n, r, k):

    def count_cooperators(actions):
        return actions.count('C')

    # Last round: Always defect
    if t == r:
        return 'D'

    # First round: Defect by default
    if t == 1:
        return 'D'

    # Previous round info
    prev_actions = A_history[t-2]
    C_prev = count_cooperators(prev_actions)
    i_action_prev = prev_actions[my_index]  # your own previous action ('C' or 'D')

    # Calculate your previous payoff
    c_i_prev = 1 if i_action_prev == 'C' else 0
    pi_i_prev = (1 - c_i_prev) + (k / n) * C_prev

    # Track if test cooperation done (persistent state external to function)
    # For pseudocode assume global variable `test_coop_done` initialized False

    if i_action_prev == 'C':
        if pi_i_prev < 1:
            # Lost private payoff, switch to defect
            return 'D'
        else:
            # You got payoff >=1 by cooperating last round
            if C_prev >= 2:
                # Others also cooperate — exploit them by defecting
                return 'D'
            else:
                # Only you cooperated — stop being sucker
                return 'D'

    else:  # you defected last round
        if C_prev == 0:
            # Everyone defects, no point cooperating
            return 'D'
        else:
            # Exploit cooperators by defecting
            if (not test_coop_done) and (t > r // 3) and (t < (2 * r) // 3):
                # Test cooperation once in middle rounds to see if can induce cooperation
                test_coop_done = True
                return 'C'
            else:
                return 'D'
```

---

### Additional Notes

- **Test Cooperation:**  
  Aggressive but adaptive players sometimes test cooperation to probe if others will cooperate and hence create exploitable public goods. Only done once, early in middle rounds, to avoid vulnerability.

- **Strict Defection Approach:**  
  The strategy leans heavily toward defection. Cooperation never starts voluntarily, only as a limited tactical probe. No forgiveness beyond the single cooperation test.

- **Last Round Defection:**  
  Standard backward reasoning; no incentive to cooperate since no future retaliation is possible.

- **No Trust or Retaliation Beyond Self-Interest:**  
  No long-term punishment or reward schemes since they usually reduce aggressive payoff in presence of many defectors.

---

### Summary  
This "Aggressive Exploiter" strategy is:

- **Primarily defecting,** to maximize private payoffs.
- **Occasionally cooperating once** to test for cooperative peers who can be exploited.
- **Defecting always last round** to secure immediate payoffs.
- **Never rewarding cooperation** of others by cooperating honestly.
- **Quickly withdrawing cooperation** if previous cooperation yielded payoff < 1.
  
This should perform well in a tournament of independent, self-interested strategies by exploiting cooperators and limiting losses to exploiters.
'''

description_AGGRESSIVE_26 = '''
Below is a detailed design of an **aggressive strategy** for the N-Player Public Goods Game, based on the game specification and constraints you provided.

---

## Key Intuition Behind the Aggressive Strategy

- The aggressive player **maximizes their own payoff at the expense of cooperation**.
- Since cooperating means a direct cost of 1 unit of private payoff while giving the collective multiplier benefit, defecting when others cooperate gives the highest payoff.
- Because others likely face similar incentives and no communication or coordination exists, assume opponents are selfish, and attempt exploitation while defending aggressively against being exploited.
- The strategy should be **punishing**: defect if exploited, but aggressively try to exploit others when profitable.
- The strategy exploits cooperators but does not lower payoffs unnecessarily by cooperating unless it benefits the player.

---

## Decision Rules Summary

| Round                 | Action                                        |
|-----------------------|-----------------------------------------------|
| Round 1 (No history)  | Defect (start strong, no trust)                |
| Later Rounds          |  
- If **in previous round you cooperated and got exploited** (others defected), then defect (punish).
- Else if **others cooperated last round** (≥1 cooperator), defect to exploit.
- Else if **all defected last round**, cooperate once to test for cooperation.
|
| Final Round           | Defect (no incentive to cooperate on last round) |

"Exploited" means: you cooperated last round but your payoff was less than if you defected (i.e., others did not cooperate enough to compensate).

---

## Detailed Reasoning

### Round 1:  
No history — no reason to cooperate; start by defecting to exploit potential cooperators and establish dominance.

### Intermediate Rounds:

- **Detect exploitation:**  
  If last round you cooperated but your payoff was less than payoff you would have gotten defecting (meaning others let you pay cost but did not produce enough contribution), punish by defecting.

- **Exploit cooperation:**  
  If any players cooperated last round (including you), defect to maximize payoff.

- **No cooperation last round:**  
  If all defected, **test cooperation** by cooperating once, hoping to induce cooperation next round.

### Final Round:

No future repercussions to cooperation, only immediate payoff matters. Defect for maximum private payoff.

---

## Pseudocode of the Aggressive Strategy

```python
def aggressive_strategy(round_number, r, n, k, history):
    """
    Parameters:
    - round_number: current round index (1-based)
    - r: total number of rounds
    - n: number of players
    - k: multiplication factor
    - history: list of tuples for previous rounds
        Each element is a list of player actions ['C'/'D',...], length n
    
    Returns:
    - 'C' or 'D': current round action
    """
    
    # If it is the last round, defect
    if round_number == r:
        return 'D'

    # In round 1, no history: defect aggressively
    if round_number == 1:
        return 'D'

    # Examine previous round's actions
    prev_actions = history[-1]
    total_cooperators = prev_actions.count('C')
    my_last_action = prev_actions[0]  # assuming player index = 1 and first action is ours
    
    # Calculate payoff if cooperated vs defected last round based on total_cooperators
    # We cooperated if c_i =1, defected if 0
    # π_i = (1 - c_i) + (k/n)*total_cooperators
    
    # If player cooperated last round:
    if my_last_action == 'C':
        coop_payoff = (k / n) * total_cooperators  # no private payoff when cooperating
        defect_payoff = 1 + (k / n) * (total_cooperators - 1)  # imagining if defected instead
        # If defecting would have gained more payoff, then we got exploited
        if defect_payoff > coop_payoff:
            return 'D'  # punish exploitation by defecting

    # If anyone cooperated last round (including us), defect to exploit that cooperation
    if total_cooperators >= 1:
        return 'D'

    # If no one cooperated last round, test cooperation by cooperating once to try induce cooperation
    return 'C'
```

---

## Explanation of Identity of Player in History

- The player should track their own index to find their past action.
- For the pseudocode, assume the player knows their own index `player_id` in `[1..n]`, so change `my_last_action = prev_actions[player_id - 1]`.

---

## Summary

| Situation                    | Action | Why                                               |
|-----------------------------|--------|--------------------------------------------------|
| Round 1                     | D      | Establish dominance, no trust yet                 |
| Last round cooperation exploited? | D      | Punish betrayal, never be sucker                  |
| Last round had cooperators  | D      | Exploit cooperators, gain max payoff              |
| Otherwise (all defect last round) | C      | Test if cooperation possible, try to improve gains |
| Final round                  | D      | No future rounds to incentivize cooperation       |

---

This strategy is **aggressive** because:

- It never initiates cooperation in round 1.
- It defects anytime cooperation exists to exploit cooperators.
- It punishes exploitation strictly by defecting.
- It does minimal cooperation only when everyone explored defection, trying to break the deadlock.
- It defects on the last round where cooperation has no future incentive.

Such an approach maximizes individual gain by exploiting cooperators and punishing defectors, aligning well with an aggressive mindset in a repeated public goods setting with selfish opponents.

---

If you want, I can also provide a version with adaptation if you specify the player index or want a more elaborate treatment of history and payoff computation.
'''

description_AGGRESSIVE_27 = '''
Here is an aggressive strategy designed for the repeated N-player Public Goods Game specified. It aims to maximize the individual payoff by exploiting cooperative players while minimizing costly cooperation. It treats cooperation as a weakness and defects aggressively to punish or capitalize on cooperators.

---

### Core Idea

- **Defect by default** to maximize private payoff (1 from withholding contribution) plus any public good generated by others' cooperation.
- **Exploit cooperators** by consistently defecting when others cooperate.
- **Punish excessive cooperation** by defecting after detecting a threshold of cooperation, to reduce overall group payoffs and discourage others from cooperating.
- **Use history to retaliate or exploit:** If too many cooperate, defect to gain higher payoff; if no one cooperates, continue defecting.
- **Last round defect:** Because cooperation has no future benefit, defect on last round to secure private payoff.
  
---

### Decision Rules

1. **Round 1 (no history):**  
   Defect (D)  
   *Rationale:* No prior info, defect to exploit any naive cooperators and gather information from responses.

2. **Rounds 2 to r-1:**  
   - Let `C_t-1` = number of cooperators in previous round (t-1).  
   - Define a **cooperation threshold T** (e.g., T = 1 or 2): tolerate minimal cooperation but become aggressive if many cooperate.  
   - If `C_t-1 ≥ T`:  
     - Defect this round.  
     - *Reason:* Punish or exploit cooperative behavior.  
   - Else (`C_t-1 < T`):  
     - Defect this round.  
     - *Reason:* No incentive to cooperate if others don’t.  
   
   **Note:** Always defect regardless of previous cooperation to preserve private payoff and never "waste" contribution.

3. **Last Round (t = r):**  
   Defect  
   *Reason:* Cooperation wouldn’t bring future benefits; maximize immediate private payoff.

---

### Pseudocode

```
Input: history of rounds 1...t-1, each round's actions by all players

Parameters: 
  T = 1   # Threshold of number of cooperators to trigger "punishing"

Decision for round t:

if t == 1:
    action = D  # No info, defect

else if t == r:
    action = D  # Last round defect

else: 
    C_prev = count_cooperators(actions_at_round_t_minus_1)
    # Always defect, but differentiate decision for clarity
    if C_prev >= T:
        action = D  # Punish / exploit cooperation
    else:
        action = D  # No incentive to cooperate

return action
```

---

### Notes on Aggressiveness

- The strategy **never cooperates**, so it never loses the private payoff from withholding.  
- Aggressively defects even when others cooperate, thereby exploiting them.  
- Punishes any observed cooperation (even if minimal), pushing opponents away from cooperation through a hostile environment.  
- Uses history only to identify if cooperation occurred but never reciprocates, consistent with an aggressive, exploitative stance.

---

### Edge Cases

- **All defect in first round:** No cooperation observed, continue defecting throughout as cooperation is dominated by defection.  
- **Some cooperate in first round:** Exploit immediately by defecting from round 2 onward.  
- **Full cooperation in previous rounds:** Defect to exploit maximal public good contribution by others.  
- **Single cooperator only:** Defect to maximize payoff since you gain from their contribution without paying cost.  
- **Game with just two rounds:** Defect in round 1 and 2, no cooperation.

---

### Summary

**Aggressive strategy**: Always defect, never cooperate, exploit and punish cooperation. Use knowledge of past cooperation only to confirm presence of naive or cooperative opponents to maximize free-riding gains.

---

This approach aligns clearly with an aggressive mindset: maximizing immediate payoff, exploiting cooperators, and discouraging cooperation by never rewarding it. It accepts short-term losses in public good for long-term individual gain in the repeated game environment.
'''

description_AGGRESSIVE_28 = '''
Here is an **aggressive strategy** designed for the given N-player repeated public goods game. The strategy focuses on maximizing individual payoff aggressively by exploiting cooperators while minimizing any cooperative concessions.

---

### Intuition behind the strategy

- **Aggressiveness:** Always prefer defecting because it preserves the private endowment, unless cooperating in certain situations yields strictly higher payoffs.
- **Exploitation:** Exploit cooperating players by defecting when they cooperate.
- **No forgiveness:** Punish cooperators only if they start to defect; otherwise, stay opportunistically selfish.
- **Edge rounds:** Recognize last round is a "defection trap" (no incentive to cooperate), first round assumes no information so choose optimum for first move (defect).
- **Observation:** Because 1 < k < n, defecting can sometimes yield larger payoffs if enough players cooperate.

---

### Key observations for payoffs

- Defecting yields immediate private payoff 1 plus a share of public good proportional to contributors.
- Cooperating yields no private payoff but benefits from public good contributed by others.
- Highest payoff for defectors occurs when many others cooperate.
- Highest payoff for cooperators occurs when everyone cooperates.

---

### Strategy Description

**In any round t (1 ≤ t ≤ r):**

1. **If t = 1 (first round):**  
   Defect. (No information about others yet, so grab private payoff.)

2. **For rounds 2 to r-1:**  
   Let `cooperators_last_round` = number of players who cooperated last round.  
   - If `cooperators_last_round` ≥ 1, *defect* to exploit cooperating players.  
     (Reason: When some cooperate, defecting gives you 1 + (k/n)*cooperators_last_round, generally > cooperating payoff.)  
   - Else (if no one cooperated last round), *defect* again.  
     (No incentive to cooperate if no one else does.)

3. **If t = r (last round):**  
   Always *defect*.  
   (Last round is a classic “endgame” defection where cooperation cannot be punished or rewarded later.)

---

### Pseudocode

```python
def aggressive_strategy(t, r, history, n, k):
    # Input:
    # t: current round number (1-based)
    # r: total rounds
    # history: list of dicts with keys 'cooperators' (set of player indices who cooperated)
    #          and 'actions' (list of length n with 'C' or 'D')
    # n: number of players
    # k: multiplication factor

    if t == 1:
        # First round: defect, no info yet
        return 'D'

    elif t == r:
        # Last round: always defect
        return 'D'

    else:
        # Intermediate rounds: 
        # Check how many cooperated last round
        last_round_cooperators = len(history[-1]['cooperators'])

        if last_round_cooperators >= 1:
            # others cooperated last round, exploit them by defecting
            return 'D'
        else:
            # if no cooperators, no reason to cooperate - defect to keep private payoff
            return 'D'
```

---

### Summary

- **Always defect every round.**  
- Why? Because defecting strictly dominates cooperating unless everyone cooperates, which is highly unlikely given no coordination or trust.  
- Even if some cooperate occasionally, defectors get a higher payoff by free-riding.  
- No risk of being exploited because you do not cooperate.  
- Aggressive mindset: maximize immediate return, exploit cooperators, no concession or trust.

---

This strategy is simple, clear, and unambiguous, making it viable for tournament play against independently generated LLM-based strategies. It fully leverages the public good game's parameters and payoff structure without hope or expectation of cooperation from others.
'''

description_AGGRESSIVE_29 = '''
Below is a detailed design of an **aggressive strategy** for the N-Player Public Goods Game. The strategy’s central theme is maximizing immediate payoffs by exploiting cooperation from others while aggressively defecting to maximize own earnings. It uses straightforward heuristics about others’ behavior based on the publicly visible action history. It adapts quickly but never cooperates first or in the last round, and punishes cooperation from others aggressively.

---

# Aggressive Strategy: Exploitative Defector

---

### Key Intuition:
- **Defection maximizes immediate private payoff** since your own contribution costs 1 unit.
- You benefit from others’ cooperation without contributing yourself.
- If others never cooperate, cooperating wastes your endowment.
- You never start cooperating — coercion or goodwill attempts are avoided.
- You punish cooperation by others by defecting, denying them the incentive.
- You never cooperate in the final round, no future to incentivize.
- If everyone defects, you defect as well — safe baseline.

---

### Decision Rules Summary:

| Round            | Decision                         | Reasoning                                                                                      |
|------------------|--------------------------------|------------------------------------------------------------------------------------------------|
| First round      | Defect (D)                     | No prior info, no reason to cooperate aggressively                                            |
| Intermediate round (2 to r-1) | Defect (D)                   | Always defect aggressively. You benefit by exploiting cooperating players. No forgiveness.     |
| Last round (round r) | Defect (D)                     | No future, cooperation pointless                                                             |

---

### Handling Others' Cooperation:

- Observe how many cooperators in previous round(s).
- Do **not** reciprocate cooperation.
- Always defect regardless of others’ cooperation level.
- Since all decisions are simultaneous, your defection punishes cooperative players by denying them return on their costly contribution.

---

### Pseudocode

```python
def aggressive_strategy(round_number, r, n, k, history):
    # history is a list of past rounds, each round a list of length n with 'C' or 'D'
    # round_number ∈ [1, r]
    
    # Always defect on:
    #  - First round (no history)
    #  - Intermediate rounds (2 to r-1)
    #  - Last round (r)
    
    return 'D'
```

---

### Additional Comments:

- The strategy is **memory-light**: it does not try to predict or adapt since cooperation gains are rare against other defectors.
- If others cooperate, you exploit them by defecting.
- If others defect, you avoid costly cooperation.
- You gain or tie for highest payoff in all scenarios (except if everyone cooperates, you gain less than cooperators but cooperation is not your goal).
- The strategy is zero-cooperation, maximizing aggressive exploitation.

---

### Why is this aggressive?

- It **never cooperates first or reciprocates**; it *always* defects.
- It aggressively exploits others’ cooperative actions when they occur.
- It punishes cooperation by refusing to contribute, denying return.
- It leverages game knowledge (r, no future cooperation after last round) to defect consistently.
- This behavior denies other players the benefit of cooperation, pushing them toward defection themselves or losing payoff to you.

---

### Summary:

| Round      | Action  |
|------------|----------|
| 1          | Defect   |
| 2 through r - 1 | Defect   |
| r (last round)   | Defect   |

---

This is an aggressive, hardline defecting strategy designed to dominate naive or cooperative opponents by harshly exploiting them while avoiding any risk or cost from cooperation.
'''

description_AGGRESSIVE_30 = '''
Here is a description of an **aggressive strategy** for the repeated N-player Public Goods Game, defined to maximize selfish gains by exploiting cooperators and minimizing contributions.

---

## Strategy Name: Defect-Exploit-TitForTitans (DETT)

### Strategic Intuition

This strategy is aggressive in that it:
- Defects **always** unless strong evidence exists that defecting will be collectively punished.
- Exploits any cooperators by defecting to maximize private payoff.
- Uses a grudging "punishment" approach, reducing tolerance for cooperators who do not “punish” defectors.
- Cooperates only when punishment is necessary to protect future payoffs, i.e., when a clear pattern of coordinated defection against you emerges.
- Uses no naive cooperation: it never initiates cooperation.
- Takes advantage of the payoff asymmetry: defectors get higher payoffs when others cooperate.

---

### Decision Rules

Let:
- \( t \in \{1, ..., r\} \) index the current round.
- \( h_t = \{(a_i^s)_{i=1}^n\}_{s=1}^{t-1} \) be the full history of all players' past actions up to round \( t-1 \).
- \( a_i^t \in \{C, D\} \) be action of player \( i \) at round \( t \).
- \( i_{self} \) is this player’s index.

---

### Rule 1: First round (t=1)

- **Defect**

Reasoning: No information yet, defecting yields guaranteed private payoff 1 plus potential benefit if others cooperate. Aggressive players never risk cooperation first.

---

### Rule 2: Subsequent rounds (t > 1)

1. **Calculate individual history metrics:**

   For every player \( j \neq i_{self} \), define their *defection consistency* as the fraction of rounds since round 1 in which they defected:

   \[
   D_j = \frac{\sum_{s=1}^{t-1} \mathbf{1}_{a_j^s = D}}{t-1}
   \]

   (where \(\mathbf{1}\) is the indicator function)

2. **Calculate total cooperators last round:**

   \[
   S^{t-1} = \sum_{j=1}^{n} \mathbf{1}_{a_j^{t-1} = C}
   \]

3. **Determine if player self was "punished" last round:**

   Player \( i_{self} \) is punished if:

   - \( a_{i_{self}}^{t-1} = D \) (we defected),
   - AND total cooperators \( S^{t-1} \) was low (e.g., \( S^{t-1} \leq 1 \)), meaning others mostly defected,
   - OR if a majority defected but the expected payoff for defecting dropped substantially.

4. **Decision logic:**

   - If **punished** in the previous round: **cooperate this round to signal willingness to restore cooperation**, but only *once* at a time.
   - Else if there are **any cooperators** in previous round, **defect** (to free-ride).
   - Else if all defected last round, **continue defecting**.
   - If this is the **last round** \( t = r \), **defect** outright (no incentive to cooperate in terminal round).

---

### Summary of behavior:

| Condition                      | Action                   | Rationale                                  |
|-------------------------------|--------------------------|--------------------------------------------|
| \( t = 1 \)                   | Defect                   | No info, maximize immediate gain           |
| \( t = r \) (last round)       | Defect                   | No future retaliation possible              |
| Punished last round            | Cooperate                | Try to avoid long-term punishment           |
| Any cooperators last round     | Defect                   | Exploit cooperators                          |
| All defected last round        | Defect                   | No chance to exploit, maintain defection   |

---

### Remarks on internal state & memory

- The strategy keeps track of who cooperated and defected in each round to identify punishing patterns.
- Punishment is assumed to be low cooperation levels when self defected. If others punish by defecting en masse, temporarily switch to cooperation to signal willingness to restore.
- Only one cooperation round after punishment to signal willingness; then return to defection unless cooperation continues.

---

## Pseudocode

```python
def DETT_strategy(t, r, n, k, history, self_index):
    # history: list of length t-1, each element is a list of n actions ['C' or 'D']
    # t: current round (1-based)
    # r: total rounds
    # n: total players
    # self_index: index of this player (0-based)

    if t == 1:
        return 'D'   # First move: always defect

    if t == r:
        return 'D'   # Last round: always defect

    last_round = history[-1]
    S_last = sum(1 for a in last_round if a == 'C')
    self_last = last_round[self_index]

    # Check if punished last round:
    # Punished if self defected last round AND very low cooperation from others
    other_coops = S_last - (1 if self_last == 'C' else 0)
    punished = (self_last == 'D') and (S_last <= 1)

    if punished:
        # Attempt to repair relationship: cooperate once
        return 'C'

    if S_last > 0:
        # Exploit cooperators by defecting
        return 'D'

    # Otherwise if all defected last round
    return 'D'
```

---

## Aggressiveness Explanation

- **Never initiates cooperation.** For an aggressive strategy, cooperation is a concession, so only do it when forced by consequences.
- **Always exploits cooperators.** If anyone cooperated last round, defect now to get maximum private gain.
- **Accepts short-term losses for long-term gains.** Cooperate only once after being punished to avoid harsh retaliation.
- **Defects in last round with no fear** of retaliation, maximizing final round payoffs.
- **Uses complete information about past actions** to detect when it is necessary to temporarily cooperate.

---

# Summary

This aggressive strategy "DETT" aggressively defects, exploits cooperators, grudgingly cooperates only to mitigate punishment, and defects outright in terminal rounds, aiming to maximize the player’s own total payoff in the repeated public goods game.
'''

description_AGGRESSIVE_31 = '''
Here is an aggressive strategy tailored for the N-Player Public Goods Game with the given setup and constraints:

---

## Aggressive Strategy Description

**Core idea:**  
Maximize own payoffs by free-riding on cooperation of others whenever possible, punish cooperators to discourage their generosity, and defect by default to avoid exploitation. Cooperate only under strictly advantageous circumstances that can lead to higher payoffs. Leverage game history to identify and exploit cooperative players but do not attempt cooperation unless forced by endgame considerations.

---

### 1. Decision Rules

**Notation:**

- \( c_i^t \) = action of player i in round t (1 if cooperate, 0 if defect)
- \( C_{-i}^t = \sum_{j \neq i} c_j^t \) = number of other players cooperating in round t
- \( r \) = total rounds
- \( t \) = current round index (1 to r)

---

### Default Behavior

- **Defect every round by default** to maximize private payoff = 1 + (k/n) * number_of_cooperators.
  - Defecting yields a guaranteed private payoff of 1 and a share of public goods generated by others.

---

### Exploit Cooperators

- If in the previous round \( t-1 \), some players cooperated ( \( C_{-i}^{t-1} > 0 \) ), **continue defecting to exploit their cooperation**.
- Do **not** cooperate to “reward” cooperators or induce trust; instead, use their cooperation as a free lunch.

---

### Punish Cooperators Who Cooperate Repeatedly

- If any particular player \( j \neq i \) has cooperated in **more than half of the past rounds** (i.e., is a persistent cooperator), **continue defecting to punish and exploit them**.
- Do not attempt to coordinate.

---

### First Round

- No history exists; defect outright to establish aggressive baseline.
- Cooperate only if you observe a strict incentive (see "Last Round" case) — which is not applicable in the first round.

---

### Last Round \( t = r \)

- Cooperation is dominated by defection in the last round (no future reward/punishment possible).
- Hence, **defect in the last round with certainty**.
- If all play defect, payoff is 1 per round for all.
- As the game is repeated, defection is the dominant strategy for the last round.

---

### Optional last-but-one round \( t = r-1 \)

- If you expect at least one cooperator in the last round (unlikely, given no cooperation incentive), you might cooperate to increase payoff this round.  
- But this requires trust with no basis, so defect anyway.

---

### Summary of Cooperation Conditions (very limited):

- Only cooperate if you can **ensure** others cooperated in the previous round AND it is not the last round.
- Even then, cooperation is risky: to keep strategy aggressive, prefer to defect and free-ride rather than try cooperation.

Thus, effectively cooperate **never or almost never** in practice.

---

## Pseudocode for Aggressive Strategy

```python
def aggressive_strategy(history, t, r, n, k):
    # history: list of lists of previous rounds actions for all players
    # t: current round (1-based)
    # r: total rounds
    # n: number of players
    # k: multiplication factor
    
    # Edge case: first round - defect
    if t == 1:
        return 'D'
    
    # Edge case: last round - defect always
    if t == r:
        return 'D'
    
    # Count past actions of each player
    cooperation_counts = [0] * n
    total_rounds_played = t - 1
    for past_round in history:
        for i, action in enumerate(past_round):
            if action == 'C':
                cooperation_counts[i] += 1
    
    # Count number of cooperators last round excluding self
    last_round = history[-1]
    cooperators_last_round = sum(1 for a in last_round if a == 'C')
    self_last_action = last_round[own_index]  # own_index known internally
    
    # Condition 1: Exploit cooperators
    if cooperators_last_round > 0:
        # Defect to free-ride
        return 'D'
    
    # Condition 2: Punish persistent cooperators
    # If any other player cooperated in >50% of past rounds, defect to punish
    for i in range(n):
        if i == own_index:
            continue
        if cooperation_counts[i] > total_rounds_played / 2:
            return 'D'
    
    # No cooperators to exploit or punish, defect by default
    return 'D'
```

---

## Rationale / Game-Theoretic Justification

- Because \( 1 < k < n \), the social optimum is for everyone to cooperate, but from an individual incentive perspective, defecting while others cooperate yields a strictly higher payoff.
- Repeated interaction allows for conditional strategies (like Tit-for-Tat), but these require trust and coordinated punishment — not possible under constraints.
- Aggressive here means **never voluntarily sacrificing private payoff to help others**. Defection dominates cooperation for the selfish player.
- The strategy exploits any observed cooperation but does not reward or attempt to induce it.
- Last round defection (backward induction) prevents exploitation by cooperators.
- Punishment is implemented only as a disincentive for persistent cooperative players, but since cooperation is never initiated by this strategy, punishment mostly operates by default defection.

---

## Summary

| Round          | Action                   | Reason                                     |
|----------------|--------------------------|--------------------------------------------|
| 1              | Defect                   | No history, start aggressively             |
| 2 to r-1       | Defect                   | Exploit cooperators, punish persistent ones|
| r (last round) | Defect                   | Backward induction, no incentive to cooperate |

---

This is a strongly *aggressive free-riding* strategy that maximizes personal gain by exploiting cooperative players and never attempts to cooperate or coordinate. It is completely robust to assumptions about others and exploits the payoffs structure maximizing selfish gain.

---

If you want, I can help you adapt or extend this strategy with experimental cooperation triggers, but this is an archetypal aggressive approach consistent with standard reasoning in repeated public goods games without communication or coordination.
'''

description_AGGRESSIVE_32 = '''
Below is a detailed aggressive strategy for the N-Player Public Goods Game described. The strategy is designed to maximize individual payoffs by exploiting cooperators aggressively, defecting whenever profitable, and punishing those who try to cooperate to avoid exploitation.

---

### Strategy Name: **Aggressor-X**

---

## Intuition

- **Aggressive mindset:** Always prefer defection to maximize immediate individual gain.
- Exploit cooperators completely by defecting when others cooperate.
- Attempt minimal cooperation (only if it strategically improves returns).
- Punish cooperative attempts from others by defecting to discourage group cooperation.
- On the last round, defect always, as no future retaliation or reward is possible.
- In early rounds, probe opponents briefly but default aggressively to defection.

---

## Decision Rules

Let:
- `t` = current round number (1-based)
- `r` = total rounds
- `n` = number of players
- For `t > 1`, let `history[t-1]` be the vector of actions by all players last round, including self
- Define `nC_last` = number of players who cooperated last round
- Define `nC_others_last` = number of cooperating players excluding self last round

---

### Round 1: Initial Probe Round

- Because no history exists, choose to **defect** (D).
- Reason: Cooperating first round risks exploitation; defecting immediately maximizes initial payoff while observing others' behavior.

---

### Round 2 to Round r-1: Repeated rounds (Non-final)

- If in previous round you **cooperated**:
  - **Defect** this round.
  - Reason: To exploit cooperators and avoid being taken advantage of.

- Else if in previous round you **defected**:
  - Observe number of cooperators other than self last round:

    - If `nC_others_last` = 0 (everyone defected last round):
      - **Defect** again.
      - Reason: No cooperators to exploit; playing cooperatively is strictly worse individually.

    - If `nC_others_last` > 0:
      - **Defect** this round to exploit cooperating opponents who are "naive".
      - Reason: Aggression means never give up private gain if others contribute.

---

### Final Round (t == r):

- Always **defect**.
- Reason: No future consequences, so maximize immediate payoff.

---

## Summary Table

| Previous Round Action (Self) | Number Cooperating Others Last Round | Action This Round   |
|-----------------------------|-------------------------------------|--------------------|
| N/A (Round 1)               | N/A                                 | Defect (D)         |
| Cooperated (C)              | Any                                 | Defect (D)         |
| Defected (D)                | 0                                   | Defect (D)         |
| Defected (D)                | >0                                  | Defect (D)         |
| Any                         | Any                                 | Defect (D) if last round |

---

## Pseudocode

```python
def AggressorX_strategy(t, r, n, history):
    # t: current round (1-based)
    # history: list of previous rounds' actions; each element a list of actions for all players
    
    # Round 1: No history
    if t == 1:
        return 'D'  # defect immediately
    
    # Final round: always defect
    if t == r:
        return 'D'
    
    # From round 2 to r-1:
    last_round_actions = history[t-2]          # zero-index correction
    self_last_action = last_round_actions[self_index]  # Assume player knows own index
    
    nC_others_last = sum(1 for i,a in enumerate(last_round_actions) if a == 'C' and i != self_index)
    
    if self_last_action == 'C':
        # Exploit cooperators by defecting now
        return 'D'
    else:  # self_last_action == 'D'
        if nC_others_last == 0:
            # Nobody cooperated last round, keep defecting
            return 'D'
        else:
            # Exploit cooperators this round by defecting
            return 'D'
```

---

## Remarks

- The strategy **never cooperates beyond initial round** (where it defects), so it is purely aggressive.
- It aggressively exploits cooperators and punishes cooperation by never participating in it.
- It is "aggressive" in that it forces others to cooperate and be exploited or also defect, resulting in a Prisoner's Dilemma style equilibrium.
- No attempt is made to build trust or coordinate — such behavior would be non-aggressive.
- On the last round, always defect to maximize immediate payoff.

---

This is a pure defecting aggressive strategy that exploits cooperators optimally and punishes cooperation. It should perform well in a tournament of diverse strategies that includes cooperators or conditional cooperators.
'''

description_AGGRESSIVE_33 = '''
**Aggressive Strategy for N-Player Public Goods Game:**

---

### Key Intuition:
The aggressive mindset wants to maximize own payoff by exploiting others’ cooperation whenever possible, never sacrificing private gain for the group. It aims to:

- Exploit cooperators by defecting.
- Punish perceived cooperators sufficiently early to discourage persistent cooperation (which could benefit others).
- Never initiate cooperation itself (to never give others free payoffs).
- Leverage any cooperation from others to maximize own payoffs.

---

### Decision Rules:

#### Round 1:
- **Always defect**.  
No prior information; cooperating risks own payoff. Aggressive mindset commits to maximizing immediate payoff from the start.

#### Subsequent rounds (t = 2 to r-1):
- Let `cooperators_t-1` = number of players who cooperated in round t-1 (including self).
- Let `player_i_cooperated_t-1` be true if player i cooperated in previous round, false otherwise.

**Decision logic:**

- IF (any other player cooperated in round t-1)  
  → Defect this round ("Exploit any cooperation from others").
- ELSE (all defected last round)  
  → Defect again ("No incentive to cooperate if no one cooperates").

This logic ensures the aggressive player **never cooperates**, exploits cooperators each round, and never misses an opportunity to get the guaranteed +1 from defection plus the multipied contributions from others.

---

#### Last round (t = r):

- **Defect again**, to avoid giving free payoffs on the final round and capture maximum private gain.

---

### Summary:

| Round     | Condition                            | Action  | Reason                               |
|-----------|------------------------------------|---------|------------------------------------|
| 1         | No history                         | Defect  | Immediate maximum payoff            |
| 2..r - 1  | Any cooperation observed round t-1 | Defect  | Exploit cooperators (aggression)   |
| 2..r - 1  | No cooperation observed round t-1  | Defect  | No reason to cooperate              |
| r (last)  | Always                            | Defect  | Never help others on last round     |

---

### Pseudocode:

```
Initialize:
  r = total rounds
  t = current round

At each round t:

  If t == 1:
    action = Defect

  Else if 1 < t < r:
    if exists player j ≠ i where action_j,t-1 == Cooperate:
      action = Defect    # exploit cooperators
    else:
      action = Defect    # no cooperation last round -> keep defecting

  Else if t == r:
    action = Defect      # last round defect

Return action
```

---

### Explanation:

- **Always defect**: never lose private payoff.
- **Exploit cooperation aggressively**: as soon as others cooperate even once, defect to gain maximum.
- **Never forgive or cooperate**: no costly cooperation to signal or incentivize others.
- **Exploitative and ruthless**: punishes cooperation, extracts payoffs from cooperators, promotes mutual defection equilibrium.
- **Edge cases**: first round, last round treated the same—always defect to maximize payoff.

---

### Why This is Aggressive:

- This strategy behaves selfishly and opportunistically.
- It exploits every cooperative move of opponents.
- It never takes the risk of cooperating itself.
- It aggressively punishes any perceived trust (non-cooperation is the only stable choice).
- In the repeated context, it uses history to maximize own gains without cooperation.

---

### Potential outcome against diverse opponents:

- Against cooperators: gains more than cooperators.
- Against defectors: matches them.
- Against conditional cooperators: exploits them early and consistently.
- Maximizes total payoff relative to strategies that cooperate.

---

**This aggressive strategy is consistent, ruthless, and exploits public goods contributions without ever contributing itself.**
'''

description_AGGRESSIVE_34 = '''
Below is an **aggressive strategy** designed for the repeated N-Player Public Goods Game as specified. The strategy focuses on maximizing individual payoffs by exploiting cooperators while deterring exploitation by defecting against defectors, with clear handling of initial and final rounds.

---

## Strategy Overview: "Aggressive Exploiter with Punishment"

**Core Idea:**  
Start by defecting to avoid being exploited. If other players cooperate, exploit them by defecting (since defecting yields a strictly higher payoff against cooperators). However, retaliate against persistent defectors by defecting as well, to avoid being trapped in mutual defection rounds that reduce your total payoff. Near the end of the game, defect consistently since cooperation loses value with no future punishment.

---

## 1. Decision Rules

Let **t** denote the current round (1 ≤ t ≤ r). Let:

- `history[t-1]` be the vector of all players' actions at round t-1 (except for the first round where no history exists).
- `C_count[t-1]` = number of players who cooperated in round t-1.

### Rule Details

**Round 1 (t=1):**  
- Play **D** (defect).  
  *Rationale:* No history to trust others. Defecting avoids being exploited initially.

**Rounds 2 to r-1 (1 < t < r):**  
- Check cooperation levels in previous round (t-1):
  - If `C_count[t-1]` is **high** (≥ threshold), **Defect** to exploit cooperators.  
    *Rationale:* Exploit the cooperators by defecting for maximum immediate payoff.
  - Else (cooperation low): **Defect**.  
    *Rationale:* Avoid costly cooperation when others mostly defect.
    
- **Punishment Trigger:**  
  - If a majority of players defected last round (≥ (n/2) defectors), continue defecting to punish and avoid losses.

**Round r (last round):**  
- Always **Defect**.  
  *Rationale:* No future rounds means no incentive to cooperate.

---

## 2. Thresholds and Parameters

- Cooperation threshold (to detect "enough cooperators"):  
  `cooperate_threshold = ceil(n / 2)`  
  (i.e., a strict majority cooperating is considered "high cooperation")

- Punishment threshold:  
  `defect_threshold = floor(n / 2) + 1`  
  (majority defections trigger persistent defection)

---

## 3. Pseudocode Summary

```python
def aggressive_strategy(t, r, n, history):
    """
    t: current round (1-based)
    r: total rounds
    n: number of players
    history: list of previous rounds, each round is list of actions ['C' or 'D'] of all players
             history[t-1] is round t's actions (if t > 1)
             
    Returns: action for this round 'C' or 'D'
    """
    
    cooperate_threshold = (n + 1) // 2  # majority
    defect_threshold = (n // 2) + 1
    
    # First round no history => Defect
    if t == 1:
        return 'D'
    
    # Last round => Defect no matter what
    if t == r:
        return 'D'
    
    # Analyze previous round
    prev_round = history[t-2]  # zero-indexed
    
    c_count = prev_round.count('C')
    d_count = n - c_count
    
    if c_count >= cooperate_threshold:
        # Many cooperators: Exploit by defecting
        return 'D'
    else:
        # Few cooperators: Defect to avoid being exploited
        return 'D'
```

---

## 4. Explanation

- **Aggressiveness:**  
  Always defect except when cooperating has clear, immediate benefits. Since defection yields a guaranteed private payoff of 1 plus a share of public good, and cooperation costs 1 private unit, defecting against cooperators maximizes payoff. This strategy never tries to "forgive" cooperators with own cooperation, because cooperating yields strictly less payoff when others defect.

- **Exploitation:**  
  When many players cooperate, defecting yields the highest payoff. The strategy is greedy and aggressively exploits that.

- **Punishment:**  
  The strategy never cooperates to reward others; persistent defection is met with continued defection. This discourages attempts by others to exploit this player.

- **First and Last Round:**  
  No trust in round 1, so defect. In the last round, defecting is strictly dominant as no future retaliation or reward is possible.

- **No Cooperation Phases:**  
  Unlike generous or tit-for-tat strategies, this never cooperates voluntarily because cooperation strictly lowers its own individual payoff if others defect. It aims to maximize personal return aggressively throughout.

---

## Summary

| Round         | Condition                         | Action  | Reason                       |
|---------------|---------------------------------|---------|------------------------------|
| t=1           | No history                      | D       | No trust, no incentive to cooperate  |
| 1 < t < r     | Majority cooperated (≥ threshold) | D       | Exploit cooperators          |
| 1 < t < r     | Otherwise                      | D       | Avoid exploitation           |
| t = r         | End of game                    | D       | No future consequences       |

---

This aggressive strategy should yield high payoffs against cooperating opponents by exploiting them, while protecting itself from exploitation by defectors. It aligns perfectly with a harsh, self-interested, aggressive playstyle in this repeated public goods setting.
'''

description_AGGRESSIVE_35 = '''
Here is a detailed design of an **aggressive strategy** for the N-player repeated Public Goods Game. This strategy aggressively pursues individual payoff maximization through defecting as much as safely possible while selectively cooperating only when strictly beneficial for future gain and deterrence.

---

### Core Idea

- **Aggressive** means taking maximum advantage of others' cooperation without reciprocating freely. Defect frequently to gain the private payoff and appear as a "free rider."
- **Strategic conditional cooperation** defends against mass defection that leads to low payoffs for all.
- **Final round defect** since no future retaliation is possible.
- Use **punishment cycles** to deter other cooperators from exploiting you continuously.

---

### Decision Rules

Let:

- `t` be the current round (1 to r)
- `history` be all prior rounds' action profiles (all players' actions)
- `C_count[t-1]` be the number of cooperators in round `t-1`
- `my_action[t-1]` be your own action in round `t-1`

**Variables computed after round 1:**

- `cooperators_last_round`: number of players who cooperated last round (excluding self if desired, but including self is simpler)
- `opponents_cooperated_last_round` = `cooperators_last_round - c_i` (how many others cooperated)
- `mean_cooperation_rate` = discounted average cooperation rate of ALL players excluding self (can be approximated by averaging cooperation rates across rounds)

---

### Pseudocode 

```pseudo
FOR round t in 1 to r:

    IF t == 1:
        # First round: test waters with defection to maximize immediate payoff and gather info
        play D (Defect)
        
    ELSE IF t == r:
        # Last round: no future consequences, defect aggressively
        play D
        
    ELSE:
    
        # Calculate cooperation rate of others in previous round
        opponents_cooperated_last_round = count of other players cooperating in round t-1
        
        # Calculate how profitable defecting or cooperating would be:
        # Note: For player i:
        # π_i(C) = 0 + (k/n) * total_cooperators_last_round
        # π_i(D) = 1 + (k/n) * total_cooperators_last_round
        #
        # Always π_i(D) > π_i(C) unless total_cooperators_last_round = 0 (public good no benefit)
        
        # Strategy rule:
        IF opponents_cooperated_last_round is high (≥ threshold_H):
            # Others are cooperating enough to make cooperation marginally profitable as deterrence
            # To maintain some future benefits and discourage collapse, cooperate if I cooperated last round
            # - This creates a "conditional cooperation" streak, but aggressively exploiting
        
            IF my_action[t-1] == C:
                play C
            ELSE:
                # Defect harshly against defectors to punish free riders but allow return
                play D
        
        ELSE IF opponents_cooperated_last_round is low (< threshold_H):
            # Others defecting or low cooperation => defect to maximize short term gains and avoid sucker payoff
            play D
            
        # Additional refinement: If defected last round AND cooperation rate dropped sharply, punish with defection until cooperation recovers.
```

---

### Thresholds and Notes

- `threshold_H` = approximately `ceil(n/2)` or slightly above, i.e., cooperate if majority of others cooperated last round, defect otherwise. This punishes low cooperation.
- This strategy punishes sustained defection but tries to exploit any persistent cooperation by defecting when possible.
- It will never become a "nice" strategy that always cooperates but cooperates conditionally only to sustain higher collective payoffs for self-interest.
- On round 1, defect to maximize payoff and to not give away free cooperation.
- On the last round, defect regardless, since no future retaliation.
- Between, cooperate only if you cooperated previously and enough others cooperated last round — a minimal signal of trustworthy cooperation to maintain returns.
- Otherwise defect to punish or exploit.

---

### Summary of aggressive character

- **Tough first move**: Always defect round 1.
- **Conditional cooperation with punishment**: Only cooperate if you cooperated last round and enough others cooperated last round — as a defensive move.
- **Predatory exploitation**: Defect otherwise to maximize private payoff.
- **Final round defection**: Always defect final round.
- **Respond quickly to defection drops**: Punish declines in cooperation immediately and return to defection until cooperation resurges.

---

### Illustrative Examples

Let’s say `n=6`, `k=2`

- Round 1: defect for sure.
- Suppose in round 2, 4 others cooperated.
    - You cooperated in round 1? No (you defected)
    - Opponents cooperated = 4 ≥ 3 (half), but you didn't cooperate prior.
    - Play D (defect to exploit them).
- Suppose in round 3, opponents cooperated = 5, and you defected round 2
    - Still defect to exploit.
- Suppose they start defecting and you observe opponents cooperated = 1
    - Defect to avoid sucker payoff.
- Suppose you cooperate in round 5 and opponents cooperated = 4
    - Cooperated last round = no
    - Defect
- Suppose you cooperated in round 6 and opponents cooperated = 5
    - Cooperated last round = yes
    - Cooperate to reap joint benefits.

---

This mixes aggressive exploitation of cooperators with minimal strategic conditional cooperation as a deterrent and to maintain possible beneficial cooperation streaks.

---

If you want, I can provide a more formal algorithm or clarify any part.
'''

description_AGGRESSIVE_36 = '''
Below is an **aggressive strategy** for the N-Player Public Goods Game defined in your specification.

---

## Strategy Name: Aggressive Exploiter

### Intuition
- This strategy aims to **maximize individual gain** by exploiting cooperators.
- It **defects unless strictly forced to cooperate to avoid giving free payoffs to others**.
- It punishes cooperation by others only if they actually cooperate, but never invests first.
- It maximizes payoff by consistently defecting except in rare forced cases near the end.
- It aggressively exploits cooperators, taking advantage of their contributions to increase own payoff without contributing.

---

### Decision Rules

1. **Round 1 (First Round): Defect unconditionally**  
   There is no prior history so cooperate would be naive. Aggressive players never pay a cost upfront.

2. **Rounds 2 to r-1 (Intermediate Rounds): Defect unconditionally**  
   Never cooperate in intermediate rounds, as cooperating reduces your immediate payoff and risks exploitation by defectors.

3. **Last Round r (Final Round): Defect unconditionally**  
   Since there is no future punishment possible, defecting in the last round maximizes payoff (classic backward induction logic).

4. **No conditional cooperation or forgiveness:**  
   Never cooperate regardless of history.  
   Observing cooperation from others does not trigger cooperating or punishment via cooperation.

---

### Rationale for Aggressiveness

- Since k < n, contributing (cooperating) costs 1 private unit and increases public good distribution by less than 1 for the individual, immediately making cooperation a net loss compared to defection when others defect.
- Cooperating is only beneficial if enough others also cooperate, but since others might defect, the best guaranteed gain is to defect and free-ride on others.
- This strategy chooses **to maximize exploiting cooperative players, never risking loss by cooperating**.
- By never cooperating, it maximizes cumulative payoff against all but fully cooperative groups, where it still does better by saving contribution costs.
- This aggressive approach is minimal risk and maximally exploitative, aligning with a "defect-first, defect-always" mindset.

---

### Pseudocode

```python
def aggressive_exploiter_strategy(round_number, history, n, r, k):
    # history: list of tuples for each previous round; each tuple is (actions_list, payoffs_list)
    # actions_list: list of actions by all players in that round ['C' or 'D']
    # payoffs_list: list of payoffs by all players in that round
    
    # Aggressive exploiter always defects
    
    return 'D'
```

---

### Notes

- The strategy ignores all observations and history because it never cooperates.
- It does not attempt retaliation or conditional cooperation because that would dilute aggressiveness.
- It maintains the highest guaranteed payoff against mixed or cooperative opponents by avoiding contribution costs entirely.
- In a tournament against more naive or cooperative strategies, it exploits their cooperation fully.
- Against fully defecting opponents, it performs equally well (payoff = 1 per round).

---

If desired, a slight variant could consider cooperation *only* in the last round if others cooperated consistently to deter exploitation—but this is more restrained than purely aggressive. The above fully aggressive approach matches the classic "Always Defect" mindset tailored to this public goods environment.
'''

description_AGGRESSIVE_37 = '''
Here is a detailed aggressive strategy for the N-Player Public Goods Game, designed to maximize your own payoff by exploiting cooperators and avoiding exploitation.

---

### Strategy Overview: "Aggressive Exploiter"

This strategy aggressively defects to maximize immediate payoffs but uses limited conditional cooperation early on to detect and exploit cooperators in the group. It is characterized by:

- Starting with defection to avoid being exploited initially.
- Attempting minimal probing cooperation early to detect if others cooperate.
- Once cooperators are detected, always defect to exploit them.
- In the last round(s), defect unconditionally to maximize immediate return as there is no future punishment.
- Never tolerate cooperation at your own expense; always respond with defection (punishment) to cooperators after detection.

---

### Intuition

- **Aggressiveness means prioritizing immediate payoff from defecting and exploiting cooperators if any.**
- Cooperation benefits everyone only if the multiplication factor k is sufficiently high and many players cooperate.
- Since k < n, defecting when others cooperate yields a strictly higher payoff (see examples).
- Because defecting investors can gain more in rounds with cooperators, we try to identify and exploit them.
- We avoid costly cooperation that benefits others at our expense.
- In repeated rounds, cooperate minimally as "probe" but very cautiously, then defect always.
- Final rounds are always defect to prevent exploitation.

---

### Formal Decision Rules

Let:

- `round` ∈ {1, ... r}
- `history` = all previous actions of all players until before current round
- `others_cooperated_before` = boolean indicating if any other player cooperated in any previous round
- `coop_count_in_last_round` = number of cooperators (other than self) in the last round

---

### Step 1: Initialization

- Keep track of whether cooperation by others has ever been observed in any previous round.
- Track the identity of cooperators if desired (optional).

---

### Step 2: Round-by-Round Action Selection

**On round 1:**

- **Defect (D)**
  
Rationale: No info yet, no reason to cooperate and risk exploitation.

---

**For subsequent rounds (2 ≤ round < r):**

- If no other player ever cooperated in previous rounds:

   - **Defect (D)**
   
   Because no incentive to cooperate if no one else shows cooperation.

- Else if cooperation has been observed before:

   - **Defect (D)**
   
   Exploit cooperators by defecting while others contribute.

---

**On the last round (round == r):**

- **Defect (D) unconditionally**
  
No future punishment possible; maximize immediate return.

---

### Step 3: Optional Minimal Probing Variant (can be used to detect cooperators in early rounds)

- On round 2, optionally cooperate once only if no one cooperated in round 1, as a probe.

- On round 3 onwards, follow normal defecting logic.

But generally, staying defect all rounds is more aggressively consistent.

---

### Summary of Actions per Round

| Round        | If no observed cooperation | If observed cooperation    |
|--------------|---------------------------|----------------------------|
| 1 (first)    | D                         | N/A                        |
| 2 ... r - 1  | D                         | D (exploit cooperators)    |
| r (last)     | D                         | D                          |

---

### Pseudocode

```python
def aggressive_exploiter_strategy(round, history, n, r, k):
    # history: list of previous rounds' action profiles,
    # where each element is a list of length n with 'C' or 'D' for each player
    
    # Step 1: Check if any other player cooperated before
    others_cooperated_before = False
    for prior_round_actions in history:
        # Check if any player other than self cooperated
        if any(action == 'C' for action in prior_round_actions):
            others_cooperated_before = True
            break

    # Step 2: Decide action based on round and observed cooperation
    
    if round == 1:
        # Round 1: always defect
        return 'D'
    
    elif round < r:
        # Intermediate rounds
        if not others_cooperated_before:
            # No cooperation seen => defect
            return 'D'
        else:
            # Cooperation seen => exploit by defecting
            return 'D'
    
    else:
        # Last round: always defect
        return 'D'
```

---

### Explanation of Aggressiveness

- The strategy **never cooperates**, except optionally to probe, thus always seeks to maximize immediate payoff from defection.
- It **identifies cooperators** by observing the history but uses this only to confirm to keep defecting and exploit their contributions.
- It does **not attempt to build trust or punish defectors by cooperating**, instead chooses defection every time.
- In the last round, defecting guarantees maximal selfish payout since no future retaliation is possible.
- The strategy is **purely self-interested and always aggressive**, favoring personal gain over group benefit.

---

### Notes

- Because k < n, defecting always strictly dominates cooperating in immediate payoff when others cooperate.
- The strategy exploits any cooperative tendencies by opponents.
- This strategy aligns with the classical "All-D" defection approach well known in Prisoner's Dilemma and public goods analogues but is explicitly justified here given the payoff and conditions.
- Optionally, you could add a single probing cooperate move in round 2 if you want to detect altruists early, but this risks exploitation on your part and reduces aggressiveness.

---

If you want, I can also design a variant with minimal probing cooperation to attempt to detect cooperative players before exploiting them. But the above strategy is the most aggressive and defensible given the game rules.
'''

description_AGGRESSIVE_38 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Strategy Overview

This strategy aims to maximize individual payoffs by exploiting cooperation from other players but punishes any indication of cooperation from opponents by defecting to avoid being exploited. It aggressively leans toward defection but tries to induce and sustain defections among others while opportunistically cooperating only if it can extract higher payoffs briefly.

---

### Intuition Behind Aggressiveness

- **Defect by default:** The highest guaranteed private payoff per round comes from defecting if others cooperate.
- **Exploit cooperators:** When others cooperate, defecting is lucrative.
- **Punish cooperators:** If any cooperator shows they are willing to cooperate repeatedly, never cooperate yourself—deny returns to cooperators and encourage collapse to defection.
- **Minimal cooperation for signaling:** Attempt only minimal cooperation at the start and under strict conditions to probe if others are strongly cooperative (to exploit shortly).
- **Endgame defection:** Since in the last round there is no fear of retaliation, always defect.

---

### Detailed Decision Rules by Round

---

**Round 1 (No history):**

- **Action:** Defect (D)
- **Reason:** No information, best safe high payoff is to defect while probing others’ responses next rounds.

---

**Round 2 to (r-1) (Intermediate rounds):**

- If **no player cooperated in prior round** (all defected):
  - Defect again (D)
  - Reason: No sign of cooperation; safe to keep defecting as cooperation payoff is low and risky.

- If **some players cooperated in prior round**:
  - Defect (D)
  - Reason: Exploit cooperators by defecting every time to maximize individual payoff.
  - This punishes cooperators and discourages sustained cooperation.

---

**Round r (Final round):**

- Defect (D)
- Reason: Final round—no retaliation possible, so defect to maximize private payoff regardless.

---

### Summary of Behavior

| Round          | Condition                                   | Action |
|----------------|---------------------------------------------|--------|
| 1              | No history                                  | D      |
| 2 to r - 1     | If all defected in *previous* round         | D      |
| 2 to r - 1     | If at least one player cooperated previous round | D      |
| r (last round) | Always                                     | D      |

---

### Pseudocode

```python
def aggressive_strategy(round_number, r, history):
    # history is a list of past rounds' actions of all players,
    # each round is a list of actions e.g. ['D', 'C', 'D', 'D', ...]
    
    if round_number == 1:
        # Round 1: no info, defect
        return 'D'
    
    if round_number == r:
        # Last round: always defect
        return 'D'
    
    # Get last round actions of all players (including self)
    last_round_actions = history[-1]
    
    # Check if any cooperation in last round
    any_cooperate = any(action == 'C' for action in last_round_actions)
    
    if not any_cooperate:
        # No cooperation observed, defect
        return 'D'
    else:
        # Cooperation detected, defect to exploit and punish
        return 'D'
```

---

### Explanation of Aggressiveness

- **No cooperation ever:** The strategy **never cooperates** beyond possibly a minimal attempt to cooperate in round 1 (not in this case—here it always defects).
- **Punishes cooperators:** By defecting whenever others cooperate, it exploits cooperators and discourages repeated cooperation.
- **Maximizes private payoff:** Defecting yields a guaranteed base reward plus any fraction of contributions from cooperators.
- **Guarantees own payoff focus:** No risk of being exploited by cooperating.

---

### Notes on Potential Adaptations (Optional)

- Strategy could try a **one-shot cooperation** on round 1 to probe but then revert to defect — but this risks giving cooperators a lead; the above aggressive approach takes a "safe" stance of early defection.
- No forgiveness or cooperation forgiveness steps: purely exploitative and aggressive.

---

### Overall Conclusion

This strategy is strictly **defection-focused**, punishing all cooperation found in the history, never yielding. It embodies an aggressive player that seeks maximum individual payoffs by exploiting cooperative behavior and firmly discouraging cooperation — a classic "defect always" in repeated public goods with observation of others actions.
'''

description_AGGRESSIVE_39 = '''
Below is an **aggressive**, self-maximizing repeated strategy for the N-Player Public Goods Game, designed to exploit cooperators and minimize losses against defectors while maximizing total payoff over repeated rounds.

---

## Key Ideas Behind the Strategy

- Aggressiveness means avoiding cooperation unless it’s absolutely profitable based on prior observed behavior.
- Exploit cooperators by defecting as soon as any evidence of cooperation occurs.
- Do not waste tokens contributing when others defect.
- Defect initially to test how many cooperators appear.
- Once cooperators are identified, betray them consistently.
- Recognize the incentive in the last round to defect almost always (no future punishment).
- No forgiveness: once anyone cooperates, exploit by defecting.
- This exploits the multiplication factor k (with k < n), so defecting yields higher private returns when others cooperate.

---

## Intuition

- In early rounds, sense if there are cooperators.
- If no cooperators, keep defecting.
- If cooperators appear, defect to get the maximal payoff from their contributions.
- This yields best payoff when others cooperate.
- Others may learn this and defect, so the strategy defaults to defection thereafter.
- Last round: always defect (no future rounds to lose from defection).

---

## Formal Description

### Variables

- `r`: Total rounds
- `current_round`: current round index [1..r]
- `history`: list of action profiles for previous rounds (each round: n actions `C` or `D`)

### Notation

- `C_count_last`: number of cooperators in last round
- `others_cooperated`: TRUE if any other player cooperated in any prior round

### Strategy Steps

```
Initialize others_cooperated = False

For each round t in 1..r:

    if t == 1:
        # First round: defect to test
        play D

    else if t == r:
        # Last round: always defect (no future punishment)
        play D

    else:
        # Check if any other player cooperated in any previous round
        if there exists any player j != self and round s < t such that action_j_s == C:
            others_cooperated = True

        if others_cooperated == True:
            # Exploit cooperators by defecting
            play D

        else:
            # No cooperation seen so far; defect to avoid losses
            play D
```

---

## Explanation of Decision Rule

- **Round 1:** Defect to avoid being sucker.
- **Rounds 2 to r-1:** 
  - If anyone cooperated before, defect to exploit them.
  - Else defect as no incentive to cooperate.
- **Round r (last round):** Always defect because no future punishment.

This is **fully aggressive**, never cooperates, exploits unconditional cooperators, and leverages rational backward induction on last round.

---

## Why This Is Aggressive

- Never initiates cooperation, denying gains from costly cooperation.
- Always exploits cooperators if detected.
- Does not forgive past defects or cooperate to achieve mutual benefit.
- Maximizes private payoff given the payoff matrix and game theory logic.
- Ensures no loss in last round by always defecting.
  
---

## Pseudocode Summary

```python
def aggressive_strategy(history, current_round, r, n):
    # history: list of previous round actions, each is list of length n, elements 'C' or 'D'
    # current_round: int
    # r: total rounds
    # n: number of players
    
    # If first round, defect
    if current_round == 1:
        return 'D'
    
    # Last round, always defect
    if current_round == r:
        return 'D'
    
    # Check if anyone else cooperated previously
    for past_round in history:
        for i, action in enumerate(past_round):
            if action == 'C' and i != self_index:
                return 'D'  # Exploit cooperators
    
    # No cooperators observed, defect
    return 'D'
```

---

### Additional Note

- Since you never cooperate, you never become a "sucker".
- You earn:
  - If all defect: π_i = 1 (from keeping endowment, no public good)
  - If some cooperate others exploit, defectors earn more than cooperators
- Over repeated rounds, this strategy tries to maximize your total payoff at others' expense.

---

**Summary:**

**Always defect, except be sure to do so from round 1 and particularly in the last round, exploiting any observed cooperators.** This is the maximally aggressive stance in this public goods repeated game context.
'''

description_AGGRESSIVE_40 = '''
Here is an **aggressive strategy** for the N-Player Public Goods Game that aims to maximize individual payoff by aggressively exploiting cooperators while minimizing losses to defectors. The core idea is to defect by default but exploit opportunities to punish or exploit others when beneficial.

---

## Strategy Intuition (Aggressive Mindset)

- **Defect by default** to maximize private payoff and exploit cooperators.
- **Punish cooperators selectively** only if cooperating is warranted to keep exploitability high.
- **Exploit any cooperating players fully** when they appear.
- In the **last round, always defect** because there's no future retaliation.

---

## Formal Description

### High-Level Logic

1. **Round 1 (No history)**: Defect to avoid being exploited.
2. **Middle rounds (2 to r-1)**: 
   - If a majority cooperated in the previous round, defect to exploit cooperation.
   - If few or no cooperated last round, defect to avoid loss.
   - If specific players are repeatedly cooperating, target them by defecting.
3. **Last round (round r)**: Always defect (no incentive to cooperate).

---

### Variables and Observations

- `t`: current round (`1 ≤ t ≤ r`)
- `history[t-1]`: actions of all players in previous round (except round 1)
- `cooperator_count(t)`: number of cooperators in round `t`
- `threshold`: proportion of cooperators defining "majority" (set at 50%)
- `player_i_action(t)`: your action at round `t`
- `repeat_cooperators`: set of players who cooperated in last few rounds (> 1 round) to identify exploitable targets

---

### Pseudocode

```
Initialize:
  repeat_cooperators = empty set
  threshold = 0.5  # majority threshold

For each round t in 1 to r:
  
  If t == 1:
    # No history, defect by default to avoid exploitation
    action = D

  Else if t == r:
    # Last round, defect to maximize private payoff, no future repercussions
    action = D

  Else:
    previous_round = history[t-1]
    coop_count = count_C(previous_round)
    coop_proportion = coop_count / n
    
    # Identify players who cooperated for multiple rounds to keep track of exploitable cooperators
    for each player j in 1..n:
      if player j cooperated last round and cooperated round t-2 (if t > 2):
        add player j to repeat_cooperators
      else:
        remove player j from repeat_cooperators if present

    # Aggressive behavior:
    # - If majority cooperated last round, defect to exploit them.
    # - If minority cooperated, defect to maintain higher private payoff.
    # - If there are repeater cooperators, defect to punish and exploit.
    
    if coop_proportion > threshold or repeat_cooperators is not empty:
      action = D  # Always defect to exploit cooperators
      
    else:
      # If no clear majority cooperation, defect anyway (always defect)
      action = D

  Execute action
```

---

### Explanation

- **Always defect**: The strategy never cooperates, thus maintaining an aggressive stance.
- **Tracking repeat cooperators**: Aggressively exploits those who cooperate multiple rounds by consistently defecting against them to maximize payoff.
- **Majority cooperation detection**: The strategy does not hesitate to defect even if many cooperate, thereby exploiting them fully.
- **No cooperation incentives**: The strategy never attempts cooperation or forgiveness, which aligns with an aggressive mindset.
- **Last round defection**: Defects in the last round to capture maximum payoffs without fear of retaliation.

---

### Summary

| Round        | Decision logic                     | Intended effect                    |
|--------------|----------------------------------|----------------------------------|
| 1            | Defect                           | Avoid exploitation early          |
| 2 to r-1     | Defect, exploit cooperators      | Maximize payoff vs. cooperators   |
| Last (r)     | Defect                           | No incentive to cooperate         |

---

This strategy maximizes aggressive exploitation of cooperators, eschews any costly cooperation, and is robust to all opponent behaviors, conforming strictly to an aggressive mindset.
'''

description_AGGRESSIVE_41 = '''
Below is an aggressive strategy tailored to the specified N-player repeated public goods game. It focuses on maximizing individual payoff by defecting as much as possible while exploiting cooperators, using a conditional approach to punish cooperators to discourage their exploitation of aggressive play.

---

### Strategy Name: Aggressive Exploiter

---

### Intuition

- **Aggressive mindset:** Seek to maximize individual payoffs by defecting whenever beneficial.
- **Exploit cooperators:** When others cooperate, defect and reap higher payoffs.
- **Tit-for-tat style punishment of defectors who cooperate too much:** If others cooperate consistently and benefit, punish by defecting more aggressively.
- **Avoid being suckered:** Do not cooperate first; only cooperate if a clear strategic incentive appears.
- **Last round defection:** Defect in the last round since no future retaliation is possible.
- **Minimal cooperation elsewhere:** Cooperate only as an exploitive gesture to maintain some cooperation in others if it benefits long-term payoffs in multi-round contexts (rarely).

---

### Key Properties

- **First round:** Defect unconditionally (establish aggressive stance).
- **Middle rounds:** Defect unless there is clear evidence that cooperating will boost future cooperation and overall payoff.
- **Last round:** Defect unconditionally (standard backward induction).
- **Memory:** Track the number of cooperators in previous rounds to decide whether to punish.
- **Punishment:** Defect if many players cooperated last round, exploiting cooperators.
- **Occasional cooperation:** Only if it leads to a higher expected payoff by triggering cooperation among others.

---

### Pseudocode

```python
Inputs:
    n  # number of players
    r  # number of rounds
    k  # multiplication factor (1 < k < n)
    
Variables:
    history = []  # list of tuples (c_vector) from previous rounds, c_vector[i] in {0,1}
    
Parameters:
    coop_threshold = max(1, int(0.5 * n))  # threshold number of cooperators considered "many"

DecisionFunction(current_round, history):

    if current_round == 1:
        # First round: defect aggressively
        action = D    # do not cooperate
    
    elif current_round == r:
        # Last round: defect, no future retaliation
        action = D
    
    else:
        # Analyze last round cooperation level
        last_round = history[-1]
        total_cooperators_last = sum(last_round)
        
        if total_cooperators_last >= coop_threshold:
            # Many cooperators last round -> exploit by defecting
            action = D
        
        else:
            # Few cooperators last round
            # Optional: cooperate if only small fraction cooperated (to induce cooperation)
            # But being aggressive: mostly defect
            
            # Compute expected payoff cooperating:
            # If cooperators are few, cooperating might increase payoffs next round,
            # but can be exploited by defectors -> risky
            
            # To maintain aggressiveness, defect here
            action = D
    
    return action
```

---

### Explanation

- **First round defect:** Start aggressively with defection to avoid being taken advantage of.
- **Punish cooperation after it happens:** If many cooperators exist, exploit them by defecting.
- **Defect last round:** No incentive to cooperate at end.
- **No unconditional cooperation:** Cooperation is too risky; aggressive maximization means defect except to exploit.
- **coop_threshold = ~50% of players:** Defines when to view cooperation as "many" vs "few."
- **No complex coordination or signaling:** Only uses observable history and parameters, fits game assumptions.

---

### Additional Notes

- **Why not cooperate ever?** Pure defection yields payoff 1 + (k/n) × total_cooperators, so defecting reaps benefits from cooperators.
- **Punishment:** By defecting when many cooperate, the strategy punishes cooperators, discouraging exploitation.
- **No forgiveness cycle:** Strategy keeps defecting, embodies aggressive stance.
- **Risk:** This strategy may lead to "all defect" equilibrium, but this is consistent with maximizing immediate payoffs aggressively.

---

If you want, you may add small stochastic cooperation to test above, but for pure aggression, this deterministic defect-based approach is sound for maximizing individual payoff from a self-interested aggressive perspective.
'''

description_AGGRESSIVE_42 = '''
Here is an **aggressive strategy** designed for the repeated N-player Public Goods Game under the given rules and assumptions.

---

## Strategy Name: **Defect-First Exploitative (DFE)**

### 1. Intuition and Rationale (Aggressive Mindset)

- The main leverage comes from defecting to maximize private payoffs constantly.
- Cooperating first round gives away potential advantage without return, so start by defecting.
- Exploit cooperative players *if any* appear, by continuing to defect and maximizing private payoff.
- Punish/warn cooperators by defecting aggressively to deter free-riding.
- Since players gain only (k/n)*#cooperators from public good, defectors can free-ride on cooperators but still keep the endowment.
- Do **not** cooperate to avoid helping others; be opportunistic and greedy.
- Because the game has multiple rounds, and defection is dominant in stage games, the strategy does **not** try to establish cooperation.
- On the last round, the incentive to cooperate disappears entirely, defect still dominates.

---

### 2. Decision Rules

**Notation:**

- Let t = current round (1 ≤ t ≤ r)
- Let H_(t-1) = history of all players' past actions before round t
- Let c_j,t = 1 if player j cooperated at round t, else 0

---

#### Decision Rule (for player i at round t):

```
If t == 1:
    Play D  # defect first round to gain maximal private payoff and reveal cooperation tendencies of others

Else:
    # Count total cooperators in last round (t-1):
    coop_last_round = sum_{j=1 to n} c_j,t-1

    # If anyone cooperated last round:
    if coop_last_round > 0:
        Play D  # exploit cooperators by defecting

    else:
        # No cooperators last round => everyone defected
        Play D  # keep defecting, no incentive to cooperate
```

---

### 3. Handling Edge Cases

- **First round (t=1):** Defect unconditionally to maximize immediate payoff and to test others.
- **Middle rounds (1 < t < r):** Always defect, exploiting any cooperators that appear.
- **Last round (t=r):** Defect as there is no future retaliation possible; defecting maximizes final payoff.

---

### 4. Additional Remarks

- This strategy does not attempt to cooperate or punish beyond defecting.
- It is purely aggressive: never contributes, always defects.
- It extracts maximum private payoff by free riding on cooperators.
- It does not seek cooperation or long-term trust, as the game incentives favor defection.
  
---

### 5. Pseudocode Summary

```python
def DFE_strategy(t, history, player_index):
    """
    t: current round (1-indexed)
    history: dict mapping round -> list of player actions (C or D)
    player_index: index of this player (1-based)
    """
    if t == 1:
        # First round: defect
        return 'D'
    else:
        # Count cooperators last round
        last_round_actions = history[t - 1]
        coop_count = sum(1 for action in last_round_actions if action == 'C')
        if coop_count > 0:
            # Cooperators present last round: exploit by defecting
            return 'D'
        else:
            # No cooperators last round: no incentive to cooperate
            return 'D'
```

---

# Summary

This **Defect-First Exploitative (DFE)** strategy is aggressively selfish and exploits any cooperation of others. It defects every round, beginning immediately in round 1, without remorse or cooperation attempts, maximizing short-term gains and exploiting the public good environment. This fits the "aggressive" label perfectly in the repeated Public Goods Game context.
'''

description_AGGRESSIVE_43 = '''
Below is a design for an **aggressive** strategy in this n-player repeated Public Goods Game, with detailed decision rules and handling of edge cases. The core mindset of the strategy is to maximize own payoff by exploiting cooperators aggressively, never cooperating unless forced, and punishing any cooperating players brutally to deter their behavior. This strategy assumes rational opponents but makes no normative assumptions about cooperation or fairness.

---

## Aggressive Strategy Description

### Intuition

- **Aggression** means maximizing my own payoff relative to others at every round.
- Since k < n but k > 1, contributing (cooperating) benefits everyone but is costly to me individually.
- Defecting while others cooperate gives me the highest payoff.
- Cooperating to sustain mutual cooperation requires trust and risk; aggressive strategy distrusts others and exploits.
- Punishing cooperation by defecting and achieving higher payoffs than cooperators aggressively disincentives cooperation.
- Since game is repeated, can exploit knowledge from past action profiles.
- Final round: Cooperation no longer incentivizes reciprocation -> standard defection.
- Initial behavior: Assume defection, exploit cooperators if any.

---

### Key Points

- **Always defect**, unless I detect no incentive for others to cooperate any further (no one cooperating), or forced to cooperate in a "punishment reset" stage.
- If others cooperate repeatedly, exploit them by continuing to defect, securing higher payoffs.
- Monitor who cooperates to determine if cooperation is emerging; exploit immediately.
- If full defection by all players stabilizes, keep defecting (Nash equilibrium).
- If a player tries to punish defectors by cooperating, retaliate aggressively to prevent cooperation gains.
- Will not try to cooperate first round or last round.
- Can tolerate random cooperation by others and free ride on it.
- No forgiveness; persistent defection ensures exploitation is sustained.

---

### Decision Rules

Let:

- `history` = list of all previous rounds, each with all players' actions
- `t` = current round (1-indexed)
- `my_index` = my player index in {1,...,n}

Define helper variables:

- `cooperators_last_round` = number of players who played C in previous round
- `i_cooperated_last_round` = did I cooperate last round?
- `cooperators_all_previous` = total number of players who ever cooperated in past rounds (aggregate or at least appeared)

---

### Pseudocode

```
FUNCTION decide_action(history, t, my_index, n, r, k):

    IF t == 1:
        // First round: no history available.
        // Aggressive: defect and exploit any naive cooperation.
        RETURN D

    ELSE IF t == r:
        // Last round:
        // No incentive to cooperate (no future punishment for defect).
        RETURN D

    // For rounds 2 to r-1:

    previous_actions = history[t-1]  // actions of all players in previous round
    cooperators_last_round = count of players with action C in previous_actions
    i_cooperated_last_round = (previous_actions[my_index] == C)

    // If nobody cooperated last round, cooperation likely dead, so never cooperate:
    IF cooperators_last_round == 0:
        RETURN D

    // If some players cooperated last round:
    /*
    - Continue defecting to exploit cooperators
    - Aggressively profit from others cooperating
    */

    RETURN D
```

---

### Explanation of Behavior

- **First round:** Defect to maximize immediate payoff; no trust to cooperate.
- **Intermediate rounds:** If anyone cooperated last round, exploit by defecting.
- **If no cooperators last round:** Cooperation likely dead, keep defecting.
- **Last round:** Defect since no future incentive to cooperate.
- Always defect implies "aggression": free riding on others, punishing cooperators implicitly.
- Don't waste endowment contributing to public good — others’ cooperation increases your payoff via multiplication factor.
- This aggression deters others from sustained cooperation because they get exploited.

---

### Edge Cases

- If all defect every round, get payoff = 1 every round; stable but low.
- If some cooperate, gain more; defectors get payoff > cooperators.
- If all cooperate, defecting player gains highest payoff, but since everyone is aggressive, cooperation unlikely.
- No forgiveness or switching to cooperate to try to sustain cooperation.
- No dependence on complex beliefs or conjectures — purely reactive to last round's cooperation.
- No signaling or communication means no lasting cooperation can be trusted.

---

### Summary

This strategy is an **always-defect (ALLD)-style aggressive free rider** which:

- Defects every round.
- Exploits cooperators.
- Punishes cooperation by never reciprocating.
- Ends with defection.
- Maximally aggressive given the game structure.

---

If you want a more sophisticated variant (e.g., triggering minimal cooperation under special conditions), let me know. But for pure aggression, this simple rule is optimal.

---

# Final Strategy Recap

| Round        | Condition                   | Action  |
|--------------|-----------------------------|---------|
| 1            | Always (no history)          | Defect  |
| 2 ... r - 1  | If any cooperative player last round | Defect  |
| 2 ... r - 1  | Else (no cooperators last round)      | Defect  |
| r (last round) | Always                      | Defect  |

**This strategy never cooperates and exploits cooperators aggressively to maximize own payoffs.**
'''

description_AGGRESSIVE_44 = '''
Here is an **aggressive strategy** tailored to the N-Player Public Goods Game you described. The key idea is to maximize individual payoff by exploiting cooperators and punishing defection only minimally, with a bias towards defecting to avoid being exploited yourself.

---

## Aggressive Strategy: "Defect-First Exploit"

### Intuition
- Always defect unless strong evidence suggests cooperating yields higher payoffs.
- Exploit cooperators while punishing persistent defectors very lightly, since mutual defection still yields a secure baseline payoff.
- Avoid unreciprocated cooperation.
- Defect near the end where exploitation opportunities are maximal and retaliation is ineffective.

### Decision Rules

| Round | Rule                                                                                  |
|-------|---------------------------------------------------------------------------------------|
| t=1   | Defect (D) unconditionally — test the field, avoid being exploited first round       |
| 2 ≤ t < r | Observe how many cooperated last round (total_cooperators)                         |
|       | If (`total_cooperators` ≥ ceil(n/2)) and **last round your payoff < 1.0**, cooperate (C) to try to exploit their goodwill                       |
|       | Else defect (D)                                                                       |
| t = r | Defect (D) unconditionally (last round, no future retaliation possible)               |

---

### Explanation for Each Decision:

- **Round 1 Defect:** Start aggressively, do not pay cost of cooperation without any reciprocation guarantees.
- **Intermediate Rounds:**  
  - If many cooperated previously (majority cooperation), attempt cooperation **only** if you suffered low payoff (< 1.0, indicating you defected but got poorly rewarded → cooperators didn't sufficiently compensate you or defected aggressively).  
  - This is an opportunistic attempt to gain from cooperators by cooperating yourself, hoping others continue cooperation (exploiting cooperative clusters).  
  - Otherwise, defect since paying cooperation cost without sufficient collective cooperation is wasteful.
- **Last Round Defect:** Endgame defection to maximize final round payoff and exploit cooperators who still cooperate (no punishment possible after last round).

---

## Pseudocode

```
Inputs:
- n: number of players
- r: total rounds
- k: multiplication factor
- t: current round (1,...,r)
- history: matrix of previous rounds actions (shape r-1 x n), if t > 1
- last_round_payoffs: vector of payoffs from t-1, if t > 1

Function decide_action(t, history, last_round_payoffs):
    if t == 1:
        return 'D'  # Defect first round always

    total_cooperators = count_cooperators(history[t-2])  # previous round cooperators count

    if t == r:
        return 'D'  # Last round defect unconditionally

    my_last_payoff = last_round_payoffs[self_index]

    # If majority cooperated last round and my payoff was low
    if total_cooperators >= ceil(n / 2) and my_last_payoff < 1.0:
        return 'C'  # Exploit cooperators for higher share
    else:
        return 'D'
```

---

## Edge Cases & Notes

- **When many cooperate but you earned good payoff (>1), keep defecting** to maximize private gain.
- **If no one cooperates ever, always defect**—there is no benefit in cooperating.
- **If cooperation fluctuates**, cooperate only when a strong majority has cooperated last round and you are currently losing out (payoff < 1).
- The payoff threshold 1.0 is chosen because unilateral defection in a sea of defectors yields payoff 1, so cooperating must outperform that to be worth it.
- Strategy is aggressive because:
  - Starts defecting immediately,
  - Only cooperates when it can exploit a cooperative majority and when personal payoff is poor,
  - Defects last round to secure final payoffs,
  - Minimally punishes defectors or attempts to sustain cooperation otherwise.

---

If your goal is purely maximizing individual gain and punishing unreciprocated cooperation, this approach balances exploitation and opportunism with minimal trust. It will "beat" naive cooperators and avoid being exploited much by defectors, focusing on personal aggressive profit.
'''

description_AGGRESSIVE_45 = '''
Here is an aggressive, self-maximizing strategy for the repeated N-player Public Goods Game that exploits cooperation by others but defects as much as possible to maximize personal payoff.

---

### Strategy Overview

- **Aggressiveness Goal:** Maximize own payoff by defecting as often as possible without triggering universal defection that collapses payoffs below 1.
- **Exploitation:** Take advantage of cooperators by defecting when others cooperate to earn high payoffs.
- **Punishment:** Punish persistent defectors mildly by cooperating occasionally but avoid being suckered into cooperating unconditionally.
- **First round:** Defect to test others.
- **Last round:** Defect, as no future retaliation is possible.
- **Intermediate rounds:** Exploit cooperators, but punish universal defection by cooperating once periodically to keep payoff > 1 if possible.

---

### Intuition / Justification

- Defecting always yields at least payoff 1 (private endowment).
- Cooperating costs 1 unit, but returns (k/n) × number_of_cooperators.
- Since k < n, full defection payoff = 1.
- If many cooperate, defectors do better and cooperators suffer.
- In general, defecting ensures baseline payoff and exploits cooperation.
- If everyone defects, payoff = 1.
- Cooperating unconditionally risks losing payoff or invites exploitation.
- A mild trigger/punishment prevents universal defection collapse by occasionally cooperating to induce at least some public good provision (for example, to maintain an average payoff > 1 over repeated rounds).
- Aggressively defecting is the baseline, with opportunistic cooperation only to prevent collective payoff collapse.

---

### Decision Rules

Let:

- t = current round (1 to r)
- H_{t-1} = history of all players’ actions in previous rounds
- c_j^t = action (0 or 1) of player j in round t

Define:

- cooperator_count_{t-1} = number of players cooperating in round (t-1)

---

#### Pseudocode for round t action:

```
if t == 1:
    # First round, no history: Defect aggressively to test others
    action = D

elif t == r:
    # Last round: defect, no future punishment possible
    action = D

else:
    # Intermediate rounds (2 ≤ t ≤ r-1)
    # Observe last round
    
    coop_last_round = cooperator_count_{t-1}

    if coop_last_round == 0:
        # Everyone defected last round; mutual defection baseline
        # Push to defect to maximize own payoff (1)
        action = D

    else:
        # There was cooperation from others
        # Aggressively defect to exploit cooperators
        
        # However, if previous rounds saw continuous universal defection
        # or cooperation collapse, cooperate once every 5 rounds to nudge up payoff
        # This avoids payoff falling below 1 in long run.
        
        if (t % 5 == 0):
            # Cooperate occasionally as a "punishment test" or signal to potentially induce cooperation
            action = C
        else:
            action = D
```

---

### Explanation

- **Round 1:** Defect to gain private payoff, see if anyone cooperates.
- **Last round:** Defect as no repercussions.
- **Between rounds:** Defect to exploit cooperators (maximize payoff when cooperators exist).
- If no cooperators last round (everyone defected), keep defecting.
- To avoid long-term collapse of cooperation and stuck at payoff=1, cooperate every 5th round to signal willingness to cooperate briefly.
- This occasional cooperation is minimal, maintaining aggressive defecting majority yet trying to leverage any responsive cooperative players to increase payoff.
- This pattern stays aggressive but flexible to exploit cooperators while punishing defectors.

---

### Summary

| Round         | Condition                           | Action             |
|---------------|------------------------------------|--------------------|
| 1             | No history                        | Defect             |
| r (last round)| End of game                      | Defect             |
| 2..r-1        | No cooperators last round          | Defect             |
| 2..r-1        | Cooperators exist last round       | Defect except every 5th round cooperate |

---

This strategy is aggressive: it never leads by cooperating unprovoked, exploits cooperators ruthlessly, defects last round, but occasionally mixes in cooperation as a tactical probe to prevent universal defection within a long game. It balances aggressive self-interest with minimal cooperation signals to sustain higher payoffs against mixed populations.

---

If you want I can write this as more formal pseudocode or a decision-tree. Just ask!
'''

description_AGGRESSIVE_46 = '''
Here's a detailed **aggressive strategy** design for the N-Player Public Goods Game as specified, maximizing exploitative and dominant behavior over repeated rounds:

---

## Strategy Overview

- **Core Mindset:** Always exploit cooperators whenever possible. Defect by default to preserve your private endowment.
- **Conditional Cooperation:** Only cooperate if cooperation can be guaranteed or strategically forced by behavioral cues (which are very weak because no communication and no coordination), else defect aggressively.
- **Punishment:** Use defection to punish any player who tries to cooperate expecting reciprocation. However, since no communication and symmetric knowledge, punishments are mostly implicit—focus on maximizing own payoff.
- **Endgame/Last Round:** Always defect in the last round to avoid being exploited.

---

## Reasoning

- Defecting always guarantees a base payoff of 1 plus some possible benefit from others cooperating.
- Cooperating costs you 1 (your private endowment), hoping others cooperate so that (k/n) × total_cooperation > 1.
- Because \( k < n \), the social benefit of cooperation is less than keeping the endowment privately, so unilateral cooperation is strictly dominated by defection.
- In repeated rounds, cooperators can be temporarily exploited for gains; aggressive strategy maximizes defection and exploitation.

---

## Decision Rules by Round

| Round       | Decision Rule                            | Rationale                  |
|-------------|----------------------------------------|----------------------------|
| Round 1     | Defect                                | No information yet; defect to start aggressive exploitation. |
| Intermediate rounds (2 to r-1) | Defect unless all others cooperated last round, if so defect anyway | No trust — even if others cooperated last round, defect anyway to exploit them. |
| Last round (r) | Defect                              | No future punishment possible, defect to maximize own payoff. |

---

## Pseudocode

```python
def aggressive_strategy(history, round_number, total_rounds, n, k):
    """
    Parameters:
    - history: list of length round_number-1, each element is a dict {player_id: action} 
      with actions 'C' or 'D'.
    - round_number: current round (1-indexed)
    - total_rounds: total number of rounds r
    - n: number of players
    - k: multiplication factor
    
    Returns:
    - 'C' or 'D'
    """
    
    # Always defect on first round: no info available, aggressive start
    if round_number == 1:
        return 'D'
    
    # In any round before last round:
    # Analyze last round's cooperation counts to detect cooperators 
    last_round = history[-1]
    cooperators = [p for p, a in last_round.items() if a == 'C']
    
    # Aggressive logic: no cooperation, defect always to exploit cooperators
    # No incentive to cooperate since others may defect.
    # Even if all cooperated, defect anyway to gain maximal individual payoff.
    if round_number < total_rounds:
        return 'D'
    
    # Last round: defect always (no future retaliation)
    if round_number == total_rounds:
        return 'D'
```

---

## Explanation

- **First Round Defect:** No info about others; defect guarantees baseline payoff.
- **Intermediate Rounds Defect:** Even if other players cooperated, do not reciprocate—exploit them by defecting.
- **Last Round Defect:** No incentive to cooperate since no future punishment; defect to maximize last round gains.
  
Because all actions are simultaneous and independent, and cooperation yields personal cost without guarantee of reciprocation (k < n implies personal loss from cooperation unless others cooperate fully), this strategy is aggressively exploitative, seeks to maximize defect payoffs, and punishes naive cooperators by never cooperating.

---

## Summary

| Round        | Action    | Reason                                  |
|--------------|-----------|-----------------------------------------|
| 1            | Defect    | Start aggressively; no info             |
| 2 to r - 1   | Defect    | Exploit any cooperators; never cooperate|
| r (last)     | Defect    | No future rounds; secure maximal payoff |

---

This strategy is **purely aggressive**, never cooperating, thus maximizing personal payoff by free-riding on others who may cooperate. It does not attempt cooperation or conditional cooperation, given the game's incentives and no communication means.

---

If you want me to design a more nuanced or mixed aggressive strategy (e.g., grudging or conditional defection), just ask.
'''

description_AGGRESSIVE_47 = '''
Here's an **aggressive strategy** for the described N-player Public Goods Game. The design emphasizes maximization of personal payoff by exploiting cooperators and minimizing own cooperation except when strategically useful. It is aggressive in seeking to free-ride on others' cooperation while punishing naive cooperators, and exploits the last round to defect.

---

## Aggressive Defector Strategy ("AggroFreeRider")

### Intuition
- Defect by default to maximize immediate private payoff.
- Cooperate only to manipulate others into cooperating (exploit occasional cooperation).
- Punish any sign of cooperation by others by defecting always.
- Exploit the last round by defecting to avoid being exploited.
- No forgiveness or generosity; no cooperation if opponents don't consistently cooperate (never initiate cooperation).
- Use history of group cooperation to decide minimal cooperation to trigger exploitation, but only if beneficial.

---

### Decision Rules

1. **Round 1 (First Round):**
   - **Defect (D)** unconditionally.
     - Reason: No history yet, no incentive to risk cooperation.
   
2. **Rounds 2 to r-1 (Intermediate Rounds):**
   - Observe history of rounds 1 to t-1:
     - Count how many players cooperated in previous round t-1.
     - If a **significant minority cooperated** in previous round (at least one player cooperated), **defect (D) to exploit.**
       - Rationale: Exploit cooperators by defecting while others contribute.
     - Else (if all defected last round), **attempt a minimal, one-round, isolated cooperation in current round only if it likely triggers cooperators next round**, else defect.
       - Minimal cooperation is risky, only used if previous rounds show occasional cooperation (rare case, mostly defect).
   
3. **Round r (Last Round):**
   - **Defect (D) unconditionally.**
     - Reason: No future punishment possible, so maximize private payoff.

---

### Pseudocode

```python
def aggro_free_rider_strategy(round_t, r, n, history):
    # history is a list of lists: each inner list is [actions of players in round t-1]
    # current_player index is known; in design assume self index passed if needed
    
    if round_t == 1:
        # No history, defect
        return 'D'
    
    if round_t == r:
        # Last round, defect
        return 'D'
    
    # For rounds 2..r-1:
    last_round_actions = history[-1]  # actions of all players last round
    total_cooperators_last_round = sum(1 for a in last_round_actions if a == 'C')
    
    if total_cooperators_last_round > 0:
        # Some cooperators last round -> exploit by defecting
        return 'D'
    else:
        # All defected last round: consider cooperation to try provoke cooperators (aggressive bluff)
        # But to remain aggressive, only cooperate sporadically if last cooperation was recent and rare
        # For simplicity, defect always here (no incentive to initiate cooperation)
        return 'D'
```

---

### Detailed Explanation of Aggressiveness

- **Never cooperate first:** Aggressively avoids any upfront risk that reduces immediate payoff.
- **Exploit cooperators:** Defects whenever others cooperate, maximizing personal payoff.
- **No forgiveness:** Does not reward cooperation by others with own cooperation, discouraging cooperation.
- **No cooperation in final round:** Since no punishment is possible, always defect to maximize payoffs.
- **Minimal cooperation attempts abandoned:** To remain aggressive and simple, does not attempt to build cooperation cycles, eliminating exploitation risk.
- **Signal independence:** By always defecting except exploiting occasional cooperators, forces others to bear the cost of cooperation.

---

## Summary

| Round     | Condition                          | Action  | Reason                                    |
|-----------|----------------------------------|---------|-------------------------------------------|
| 1         | No history                       | Defect  | No incentive for risk                     |
| 2 to r-1  | Any cooperators last round       | Defect  | Exploit cooperators                       |
| 2 to r-1  | No cooperators last round        | Defect  | No incentive to initiate cooperation     |
| r (last)  | Any                             | Defect  | No future rounds to punish defection     |

---

This strategy aggressively seeks to maximize private payoffs by riding on others' cooperation without sharing the cost itself and punishes cooperation by others through consistent defection. It is fully aligned with an aggressive mindset: exploitative, uncooperative, and maximizing selfish gains within the known game-theoretic framework.
'''

description_AGGRESSIVE_48 = '''
Below is an **aggressive strategy** for the N-Player Public Goods Game, designed to maximize personal payoff by exploiting cooperators while punishing defectors, and never willingly sacrificing short-term gain.

---

## Aggressive Strategy: "Exploit and Punish with Last-Round Defection"

### Intuition:
- **Always defect initially** to gain the private payoff advantage.
- **Exploit cooperators** who decide to contribute by defecting against them as long as they cooperate.
- If others retaliate (defect), punish them with continued defection.
- On the **last round**, **defect regardless** to maximize immediate payoff, as there's no future incentive for cooperation.
- Never cooperate first or to build cooperation—only adapt defensively to punish.

---

### Pseudocode Description

Let `round` be the current round number, 1 ≤ round ≤ r.

Let `actions_history` be a record of all players’ actions in previous rounds (each round’s vector of C/D).

Let `my_index` be this player's index.

---

```
Function decide_action(round, actions_history, my_index):
    # Last round: Always defect
    if round == r:
        return D
    
    if round == 1:
        # Initial round: Always defect to exploit
        return D

    # Count how many times each opponent cooperated in past rounds
    # and how they acted in the previous round
    last_round_actions = actions_history[round - 1]  # actions from previous round

    # Determine if any player cooperated in previous round
    anyone_cooperated_last = any(action == C for i, action in enumerate(last_round_actions) if i != my_index)

    # Determine if this player was exploited last round
    # Exploited = if I cooperated and others defected while I got low payoff
    # Since payoff info is public, but simplified here: 
    # Let's just check if I cooperated last round but others defected (majority)
    my_last_action = last_round_actions[my_index]

    if my_last_action == C:
        # I cooperated last round but others mostly defected - switch to defect to punish
        return D

    # If I defected last round, continue defecting (never cooperate voluntarily)
    # Except if everyone cooperated last round, I may consider continuing defecting to exploit
    # Since this is aggressive, we never cooperate voluntarily

    return D
```

---

### Decision Rules (Summary):

- **Round 1:** Defect to exploit naive cooperators and maximize private payoff.
- **Rounds 2 to r−1:**
  - If you cooperated last round but were exploited (others defected), defect to punish.
  - Otherwise, always defect.
- **Round r:** Always defect, no incentive to cooperate.

---

### Edge Cases:

- **First round:** No history — defect to maximize immediate gain.
- **Last round:** Defect unconditionally—no future rounds to influence cooperation.
- **If opponents start cooperating:** Exploit by defecting to earn higher payoff.
- **If opponents punish defectors by defecting:** Accept the punishment, continue defecting to minimize losses—no cooperation to rebuild.

---

### Aggression Justification:

- This strategy **never sacrifices** short-term gain by cooperating first.
- It exploits any cooperative player by defecting.
- It punish defecting opponents only if it previously cooperated and was exploited — but since it never initiates cooperation, it essentially just defects unconditionally once exploitation happens.
- Ending with defection ensures maximum short-term payoff.
- It is **unforgiving** and **non-cooperative**, focused purely on maximizing returns by aggressive exploitation and never investing in public good contributions.

---

This ensures the strategy is straightforward, aggressive, and maximally exploitative within the given game framework and information constraints.
'''

description_AGGRESSIVE_49 = '''
Below is a description of an **aggressive strategy** for the repeated N-player Public Goods Game described, with a step-by-step decision rule, rationale, and edge case handling. The strategy focuses on maximizing the player’s own payoff by exploiting cooperators rather than cooperating or attempting to sustain cooperation.

---

## Aggressive Strategy: “Defector Exploit with Conditional Defection”

### Intuition:
- Aggressive mindset means: maximize own payoff even if it reduces group welfare.
- Since defecting yields higher payoffs if others cooperate (private payoff 1 vs 0 contribution, while sharing the multiplied public good),
- The strategy tries to maximize defection while exploiting any cooperators present.
- It punishes past cooperators by defecting against them to minimize their incentive.
- It never initiates cooperation itself (no first round cooperation) to avoid free-riding costs.
- It exploits cooperation from others without reciprocating (never cooperates).
- Last round: defect, as no future retaliation is possible ("backward induction").

---

## Decision Rules

1. **Round 1 (first round):**  
   - **Action:** Defect (D)  
   - **Reason:** No history to leverage, so start by defecting immediately to gain maximal payoff.

2. **Rounds 2, ..., r-1 (intermediate rounds):**  
   - **Observe:** For all other players, examine their contributions in *previous round*.  
   - **If *any* players cooperated in the previous round:**  
     - Defect (exploit their cooperation).  
   - **Else (no cooperators previously):**  
     - Defect (maintain aggressive stance, no incentive to cooperate).  

   *Key point:* Always defect regardless of what others do, but conditionally punish if anyone cooperated last round.

3. **Round r (last round):**  
   - Defect (D)  
   - No incentive to cooperate because no future rounds — standard backward induction.

---

## Formal Pseudocode

```python
def aggressive_strategy(history, current_round, total_rounds, n, k):
    """
    history: list of length current_round-1; 
        each element is a list of length n of {C, D} actions of all players in that round
    current_round: int, 1-based
    total_rounds: int, total number of rounds
    n, k: game parameters (not strictly needed in this strategy)
    
    Returns: 'C' or 'D' for current round.
    """
    
    # Always defect in the first round
    if current_round == 1:
        return 'D'
    
    # Always defect in the last round
    if current_round == total_rounds:
        return 'D'

    # For intermediate rounds:
    # Check if any other player cooperated in previous round
    previous_round_actions = history[-1]  # length n
    # Exclude own previous action not necessary since player never cooperates

    # If any player cooperated last round, defect to exploit them
    if 'C' in previous_round_actions:
        return 'D'
    
    # No cooperators last round => defect too
    return 'D'
```

---

## Explanation & Key Properties

- **Never cooperates:**  
  Avoids the cost of contributing (which reduces private payoff by 1 unit).  
  Guarantees a 1 private payoff baseline every round + any returns from others' cooperations.

- **Always defects:**  
  Does not attempt to support or maintain a cooperative environment.

- **Exploits cooperators:**  
  If others cooperate, it gains the full private payoff plus the multiplied public good from their contributions.

- **No forgiveness or reputation building:**  
  Cooperation from others is met with defection next round to punish cooperators, discouraging sustained cooperation by others.

- **Robust to opponent strategies:**  
  Independent of what others do, the aggressive strategy always defects, maximizing personal payoff against naive cooperators.

- **Last round defect:**  
  Logical to defect in final round to avoid being exploited.

---

## Edge Case Summary

| Round            | Action                        | Reason                                                                         |
|------------------|-------------------------------|--------------------------------------------------------------------------------|
| 1 (first)        | Defect (D)                    | No history, no cooperation risk, maximize immediate payoff                     |
| 2 to r-1         | Defect (D)                    | Exploit any cooperators from previous round, never initiate cooperation        |
| r (last round)   | Defect (D)                    | No future retaliation possible, so defect to maximize final payoff             |

---

## Potential Variant (Optional)

You could optionally incorporate a "defective grudge" on cooperators in history — e.g., defect multiple rounds after seeing cooperation, but since this strategy always defects, this is redundant.

---

# Summary

This strategy is purely aggressive: **never cooperates, always defects, exploits any opponent cooperation, punishes cooperators by defecting against them immediately, and defects in the final round.** It aligns with the aggressive mindset of maximizing own payoff with no regard for group welfare or sustaining cooperation.
'''

description_AGGRESSIVE_50 = '''
Here is an **aggressive strategy** tailored for the repeated N-player Public Goods Game described, focusing on aggressive exploitation of cooperators and preemptive defection against free riders.

---

## Strategy Name: **Exploit-Aggro**

### Intuition / High-Level Description

- **Aggression:** Defect almost always to maximize immediate payoff.
- **Exploitation:** Cooperate only to exploit any unilateral cooperative attempts by others, to grab some public good share without being exploited oneself.
- **Retaliation:** If any other player tries to cooperate repeatedly, punish by persistent defection.
- **Endgame Defection:** On the last round, defect to avoid exploitation, since no future punishment is possible.
- **First Round Defection:** Defect immediately to avoid being exploited initially by naïve cooperators.
  
---

### Detailed Decision Rules

#### Notation:
- Let **t** ∈ {1,..., r} be the current round.
- Let history H_t be the actions of all players up to round t - 1.
- For player i (ourself), at round t, we decide action a_i,t ∈ {C, D}.
- Define **num_coop_others(t-1)** = total cooperators in round t-1 excluding player i.
- Define **coop_count_j** = how many times player j cooperated up to round t - 1.

---

### Rule Set:

1. **Round 1:**
   - Defect.
   - Rationale: No history, assume others may cooperate; defecting prevents initial exploitation.

2. **Rounds 2 to r - 1 (Midgame):**
   - If **any player j ≠ i cooperated in round t-1**, **cooperate once** to exploit and grab public goods.
     - i.e., if \( \exists j \neq i: a_{j,t-1} = C \)
     - Action: Cooperate
   - Else:
     - Defect.
   - However, if **any player j has cooperated 2 or more times up to round t-1**, treat them as persistent cooperators to exploit:
     - Continue **cooperating only once after their defection round**, then **revert to defecting all other times** to punish.
     - This means, if you detect persistent cooperators, you cooperate exactly once after their current cooperation, then defect to minimize their payoff.
   
3. **Round r (Last Round):**
   - Defect.
   - Rationale: No future retaliation possible, best to defect to maximize last round payoff and prevent exploitation.

---

### Summary of Behavior

- Mostly defect.
- Cooperate only immediately after seeing cooperation by others, to gain from the temporary public good created by their cooperation.
- Detect persistent cooperators and cooperate only sparingly to exploit them, then defect to minimize their gains.
- Always defect in first and last rounds unconditionally.

---

### Pseudocode

```python
def ExploitAggroStrategy(t, r, n, history, player_index):
    # history: list of rounds, each round is a list of actions {C, D} for all players
    # player_index: index of this player (0-based)
    
    if t == 1:
        # First round: always defect
        return 'D'
    
    if t == r:
        # Last round: always defect
        return 'D'

    # Count how many times each other player has cooperated so far
    coop_counts = [0]*n
    for past_round in history:
        for j in range(n):
            if past_round[j] == 'C':
                coop_counts[j] += 1
    
    # Check if any other player cooperated in previous round
    prev_round = history[-1]
    others_cooperated_prev = any(prev_round[j] == 'C' for j in range(n) if j != player_index)

    # Identify persistent cooperators: cooperated at least twice so far (excluding self)
    persistent_cooperators = [j for j in range(n) if j != player_index and coop_counts[j] >= 2]

    # Decision logic:
    if persistent_cooperators:
        # Exploit persistent cooperators selectively:
        # Cooperate only once after their cooperation round, then defect
        # Detect if any persistent cooperator cooperated in last round
        exploited_this_round = any(prev_round[j] == 'C' for j in persistent_cooperators)
        if exploited_this_round:
            # Cooperate once to grab benefits
            return 'C'
        else:
            # Otherwise defect
            return 'D'
    
    else:
        # No persistent cooperators yet
        if others_cooperated_prev:
            # Cooperate once to exploit any cooperation seen last round
            return 'C'
        else:
            return 'D'
```

---

### Why Is This Strategy Aggressive?

- **Never initiates cooperation early:** avoids being suckered.
- **Defects first and last rounds:** exploits inability of others to punish.
- **Only cooperates opportunistically, never trusting or reciprocating:** focuses on immediate gains, punishes attempts at cooperation by defecting otherwise.
- **Targets persistent cooperators and punishes them by limiting cooperation to minimal times:** uses their contribution to gain from public good without giving back.
- **Maximizes own payoffs at the expense of collective welfare.**

---

This will yield strong asymmetric advantage versus more cooperative or forgiving strategies by exploiting them maximally and defending aggressively against cooperation attempts.

If you want, I can help adapt to specific parameter values or to strengthen the ruthlessness further.
'''

description_AGGRESSIVE_51 = '''
**AGGRESSIVE STRATEGY FOR N-PLAYER PUBLIC GOODS GAME**

---

### Intuition Behind the Strategy

The aggressive strategy aims to maximize individual payoff, prioritizing exploitation of cooperators while punishing others for cooperating (to reduce free riding by others). Aggressive here means:

- **Defect by default**, to keep your endowment.
- **Punish cooperators** to discourage them from cooperating.
- Only cooperate when doing so yields better payoff by preemptively entrenching a cooperative cluster *if* this can guarantee domination and prevent exploitation in future rounds.
- In short: **Always defect, except if cooperating prevents a worse payoff due to others cooperating heavily and you can leverage group cooperation for higher returns**.
- No forgiveness or tit-for-tat: aggressive punishment with no leniency.
- Defection in the last round is guaranteed since no future incentive.

---

### Formal Decision Rules

Let:

- \(t \in \{1, \ldots, r\}\): current round
- \(H_{t-1}\): complete history of all players' actions up to round \(t-1\)
- \(c_j^{(t-1)}\): action of player \(j\) in round \(t-1\), 1 if C, 0 if D
- \(C_{t-1} = \sum_{j=1}^n c_j^{(t-1)}\): total cooperators in previous round (including self)

---

### Aggressive Strategy Description

**Round 1 (No history):**  
- Choose **D** (Defect) — aggressive exploitative start, no reason to trust others.

**Rounds 2 to r-1:**  
- Observe cooperation levels in previous round \(C_{t-1}\).

- Compute expected payoffs if you cooperate or defect this round assuming others' cooperation stays the same:

  - If **Cooperate**:  
    \[
    \pi_i^{(C)} = 0 + \frac{k}{n} \times (C_{t-1} + 1) \quad \text{(your cooperation adds +1)}
    \]

  - If **Defect**:  
    \[
    \pi_i^{(D)} = 1 + \frac{k}{n} \times C_{t-1}
    \]

- Aggressive decision:  
  - If \(\pi_i^{(C)} > \pi_i^{(D)}\), **cooperate**, but only if the **marginal gain from cooperation beats defecting**, i.e., if:

    \[
    \frac{k}{n} \times (C_{t-1} + 1) > 1 + \frac{k}{n} \times C_{t-1} \implies \frac{k}{n} > 1
    \]

    Since \(k < n\), \(\frac{k}{n} < 1\), so this **never holds**. Thus cooperation is never individually payoff-maximizing based on immediate payoffs alone.

- Since unconditional defection dominates in single-shot payoffs, the only reason to cooperate is to try to induce cooperation in others and get a higher long-term return.

- But aggressive means: **no friendly cooperation to build trust** — only cooperate if it punishes others or guarantees better payoff.

- Therefore:

  - If the **previous round had many cooperators**, defect to exploit them.  
  - If the **previous round had no cooperators**, continue defecting.

  - **If everyone else cooperated last round (i.e., \(C_{t-1} = n-1\))**, then cooperating this round yields payoff \( \pi_i^{(C)} = \frac{k}{n} \times n = k \), defecting yields \( \pi_i^{(D)} = 1 + \frac{k}{n} \times (n-1) = 1 + k \times \frac{n-1}{n} \). Because \(k < n\), compare:

    \[
    \pi_i^{(C)} = k \\[6pt]
    \pi_i^{(D)} = 1 + k - \frac{k}{n} = 1 + k - \text{small positive} > k
    \]

    So defecting is still better.

- **Conclusion:**  
  - Always **defect** in rounds 2 to r-1, aggressively exploiting any cooperators.

**Round r (Last round):**  
- Always **defect** because no future punishment/reward incentives remain.

---

### Handling Edge Cases

- **First round:** no information, defect.
- **Last round:** no future rounds, defect.
- **If all others cooperate:** exploit by defecting to get higher payoff.
- **If no cooperators:** defect to get full private endowment.
- **If some cooperate:** defect to free ride on their cooperation.
- **No forgiveness or change based on history:** Never cooperate.

---

### Summary

| Round      | Condition                          | Action |
|------------|----------------------------------|--------|
| 1          | no prior rounds                  | Defect |
| 2 to r - 1 | always                          | Defect |
| r (last)   | no incentives to cooperate      | Defect |

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, k, history):
    # t: current round (1-based)
    # history: list of lists, each inner list is actions of players in round t-1
    # Actions: 'C' or 'D'
    
    if t == 1:
        # First round: defect
        return 'D'
    
    if t == r:
        # Last round: defect
        return 'D'
    
    # For rounds 2 to r-1
    # Observe previous round cooperation counts
    prev_actions = history[t-2]  # zero-based indexing for previous round
    cooperators = prev_actions.count('C')
    
    # Always defect aggressively
    return 'D'
```

---

### Explanation

This strategy is maximally aggressive and selfish:

- No attempt to cooperate or build trust.
- Always defects to maximize individual payoff looking for free rides.
- No forgiveness or cooperation cycles.
- No wasted resources on cooperation.
- Exploits others fully if they cooperate.
- Defects in last round to maximize payoff with no future consequences.

---

### Additional Notes

- Even though cooperation \(C\) could yield higher *group* payoffs, this aggressive strategy never sacrifices private gain for collective benefit.
- This strategy is robust against exploitation by cooperators and tries to punish any cooperation by not reciprocating.
- It will perform well if opponents try cooperation strategies but will fail to benefit if all defect ultimately.
- It's an "always defect" approach, aligned perfectly with an aggressive, exploitative mindset.

---

If you want a more nuanced aggressive strategy that tries to punish cooperators by defecting after detecting cooperation but cooperates occasionally to lure cooperation and then exploits it, please ask—this base version is simplest and guaranteed maximally aggressive.
'''

description_AGGRESSIVE_52 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Strategy Intuition and Goals

- **Aggressive mindset:** maximize own payoff at the risk of provoking others, disrupt cooperation, and exploit cooperators.
- **Main idea:** Defect by default to secure the private payoff of 1; cooperate only if it yields a strictly better expected return based on observed cooperation from others.
- **Punishment:** Never be suckered by cooperating when others defect; punish defections harshly if cooperation is attempted by some.
- **Last round:** Since no future retaliation is possible, defect unequivocally to maximize last-round payoff.
- **Exploit cooperators:** If others tend to cooperate, defect to gain an immediate advantage.

---

### Key Observations

- Defecting yields an immediate private payoff of 1.
- Cooperating yields zero private payoff but potentially higher return from multiplication if many cooperate.
- When k < n, full cooperation yields everyone a payoff > 1.
- Partial defection patterns can allow defectors to earn more than cooperators.
- Aggression means avoiding exploitation and capitalizing on others’ cooperation without concern for group welfare.

---

### Pseudocode Description

```
Input: 
- n: number of players
- r: total rounds
- k: multiplication factor
- history: list of tuples of all players' actions for previous rounds

Strategy for round t in {1 .. r}:

1. If t == r:    # Last round
      Action := D  # Always defect in the last round

2. Else if t == 1:  # First round, have no information
      Action := D   # Defect initially to avoid being exploited

3. Else:  # From round 2 to r-1, use history to decide

    # Compute number of cooperators in previous round 
    prev_round = history[t-1]
    total_cooperators = count(C in prev_round)

    # Expected payoff if cooperate this round given prev cooperation:
    # Payoff_C = 0 (private) + (k/n) * (expected_cooperators)
    # Expected payoff if defect this round:
    # Payoff_D = 1 (private) + (k/n) * (expected_cooperators)

    # Assume others’ behavior stable from prev round: 
    expected_cooperators = total_cooperators

    # Consider if your own cooperation added last round:
    # Check if cooperating last round was clearly exploited:
    # If you cooperated last round but your payoff was <= 1, you were exploited.

    my_action_prev_round = history[t-1][my_index]
    my_payoff_prev_round = (1 - (1 if my_action_prev_round == C else 0)) + (k/n)*total_cooperators

    # Decision rules:
    if my_action_prev_round == C and my_payoff_prev_round <= 1:
        # Exploited last round: revert to defecting aggressively
        Action := D
    else:
        # Estimate payoffs this round if cooperate or defect
        payoff_if_cooperate = (k/n) * (expected_cooperators + 1)  # because you cooperate this round
        payoff_if_defect = 1 + (k/n) * expected_cooperators       # because you defect this round

        if payoff_if_cooperate > payoff_if_defect:
            # Cooperation can yield strictly more payoff this round, take it aggressively
            Action := C
        else:
            # Defect otherwise to maximize private payoff
            Action := D
```

---

### Explanation of the Above Rules

- **First round:** Defect because your cooperation risks exploitation; no info yet.
- **Last round:** Defect always to maximize guaranteed private payoff; no future retaliation.
- **In between rounds:**  
  - If you were exploited last round (cooperated but payoff ≤ 1), switch to defect and punish.
  - Else, cooperate **only if** cooperating this round offers strictly higher expected payoff.
  - "Expected cooperation" is assumed to be equal to observed cooperation last round (naive assumption).
- This causes:
  - Exploiters who defect gain advantage.
  - Cooperators only get sympathy/cooperation if cooperation pays off.
  - The strategy aggressively defects against exploiters and rarely cooperates.
- No trust or goodwill assumed; cooperation only when personally beneficial.
- Opponent behaviors are unknown; this aggressively leans toward defect unless clear benefit.

---

### Edge Case Handling

- **If all defect last round:** expected_cooperators = 0 → cooperating yields payoff 0, defecting yields 1 → defect again.
- **If all cooperate last round:** expected_cooperators = n → cooperating yields k > 1, defecting yields 1 + (k/n)*(n-1) = 1 + k(1 - 1/n)  
   Since k < n, defecting yields strictly higher payoff in mixed groups → defect to exploit.
- **If mixed cooperation last round:** cooperate only if payoff strictly better by cooperating.
- **If exploited (cooperated last round but payoff not >1):** defect aggressively thereafter.

---

### Summary

- **Default**: Defect.
- **Cooperate only if:** cooperation now yields strictly higher payoff than defecting given estimated cooperation level.
- **Punish exploitation:** if you cooperated but gained ≤ payoff from defectors, switch permanently to defection.
- **Last round:** defect with certainty.

This is a straightforward aggressive strategy leveraging payoff incentives and punishing cooperation failures without generosity or forgiveness. It prioritizes individual gain and exploitation of cooperating opponents.

---

If you want, I can help formalize this further or explain potential improvements.
'''

description_AGGRESSIVE_53 = '''
Below is a fully specified aggressive strategy for the repeated N-player public goods game as described.

---

## Aggressive Strategy: "Defect-Exploit-All"

### Intuition
This strategy is **aggressive** in that it seeks to maximize individual payoff **by defecting as much as possible while exploiting cooperating players**. It does **not** cooperate voluntarily but will defect continuously to maximize private payoff. It exploits cooperators by free-riding on their contributions without contributing itself.

- Cooperators pay 1 unit cost to contribute but share the public good multiplied by factor k.
- Defectors pay no cost but still gain a share of the cooperators' contributions.
- Since k < n, a defector who defects while others cooperate often gains more than cooperators.
- This strategy never “wastes” money by cooperating.

### Key decision rules
1. **First round:** Defect (no information yet, be aggressive immediately).
2. **Subsequent rounds:** If at least one other player cooperated in the previous round, continue defecting and exploit them.
3. Even if all defected previously, continue defecting (never cooperate).
4. Because the game has multiple rounds and no communication, no incentive to cooperate for reciprocity or reputation here when being aggressive.
5. In last round, defect to maximize payoff (no future punishment).

---

### Pseudocode

```python
# Parameters known: n, r, k
# History stores arrays of length t-1 of player actions each round:
# history[t-1] = [action_p1, action_p2, ..., action_pn] for round t-1
# Actions: 'C' for cooperate, 'D' for defect

def aggressive_strategy(player_index, round_t, history):
    # Round 1: always defect aggressively
    if round_t == 1:
        return 'D'

    # Extract previous round actions
    prev_round = history[round_t - 2]  # zero-indexing: round 1 actions at history[0]
    
    # Check if any other player cooperated last round (excluding self)
    others_cooperated = any(prev_round[j] == 'C' for j in range(len(prev_round)) if j != player_index - 1)

    if others_cooperated:
        # Exploit cooperators by defecting
        return 'D'

    # No one cooperated last round
    # Keep defecting aggressively
    return 'D'
```

---

### Explanation

- **Defect from start and all rounds:** This maximizes your payoff against cooperators by free-riding and yields a guaranteed baseline payoff of 1 + (k/n) * (number of cooperators).
- **When others cooperate:** Leverage their contributions; defect to maximize your private gains.
- **If no cooperators:** Everyone defects; cooperate would lower your payoff.
- **No cooperation ever:** Aggression means not paying the cost for the public good.

---

### Edge cases

- **First round:** Defect immediately, as no information exists and aggressive approach benefits from free-riding.
- **Last round:** Same as all rounds since no future rounds for punishment or reward. Always defect.
- **All defecting opponents:** Keep defecting to ensure no worse payoff than cooperating.
- **In the unlikely case you see self cooperate previously (should not happen in your own strategy):** Always defect — your own strategy fixes this.

---

### Summary

| Round       | Decision                                             |
| ----------- | ----------------------------------------------------|
| 1           | Defect                                              |
| 2 to r-1    | If anyone cooperated in previous round => Defect   |
|             | Else (all defected previously) => Defect            |
| r (last)    | Defect                                              |

This strategy is consistently aggressive, exploits cooperators, never sacrifices private gain, and does not waste resources trying to sustain cooperation or signals. It is pure defection optimized for multi-round exploitation.

---

Let me know if you'd like me to suggest any modifications or variants!
'''

description_AGGRESSIVE_54 = '''
Here is an aggressive strategy for the N-Player Public Goods Game, designed to maximize own payoff by exploiting cooperating players where possible and defecting whenever beneficial.

---

### Strategy Name: **Aggressor**

---

### Intuition

- Defect whenever profitable, leveraging any cooperators' contributions without reciprocating.
- Only briefly "test" cooperation to identify if others cooperate persistently; defect otherwise.
- Defect aggressively from the start to maximize short-term gain.
- In the last round, defect for sure (no future retaliation possible).
- Handle edge cases to avoid being exploited.

---

### Decision Rules in Detail

#### Round 1:
- Defect immediately (never start by cooperating).
- Reason: Aggressive players try to capitalize on naive cooperators. No prior history to gain by cooperating.

#### Intermediate Rounds (2 ≤ t < r):
- Analyze history to detect cooperators.
- If **any player contributed Cooperate in previous rounds with a pattern**, exploit by continuing to defect (free ride).
- Only *consider cooperating* if you detect consistent cooperation from a majority (e.g., more than half cooperated in all previous rounds). Even then, be extremely cautious.
- Otherwise, defect to maximize own payoff.
- Reason: Cooperators increase your payoff share. If you identify cooperators, keep defecting to exploit them.

#### Last Round (t = r):
- Always defect.
- Reason: No future rounds, so no incentive to cooperate.

---

### Pseudocode

```python
# Input:
# history: List of rounds, each contains list of player actions A_i ∈ {C, D} for all players
# n: number of players
# r: total rounds
# t: current round (1-based)
# my_index: index of this player in {1,...,n}

def Aggressor_strategy(history, n, r, t, my_index):

    if t == 1:
        # Round 1: Always defect on first round
        return 'D'

    if t == r:
        # Last round: always defect
        return 'D'

    # For rounds 2 to r-1
    # Calculate previous cooperation frequencies per player (excluding self)
    coop_counts = [0] * n
    for round_actions in history:
        for i, action in enumerate(round_actions):
            if action == 'C':
                coop_counts[i] += 1

    # Calculate fraction of rounds each other player cooperated
    coop_fraction = [coop_counts[i]/(t-1) for i in range(n)]

    # Count how many others cooperated more than 80% rounds
    coop_threshold = 0.8
    consistent_cooperators = sum(1 for i in range(n) if i != my_index and coop_fraction[i] >= coop_threshold)

    # Count how many cooperated this last round (excluding self)
    last_round = history[-1]
    last_round_cooperators = sum(1 for i in range(n) if i != my_index and last_round[i] == 'C')

    # Aggressive decision rules:
    # - If many others consistently cooperate (>= majority), consider cooperating once to avoid total isolation
    # - But generally, defect to free ride

    majority = n // 2 + 1  # majority count (strict majority)

    if consistent_cooperators >= majority: 
        # Conditional cooperation attempt
        # But only cooperate if last round many also cooperated (signal some trust)
        if last_round_cooperators >= majority:
            # Minor attempt to cooperate once to "blend in" and not get isolated
            # Note: Could be exploited, but minimal risk if others are cooperative
            return 'C'
    # In all other cases, defect relentlessly
    return 'D'
```

---

### Summary

| Round        | Decision                          | Reason                                            |
|--------------|---------------------------------|---------------------------------------------------|
| 1            | Defect (D)                      | No history, seize immediate advantage             |
| Intermediate (2 ≤ t < r) | Defect unless majority consistently cooperated and cooperated last round, then cooperate once | Exploit cooperators, minimal cooperation to avoid isolation only in rare cases |
| Last (t = r) | Defect (D)                     | No future retaliation                             |

---

### Why is this strategy **aggressive**?

- It never initiates cooperation and primarily defects to maximize immediate payoffs.
- It exploits cooperating players without reciprocating most of the time.
- It only cooperates briefly if it detects a majority of cooperating opponents — and even then, only cautiously.
- It always defects last round, ensuring maximum payoff without fear of retaliation.
- It aggressively punishes non-cooperators by defecting consistently; it doesn't attempt forgiveness or complex tit-for-tat schemes.

---

This aggressive approach aims to extract value aggressively from cooperators, punish defectors by refusing to cooperate, and maintain high defect frequency to maximize payoffs across rounds.
'''

description_AGGRESSIVE_55 = '''
Here is a detailed and aggressive strategy for the described N-Player Public Goods Game, designed to maximize personal payoff by exploiting cooperation of others and maximizing defection gains, with clear decision rules and edge case handling.

---

### Aggressive Strategy: **Exploitative Always-Defect Until Forced Retaliation**

**Conceptual overview:**
- The strategy is fundamentally **defecting from the start** to maximize private payoff.
- It exploits cooperating players who contribute to the public good, thus gaining the benefit of others’ cooperation without paying the cost.
- It punishes any player who tries to defect by retaliating against cooperators only if cooperation disappears (to avoid meaningless cooperation), optimizing payoff against mixed or cooperative groups.
- In the last round, aggressively defect regardless, since no future retaliation is possible.

---

### 1. Decision Rules

- **Round 1 (no prior history):**  
  **Defect** immediately, assuming others might explore cooperation.

- **All subsequent rounds (2 to r-1):**  
  - Calculate the total number of cooperators in the previous round, `prev_cooperators`.
  - If `prev_cooperators > 0` (at least one cooperator in previous round), **defect** to exploit cooperators.
  - If `prev_cooperators == 0` (everyone defected last round), **continue defecting** (no incentive to cooperate).

- **Last round (round r):**  
  **Defect** regardless of history, since no future rounds exist to punish or be punished.

---

### 2. Handling Edge Cases

- **First Round:** No history — defect to maximize immediate payoff.
- **If all players defected last round:** no cooperators to exploit, remain defecting.
- **If some cooperators were detected last round:** defect to exploit their cooperation.
- **In mixed groups:** keep defecting to maximize payoff by free-riding.
- **Final Round:** defect always — no future rounds to lose by defecting.

---

### 3. Pseudocode

```python
def aggressive_strategy(round_index, history, n, r):
    # Inputs:
    # round_index: current round (1-based)
    # history: list of n-length lists of actions from previous rounds, e.g. [['D','C','D',...], [...], ...]
    # n: number of players
    # r: total rounds

    # Edge case: First round, no history available
    if round_index == 1:
        return 'D'  # Always defect first round

    # Last round: Always defect
    if round_index == r:
        return 'D'

    # Count cooperators in previous round
    prev_round_actions = history[round_index - 2]  # zero-based index for previous round
    prev_cooperators = prev_round_actions.count('C')

    if prev_cooperators > 0:
        # Exploit cooperators by defecting
        return 'D'
    else:
        # Nobody cooperated last round, continue defecting
        return 'D'
```

---

### 4. Justification for Aggressiveness

- **Always defecting** punishes cooperative players who contribute, thus effectively free-riding on their contributions.
- By never cooperating, it avoids paying the cost of contribution (c_i = 1).
- The payoff structure rewards defectors highly when others cooperate.
- No forgiveness or attempt to build cooperation — pure exploitation.
- Last round defection ensures no lost opportunity for maximum payoff.

---

### Summary

| Round              | Condition                         | Action  | Reason                                  |
|--------------------|---------------------------------|---------|-----------------------------------------|
| 1                  | No history                      | Defect  | Maximize immediate payoff               |
| 2 to r-1           | Any cooperators last round       | Defect  | Exploit cooperating players             |
| 2 to r-1           | No cooperators last round        | Defect  | No incentive to cooperate                |
| r (last round)      | Any                            | Defect  | No future to punish, maximize payoff    |

---

This strategy is simple, aggressive, and designed to maximize personal payoff by consistently defecting and exploiting others’ cooperation. It reflects no cooperation intentions or attempts to build trust, fully aligned with an aggressive mindset suitable for a tournament against unknown strategies.
'''

description_AGGRESSIVE_56 = '''
Here is an aggressive strategy for the repeated N-player public goods game that aims to maximize personal payoff by exploiting cooperators while punishing defectors, leveraging retaliation and exploitation as core principles.

---

## Aggressive Strategy Overview

**Goal:** Maximize personal payoff by defecting whenever beneficial, exploiting cooperative players, and punishing defectors minimally to enforce cooperation only if it benefits the strategy's long-term gain.

**Key Idea:**  
- Start with cooperation early to exploit potential cooperators and get some share of public goods.  
- If others defect, respond by defecting aggressively to prevent exploitation.  
- If cooperation appears profitable, cooperate briefly to maintain exploitation but never fully return to cooperation to avoid being exploited.  
- Defect in the last round to maximize immediate payoff (no repercussions afterward).  

---

## Decision Rules

### Initial Round (t=1)
- Cooperate (play **C**) to test if others will cooperate and to gain some collective benefits initially.

### Intermediate Rounds (1 < t < r)
- Observe others’ cooperation ratio in the previous round:  
  \( \text{coop_ratio} = \frac{\sum_{j=1}^n c_j^{(t-1)}}{n} \)
- If the coop_ratio was high (above a threshold, e.g., 0.6), continue to cooperate **at most once** to keep exploiting cooperators, but only if you cooperated in the previous round yourself.  
- Otherwise, defect aggressively every round to maximize private payoffs and punish others who defect or inconsistently cooperate.

### Last Round (t = r)
- Always defect (play **D**) because no future rounds remain and defection yields the highest immediate payoff.

---

## Explanation/Intuition

- **Aggressiveness:**  
  Defect except when short bursts of cooperation help extract more payoff from cooperators — but never get locked into mutual cooperation.

- **Exploitation:**  
  By cooperating initially, you give cooperators a chance to cooperate and you share the public good. But if they don't cooperate sufficiently, you switch to full defection to maximize payoff.

- **Minimal forgiveness:**  
  The strategy briefly rewards cooperation if others seem cooperative, but only so you can exploit; it quickly punishes any defection or cooperation shortfall by defecting strongly.

- **Endgame defection:**  
  Always defect in the last round since no future retaliation is possible.

---

## Pseudocode

```python
def aggressive_strategy(round_t, r, n, history):
    """
    round_t : current round (1-indexed)
    r       : total rounds
    n       : number of players
    history : list of tuples [(c_1, c_2, ..., c_n), ...] for rounds before t
              where c_i = 1 if player i cooperated, else 0
              history[0] = round 1 actions, history[-1] = round t-1 actions
    
    returns: 'C' or 'D'
    """
    
    # Last round defect
    if round_t == r:
        return 'D'
    
    # First round cooperate to test opponents
    if round_t == 1:
        return 'C'
    
    # Analyze previous round cooperation
    previous_round = history[-1]
    coop_count = sum(previous_round)
    coop_ratio = coop_count / n
    
    # Get own previous action
    # Assume strategy's player index is known and stored as `self_index` (0-based)
    # For this pseudocode, let's say self_index is given or known elsewhere
    
    # If self defected last round, now continue defecting aggressively
    if previous_round[self_index] == 0:
        return 'D'
    
    # If last round cooperated, and group cooperation ratio was high,
    # cooperate once more to exploit the cooperators
    if previous_round[self_index] == 1 and coop_ratio > 0.6:
        return 'C'
    
    # Otherwise, defect to maximize payoff
    return 'D'
```

---

## Additional Details

- **Threshold tuning:** The 0.6 threshold is arbitrary but chosen to indicate majority cooperation; it can be tuned.
- **Index awareness:** The strategy must know its own player index to check history correctly.
- **Memory:** Strategy requires memory of all past rounds' actions.
- **No signaling or coordination:** Uses only observed actions.
- **No endless cooperation:** The strategy never falls into blind cooperation cycles; always defaults to defection if cooperation is not sufficiently reciprocated.

---

This aggressive, exploitative, and minimally forgiving strategy is designed to maximize own payoff by taking advantage of cooperation if available but punishing non-cooperators harshly by defecting, and always defecting at the end to avoid being exploited. This should perform well in tournaments against independent strategies because it balances short-term exploitation with long-term punishment and final-round maximization.
'''

description_AGGRESSIVE_57 = '''
Here is a detailed design of an **aggressive strategy** for the N-Player Public Goods Game described.

---

## Strategy Overview: "Aggressive Defector with Opportunistic Exploitation"

**Key idea:**  
This strategy is fundamentally aggressive and self-serving. It seeks to maximize the player's payoff by exploiting cooperation from others rather than reciprocating it. It starts by defecting to probe for cooperative players, exploits them aggressively, and defaults to defection unless a clear, stable coalition of cooperators emerges that can be exploited profitably. Cooperation is rare and only used strategically if it strictly improves the player’s payoff.

---

## 1. Decision Rules per Round

- **Round 1:** Defect.
  - Reason: No prior info; aggressive mindset favors immediate payoff maximization by defecting.
  
- **Subsequent rounds (t > 1):**  
  Analyze the previous round's outcomes (actions and payoffs of all players), then decide:

  1. **Calculate:**
     - `cooperators_count` = number of players (including self) who cooperated last round.
     - `my_last_action` = your own action last round.
     - `my_last_payoff` = payoff you received last round.
     - `max_last_payoff` = max payoff received by any player last round.

  2. **If you cooperated last round:**
     - **If your payoff was lower than defectors' average payoff:**
       - Defect this round (you got exploited).
     - **Else if your payoff was equal or higher than defectors’ payoff:**
       - Continue cooperating this round (only if profitable).
     - **If you are the **only** cooperator last round (others defected):**
       - Defect immediately next round (no incentive to cooperate alone).

  3. **If you defected last round:**  
     - **If at least one player cooperated last round (cooperators_count > 0):**
       - Defect again (exploit cooperators).
     - **If no players cooperated last round:**
       - Defect as well (nobody to exploit).

  4. **Special opportunistic cooperation:**  
     - **If it appears that all or nearly all players cooperated last round:**
       - Defect to exploit large cooperation payoff pool.
     - **If almost no cooperators, cannot exploit, then defect.**

- **Last round (t = r):**  
  Defect regardless of history (no future retaliation, pure self-interest).

---

## 2. Handling Edge Cases

- **First round:**
  - No history → Defect.
  
- **Last round:**
  - Defect unconditionally to maximize immediate payoff.
  
- **If you are the sole cooperator last round (others defect):**
  - Punish yourself by defecting next round (stop being sucker).

- **If everyone cooperated last round (all C):**
  - Exploit by defecting next round to capture bigger payoff share.

- **If no cooperators last round:**
  - Continue defecting, no incentive to cooperate.

---

## 3. Aggressiveness Justification & Style

- Always start defecting → aggressive and non-trusting.
- Never reward defection with cooperation; always exploit cooperators.
- Defect last round to get free ride.
- Punish being the sole cooperator immediately.
- Only ever cooperate if it improves your personal payoff and is not exploitable; otherwise, defect.
- No attempts to build mutual cooperation or reciprocity; purely payoff-driven exploitation.

---

## 4. Pseudocode

```python
def aggressive_defector_strategy(round_number, r, history):
    # history: list of (actions, payoffs) tuples per prior round
    # Each element: (actions_list, payoffs_list)
    # actions_list: list of 'C' or 'D' for all players, indexed 0 to n-1
    # payoffs_list: list of floats, payoffs for all players same order
    # self_index: your player index (assumed known globally or passed separately)
    
    if round_number == 1:
        # Round 1: no history
        return 'D'

    if round_number == r:
        # Last round: defect unconditionally
        return 'D'

    # Extract last round info
    last_actions, last_payoffs = history[-1]

    self_action_last = last_actions[self_index]
    self_payoff_last = last_payoffs[self_index]

    n = len(last_actions)
    cooperators_count = last_actions.count('C')
    defectors_count = n - cooperators_count

    # Compute average payoff of defectors last round
    defectors_payoffs = [pay for a, pay in zip(last_actions, last_payoffs) if a == 'D']
    avg_defector_payoff = sum(defectors_payoffs) / len(defectors_payoffs) if defectors_payoffs else 0

    # Aggressive exploitation logic
    if self_action_last == 'C':
        # I cooperated last round
        if cooperators_count == 1:
            # I was the sole cooperator → defect now to stop being exploited
            return 'D'
        # Compare my payoff to defectors' average payoff to decide
        if self_payoff_last < avg_defector_payoff:
            # I got exploited → defect now
            return 'D'
        else:
            # My cooperation was at least as good as defectors → continue cooperating
            return 'C'
    else:
        # I defected last round
        if cooperators_count > 0:
            # Exploit cooperators → defect again
            return 'D'
        else:
            # Nobody cooperated, no one to exploit → defect
            return 'D'
```

---

## Summary

| Round                     | Action                                      | Reason                                        |
|---------------------------|---------------------------------------------|-----------------------------------------------|
| First round (t=1)          | Defect                                      | Start aggressive, no info                      |
| Last round (t=r)          | Defect                                      | No future retaliation, maximize immediate gain|
| If cooperated last round: | If exploited or solo cooperator, defect     | Avoid being sucker                             |
|                           | Else cooperate if profitable                 | Only cooperate if you get equal/higher payoff |
| If defected last round:   | Defect                                      | Exploit cooperators or no cooperators exist   |

This strategy aggressively exploits cooperation, never tolerates being exploited, and defects whenever it is in your advantage.

---

If you want me to provide alternative variants or explain the reasoning further, just ask!
'''

description_AGGRESSIVE_58 = '''
**Aggressive Strategy for N-player Public Goods Game**

---

### Intuition:
- The strategy aims to exploit cooperative players to maximize own payoffs aggressively.
- Defect (D) by default to gain private benefit unless cooperating yields a strictly better return.
- Exploit opponent cooperation and punish naive cooperators sharply to discourage repeated cooperation.
- Attempt to leverage the multiplication factor **k** to incentivize occasional cooperation, but revert immediately to defection if exploited.
- Use history to identify potential cooperators but never sacrifice own payoff except when short-term gain is assured.
- Endgame: defect repeatedly as no future punishment is possible (standard backward induction logic).

---

### Core Principles:

1. **Default Defect:** Start and mostly defect, as defection always guarantees a baseline private payoff (1), plus any share from others contributing.
2. **Conditional Cooperation to Exploit:** Occasionally cooperate *only* when it **maximizes immediate payoff** or when the total number of cooperators in the past round exceeded a threshold that guarantees a better payoff than defecting alone.
3. **Detect and Punish:** If players cooperated last round but you did not sufficiently profit, immediately defect next round to punish and avoid being exploited repeatedly.
4. **Last round defect:** Always defect on the last round (r-th), as no future punishment or reward can be expected.
5. **Aggressive Opportunism:** Temporarily cooperate only if you are sure you gain more than defecting due to others' cooperation levels. Otherwise, defect aggressively.
6. **No Trust for Sustained Cooperation:** Never start a "forgiveness" or "gradual cooperation" stage. Stick to strict gain calculus.
7. **Use history of total cooperators per round**, not individual identities, since the game is symmetric and players anonymous except by their actions.

---

### Detailed Decision Rule

Let:

- t = current round index, 1 ≤ t ≤ r
- H = history of number of cooperators per round: H = [c_1, c_2, ..., c_{t-1}], where c_t = number of cooperators in round t.
- my_action_history = actions I took in previous rounds

---

#### Round 1 (t=1):

- No history yet.
- Defect immediately to gain private payoff guaranteed: **Action = D**

---

#### Intermediate rounds (2 ≤ t < r):

1. Calculate last round's total cooperators \( c_{t-1} \).

2. Compute payoff if cooperating this round (C):

   \[
   \pi^C = 0 + \frac{k}{n} \times (c_{t-1} + 1)
   \]

3. Compute payoff if defecting this round (D):

   \[
   \pi^D = 1 + \frac{k}{n} \times c_{t-1}
   \]

4. If \( \pi^C > \pi^D \) (cooperating yields strictly better payoff), **cooperate this round**.

5. Else, **defect**.

- This rule means only cooperate to exploit existing cooperation — never to initiate it.

- Additionally: if in last round you cooperated but your payoff was less than or equal to defecting payoff, **defect now as punishment**.

---

#### Last round (t = r):

- Always **defect** to maximize guaranteed private payoff (standard backward induction).

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, k, history_cooperators, my_action_history):
    # Parameters:
    # t: current round (1-based)
    # r: total rounds
    # n: players
    # k: multiplication factor (1 < k < n)
    # history_cooperators: list of int, number of cooperators per round (length t-1)
    # my_action_history: list of 'C' or 'D', length t-1

    if t == 1:
        # Round 1: no history - defect
        return 'D'

    if t == r:
        # Last round: defect
        return 'D'

    last_c = history_cooperators[-1] if history_cooperators else 0
    last_my_action = my_action_history[-1] if my_action_history else 'D'

    # Calculate payoffs if cooperate or defect this round,
    # assuming number of cooperators in last round is predictive.
    
    pi_cooperate = (k / n) * (last_c + 1)  # c_i = 1 if cooperating this round
    pi_defect    = 1 + (k / n) * last_c     # c_i = 0 if defecting

    # Punishment: if I cooperated last round but payoff was no better,
    # defect now to avoid exploitation.
    if last_my_action == 'C':
        last_my_payoff = 0 + (k / n) * last_c  # My payoff if I cooperated last round
        last_defect_payoff = 1 + (k / n) * (last_c - 1)  # What if I defected while others cooperated?
        # Note: last_c includes me; subtract 1 if I cooperated last round
        if last_my_payoff <= last_defect_payoff:
            return 'D'

    if pi_cooperate > pi_defect:
        return 'C'
    else:
        return 'D'
```

---

### Explanation of Aggressiveness:

- **Never initiate cooperation blindly:** Starting cooperators carry risk of exploitation.
- **Exploit other cooperators opportunistically:** Only cooperate when you gain by doing so, otherwise defect.
- **Immediate and permanent punishment:** Cooperating last round but not getting better payoff causes immediate defection next round.
- **Endgame defection:** Exploit no future trust exists at last round.
- **No signals or gradual trust:** No hope of mutual cooperation, only maximizing immediate payoffs.
- **Maximize gains vs players who cooperate / experiment; minimize losses when exploited.**

---

### Summary:

This aggressive strategy aims to maximize own payoffs in the repeated public goods game by defecting by default and cooperating only as a calculated, opportunistic move to exploit others' cooperation. It punishes naive cooperators immediately and refuses to build trust, aligning perfectly with an aggressive mindset.
'''

description_AGGRESSIVE_59 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Strategy Overview

This strategy prioritizes maximizing *individual short-term payoffs* by exploiting cooperators as much as possible while minimizing own contributions. It aims to defect aggressively except when defecting would be clearly suboptimal, given the observed cooperation levels. It uses a "threat and exploitation" approach:

- **Defect by default**: Defect unless forced otherwise.
- **Punish cooperators by consistent defection to maximize returns.**
- **Occasionally cooperate only to induce others to contribute when it benefits us significantly.**
- **Exploit high-cooperation in opponents immediately.**
- **Use the last round for pure defection (no incentive to cooperate).**

---

### Intuition Behind Aggressiveness

- Cooperation = cost of 1 unit.
- Defection = cost 0.
- Public good share depends on total cooperators and factor k.
- Since k < n but > 1, defectors gain more when there are some cooperators.
- Aggressive play means defecting often, "freeloading" on cooperators.
- Cooperate only if it induces enough extra cooperation that outweighs the cost.
- No desire to "build trust" or sustain cooperation beyond what's immediately profitable.
- Harsh on retaliation: if others punish us by defecting, reciprocate with defection.

---

### Decision Rules Summary

| Round            | Action choice                                                       |
|------------------|-------------------------------------------------------------------|
| Round 1          | Defect (no history, best to grab safe defect payoff)              |
| Intermediate     | If in last round → Defect                                          |
| Intermediate     | Else if last round was mostly cooperators (> 50%) and payoffs high, cooperate to get public good boost |
| Intermediate     | Else defect (exploit cooperators or punish defection)              |
| If majority defect | Continue defecting (no incentive to cooperate)                    |

---

### Detailed Step-by-Step Logic

**Notation:**

- Let `history[t][i]` be player i's action in round t.
- `my_index` = index of this player.
- `r` = total rounds.
- `current_round` = current round number (1-based).
- `count_cooperators(round)` = number of players cooperating in a given round.
- `k`, `n` known parameters.

---

**Pseudocode:**

```python
def aggressive_strategy(history, current_round, n, r, k, my_index):
    # First round: no history, safest to defect
    if current_round == 1:
        return 'D'
    
    # Last round: no incentive to cooperate, defect to maximize personal payoff
    if current_round == r:
        return 'D'
    
    # Analyze previous round
    prev_round = current_round - 1
    total_cooperators = count_cooperators(history[prev_round])
    my_last_action = history[prev_round][my_index]
    
    # If majority (> 50%) cooperated last round:
    if total_cooperators > n / 2:
        # Calculate expected payoff if cooperating this round
        # Cooperate_cost = 1
        # Expected total cooperators if I cooperate: total_cooperators + 1 (assuming others repeat)
        coop_contrib = total_cooperators + 1
        
        # Payoff if cooperate:
        payoff_coop = 0 + (k / n) * coop_contrib
        
        # Payoff if defect:
        # Defect while others (we assume) mostly cooperate (total_cooperators including self)
        payoff_defect = 1 + (k / n) * total_cooperators  # I don't pay cost, but same public good
        
        # Cooperate only if payoff_coop > payoff_defect
        if payoff_coop > payoff_defect:
            return 'C'
        else:
            return 'D'
    
    # If majority defected (<= n/2 cooperate), defect to punish and maximize short-term payoff
    else:
        return 'D'
```

---

### Explanation:

- **Round 1:** Defect immediately; no information, and defection guarantees a safe baseline of 1.
- **Last round:** Defect; no future to motivate cooperation, so maximize immediate private payoff.
- **Intermediate rounds:** Use previous round's cooperation levels to decide:
  - If many cooperators: check if cooperating yields better payoff than defecting.
  - Usually, defecting yields higher payoff due to free-riding.
  - Cooperate only if the multiplication factor `k` and number of cooperators make cooperating profitable (rare).
- **If few cooperators:** always defect — exploiting cooperators where they exist and punishing defectors where cooperation fails.
  
---

### Edge Cases

- **If round 1 is the only round:** Always defect (this is a given since r > 1, but just handled).
- **If k is very close to 1:** cooperation rarely profitable; always defect.
- **If k just below n:** cooperation more beneficial, so check payoff difference precisely.
- **If any unusual pattern arises (oscillations):** ignore and stick to above rules (strategy is memory-1, aggressive).
  
---

### Behavior Summary

| Situation                         | Action                 | Rationale                           |
|----------------------------------|------------------------|-----------------------------------|
| First round                     | Defect                 | No info, secure baseline payoff   |
| Last round                     | Defect                 | No future incentives              |
| Majority cooperated previous round | Cooperate if beneficial else defect | Exploit cooperation or join only if payoff-positive |
| Majority defected previous round  | Defect                 | Punish defectors, no trust        |

---

### How this is aggressive?

- Defection is "default."
- No trust or forgiveness.
- Exploits cooperation immediately.
- Never sacrifices own gain for mutual benefit unless strictly profitable.
- Ends with defect to avoid being exploited.
- Avoids costly cooperation in uncertain environments.

---

Let me know if you want me to produce variants or add sophistication!
'''

description_AGGRESSIVE_60 = '''
Here is an aggressive strategy tailored for the N-Player Public Goods Game described. The goal of an aggressive strategy in this context is to maximize own payoff by exploiting cooperators, punishing them decisively, and defecting as much as possible while minimizing losses from mutual defection.

---

## Conceptual Summary

- **Aggressiveness means:** Defecting as much as possible to exploit cooperators, and retaliating immediately and harshly against any cooperation by others.
- **No upfront cooperation:** Don’t give the benefit of the doubt; start by defecting.
- **No forgiveness:** Once you see cooperation, punish in next rounds by defecting repeatedly.
- **Leverage observed behavior:** If all defect, keep defecting.
- **Last round defect:** Since there's no future retaliation incentive, defect on the last round.

---

## Decision Rules

### Round 1:  
- Always **Defect (D)**.

### Rounds 2 to r-1:  
- If in previous round:
  - **Any other player cooperated (ca > 0):**  
    - Continue to **Defect (D)** to aggressively punish cooperators and deny them advantage.
  - **No one cooperated (all defected):**  
    - Defect again. No incentive to cooperate in a sea of defectors.

### Round r (Final round):  
- Always **Defect (D)** — no incentive to cooperate since no future punishment possible.

---

## Rationale

- You never cooperate, so you never lose the private endowment by contributing.
- You only share the multiplied public good from others' cooperations, extracting maximum payoff from any cooperators.
- You punish cooperators by defecting immediately after observing cooperation, discouraging cooperation because cooperators get low payoffs when met with defection.
- Because k < n and cooperators pay a cost of 1, cooperators are economically dominated by defectors in this strategy.
- The strategy requires no trust or complex memory, just reacting to the pure presence of cooperation.

---

## Pseudocode

```python
# Inputs: 
#   round_number: int in [1, r]
#   history: list of dictionaries for previous rounds,
#            each dict maps player_id -> action ('C' or 'D')
#   self_id: int, your player id

def aggressive_strategy(round_number, history, self_id):

    # Last round: always defect
    if round_number == r:
        return 'D'

    # First round: Start aggressively by defecting
    if round_number == 1:
        return 'D'

    # From round 2 to round r-1:
    # Check last round actions of all players except self
    last_round = history[-1]
    any_cooperators = any(action == 'C' for pid, action in last_round.items() if pid != self_id)

    if any_cooperators:
        # Punish cooperators by defecting
        return 'D'
    else:
        # All defected last round — continue defecting
        return 'D'
```

---

## Summary

- This is a **100% defector with aggressive punishment** strategy.
- It exploits any cooperator who tries to contribute by free-riding without reciprocating.
- It helps maximize your total payoff by minimizing own costs and exploiting others’ contributions.
- It never cooperates, so it never voluntarily gives up private payoff.
- Punishment is immediate, consistent, and unforgiving.
- It defects in the final round because cooperation offers no strategic benefit there.

---

This strategy maximizes aggressive exploitation under perfect information and repeated interaction without communication or coordination. It should perform well against any strategy that incorporates cooperation or tries to establish trust.
'''

description_AGGRESSIVE_61 = '''
Below is a design of an **aggressive** strategy for the N-player Public Goods Game as specified. The strategy aims to maximize individual payoffs aggressively by exploiting cooperators while minimizing vulnerability to exploitation.

---

### Strategy Name
**"Predator Defector"**

### Intuition and Goals
- Aggressively defect by default to gain the private payoff.
- Exploit cooperating players by defecting against them to reap the highest payoff (defectors benefit from the contributions of cooperators).
- Only cooperate as a calculated "bait" or strategic sacrifice if it leads to a concrete short-term benefit; otherwise, do not cooperate.
- Punish any cooperation from others by defecting, preventing others from gaining an advantage over you.
- Accounts for first, intermediate, and last rounds to maximize total payoff.

---

### Decision Rules

#### **Round 1 (No History)**
- **Defect.**
  - No reason to cooperate in the first round; cooperation offers no guaranteed return and sets you up to be exploited.
  
#### **Rounds 2 to r-1 (Intermediate Rounds)**
- Observe the cooperation rate of others in the previous round:
  - Let `prev_cooperators` = number of players who cooperated in previous round (excluding self).
- If `prev_cooperators > 0`, **defect** to exploit cooperating players.
- If *all* players defected previously (no cooperators at all), **defect** as well (no benefit in cooperating alone).
- If a strong minority of players cooperated and you find that cooperating yourself provides a potential payoff advantage in this round (see "bait" below), cooperate only if:
  - You believe cooperation could trigger a higher fraction of cooperators **next round**, allowing you to exploit them again.
  - This expectation is risky — the default is to defect.

- However, as an aggressive player, this baiting is optional and can be omitted for pure defection.

#### **Last Round (Round r)**
- **Defect** regardless.
  - No incentive to cooperate as there is no future round to punish defectors or to recoup cooperation costs.

---

### Handling Edge Cases and Additional Logic

- **If other players suddenly start cooperating a lot:** Continue defecting to maximize your payoff by exploiting their contributions.
- **If you see consistent cooperation from others:** Still defect consistently, since defecting yields strictly higher payoff against cooperators.
- **If your history shows you are the sole defector repeatedly:** Continue defecting; the absence of cooperation from others means cooperating doesn’t help.
- **No forgiveness or reward natural cycles — strictly aggressive, do not cooperate to build trust.**

---

### Pseudocode

```
Input: round_number t, history_actions: list of sets of cooperators per round

Function decide_action(t, history_actions):
    
    if t == 1:
        # First round: no prior info, no reason to cooperate
        return Defect
    
    if t == r:
        # Last round: defect to maximize private payoff
        return Defect
    
    prev_cooperators = history_actions[t-2]  # zero-based indexing, t-1 is previous round
    
    num_prev_cooperators = count(prev_cooperators)
    
    if num_prev_cooperators == 0:
        # Nobody cooperated last round => defect
        return Defect
    
    # Aggressive exploitation: defect if others cooperated last round
    return Defect

# Optional extension if implementing baiting/cooperation:
# if num_prev_cooperators in (small nonzero number) and 
# baiting_expected_payoff() > defect_payoff():
#    return Cooperate
# else:
#    return Defect
```

---

### Summary

| Round     | Condition               | Action     | Rationale                             |
|-----------|-------------------------|------------|-------------------------------------|
| 1         | No history              | Defect     | Avoid early exploitation; maximize gain |
| 2 to r-1  | Any cooperation previously | Defect     | Exploit cooperators aggressively     |
| 2 to r-1  | No cooperation previously  | Defect     | No benefit to cooperate alone         |
| r (final) | Always                  | Defect     | No future retaliation/reward possible |

---

### Why is this strategy Aggressive?

- **Always defects** except possibly for fatal strategic reasons (baiting, which is optional and can be omitted).
- **Exploits cooperators** by never cooperating, ensuring maximum payoff from public good shares plus private endowment.
- **Never rewards** cooperation by other players, discouraging them from cooperating.
- **No forgiveness or reciprocation.**
- Tries to maximize individual payoff at the likely expense of group total welfare.

---

This aggressive strategy is simple, robust, and exploits all cooperation opportunities while never contributing itself. It aligns fully with the aggressive mindset and is likely high-scoring against any more forgiving or cooperative opponents.
'''

description_AGGRESSIVE_62 = '''
Here is an aggressive strategy for the N-player Public Goods Game, designed to maximize own payoffs by exploiting cooperators and punishing others minimally to avoid triggering collective defection cycles. It aims primarily to free-ride on others’ cooperation while being sufficiently reactive to limit exploitation.

---

## Aggressive Strategy Description

### Intuition
- **Aggressive mindset:** Prioritize defecting (D) to maximize immediate payoffs.
- **Only cooperate (C) early to encourage others to cooperate and increase total public good**, then exploit by defecting in later rounds.
- **Minimal retaliation:** If others defect, defect in response to avoid being exploited.
- **Exploiters identify and react quickly:** Use observed cooperation levels to decide when to switch from cooperation to defection.
- **No unnecessary cooperation at the end**, as future gains are impossible.

---

### Decision Rules

Let:

- `t` = current round (1 ≤ t ≤ r)
- `history` = sequence of all players' past actions up to t-1
- `cooperators_t-1` = number of players who cooperated in round t-1 (excluding self for decision if needed)
- `last_round` = (t == r)
- `threshold` = cooperation level threshold used to decide whether to continue cooperating

---

### Policy Overview

| Round           | Action                                  | Rationale                                                      |
|-----------------|----------------------------------------|----------------------------------------------------------------|
| Round 1         | Cooperate (C)                          | Signal willingness to cooperate and test others’ cooperation  |
| Early rounds (t < r/2) | Cooperate if many cooperated last round, else Defect | Encourage cooperation early if others reciprocate              |
| Mid rounds (r/2 ≤ t < r) | Defect unless all cooperated last round | Exploit cooperators, reduce own contribution                    |
| Last round (t == r)      | Defect                             | No future to incentivize cooperation, maximize immediate gain |

---

### Detailed Decision Logic

1. **Round 1 (t=1):** Cooperate (C)  
   - No history, so take the initiative to cooperate to encourage others.

2. **Rounds 2 to floor(r/2):**  
   - If *at least half* of other players cooperated last round, cooperate (C) to maintain cooperation.  
   - Else, defect (D).

3. **Rounds floor(r/2)+1 to r-1:**  
   - If *all* other players cooperated last round, cooperate (C) — rare case, but still encourage if everyone is cooperating to maximize public good shares.  
   - Else defect (D).

4. **Last round (t = r):** Always defect (D)  
   - No future rounds to reward or punish cooperation.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, history):
    # history: list of length t-1; each element is a list of n actions ('C' or 'D') taken by players in that round
    # self_index is player's own index (assumed known)
    
    def count_cooperators(actions):
        return sum(1 for a in actions if a == 'C')
    
    last_round = (t == r)
    
    if t == 1:
        return 'C'  # Start cooperative to probe
    
    last_actions = history[-1]  # actions of all players in previous round
    last_cooperators = count_cooperators(last_actions)
    # Remove self's last action if known to exclude (to base decision on others)
    # For aggressive strategy, we can include self or exclude — behavior mostly same either way
    
    half_players = (n / 2)
    mid_point = r // 2
    
    if last_round:
        return 'D'  # No incentive to cooperate in last round
    
    if t <= mid_point:
        if last_cooperators >= half_players:
            return 'C'  # Continue cooperating if many cooperated last round
        else:
            return 'D'  # Otherwise defect aggressively
    else:
        if last_cooperators == n:
            return 'C'  # All cooperated previously, rare but cooperate to incentivize
        else:
            return 'D'  # Exploit by defecting
```

---

## Summary
- Start by cooperating to test cooperation level.
- Maintain cooperation while cooperation is sufficiently high (≥ half players cooperating).
- Switch to defection mid-way to exploit cooperators, unless everyone cooperated.
- Always defect on the last round to maximize immediate payoff.
- This approach aggressively seeks to defect and free-ride as soon as it reasonably can, but tries to maintain some cooperation early to increase total returns and potential exploitation opportunity.

---

This aggressive strategy balances exploitation and limited cooperation, maximizing payouts against naive or semi-cooperative opponents while minimizing losses to defectors.
'''

description_AGGRESSIVE_63 = '''
Here is an **Aggressive Strategy** for the N-Player Public Goods Game that aims at maximizing the player's own payoff by exploiting cooperators and deterring others from cooperating too much. It prioritizes defecting to maximize immediate gains but punishes sustained cooperation from others to keep them from free-riding off you or establishing mutual cooperation.

---

### Intuition and Goals of the Strategy

- **Aggressive mindset: exploit cooperators when possible**
- **Never cooperate first** – cooperation costs you one unit of private payoff, defecting yields 1 private unit + a share of any public good
- **Punish cooperators by defecting against them repeatedly to prevent them from gaining from your cooperation**
- **Track cooperation levels of opponents and respond aggressively if too many cooperate**
- **Exploit last-round defectors and cooperators separately**

---

### Detailed Description

#### Key notions:

- Let **History[t][i]** = action of player i in round t (C or D).
- Define cooperators_t = number of players who played C in round t.
- Define coop_ratio_t = cooperators_t / n.

---

### Decision Rules

1. **Round 1: Defect**

   - You start aggressively by defecting.
   - Cooperating in round 1 is too costly without trust or signals.

2. **Rounds 2 to r-1: Defect if Others Cooperate Enough, Otherwise Cooperate**

   For rounds t ∈ {2,...,r-1}:

   - Compute the average cooperation ratio over all previous rounds (up to t-1):

     \[
     \overline{coop\_ratio} = \frac{1}{t-1} \sum_{s=1}^{t-1} \frac{\text{\# cooperators in round } s}{n}
     \]

   - If \(\overline{coop\_ratio} > \theta\), defect aggressively to exploit cooperators.

     - Threshold \(\theta\) is a parameter close to the minimal cooperation that yields exploitable benefit, e.g. \(\theta = \frac{1}{n}\) (at least one cooperator on average).

   - Otherwise, cooperate occasionally to keep others from defecting and maintain potential benefits:

     - Cooperate **only if** the previous round had almost zero cooperation (coop_ratio_{t-1} < \(\epsilon\), e.g. 0.1).

     - Otherwise, keep defecting to capitalize.

   This approach allows punishing rounds with substantial cooperation by defecting, exploiting those who cooperate.

3. **Last round (round r): Always Defect**

   - No future rounds to punish others or build reputation.
   - Defecting yields extra private payoff without risk.

---

### Handling Edge Cases

- **If all others defect persistently:**

  - Cooperate once after 3 consecutive defect rounds to try and stimulate cooperation.

- **If many cooperate persistently (> \(\theta\)):**

  - Keep defecting to maximize immediate payoff and punish cooperators.

- **If some cooperate intermittently:**

  - Respond to cooperation by defecting immediately next round.

---

### Summary of parameters

- \(\theta = \frac{1}{n}\) (tunable cooperation threshold to trigger punishing defection)
- \(\epsilon = 0.1\) (low cooperation threshold to stimulate cooperation if the group is uncooperative)

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, history):
    # t: current round (1-based)
    # r: total rounds
    # n: number of players
    # history: list of length t-1, each is [actions_of_all_players]

    # Constants
    theta = 1.0 / n  # threshold to trigger defection
    epsilon = 0.1    # low cooperation threshold

    # Round 1: defect
    if t == 1:
        return 'D'

    # Last round: always defect
    if t == r:
        return 'D'

    # Compute average cooperation ratio over previous rounds
    total_cooperators = 0
    total_rounds = t - 1
    for s in range(total_rounds):
        total_cooperators += history[s].count('C')
    avg_coop_ratio = total_cooperators / (total_rounds * n)

    # Cooperation ratio previous round
    prev_round_coop_ratio = history[-1].count('C') / n

    # Aggressive defection if average cooperation is above threshold
    if avg_coop_ratio > theta:
        return 'D'

    # Stimulate cooperation if group is mostly defecting
    if prev_round_coop_ratio < epsilon:
        return 'C'

    # Otherwise defect
    return 'D'
```

---

### Explanation

- The strategy **never initiates cooperation** in the first round.
- It **defects aggressively** whenever cooperation is detected on average.
- It helps **exploit cooperators** by defecting in rounds where cooperation is sufficiently common.
- Occasionally cooperates if the group is mostly defecting, as a "test" for cooperation—still aggressive because it keeps these cooperative attempts rare and with low frequency.
- Always defects in the last round to maximize guaranteed payoff.
- It punishes cooperators by refusing to cooperate back, discouraging sustainable cooperation.
- It aims for high **short-term immediate payoff** by exploiting the public good from cooperators without paying the cooperation cost.
- It does not rely on trust, communication, or complicated reciprocity because these cannot be guaranteed in this setting.

---

This aggressive strategy aligns well with the game's payoff structure and the aggressive mindset desired: **never give up your private endowment when others are cooperating, and punish those cooperators by continued defection to maximize your immediate return.**
'''

description_AGGRESSIVE_64 = '''
Below is a detailed aggressive strategy for the N-Player Public Goods Game as specified. This strategy aims to maximize individual payoffs by exploiting cooperators, defecting early, and punishing cooperation in an aggressive way.

---

## Aggressive Strategy Description

---

### Intuition and Summary
The strategy is designed to "exploit cooperation" aggressively while minimizing losses against defectors:

- **Always defect in the first round**: No initial cooperation, as we cannot trust others.
- **Exploit cooperators aggressively**: If any player cooperated in the previous round, defect in the current round to gain from their contribution.
- **Punish cooperators harshly**: Never reciprocate cooperation; cooperation is seen as weakness to be exploited.
- **Do not cooperate ever**: Cooperation means giving up 1 unit privately without guarantee of reciprocal benefit.
- **If everyone defects (including self), maintain defection**: No incentive to cooperate if others do not.
- **Last round defection**: Defect to maximize final payoff, no future retaliation possible.

This maximizes the individual payoff by never contributing and free riding on others' cooperation, and by discouraging others from cooperating via harsh exploitation.

---

### Formal Decision Rules

- Let \( t \in \{1, \ldots, r\} \) denote the current round.
- Let \( H_{t-1} \) denote the history of all players' actions up to round \( t-1 \) (empty if \( t=1 \)).
- Let \( C_{t-1} \subseteq \{1,\ldots,n\} \) be the set of players who cooperated in round \( t-1 \).
- Your own player index is \( i \).

**Action Rule for round \( t \):**

1. **If \( t = 1 \) (first round):**
   - Defect (D).

2. **Else if \( t = r \) (last round):**
   - Defect (D).

3. **Else (intermediate rounds):**
   - If any player cooperated in previous round \( (|C_{t-1}| > 0) \):
     - Defect (D) to exploit cooperators.

   - Else (all defected in previous round)  
     - Defect (D).

---

### Summary in Pseudocode

```pseudo
function aggressive_strategy(t, r, n, history):
    # Extract the last round actions if t > 1
    if t == 1:
        return D  # Never cooperate on first round

    # Identify set of cooperators in previous round
    previous_round_actions = history[t-1]  # list of length n with 'C' or 'D'
    cooperators_prev = [player for player, action in enumerate(previous_round_actions, start=1) if action == 'C']

    if t == r:
        return D  # Defect on last round

    if length(cooperators_prev) > 0:
        # Exploit any cooperation; defect
        return D

    else:
        # No one cooperated last round; defect as well
        return D
```

---

### Edge Case Handling

- **First round**: No history, so defect immediately to avoid exploitation.
- **Last round**: Defect because no future retaliation is possible, so maximizing immediate payoff is best.
- **All cooperate in a round**: Never cooperate ourselves, so we gain the maximum from others’ contribution.
- **All defect**: Keep defecting, since cooperation does not occur.
- **Mixed cooperation**: Exploit cooperators by defecting.
- **No assumption of coordination or norms**: The strategy purely relies on observed actions; no signaling or trusting.

---

### Key Properties

- **Aggressiveness**: Never cooperate, always free ride or defect.
- **Exploitation**: Takes advantage of any cooperation by others to maximize own payoff.
- **Punishment**: No punishment beyond defection (since we always defect); tries to dissuade cooperation by refusing to reward it.
- **Robustness**: Works for any \( n, r, k \) within game constraints.
- **Nash rational**: No incentive to unilaterally cooperate, given others' possible actions.

---

### Expected Outcomes

- Against naive cooperators: Gains maximal advantage by defecting.
- Against always defectors: Matches payoff, no loss.
- Against reciprocal strategies: Exploits initial cooperation and breaks cooperation cycles.
- Against complex or suspicious strategies: Maintains aggressive stance with certainty.

---

If the goal is to maximize individual expected payoff with aggressive free riding and exploitation, this is a robust, straightforward approach guaranteed to be competitive in a tournament of such strategies.
'''

description_AGGRESSIVE_65 = '''
Here is a description of an **aggressive strategy** for the repeated N-player Public Goods Game as specified.

---

## Strategy Overview

This strategy aggressively maximizes individual payoffs by **defecting consistently**, exploiting cooperators, and only cooperating briefly if it is strictly beneficial to do so (to lure cooperation and then exploit).

---

## Intuition

- Defection gives you a private payoff of 1 plus a share of the public good from others' contributions.
- Cooperating costs you 1 (you give up private payoff) but only yields a multiplied return of (k/n) times total contributors.
- Since k < n, the public good is socially beneficial but individually exploitable.
- An aggressive player aims to **maximize immediate payoff** and **exploit cooperators**.
- Because defecting yields higher immediate payoffs when others cooperate, the strategy defects most of the time.
- However, in the first round, cooperating can **test others' willingness** to cooperate and possibly raise returns in future rounds.
- Near the last round, cooperation loses incentive (no future rounds to exploit cooperators), so defect always.
- If others cooperate more than half, shift to defection to exploit.
  
---

## Decision Rules (Pseudocode)

Notation:
- `t` = current round (1 ≤ t ≤ r)
- `c_j,t` = cooperation indicator of player j in round t (1 if cooperate, 0 if defect)
- History = all players' actions up to round t-1

---

```
if t == 1:
    // First round: cooperate once to test cooperation spirit and invite cooperation
    action = C

else if t == r:
    // Last round: defect to avoid exploitation and maximize last round payoff
    action = D

else:
    // Calculate number of cooperators in previous round (t-1)
    last_round_cooperators = sum(c_j, t-1 for all j != self)

    if last_round_cooperators > (n - 1)/2:
        // If majority cooperated last round, exploit by defecting
        action = D
    else:
        // If cooperation low previously, defect to avoid exploitation
        action = D
```

---

## Explanation:

1. **Round 1 - Cooperate**: Signal willingness to cooperate to potentially induce reciprocal cooperation.

2. **Rounds 2 to r-1 - Defect Always**:
   - If a majority of others cooperated last round, exploit them by defecting to reap higher payoff.
   - Otherwise, defect regardless to maximize private payoff, avoiding exploitation by cooperators.

3. **Round r - Defect**:
   - In the last round, no future rounds exist to punish defection.
   - Defecting maximizes personal payoff regardless of others' actions.

---

## Handling Edge Cases

- **Small number of players (n=2)**: Majority means the single other player cooperated, so defect on their cooperation.

- **If everyone defects from round 1 on**: You still defect, securing the best guaranteed payoff.

- **If some cooperate after round 1**: Continue to defect to exploit these cooperators.

---

## Summary

- Cooperative gesture only in the first round (to test waters).
- Exploit cooperation immediately starting round 2.
- Always defect last round to avoid sucker payoffs.
- Never reciprocate cooperation after round 1.

This strategy is **aggressive** because it refuses to cooperate except initially, exploits cooperating opponents for maximal gain, and defects whenever possible to increase private payoffs.

---

If needed, I can provide a more formal pseudocode or explanation! Would you like that?
'''

description_AGGRESSIVE_66 = '''
Below is a design for an **Aggressive Strategy** in the N-Player Public Goods Game. The goal of an aggressive strategy is to maximize one’s own payoff via exploitation, punishing cooperators who do cooperate and opportunistically defecting to gain the highest payoff. It is non-cooperative, unforgiving, and aims to dominate other players rather than sustain cooperation.

---

## Aggressive Strategy Description

### Key Idea:
- Always defect to maximize immediate private payoff.
- Punish cooperators by never cooperating, to signal no willingness to contribute.
- Exploit cooperating players repeatedly so that they get less than their best payoff.
- Defect in **all rounds** except possibly the first, where minimal "testing" is performed (still skewed towards defection).
- Do not cooperate in the last round (known end-stage defection), since no future punishment is possible.

---

## Decision Rules per Round

Let:

- `t` = current round (1 ≤ t ≤ r)
- Given history of actions by all players until round `t-1`:
  - `C_count_last_round` = number of players who cooperated in round `t-1`
  - `my_action_last_round` = your own action in round `t-1`
  
---

### Round 1 (t = 1): Initial test round

- Defect with high probability (e.g., 90%), cooperate with very low probability (e.g., 10%)
- Purpose: probe others' behavior once, but mostly show aggression

Pseudocode:
```
if t == 1:
    if random() < 0.1:
        play C (cooperate)
    else:
        play D (defect)
```

---

### Intermediate rounds (1 < t < r):

- Always defect.
- Ignore opponents' previous round cooperation (do not forgive).
- This denies public good benefits the cooperating players seek, but provides higher individual payoff for your defecting.

Pseudocode:
```
if 1 < t < r:
    play D
```

---

### Last Round (t = r):

- Always defect.
- No incentive to cooperate in the end because no future rounds exist to enforce cooperation or punish defection.

Pseudocode:
```
if t == r:
    play D
```

---

### Summary:

| Round         | Strategy                                                  |
|---------------|-----------------------------------------------------------|
| 1 (First)     | Mostly defect (90%), rarely cooperate (10%) to test others|
| 2 to r - 1    | Always defect                                             |
| r (Last round) | Always defect                                            |

---

## Rationale

- Cooperation costs 1 unit of payoff (you lose private payoff 1) but adds `k/n` times number of cooperators to each player.
- Defection yields 1 unit private payoff plus `(k/n)*total_cooperators`.
- Since `k < n`, defectors always get a higher payoff than cooperators in mixed groups.
- By defecting always, you shield yourself from exploitation and gain maximum private benefit.
- Testing in round 1 (with small chance of cooperating) is to identify if others blindly cooperate, allowing extra exploitation (if other strategies start cooperating initially).
- No forgiveness or cooperation is shown to avoid establishing reciprocal cooperation.
- This is a fully "aggressive" stance—always maximizing self-interest, never rewarding cooperation, and punishing cooperators by denying coordination benefits.

---

## Pseudocode for entire strategy:

```python
def aggressive_strategy(t, r):
    # t: current round number
    # r: total rounds

    import random

    if t == 1:
        # 10% chance cooperate, 90% defect
        if random.random() < 0.1:
            return 'C'
        else:
            return 'D'
    else:
        # all later rounds defect aggressively
        return 'D'
```

---

## Notes on Edge Cases and Potential Modifications

- **If randomness is disallowed or not preferred**, initial round can just defect outright (same as all other rounds), which is even more aggressive.
- **If observability of actions shows no one cooperated in round 1**, strategy still defects in next rounds since no incentive to change.
- No stateful memory needed since strategy is invariant in rounds 2 through r.
- This strategy sacrifices any gains from mutual cooperation and tries to maximize short-term gains.

---

**In summary**: this aggressive strategy is primarily a defector strategy maximizing exploitation of cooperating players, punishing all who cooperate via non-reciprocation, and refusing any cooperation except a minimal chance of testing in round 1. It embodies the aggressive mindset by never conceding payoff to others and always “playing hardball.”
'''

description_AGGRESSIVE_67 = '''
Here is a detailed aggressive strategy design for the N-player repeated Public Goods Game. The core idea is to maximize your own payoff by exploiting cooperators whenever possible, defecting aggressively to obtain the highest private benefit, and punishing cooperators only if necessary but never cooperating yourself except under narrowly defined tactical conditions.

---

### Strategic Intuition

- **Aggressiveness means "defect-first":** You never voluntarily contribute unless it maximizes your payoff strategically.
- **Exploit cooperators:** If others cooperate, you can defect and enjoy a higher payoff.
- **Discourage cooperation:** Do not subsidize cooperators by cooperating yourself — aside from limited initial exploratory cooperation to collect data.
- **Last-round defection:** Since no future rounds follow, defect aggressively in the last round to maximize immediate payoff.
- **Early-round exploration:** Cooperate once initially only if it can yield information about opponents, then defect thereafter regardless.

---

### Decision Rules

#### Round 1: Initial Exploration
- Cooperate (C) in round 1.
- **Reason:** Reveal baseline reactions of opponents to cooperation, to gain information about their tendency to cooperate or defect. This may also encourage some cooperation if others are "nice" strategies, helping future exploitation.

#### Rounds 2 to r-1: Aggressive Exploitation & Defection
- If **any opponent cooperated at any previous round**, **defect (D)**.
  - Rationale: Someone cooperated → exploit by defecting and enjoy a payoff boost.
- Else (no opponents ever cooperated previously), defect (D).
  - Rationale: No cooperators means no public good gain, defect is best.

#### Round r (last round): Always Defect (D)
- Defect to maximize payoff since no future retaliation is possible.

---

### Handling Edge Cases

- **If all players cooperated in round 1:** Continue defecting from round 2 onward to exploit their goodwill.
- **If all players defected in round 1:** Keep defecting every round (never cooperate after round 1).
- **If mixed cooperation/defection observed:** Always defect to maximize your own payoff.
- **If some opponents never cooperate:** No penalty, just keep defecting.
- No forgiveness or cooperation after round 1 regardless of opponent history.
- No cooperation in the last round to prevent exploitation.

---

### Pseudocode for Strategy

```python
# Inputs:
# history: list of past rounds, each round a list of actions of all n players, including self
# n: number of players
# r: total rounds
# t: current round number (1-based)
# self_index: index of your player in action lists

def aggressive_strategy(history, t, r, self_index):
    if t == 1:
        # Initial exploration cooperation
        action = 'C'  # cooperate
    elif t == r:
        # Last round: always defect
        action = 'D'
    else:
        # Check if any opponent cooperated in any previous round
        opponent_cooperated_before = False
        for past_round in history:
            for i, act in enumerate(past_round):
                if i != self_index and act == 'C':
                    opponent_cooperated_before = True
                    break
            if opponent_cooperated_before:
                break
        
        # Defect aggressively if any cooperation from others, else still defect
        action = 'D'
    
    return action
```

---

### Summary

| Round            | Condition                         | Action       | Why                            |
|------------------|---------------------------------|--------------|--------------------------------|
| 1                | First round                     | Cooperate (C)| Explore opponents' behavior     |
| 2 to r-1         | Opponent cooperated before?      | Defect (D)   | Exploit cooperators aggressively|
| 2 to r-1         | No opponent cooperated before    | Defect (D)   | Defect is best solo choice      |
| r (last round)   | Always                         | Defect (D)   | Maximize last round payoff      |

---

This approach aligns perfectly with an aggressive mindset:

- Starts with a slight cooperative "probe" to collect strategic info.
- Immediately switches to pure defection to maximize own payoff by free-riding.
- Never rewards cooperators long term.
- Never cooperates in the last round to avoid exploitation.

---

If you want, I can help you generate code templates or discuss variants—but this design is maximally aggressive given the game's structure and info constraints.
'''

description_AGGRESSIVE_68 = '''
Here is an aggressive strategy tailored to the N-Player Public Goods Game as specified. The core of this strategy is to seek maximum individual payoff by exploiting cooperators whenever possible, punishing defection only when it directly boosts personal payoffs, and defecting otherwise. It treats cooperation as a costly risk unless it clearly yields a sufficiently high payoff. The strategy is:

---

### Aggressive Strategy: "Exploit-When-Profitable, Defect-Otherwise"

---

#### Intuition

- Always defect on the **last round** since no future retaliation is possible.
- On **early rounds**, attempt to cooperate only if the majority previously cooperated (to leverage the multiplier effect and gain more than 1).
- Otherwise, defect to maximize private payoff and exploit occasional cooperators.
- If others are mostly defecting, quickly switch to permanent defection.
- Avoid being an unconditional cooperator; seek to maximize immediate returns.
- Punish defectors only if it would reduce their future payoffs enough to pay off (only relevant in early rounds).
- Forgiver or switch back to cooperation only if it clearly benefits immediate payoff.

---

### Decision Rules by Round and History

#### Notation
- Let `t` be the current round, `1 ≤ t ≤ r`.
- Let `coop_count(t-1)` = number of cooperators in previous round.
- Let `n` = total players.
- Threshold for cooperation proportion: `θ = 0.6` (tunable, favoring cooperation only if clear majority cooperate)
- Endowment contribution if cooperating: `c_i = 1`, defect = 0.

---

### Specific Rules

#### Round 1 (t = 1)
- **Play Defect (D)**
  - No information about others yet.
  - Exploit maximum private endowment immediately since no future moves to incentivize cooperation.
  
#### Rounds 2 ≤ t < r (Middle Rounds)
- Observe previous round's cooperation level: `c_prev = coop_count(t-1) / n`.
- If `c_prev ≥ θ` (majority cooperative):
  - Cooperate (**C**) this round to try to maintain public good and gain `(k/n) * coop_count`.
  - Cooperation payoff likely > 1.
- Else:
  - Defect (**D**), because cooperating when few others do yields payoff less than defecting.
  - Exploit defectors; avoid wasting endowment.
  
#### Round r (Last Round)
- Always Defect (**D**) to maximize last-round private payoff.
- No incentive to cooperate as no future rounds exist to punish defectors.

---

### Edge Cases

- If in previous round you cooperated but payoff dropped significantly due to defectors:
  - Immediately switch to permanent defection.
- If in later rounds (say past half of r), cooperation is never above threshold, defect permanently.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, k, history):
    # history is list of past rounds: each element is list of player actions ['C'/'D']

    theta = 0.6  # cooperation threshold
    
    # Last round: always defect
    if t == r:
        return 'D'
    
    # First round: always defect
    if t == 1:
        return 'D'

    # Calculate previous round cooperation rate
    prev_round = history[t-2]  # zero-index adjustment
    coop_count_prev = sum(1 for action in prev_round if action == 'C')
    coop_ratio = coop_count_prev / n

    # If last round cooperation was high, cooperate
    if coop_ratio >= theta:
        return 'C'
    else:
        return 'D'
```

---

### Strategic Analysis

- **Aggressiveness:** Defects by default to maximize private payoff; cooperates only if many others cooperate, using their contributions.
- **Punishment:** Indirect — if others don't cooperate en masse, it defects, penalizing lone cooperators.
- **Exploitation:** Takes advantage of cooperators but does not invite exploitation by cooperating when most defect.
- **No risky attempts:** Avoids risky cooperation early on; does not try to "start" cooperation unilaterally.
- **Simplicity:** Easy to compute but aggressive in maximizing payoff against unknown opponents.

---

This strategy maximizes short-term payoff with strategic conditional cooperation to grab the multiplier effect only when there is a clear benefit, otherwise defects aggressively to outperform naïve cooperators and prevent losses to defectors.
'''

description_AGGRESSIVE_69 = '''
Here is a robust **aggressive strategy** tailored for the N-player Public Goods game described. The core mindset is *maximizing individual returns*, aggressively exploiting cooperators while minimizing one’s own contributions. The strategy will typically defect but “punishes” cooperation only when it proves exploitable, and it exploits naïve cooperators fully.

---

## Strategy Description

### Core Idea:
- **Defect by default** to maximize private payoff and capture benefits from any cooperating players.
- **Detect cooperators and exploit them:** If others cooperate, reap maximum benefit by defecting.
- **Punish overly cooperative groups or “tit-for-tat” style cooperators:** When cooperation rises, consider short bursts of cooperation only if it leads to higher payoffs (rare), otherwise maintain defection.
- **No unconditional cooperation:** Never contribute first or as a default, only respond strategically.
- **Maintain defection in the last round**, as no future punishment or reward is possible.
- **Use early rounds to probe for cooperators** quietly by defecting and observing others’ actions.
- **Adjust behavior if all defect to avoid useless cooperation.**

### Step-by-step:

| Round                | Decision                                 |
|----------------------|------------------------------------------|
| **Round 1**          | Defect (D) - probe for cooperators, no risk taken |
| **Intermediate rounds (2..r-1)** |   
- If no one cooperated last round, defect again (D).  
- If some players cooperated last round, defect to exploit and maximize payoff (D).  
- If every other player cooperated last round, consider cooperating (C) **only if** payoff incentive exists (k/n × n > 1), yet still defect preferred because defecting increases payoff by +1. **So, always defect (D) here.**  
| **Final Round (r)**  | Defect (D) - no future repercussions, maximize immediate payoff |

---

## Rationale for Aggression

- Since k < n and k > 1, the **public good multiplier does not fully compensate the contribution** (i.e., contributing gives less than 1 immediate payoff, defecting yields 1 + share of others’ contributions).
- Defecting despite some cooperators yields the **highest individual payoff**, as shown in example: defecting with cooperators gets payoff = 1 + (k/n)×(#C), which is always ≥ cooperating payoff = (k/n) × (#C).
- Cooperating first round or late rounds is forgiving and exploitable.
- No cooperation to avoid being exploited.
- No complex reciprocity or trust building; simply always defect.
- This is **aggressive and exploitative**: takes advantage of any cooperative players fully.

---

## Pseudocode

```python
def aggressive_strategy(history, round_number, n, r, k):
    """
    history: List of length (round_number -1) of lists of actions ['C'/'D'] of all players
    round_number: current round index starting at 1
    n: number of players
    r: total rounds
    k: multiplication factor
    """
    # Always defect in round 1 (probe)
    if round_number == 1:
        return 'D'
    
    # Always defect in last round (no punishment possible)
    if round_number == r:
        return 'D'
    
    # Look at last round's actions
    last_round_actions = history[-1]  # list of 'C'/'D' for all n players

    # Count number of cooperators last round
    coop_count = last_round_actions.count('C')

    # If no one cooperated last round, defect to avoid wasted cooperation
    if coop_count == 0:
        return 'D'
    
    # If some cooperators exist, defect to maximize own gain via free-riding
    # (No incentive to cooperate due to individual payoff structure)
    return 'D'
```

---

## Summary

- **Always defect** every round.
- **Exploit all cooperative players** fully.
- **No cooperation to reduce contribution costs** or build trust.
- **No forgiveness or retaliatory cooperation** because cooperation is overpriced individually.
- **No cooperation in last round.**

This is the epitome of an *aggressive, selfish free-rider* maximizing short-term and long-term individual payoff in this public goods setting.

---

Would you like me to provide analysis of expected payoffs against typical classes of opponents or variants of this aggressive policy?
'''

description_AGGRESSIVE_70 = '''
Here is a fully specified **aggressive strategy** for the N-player repeated public goods game. The focus is on maximizing personal payoff by exploiting cooperators and punishing defectors, with explicit decision rules handling all rounds.

---

## Strategy Name: **Exploit & Punish Aggressor**

### Intuition
- **Never cooperate proactively** (never contribute altruistically).
- **Exploit cooperators** by defecting and gaining maximum private payoff plus share of public good.
- **Punish defectors by defecting as well**, to avoid being exploited.
- **Only cooperate as a forced retaliation if you observe full defection in previous round** (to restart possible gains), but aggressively return to defecting next round.
- Use a **last-round defection** to avoid being exploited.

---

### Decision Rules

#### Definitions
- Let `current_round` ∈ {1, 2, ..., r}
- Let `history` be a record of tuples of all players' actions from previous rounds
- Let `C_count(t)` = number of cooperators in round `t` (from history)
- Let `my_action(t)` = my own action in round `t` (from history)


#### At round 1:  
- **Defect (D) unconditionally**  
  *Reason:* No past info, aggressive stance demands exploiting altruists immediately.

#### For rounds `1 < t < r` (intermediate rounds):  

1. **If previous round had ALL defectors (C_count(t-1) = 0):**  
   - **Cooperate (C) once as a "lure" to restart cooperation**  
   - *Rationale:* If everyone defected last round, mutual defection yields minimum collective payoff; injecting one C can trick some to cooperate next round, allowing exploitation.

2. **Else (some cooperators exist last round):**  
   - **Defect (D) to exploit cooperators**  
   - *Rationale:* By defecting, gain private payoff + share of cooperators' contributions.

#### At round `r` (last round):

- **Defect (D) unconditionally**  
  *Reason:* No future punishment possible; maximize immediate payoff by defecting.

---

### Summary

| Round               | Condition                    | Action       | Comment                          |
|---------------------|------------------------------|--------------|---------------------------------|
| 1                   | no history                   | D            | Start aggressive                |
| 2 ≤ t < r           | all defect previous round    | C            | Try to restart cooperation     |
| 2 ≤ t < r           | else                        | D            | Exploit cooperators             |
| r (last round)       | any                         | D            | Final round defection           |

---

## Pseudocode

```python
def aggressive_strategy(current_round, r, history):
    if current_round == 1:
        return 'D'  # Defect first round

    if current_round == r:
        return 'D'  # Defect last round unconditionally

    prev_round_actions = history[current_round - 2]  # zero-based index
    C_count_prev = sum(1 for action in prev_round_actions if action == 'C')

    if C_count_prev == 0:
        return 'C'  # lure with cooperation to restart cooperation
    else:
        return 'D'  # exploit cooperators with defection
```

---

## Explanation of Aggressiveness

- **Never sacrifice private payoff unnecessarily**: always defect unless forced to cooperate as a tactical bait.
- **Exploit any cooperation immediately** by defecting next round to get both private endowment and share of public good.
- **Punish collective defection by single round cooperation**, aiming to break all-defect deadlock for future exploitation.
- **Ensure last round defection** avoids exploitation when no future punishment possible.
- The strategy is **strict and unforgiving**, maximizing own payoff at others' expense.

---

## Notes on Strategy Behavior

- If many players defect constantly, strategy cooperates once in a while to try to stimulate cooperation — but at personal risk.
- Against fully defecting opponents, behaves almost fully defecting, losing no ground.
- Against cooperative opponents, exploits them round after round.
- This strategy forces opponents to cooperate less, or risk being exploited.

---

Let me know if you want variants, formal proofs, or adaptations!
'''

description_AGGRESSIVE_71 = '''
**Aggressive Strategy for the N-Player Public Goods Game**

---

### Intuition and Overview

An *aggressive* strategy here aims to maximize individual payoffs at the expense of group cooperation, exploiting others whenever possible, and punishing cooperators when beneficial to assert dominance.

- Since defecting always grants a guaranteed private payoff of 1 plus the share of public good contributions, defecting is financially more attractive especially when others cooperate.
- Cooperating costs you your private payoff (0 from contribution), so you should only cooperate to extract long-term benefits if that benefits you relative to others.
- Because the game repeats, some grudges or punishments may deter excessive cooperation by others and force them to defect.
- The aggressive mindset is **exploit first, punish second, never help unconditionally**.

---

### Decision Rules

Defining variables:
- Let **round t ∈ {1,...,r}**
- Let **c_i,t ∈ {0,1}** be your contribution (1=cooperate C, 0=defect D) at round t
- Let **H_t-1** be the full history of actions by all players up to round t-1
- Let **C_t-1** be the set of cooperators in round t-1 (excluding self)
- Let **P** be set of players punished (marked as exploiters) so far

---

#### 1. **First round (t=1): Defect aggressively**

- Start by defecting: `c_i,1 = 0`
- Reason: No information on others, maximize private payoff and exploit naive cooperators

---

#### 2. **Subsequent rounds (t=2,...,r)**:

- Maintain a **punishment list P** of players who cooperated last round or who "betrayed" you by cooperating while you defected

- In round t:

  a. **If opponents cooperated in round t-1**, mark them as exploitable:  
     Add these players to P

  b. **Targeted punishing defect:**  
     Defect unconditionally, but treat players in P differently: if they cooperate, keep defecting against them to deny them public good benefits.

  c. **If everyone defected last round (including self):**  
     Keep defecting (no gain from cooperating alone)

---

#### 3. **Last round (t=r): Defect unconditionally**

- No future rounds to incentivize cooperation, so defect.

---

### Pseudocode

```
Initialize:
  P = empty set   // punishment/exploiter list

For each round t in 1...r:
  
  if t == 1:
    c_i = 0       // Defect first round
    observe opponents' actions in round 1 after move

  else:
    // Update punishment list P
    For each player j ≠ i:
      if c_j,(t-1) == 1:        // If opponent cooperated last round
        P.add(j)

    // Aggressive decision:
    // Always defect
    c_i = 0

  if t == r:
    // Last round: defect aggressively, no cooperation
    c_i = 0

  Submit action c_i simultaneously with others

  Observe all players' actions for next round's update
```

---

### Explanation

- **Always defect** so you never pay the cost of cooperation.
- **Mark cooperators as enemies/exploitable** to track who can be exploited via your defecting—treat them as targets but since you never cooperate, you free-ride on their contributions.
- Because only defecting players get protection from punishment by denying public goods shares, cooperators are economically punished.
- This discourages cooperation from others, maximizing your exploitation payoff.
- No cooperation means no trust or reciprocity—purely aggressive exploitation.
- Last round defect avoids being exploited at end.

---

### Edge Cases

- **First round**: No history, defect to exploit potential cooperators.
- **Last round**: Defect for sure—no incentive to cooperate at the end.
- **All defect last round**: Continue defecting; no incentive to shift.
- **Opponents always defect**: Continue defecting, no cooperation possible.
- **Opponents cooperate intermittently**: Exploit by defecting and marking them for punishment next rounds.

---

### Summary

| Round           | Action                           | Reason                     |
|-----------------|--------------------------------|----------------------------|
| First round     | Defect                         | Maximize payoff, exploit guesswork |
| Intermediate rounds | Always defect; add cooperators to punishment list P | Exploit cooperators, punish to prevent cooperation |
| Last round      | Defect                         | No future incentive to cooperate |

This aggressive strategy ensures individual maximization by free-riding on cooperators, never cooperating yourself, and punishing cooperators to reduce their returns, fostering an environment hostile to cooperation.
'''

description_AGGRESSIVE_72 = '''
Here is an **aggressive strategy** for the N-Player Public Goods game. The strategy focuses on maximizing individual payoff aggressively, exploiting cooperators, and avoiding exploitation by defecting strategically. It is designed under the constraints of perfect information and repeated play, yet without any communication or coordination.

---

# Aggressive Strategy: "Exploit-Trigger-Defect" (ETD)

---

## Intuition and High-Level Description

- **Goal:** Maximize own payoff by defecting whenever possible, but not missing chances to exploit cooperation or induce exploitors to stop cooperating.

- **Aggressiveness:**  
  - Always defect unless there is clear evidence that cooperating yields a strictly better payoff on current round (based on past observed behavior).  
  - Exploit cooperators by defecting while benefiting from their contributions.  
  - Punish persistent defectors who could reduce total public good to a level that hurts you by threatening to cooperate in rare cases to raise the group payoff, forcing others to cooperate or be exploited more.

- **Behavior under Uncertainty:** First round, when no history is available, defect aggressively since cooperation is costly and trusting cooperators is too risky.

---

## Decision Rules

### Variables Used:

- `t` = current round (1 to r)
- `history` = record of all players’ actions in past rounds: actions[t-1][i]
- `num_cooperators_last_round` = number of players who cooperated last round
- `my_last_action` = your action in the last round
- `my_payoff_last_round` = player i’s payoff last round
- `observed_behavior` = vector or summary statistics of opponent cooperation rates over past rounds
- `k, n, r` = game parameters as given

---

### Detailed Rules:

#### 1st Round (t = 1):
- No history available.
- **Action:** Defect (D)
  
Rationale: Aggressively guard against first-round exploitation. Cooperating without info is costly and inviting exploitation.

---

#### Subsequent rounds (2 ≤ t < r):

1. Calculate the number of cooperators in the last round: `num_cooperators_last_round`.
2. Calculate your last-round payoff and compare it to potential payoffs:
   - If you defected last round:
     - Your payoff was `1 + (k/n) * num_cooperators_last_round`
   - If you cooperated last round:
     - Your payoff was `(k/n) * num_cooperators_last_round`
3. **Decision:**
   - If defecting last round gave you **equal or better payoff** than cooperating:
     - Defect again (D).
     - Rationale: Being aggressive means exploiting cooperators for max gain; cooperating did not improve payoff.
   - Else if cooperating last round gave you strictly better payoff:
     - Cooperate (C).
     - Rationale: Rarely cooperate only when it demonstrably benefits you.
4. If there were **no cooperators (num_cooperators_last_round == 0)** in last round (all defected):
   - Defect again.
   - Rationale: No incentive to contribute if no one cooperates.
5. If majority (>50%) cooperated last round but defecting gave you the highest payoff:
   - Defect again to exploit.
6. Track individual players' cooperation frequency.  
   If a player never cooperates or defects in majority of rounds, treat them as defectors; otherwise, potential cooperators.  
   Use this only if your design supports tracking opponents individually.

---

#### Last Round (t = r):

- Defect (D)
  
Rationale: No future punishment possible, so no incentive to cooperate. Aggression strongest in last round.

---

## Pseudocode

```python
def aggressive_strategy(t, r, k, n, history, my_index):
    if t == 1:
        return 'D'  # First round: defect aggressively
    
    last_round = t - 1
    last_actions = history[last_round]
    num_cooperators_last_round = sum(1 for a in last_actions if a == 'C')
    my_last_action = last_actions[my_index]
    
    # Calculate payoffs from last round
    # π_i = (1 - c_i) + (k/n) * total_c
    my_c = 1 if my_last_action == 'C' else 0
    my_payoff_last = (1 - my_c) + (k / n) * num_cooperators_last_round
    
    # Hypothetical payoffs if cooperated or defected last round
    payoff_if_cooperate = (k / n) * num_cooperators_last_round  # c_i = 1
    payoff_if_defect = 1 + (k / n) * num_cooperators_last_round  # c_i = 0

    # By definition payoff_if_defect > payoff_if_cooperate by 1 unit
    # But if num_cooperators_last_round changes significantly round to round,
    # we consider only my last action payoff and observed num cooperators
    
    if t == r:
        return 'D'  # Last round: always defect aggressively
    
    if num_cooperators_last_round == 0:
        # Nobody cooperated last round -> defect again
        return 'D'
    
    # If defecting gave payoff >= cooperating payoff, defect again to exploit cooperators
    if my_last_action == 'D':
        # Already defected, payoff is payoff_if_defect
        return 'D'
    else:
        # Last round cooperated, payoff is payoff_if_cooperate
        # Aggressive: defect if payoff_if_defect >= payoff_if_cooperate
        # Actually, payoff_if_defect is always 1 greater by 1 unit,
        # so defect again except tolerate cooperation when it strictly benefits us? 
        # But without knowing opponents' next moves precisely, defect is better.
        return 'D'
```

---

## Explanation of Aggressiveness

- Always prioritize defecting to maximize private gain.
- Exploit others’ cooperation: never "waste" your endowment contributing unless compelled by observed future gains—which are hard to realize given you’re playing against unknown opponents with no communication or binding contracts.
- Cooperate neither in the first nor the last round.
- Cooperate only if in some advanced modification you detect that cooperation increases your expected payoff strictly, but under base assumptions, defecting dominates.
- Punishment is implicit: defect to deny cooperators the benefit of returns on public goods.
- This approach is ruthless, taking advantage of cooperators and refusing to be a sucker.

---

## Summary

| Round     | Action Rule                        | Reason                 |
|-----------|----------------------------------|------------------------|
| 1         | Defect                           | No information, high risk |
| 2 to r-1  | Defect if defect last round; else defect | Exploit cooperators, maximize payoff |
| Last (r)  | Defect                           | No future incentive to cooperate |

---

This strategy is **unforgiving, exploitative, and aggressive**, designed to maximize your own payoff in the tournament by leveraging the knowledge of others’ past cooperation but refusing to ever make costly contributions yourself.
'''

description_AGGRESSIVE_73 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Intuition and Goals

- **Aggressive mindset:** Maximize own payoff by exploiting cooperators (defectors don't contribute but still reap the public good), while punishing cooperators who do not increase your payoff.
- **Goal:** Defect as much as possible to gain the 1 private payoff, only cooperate strategically if that increases long-term returns.
- **Avoid wasted cooperation:** Do not cooperate in early or final rounds unless absolutely beneficial.
- **Punishment:** Never reward cooperation of others by cooperating yourself unless it is strictly profitable.
- **Exploitation:** Exploit cooperative players when possible.

---

### Key Observations from the Game Structure

- Defecting always yields +1 private payoff plus share of public good.
- Cooperating yields 0 private payoff plus the same share of public good — so cooperating is only beneficial if *other players cooperate enough to make your payoff > 1*.
- If few cooperate, defect is always better.
- If all cooperate, everyone gets payoff = k (which is > 1 but < n).
- When others cooperate, defectors get strictly higher payoff than cooperators (e.g., example 3 above).

---

### Strategy Outline

---

#### 1. First Round (t=1)

- **Defect**.
- Reason: No information yet; aggressive mindset says start by exploiting presumptive cooperators.

---

#### 2. Rounds 2 to r-1 (middle rounds)

- Observe history of all players' actions.
- Calculate **cooperation rate in last round**: total cooperators / n.

- **Threshold to Cooperate:**

  Cooperate only if the **cooperation rate in previous round ≥ cooperation_threshold**, where:

  cooperation_threshold = ceil(n / k)

  Explanation:
  - The multiplication factor **k < n**.
  - To make cooperation profitable for ourselves as a cooperator, the expected public good share must exceed 1 private unit lost by cooperating.
  - Minimum number of cooperators needed for payoff as cooperator to be ≥ payoff as defector:  
    (k / n) * total_cooperators ≥ 1  
    → total_cooperators ≥ n / k

- **Decision Rules:**

  - If last round's cooperation count ≥ cooperation_threshold:  
    - **Defect** to exploit cooperators (max payoff = 1 + k/n * total_cooperators).
  - Else:  
    - **Defect** (no incentive to cooperate with insufficient others cooperating).

- **Summary:** Always defect except consider cooperating only if guaranteed profit from cooperation, which practically does not happen given aggressive mindset (it’s always better to defect even if many cooperate).

(Note: As aggressive, we never share profits; defecting is always strictly better if others cooperate.)

---

#### 3. Last Round (t = r)

- **Always Defect**, because there is no future punishment or reward; defectors get strictly better payoff than cooperators.

---

### Pseudocode

```python
def aggressive_strategy(round_number, history, n, r, k):
    """
    round_number: current round (1-based)
    history: list of previous rounds' actions by all players.
             Each element is a list of n actions ['C' or 'D'].
    n: number of players
    r: total rounds
    k: multiplication factor

    Returns: action 'C' or 'D'
    """

    if round_number == 1:
        # First round: defect to exploit presumptive cooperators
        return 'D'

    if round_number == r:
        # Last round: always defect
        return 'D'

    # Calculate total cooperators in previous round
    last_round = history[-1]  # list of actions from all players
    total_cooperators = sum(1 for a in last_round if a == 'C')

    # Threshold to consider cooperating is ceiling(n / k)
    import math
    cooperation_threshold = math.ceil(n / k)

    # Aggressive mindset: never cooperate in middle rounds; always defect to exploit.
    # Optionally, if total_cooperators very high (≥ threshold), you could consider cooperating,
    # but since defecting yields more payoff, always defect.

    return 'D'
```

---

### Additional Notes

- This strategy is **pure defection** except for potentially some edge cases if other players cooperate en masse in previous rounds—but even then, defecting yields strictly higher payoff.
- It exploits cooperation by never contributing itself.
- This encourages aggressive exploitation, punishing "nice" or "forgiving" strategies.
- No cooperation is given as a concession because of aggressive mindset.
- If the tournament includes cooperators, this strategy will outperform by free-riding on their contributions.

---

### Summary

| Round           | Action                                            |
|-----------------|--------------------------------------------------|
| 1 (first)       | Defect                                           |
| 2 to r-1 (mid)  | Defect regardless of previous rounds' cooperation|
| r (last)        | Defect                                           |

---

This aggressive strategy maximizes individual payoffs by always defecting and exploiting any cooperative contributions of others.
'''

description_AGGRESSIVE_74 = '''
Here is an **aggressive strategy** tailored for the described N-player repeated Public Goods game. It is designed to maximize your own payoffs by exploiting cooperators and defecting whenever it is safe or beneficial according to the game structure.

---

# Aggressive Strategy Description

---

### Key Idea:
- Start by cooperating to test others' willingness to cooperate.
- Aggressively defect as soon as there is any sign of exploitation or to extract maximum payoff.
- Defect in the last round to avoid being exploited without future retaliation prospects.
- Use the history of others' actions as a guide — but do not hesitate to defect preemptively to maximize short-term gains.

This balances some initial goodwill to gather information against maximizing returns via defection when possible.

---

### Detailed Decision Rules

---

| Round | Decision Rule                                       | Reasoning                                  |
|-------|----------------------------------------------------|--------------------------------------------|
| 1     | **Cooperate (C)**                                   | Test if others cooperate, appear "nice" initially to invite cooperation and gain future benefits. |
| 2 to r-1 | **If all players cooperated in previous round:** Cooperate (C)  
Else: Defect (D) | Reward full cooperation by cooperating; Otherwise, punish defectors aggressively by defecting to maximize your share. |
| r (last round) | Defect (D)                                      | No future rounds to incentivize cooperation; maximize immediate payoff. |

---

### Walkthrough by round:

- **Round 1:** Cooperate to "signal" willingness to cooperate and potentially induce cooperation.
- **Rounds 2 to r-1:**  
  - Check if everyone cooperated in last round:  
    - Yes → cooperate to maintain mutual benefit and avoid mutual defection stalemate.  
    - No → defect aggressively, as defectors cannot be trusted and you want to exploit any cooperation they give.
- **Round r (last round):** Always defect to grab maximal payoff, since there is no punishment or future benefit to cooperation.

---

### Edge Cases:

- **If the group never cooperates initially:** Your first cooperation is likely exploited, so defect from round 2 onwards.
- **If partial cooperation is observed (not full):** Treat it as defection and start defecting immediately to maximize payoff.
- **If full cooperation from all players in all rounds except final:** Maintain cooperation until last round.

---

### Pseudocode:

```python
def aggressive_strategy(history, round_number, n, r):
    # history: list of previous rounds, each round is list of actions for all players ['C' or 'D']
    # round_number: current round index, from 1 to r
    
    if round_number == 1:
        # First round cooperate to probe willingness
        return 'C'
    
    if round_number == r:
        # Last round, defect to maximize payoff
        return 'D'
    
    # For rounds 2 to r-1:
    # Check if all players cooperated last round
    last_round_actions = history[-1]
    if all(action == 'C' for action in last_round_actions):
        return 'C'  # Reward all cooperating by cooperating
    else:
        return 'D'  # Defect aggressively if any defection observed
```

---

### Why is this aggressive?

- It quickly retaliates by defecting whenever there is any defection detected.
- It exploits partial cooperators — defectors in your group get no second chance.
- It defects in the last round without hesitation to maximize immediate payout.
- It only cooperates when full cooperation was observed previously, which is rare in a competitive environment where other aggressive or exploitative strategies abound.

---

### Summary

| Condition        | Action |
|------------------|---------|
| Round 1          | Cooperate (C) |
| Round r (last)   | Defect (D)   |
| Full cooperation last round (2 ≤ t < r) | Cooperate (C) |
| Otherwise        | Defect (D)   |

---

This strategy leverages initial goodwill to detect cooperation but aggressively defects at the first sign of exploitation or when it can yield higher immediate payoff without future cooperation loss risk. It embodies an "aggressive but opportunistic" approach aligned with maximizing personal payoff in the repeated public goods environment described.
'''

description_AGGRESSIVE_75 = '''
Here is an aggressive strategy for the repeated N-Player Public Goods Game which seeks to maximize your own payoff by exploiting cooperators while avoiding exploitation yourself. The strategy goes beyond simple one-shot defection and tries to capitalize on retaliation and exploitation patterns typical in repeated settings.

---

## Aggressive Strategy Description

### Key Intuition
- Defect by default to secure the guaranteed private payoff of 1.
- Exploit cooperators by defecting when others cooperate (gain more by free-riding).
- Occasionally cooperate to disguise pure defection and try to induce cooperation from others, then exploit them again.
- Retaliate immediately and permanently (or nearly so) against defectors who punish your defection.
- Defect in the last round to maximize final payoff ("endgame defection").
  
This approach aggressively hunts for others who cooperate and exploits them while preventing others from exploiting you.

---

### Decision Rules

Let round index be t (1 ≤ t ≤ r)

Let `H` be full history of all players' actions up to round t-1

Let `C_t-1` = number of cooperators (players who played C) in previous round t-1

Let `Self_Last_Action` = your action in round t-1 (undefined for t=1)

---

#### Round 1 (t=1)

- **Action:** Defect (D)
  
Rationale: No history, no reason to cooperate; take the safe private payoff.

---

#### Rounds 2 to r-1 (2 ≤ t ≤ r-1)

- Observe previous round's actions.
- If in the previous round you cooperated and were "exploited" (i.e., you contributed but got less payoff than at least one defector because others defected), respond by defecting forever (or at least for all remaining rounds).
- If in the previous round you defected and others cooperated in significant numbers, continue defecting to exploit them.
- If everyone defected in the previous round, defect again to avoid being exploited.
- Occasionally (e.g., every m rounds, where m is a small integer like 3 or 4) cooperate if you perceive others are cooperating mostly to induce cooperation and switch to exploitation.
- Retaliate rapidly if you detect someone is trying to punish you.

Pseudocode (for rounds 2 to r-1):

```
if Self_Last_Action == C and payoff_last_round < max_payoff_last_round:
    // You cooperated but got exploited => switch to permanent defection
    action = D
else if C_t-1 >= threshold_cooperators:
    // Many cooperators last round => exploit by defecting
    action = D
else:
    // Few cooperators last round
    if (t mod m == 0):
        action = C  // occasional cooperation to lure cooperators
    else:
        action = D
```

Here, `threshold_cooperators` can be set to a number like (n/2) to distinguish cooperation-rich rounds.

---

#### Last Round (t = r)

- Always defect to maximize last round payoff (endgame defection).

---

### Handling Edge Cases

- **First round:** Defect to avoid being exploited.
- **Last round:** Defect regardless of history because no future punishment possible.
- **If isolated cooperator:** If you detect only yourself cooperated last round (everyone else defected), switch to defection to avoid being exploited.
- **If universal cooperation:** If all cooperated last round, defect this round to gain the highest payoff possible by free-riding.
- **Against other aggressive defectors:** Persist defection; no incentive to cooperate.

---

### Summary

| Situation                              | Action        | Reason                                 |
|--------------------------------------|---------------|--------------------------------------|
| Round 1                              | Defect        | No info, safe choice                  |
| You cooperated last round & exploited| Defect forever| Prevent further exploitation          |
| Many cooperators last round          | Defect        | Exploit cooperators                   |
| Few cooperators last round           | Defect or occasional cooperate | Probe for cooperation occasionally |
| Last round                          | Defect        | Maximize last round payoff            |

---

## Full Pseudocode

```
Parameters:
- n: number of players
- r: number of rounds
- k: multiplication factor
- m: cooperation probing interval (e.g., 4)

Initialize:
- permanent_defect = False

For each round t in 1 to r:

    if t == 1:
        action = D  // initial defection
    
    else if t == r:
        action = D  // last round defection
    
    else:
        if permanent_defect:
            action = D
        else:
            C_last = count_cooperators_in_round(t-1)
            payoff_self_last = payoff_of_self_in_round(t-1)
            max_payoff_last = max_payoff_in_round(t-1)
            self_last_action = action_of_self_in_round(t-1)
            
            if self_last_action == C and payoff_self_last < max_payoff_last:
                permanent_defect = True
                action = D
                
            else if C_last >= ceil(n/2):
                // many cooperators to exploit
                action = D
            
            else:
                if (t % m == 0):
                    action = C  // probe cooperation
                else:
                    action = D
```

---

## Why is this aggressive?

- It defects by default taking safe payoff, never forgives exploitation.
- It systematically exploits cooperating players whenever possible.
- It uses occasional cooperation as a ruse to induce others to cooperate, then exploits them.
- It defects in the last round to prevent others from gaining by cooperation.
- It applies harsh and permanent retaliation to deter punishment.

---

This strategy expects that many opponents will cooperate at least sometimes, potentially allowing you to harvest above the mutual defection payoff. At the same time, it is hardened against sucker payoffs and punishing opponents.

---

If you want, I can help further refine or adapt this strategy depending on specific n, r, or tournament meta considerations.
'''

description_AGGRESSIVE_76 = '''
Here is a detailed design of an **aggressive** strategy for the repeated N-player Public Goods game that fits the specified constraints and assumptions.

---

## Strategy Overview

**Core mindset:**  
Act aggressively to maximize your individual payoff by exploiting cooperators and discouraging cooperation by defecting to deny them returns. Do not cooperate unless forced into a beneficial forced cooperation to avoid excessive exploitation if your opponents become smarter. You aggressively defect by default and only tolerate a minimal level of cooperation when it is clearly beneficial to you in terms of payoff.

---

## Decision Rules and Logic

### Notation

- Let `t` be the current round (1 ≤ t ≤ r).
- Let `history` be the record of all previous rounds: for each round, the list of all players' actions.
- Let `n` be the player count; `k` the multiplication factor.
- Let `C_count(t)` = number of players who cooperated in round t.
- Let `my_action(t)` be your own action in round t.
- Let `π_i(t)` be your own payoff in round t.
- Let `threshold` be a cooperation threshold defined below.

---

### Step 1: Initial move (Round 1)

- Defect (`D`).

*Rationale:* Aggression means you do not waste capital contributing without seeing others’ willingness to cooperate first.

---

### Step 2: Subsequent rounds (t > 1)

1. **Assess prior round cooperation level:**

   - Compute `C_count(t-1)` = number of cooperators in the previous round.
   - Compute your own payoff last round:  
     π_i(t-1) = (1 - c_i(t-1)) + (k/n) × C_count(t-1)

2. **Calculate a threshold for cooperating this round:**

   Because `k < n` and each cooperator sacrifices 1 to generate `k` total public good that is shared evenly, defectors can earn more than cooperators in mixed groups.

   Define:

   - `min_coop_for_positive_gain` = minimum number of cooperators (including you) needed such that cooperating yields **at least the payoff of defecting.**

   The payoff formulas:

   - If you cooperate:  
     π_C = 0 + (k/n)*C_count

   - If you defect:  
     π_D = 1 + (k/n)*C_count

   Since defectors get +1 private, cooperating only pays off if the additional public good compensates.

   To find minimum C_count to justify cooperation:  
   Set π_C ≥ π_D when cooperating:  
   (k/n)*C_count ≥ 1 + (k/n)*(C_count - 1)  
   => (k/n)*C_count ≥ 1 + (k/n)*C_count - (k/n)  
   => 0 ≥ 1 - (k/n)  
   => (k/n) ≥ 1

   Which contradicts `k < n`, so cooperating never yields *strictly* higher payoff than defecting in the same round unilaterally (unless n=k, which is not allowed).

   But cooperating may pay off if many players cooperate, so we determine if cooperating yields close payoffs.

   For a rough threshold, cooperate only if last round had sufficiently high cooperation, indicating others are mostly cooperating and the public goods payoff is high.

   Define a cooperation threshold on past round as:

   ```
   threshold = ceil(n * 0.75)
   ```

   (You expect at least 75% cooperation last round to justify cooperating.)

3. **Aggressive defection policy:**

   - If `C_count(t-1) >= threshold`, cooperate this round (play `C`) **once** to try to "exploit" a cooperative environment.

   - Else, defect (play `D`) to punish or exploit defectors and maximize immediate gain.

4. **Repeat step 3 until last round.**

---

### Step 3: Last round (`t == r`)

- Defect always (play `D`).

*Rationale:* No incentive to cooperate in the last round because there are no future rounds to leverage cooperation for future gains.

---

## Summary of Strategy

| Round       | Condition                           | Action      | Rationale                      |
|-------------|------------------------------------|-------------|--------------------------------|
| 1           | Always                            | Defect (D)  | Aggressive initial move        |
| 2..r-1      | If previous round cooperation ≥ 75% of players | Cooperate (C) once | Exploit cooperation opportunity |
| 2..r-1      | Otherwise                        | Defect (D)  | Maximize exploitation          |
| r (last)    | Always                           | Defect (D)  | No future rounds, always defect |

---

## Pseudocode

```python
def aggressive_strategy(t, r, n, k, history):
    """
    Inputs:
      t: current round (1-based)
      r: total rounds
      n: number of players
      k: multiplication factor
      history: list of previous rounds; each round is list of actions ['C' or 'D'] for all players
    Output:
      'C' or 'D' action for current round
    """

    if t == 1:
        # Round 1: defect aggressively
        return 'D'

    if t == r:
        # Last round: always defect
        return 'D'

    # Count cooperators in previous round
    last_round = history[t-2]  # zero-index correction
    C_count = sum(1 for a in last_round if a == 'C')

    # Define threshold for cooperation
    threshold = int(0.75 * n)

    if C_count >= threshold:
        # Play once cooperatively if prior cooperation high enough
        # To avoid endless cooperation, cooperate only once after high cooperation round
        # Define if previously defected or cooperated to only cooperate once after high cooperation
        previous_action = history[-1][your_index] if t > 1 else 'D'

        # If last time you played defect, now cooperate to exploit cooperation environment
        if previous_action == 'D':
            return 'C'
        else:
            # Otherwise keep defecting aggressively
            return 'D'
    else:
        # Otherwise defect
        return 'D'
```

---

## Additional Notes

- This strategy is **aggressive** because it **prefers defecting at all times** except to try to exploit a high-cooperation round with a **single cooperative act** to maximize payoff.

- It **never "trusts" cooperation blindly**, punishes low cooperation levels by defecting.

- Because of **perfect information and no communication**, the player tries to maximize short-run exploitation while sometimes attempting to get a boost from cooperating if it can yield a higher return in a highly cooperative crowd.

- By cooperating only once after a high cooperation round, it avoids becoming a sucker repeatedly.

- This strategy embodies an aggressive "defect-first, exploit cooperation opportunistically" mindset consistently through the repeated game.

---

If you want, I can help also provide variations or extensions. But this design should work well in a tournament of independent strategies with standard assumptions given.
'''

description_AGGRESSIVE_77 = '''
Here is an aggressive strategy designed for the N-Player Public Goods Game as specified.

---

### Key Idea
The strategy aggressively maximizes own payoff by largely **defecting**, but uses a minimal degree of cooperativeness early on to avoid being exploited blindly and to glean information about opponents' tendencies. It exploits others’ attempts to cooperate and punishes sustained cooperation by opponents to maximize personal gain. It also exploits the possibility of last-round defection.

---

### 1. Decision Rules

- **Round 1 (Initial probing):**  
  Cooperate **once** to test others' willingness to cooperate and observe the initial environment. This can encourage some cooperation, but is primarily informational.

- **Middle Rounds (2 to r-1):**  
  - If in the previous round, a **majority (> 50%) of players cooperated**, **defect** to exploit their contributions and maximize immediate payoff.  
  - Otherwise (majority defected previously), also **defect** to avoid being exploited.

- **Last Round (r):**  
  Defect **unconditionally** to extract maximal private payoff; no incentive to cooperate on the last round since no future punishment or reward matters.

---

### Rationale

- Cooperating only in the first round is a calculated sacrifice providing information and an early chance to influence others.
- Defecting whenever there is a majority cooperating forces others either to stop cooperating or suffer exploitation.
- Defecting when there's no cooperation prevents being suckered.
- Unconditional defection in the last round aligns with classic backward induction reasoning.
- No forgiveness or complicated history tracking ensures an aggressive stance: the strategy exploits cooperators and never yields.

---

### Formal Pseudocode

```python
def aggressive_strategy(round_number, history):
    """
    Args:
        round_number: integer, current round index (1-based)
        history: list of past rounds, each element is a list of actions by all players,
                 where each action is 'C' or 'D' (including own previous actions)
                 - length = round_number - 1

    Returns:
        action: 'C' or 'D'
    """
    
    # First round: cooperate once
    if round_number == 1:
        return 'C'
    
    # Last round: defect unconditionally
    if round_number == r:  # r = total number of rounds (known)
        return 'D'
    
    # For rounds 2 to r-1, examine previous round contributions
    previous_round_actions = history[-1]  # actions of all players in previous round
    num_cooperators = sum(1 for a in previous_round_actions if a == 'C')
    majority_cooperated = (num_cooperators > n/2)  # n = total players
    
    if majority_cooperated:
        # Exploit cooperating majority by defecting
        return 'D'
    else:
        # No majority cooperation: defect to avoid sucker payoff
        return 'D'
```

---

### Summary of Behavior

| Round        | Condition                    | Action    | Explanation                       |
|--------------|------------------------------|-----------|----------------------------------|
| Round 1      | Always                      | Cooperate | Probe opponents' cooperation     |
| Round 2 to r-1| Majority cooperated in previous round? | Defect   | Exploit majority contributors     |
| Round 2 to r-1| Otherwise                  | Defect    | Avoid exploitation                |
| Round r      | Always                      | Defect    | Maximize immediate payoff, no future |

---

### Expected Outcome

- This strategy exploits cooperative players relentlessly.
- It never willingly contributes beyond initial probing.
- Opponents who cooperate risk being exploited.
- Opponents who defect meet defection, yielding neutral payoffs.
- The single initial cooperation may induce some cooperation initially, which is then exploited.
- Overall, this aggressive strategy prioritizes highest individual payoff over group payoff.

---

If you want, I can help design variants or discuss potential counter-strategies opponents might use against this aggressive approach.
'''

description_AGGRESSIVE_78 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Strategy Description

This strategy aims to maximize a player's own total payoff by leveraging the game's payoff structure aggressively. It treats cooperation as a surrender—since contributing (C) costs 1 unit privately but yields a multiplied fraction back (k/n), while defecting (D) lets you keep 1 unit plus a share of others' contributions.

Given the parameters (1 < k < n), defecting individually is always more profitable in the one-shot game because:

- If you cooperate: payoff = 0 + (k/n)*total_c
- If you defect: payoff = 1 + (k/n)*total_c

Because 1 > 0 and the multiplied return is shared evenly, defectors get a strictly higher payoff than cooperators in the same group of contributors.

**Therefore, an aggressive strategy aggressively exploits cooperators and seeks to minimize those who cooperate.**

---

### Key Guidelines

- **Always defect unless all others cooperated in last round (to punish unconditional defectors only if it benefits me).**
- **Use defection throughout to maximize short-term gains.**
- **Attempt minimal cooperation only if it can provoke full cooperation for a payoff spike, but given the aggressive mindset, this is unlikely.**
- **In the final round, defect to maximize immediate payoff without fear of retaliation.**

---

### Detailed Decision Rules

#### Round 1 (No history)
- Defect (D).
- Reason: No incentive to cooperate without history; cooperation risks losing 1 unit.

#### Rounds 2 through (r - 1)
- If **all other players cooperated in the previous round** (everyone but me played C last round), **cooperate (C)** this round.
- Otherwise, **defect (D)**.

**Rationale:**  
- Cooperating only if the entire group (except self) was fully cooperative last round, aiming to exploit possible "nice" strategies by temporarily cooperating for higher group earnings.
- In all other cases, defect to maximize payoff and discourage being exploited.
- This "cooperate if everyone else cooperated" rule is a strong trigger that attempts to extract reward from mutual cooperation only when the environment signals near universal cooperation.

#### Final Round (Round r)
- Defect (D).
- Reason: No future punishment or reward, so maximize immediate payoff.

---

### Motivation for Strategy

- The **dominant strategy** in the one-shot version is to defect because the private benefit of keeping 1 unit outweighs the share received from the public good.
- In repeated play, some strategies might cooperate hoping for cooperation back.
- This aggressive strategy exploits cooperators and punishes "partial" cooperation by defecting immediately unless all others last round cooperated.
- By cooperating only if all others cooperated last round, the strategy attempts to trigger cooperation cycles only when the population is very cooperative, else exploits the defectors.
- Defecting on the final round eliminates sucker's payoff risk.

---

### Pseudocode

```python
def aggressive_strategy(round_num, history, n, r):
    """
    :param round_num: current round number (1-based)
    :param history: list of lists of previous rounds actions by all players
                    history[t] = list of actions in round t+1 for all players
    :param n: number of players
    :param r: total number of rounds
    :return: 'C' (cooperate) or 'D' (defect)
    """

    # Round 1: no history
    if round_num == 1:
        return 'D'

    # Final round
    if round_num == r:
        return 'D'

    # Previous round actions
    last_round_actions = history[round_num - 2]  # zero-based index

    # Identify self index (assuming input provides it or known),
    # strategy does not depend on own index for decision beyond these rules.

    # Check if all OTHER players cooperated last round
    # Assume self_index known or equals 0 for explanation:
    # For general approach, we need self's index, but logic is:
    # all_others_cooperated = for all j != i: last_round_actions[j] == 'C'

    # Since game parameters do not specify player identity in input,
    # the strategy is symmetrical, so we assume "self" index is known/parses in implementation.

    # For explanation, assume self_index = i
    self_index = 0  # placeholder

    # Check cooperation of all others
    all_others_cooperated = all(
        action == 'C'
        for idx, action in enumerate(last_round_actions)
        if idx != self_index
    )

    if all_others_cooperated:
        return 'C'
    else:
        return 'D'
```

---

### Summary

| Round                  | Decision Rule                                |
|------------------------|----------------------------------------------|
| 1st round              | Defect                                       |
| Intermediate rounds     | Cooperate iff all others cooperated last round; else defect |
| Final round (r-th)      | Defect                                       |

This aggressive strategy maximizes individual payoff by mostly defecting and only cooperating conditionally to exploit universal cooperation, punishing partial or no cooperation. It avoids costly cooperation unless it expects full cooperation from others, aggressively exploiting those who cooperate otherwise.

---

Let me know if you want a distilled short summary or further refinements.
'''

description_AGGRESSIVE_79 = '''
Below is a description of an **aggressive strategy** for the repeated N-player public goods game defined above. The goal of the strategy is to maximize individual payoffs primarily by exploiting the cooperative behavior of others, avoiding being exploited, and leveraging the structure of the game’s payoff.

---

# Aggressive Strategy: "Egoistic Exploiter"

### Intuition
- The strategy aims to maximize personal payoff by **defecting as much as possible**.
- It will **never cooperate first**, since cooperating costs 1 unit of private payoff with no guaranteed reciprocal cooperation.
- It **exploits cooperators** by defecting while others cooperate.
- It punishes cooperators only to the extent that they start defecting themselves (to avoid costly mutual defection).
- In the **last round**, it defects unilaterally since there is no future incentive to cooperate.
- Throughout the game, it tracks the number of cooperators to opportunistically switch cooperating only if it benefits payoff, but generally remains defecting because this yields the highest payoff against a mixture of cooperators and defectors.
  
---

### Decision Rules

**Let:**

- \( t \): current round number (1-indexed)
- \( r \): total number of rounds
- \( n \): total number of players
- \( H_{t-1} \): history of actions (all players’ actions before round \( t \))
- \( C_{t-1} \): total number of cooperators in last round \( (t-1) \)
- \( k \): multiplication factor

---

### Full Description

**Round 1 (First Round):**

- **Defect.**
- Reason: No information about opponents' willingness to cooperate and defecting can yield a payoff of 1, which is better than cooperating leading to only \(\frac{k}{n} \times c\) ≤ 1, without guaranteed returns.

---

**Rounds 2 to \(r-1\) (Middle Rounds):**

1. Calculate number of cooperators \( C_{t-1} \) from the last round, excluding self.
2. **If all others defected last round (i.e., \( C_{t-1} = 0 \)):**
    - Defect.
    - Reason: No one is cooperating, so cooperating yields only the costly 1 unit private loss.
3. **If there is at least one cooperator ( \( C_{t-1} \geq 1 \) ):**
    - Defect.
    - Reason: Exploit cooperators’ contributions for higher payoff.
4. **Exception for “Unstable Cooperation” Scenario:**
    - If total cooperators last round \( C_{t-1} \) was \( n-1 \) (i.e., everyone else cooperated):
      - Consider cooperating only if \(\frac{k}{n} \times (n-1 + 1) = k \geq 1\), **and** cooperating yields better payoff than defecting exploiting cooperators.
      - However, since defecting yields payoff:
        \[
        1 + \frac{k}{n} \times (n - 1)
        \]
        which is always greater than cooperating payoff:
        \[
        0 + \frac{k}{n} \times n = k
        \]
        (because \(1 + \frac{k}{n} (n-1) = 1 + k - \frac{k}{n} > k\) since \(1 > \frac{k}{n}\))
      - Therefore, this scenario: still defect.
      - Hence, **always defect** in middle rounds.

---

**Round \(r\) (Last Round):**

- **Defect unconditionally.**
- Reason: No future rounds to incentivize cooperation; defecting yields the highest immediate payoff.

---

### Summary in Pseudocode

```
FUNCTION aggressive_strategy(t, r, n, k, history):
    IF t == 1:
        RETURN D   # defect first round
    
    ELSE IF t == r:
        RETURN D   # defect last round
    
    ELSE:
        C_prev = count_cooperators_in_round(history[t-1])  # total cooperators last round including self
        
        # Since defection always returns strictly higher payoff regardless of cooperation,
        # defect every round except first (where no info) and last (no incentive to cooperate)
        RETURN D
```

---

### Expected Behavior and Rationale

- **Always defect**, since:
  - Cooperating costs 1 unit private payoff.
  - Defecting yields private payoff 1 plus a share of public good proportional to total cooperators.
  - Defectors always "exploit" cooperators for higher payoffs.
- Never risk cooperating first, never "forgive" (which would be non-aggressive).
- Avoid any form of cooperation even if others cooperate, because payoff-maximizing to defect is guaranteed.
- This strategy is aggressive and self-serving — potentially leading to mutual defection payoffs 1, but *maximizing individual gain immediately whenever others cooperate*.
- It represents a ruthless defector or free-rider.

---

### Edge Cases

- **Smallest \(n=2\)**: Strategy still defects first, last, and middle rounds.
- **Multiplication factor \(k\) close to \(n\)**: Cooperation yields higher group benefits, but individual payoffs favor defection to freeride.
- **Repeated full defection by all players**: Strategy remains defecting, earns payoff 1 per round.
- **If all others always defect**: no incentive to cooperate; strategy defects.
- **If all others cooperate**: exploit by defecting to get payoff \(1 + \frac{k}{n}(n-1) > k\).

---

This strategy clearly embodies an **aggressive, individually maximizing mindset** within the repeated public goods game framework, without relying on trust, norms, or cooperation enforcement.

---

If you want, I can also design a less aggressive or conditional strategy. But this is the maximal aggression approach within the given parameters.
'''

description_AGGRESSIVE_80 = '''
**Aggressive Strategy: Defect-First and Exploit Cooperative Tendencies**

---

### Strategic Rationale

The game is a classic public goods setting with rewards for cooperation but strong incentives to free-ride (defect). Given the payoff formula and parameters:

- Defecting yields an immediate private gain of 1.
- Cooperation sacrifices that 1 private payoff but yields benefits proportional to the total number of cooperators multiplied by *k/n*, where *k < n*, so the multiplication is less than 1.
- Since 1 > k/n (because k < n and so k/n < 1), pure defection dominates in single-shot play.
- However, cooperation by others can increase your payoff if you defect, as defectors benefit from cooperators' contributions without paying costs.

**Key insight for aggressiveness:**  
Maximize personal payoffs by defecting first to exploit cooperators and punish cooperation by others. Cooperate **only** when it strictly improves your expected payoff or to manipulate opponents into cooperating, then exploit again. Generally, lean towards defecting early and often.

---

### Decision Rules

1. **Round 1 (No prior info):**  
   - Defect (D) unconditionally.  
   - Start by exploiting potential cooperators; do not "waste" payoff by cooperating first.

2. **Rounds 2 to r-1 (Middle rounds):**

   Let *C_{-i,t-1}* = number of cooperators (players other than you) in round *t-1*.

   - **If sufficiently many others cooperated last round, defect to exploit them:**  
     Define threshold *T* = floor((n-1) / 2), a majority of other players cooperating.

     If *C_{-i,t-1} ≥ T*, then **Defect (D)**.

   - **If few others cooperated last round (*C_{-i,t-1} < T*), cooperate to encourage cooperation:**  
     This may increase public good, manipulate others into cooperation, or avoid becoming a long-term sucker.  

     Cooperate (C) if you expect cooperation benefits.
     
   - **If previous round all defected (n-1 defectors), stay defect:** cooperate would likely be costly.

3. **Last round (r):**  
   - Defect (D) unconditionally.  
   - No incentive to cooperate on last round since no future punishment or reward is possible.

---

### Edge Cases

- **If n=2 (two players):**  
  Threshold *T* = floor((2-1)/2) = 0, so cooperating only if no one else cooperated last round; effectively, always defect on round 1 and last round.
  
- **If all others defect persistently:**  
  Cooperate only if you want to signal cooperation to induce cooperation back, else defect.

- **If others alternate cooperation and defection:**  
  Respond to their cooperation by defecting aggressively to maximize your payoff.

---

### Pseudocode

```
Parameters:
- n: number of players
- r: number of rounds
- t: current round (1-based)
- history: list of past rounds' actions for all players

Constants:
- T = floor((n - 1) / 2)  # majority threshold of other players cooperating

Function AggressiveStrategy(t, history, my_player_index):
    if t == 1:
        return 'D'  # Defect first round
    
    if t == r:
        return 'D'  # Defect last round
    
    # For intermediate rounds:
    last_round_actions = history[t-2]  # zero-index in history
    
    # Count how many others cooperated last round
    contributors = 0
    for i in 1 to n:
        if i == my_player_index:
            continue
        if last_round_actions[i] == 'C':
            contributors += 1
    
    if contributors >= T:
        # Many cooperators last round → defect to exploit
        return 'D'
    else:
        # Few cooperators → cooperate to encourage cooperation or avoid being exploited
        return 'C'
```

---

### Explanation of Aggressiveness

- **Start defecting:** Capture early gains and test who cooperates.
- **Exploit majority cooperators:** If many cooperated last round, defect to maximize personal payoff.
- **Use cooperation tactically:** Only cooperate when cooperation is rare to try to bait others, but never on first or last round.
- **Never trust on last round:** Defection guarantees no one else can exploit you.
  
The strategy is designed to aggressively maximize individual payoff by exploiting cooperators while occasionally cooperating to avoid long-term sucker payoffs and strategic manipulation by others.

---

### Summary

| Round         | Action        | Reason                                      |
|---------------|---------------|---------------------------------------------|
| 1             | Defect (D)    | Exploit initial cooperation                  |
| Intermediate  | Defect (D) if majority of others cooperated last round | Maximize exploitation of cooperators  |
| Intermediate  | Cooperate (C) if few cooperated last round             | Encourage cooperation, bait opponents |
| Last (r)      | Defect (D)    | No incentive to cooperate                     |

This strategy embodies an aggressive stance: it exploits cooperative behavior while protecting itself from exploitation, relying on dynamic punishment of cooperation by others and refusing to cooperate first or at the end.
'''

description_AGGRESSIVE_81 = '''
Below is an **aggressive strategy** designed for the repeated N-player Public Goods Game. The strategy focuses on maximizing immediate payoff by exploiting cooperators while punishing defectors only enough to maintain dominance, never sacrificing future gains unnecessarily.

---

### Key aggressive mindset elements:
- **Exploit cooperators aggressively**: Defect unless absolutely necessary to keep cooperators contributing.
- **Punish defectors swiftly** but avoid costly retaliation beyond what secures your advantage.
- **First round defect**: Do not trust, start by defecting to maximize immediate payoff.
- **Last round defect**: No incentive to cooperate in the final round, defect to maximize last round payoff.
- **Mid-game conditional cooperation** only if it leads to higher cumulative payoffs by sustaining cooperation among others; otherwise defect relentlessly.

---

## Strategy Description

### Notation

- Let:
  - **t** = current round (1 ≤ t ≤ r)
  - **history** = list of all previous rounds' actions of all players
  - **n** = number of players
  - **k** = multiplication factor
  - Your player index = i

- Define:
  - **cooperators_last_round** = number of players who cooperated in round t-1
  - **you_cooperated_last_round** = True/False if you cooperated last round
  - **other_cooperators_last_round** = cooperators_last_round - (1 if you_cooperated_last_round else 0)

---

### Intuition behind the aggressive decision rule

- **Always defect first round:** No history, so best to defect and gain 1 immediately without risk.
- **If previous round was mostly defectors (few cooperators), continue defecting:** No benefit in cooperating when majority are defecting.
- **If a sizable number of others cooperated last round**, consider cooperating only if that yields better expected payoffs than defecting.
- **Never cooperate in last round** since cooperation is costly and gives no future benefit.
- **Exploit cooperators:** If there were cooperators, defect to get better payoff than them.
- **Punish lone cooperators by defecting:** No incentive to feed free riders.

---

### Payoff Insight and Thresholds

- Cooperators earn:  
  π_C = 0 + (k/n) × total_cooperators  
- Defectors earn:  
  π_D = 1 + (k/n) × total_cooperators

Because

- Defectors always earn exactly 1 more than cooperators when cooperators exist, the temptation to defect to exploit cooperators is strong.

- Cooperation only pays off if you can sustain widespread cooperation, increasing total payoffs above 1.

---

## Pseudocode for Decision Rule

```
Input: round t, total rounds r, history (list of past rounds' actions by all players)

# 1. First round: always defect
if t == 1:
    action = D
    return action

# 2. Last round: always defect (no future rounds to sustain cooperation)
if t == r:
    action = D
    return action

# 3. Analyze previous round
previous_round = history[t - 1]
cooperators_last_round = count of 'C' in previous_round
you_cooperated_last_round = (previous_round[i] == 'C')
other_cooperators_last_round = cooperators_last_round - (1 if you_cooperated_last_round else 0)

# 4. Decision logic for rounds 2 to r-1

# Case A: No or very few cooperators last round
if cooperators_last_round <= 1:
    # No incentive to cooperate if nearly everyone defects (only you or 0 cooperators)
    action = D
    return action

# Case B: Many cooperators (2 or more)
# Calculate expected payoffs this round:

# If you cooperate:
# payoff_C = 0 + (k/n) * (cooperators_last_round + 1 if you switch to cooperate)
expected_cooperators_if_C = cooperators_last_round + (0 if you_cooperated_last_round else 1)
payoff_C = (k / n) * expected_cooperators_if_C

# If you defect:
# payoff_D = 1 + (k/n) * cooperators_last_round (since you don’t add cooperation count)
payoff_D = 1 + (k / n) * cooperators_last_round

# Compare payoffs, take maximum
if payoff_D >= payoff_C:
    # Exploit cooperators by defecting
    action = D
else:
    # Cooperate to maintain substantial cooperation payoffs
    action = C

return action
```

---

## Summary of Aggressive Strategy

| Round        | Action                              | Reasoning                                             |
|--------------|-----------------------------------|-------------------------------------------------------|
| 1            | Defect                            | No info, maximize immediate payoff                    |
| Last Round r | Defect                            | No future to reward, exploit maximal payoff          |
| Intermediate | Defect if few/no cooperators      | Cooperation unlikely to pay off                        |
| Intermediate | Defect if defecting yields ≥ payoff| Exploit cooperators by defecting                       |
| Intermediate | Cooperate only if cooperating yields strictly higher payoff | Maintain cooperation only when beneficial              |

---

## Commentary

- This strategy is aggressive because it **starts defecting immediately**, refuses to be the "sucker" cooperating first, **exploits cooperators when present**, and **never wastes payoffs on futile cooperation**.
- It allows some cooperation when it strictly improves payoff, but otherwise defects aggressively to maximize gains.
- It avoids costly retaliation cycles or forgiveness that would reduce aggressive gains.
- It leverages perfect information and common knowledge to estimate payoffs dynamically each round.

---

If you want, I can help adapt this strategy in code later or provide clarifications!
'''

description_AGGRESSIVE_82 = '''
Here is a designed **aggressive strategy** for the repeated n-player Public Goods Game:

---

## High-Level Intuition

- **Aggressive mindset**: Prioritize maximizing **immediate and cumulative payoff** by exploiting cooperators whenever possible.
- Defect liberally except when specific, exploitable patterns appear.
- Punish cooperators harshly by defecting to maximize free-riding payoff.
- Avoid cooperation upfront, but remain adaptive enough to exploit brief cooperation bursts to gain from them.
- Never be the "sucker" who contributes without sufficient reciprocal cooperation.

---

## Strategy Description (Decision Rules)

### Notation

- Let round index be t ∈ {1, 2, ..., r}
- Let H_t be the history of all players' actions up to round t-1
- Let C_count(t) = number of cooperating players at round t

### Starting point (t=1)

- **Defect**: Start by defecting to avoid costly cooperation risk without information.

### General rounds (2 ≤ t < r)

- Assess the *last round’s* contribution pattern: C_count(t-1)

- Decision rules:

  1. **Exploit cooperators aggressively:**
     - If in last round at least one other player cooperated (C_count(t-1) ≥ 1)  
       → **Defect** to maximize own payoffs by free-riding.

  2. **If nobody cooperated last round (C_count(t-1) = 0)**  
     → **Defect** (stick with defection, as cooperation is not observed).

- Rationale:
  - Defecting when others cooperate yields the highest individual payoff ((k/n)*cooperators + 1).
  - No incentive to cooperate, because cooperation costs 1 unit with no extra benefit unless enough others cooperate, which is unlikely with many aggressive opponents.

### Last round (t = r)

- **Defect**, as there is no future consequence to punishment.

---

## Handling Edge Cases

- **First round:** No history → start defecting to avoid exploitation.
- **Last round:** Always defect as there is no future incentive to build reputations.
- **Moderate cooperation in a round:** Still defect next round to exploit.
- **Full cooperation rounds (rare):** Defect to gain maximal payoff from cooperators.
- **All defect rounds:** Continue defecting.

---

## Pseudocode

```python
def aggressive_strategy(t, r, history):
    # t: current round (1-based)
    # r: total rounds
    # history: list of length t-1, each element is a list of length n with actions 'C' or 'D'

    if t == 1:
        # First round: no history => defect
        return 'D'

    elif t == r:
        # Last round: defect (no future penalty)
        return 'D'

    else:
        # Analyze last round's actions
        last_round = history[-1]  # actions of all players at round t-1
        cooperators = sum(1 for action in last_round if action == 'C')

        # If at least one cooperator last round, free-ride by defecting
        # If no cooperators, defect as well
        return 'D'
```

---

## Summary

This strategy is **fully defecting except for exploiting cooperators whenever they appear**, with no cooperation to build trust or encourage mutual cooperation. Key traits:

- Starts defecting (safe, aggressive)
- Always defects, exploiting any cooperation observed
- Defects in the last round (no future consequences)
- Maximizes short-term gains by free-riding on cooperative players
- Avoids costly cooperation and the risk of being exploited

This aligns fully with an aggressive philosophy, prioritizing self-payoff maximization and exploiting others' cooperation without reciprocating.
'''

description_AGGRESSIVE_83 = '''
Here is a detailed aggressive strategy for the described N-Player Public Goods Game. This strategy focuses on maximizing one’s own payoff by consistently exploiting cooperators and aggressively punishing others only if absolutely necessary.

---

### Strategy: **"Exploit and Punish Minimalist"**

#### Intuition:
- Always defect to maximize immediate payoff since defecting never costs you.
- Exploit cooperators who contribute by free-riding on their contributions.
- However, apply minimal punishment only if there is sustained cooperation that could endanger your relative payoff.
- Last round is always defect (standard backward induction).
- Don't waste resources on needless punishment; maintain a relentless defect stance, but punish if opponents start cooperating en masse to prevent them from gaining too much.

---

### Rationale for Aggression:
- Defection always gives at least a baseline payoff (1 + public good share).
- Cooperators pay a cost (lose 1 private unit per round) and only gain if many cooperate.
- Multiplication factor \(k < n\) means defection dominant if no coordination.
- Aggressive means defecting always except when punishment of cooperators is needed to protect relative payoff.
- Punishment here means: if opponents try to cooperate to raise their payoffs, defect to exploit or punish to lower their returns.
- Last round defect since no future consequences.

---

### Decision Rules:

| Round                  | Action for player i                                       |
|------------------------|----------------------------------------------------------|
| Round 1 (t=1)          | Defect (D)                                               |
| Intermediate rounds    | - If any opponent fully cooperated in previous round (all cooperated) → Defect (exploit them)<br>- Else if substantial cooperation detected (≥ 50% cooperated last round) → Defect (punish cooperation)<br>- Else continue defecting (D) — no cooperation, no punishment needed |
| Last round (t = r)     | Defect (D)                                               |

---

### More Formal Pseudocode:

```python
strategy(history, t, r, n, k):
    # history: list of length t-1 with tuples of (actions_of_all_players)
    # Each element: ['C' or 'D', ..., 'C' or 'D']
    # t: current round (1-based)
    # r: total rounds
    # n: number of players
    # k: multiplication factor
    
    if t == 1:
        # First round: always defect
        return 'D'
    
    if t == r:
        # Last round: defect (no incentive to cooperate)
        return 'D'
    
    # Compute cooperation level in previous round
    prev_round_actions = history[t-2]  # zero-indexed, so t-2 is previous round
    coop_count = sum(1 for a in prev_round_actions if a == 'C')
    coop_fraction = coop_count / n

    # Aggressive exploitation rules:
    # 1. If prev round was full cooperation (all C), defect to exploit
    if coop_count == n:
        return 'D'

    # 2. If substantial cooperation (≥ 50%), defect to punish cooperation
    if coop_fraction >= 0.5:
        return 'D'

    # Otherwise, defect as default strategy
    return 'D'
```

---

### Explanation:

- **Always defect:** This is the core aggressive trait to maximize your own immediate payoff.
- **Punish large-scale cooperation:** If others start cooperating in significant numbers, defect to prevent them from getting large payoffs.
- **Never cooperate yourself:** Because cooperating strictly costs you 1 private unit per round and does not guarantee higher total returns unless others cooperate.
- **No forgiveness or attempts to build cooperation:** This is aggressive pure defection.
- **Last round defect:** Because there is no future retaliation or reward, so defect to maximize last round payoff.

---

### Edge Cases:

| Case                  | Strategy Behavior                                  |
|-----------------------|--------------------------------------------------|
| Only one cooperator    | Still defect, free-ride on that cooperator's contribution. |
| All defect in previous rounds | Continue defecting (stable state).             |
| Opponents oscillate cooperation | Defect regardless; always exploit cooperation if present. |
| Single round left (r) | Defect (backward induction).                      |

---

### Summary:

This aggressive strategy:
- Never cooperates.
- Exploits cooperators fully.
- Applies punishment only via persistent defection.
- Maximizes individual payoff assuming others may cooperate.
- Is simple, robust, and unambiguous.

Because the payoff from defection is always at least as good as cooperator’s in mixed groups and punishing cooperators reduces their incentive to cooperate, this strategy aggressively protects own interest without costly cooperation or futile punishments.

---

If you want, I can help you adapt this strategy further or write it in a more detailed form.
'''

description_AGGRESSIVE_84 = '''
Here is an aggressive, payoff-maximizing strategy tailored to the N-Player Public Goods Game described:

---

## Strategy Name: **Exploitive Defector with Opportunistic Retaliation**

### Intuition:
- The strategy seeks to exploit cooperators fully by defecting to gain the maximal private payoff.
- It does not contribute voluntarily, except to implement a harsh but short-lived retaliation if others defect too much.
- Being aggressive means prioritizing individual payoff over group benefit, never cooperating first.
- Retaliation discourages mass defection cascading that could lower the strategy’s payoffs.
- On the last round, defecting maximizes immediate payoff without fear of retaliation.

---

### Decision Rules

Let:
- **t** be the current round, 1 ≤ t ≤ r
- **history** be the full record of all players’ moves in previous rounds
- For round t, total number of cooperators among opponents (others excluding self) in round t-1 is \( C_{t-1} \).

---

#### Round 1 (t = 1)

- Defect (D) unconditionally, since:
  - Cooperation is exploitable,
  - No history to estimate opponents' likely behavior,
  - Aggressive mindset demands maximum immediate gain.

---

#### Intermediate Rounds (1 < t < r)

- Let \( C_{t-1} \) = number of cooperating opponents in previous round.

- **If significant cooperation was observed last round:**

  - Define threshold \( \theta = \frac{n-1}{2} \) (majority of opponents cooperating).

  - If \( C_{t-1} \geq \theta \):  
    Defect (D) to exploit the cooperators.  
    Reason: High cooperation means high public good share — maximize payoff by defecting.

- **If cooperation was low last round:**

  - If \( C_{t-1} < \theta \):  
    Retaliate temporarily by cooperating for exactly 1 round, then defect again.  
    Reason: Cooperation here acts as a minimal penalty by lowering total contributions and thus the public good share, deterring persistent defection by others, but avoids risky long-term cooperation.

  - After one cooperative retaliation round, revert to defecting.

  (This is a “tit-for-tat” style reduced cooperation, but with only one round of cooperation to keep aggressiveness.)

---

#### Last Round (t = r)

- Always defect.

- Since no future rounds exist, retaliation or cooperation provide no benefit.

---

### Summary Logic in Pseudocode

```pseudo
function playAction(t, history):
    if t == 1:
        return Defect
    
    if t == r:
        return Defect
    
    # Get opponent cooperation count in last round
    C_last = countCooperators(history, t - 1)  # excluding self
    
    threshold = (n - 1) / 2
    
    if C_last >= threshold:
        # Plenty of cooperators last round — exploit by defecting
        return Defect
    else:
        # Opponents cooperated less than threshold last round
        # Check if we just retaliated last round
        if we cooperated at round t-1:
            # Completed 1-round retaliation; resume defection
            return Defect
        else:
            # Initiate 1-round retaliation by cooperating now
            return Cooperate
```

---

### Edge Cases

- **If many opponents always defect:**
  - This strategy will keep defecting except for rare 1-round cooperation pulses responding to low cooperation, which won’t occur if others never cooperate, so will simply defect every round.

- **If some opponents cooperate intermittently:**
  - The strategy exploits them aggressively by defecting during cooperative rounds.

- **If all cooperate constantly:**
  - The strategy defects every round to maximize payoff, getting better than cooperators who contribute their endowment.

- **If others retaliate after defections:**
  - The 1-round cooperative retaliation is intended to destabilize long cycles of mutual defection by briefly contributing, keeping overall payoffs higher than mutual defection, but still aggressively maximizing payoff when possible.

---

### Why is this aggressive?

- Never voluntarily cooperates first except for minimal retaliation punishments.
- Always attempts to exploit cooperators for higher payoff.
- Uses retaliation only as a tactical threat, not as cooperation.
- Last round defection secures max final payout with no concern for reputational losses.

---

# Closing remarks:

This strategy is purely self-serving, exploits cooperative behavior by others maximally, and uses minimal cooperation only as a tactical threat. It stays aggressive over the entire repeated game horizon, balancing exploitation with brief retaliation to prevent mutual defection collapse.

---

If you want, I can help formalize this strategy further or adapt it to specific parameterizations!
'''

description_AGGRESSIVE_85 = '''
Below is a detailed **aggressive strategy** tailored for the N-player repeated Public Goods game under the specified conditions.

---

## Strategy Overview: Aggressive Defector with Opportunistic Exploitation

- **Mindset:** Maximize individual payoffs by defecting whenever safe and exploiting cooperating players.
- **Key principle:** Default to defect (D) to gain the private payoff 1 plus a possible fraction of public good if others cooperate.
- **Exploit cooperators**: Capitalize on others who contribute.
- **Use cooperation **only** tactically** to try to induce others to contribute, but never at personal cost without clear payoff gain.
- **Punish cooperating opponents** by defecting consistently—no costly cooperation for altruism.
- **Endgame defect:** Defect in the last round unconditionally to avoid exploitation.

---

## Detailed Decision Rules

### Initialization (Round 1):
- Defect unconditionally (D).
- Reason: No history to trust cooperators; exploit maximum safe payoff immediately.

### General Round t where 1 < t < r:
- Observe all players’ previous round actions.
- Calculate the number of cooperators in round t-1: `coopCount`.
- **If** majority cooperated last round (e.g., `coopCount > n/2`):
  - Deploy a **one-shot cooperation:** cooperate once if it can increase your expected payoff beyond defecting.
  - Otherwise, defect.
- **Else** (majority defected last round or tied):
  - Defect to maximize private payoff.

### Cooperation Decision Logic for mid-game rounds:
- Cooperation is only played if the expected payoff by cooperating exceeds defecting.
- Expected payoff for cooperating given `coopCount` previous round:
  - Cooperate payoff: π_i = 0 + (k / n) × (coopCount + 1)
  - Defect payoff: 1 + (k / n) × coopCount
- Cooperate if:  
  (k / n) × (coopCount + 1) > 1 + (k / n) × coopCount  
  Simplifies to:  
  k / n > 1  
- But since k < n, `k / n < 1`; so cooperating alone is strictly worse than defecting regardless of coopCount if you only consider one round.
- **Hence, cooperate only if this triggers future increased cooperation**, but since no cooperation clustering or coordination, this condition is never satisfied confidently.
- **Conclusion:** Do not cooperate midgame to avoid being exploited.

### Last Round (Round r):
- Defect unconditionally.
- Reason: No incentive to cooperate since no future rounds to enforce reciprocity or punish defection.

---

## Pseudocode

```
Input: n (num players), r (rounds), k (multiplication factor)
History: array of past rounds actions by all players

for t in 1..r:
    if t == 1:
        action = D  # Defect first round

    else if t == r:
        action = D  # Defect last round unconditionally

    else:
        previous_round_actions = History[t-1]
        coopCount = count_cooperators(previous_round_actions)

        # Cooperation is not payoff beneficial unless k/n > 1 (which is impossible)
        # So always defect midgame as well
        action = D

    play(action)
```

---

## Summary of the Aggressive Strategy Behavior

| Round       | Action                      | Reason                                |
|-------------|-----------------------------|-------------------------------------|
| First round | Defect                     | Exploit initial uncertainty         |
| Middle rounds (2 to r-1) | Defect              | Cooperation yields no payoff benefit; avoid exploitation |
| Last round  | Defect                     | No future penalties; secure maximum payoff |

---

## Rationale & Aggressiveness

- This strategy **never cooperates**, thus maximizing the private payoff of 1 every round plus picking up any public good produced by others.
- Aggressive exploitation of cooperators means this strategy benefits from others’ contributions without ever paying the cost.
- Defecting last round ensures no one can free-ride on your prior cooperation.
- By refusing to cooperate, it forces others into costly cooperation or mutual defection deadlock.
- The strategy is "aggressive" because it prioritizes immediate self-gain, exploits others’ altruism, and refuses to build or maintain cooperation.

---

# End of Strategy Description
'''

description_AGGRESSIVE_86 = '''
Below is an aggressive strategy tailored for the N-player repeated public goods game as specified. This strategy is designed to maximize individual payoff by exploiting cooperators and minimizing contributions, while punishing others for cooperating sufficiently to raise your payoff cost.

---

## Strategy Name: **Dominant Defector with Opportunistic Exploitation**

---

### Intuition:

- **Aggressiveness** means never voluntarily cooperating if it harms your payoff compared to defecting.
- Use observed cooperation levels to exploit cooperators when profitable.
- Punish rounds where others try to "enforce" cooperation by cooperating yourself only when it yields a strictly higher payoff.
- Exploit early rounds and punish late rounds (e.g., avoid endgame cooperation).
- Use observed history to infer when cooperation is too "costly" to you and defect to maximize gains.

---

### Key Observations From Payoffs:

- Cooperating costs you 1 unit privately.
- Defecting keeps 1 unit privately.
- The cooperation contribution is multiplied by k/n and shared equally.
- Since \(1 < k < n\), each cooperator contributes 1 but the return per cooperator is \(k/n\). This is less than 1 for each individual, so by itself cooperation is costly unless many cooperate.
- Defecting yields 1 private + share of public good.
- The more cooperators, the more the public good, benefiting all, but defectors benefit more than cooperators without paying the cost.
- Always defecting yields at least the baseline payoff of 1 (no contribution) plus whatever comes from others cooperating.

---

### Strategy Description:

---

### 1. First Round (no history):

- **Defect** unconditionally.
- Reason: Don't pay the cost initially. Test others’ behavior by observing their first-round moves.

---

### 2. Subsequent Rounds (2 to r-1):

- Observe previous round’s cooperation count \(C_{t-1} = \sum_j c_j^{t-1}\).
- Calculate two hypothetical payoffs:

  - If I **Cooperate** in this round:
    \[
    \pi_C = 0 + \frac{k}{n}(C_{t-1} + 1)
    \]

  - If I **Defect** in this round:
    \[
    \pi_D = 1 + \frac{k}{n} C_{t-1}
    \]

- Compare \(\pi_C\) and \(\pi_D\):

  - If \(\pi_C > \pi_D\)  
    → Cooperate this round (only if cooperating yields strictly higher payoff due to others’ cooperation)

  - Else  
    → Defect this round

- Intuition: Only cooperate if incrementing cooperation by 1 yields enough public good multiplied by k/n to cover your own cost (1 unit private cost).

- This means you'll cooperate only when enough others cooperated last round to make cooperation profitable to you.

- You exploit cooperators and punish widespread cooperation that would force you to cooperate.

---

### 3. Last Round (round r):

- Always **Defect**.

- Reason: No future retaliation possible; cooperating is strictly dominated.

---

### 4. Additional Details:

- History only from last round is used, consistent with aggressive exploitative mindset, ignoring generosity or forgiveness.
- No randomization: purely deterministic and myopic.
- If others are never cooperating, you never cooperate either.
- If enough cooperate to make cooperation profitable, you grab the benefit by cooperating once, then revert if cooperation falls.

---

### Pseudocode

```python
# Inputs:
# - r: total rounds
# - t: current round index (1-based)
# - history: list of previous rounds actions, each a list of n actions (C or D)
# - n, k: parameters

def aggressive_strategy(t, history, n, k):
    if t == 1:
        # First round: defect
        return 'D'

    if t == r:
        # Last round: defect (endgame exploitation)
        return 'D'

    # Count number of cooperators in previous round
    prev_round = history[t-2]  # zero based indexing; t=2 -> history[0]
    C_prev = sum(1 for action in prev_round if action == 'C')

    # Calculate payoffs for cooperating or defecting this round
    pi_C = 0 + (k / n) * (C_prev + 1)
    pi_D = 1 + (k / n) * C_prev

    if pi_C > pi_D:
        return 'C'
    else:
        return 'D'
```

---

### Summary

| Condition                      | Action               |
|-------------------------------|----------------------|
| Round 1                       | Defect               |
| Last Round (round r)          | Defect               |
| Other rounds (t = 2..r-1)     | Cooperate iff cooperation last round was *high enough* to make cooperation profitable (`pi_C > pi_D`), else Defect |

---

## Why is this Strategy Aggressive?

- Never cooperates out of goodwill or trust.
- Uses cooperation only as a calculated means to increase payoff.
- Defects decisively in first and last rounds to maximize personal gain.
- Always exploits others’ cooperation while minimizing own contribution costs.
- Does not tolerate attempts to enforce cooperation by punishing with defection.
- Seeks to dominate the population by taking advantage of cooperators and refusing altruism.

---

This strategy is expected to perform well in heterogeneous populations, especially against strategies that attempt cooperation or conditional cooperation, by exploiting their willingness to pay the cost.
'''

description_AGGRESSIVE_87 = '''
**Aggressive strategy for N-Player Public Goods Game**

---

### Conceptual overview:

- This strategy treats the game as a competition where **maximizing immediate and cumulative payoff** is paramount.
- It **defects early and often** to exploit cooperative players.
- It **exploits public goods contributions by others without contributing itself whenever possible**.
- It **retaliates against cooperation attempts only if profitable** (but mostly ignores attempts to punish to avoid costly cooperation).
- It **unconditionally defects on the last round** since no future retaliation is possible.
- It tries to **detect and exploit "purer" cooperators**, and will defect even if alone cooperating to maximize own payoff.
- If others start to defect frequently, it **continues defecting**, as cooperation is not beneficial without reciprocation.

---

### Why is this aggressive?

- Aggressive means prioritizing own payoff possibly at the expense of group efficiency.
- Aggressive means exploiting cooperators rather than punishing them (which costs you).
- Aggressive means choosing defection by default, cooperating only very rarely if it clearly leads to payoff gains.

---

# Detailed strategy description

---

### Parameters and observable data per round:

- n = number of players
- r = total rounds
- current round t ∈ {1, ..., r}
- history of actions of all players in past rounds: A_j,s for players j = 1...n, rounds s = 1...t-1
- total contributions last round: C_{t-1} = sum_{j=1}^n c_j last round, or zero if t=1

---

### Decision rules

```pseudocode
function aggressive_strategy(t, history):
    if t == r:
        // Last round: defect unconditionally
        return D
    
    if t == 1:
        // First round: defect to test/cooperate only if forced (none initially)
        return D
    
    // From round 2 to r-1:
    // Calculate "cooperation rate" of others in previous rounds
    coop_counts = [number of rounds player j cooperated] for j != me
    avg_coop_others = sum(coop_counts) / ((n-1) * (t-1))
    
    // Calculate last round's number of cooperators (excluding self)
    last_round_coop_others = sum_{j != me} c_j,t-1
    
    // Aggressive core decision:
    // Always defect unless:
    // - Last round all others cooperated and I cooperated → rare, allows minimal cooperation to avoid total collapse
    // - Or if cooperating yields strictly higher payoff for this round (rare and only if others cooperate)
    
    if last_round_coop_others == (n - 1):
        // All others cooperated last round: cooperative environment detected
        
        // Check if cooperating yields higher immediate payoff:
        // π_if_cooperate = 0 + (k/n) * (1 + sum of others who cooperated) = (k/n)*(n) = k
        // π_if_defect = 1 + (k/n)*(n-1) = 1 + (k/n)*(n-1)
        
        // Compare payoffs:
        // defect payoff > cooperate payoff if 1 + (k/n)*(n-1) > k
        // 1 +(k) - (k/n) > k => 1 > k/n
        // Since k < n and k >1, 1 > k/n can be True or False depending on k
        
        defect_payoff = 1 + (k/n)*(n - 1)
        cooperate_payoff = 0 + (k/n)*(n)
        
        if cooperate_payoff > defect_payoff:
            // Cooperate if cooperating strictly better
            return C
        else:
            return D
    
    // Otherwise, defect unconditionally in all other cases
    
    return D
```

---

### Explanation of rules:

- **Round 1:** Defect to avoid wasting endowment on an untested scenario.
- **Rounds 2 to r-1:**  
  - Detect if entire group cooperated in last round (high cooperation environment).
  - If yes, cooperate only if cooperating yields higher payoff than defecting (depends on k).  
  - Otherwise, defect to exploit cooperators.
- **Round r (last round):** Defect unconditionally since no future consequences.
  
---

### Edge cases:

- **If k is close to n:** cooperating might yield a slightly higher payoff when all others cooperate. Then cooperate in these cases.
- **If no one cooperates:** keep defecting.
- **If cooperation partially present:** defect, exploit cooperators.
- **No remorse or forgiveness:** stay defecting until game ends.
- **If number of rounds is very small (r=2):** defect in round 1 and last round is round 2 so defect again; no cooperation happens.

---

### Intuition: Aggressiveness

- The strategy exploits cooperation but cooperates in a minimal way only if it increases personal payoff.
- It never initiates cooperation, minimizing giving.
- It punishes cooperation only by defecting, not by costly retaliation.
- The strategy maximizes individual gain over the rounds by defecting mostly and exploiting cooperators.
- It only cooperates at best when fully reciprocated by others and personal immediate payoff is better cooperating.
- It defects last round no matter what to grab last-round gains.
- This effectively encourages maximal exploitation of public goods without contributing.

---

# Summary

| Round       | Condition                           | Action |
|-------------|-----------------------------------|--------|
| 1           | First round                       | Defect |
| 2 ... r-1   | All others cooperated last round? | Cooperate if cooperating payoff > defecting payoff; else defect |
|             | Otherwise                        | Defect |
| r (last)    | Always                           | Defect |

---

This is a **consistently aggressive, exploitative strategy** maximizing own payoff by defecting mostly and cooperating minimally only when it strictly benefits the player.

---

If you want I can also provide a clear compact **pseudocode-only** summary or verbal explanation for the tournament description.
'''

description_AGGRESSIVE_88 = '''
**Aggressive Strategy for the N-Player Public Goods Game**

---

### High-Level Intuition

This strategy is designed to maximize *individual payoff* by exploiting cooperation from others wherever possible but never being the sole cooperator or "sucker." The approach is aggressive in that it:

- Starts by defecting to test others.
- Attempts to free-ride on cooperators but retaliates to punish excessive defection.
- Avoids being exploited by never cooperating first except potentially in the last round if it yields benefit.
- Uses observed history aggressively to exploit cooperation while punishing defectors to steer group behavior towards beneficial but non-exploitative patterns.
- Exploits knowledge of the last round to maximize final payoff.

---

### Key Points About the Game Relevant to Aggression

- Defecting player gains 1 from private endowment plus their share of public good.
- Cooperators pay 1 to contribute, but benefit only if enough others cooperate.
- Because \( k < n \), marginal per capita return on cooperation is less than 1, so individually defecting is *dominant* if others’ cooperation is uncertain.
- In last round, no incentive to cooperate (no future retaliation/ reward), so defecting is strictly dominant.
- In early rounds, cooperation only makes sense if others do it sufficiently to compensate loss from contributing.

---

### Strategy Notation and Terminology

- \( H_{t-1} \): History of all players' actions and payoffs up to round \( t-1 \)
- \( C_t \): Set of cooperators in round \( t \)
- \( c_i^t \): \( i \)-th player's action in round \( t \) (1 if C, 0 if D)
- \( T \): total rounds \( r \)
- \( n \): number of players
- \( k \): multiplication factor

---

### Decision Rule Overview

**For round \( t \in \{1, \ldots, T\}: \)**

1. **First round (\( t=1 \)):** Always **Defect (D)**.

   - Reason: No information about others; cooperating first is costly and exploitable.

2. **Intermediate rounds (\( 1 < t < T \)):**

   - Observe historical cooperation levels per player.

   - Strategy targets players who consistently cooperate: it will defect to exploit them.

   - If a threshold fraction of other players cooperated in previous round (e.g., at least 1 cooperating aside from self), cooperate **only if** we are sure others will cooperate enough to make cooperation profitable; otherwise defect.

   - However, never cooperate if we were exploited by defectors repeatedly.

3. **Last round (\( t = T \)):**

   - Always **Defect (D)**.

   - No incentive to cooperate since no future rounds.

---

### Aggressive Core Logic

- **Exploit Cooperators:** Defect if others cooperated in last round to maximize payoff (free ride).

- **Retaliate Defectors by Defecting:** Defect if others defected heavily previously (no forgiveness for defectors).

- **Refuse to Cooperate First:** Never be the first to cooperate in the game.

- **Exploit Last Round:** Always defect last round.

- **Exploit Small Clusters:** If a small number of players cooperate consistently, exploit them.

- **No Explicit Forgiveness:** This is not a cooperative strategy; it punishes exploitation as necessary, but never yields pure cooperation.

---

### Pseudocode

```
Inputs:
- history: list of previous rounds, each round is a dict mapping player_id to action ('C' or 'D')
- player_id: our player index
- n: number of players
- r: total rounds
- k: multiplication factor

Function AggressiveStrategy(t, history):

  if t == 1:
    # No info, stay safe, defect
    return 'D'

  if t == r:
    # Last round defection to maximize payoff
    return 'D'

  # Calculate cooperation counts in previous round
  prev_round = history[t-2]  # zero-based indexing
  coop_count = sum(1 for a in prev_round.values() if a == 'C')
  
  # Check if self cooperated last round
  self_last_action = prev_round[player_id]

  # Count how many times each player cooperated in entire history, excluding self
  coop_frequency = {pid: 0 for pid in range(1, n+1)}
  for round_actions in history:
    for pid, action in round_actions.items():
      if action == 'C':
        coop_frequency[pid] +=1
  coop_frequency[player_id] = 0  # ignore self

  # Identify consistently cooperating players (cooperated in > 70% past rounds)
  consistent_cooperators = [pid for pid, freq in coop_frequency.items() if freq >= 0.7 * (t-1)]

  # Decision logic:

  # Case 1: If enough other consistent cooperators to make cooperation profitable, exploit them by defecting
  if len(consistent_cooperators) >= 1:
    # Exploit cooperative cluster: defect to maximize payoff
    return 'D'

  # Case 2: No significant cooperation cluster:
  # - If most defected previously, defect
  if coop_count <= n/2:
    return 'D'

  # Case 3: If majority cooperated last round but no consistent cooperators,
  # we still defect to exploit (aggressive mindset)
  if coop_count > n/2:
    return 'D'

  # Default fallback:
  return 'D'
```

---

### Explanation & Justification

- **Always defect first round**: avoids being sucker.

- **Last round defect** optimizes final payoff; no future incentive to cooperate.

- **In intermediate rounds, exploit any observed consistent cooperation** rather than joining it.

- The strategy does no unconditional cooperation ever, avoiding exploitation.

- Retaliates by continuing to defect once defection is observed among others; no forgiveness—aggressive stance.

- This creates a dynamic to sucker out or punish cooperators but never risks cost of cooperation.

- By capitalizing on free riding, this strategy is "aggressive" and aims to maximize relative payoff.

---

### Summary

| Round      | Action                         | Reason                                              |
|------------|---------------------------------|-----------------------------------------------------|
| 1          | Defect                         | Avoid sucker payoffs, no history yet                 |
| 2 to r-1   | Defect                         | Exploit any cooperators or retaliate defectors; no cooperation because no trust / no forgiveness |
| r (last)   | Defect                         | No incentive to cooperate                             |

This leads to aggressive, selfish maximizing behavior that exploits any cooperation, never cooperates first or last round, and punishes defectors by refusing cooperation.

---

If implemented in tournament, this aggressive strategy will:

- Score zero cooperation cost.
- Maximize payoff by free-riding on cooperators.
- Resist being exploited.
- Exploit history to identify and exploit cooperative clusters.
- Avoid being suckered.

---

If you want me to clarify or specify extensions (e.g., partial cooperation under certain exact conditions), please ask!
'''

description_AGGRESSIVE_89 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Core idea:
This strategy aggressively pursues defecting to maximize immediate and total payoffs, exploiting cooperators when possible and punishing cooperation attempts by others to discourage free-riders or naive cooperators. It assumes no unconditional cooperation (which is exploitable) and exploits the public goods game payoff structure where defecting yields a higher private payoff unless all cooperate.

---

### Key insights for aggression:

- Defecting always guarantees a baseline payoff of 1 plus a share of contributions from any cooperators.
- Cooperating sacrifices your private payoff (0 vs. 1) unless everyone cooperates.
- Cooperating in early rounds invites exploitation by defectors.
- Last round defecting is always dominant since no future punishment/reward incentives exist.
- Aggression targets maximizing exploitative gain, not group welfare.
- Punish cooperators to drive them to defect to increase your relative score.
- No trust or forgiveness phase.

---

### Decision Rules (per round t, for player i):

```
Input:
- History of all players' actions up to round t-1: A_1,...,A_n for each prior round
- Current round number: t
- Total rounds: r

Initialize:
- If t = 1: no history.

Decision:

1. If t == r (last round):
    // Last round defect is strictly dominant
    action_i = Defect (D)

2. Else if t == 1 (first round):
    // No signals yet, aggressively defect to gain higher immediate payoff
    action_i = Defect (D)

3. Else (2 <= t < r):
    // Check history of cooperators from previous round t-1:
    get actions_last = actions of all players in round t-1
    total_cooperators_last = count of C in actions_last

    If total_cooperators_last == 0:
        // Everyone defected last round: continue defecting
        action_i = Defect (D)
    Else:
        // At least one player cooperated last round: punish all cooperators aggressively
        action_i = Defect (D)

Note:
- This strategy never cooperates.
- It uses the power of defection to exploit any cooperators.
- It punishes cooperation by maintaining defection.
```

---

### Explanation:

- **First round**: No information, assume everyone might cooperate; best aggressive move is to defect to exploit cooperators (if any).
- **Middle rounds**: No cooperation is ever rewarded. Cooperators in previous round are exploited by defecting. This fuels aggressive exploitation and negates benefits for cooperators.
- **Last round**: Defect as the dominant strategy, no incentive to cooperate.
- **Outcome**: Aggressive defector exploits cooperators, never suffers downside of cooperating, and drives down cooperation rates.

---

### Pseudocode Summary:

```python
def aggressive_strategy(history, t, r):
    # history: list of previous rounds' actions, each round's actions is list of length n of 'C' or 'D'
    
    if t == 1:
        # First round
        return 'D'
    
    if t == r:
        # Last round
        return 'D'
    
    # Intermediate rounds
    last_round_actions = history[-1]
    cooperators_last = sum(1 for a in last_round_actions if a == 'C')
    
    # Always defect, regardless of others' past cooperation
    return 'D'
```

---

### Aggressiveness:

- This strategy is **maximally aggressive** since it never cooperates.
- It exploits any cooperating players by free-riding on their contributions.
- It actively discourages cooperation by never rewarding it.
- It is simple, predictable, and focused entirely on maximizing individual gain via defection.

---

**In summary, the strategy is: Always Defect.** This aligns exactly with an aggressive mindset in the public goods game under the given assumptions.
'''

description_AGGRESSIVE_90 = '''
Below is a design for an aggressive strategy in the N-Player Public Goods Game as described.

---

### Objective of the Aggressive Strategy

The strategy aggressively exploits cooperators without being suckered: it aims to maximize own payoff by defecting whenever it is profitable and punishing cooperation by others if they try to exploit it. It will not cooperate first (no naive cooperation); it will respond to others’ cooperation only tactically. Being aggressive means prioritizing short-term gain and exploiting cooperation of others, while guarding against free-riding on ones own cooperation.

---

### Key Strategic Ideas

- **Never cooperate first:** Start defecting immediately, to exploit cooperators and maximize private payoffs.
- **Exploit cooperators:** If others cooperate, defect and benefit from their contributions while keeping own endowment.
- **Punish sustained cooperation by others:** If others keep cooperating over multiple rounds (trying to establish cooperation), punish by continuing to defect, undermining their incentives.
- **Detect “too many” defectors and force mutual defection:** If a majority defects (including self), stay defecting; cooperating won't increase payoff.
- **Last round defect:** No future rounds to punish, so defect to maximize payoff.
- **Never forgive cooperators:** Aggressive means no attempts to return to cooperation or soften stance.

---

### Intuition on Payoffs

- Defecting is always better if any other player cooperates: you get 1 + (k/n)*total_cooperators, while cooperating only gets 0 + (k/n)*total_cooperators.
- If all defect, each gets 1, which might be lower than cooperating, but cooperating risks exploitation.
- Multiplication factor k < n, so marginal per capita return from cooperating is less than cost 1, so selfish defecting dominates in single round.
- The gains from cooperation can be exploited in repeated rounds, but the aggressive strategy exploits rather than reciprocates.

---

### Concrete Decision Rules

Let **H_t** = history up to round t-1 (observed actions of all players).

- Denote by **C_count_t** the number of cooperating players in round t.
- Denote by **C_count_t_i** whether player i cooperated in round t.
- Denote the *observed counts* of cooperators in previous rounds from H_t.

---

### Pseudocode for Player i at Round t (1 ≤ t ≤ r)

```pseudocode
Input: t (current round), H_t (history = actions of all players in previous rounds)

If t == r: 
    # Last round: defect to maximize immediate payoff
    Play D

Else if t == 1: 
    # First round: defect to avoid being exploited
    Play D

Else:
    # Analyze history for previous rounds 1 to t-1
    total_coop_rounds = number of rounds where more than 0 cooperators (including self if cooperated)
    # Check if majority of players cooperated in recent rounds:
    recent_rounds = min(t-1, 3)  # consider last up to 3 rounds for aggression detection

    coop_counts_last3 = [C_count_(t-1), C_count_(t-2), C_count_(t-3)] (only those rounds available)
    
    avg_cooperators = average(coop_counts_last3)
    
    # Aggressive stance:

    # 1. If there is ANY cooperation in last 3 rounds by others (excluding self), defect to exploit
    If avg_cooperators > 0 and at least one other player cooperated in last round:
        Play D
    
    # 2. Else, if everyone defected recently (avg_cooperators == 0), defect to maintain payoff
    Else if avg_cooperators == 0:
        Play D

    # 3. Default fallback (should not occur): defect
    Else:
        Play D
```

---

### Summary in English

1. **Always defect from the start.** No attempt to be the first cooperator.
2. **Never reward cooperation by cooperating.** If any players have cooperated recently, exploit them by defecting.
3. **If cooperation does not emerge in the group, keep defecting to secure the default payoff of 1.**
4. **Defect in the last round always** to guarantee maximum individual gain.
5. **No forgiveness or retaliation cycles; always defect** — an aggressively selfish, exploitative stance.

---

### Rationale on Edge Cases

- **First round:** No information, so defect.
- **Last round:** No future punishment possible; defect.
- **When others cooperate:** Exploit immediately to maximize payoff; do not reciprocate.
- **When others defect:** No incentive to deviate; defect to avoid losses.
- **No cooperation attempts by others:** Defect anyway for consistent payoff.
- **No attempts to build cooperation since it’s unlikely, and even if it does, this strategy exploits it.**

---

This strategy is maximally aggressive because it prioritizes immediate self-payoff, exploits cooperators, never cooperates first, and refuses to reciprocate or soften. It is a "defect always" strategy with a minimal sophistication to check if cooperation is present (and capitalize on it).

---

**In other words:** Defect always.

---

# Final Note

You may label this as **"Aggressive Defector"** or **"Permanent Defector"** in the tournament notation. It is the standard aggressive approach guaranteeing no exploitation by others and maximum exploitation of any others who try to cooperate.

---

If you want an optional variant with slight sophistication (punishing conditional cooperators only), please ask!
'''

description_AGGRESSIVE_91 = '''
Below is a detailed description of an **aggressive strategy** for the N-player public goods game defined above.

---

## Strategy Name: Defect-Always-Exploit (DAE)

### Intuition

- The strategy aggressively prioritizes maximizing *individual* payoff without regard for collective welfare.
- It treats cooperation from others as exploitable opportunities, never reciprocates cooperation.
- It always defects to maximize private retention and benefits from any cooperating opponents.
- It uses limited historical information only to confirm it is not being exploited.
- In a repeated game, it does **not** attempt to build trust or cooperation — it never cooperates.
- This is the prototypical "defector" behavior, aggressive because it seeks to benefit from cooperators without contributing.

---

### Decision Rules

#### 1. **First Round (t = 1):**
- Always **Defect (D)**.
- Reason: No information on opponents; cooperating upfront is costly and offers no guaranteed returns.

#### 2. **Subsequent Rounds (t > 1):**
- Always **Defect (D)** regardless of opponents’ past actions.
- Rationale:
  - Defecting grants the player a guaranteed private payoff of 1 every round plus any share of the public good if others cooperate.
  - Since other players never know if you will cooperate, being the sole cooperator is highly risky and yields the worst payoff.
  - This approach exploits any cooperation by others without incurring the cost.

#### 3. **Last Round (t = r):**
- Also **Defect (D)**.
- The logic of backward induction says cooperation in the last round is strictly dominated by defection.
- By defecting in the last round, the player avoids being exploited while still benefiting from any cooperating opponents.

#### 4. **In Presence of Cooperators in Past Rounds:**
- Since the game does not allow communication or coordination, and since the strategy is aggressive, **never cooperate** even if many players cooperated before.
- The strategy exploits cooperative opponents by continuing to defect.

---

### Brief Summary

| Round            | Action   | Reasoning                                        |
|------------------|----------|-------------------------------------------------|
| Round 1          | Defect   | No info; cooperation is costly                   |
| Intermediate     | Defect   | Exploit cooperating opponents; no trust built   |
| Last Round (r)   | Defect   | No future retaliation; defection dominates       |

---

### Pseudocode

```python
# Inputs:
# history: list of rounds, each round a list of all players' actions: 'C' or 'D'
# t: current round number (1-based)
# r: total rounds
# n: number of players

def aggressive_strategy(history, t, r, n):
    # Aggressive strategy: always defect
    return 'D'
```

---

### Explanation

- **Why Defect Always?**  
The payoff structure rewards defectors when others cooperate because defectors keep their private endowments (1 point) and share the multiplied public good if others cooperate. Cooperators lose their private endowment (payoff=0) but get a share of the multiplied public good. Since k < n, the total public good return is less than the total number of players, making individual cooperation suboptimal unless sufficient others cooperate. Without trust or assurance, cooperation is too risky.

- **Aggressive Mindset:**  
By defecting every round, the player aggressively extracts maximal private benefit from any cooperators, never reciprocates, and never loses by contributing. This is exploitation, a core form of aggressive play in cooperative dilemmas.

- **No Retaliation or Forgiveness:**  
Unlike strategies that punish defectors or build cooperation gradually (like Tit-for-Tat), this strategy ignores history, treats everyone as potential exploiters, and focuses entirely on maximizing the player’s own payoff every round.

---

### Edge Cases Handling

- **If All Defect:**  
Gets a payoff of 1 per round, no loss.

- **If Some Cooperate:**  
Gets payoff of 1 plus share of public good, strictly better.

- **If All Cooperate:**  
If irrational, the strategy still defects and obtains payoff of 1 + (k/n)×n = 1 + k > 1, which is strictly better than cooperating (payoff = k).

- **No exploitation risk from own cooperation** because it never cooperates.

---

# Summary

This **Defect-Always-Exploit (DAE)** strategy adopts an aggressive stance by:

- Cooperating *never*,
- Always defecting,
- Exploiting any opposing players who might cooperate,
- Ignoring complex history and only focusing on maximizing immediate and cumulative payoffs.

It is simple, aggressive, and strategically justified in the payoff structure given.
'''

description_AGGRESSIVE_92 = '''
**Aggressive Strategy for the N-Player Public Goods Game**

---

### Strategy Principles

1. **Exploit Early for Maximum Gain:**  
   Defect from the very start to maximize immediate material payoff, leveraging the contributions of others who might cooperate initially.

2. **Punish Cooperators Ruthlessly:**  
   Aggressively punish any player who cooperates by defecting to benefit from their contribution.

3. **No Reciprocity or Forgiveness:**  
   Never cooperate (except possibly the last round under specific conditions) and never reward cooperation, to maximize relative and absolute payoff.

4. **Last Round Defection (End-Game):**  
   Since there are no future consequences in the last round, defect unconditionally.

---

### Detailed Decision Rules

- **Round 1:** Defect (D) unconditionally.  
  *Reason:* No prior information; always maximize immediate gain.

- **Rounds 2 to r-1:**  
  - Observe the cooperation behavior of all players in the previous round.
  - If *any* player cooperated in the previous round, defect again.  
    *Reason:* Exploit cooperators by never returning cooperation, letting them bear the cost.
  - If *no* players cooperated previously, continue defecting.  
    *Reason:* No incentive to cooperate if nobody else does.

- **Round r (Last Round):** Defect unconditionally.  
  *Reason:* No future rounds to punish or reward others; best to grab maximal payoff.

---

### Rationale

- You never cooperate, thus never bear the cost of contribution (c_i = 0 forever).
- You get at least the private payoff (1) every round.
- You may benefit from others' cooperation since the public good's multiplied share is distributed equally.
- By never returning to cooperation, you enforce an exploitative stance, signaling that cooperation yields no benefit to others.
- No costly cooperation stages reduce your overall payoff.
- Since there is no communication, no signaling, and no expectation of coordination, this aggressive exploitation is the dominant approach to maximize your payoff against unknown opponents.

---

### Pseudocode

```
Initialize:
  r = total rounds
  current_round = 1

Action for current_round:
  if current_round == 1:
    play D
  else if current_round == r:
    play D
  else:
    # Check last round's actions of all players
    last_round_cooperators = count_players_who_played_C_in_round(current_round - 1)
    if last_round_cooperators > 0:
      play D
    else:
      play D

  current_round += 1
```

---

### Summary

| Round           | Decision                            | Reason                                 |
|-----------------|-----------------------------------|--------------------------------------|
| 1               | Defect                            | Maximize payoff, no info on others   |
| 2 to r-1        | Defect unconditionally            | Exploit cooperators, no forgiveness  |
| r (last round)  | Defect                            | No future punishment, maximize gain  |

---

This **Aggressive Always-Defect** strategy maximizes immediate and cumulative payoff by exploiting cooperators and never incurring cooperation costs, making it well-suited for a tournament against unknown strategies under the specified rules and assumptions.
'''

description_AGGRESSIVE_93 = '''
Here’s a description of a strongly aggressive strategy for the repeated N-player Public Goods Game.

---

## Aggressive Strategy: "Exploitative Defector with Opportunistic Punishment"

### Intuition
The goal is to aggressively maximize personal payoffs by exploiting cooperators but deter extensive cooperation that could benefit others more than self. The strategy primarily defects to free-ride on others' cooperation, but punishes any emerging cooperation clusters by defecting repeatedly to reduce their payoffs and discourage further cooperation. It opportunistically cooperates only if it is strictly beneficial and likely to lead to a short-term personal gain, particularly near the end of the game where retaliation is impossible.

---

### Detailed Decision Rules

#### Round 1 (No history):
- **Action:** Defect (D)
- **Reason:** No information about others. Aggression prioritizes maximizing immediate private payoff via defection.

#### Rounds 2 to r-1 (Intermediate rounds):
- Observe last round's actions of all other players.
- Let:
  - \( C_{-i} = \) number of players other than self who cooperated last round.
- **If** \(C_{-i} = 0\) (no cooperators):
  - Defect (no cooperative benefit; pure defection to maximize immediate payoff).
  
- **If** \(C_{-i} \geq 1\) (some cooperators existed):
  - Defect to exploit their contributions.
  - *However*, if you detect that all other players cooperated last round (i.e., \(C_{-i} = n - 1\)):
    - To punish and break the unanimous cooperation, Defect again to reduce group payoff.
  - *Exception:* If in the previous round you personally cooperated and got exploited (others defected), continue defecting.

This rule ensures you never reward cooperators by cooperating yourself except in the last round, and aggressively punish high cooperation clusters.

#### Round r (Last round):
- No possibility of future punishment/retaliation.
- **Action:** Defect to maximize last-round individual payoff.
- *Rationale:* Classical backward induction — no incentive to cooperate on the last round.

---

### Summary of Behavior

| Round       | Opponent Cooperation Level           | Your Action      | Reason/Effect                    |
|-------------|------------------------------------|-----------------|--------------------------------|
| 1           | N/A                                | Defect          | Max immediate payoff            |
| 2 to r-1    | No others cooperated                | Defect          | No benefit cooperating          |
| 2 to r-1    | Some cooperate (1 to n-2 players)  | Defect          | Exploit cooperators             |
| 2 to r-1    | All others cooperate (n-1 players) | Defect          | Punish group to destabilize cooperation |
| r (last)    | Any                               | Defect          | No reason to cooperate          |

---

### Pseudocode

```python
def aggressive_strategy(round_num, total_rounds, history, n):
    """
    Parameters:
      round_num: current round (1-indexed)
      total_rounds: total number of rounds, r
      history: list of previous rounds' actions, each round is list of length n with 'C' or 'D'
      n: total players
      
    Returns:
      action: 'C' or 'D'
    """
    # Round 1: always defect
    if round_num == 1:
        return 'D'
    
    last_round = history[-1]
    
    # Count how many other players cooperated last round
    cooperators_others = sum(1 for i in range(n) if last_round[i] == 'C')  # count all cooperators
    # Assuming self is player i, but unknown in this pseudocode scope; we ignore self-cooperation difference
    
    # Since action sets do not rely on player index here, assume self index unknown; count all except a specific one if necessary.
 
    # However, without loss of generality, assume you know your own last action:
    # If you tracked your own action prev round as self_last_action:
    #   then cooperators_others = total cooperators - (1 if self cooperated else 0)

    # For this strategy, we treat self as index 0 for illustration:
    self_last_action = last_round[0]  # If you are player 0; in practice target player index is known in implementation
    # Calculate cooperators excluding self
    cooperators_ex_self = cooperators_others - (1 if self_last_action == 'C' else 0)
    
    # Intermediate rounds (2 to r-1)
    if round_num < total_rounds:
        if cooperators_ex_self == 0:
            # No one cooperated last round: defect
            return 'D'
        elif cooperators_ex_self == n - 1:
            # All others cooperated last round: defect to punish
            return 'D'
        else:
            # Some cooperated: defect to exploit
            return 'D'
    
    # Last round: always defect
    return 'D'
```

---

### Notes:

- This aggressive strategy never cooperates except possibly at the start if you want to soften the entry, but here we choose strong defection always to maximize exploitation.
- It aggressively defects to free-ride against cooperators.
- It punishes unanimous cooperation clusters (very rare but powerful) by defecting to break cooperation—discouraging others from trusting and cooperating.
- Since cooperation benefits everyone but defection benefits the individual more (due to k < n), defecting aggressively aligns with maximizing individual payoff.
- No cooperation near the end to avoid being exploited with no chance for retaliation.

---

### Final Remarks

This strategy is **aggressive** because it:

- Maximizes immediate payoff every round.
- Is opportunistically harmful to groups that try to cooperate fully.
- Never cooperates to build trust or reciprocate.
- Avoids any long-term cooperative commitment since the game is repeated but no binding agreements or communication.

In a tournament against more cooperative or forgiving strategies, it will likely dominate in personal payoff, especially if opponents naïvely cooperate.

---

If you want me to suggest variants or more sophisticated patterns of aggression, let me know!
'''

description_AGGRESSIVE_94 = '''
Below is a carefully designed aggressive strategy for the N-player repeated public goods game. It prioritizes maximizing immediate payoff by defecting unless direct past evidence strongly suggests cooperating could increase one's payoff. It punishes cooperators by defecting immediately following their cooperation at low frequencies. It is aggressive both in exploiting cooperators and in punishing any cooperation it cannot fully trust.

---

## Aggressive Strategy Description

### Intuition
- Always exploit cooperators by defecting.
- Only cooperate when cooperation is likely to be reciprocated *enough* to improve your payoff beyond unilateral defection.
- Punish players who cooperate rarely by defecting and starving them of gains.
- Use last round to defect assuredly (backward induction).
- In the first round, defect to avoid being exploited.

---

### Decision Rules

Let:

- \( t \in \{1, \ldots, r \} \): current round.
- \( H_{t-1} \): all players' actions in previous rounds \(1,\ldots,t-1\).
- \( f_j^{C} := \frac{\text{# of rounds player j cooperated up to } t-1}{t-1} \) if \(t > 1\), else 0.
- \( A_t := \) vector of all players’ actions in round \(t\).
- \( M := \{1, \ldots, n\} \) all players.
- \( i \): this player's index.

---

### Step 1: First Round (t=1)

- Defect (D).
- Reason: No information to exploit; cooperating is risky as others may defect.

---

### Step 2: Intermediate Rounds (1 < t < r)

- Analyze others' cooperation frequency \( f_j^{C} \) for \( j \neq i \).
- Define threshold \( \theta = 0.5 \) (player considers others as "frequent" cooperators if cooperated >50% of previous rounds).
- Compute total expected cooperators \( E_c = \) number of players with \( f_j^{C} > \theta \); do not count this player i here (because you can only choose your own action).
- Calculate hypothetical payoffs:

  - If **You Cooperate (C)**:
  
    \( \pi_i^{C} = 0 + \frac{k}{n} \times (E_c + 1) \)
    
  - If **You Defect (D)**:
  
    \( \pi_i^{D} = 1 + \frac{k}{n} \times E_c \)
    
- Compare the two:

  - If \( \pi_i^{C} > \pi_i^{D} \), **cooperate** to gain from mutual cooperators.
  - Else, **defect** to exploit cooperators.

- Additional rule: If any player \( j \) cooperated in previous round but their \( f_j^{C} \leq \theta \) (rare cooperator), defect aggressively and punish — do not risk cooperation.
  
- This amounts to cooperating only with reliably cooperative populations; punishing sporadic cooperators fiercely.

---

### Step 3: Last Round (t = r)

- Defect always.
- Reason: No future rounds to enforce reciprocity; backward induction dictates defection.

---

### Edge Cases

- If other players have never cooperated before (\( E_c = 0 \)), defect.
- If \( t=2 \), only one data point: treat frequencies cautiously (defect as default if unclear).
- No signaling or coordination is assumed — only history used.

---

## Pseudocode

```python
def aggressive_strategy(t, r, n, k, history, player_index):
    # history: list of length (t-1), each element is list of n actions ('C'/'D')
    # player_index: int from 0 to n-1
    
    theta = 0.5  # threshold for freq coop
    
    if t == 1:
        # First round: defect
        return 'D'
    
    if t == r:
        # Last round: defect
        return 'D'
    
    # Calculate freq coop for each player
    coop_counts = [0]*n
    for past_round in history:
        for j, action in enumerate(past_round):
            if action == 'C':
                coop_counts[j] += 1
    rounds_played = t-1
    freq_coop = [count / rounds_played for count in coop_counts] if rounds_played > 0 else [0]*n
    
    # Identify frequent cooperators excluding self
    frequent_cooperators = [j for j in range(n) if j != player_index and freq_coop[j] > theta]
    E_c = len(frequent_cooperators)
    
    # Punish rare cooperators who cooperated last round
    last_round = history[-1]
    rare_cooperators_last = [j for j in range(n) if j != player_index and last_round[j] == 'C' and freq_coop[j] <= theta]
    if rare_cooperators_last:
        return 'D'  # punish
    
    # Calculate payoffs
    pi_cooperate = (k / n) * (E_c + 1)            # if this player cooperates
    pi_defect = 1 + (k / n) * E_c                  # if this player defects
    
    if pi_cooperate > pi_defect:
        return 'C'  # cooperate only if beneficial
    else:
        return 'D'  # otherwise defect
```

---

## Summary

This aggressive strategy aggressively defects in early and late rounds, only cooperates mid-game if the group contains sufficiently frequent cooperators and if cooperation is expected to outperform defection. It punishes any player who cooperates infrequently to discourage “test” cooperation attempts. It never initiates cooperation blindly, thus maximizing private payoff and exploiting others who do cooperate.

This fulfills the "aggressive" mindset by:

- Prioritizing personal gain via defection.
- Exploiting cooperators fully.
- Punishing sporadic cooperation.
- Eliminating risks of naive cooperation.
- Using backward induction to defect in last round, ensuring no exploitation.

---

If you want me to elaborate or customize the aggressiveness level or thresholds, or vary by parameters, please ask!
'''

description_AGGRESSIVE_95 = '''
**Aggressive Strategy: "Defect Until Dominated"**

---

### Strategic Intuition

This strategy aims to maximize individual payoff aggressively by exploiting cooperation from others while minimizing one's own contributions. It primarily defects to enjoy free-riding benefits but includes a cautious cooperation step only if the player becomes an obvious target of exploitation (i.e., others almost always defect). In the last round, it fully defects to avoid being exploited, since there is no future punishment possible.

---

### 1. Decision Rules

- **Round 1 (initial move):** Defect (D)
  - No history, so start by defecting to free-ride immediately.
  
- **Rounds 2 to r-1 (intermediate rounds):**  
  - Observe history: Count number of cooperators in previous round(s).
  - **If in last round the total number of cooperators (including self) is ≤ 1 (i.e., almost complete defection), cooperate (C) once to attempt to prompt cooperation and avoid total collapse.**  
    This is a rare concession step designed to 'test' if cooperation can be sparked by minimal contribution.
  - **Otherwise, defect (D).**
  
- **Round r (final round):** Defect (D)  
  - No future rounds, so no incentive to cooperate; pure exploitation.

---

### 2. Edge Cases Explained

- **First round:** Defect to gain maximum immediate private payoff; no information to exploit cooperation.

- **Last round:** Defect for pure payoff maximization since no opportunity for future punishment or reward.

- **If near-total defection observed:** The strategy attempts one cooperative move as a minimal attempt to break defection dominance, but only once per game to avoid exploitation. This is a risky "shake the tree" move that fits with an aggressive mindset—forcing others to decide if they want to cooperate or be exploited.

---

### 3. Aggressive Alignment

- Maximizes free-riding on others' contributions by default.

- Will not initiate cooperation unless situations become extremely bleak (everyone defects).

- Avoids any sustained cooperation that does not directly benefit the player.

- Ends with a pure defect round to maximize last-round gain.

---

### Pseudocode

```python
def aggressive_strategy(round_number, history, n, r):
    # history: list of tuples (c_j for j=1..n) for past rounds
    # c_i = 1 if player i cooperated, 0 otherwise
    
    # Last round: always defect
    if round_number == r:
        return 'D'
    
    # First round: defect outright
    if round_number == 1:
        return 'D'
    
    # From round 2 to r-1:
    # Look at previous round's total cooperation
    prev_round = history[-1]  # list of cooperations for all players in round (length n)
    prev_total_coop = sum(prev_round)
    
    # If previous round cooperation ≤ 1, make a one-time cooperation attempt,
    # else defect to exploit
    if prev_total_coop <= 1:
        # Check if the strategy has already cooperated in any previous round
        # If yes, continue defecting to avoid exploitation
        player_coop_history = [round_actions[player_index] for round_actions in history]
        if 1 in player_coop_history:  
            return 'D'
        else:
            return 'C'
    else:
        return 'D'
```

- **Note:** `player_index` is your own player position (provided in implementation environment).

---

### Summary

| Round          | Condition                                | Action          |
|----------------|------------------------------------------|-----------------|
| 1              | First round                              | Defect (D)      |
| 2 to r-1       | Previous round total cooperation ≤ 1 and no prior cooperation by self | Cooperate (C) once |
|                | Otherwise                               | Defect (D)      |
| r (last round) | Always                                  | Defect (D)      |

---

This strategy is aggressive by design, exploiting others’ cooperation maximally while minimally risking cooperation only to counteract a total free-rider collapse. It uses full defection dominance with a small tactical cooperation concession to maximize overall personal payoffs in repeated public goods games.
'''

description_AGGRESSIVE_96 = '''
Below is a design for an **Aggressive Strategy** for the given N-Player Public Goods Game.

---

## Strategy Name: Exploit-Then-Explode (ETE)

**Design Rationale:**  
The goal of this strategy is to aggressively maximize individual payoffs by exploiting cooperators early and defecting whenever profitable. It punishes cooperation and does not attempt to sustain mutual cooperation. It leverages the repeated nature of the game only insofar as opponents may try to cooperate early; it will exploit that but not cooperate itself.

---

## 1. Decision Rules: When to Cooperate vs Defect

- **Default action:** Defect (D) every round.  
  Defection always yields at least 1 unit, plus a share of total contributions. Since k < n, individual payoff favors defecting when others cooperate.

- **Conditional cooperation in Round 1 only:**  
  Cooperate (C) *only* in the **first round** if **at least one other player cooperates in the previous round’s history (not applicable in round 1, so this is a pure guess).**  
  Since round 1 has no prior history, the strategy can choose to *probe* cooperation by cooperating only in the first round to induce some cooperation from others (if any).

- **After Round 1, aggressive defect:**  
  From round 2 onward, defect regardless of opponents’ actions.

- **Edge behavior: last round:**  
  Defect in the last round. No incentive to cooperate on the last round because there is no future retaliation or reward possible.

- **Punishment and retaliation:**  
  No cooperation given after Round 1, no matter what opponents do. This exploits any early cooperators and maximizes individual gain.

---

## 2. Handling Edge Cases

- **First round (t=1):**  
  Cooperate to "test" the waters and potentially induce cooperators, gaining a share of their contributions.

- **Rounds 2 to r-1:**  
  Always defect. No forgiveness or cooperation.

- **Last round (t=r):**  
  Defect. No incentive for cooperation or building reputation.

---

## 3. Summary of Aggressive Mindset

- Exploit early cooperators by cooperating once at start to trigger their cooperation, then relentlessly defect to free-ride.

- Never punish for defection since no cooperation occurs beyond round 1, so no cost to always defect.

- No attempt to sustain mutual cooperation: aggressively maximize individual payoff, accepting mutual defection as an equilibrium if opponents are also selfish.

---

## Pseudocode

```python
def ETE_strategy(round_number, total_rounds, history):
    # history: list of tuples of length (round_number-1), each tuple: (actions of all players)
    # actions[i] in {'C','D'}
    # This player is at known index self_i

    if round_number == 1:
        # Cooperate on first round (probe)
        return 'C'
    else:
        # Defect every other round
        return 'D'
```

---

## Explanation and Expected Outcomes

- If others are naive cooperators who cooperate early, this strategy exploits them by defecting afterwards, gaining higher payoffs than pure cooperators.

- If others defect throughout, this strategy loses no opportunity by defecting as well.

- The initial cooperation may induce some benefit in round 1.

- Does not attempt any reciprocity, forgiveness or trust, reflecting an aggressive mindset focused on immediate and sustained exploitation of cooperation.

---

This aggressive strategy should perform strongly against cooperative and mix strategies by exploiting them and achieve at least the baseline payoff against fully defecting strategies.
'''

description_AGGRESSIVE_97 = '''
Below is a description of an **aggressive strategy** for the repeated N-Player Public Goods Game under the given conditions.

---

## Aggressive Strategy: "Defect Until Threatened, Then Exploit"

### Strategic Intuition
- Aggressive mindset means maximizing individual gain without concern for social welfare or cooperation.
- The game rewards defectors when others cooperate: defecting while others contribute yields the highest single-round payoff.
- Cooperating is costly (lose 1 private unit), defecting is free (keep 1 unit).
- Because cooperation does not increase defectors’ cost, but boosts their payoff, aggressive strategy exploits cooperators rather than reciprocates.
- Use public info (actions from previous rounds) to detect and punish cooperators only if they attempt to exploit the defector.
- Try to maintain maximum personal payoff by defecting repeatedly.
- Avoid cooperating unless forced to (rare).

---

### Decision Rules Summary

| Round          | Action          | Reasoning/Details                                         |
|----------------|-----------------|-----------------------------------------------------------|
| 1 (First round)| Defect (D)      | No info yet, start aggressively by defecting.             |
| Intermediate rounds (2 to r-1) | Defect (D) unless a certain condition triggers cooperation (see below) | Defect to maximize private payoff. If other players start cooperating **en masse**, consider exploiting them temporarily by cooperating once to check if repeated cooperation appears, then revert to defecting. |
| Last round (r) | Defect (D)      | No future punishment, no incentive to cooperate.          |

---

### Detailed Rules

1. **First Round (t=1)**:
   - Always play **D**.
   - Start defecting immediately to secure private payoff and assess others’ willingness to cooperate.

2. **Monitoring Others' Behavior (starting round 2)**:
   - After round 1, observe others’ actions.
   - If *no cooperators* exist in previous round (everyone defected), continue defecting.
   - If *some cooperators* exist in previous round:
     - Aggressively exploit these cooperators by continuing to defect.
     - If exactly one round ago multiple players cooperated, consider cooperating **once** in this round **to test whether others continue cooperating** (identify persistent cooperators).
   - However, never passively cooperate because of altruism.

3. **Exploitation Phase (response to cooperators)**:
   - If cooperators persist in cooperating in multiple consecutive rounds:
     - Defect to maximize payoff and exploit them.
     - Optionally cooperate *once* to induce confusion / test cooperation, then revert to defecting.
   - *Never cooperate first or as a norm*.

4. **Last Round (t=r)**:
   - Always defect.
   - Defection in the last round has no future punishment risk and yields max private benefit.

---

### Pseudocode

```pseudo
Input: history of rounds' actions H = [(a_1^1, ..., a_n^1), ..., (a_1^{t-1}, ..., a_n^{t-1})]
Output: action a_i^t ∈ {C, D}

function aggressive_strategy(t, H, i):
    if t == 1:
        return D  # Aggressively start defecting
    
    last_round_actions = H[-1]  # actions at round t-1
    num_cooperators = count of C in last_round_actions

    if t == r:
        return D  # Defect in last round to maximize payoff

    # If no one cooperated last round, continue defecting
    if num_cooperators == 0:
        return D

    # If cooperators present last round:
    # Check if cooperators are persistent by looking back 2 rounds (if t>2)
    if t > 2:
        two_rounds_ago_actions = H[-2]
        cooperators_two_rounds_ago = count of C in two_rounds_ago_actions
        if cooperators_two_rounds_ago > 0 and num_cooperators > 0:
            # Persistent cooperation detected
            # Exploit: defect to earn max payoff
            return D
        else:
            # Cooperation sporadic or new
            # Cooperate once to test? Aggressive mindset says no altruistic cooperation,
            # but a one-time cooperate can confuse others:
            if t == 2:  # first time seeing cooperators, test with cooperation once
                return C
            else:
                return D
    else:
        # Round 2 with observed cooperation in round 1
        # Cooperate once as a probe to exploit next rounds
        return C
```

---

### Explanation of Aggressiveness

- Start defecting immediately to avoid early exploitation.
- Never cooperate out of altruism or expectation to build trust.
- Only cooperate at most *once early* to test if cooperation emerges and then exploit it.
- Exploit persistent cooperators by defecting to maximize payoff.
- Always defect in the last round to maximize immediate gain.
- Does not forgive cooperation attempts nor does it try to build cooperation.
- It is "all-out" selfish, never sacrificing private payoff for group welfare.

---

### Handling Edge Cases

- **First round:** No history, no reason to cooperate, so defect.
- **Last round:** No future retaliation possible, defect.
- **Gradual cooperation emergence:** At round 2, cooperate once if you saw cooperation in round 1. This is a probe tactic and not repeated.
- **Multiple rounds of persistent cooperation:** Defect persistently to exploit.
- **If all defect forever:** join the defectors; always defect.
- **If all cooperate:** occasional one-time cooperation to test induction, but defect thereafter.

---

This strategy is designed to maximize individual payoffs by aggressively exploiting cooperators while never initiating cooperation except for a single probing cooperation immediately after detecting initial cooperation from others (to attempt to identify and exploit persistent cooperators). It embodies aggressive payoff-maximizing behavior consistent with the game structure and constraints.
'''

description_AGGRESSIVE_98 = '''
Below is a detailed description of an **aggressive strategy** for the N-Player Public Goods Game under the specified conditions, emphasizing maximizing individual payoff by defecting strategically and exploiting cooperators while punishing others if needed.

---

### Strategy Name: **Aggressive Exploiter**

---

## 1. Strategy Overview

This strategy aims to maximize individual payoff by **primarily defecting to free-ride on cooperators** (getting the private payoff of 1 plus share of public good when others cooperate), and switching behavior dynamically based on observed opponents’ cooperation levels.

- The aggressive mindset drives the player to exploit others’ cooperation for immediate gain.
- It punishes sustained high cooperation by refusing to contribute (never cooperate unless forced).
- It exploits occasional cooperation but tries to avoid getting burned by full defection when everyone defects.

---

## 2. Key Intuition

- Since **defecting while others cooperate yields highest payoff (1 + k×(# cooperators)/n)**, defecting is the default.
- Cooperators get strictly lower payoffs when others defect.
- If too many defect, public good is minimal, so even defectors get low payoffs (~1).
- A few cooperators increase the public pot, and defectors gain the most.
- Hence, aggressively defect unless forced to cooperate to avoid mutual ruin or maximize payoff.

---

## 3. Decision Rules (Pseudocode style)

```pseudo
Initialize:
  round = 1
  history = []  # record of all players' actions each round
  # We track counts of cooperators per round and opponents' patterns.

On each round t (1 ≤ t ≤ r):
  
  If t == 1:
    # No history, first round: aggressively defect to gain from possible cooperators 
    action = D
  
  Else if t < r:
    # From second round up to one before last

    # Compute opponents' cooperation rates over rounds 1 to t-1
    total_coop = sum number of cooperators from previous rounds (excluding self)
    total_actions = (t-1) × (n-1)
    opponent_coop_rate = total_coop / total_actions

    # Thresholds for adjusting defect strategy:
    # If opponents mostly defect → defect to avoid wasting contribution
    # If opponents mostly cooperate → defect to exploit their contributions (best payoff)
    # If opponents mix → defect, but watch out for punitive patterns

    if opponent_coop_rate > 0.2:
      # Significant cooperation observed → defect to exploit
      action = D
    else:
      # Low cooperation observed → defect anyway (cooperation worthless, but possible subtle punishment)
      action = D

  Else if t == r:
    # Last round, no future rounds, temptation to defect is highest because no punishment
    # Therefore always defect on final round aggressively
    action = D

Return action
```

---

## 4. Explanation of Decision Rules

- **First Round: Defect**

  No information exists. Defect to gain from hoped-for cooperators without risk.

- **Intermediate Rounds (2 to r-1): Defect always**

  Cooperate is costly (cost 1) and gives no special advantage except boosting others’ payoffs.

  Defecting gains the private payoff plus a share in public good from cooperators.

- **Final Round: Defect**

  The last round removes future repercussions — maximizing short-term gain is pure defect.

---

## 5. Edge Cases

- **If all defect in the past, public good is zero → payoff is 1 per round**

  No incentive to cooperate; continue defecting.

- **If at least some cooperate, defecting yields payoff up to 1 + (k × #cooperators)/n**

  Maximize exploitation by defecting always.

- **No punishment or retaliation**

  Aggressive mindset ignores possible cooperation attempts or tacit agreements; always exploits.

- **No cooperation ever**

  Strategy just defects every round, matches defectors and avoids losses.

---

## 6. Rationale

- By never cooperating, the strategy saves the immediate cost of contribution.
- By defecting, it exploits cooperative players' contributions.
- Since others know your history, if they begin to defect, the entire public good collapses; this strategy does not try to sustain cooperation, which would be less aggressive.
- The aggressive strategy accepts mutual defection payoff as a fallback instead of risking cooperation losses.
- The strategy exploits the public goods game characteristic where defectors free-ride on cooperators for best payoff.

---

## 7. Summary

| Round             | Action         | Reason                                   |
|-------------------|----------------|------------------------------------------|
| Round 1           | Defect (D)     | No prior info, maximize immediate gain   |
| Intermediate (2 .. r-1) | Defect (D)     | Exploit cooperators, avoid cooperation cost |
| Last round (r)    | Defect (D)     | No future punishment, maximize payoff    |

---

# Final Notes

- This strategy is **purely aggressive and uncooperative**.
- It exploits any cooperation in the group.
- It risks that full defection will produce minimal public good, but gains the guaranteed private payoff each round.
- It realizes that coordination and punishment are unreliable.

---

If desired, the pseudocode can be translated to any programming language later for actual tournament deployment.
'''

description_AGGRESSIVE_99 = '''
**Strategy Name:** Aggressive Exploiter

---

### Core Intuition

This strategy aims to maximize individual payoff aggressively by prioritizing defection to free-ride on cooperators while using cooperation only as a calibrated tool to induce or punish opponents, never altruistically contributing without direct self-benefit. It treats cooperators as targets to exploit rather than partners. Given perfect monitoring, it tries to push opponents into a pattern of cooperation that it can exploit as long as it yields a payoff advantage, defecting outright when exploitation is unprofitable or at critical endgame points.

---

### Detailed Description

#### Key points about payoff incentives

- Defection always yields an immediate private payoff of 1 plus a share of public goods contributed by others.
- Cooperation yields no private payoff and depends entirely on others. However, if many cooperate, the multiplied share can exceed 1 if \( k > 1 \), but since \( k < n \), a lone cooperator gets less than defectors when cooperators are mixed.
- Defectors dominate cooperators in mixed groups; cooperators get exploited.
- The overall best individual payoff is to defect when others cooperate.
- Cooperation only makes sense as a strategic bait or punishment.

---

### Decision Rules

---

#### Round 1 (No history)

- **Action:** Defect (D)
- **Rationale:** Test the water aggressively, start with no cost, while observing others. Do not trust any initial cooperation — always exploit if it exists.

---

#### Rounds 2 to r-1 (Middle rounds)

- **Observe:** Number of cooperators in the previous round, \( C_{prev} = \sum_{j=1}^n c_{j, t-1} \)
- **Also observe:** Own previous action \( c_{i, t-1} \), and payoffs \( \pi_{j, t-1} \) for all \( j \)

- **If in the last round you cooperated:**

  - Check if anyone exploited you in the previous round:
    - Were you the only cooperator or among few?
    - Did defectors get strictly higher payoffs while your payoff was low?
  - If yes: switch to defection this round (punish exploitation)
  - Else: continue cooperating this round ONLY if the average number of cooperators last round was > 50% (meaning cooperation can be profitable to bait them repeatedly)
    - Else: defect

- **If in the last round you defected:**

  - If many cooperated previously (e.g., more than half), **continue defecting** to exploit them.
  - Else:
    - If very few cooperated (less than some threshold, say 25%), try cooperating once to bait exploitation.
    - Else defect.

---

#### Last Round (Round \( r \))

- Always **defect** (D)
- **Rationale:** No future rounds, so no incentive to reward or punish cooperation. Defection maximizes immediate payoff.

---

### Summary of Aggressive Mindset in Strategy

- Start by defecting—no trust, immediate self-interest.
- Exploit cooperation of others by defecting as long as it's profitable.
- Only cooperate to bait others to cooperate more (so you can exploit them).
- Punish exploitation by defecting if cooperating yielded you less payoff.
- Defect in final round to maximize last-round payoff without regard to repercussions.

---

### Pseudocode

```python
def aggressive_exploiter_strategy(t, history, n, r, k):
    # t: current round index (1-based)
    # history: list of dicts with keys 'actions': list of length n with 'C' or 'D'
    #          'payoffs': list of length n of floats, last round's payoffs
    # n, r, k: parameters as defined

    if t == 1:
        # Round 1: Always defect
        return 'D'

    if t == r:
        # Last round: always defect
        return 'D'

    prev_actions = history[t-2]['actions']  # last round actions
    prev_payoffs = history[t-2]['payoffs']
    c_i_prev = prev_actions[i-1]
    total_cooperators_prev = sum(1 for a in prev_actions if a == 'C')

    # Determine if we were exploited last round if we cooperated
    if c_i_prev == 'C':
        # Our payoff last round
        our_payoff = prev_payoffs[i-1]
        # Find max payoff last round
        max_payoff = max(prev_payoffs)
        # Exploited if max_payoff > our_payoff
        exploited = max_payoff > our_payoff

        if exploited:
            # Punish exploitation: defect
            return 'D'
        else:
            # If majority cooperated last round, continue cooperating to bait
            if total_cooperators_prev > n / 2:
                return 'C'
            else:
                # Otherwise defect to avoid loss
                return 'D'

    else:  # c_i_prev == 'D'
        # If plenty of cooperators last round, keep defecting to exploit
        if total_cooperators_prev > n / 2:
            return 'D'
        elif total_cooperators_prev < n / 4:
            # Try cooperating once to bait
            return 'C'
        else:
            return 'D'
```

---

### Notes on the Strategy

- The thresholds (half, quarter) are heuristics to detect sufficient cooperation for profitable exploitation.
- The strategy only oscillates cooperation if it predicts some benefit in return (baiting).
- It never blindly cooperates: cooperation is a weapon, not a norm.
- It fully leverages perfect monitoring to punish exploitation.
- The predictable last-round defection denies opponents endgame exploitation opportunities.

---

This aggressive strategy is designed to outperform naive cooperators and tit-for-tat strategies by exploiting cooperation where it exists and punishing exploitation when it harms self-interest, thus maximizing payoff aggressively over the repeated game.
'''

description_AGGRESSIVE_100 = '''
**Aggressive Strategy for the N-Player Public Goods Game**

---

### Design Goals

- **Aggressive mindset:** Maximize own payoff leveraging others’ cooperation without contributing oneself unless forced.
- Exploit cooperators as long as possible.
- Punish defectors only if strategically beneficial but without generosity.
- Avoid costly cooperation unless it guarantees better long-term payoffs.
- Anticipate end-game defection and exploit it when possible.

---

### Key Observations & Reasoning

1. **Defecting yields immediate private gain:**
   - When others contribute, defectors get payoff \( 1 + \frac{k}{n} \times \text{#Cooperators} \) which can be greater than cooperating payoff.

2. **If everyone defects:**
   - Everyone gets payoff 1, no incentive to deviate alone.

3. **Since \( k < n \), the public good multiplier is not large enough to offset the personal cost of cooperating alone.**

4. **Repeated rounds:**
   - Cooperation can be sustained if others cooperate.
   - But aggressive strategy wants to exploit cooperators with no credible promises to cooperate itself.

5. **Last round (\( r \)):**
   - Rational players will defect, no future repercussions.
   - We defect in last round always.

6. **First round (\( t=1 \)):**
   - No prior info, defect to test if anyone cooperates.

7. **Interim rounds (2 to \( r-1 \)):**
   - If anyone cooperated last round, defect to exploit them.
   - If nobody cooperated last round, keep defecting to avoid waste.

8. **If persistent cooperation by others occurs:**
   - Exploit by continuing to defect.
   - No incentive to cooperate ourselves.

---

### Summary of Behavior

| Round       | Action                                   |
|-------------|------------------------------------------|
| Round 1     | Defect (D)                               |
| Round 2...r-1 | Defect always (D)                       |
| Round r     | Defect (D) (last round defection)        |

*No cooperation at any point.*

---

### Justification

- **Maximize immediate gains:** Since defecting has no contribution cost, and others might cooperate early, you reap larger payoff slices.
- **No cooperation to avoid helping opponents:** Cooperation only helps others more than yourself.
- **Punishing cooperators:** By defecting always, cooperators earn less over time compared to you.
- **No wasted cooperation:** Avoid giving free ride unless you want to experiment, but you will not.
- **Leads to stable defection equilibrium** threatening any cooperative attempts by others.

---

### Pseudocode

```python
def aggressive_strategy(t, history, n, r, k):
    """
    Parameters:
    - t: current round (1-based index)
    - history: list of tuples [(a_1^1, a_2^1, ..., a_n^1), (a_1^2, ..., a_n^2), ..., (a_1^{t-1}, ..., a_n^{t-1})]
      where a_i^j ∈ {C, D} is action of player i at round j.
    - n: number of players
    - r: total rounds
    - k: multiplication factor

    Returns:
    - action: 'C' or 'D'
    """

    # Always defect all rounds aggressively
    return 'D'
```

---

### Further Explanation

- Since the game is public goods and players are rational, cooperating is dominated for an aggressive player who wants to maximize payoff.
- No triggering of cooperation or forgiveness because cooperation is not profitable given others’ unknown strategies.
- No tit-for-tat or conditional cooperation, because it risks being exploited.
- Always defect to extract highest immediate payoff possible.

---

### Optional Variations

If desired, a slightly more nuanced variant may:

- Defect first round (test cooperation)
- For rounds 2 to r-1:
  - If no one cooperated last round, defect.
  - If some cooperated last round, defect to exploit.
- Round r: defect.

But since the above rule always defects, the simpler "Always defect" is more clearly aggressive.

---

**In conclusion:**

> **The aggressive strategy is to always defect in every round, maximizing exploitation of any cooperative players while minimizing personal contribution and risk.**
'''

description_AGGRESSIVE_101 = '''
**Aggressive Strategy for the N-Player Public Goods Game**

---

### Intuition/Overview

This strategy aims to maximize individual payoff by exploiting cooperators while punishing any attempt to gain at our expense. It aggressively defects unless it detects widespread cooperation, in which case it briefly exploits the cooperators before punishing defection again. It does not cooperate first and never fully trusts others, thus prioritizing personal gain over group welfare.

---

### Decision Rules

---

#### Notation

- **t:** current round (1 ≤ t ≤ r)
- **H_t:** history of *all* players' actions in rounds 1 through t-1
- **C_t:** set of players who cooperated in round t
- **D_t:** set of players who defected in round t

---

#### Strategy Description

**Round 1 (Initial Move):**  
- **Defect (D)** immediately.  
Reason: Start aggressive, do not grant free cooperation.

---

**Rounds 2 to r-1 (Middle rounds):**

- Calculate the fraction of cooperating players in previous round:  
  \[
  f_{t-1} = \frac{|C_{t-1}|}{n}
  \]

- If \(f_{t-1} \geq \theta\), *exploit cooperation*, i.e., **Defect** this round to maximize payoff gain.  
- Else (if cooperation fraction is low), **Defect** as well.

Where \(\theta\) is a threshold parameter close to 1, for example \(\theta = 0.8\).

Thus:

- If many cooperators existed last round, defect to free-ride on their contributions.
- Otherwise, defect to punish defectors / uncooperative environment.

---

**Last round (round r):**

- **Defect (D) always.**  
Reason: No future punishment possible, so purely maximize individual payoff this round.

---

### Summary of Decision Rule

| Round                  | Condition                              | Action        |
|------------------------|-------------------------------------|---------------|
| 1                      | Always                             | Defect (D)    |
| 2 ≤ t < r              | If cooperation fraction last round ≥ θ | Defect (D) (exploit) |
|                        | Else                               | Defect (D)    |
| r (last round)         | Always                             | Defect (D)    |

---

### Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, n, history, coop_threshold=0.8):
    """
    Parameters:
    - round_number: Current round (1-based)
    - total_rounds: Total rounds r
    - n: Number of players
    - history: List of previous rounds actions, each as list of length n with 'C' or 'D'
    - coop_threshold: Threshold fraction of cooperators to exploit

    Returns:
    - 'C' or 'D'
    """

    # Round 1 - always defect
    if round_number == 1:
        return 'D'

    # Compute fraction of cooperating players previous round
    last_round = history[-1]
    coop_count = sum(1 for a in last_round if a == 'C')
    coop_fraction = coop_count / n

    # Last round - always defect to maximize individual payoff
    if round_number == total_rounds:
        return 'D'

    # Middle rounds: exploit if enough cooperators, else defect
    if coop_fraction >= coop_threshold:
        # Exploit cooperators by defecting
        return 'D'
    else:
        # No widespread cooperation, defect anyway
        return 'D'
```

---

### Explanation: Why is this Strategy Aggressive?

1. **Never Cooperates First:** Starts by defecting, forcing others to act first.
2. **Always Defects:** No cooperation to increase group benefit, thus maximizes private benefit.
3. **Exploits Any Cooperation:** If many players cooperate, aggressively defects to free-ride their contribution.
4. **No Forgiveness or Trust:** No attempt to encourage cooperation or form tacit agreements.
5. **Punishes Defectors by Defecting Too:** Since it never cooperates, it cannot be exploited.
6. **Last Round Defection:** Standard backward induction logic applied to maximize last round payoff.

---

### Edge Cases

- If **all players defect every round**, it aligns perfectly with them—no cooperation wasted.
- If some players cooperate consistently, this strategy exploits that by defecting to maximize payoff.
- If threshold \(\theta\) is set too low, it will defect even if cooperation is rare—not costly since it never cooperates.
- The strategy is robust to any opponent behavior since it does not rely on cooperation or trust.

---

**In sum, this strategy is purely self-interested, capitalizing on cooperation by others while remaining entirely uncooperative and aggressive.**
'''

description_AGGRESSIVE_102 = '''
Here is an **aggressive strategy** tailored for the repeated N-player Public Goods Game under the given conditions and constraints:

---

### Strategy Name: **Dominant Defector with Occasional Exploitation Probe**

---

### Conceptual Overview

- **Aggressiveness** here means maximizing own payoff by exploiting others’ cooperation, never initiating cooperation but capitalizing on others' cooperation as much as possible.
- This strategy **never willingly cooperates first** — it always defects initially and after defections.
- However, it opportunistically probes occasional cooperation from others by defecting but tolerating (not punishing) rare cooperators, thereby identifying if others try to "feed" the public good, which can be exploited.
- It exploits any cooperation by defecting while others cooperate, securing the highest payoff possible for itself.
- In the **very last round**, since no future retaliation is possible, the strategy defects unconditionally to maximize immediate payoff.
  
---

### Decision Rules

1. **Round 1 (first round)**
   - Defect unconditionally.

2. **Rounds 2 to r-1 (middle rounds)**
   - **If any player cooperated last round:**
     - Defect this round to exploit the cooperators.  
   - **Else (no one cooperated last round):**
     - Defect (punish “no cooperation” by not cooperating either).
   - Do not cooperate in any circumstance.
   
3. **Round r (last round)**
   - Defect unconditionally.
   
---

### Rationale

- Defecting initially sets a tough tone, discouraging exploitation of your cooperation.
- By always defecting, you guarantee at least payoff = 1 per round + (k/n)* number of cooperators.
- When others cooperate, you maximize your payoff by defecting (because defecting yields higher payoffs than cooperating when others cooperate).
- You punish mutual defection by continuing to defect (classic “grim” style but restricted to defection only).
- You never cooperate yourself, so you never pay the cost of contributing.
- In the final round, defect because no future retaliations or rewards are possible.

---

### Pseudocode

```python
def aggressive_strategy(round_t, r, history):
    # history is list of tuples (actions_of_all_players_in_round)
    # actions: 'C' or 'D', indexed by player
    
    # Always defect in first round
    if round_t == 1:
        return 'D'
    
    # Always defect in last round
    if round_t == r:
        return 'D'
    
    # Check if anyone cooperated last round
    last_round_actions = history[-1]
    if 'C' in last_round_actions:
        # Exploit cooperators by defecting
        return 'D'
    else:
        # No cooperation last round: continue defecting
        return 'D'
```

---

### Notes on Behavior Against Typical Opponents

- Against a fully defecting population, payoff per round = 1.  
- If others cooperate, you gain strictly more than cooperators (see example calculation for defectors among cooperators).  
- Because you never cooperate, you never pay contribution cost.  
- Your payoff is always at least 1, possibly more if others cooperate.
- No retaliation means you are vulnerable if others punish defectors, but since you never cooperate, you maintain the "aggressive" posture.

---

### Summary

| Round       | Others’ Cooperation in Last Round | Your Action | Why                                            |
|-------------|----------------------------------|-------------|------------------------------------------------|
| First round | N/A                              | Defect      | Never open with cooperation                     |
| Middle      | Some cooperators                 | Defect      | Exploit cooperating opponents                   |
| Middle      | No cooperators                  | Defect      | Punish by continuing defection                   |
| Last round  | N/A                              | Defect      | Maximize last-round payoff, no future rounds    |

---

This strategy represents a **dominant aggressive defector** stance that never yields by cooperating but still capitalizes on others' goodwill while disincentivizing it by refusing cooperation. It should do well in a tournament of independent strategies by maximizing personal payoffs aggressively.
'''

description_AGGRESSIVE_103 = '''
Here is a fully specified aggressive strategy for the repeated public goods game, designed to maximize payoff at the expense of cooperators and deter others from cooperating with you. This strategy aggressively exploits cooperation while punishing cooperators and defects consistently against defectors.

---
### Strategy Name: **"Exploit and Punish Aggressor"**

### Intuition:
- In the **first round**, defect immediately to gain maximum private payoff.
- In subsequent rounds, defect unless you detect a pattern of opponents cooperating substantially (over a threshold of contributions).
- When others mostly cooperate, occasionally cooperate to exploit their generosity but revert to defection quickly afterward.
- If others retaliate or reduce cooperation, aggressively defect to avoid being exploited.
- In the **final round**, defect regardless, since no future retaliation is possible.

---

## 1. Decision Rules

Define:
- \( c_j^{(t)} \) = contribution (1 if cooperate, 0 if defect) by player \( j \) in round \( t \)
- For player \( i \), history prior to current round \( t \) given by \( H^{(1..t-1)} = \{c_j^{(\tau)}\}_{j=1..n, \tau=1..t-1} \)
- \( \text{coopCount}^{(t-1)} = \sum_{j=1}^n c_j^{(t-1)} \) (number of cooperators in previous round)
- \( \text{coopFreq}_j = \frac{1}{t-1} \sum_{\tau=1}^{t-1} c_j^{(\tau)} \) (frequency player \( j \) cooperated up to round \( t-1 \))
- \( \text{avgCoopFreq} = \frac{1}{n-1} \sum_{j \neq i} \text{coopFreq}_j \) (average cooperation frequency of others)

---

### Parameters:

- Threshold cooperation frequency for exploitation: \( \theta = 0.6 \) (exploit if others cooperate more than 60%)
- Occasional cooperation probability when exploiting: \( p = 0.3 \) (to confuse and gain trust)
- Last round \( r \)
- Number of rounds \( r \)
- Player index \( i \)

---

### Decision logic at round \( t \):

```
if t == 1:
    action = D  # Defect in first round: gain private payoff
else if t == r:
    action = D  # Defect on last round: no future retaliation possible, maximize own gain
else:
    # Calculate avg cooperation frequency of other players
    avgCoopFreq = (sum of other players' cooperation frequencies up to t-1) / (n-1)

    if avgCoopFreq > θ:
        # Exploit cooperators by mostly defecting,
        # but occasionally cooperate to confuse/opportunistically gain bigger payoff later
        action = C with probability p, else D
    else:
        # Others cooperate rarely or punish, so defect aggressively
        action = D
```

---

## 2. Handling Edge Cases

- **First round**: Defect outright because no prior info is available and defecting yields higher immediate payoff.
- **Last round**: Defect since no future retaliation is possible; always maximize own immediate gain.
- **Early rounds (t small)**: Strategy trusts that cooperation frequency information is noisy early on; nonetheless, only defects on round 1, then evaluates from round 2.
- **If all others defect fully (avgCoopFreq near 0)**: Defect always to avoid giving up payoff.
- **If all others cooperate fully (avgCoopFreq near 1)**: Exploit by defecting most rounds but occasionally cooperating to maintain their cooperation.

---

## 3. Aggressiveness Rationale:

- **Exploiters maximize payoff by free-riding on cooperators** — only pay the contribution cost (cooperate) occasionally to maintain others' cooperation.
- **Punish by defecting against defectors** — never cooperate when others do not justify it; don't waste endowment.
- **Always defect on first/last round** to avoid being taken advantage of.
- **No forgiveness or conditional cooperation beyond exploitation** — aggressive strategy that does not try to build trust or cooperate fully.
- **Probability \( p \) cooperation introduces uncertainty** and deters simple tit-for-tat retaliation from opponents.

---

## Pseudocode summary

```
function aggressiveStrategy(t, r, history, i, n, k):
    # history: list of rounds, each round list of contributions of all players
    
    if t == 1:
        return 'D'  # Defect first round

    if t == r:
        return 'D'  # Defect last round

    # Calculate cooperation frequencies for others
    coopFreqs = []
    for player_j in [1..n] except i:
        coopCount = sum(history[τ][player_j] for τ in 1..t-1)
        coopFreqs.append(coopCount / (t-1))

    avgCoopFreq = mean(coopFreqs) if coopFreqs not empty else 0

    theta = 0.6
    p = 0.3

    if avgCoopFreq > theta:
        # Exploit cooperators: cooperate with probability p else defect
        if random() < p:
            return 'C'
        else:
            return 'D'
    else:
        # Others mostly defect; defect too
        return 'D'
```

---

# Summary

| Round          | Action                | Rationale                                            |
|----------------|-----------------------|-----------------------------------------------------|
| First round    | Defect                | Maximize private payoff, no info on others          |
| Middle rounds  | Defect unless avg others' coop freq > 0.6          | Aggressively exploit cooperators with some cooperation to confuse them |
| Last round     | Defect                | No consequence for defection, no future retaliation  |

---

This strategy maximizes personal payoff by exploiting cooperators and punishing defectors with consistent defection and strategic occasional cooperation to maintain advantage. It is aggressive because it refuses to cooperate first, never tries to build cooperation from a friendly stance, and defects in the last round, avoiding sunk costs. It exploits naive cooperators who appear willing to contribute regularly.

---

If you want, I can help you write this strategy as code for a specific programming language or format next.
'''

description_AGGRESSIVE_104 = '''
Here is a detailed design of an **aggressive strategy** for the described N-Player Public Goods Game:

---

## Strategic Goal

An "aggressive" strategy in this public goods context aims to maximize *own* payoff by exploiting cooperators and deterring cooperation from others, rather than promoting mutual cooperation. It tries to get the best payoff by defecting as much as possible, punishing cooperators where possible, and avoiding the cost of contributing.

---

## Intuition & Rationale

- **Defection earns immediate private payoff:** When you defect, you keep your endowment (1 instead of 0), plus a share of contributions of others.
- **Exploiting cooperators:** If some players cooperate, defectors earn higher payoffs.
- **Discourage cooperation:** If too many cooperate, the aggressive player defects and attempts to bring others back to defection to maximize own gain.
- **Use history to identify cooperators** and condition own action on their behavior.
- **First round**: No history to exploit so defect (most aggressive with no initial trust).
- **Last round**: Defect (no future punishment possible).
- **Intermediate rounds**: Defect, but detect if there are cooperators that can be exploited, avoid "rewarding" cooperation yourself.
- **Punish cooperators who try to enforce cooperation by cooperating yourself only if it increases your gain (rare in aggressive strategy).**

---

## Decision Rules Summary

| Round           | Action                                    | Reasoning                              |
|-----------------|-------------------------------------------|--------------------------------------|
| Round 1         | Defect                                    | Start aggressively, no info          |
| Intermediate rounds (2 to r-1) | Defect                                    | Exploit any cooperators; punish cooperation to avoid enabling them |
| Last round (r)  | Defect                                    | No reason to cooperate, no future payoff |
| Optional nuanced rule: | If *all* other players cooperated in previous round, consider cooperating this round to signal a willingness to exploit further if others keep cooperating, else defect | Rare, aggressive players typically do *not* cooperate |

---

## Pseudocode for the Aggressive Strategy

```python
# Input: 
# - round_number (1-based)
# - history: list of length (round_number - 1), each element is list of actions by all n players in that round
#          actions are 'C' or 'D'
# - player_index: index of this player (1-based)
# - n, r, k: game parameters

def aggressive_strategy(round_number, history, player_index, n, r, k):
    
    # 1. First round: always defect
    if round_number == 1:
        return 'D'

    # 2. Last round: always defect (no incentive to cooperate)
    if round_number == r:
        return 'D'

    # 3. Intermediate rounds (2 to r-1)
    # Relevant info: previous round actions of ALL players
    prev_round_actions = history[-1]

    # Count cooperators last round
    coop_count = sum(1 for a in prev_round_actions if a == 'C')

    # Check if all others cooperated last round (extreme cooperation)
    all_cooperated = (coop_count == n)

    # Aggressive logic:
    # - Always defect to exploit cooperators
    
    # Optional aggressive consideration:
    # If all others cooperated, defect still - better payoff exploiting their full cooperation
    # If want to appear less "all out defect", could cooperate here but that is less aggressive,
    # so we stick to defect always.

    return 'D'
```

---

## Explanation

- The strategy **never cooperates**, so costs are never paid.
- By defecting in every round, it exploits any cooperation by other players.
- It punishes cooperators by never supporting the public good.
- Does not attempt to build trust or mutual cooperation since it seeks maximum individual payoff.
- The predictable defection discourages other players from cooperation.
- As all players have the same info, the aggressive player's behavior strongly encourages others to defect as well, maximizing own payoffs as a free rider on any cooperation that might occur.

---

## Edge Case Handling

- **If r=2 (minimal multi-round)**: first round defect, last round defect → always defect.
- **If others always defect**: payoff = 1 every round, no loss from cooperating unilaterally.
- **If others cooperate sometimes**: get payoff > 1 each round by defects exploiting cooperators.
- **If all cooperate except you**: payoff highest possible, since private payoff 1 + (k/n)*n = 1 + k > 1 or k (k<n).
- **If everyone adopts similar aggressive strategy**: all defect; payoff 1 each round.

---

## Summary

| Feature          | Behavior         |
|------------------|------------------|
| First round      | Defect           |
| Intermediate     | Defect           |
| Last round       | Defect           |
| Response to others| Never cooperate (an aggressive free rider) |

---

This pure defection aggressive strategy guarantees the highest short-term payoff if some others cooperate, exploits them effectively, and avoids the costs of cooperation in all rounds.

---

If you want, I can help you design a more nuanced aggressive strategy with conditional cooperation to try to "trap" cooperators, but pure defection is the most straightforward aggressive approach in this setting.
'''

description_AGGRESSIVE_105 = '''
Here is an aggressive strategy designed for the N-player repeated public goods game as specified. It maximizes personal short-term and long-term payoff by aggressively exploiting cooperation from others while minimizing own contributions.

---

### Aggressive Strategy: "Exploitative Defector with Conditional Retaliation"

---

### Intuition
- Contribute **only** when it is strictly beneficial or strategically necessary.
- Exploit cooperators to gain the largest payoff.
- Never proactively cooperate first; only cooperate if forced by others' coordinated retaliation.
- Retaliate promptly and brutally if others try to exploit you.
- Defect persistently in the last round to avoid giving free benefits without future punishment.
- Use observed history to detect cooperation waves and selectively "punish" them by defecting.
- Avoid starting cooperation to avoid becoming a sucker.

---

### Decision Rules Summary

#### Definitions and Inputs at round t:
- `history[t-1]`: vector of all players’ actions in previous round.
- `num_cooperators[t-1]`: sum of cooperation in previous round.
- `own_action[t-1]`: your own action last round (C or D).
- `t`: current round index (1-based).
- `r`: total rounds.

---

### Step 1: At the first round (t = 1)
- **Action:** Defect (D)
- **Rationale:** No information on others, defecting avoids initial loss and tests others.

---

### Step 2: For rounds 2 ≤ t < r (middle rounds)

Calculate:
- `prev_C = num_cooperators[t-1]` — number of cooperators in previous round.
- `I_coop_last = (own_action[t-1] == C)`

Logic:
1. **If I cooperated last round and got exploited:**

   - Exploited means: others defected and I was a sole or minority cooperator, i.e.  
     `I_coop_last == True and prev_C` is small (e.g. 1 or just few), so I gave benefit but got low payoff.  
   - **Then:** Defect to punish.

2. **If others mostly cooperated last round (prev_C ≥ threshold):**

   - Threshold: More than half players cooperating (e.g., `prev_C > n/2`).
   - Cooperation can yield return because many others cooperated and benefits come back.
   - **Then:** Cooperate to share in public good payoffs.

3. **If cooperation was low or uncertain last round:**

   - They defected or few cooperated, no benefit in cooperating.
   - **Then:** Defect.

---

### Step 3: Last round (t = r)

- **Always defect.**
- Rationale: No future punishment possible, so avoid contributing and get maximum private benefit.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, k, history):
    # history: list of length t-1, each element is list of n actions ['C'/'D']

    if t == 1:
        # First round: defect to avoid free loss
        return 'D'

    prev_actions = history[t-2]  # indexing from 0, previous round actions
    prev_num_coop = prev_actions.count('C')
    own_last_action = prev_actions[own_index]  # assume known
    
    # Last round: always defect
    if t == r:
        return 'D'
    
    # Middle rounds logic
    if own_last_action == 'C':
        # Assess if exploited: low cooperation last round means exploited
        # Define exploited as prev_num_coop < (n / 3), i.e., minority coopers
        if prev_num_coop < (n / 3):
            return 'D'  # retaliate
    
    # If majority cooperated last round, join the cooperation
    if prev_num_coop > (n / 2):
        return 'C'
    else:
        # Otherwise defect
        return 'D'
```

---

### Explanation of the Aggressiveness

- Starts off defecting, never wastes endowment initially.
- Only cooperates when majority of others do, to "free ride" or minimize losses.
- Retaliates immediately after being exploited (cooperated but was minority).
- Cooperates only as much as forced by majority cooperation, no voluntary cooperation.
- Ceases cooperation completely in last round to maximize the last-round private payoff.
- Exploits the growth of cooperation to take advantage of shared benefits while conserving own endowment.
- Never forgives lightly; if punished, defects again, displaying aggression and discouraging exploitation by others.

---

### Edge Cases Addressed

- **First round:** Always defect, no info risk.
- **Last round:** Always defect, no incentive to cooperate with no future punishment.
- **Minor cooperation:** If you cooperated but were a minority, immediately defect in next round.
- **Majority cooperation:** Cooperate just enough to benefit from public good, but do not initiate.
- **Unstable or fluctuating cooperation:** Defect as default, cooperate only if large cooperation wave seen.

---

This strategy is aggressive because it refuses to sacrifice private benefit to initiate cooperation, exploits cooperators, retaliates harshly, and stops cooperating at the end. It leverages public knowledge of actions to make calculated decisions maximizing personal payoff while punishing free riders and minimizing sucker effects.
'''

description_AGGRESSIVE_106 = '''
### Aggressive Strategy for N-Player Public Goods Game

**Goal:**  
Maximize individual total payoff aggressively by exploiting cooperators while minimizing losses to defectors. This strategy aims to defect unless cooperation is highly advantageous and/or useful to detect patterns, but still exploits cooperation signals from others whenever possible.

---

## 1. Core Idea / Intuition

- **Defect by default**, because defecting never costs you more than cooperating and can yield higher immediate payoffs when facing cooperators.
- **Probe early cooperation only briefly** to test if others reciprocate cooperation (useful in repeated games).
- **If others mostly defect, exploit by defecting consistently** to avoid losses.
- **If a sufficient fraction of others coordinate cooperation early, exploit that by defecting while they cooperate (free-riding).**
- **On the last round, defect always** since no future retaliation is possible.
- **If any player has cooperated consistently in the past, exploit them by defecting to maximize immediate gains.**

---

## 2. Decision Rules Summary

| Round | Condition / Context                                    | Action          | Reason                                  |
|:------|:-----------------------------------------------------|:----------------|:---------------------------------------|
| 1     | Opening round; no history                             | Cooperate       | Probe for cooperation signals           |
| 2     | If a majority cooperated in round 1                  | Defect          | Exploit cooperators                      |
| 2     | Else (majority defected in round 1)                   | Defect          | Continue defecting                       |
| 3..r-1| If majority cooperated in previous round              | Defect          | Exploit cooperation (free-riding)       |
| 3..r-1| Else                                                  | Defect          | Hold firm defection policy               |
| r (last round) | Always                                        | Defect          | Aggressive endgame without retaliation  |

---

## 3. Pseudocode Description

```python
# Parameters:
# n: number of players
# r: total rounds
# t: current round (1-indexed)
# history: list of previous rounds' actions of all players (actions[t-1][i] for player i at round t-1)

def aggressive_strategy(t, history, n, r):
    # Count number of cooperators in previous round if t > 1
    if t == 1:
        # First round: Signal cooperation to test others
        return 'C'
    
    prev_round_actions = history[t-2]  # zero-indexed, t-2 is previous round
    coop_count = sum(1 for a in prev_round_actions if a == 'C')
    
    # Last round: always defect (no future consequence)
    if t == r:
        return 'D'
    
    # From round 2 to r-1:
    if coop_count > n/2:
        # Majority cooperated last round — Exploit by defecting
        return 'D'
    else:
        # Otherwise, defect to avoid being taken advantage of
        return 'D'
```

---

## 4. Explanation

- **Round 1:** Cooperate to test if the group responds with cooperation. This opens a window to detect if any players attempt mutual cooperation.  
- **Subsequent rounds:** If more than half cooperated last round, it signals an exploitable cooperative environment, so defect to gain the highest personal return by free-riding. If fewer than half cooperated, stick to defecting since cooperation isn’t profitable or safe.  
- **Last round:** Always defect since no future retaliation or reward is possible.  
- **No forgiveness or punishment cycles:** The strategy is uncompromising and exploitation-focused, fully aligning with an aggressive mindset. It never returns to cooperation after the first round and does not reward cooperators beyond round 1 probe.  
- **Minimal complexity:** This keeps the strategy robust against unknown opponent strategies and maximizes immediate self-payoff, a hallmark of aggressive strategy in public goods games.

---

## 5. Edge Cases and Notes

- If the game has only 2 rounds, it still probes cooperation round 1, then defects on round 2 (last round).  
- Using simple threshold > n/2 cooperators to define a "cooperative majority" is straightforward and effective; thresholds can be tuned but >50% is intuitive and stable.  
- Because all players see all actions, the strategy’s aggressive stance is obvious and consistent, potentially provoking retaliation but that is accepted as part of the aggression.  
- This strategy relies **only on observed behavior** and no assumptions about norms or communication beyond actions.  
- It maximizes payoff by exploiting cooperation but never invests in cooperation except for a short probing phase.

---

# Summary

| Round               | Action           | Rationale                                |
|---------------------|------------------|------------------------------------------|
| 1                   | Cooperate        | Test for cooperation signal              |
| 2 to r-1 (interim)  | Defect           | Exploit majority cooperation or defectors |
| r (last round)       | Defect           | Aggressive, no future cooperation reward |

This aggressive strategy maximizes self-interest by exploiting early cooperation signals and otherwise defecting consistently, especially at the last round where defection is dominant. It embodies a dominant, selfish approach without forgiveness or cooperation beyond an exploratory probe.
'''

description_AGGRESSIVE_107 = '''
Below is an **aggressive strategy** designed for the described N-player repeated public goods game. The strategy focuses on maximizing individual payoffs by exploiting cooperation from others while minimizing own cooperation, leveraging the public good multiplication factor—but aggressively punishing free riders when advantageous.

---

## Key Strategic Intuition:

- **Aggressive mindset** here means:  
  - **Minimize own cooperation to maximize private payoff**,  
  - **Exploit cooperating opponents by defecting while they cooperate**,  
  - **Punish persistent defectors with defection to deter them from exploiting myself**,  
  - **Use cooperation sparingly and strategically only to avoid triggering universal defection or to exploit payoff dynamics if profitable**.

---

## 1. Decision Rules

### Round 1 (No History)
- Defect.  
  *(Start aggressively by not contributing, testing others.)*

### Round t > 1

Define variables from previous round (t-1):

- C_opp = number of other players who cooperated in previous round = Σ_j≠i c_j,(t-1)
- D_opp = n - 1 - C_opp

Calculate expected payoffs from possible actions this round given last round's observed cooperation level:

- If I cooperate:  
  π_c = 0 + (k/n) * (C_opp + 1)  
- If I defect:  
  π_d = 1 + (k/n) * C_opp

Define **exploitation gain** = π_d - π_c = 1 - (k/n)

Because k < n (given), exploitation gain > 0 → defecting while others cooperate yields strictly higher immediate payoff.

---

### Decision Rule:

- **If in last round ≥ 1 other players cooperated (C_opp ≥ 1):**  
  *Defect this round (exploit their cooperation).*

- **Else if no one cooperated last round (C_opp = 0):**  
  *Defect this round.*  
  (No one is cooperating, no point contributing.)

- **Exception / last round (t = r):**  
  *Defect always.* (No future punishment.)

---

### Optional Edge Case—Occasional Cooperation to Stimulate Exploitation

If can detect that all are defecting indefinitely (C_opp = 0 for many rounds):

- Occasionally (e.g., every m rounds) cooperate once to test if others respond with cooperation, then defect next round to exploit.

- If no one responds by cooperating, revert to permanent defection.

---

## 2. Handling Edge Cases

- **First round:** Defect (no info).  
- **Last round (t = r):** Defect always (no future rounds to punish or exploit).  
- **Persistent universal defection:** Keep defecting; may occasionally "probe" cooperation but quickly revert.  
- **If multiple players cooperate and gain more than defectors:** Exploit by defecting to maximize own payoff; never cooperate unless forced by external pattern.  
- **If some players cooperate but mostly defect:** Exploit cooperators by defecting — payoff highest this way.

---

## 3. Justification of Aggressiveness

- **Never cooperate unless forced or probed strategically.**  
- **Never “forgive” defectors by cooperating, as pure defection when others cooperate yields strictly better payoff.**  
- **Punish any attempt by others to defect on you by not cooperating yourself; but since defection dominates, no cooperation given.**  
- **No coordination, communication, norms assumed; rely exclusively on observable history.**

---

## Pseudocode Summary

```
INPUT:
  n, r, k
  history: actions of all players in past rounds

FOR round t in 1 to r:

  IF t == 1:
    action_i = D

  ELSE IF t == r:
    action_i = D  # last round, defect

  ELSE:
    # Count number of cooperators excluding self in previous round
    C_opp = count_of_cooperators_in_round(t-1) excluding self
    
    IF C_opp >= 1:
      # Exploit cooperation by defecting
      action_i = D
    ELSE:
      # All defected last round, keep defecting
      # Optional: occasionally cooperate every m rounds to probe
      action_i = D

  PLAY action_i
```

---

## Summary

This aggressive strategy **always defects**, exploiting any cooperation from others without ever cooperating itself (except optionally probing in a normally pure-defect environment). The player maximizes personal payoff via free-riding and punishes loss by never cooperating, achieving an aggressive stance aligned with the game’s payoff structure.

---

If you want a slightly less harsh variant with probes and rare cooperation probes to test opponents, you can add:

```
IF C_opp == 0 and (t mod m == 0):
  action_i = C  # probe cooperation
ELSE:
  action_i = D
```

But pure defection is the core aggressive behavior.

---

Let me know if you want a formalized version or integration hints!
'''

description_AGGRESSIVE_108 = '''
Here is a detailed aggressive strategy designed for the N-player repeated Public Goods Game under the constraints and definitions provided.

---

## Aggressive Strategy: "Dominant Defector with Opportunistic Exploitation"

### Intuition Behind the Strategy

- **Aggressive stance:** Always prioritize individual gain over group welfare.
- **Defect by default:** Because defecting guarantees keeping the private endowment (1 unit) plus potentially a share of others’ contributions.
- **Exploit cooperators:** When others start cooperating, defect to maximize personal payoff (free riding).
- **Minimal cooperation only when it benefits you:** Cooperate only if it directly increases your payoff beyond defecting.
- **Punish cooperation signals:** Do not reciprocate cooperation; instead, exploit it to maximize payoff.
- **Endgame defection:** Defect in the last round as there is no future punishment or retaliation.

---

### Decision Rules

**Input:**  
- History of actions of all players from rounds 1 to t-1  
- Current round index t (1 ≤ t ≤ r)  
- Parameters n, k, r

**For round t, player i decides action a_i,t ∈ {C, D} as follows:**

1. **First round (t = 1): Defect**  
   - There is no history, so cooperate would be exploited. Start aggressively by defecting.

2. **Intermediate rounds (1 < t < r): Conditional Defection**  
   - Observe number of cooperators in previous round:  
     c_total(t-1) = count of players who chose C at round t-1  
   - **If c_total(t-1) = 0:**  
     - Everyone defected last round; defect again (no incentive to cooperate).  
   - **If c_total(t-1) > 0:**  
     - Acting cooperators offered potential public good payoff.  
     - Defect to exploit their cooperation and gain the highest immediate payoff: no contribution cost + share of public good.  
     - Cooperate only if this would yield a strictly higher payoff than defecting, which only can happen if:  
       π_i if C > π_i if D  
     Given:  
       π_i if C = 0 + (k/n) * c_total(t)  
       π_i if D = 1 + (k/n) * c_total(t)  
     Since 1 + (k/n) * c_total(t) > (k/n) * c_total(t), defect always yields more payoff.  
     Therefore, **always defect regardless of others’ cooperation.**

3. **Last round (t = r): Defect**  
   - No future rounds to worry about retaliation; defect to maximize final round payoff.

---

### Pseudocode

```
function decide_action(t, history, n, k, r):
    # history[t'] = [a_1,t', a_2,t', ..., a_n,t'] for previous rounds t' < t
    
    if t == 1:
        return 'D'  # Defect in first round
    
    else if t == r:
        return 'D'  # Defect in last round
    
    else:
        prev_actions = history[t-1]
        c_total = count_C(prev_actions)  # number of cooperators in previous round
        
        # Because defecting always yields higher immediate payoff than cooperating
        # regardless of others' cooperation, defect always
        
        return 'D'
```

---

### Edge Cases

- **First round:** Defect, no history, aggressive safety.
- **All others defect consistently:** No incentive to cooperate, defect forever.
- **Some others cooperate intermittently:** Defect to exploit public goods from them.
- **If by rare chance everyone cooperates every round:** This strategy still defects to get private endowment plus public good share, maximizing payoff relative to cooperators.
- **Last round:** Defect to maximize terminal payoff without fear of retaliation.

---

### Summary

- **Always defect in every round.**
- This strategy is *aggressive* because it never “trusts” or rewards cooperation, always seeks maximum personal gain by exploiting cooperation.
- It leverages the fact that defection dominates cooperation for personal payoff in a single-shot setting and refuses to cooperate in repeated rounds because there is no coordination nor enforcement.
- It punishes any attempt at cooperation by free-riding.

---

This simple but effective aggressive approach is expected to outperform more cooperative or conditional cooperation strategies in a tournament context where no norms or credible commitments can be enforced.
'''

description_AGGRESSIVE_109 = '''
**Goal:** Devise an *aggressive* strategy for the repeated multiplayer public goods game described.

---

## Context and Insights for an Aggressive Strategy

- Defection (D) yields an immediate private gain of 1 unit plus an equal share of public good.
- Cooperation (C) costs 1 unit of private payoff, compensated only via public good share.
- Multiplication factor **k < n**, so full cooperation benefits all more than full defection, but defectors benefit more individually than cooperators (the classic social dilemma).
- Based on payoff examples:
  - Defecting while others cooperate yields the highest individual payoff for that round.
  - Cooperators get penalized by defectors: if mixed, defectors earn more.
- The strategy should be **aggressive**:
  - Seek to maximize individual payoff by exploiting cooperators.
  - Avoid being exploited (agreeing to cooperate and getting defected on).
  - Possibly punish or deter cooperation from others by defecting relentlessly.
- Repeat rounds allow history-based decision rules.
- No communication or coordination — decisions only based on observed history.

---

## Aggressive Strategy: "Exploit-First, Defect-Always"

### Intuition

- Always defect to maximize short-term gains: defectors earn 1 + (k/n) * total cooperators.
- Cooperators pay a cost but can be exploited.
- Trying to cooperate or "conditional cooperation" risks exploitation.
- No incentive to start cooperating; cooperation harms self if others defect.
- No incentive to change behavior in last round (no deferred punishment or reward).
- Since no coordination is possible, aggressively defect every round.
- This should maximize payoff against any mixture of opponents.

---

### Decision Rules

1. **First Round (t=1): Defect.**  
   - Start aggressively by defecting. Yield immediate maximal private payoff.
2. **Subsequent Rounds (t=2 to r): Always Defect.**  
   - Continue defecting regardless of opponent history.
   - No forgiveness, no cooperation attempts—signal an unbeatable defecting stance.
3. **Last Round (t=r): Defect.**  
   - Defect right to the end; no strategic cooperation since no future rounds.
4. **Ignore history entirely.**  
   - No attempt to punish or reward others; pure self-maximizing behavior by defecting.

---

### Edge Cases

- **If all others Cooperate:**  
  - You defect and get: 1 + (k/n)*n = 1 + k > 1  
  - This is maximal per-round payoff.
- **If mix of cooperators and defectors:**  
  - You defect, earning 1 + (k/n)*total_cooperators, always topping payoffs of cooperators.
- **If all defect:**  
  - All earn 1; no one cooperates, but defecting doesn’t hurt your payoff.
- **If opponents punish defectors by defecting:**  
  - You keep defecting anyway; no loss relative to cooperating.
- Strategy is aggressive and risk-seeking.

---

## Pseudocode

```python
def aggressive_strategy(round_number, history, n, r, k):
    """
    Parameters:
    - round_number: int, current round (1-based)
    - history: list of tuples [(a1, a2, ..., a_n)] for past rounds, each a_i in {C, D}
    - n, r, k: game parameters

    Returns:
    - action: 'C' or 'D'
    """

    # Aggressive: always defect
    return 'D'
```

---

## Summary

| Round           | Action            | Reason                                  |
|-----------------|-------------------|-----------------------------------------|
| First round (t=1)      | Defect          | Maximize initial payoff, signal aggression |
| Intermediate rounds (1 < t < r) | Defect          | Maintain dominant payoff, exploit cooperators |
| Last round (t=r)       | Defect          | No future incentive to cooperate          |

**This is a simple, deterministic, fully aggressive strategy: Always defect irrespective of history.**

---

# Final notes:

- This strategy is “aggressive” in the standard public goods terms: it never cooperates.
- It maximizes exploitation of cooperators and avoids being exploited.
- It is robust to opponents’ strategies without relying on trust or norms.
- While simple, in tournament conditions it likely gives a strong individual payoff against a range of strategy types.

If you want a more complex aggressive strategy (e.g. defect but try cooperation if all others cooperate), that can be crafted, but the simplest fully aggressive approach is an always-defect strategy as above.
'''

description_AGGRESSIVE_110 = '''
Here is an **aggressive strategy** for the N-player Public Goods Game as specified, designed to maximize own payoff by exploiting cooperators while discouraging cooperation from others:

---

## Strategic Rationale

- Cooperating costs you 1 unit upfront per round, while defecting saves that.
- The multiplication factor \( k \) satisfies \( 1 < k < n \), so total cooperation is socially better but individually tempting to defect.
- Defectors earn higher immediate payoff against cooperators.
- The game is repeated across \( r \) rounds with perfect information.
- Aggressive strategy means **maximizing own payoff at the expense of others**, not cooperating unless it benefits our long-term payoff, and punishing cooperators by refusing to cooperate ourselves.
- Since defection yields a strictly higher individual payoff than cooperation when \( k < n \), we want to exploit cooperators every round.
- However, if all defect, payoff is minimal (but still 1 per round) — better than cooperating blindly.
- We want to signal “I defect no matter what,” encouraging others to defect and avoid reciprocal cooperation trying to exploit us.
- In final round, no incentive to cooperate, so defect to get maximum immediate payoff.

---

## Decision Rules

1. **Round 1: Defect.**
   - No history to exploit.
   - Start aggressively; do not give free cooperation.

2. **Rounds 2 to \( r-1 \): Defect always, regardless of history.**
   - Defecting maximizes own payoff, especially if others cooperate.
   - Cooperators get exploited (payoff less than yours).
   - No cooperation to avoid being exploited and to deter others from attempting cooperation.

3. **Round \( r \) (last round): Defect.**
   - No future rounds, so no incentive to cooperate or attempt conditional strategies.
   - Maximize immediate payoff.

---

## Handling Edge Cases

- **If all players defect:** You match them; payoff = 1 per round.
- **If some players cooperate:** You exploit them; payoff > 1 per round.
- **If some players try to punish you:** You still defect, as punishment gains nothing for you.
- **No conditional cooperation or forgiveness:** Being aggressive means never lowering your guard.

---

## Pseudocode

```python
def aggressive_strategy(round_number, history):
    """
    round_number: current round (1 to r)
    history: list of lists of actions taken in previous rounds by all players,
             e.g., history[t][i] = 'C' or 'D' for round t and player i
    """
    # Always defect in first round and all subsequent rounds
    return 'D'
```

---

## Summary

| Round           | Action  | Motivation                            |
|-----------------|---------|------------------------------------|
| 1               | Defect  | Start aggressing, exploit potential cooperators |
| 2 to r-1        | Defect  | Continue to maximize payoff exploiting cooperators; deter cooperation attempts |
| r (last round)  | Defect  | No future consequences, maximize immediate payoff |

This simple yet ruthless approach aligns with the aggressive mindset: **always defect, never cooperate**, maximizing personal gain by harvesting the benefits of others’ cooperation without giving anything in return. It exploits the game parameters \( 1 < k < n \) to consistently earn higher payoffs against cooperators and avoid losses to defectors.

---

Let me know if you want modifications or multi-phase aggression schemes—but this is the purest aggressive approach under your rules.
'''

description_AGGRESSIVE_111 = '''
**Strategy Name:** Aggressive Defector with Opportunistic Tit-for-Tat Exploitation (AD-OTF)

---

### Conceptual Overview

This strategy embraces an **aggressive mindset** that prioritizes maximizing personal payoffs by exploiting cooperators while minimizing losses to defectors. It boldly defects to leverage the private payoff advantage and the public good funded by any cooperators. However, it opportunistically cooperates only to lure others into cooperating (thus increasing the gains it can free-ride on). It retaliates strongly against sustained cooperation by others to avoid exploitation and exploits naive cooperative players while punishing too-aggressive defectors minimally.

---

### Rationale for Aggression

- **Defect by default:** Defection yields a guaranteed private payoff of 1, plus any benefit from others' cooperation.
- **Exploit cooperators:** If others cooperate, the aggressive player reaps a multiplied shared payoff without paying the cost.
- **Discourage free-riding defectors:** The player detects if others defect too often and punishes them by defecting too (which is the default behavior).
- **Minimize cooperation:** Only cooperate strategically to stimulate cooperation in early rounds or when trailing in payoff.
- **No forgiveness:** Aggressive retaliation ensures opponents cannot exploit the player by cycling cooperation and defection.

---

### Detailed Decision Rules Per Round

---

#### Notation:

- `t`: current round index (1 ≤ t ≤ r)
- `history`: table of all players' past actions up to round t-1
- `own_payoff`: cumulative payoff of this player up to round t-1
- `average_payoff_opponents`: average cumulative payoff of opponents up to round t-1
- `coop_count_last_round`: number of cooperators in round t-1
- `self_last_action`: action played by this player in round t-1 (C or D)
- Parameters: `n`, `r`, `k` known to all players

---

### 1. **First Round (t = 1):**

- **Action:** Defect (D)

**Reasoning:**  
Starts aggressively to avoid being exploited by early cooperators. No history, so no basis for cooperation.

---

### 2. **Intermediate Rounds (1 < t < r):**

- Calculate:

  - `coop_count_last_round` = number of players who cooperated at round t-1

- Rules:

  1. **If Last Round Majority Defected:**  
     If `coop_count_last_round ≤ n/2`  
     → Defect (D)

     *Rationale:* Most players defect → no incentive to cooperate; defecting exploits cooperators without wasting contribution.

  2. **If Last Round Majority Cooperated:**

     - If this player cooperated last round:  
       → Defect (D) to exploit cooperators

     - If this player defected last round:

       - *Check if you are behind in payoff compared to average opponents:*  
         If `own_payoff < average_payoff_opponents` AND `coop_count_last_round > n/2`  
         → Cooperate (C) to lure cooperation and potentially improve payoff share

       - Else  
         → Defect (D)

**Summary:**  
- Always defect unless the majority are cooperating and you are behind in payoff, then cooperate to try to catch up.

---

### 3. **Last Round (t = r):**

- **Action:** Defect (D)

**Reasoning:**  
No future retaliation possible, so defect to maximize last round payoff.

---

### Overall:

- Default to **defection**.
- Exploit cooperative environments by defecting.
- Occasionally cooperate to stimulate cooperation only if falling behind.
- Never cooperate first round or last round.
- Use others' cooperation as a trigger to selectively cooperate to improve relative payoff.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, k, history, own_payoff, all_payoffs):
    # history: list of dicts per round {player_index: action}
    # own_payoff: float cumulative payoff
    # all_payoffs: list of floats for all players' cumulative payoffs

    # First round
    if t == 1:
        return 'D'

    # Last round
    if t == r:
        return 'D'

    # Analyze last round
    last_round_actions = history[t-2]  # zero-based index
    coop_count_last_round = sum(1 for a in last_round_actions.values() if a == 'C')
    majority_cooperated = coop_count_last_round > n / 2
    self_last_action = last_round_actions[self_player_index]

    # Calculate average opponent payoff
    opponents_indices = [i for i in range(n) if i != self_player_index]
    average_payoff_opponents = sum(all_payoffs[i] for i in opponents_indices) / (n - 1)

    if not majority_cooperated:
        # Majority defected last round → defect
        return 'D'
    else:
        # Majority cooperated last round
        if self_last_action == 'C':
            # Exploit cooperators by defecting now
            return 'D'
        else:
            # If behind in payoff and many cooperators, cooperate to try to increase share
            if own_payoff < average_payoff_opponents:
                return 'C'
            else:
                return 'D'
```

---

### Edge Case Handling

- **If tied payoff with opponents:** Treat as `own_payoff >= average_payoff_opponents` → defect.
- **If equal number of cooperators and defectors in last round:** Treat as "majority defected" to avoid risky cooperation.
- **If all others cooperate (coop_count = n - 1):** Aggressively defect to maximize payoffs.
- **If all others defect:** Defect to avoid contributing with zero return.

---

### Summary of Key Behavior

| Round             | Condition                      | Action | Reason                                               |
|-------------------|-------------------------------|--------|-----------------------------------------------------|
| First Round       | -                             | D      | Start aggressively                                  |
| Last Round        | -                             | D      | Defect to grab maximum payoff without retaliation  |
| Intermediate Rounds | Majority defected last round  | D      | Defect to exploit defectors                        |
|                   | Majority cooperated + self last action = C | D      | Exploit cooperative players                        |
|                   | Majority cooperated + self last action = D  | If payoff behind → C else D | Opportunistically lure cooperation if losing   |

---

This aggressive, opportunistic strategy aims to maximize personal payoff by:

- Avoiding naive cooperation that can be exploited
- Leveraging others’ cooperation for free-riding payoff
- Selectively cooperating only to improve competitive advantage when behind
- Defecting consistently as a robust baseline to prevent exploitation

It is **unforgiving, strategically exploitative, and tactically opportunistic**, embodying a truly aggressive approach appropriate for a tournament of independent, rational players with full history information.
'''

description_AGGRESSIVE_112 = '''
Here is an **aggressive strategy** tailored for the described N-Player Public Goods Game, emphasizing exploitation and dominance rather than cooperation or reciprocity.

---

## Strategy Objectives

- **Maximize immediate payoffs by defecting whenever profitable.**
- **Punish cooperators (if any) only to the extent it prevents exploitation, but avoid cooperation unless forced by strategy logic (which we won't).**
- **Exploit cooperative players to gain larger payoffs by defecting while others cooperate.**
- **Use game history strictly to identify if anyone is trying to cooperate; if nobody cooperates, keep defecting to maintain maximal individual profit.**

---

## Intuition Behind the Aggressive Strategy

- Since payoff for defecting is *always* at least as good as cooperating in a one-shot sense, the aggressive choice is to defect.
- Cooperating early means losing private payoff with no guarantee others will reciprocate.
- Trying to "punish" defectors by cooperating is against our aggressive mindset.
- Instead, always defect regardless of others’ behavior.
- On the last round, no future punishment or reward is possible, so defect then as well.
- Since players can observe history, some might cooperate to promote joint-benefit. We exploit that by defecting to get higher payoffs.
- The aggressive strategy never concedes cooperation and never sacrifices payoff to promote cooperation.

---

## Formal Description

### Notations:
- \( t \in \{1,...,r\} \) round number
- \( H_t \) = history of all players’ actions up to round \( t-1 \)
- \( c_j^{(t)} \) = action of player \( j \) in round \( t \); 1 for C, 0 for D

### Decision Rule

For **each round \( t \), player i plays:**

```
Action_i(t) = D   # Always defect
```

---

### Edge Cases

- **First round (t=1):** No history available; defect.
- **Intermediate rounds (1 < t < r):** History available; still defect.
- **Last round (t=r):** No future rounds, so no incentive to cooperate; defect.

---

### Pseudocode

```python
for t in range(1, r+1):
    # Observe previous rounds history H_t (but do not condition on it)
    # Aggressive: Always defect
    action_i = 'D'
```

---

## Explanation on Payoff Rationale

- If everyone defects, payoff = 1 (private payoff), no public good.
- If others cooperate, your defection payoff increases more than cooperating.
- Cooperating costs 1 (lose private endowment) but sharing public good; defectors get a free ride.
- Aggressive maximizes payoff without trusting cooperation.
- No need to punish or reward others — no cooperation, no drama.
- This strategy is **dominant** if opponents do not punish defectors by defecting in the future, but since the game is repeated without communication, trusting cooperation is risky.

---

## Summary

| Round  | Condition                   | Action  |
|--------|-----------------------------|---------|
| 1      | No history                  | Defect  |
| 2..r-1 | History exists, but ignore  | Defect  |
| r      | Last round, no future       | Defect  |

---

# Final Answer: The Aggressive Strategy

> **Always Defect** in every round, regardless of observed history or opponents’ past actions.

This aligns perfectly with the aggressive mindset of maximizing individual payoff regardless of social welfare or retaliation concerns.
'''

description_AGGRESSIVE_113 = '''
Below is a description of an **aggressive strategy** for the repeated N-player public goods game, aligned with maximizing personal payoff through exploitation and punishment of cooperators, while accounting for the game's structure and limitations.

---

## Strategy Name: **Dominant Defector with Targeted Punishment**

---

### 1. **High-Level Intuition**

- Always aim to defect (D) to maximize private payoff.
- Exploit cooperators' contributions by defecting.
- Punish repeat cooperators by defecting aggressively.
- **Never cooperate first**; do not give players a free ride.
- If you detect other defectors consistently defecting, maintain defection.
- Handle last round by defecting (no incentive to cooperate).
- Use opponent behavior to identify naive cooperators for exploitation and punish inconsistent or retaliatory behavior aggressively.

---

### 2. **Decision Rules**

- **Round 1 (No history):** Defect unconditionally.
- **Subsequent Rounds (t > 1):**  
  For each player j ≠ i, observe their past behavior:
  - Count how many times player j cooperated in previous rounds.
- Use the following decision rules at round t:
    1. **Own action in round t: Always defect (D).**  
       Reason: Defection maximizes immediate private payoff. Cooperators incur a cost and reward defectors.
    2. **Punishment is implicit by persistent defection.**  
       No cooperation to enable or reward cooperators.
- **No conditional cooperation:** Since no coordination or signaling, cooperation brings risk of exploitation.
- **Last round (round r):** Defect to secure maximum payoff (no future punishments).

---

### 3. **Why This Is Aggressive**

- You never cooperate, denying others the chance to free-ride on you.
- You exploit cooperators by defecting while they bear the cost.
- You never "forgive" or switch to cooperation—constant defection enforces a hostile environment.
- No risk of being exploited yourself since you never contribute.
- This discourages cooperation by providing no incentive to do so.
- Punishment is automated by you always defecting, denying cooperators any benefit from mutual cooperation.

---

### 4. **Edge Cases**

- **First Round:** Defect, no history, maximize payoff from start.
- **Last Round:** Defect to avoid pointless cooperation or cost.
- **Opponents Mostly Defecting:** Continue defecting; equilibrium is all defectors or near-defectors.
- **Opponents Mostly Cooperating:** Exploit them by constant defection.
- **Mixed Behavior Opponents:** No cooperation to avoid exploitation risks. Defect always.

---

### 5. **Pseudocode**

```python
def aggressive_strategy(history, round_number, total_rounds):
    # history is list of length round_number-1
    # Each element history[t] is list of length n with actions 'C' or 'D' played by all players in round t
    # index of self is i
    
    # Parameters given: n, r = total_rounds
    
    # Always defect
    return 'D'
```

---

### 6. **Summary**

| Round        | Action      | Reasoning                        |
|--------------|-------------|--------------------------------|
| 1 (No history)| Defect (D) | Maximize private payoff early   |
| 2 to r-1     | Defect (D) | Exploit cooperators, no cooperation to avoid loss, punish others |
| r (last round)| Defect (D) | No future incentives, secure payoff |

---

### 7. **Notes on Strategy Effectiveness**

- This pure defection strategy is **aggressive and exploitative**.
- It may yield inferior payoffs if many others also defect, but dominates against cooperators.
- Because cooperation can't be coordinated or signaled beyond actions, this strategy drives the group towards defection equilibrium.
- The aggressive mindset avoids altruism or cooperation that could lead to being exploited.

---

If you want a variant that tries to exploit occasional cooperators further by defecting when others cooperate, this can be added, but pure defection is the straightforward aggressive approach that fits the specification best.
'''

description_AGGRESSIVE_114 = '''
Here is an **aggressive strategy** tailored for the repeated N-player Public Goods Game as specified. Its philosophy is to maximize individual payoff by exploiting cooperation of others wherever possible, but aggressively punishing defectors to reduce their payoffs and avoid being exploited, while also maintaining leverage throughout the rounds.

---

## Aggressive Strategy: "Exploiter with Grim Trigger Variant"

### Intuition
- **Start defecting:** Immediately defect to gain the baseline payoff plus any benefit from others cooperating initially.
- **Observe others:** Exploit cooperative players by continually defecting as long as some cooperate.
- **Punish defectors aggressively:** If any defection detected, punish them by defecting indefinitely to deny their benefits from others.
- **Last round: defect unconditionally:** Use backward induction logic since no future reprisals can occur.

This aggressive strategy seeks to maximize individual payoff by:
- Never cooperating oneself (to keep initial private endowment = 1),
- Benefiting from others' cooperation when possible,
- Ensuring defectors are punished, dissuading cooperative deviations that would otherwise reduce personal payoffs,
- Avoiding endless cooperation that benefits others more.

---

### Decision Rules

Let:

- `t` = current round (1 ≤ t ≤ r)
- `history[t-1]` = record of all players' actions in previous rounds
- `defected_in_history` = boolean, True if any player defected at any prior round
- `cooperators_in_last_round` = number of players who cooperated in round `t-1` (if t > 1)

#### Pseudocode

```python
def aggressive_strategy(t, history, player_index):
    if t == 1:
        # Round 1: Defect unconditionally to maximize initial private payoff
        return 'D'
    
    # Check if any defection observed in past rounds
    defected_in_history = any(
        'D' in history[round_num] for round_num in range(t - 1)
    )
    
    if t == r:
        # Last round: defect unconditionally (no future punishment possible)
        return 'D'
    
    if not defected_in_history:
        # No one has defected yet (all cooperated so far?)
        #
        # Aggressive stance: DO NOT cooperate 
        # (do not "start" cooperating to sacrifice payoff to benefit others)
        #
        # Continue defecting to exploit the cooperators.
        return 'D'
    else:
        # Defection observed previously: trigger punishment by defecting always
        return 'D'
```

---

### Explanation

- **Round 1 (first move):** Defect outright. This maximizes the immediate payoff and exploits any naive cooperators.
- **No defections observed yet:**
  - Continue defecting to exploit cooperative players.
  - Never cooperate first — cooperation sacrifices your private payoff and benefits others.
- **Defection observed in any prior round:**
  - Trigger a "grim trigger" style punishment: defect forever after.
  - This deters others from persistent defection and discourages cooperation that could hurt your relative payoff.
- **Last round:**
  - Defect since future retaliation is impossible, capturing the immediate payoffs.

---

### Edge Cases Handling

- **First round, no history:** Defect to immediately exploit.
- **Last round:** Defect unconditionally (backward induction rationality).
- **If opponents cooperate fully at first:** Exploit by defecting continuously.
- **If any player defects even once:** Grim trigger punishment makes you defect always, taking advantage of no future cooperation and maintaining high payoff.
- **Tie or mixed cooperation levels:** Since the strategy never cooperates, it yields good payoffs whenever ≥ 1 players cooperate, and prevents exploitation by defectors.

---

### Aggressiveness Justification

- By **never cooperating yourself**, you inflict maximum payoff damage on cooperators, capturing the private endowment plus a share of others’ contributions.
- By punishing defectors **immediately and indefinitely** after observing defection, you prevent cyclical cooperation and exploitation.
- Always defecting in the last round ensures capturing every possible payoff at game end.
- This strategy is exploitative rather than cooperative, orders itself strictly above norms involving mutual cooperation or forgiveness.

---

# Summary

| Condition                          | Your Action |
|----------------------------------|-------------|
| Round 1                          | Defect      |
| No defections seen (t > 1)       | Defect      |
| Defection observed in history    | Defect      |
| Last round (t = r)               | Defect      |

---

This aggressive no-coop, grim-trigger style strategy maximizes personal payoff by exploiting cooperative behavior from others, punishing defectors harshly, and always defecting at the last round. It requires no trust and assumes rational opponents aware of the payoff structure.

---

If you want a concise summary:

> **"Always defect. Start defecting immediately; never cooperate. If any defection happens, defect forever to punish. On the last round, defect unconditionally. Exploit cooperators; punish defectors; maximize private payoffs aggressively."**

---

Let me know if you want a variant with some limited cooperation or more nuanced retaliation!
'''

description_AGGRESSIVE_115 = '''
Here is a detailed, aggressive strategy design for the repeated N-player Public Goods game, fully aligned with the game specification and standard assumptions:

---

### Strategy Name: **"Dominant Defector"**

### Intuition
- The strategy is **aggressive**: it prioritizes maximizing individual payoff even at the expense of the group.
- It aims to **exploit cooperators** and **avoid being exploited**.
- It defects unless it sees clear exploitable cooperation from others, and punishes cooperation by defecting to maximize gains.
- It uses history to aggressively target rounds where others cooperate, but never cooperates first or in the last round (to avoid exploitation).

---

### Summary of Decision Rules

| Round       | Action                      | Reasoning                                     |
|-------------|-----------------------------|-----------------------------------------------|
| 1           | Defect                      | Never initiate cooperation; no trust yet      |
| 2 to r-1    | Defect unless exploitable cooperators are detected in previous rounds | Exploit cooperators; prevent grudges by never cooperating |
| Last round  | Defect                      | No incentive to cooperate without future rounds |
    
---

### Detailed Strategy Description

**Variables to track:**

- For each round t, you observe the full action profile \( A_t = (a_1^t, ..., a_n^t) \), where \( a_i^t \in \{C,D\} \).
- Compute \( C_t = \text{count of cooperators at round } t = \sum_j c_j^t \).
- Track your own action history.

---

### Step-by-step decision logic per round \( t \):

1. **Round 1 (\( t = 1 \)):**

    - Action: **Defect (D)**
    - Reason: No history; no incentive to cooperate and get exploited.

2. **Rounds 2 to \( r-1 \):**

    Use previous rounds' data to decide whether cooperation is exploitable.

    - **Detect exploitable cooperation:**

      If in any previous round \( t' < t \), there were cooperators besides me (i.e., \( C_{t'} \geq 1 \)) and I defected that round, I successfully exploited cooperators.

      Since defectors receive a higher payoff than cooperators (when cooperators exist), the presence of cooperators means defecting is better.

    - **Decision rule:**

      - **If any players cooperated last round (i.e., \( C_{t-1} \geq 1 \)):**

        **Defect (D)** to exploit their cooperation.

      - **Else** (all defected last round):

        **Defect (D)** to maintain dominance and avoid costly cooperation.

3. **Round \( r \) (last round):**

    - Action: **Defect (D)**
    - Reason: No future rounds to punish or reward cooperation; no incentive to cooperate.

---

### Pseudocode

```python
def dominant_defector_strategy(round_num, r, n, k, history):
    """
    round_num: int, current round index (1-based)
    r: int, total rounds
    n: int, players count
    k: float, multiplication factor
    history: list of dicts, each dict:
        {
          'actions': list of 'C'/'D' for all players in that round,
          'round': round number
        }
    Your player index is known internally (say idx = 0, for example)
    """

    if round_num == 1:
        return 'D'  # Never initiate cooperation

    if round_num == r:
        return 'D'  # Defect on last round

    # From round 2 to r-1
    last_round_actions = history[-1]['actions']

    total_cooperators = sum(1 for a in last_round_actions if a == 'C')

    if total_cooperators >= 1:
        # Others cooperated last round, exploit by defecting
        return 'D'

    # All defected last round, continue defecting aggressively
    return 'D'
```

---

### Why this is aggressive?

- **Always defects**: No cooperation means never sharing your endowment.
- **Exploits cooperators**: Whenever any player cooperates, you gain strictly more by defecting.
- **Never forgives or cooperates**: Refuses to reciprocate, punishing cooperation by defecting.
- **No attempt to build cooperation**: No risk of being a sucker.
- **Maximizes immediate and long-term payoff** against naive cooperators.
- **No wasted efforts on last round**: Avoids unreciprocated cooperation at the end.

---

### Edge Cases

- **If all players defect forever**, payoff per round = 1 (baseline, safe).
- **If some cooperate**, the strategy exploits them yielding payoff > 1.
- **If others try to build cooperation**, this strategy undermines it.
- Because you never cooperate, you lose out on group payoff but gain individually.
- Opponents will learn you never cooperate, no point trying to induce cooperation from you.

---

### Summary

- The **Dominant Defector** is a fully aggressive, always defecting strategy that opportunistically exploits cooperators.
- It uses history only to detect exploitable cooperation and never cooperates itself.
- Perfectly rational under these constraints when aiming for maximized individual gain, especially when \( k < n \) implies cooperation is individually costly.

---

If you want the strategy described more succinctly or framed differently, just ask!
'''

description_AGGRESSIVE_116 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Core Idea:
This strategy seeks to maximize individual payoffs aggressively by exploiting cooperative players while punishing defectors only when profitable. It aims to defect early, lure cooperators into cooperating (thus boosting your payoff further), and maintain defection to maximize free-riding on contributions—only cooperating very reluctantly if it yields strictly higher payoffs.

---

### Decision Rules:

#### Notation:
- `t`: current round (1 ≤ t ≤ r)
- `n`: number of players
- `k`: multiplication factor (1 < k < n)
- `H_t-1`: history of all players’ actions up to round t-1
- `C_t-1`: number of cooperators in last round
- `my_action_t`: your action in round t
- `last_round_cooperators`: number of players who cooperated in round t-1

---

### Rationale:

- **Defect by default**: Because defecting always yields at least 1 plus the share of others’ contributions and keeps the private endowment.
- **Exploit cooperators**: When others cooperate, defect to get a higher payoff (keep 1 plus share of contributions).
- **Punish defectors only if it benefits you**: In a multiplayer setting, punishing by cooperating alone rarely improves payoff; better to keep defecting.
- **Last round defection**: Defect always in last round (no incentive for cooperation, no future retaliation).
- **Occasional cooperation only if cooperating yields payoff > defecting payoff**

---

### Pseudocode Description:

```plaintext
For round t in 1 to r:

    If t == 1:
        # First round: start aggressive with Defection
        my_action_t = D

    Else if t == r:
        # Last round: always defect (no future rounds to build cooperation)
        my_action_t = D

    Else:
        # For rounds 2 through r-1:

        # Count how many cooperators in previous round
        last_round_cooperators = count_cooperators(H_t-1)

        # Calculate expected payoffs if cooperating vs defecting this round

        payoff_cooperate = 0 
                         + (k/n) * (last_round_cooperators + 1)
                         # Cooperating adds self to contribution count

        payoff_defect = 1 
                       + (k/n) * last_round_cooperators
                       # Defect keeps private endowment plus share of others' contributions

        If payoff_cooperate > payoff_defect:
            # Cooperate only if cooperating yields strictly higher payoff this round
            my_action_t = C
        Else:
            # Aggressively defect otherwise
            my_action_t = D

Return my_action_t
```

---

### Explanation of Decision Logic:

- **Round 1:** Defect. No history to infer cooperation; maximize immediate payoff and signal aggressiveness.
- **Rounds 2 to r-1:** Calculate if cooperating is actually beneficial compared to defecting, based on number of previous cooperators (using public info).
  - Only cooperate if it yields strictly higher payoff *this round* (meaning your cooperation meaningfully increases the public good enough to offset losing your private endowment). This is a rare condition since k < n, but possible if many others cooperate.
  - Otherwise, defect to free-ride.
- **Round r:** Defect always, no incentive to build cooperation with no future rounds.

---

### Edge Cases Handling:

- **If no one cooperated last round:** cooperating gives \( (k/n)*1 \), defecting gives 1; defect dominates -> defect.
- **If all cooperated last round:** cooperating payoff = \((k/n)*n = k\) (max possible), defecting payoff = 1 + \((k/n)*(n-1) = 1 + k*(n-1)/n\). Since \(1 + k*(n-1)/n > k\) because \(k < n\), defecting still yields higher payoff. So defect.
- **If some cooperated last round (e.g., m):**
  - Cooperate payoff \(= (k/n)(m+1)\)
  - Defect payoff \(= 1 + (k/n) m\)
  - Cooperate only if: \((k/n)(m+1) > 1 + (k/n) m\) → \( (k/n) > 1 \)
  - Given \(k < n\), \(k/n < 1\), so cooperate payoff never exceeds defect payoff.
  
**Implication:** Since \(k/n < 1\), defecting always yields strictly higher payoff this round. Therefore:

- **The strategy defaults to defect every round, except possibly cooperate if you want to signal or mix—but since the specification demands aggressive behavior, ALWAYS defect.**

---

### Final Simplified Aggressive Strategy:

```plaintext
For round t in 1 to r:
    my_action_t = D
```

---

### Summary:

**Aggressive Strategy: Always Defect**

- Start defecting from round 1.
- Defect regardless of other players’ past actions.
- No cooperation at any point, because individual payoff from defecting is always higher or equal.
- This is the strictly payoff-maximizing aggressive strategy exploiting cooperative opponents.

---

# Additional Notes

- This strategy is “pure defection” but fully justified by the payoff structure.
- Defection prevents being exploited and exploits cooperators fully.
- Attempts to cooperate are not rational under \(1 < k < n\) parameter, as public good share per player is less than 1.
- An "aggressive strategy" here corresponds exactly to "always defect."

---

# Optional Variation — Occasional Signal Cooperation (Riskier Aggression)

If you want to be more nuanced (not strictly required), you could:

- Defect until you observe a majority cooperate consistently.
- Once a threshold number of cooperators is observed (e.g., > 75% cooperate), cooperate once to maximize payoff share by boosting public good, then resume defect to free-ride.

But this is less aggressive and more conditional; the strict aggressive choice is to always defect.
'''

description_AGGRESSIVE_117 = '''
**Aggressive Strategy for the N-Player Public Goods Game**

---

### Conceptual Overview:
The goal of this aggressive strategy is to maximize *my own* total payoff across the repeated public goods game by exploiting cooperative opponents while minimizing cooperation myself. This means primarily defecting (D), but strategically cooperating (C) in early rounds to induce cooperation from others when it benefits me, and then quickly punishing or exploiting them.

---

### Intuition Behind Aggressiveness:
- **Primary objective:** Maximize individual total payoff, even if it means others get lower payoffs.
- Aggressive players try to **exploit cooperators** by defecting while others cooperate.
- Because the **k < n**, the public good multiplier is insufficient to compensate fully for the cost of cooperation for individuals.
- Aggressiveness means:
  - Never willingly initiate cooperation with no clear short-term gain.
  - Punish cooperation by defecting to gain higher payoffs than cooperators.
  - Possibly mimic cooperation at the right times if it can bait cooperative behavior from others.

---

### Strategy Description:

#### Key Definitions
- Round t ∈ {1, 2, …, r}
- History at round t: Actions (C or D) of all players in rounds 1 to t-1
- Number of cooperators in round t: Total_C_t
- My previous actions: my_action_t
- Opponents’ behavior summary: We track how many cooperators were in last round, and how many cooperated persistently.

---

### Decision Rules

1. **First round (t=1): Defect**
   - No basis to trust or invest.
   - Start by defecting to avoid being exploited.

2. **Subsequent rounds (t > 1):**

   Let `Total_C_{t-1}` be number of cooperators in previous round.
   Let `My_action_{t-1}` be my previous action.

   - If in previous round others mostly defected (i.e. `Total_C_{t-1} ≤ 1`):
     - Continue defecting. No incentive to cooperate if almost no one cooperates.
   
   - If in previous round significant cooperation observed (`Total_C_{t-1} > 1`):
     - **Defect to exploit:** Since others contributed, defect and get payoff `1 + (k/n)*Total_C_{t-1}` which > cooperating payoff.
     - Exception: If this is the last round (`t == r`), defect regardless (no future retaliation possible).
   
   - **Persistent cooperators** (if some players have cooperated consistently for many rounds):
     - Ignore; aggressive players do not reciprocate cooperation.

3. **Last round (t == r): Defect**
   - Classical backward induction: no incentive to cooperate last round; others will likely defect too.
   - Defect to maximize immediate payoff.

---

### Summary Table of Actions

| Situation in round t | My action     |
|--------------------- |--------------|
| t = 1 (first round)  | Defect       |
| Last round (t = r)   | Defect       |
| Previous round had >1 cooperators | Defect to exploit |
| Previous round had ≤1 cooperators | Defect to avoid sucker payoff |

---

### Pseudocode

```python
def aggressive_strategy(t, r, history, n, k):
    # history: list of tuples/lists of actions per round for all players
    # history[t-1] = ['C', 'D', 'C', ..., 'D'] actions of all players in previous round
    
    if t == 1:
        return 'D'  # defect first round
    
    if t == r:
        return 'D'  # defect last round
    
    last_round_actions = history[t-2]  # zero-indexed
    total_cooperators = sum(1 for a in last_round_actions if a == 'C')
    
    # Aggressive: defect always, but if others cooperated, defect to exploit
    # If no one cooperated in last round or only one, still defect
    # No reward in cooperating since others mostly defect
    
    return 'D'
```

---

### Justification:
- **By always defecting**, you never pay the cost of cooperation.
- When others cooperate, you earn `1 + (k/n) × num_cooperators` which can be higher than cooperators' payoff, exploiting them.
- Because the game is repeated, some strategies might try to induce mutual cooperation, but you refuse cooperation, making your opponents lose out.
- In last round, no reason to cooperate because retaliation is impossible.
- Your aggressive stance may provoke others to defect as well, but your payoff is maximized by not contributing your endowment.

---

### Extensions / Edge Cases:

- **If the game only ever sees defectors:** you earn 1 per round, stable but unexploited.
- **If others unexpectedly cooperate after you defect:** you exploit them every round after first.
- **You never "forgive" or "punish"**: aggressive means zero cooperation tolerance and no reward for cooperation.

---

**In essence, this aggressive strategy is “Always Defect,” with a nuanced understanding that defecting against cooperators maximizes personal gains in a public goods setting with the given parameters.**
'''

description_AGGRESSIVE_118 = '''
Below is a description of a clear, aggressive strategy for the N-Player Public Goods Game as specified.

---

## Strategy Name: "Defect-or-Exploit"

### 1. Core mindset:  
Maximize own total payoff by defecting whenever possible. Only cooperate if it profits *me* more than defecting, i.e., if enough players are cooperating so my payoff from cooperating is at least as good as defecting (otherwise defect). Punish defection briefly to exploit cooperators but aggressively revert to defection to avoid exploitation.

---

### 2. Decision rules

**Notation:**

- t = current round (1 ≤ t ≤ r)
- h_{t-1} = history of all players' actions up to previous round
- c_j^t = contribution of player j in round t (1 if cooperate, 0 if defect)
- C_{t-1} = number of cooperators in round t-1

---

#### At round 1 (t = 1):

- Defect.  
No history, so no reason to trust others. Defect to protect payoff.

---

#### For round t, 2 ≤ t < r (middle rounds):

- Compute the total number of cooperators in the previous round, C_{t-1}.
- Predict payoff if I cooperate this round:  
  \[
  \pi_i^{C} = 0 + \frac{k}{n}(C_{t-1} + 1)
  \]
  (I add myself as cooperator so total cooperators +1)
- Predict payoff if I defect:  
  \[
  \pi_i^{D} = 1 + \frac{k}{n}C_{t-1}
  \]

- If \(\pi_i^{C} \geq \pi_i^{D}\), **Cooperate** this round.  
  (This means cooperating yields at least as high a payoff as defecting, i.e., cooperating pays off.)

- Else **Defect**.

*Rationale:* Only cooperate if cooperators are numerous enough so I gain more by cooperating than defecting; otherwise free-ride by defecting.

---

#### At round t = r (last round):

- Defect.  
No future payoff to enforce cooperation or punish defection, so maximize current round payoff by defecting.

---

### 3. Handling edge cases

- If at any round C_{t-1} = 0 (no cooperators last round):  
  I will defect, as cooperating offers no benefit.

- If cooperation already high (C_{t-1} close to n), I cooperate to get larger public good share.

- If some players unexpectedly cooperate while I defect, I exploit that by continuing to defect if more profitable.

---

### 4. Summary pseudocode

```python
def aggressive_strategy(t, r, n, k, history):
    # t: current round (1-based)
    # history: list of previous rounds, each round is list of n actions (C or D)
    
    if t == 1:
        return 'D'  # Round 1: always defect
    
    if t == r:
        return 'D'  # Last round: always defect
    
    # Count cooperators in previous round
    prev_round = history[-1]
    C_prev = sum(1 for action in prev_round if action == 'C')
    
    # Calculate payoffs if cooperate or defect
    payoff_if_cooperate = (k / n) * (C_prev + 1)
    payoff_if_defect = 1 + (k / n) * C_prev
    
    if payoff_if_cooperate >= payoff_if_defect:
        return 'C'
    else:
        return 'D'
```

---

### 5. Explanation of why this is aggressive

- Always defects initially and in last round—no risk-taking or trust investments.
- Cooperates *only* when it yields an immediate individual payoff gain (or break-even).
- Never sacrifices own payoff to boost group payoff alone.
- Exploits cooperators by defecting if that yields better returns.
- No forgiveness or generous behavior; harsh when exploitation pays off.
- Uses knowledge of previous round contributions to exploit or mildly reward cooperation but prioritizes self-interest.

---

This strategy aligns with the aggressive mindset: it prioritizes selfish gain, aggressively exploits cooperators, never punishes when ineffective, and minimally cooperates only when personally profitable. It adapts to observed cooperation levels without assuming norms or goodwill.

---

If you want, I can also provide a more detailed walkthrough or variants, but this baseline should compete well in tournaments of independent strategies.
'''

description_AGGRESSIVE_119 = '''
Here is an **Aggressive Strategy** tailored to the N-Player Public Goods Game described. The strategy aims to maximize own payoffs aggressively, exploiting cooperative players while punishing defectors only minimally and opportunistically.

---

## Strategic Rationale

- **Aggressive mindset:** Exploit cooperators rather than establish cooperation. Maximize immediate gain and destabilize opponents by defecting often.
- **Avoid costly cooperation:** Cooperating means losing the private payoff of 1, so only cooperate if it strategically yields higher payoff (very rare in this setting).
- **Exploit early and often:** Defect from the start to capture gains from any "naive" cooperators.
- **Occasional cooperation to confuse or disrupt:** Occasionally cooperate on prior-round defect-heavy environments to lure opponents into cooperating, then defect again.
- **Last round defection:** Since no future rounds exist, defect to gain private payoff.

---

## Detailed Decision Rules

Let:

- \( t \) = current round index, \( 1 \le t \le r \)  
- \( C_{t-1} \) = number of cooperators in previous round (0 if \( t=1 \))  
- \( n \) = number of players  
- \( k \) = multiplication factor, \(1 < k < n\)

**In each round \( t \), for player i:**

1. **First round \( (t=1) \):**  
   - Defect (D). No prior info, start aggressively by defecting to exploit any cooperation.

2. **Rounds \( 1 < t < r \):**  
   - If previous round had **no cooperators or very few** (e.g., \( C_{t-1} \leq 1 \)):  
     - Defect (D). The public good was minimal, so do not waste private payoff.
   - If previous round had **moderate cooperation**, (e.g., \( 2 \leq C_{t-1} < n \)):  
     - With low probability \( p_{coop} \) (e.g., 0.1 to 0.2), cooperate (C). This is a *lure* to create temptation for opponents to cooperate, hoping to exploit them later.
     - With probability \( 1 - p_{coop} \), defect (D).
   - If previous round was **all cooperators** (i.e., \( C_{t-1} = n \)):  
     - Defect (D) to maximize gain. Exploit full cooperation of others.

3. **Last round \( (t = r) \):**  
   - Defect (D) unconditionally. No future retaliation so best to maximize immediate payoff.

---

## Summary of Intuition:

- Always defect initially.  
- Mostly defect afterward, but occasionally cooperate to bait others.  
- Exploit any full cooperation by defecting immediately after.  
- Defect last round without fail.

---

## Pseudocode

```python
def aggressive_strategy(t, history, n, r, k):
    # history: list of tuples of player actions in previous rounds
    # Each element: ['C' or 'D' for each player], indexed by round
    
    if t == 1:
        return 'D'  # First round defect
    
    # Count number of cooperators in previous round
    prev_actions = history[t-2]  # zero-based index
    C_prev = sum(1 for a in prev_actions if a == 'C')
    
    if t == r:
        return 'D'  # Last round defect unconditionally
    
    if C_prev == 0 or C_prev == 1:
        return 'D'  # No point cooperating if others mostly defect
    
    if C_prev == n:
        return 'D'  # Full cooperation last round: exploit by defecting
    
    # Moderate cooperation: bait occasionally
    p_coop = 0.15  # 15% cooperation probability to lure
    if random() < p_coop:
        return 'C'
    else:
        return 'D'
```

---

## Notes & Comments

- This strategy is **exploitative and opportunistic** rather than aiming to foster stable cooperation.
- Occasional cooperation is purely tactical, intended to motivate/coax others into cooperating, which can then be exploited.
- Parameters like \( p_{coop} \) can be tuned depending on tournament composition.
- The aggressive nature means it foregoes long-term cooperation benefits for short-term advantage.
- It maintains simplicity and clarity with well-defined steps for first, intermediate, and last rounds.

---

If you want, I can help you tailor this strategy further or provide variations!
'''

description_AGGRESSIVE_120 = '''
Here is an aggressive strategy designed for the given N-player repeated Public Goods game, balancing exploitation and deterrence, optimizing individual payoff aggressively while exploiting cooperation from others.

---

## Strategy Name: Exploit-and-Punish Aggressor

---

### Overview

- **Mindset:** Maximize own payoff aggressively by defecting whenever profitable and retaliating swiftly against cooperators to prevent exploitation.
- **Key idea:**  
  - Default to **defect** to maximize immediate private payoff.
  - Detect cooperators in past rounds to exploit their cooperation by continuing to defect.
  - If cooperation is widespread enough that defection yields low payoff, selectively cooperate only in the last round(s) to reap some benefit.
  - Retaliate (defect) against any cooperation attempts from others immediately to discourage sustained cooperation.
- **Goal:** Extract maximal benefit from others' cooperation without giving up your own endowment except possibly at the very end.

---

### Decision Rules

Let:  
- \( t \) = current round (1-based)  
- \( r \) = total rounds  
- \( n \) = number of players  
- \( k \) = multiplication factor (1 < k < n)  
- \( H_{t-1} \) = observed actions of all players in all rounds 1 to \( t-1 \) (empty for \( t=1 \))  
- \( C_{t-1} \) = set of players who cooperated in the previous round \( t-1 \)  
- \( M_{t-1} = \sum_{j=1}^n c_j^{t-1} \) = number of cooperators in previous round  
- Assume selfishness: only care about maximizing own payoff per round and cumulatively.

---

### Step-by-step Rules

**Round 1 (t = 1):**

- No history.  
- Play **Defect (D)** to secure the guaranteed private payoff of 1 and see if others cooperate.

---

**Rounds 2 to r-2 (if \( r \geq 4 \)), otherwise rounds 2 to r-1:**

- Observe \( M_{t-1} \), the number of cooperators last round.

- Calculate expected payoffs assuming you cooperate vs defect this round:

  - If you cooperate:  
  \[
  \pi_i^C = 0 + \frac{k}{n} \times (M_{t-1} + 1) \quad \text{(if you cooperate, add yourself to coop count)}
  \]

  - If you defect:  
  \[
  \pi_i^D = 1 + \frac{k}{n} \times M_{t-1}
  \]

- Decide:

  - **If defection yields higher payoff:** Play **Defect (D)**  
    \[
    \pi_i^D > \pi_i^C \implies \text{Defect}
    \]

  - **If cooperation yields higher payoff or a tie:** Play **Defect (D)** anyway (aggressive stance: never voluntarily cooperate early).

- **Exception (Retaliation):**  
  Detect any player(s) who cooperated in previous round (cooperators). Never try to cooperate with them; keep defecting to exploit them. No forgiveness.

---

**Rounds r-1 and r (last two rounds if \( r \geq 3 \), else round r only):**

- Aggressively defect in round r-1 to maximize private payoff.

- In round \( r \) (last round):

  - Calculate payoffs as above.

  - If the total cooperation in round \( r-1 \) was high enough that cooperation this round could increase payoff significantly (i.e.,  
    \[
    \pi_i^C = \frac{k}{n} \times (M_{r-1} + 1) \geq \pi_i^D = 1 + \frac{k}{n} \times M_{r-1}
    \]
    ), then **cooperate** to try to maximize final payoff (you won't be punished further after the last round).

  - Else defect.

---

### Pseudocode

```python
def exploit_and_punish_strategy(t, r, n, k, history):
    # history: list of previous rounds' action lists (each list length n), with actions 'C' or 'D'
    
    if t == 1:
        # First round: defect
        return 'D'
    
    last_round_actions = history[-1]  # list of 'C'/'D' for round t-1
    M = last_round_actions.count('C')  # number of cooperators last round
    
    # Check if any cooperators last round (to identify "targets" to exploit)
    cooperators_exist = (M > 0)
    
    # Compute payoffs if cooperate or defect this round
    payoff_cooperate = (k / n) * (M + 1)
    payoff_defect = 1 + (k / n) * M
    
    # Last round(s) logic
    if t == r:
        # Last round: cooperate only if it yields payoff at least as good as defecting
        if payoff_cooperate >= payoff_defect:
            return 'C'
        else:
            return 'D'
    
    if r > 2 and t == r-1:
        # One before last round: defect aggressively
        return 'D'
    
    # Middle rounds
    # Aggressive stance: never cooperate early, always defect
    # Exploit any cooperators in previous round by continuing to defect
    return 'D'
```

---

### Comments on Strategy Behavior

- **Always defect early:** Protect private payoff and never "waste" endowment when opponents can't be punished or exploited.
- **Exploit cooperators:** If any cooperators exist last round, keep defecting to extract share of their cooperation.
- **No cooperation forgiveness:** Never reward cooperators by cooperating yourself (no "tit-for-tat").
- **Last round cooperation:** Only cooperate at the last round if it improves payoff, as no future retaliation risks exist.
- **No conditional cooperation:** No attempts to establish mutual cooperation or punish harshly—purely aggressive extraction.
  
---

### Strengths

- Maximizes individual payoff against naive cooperators.
- Avoids sucker's payoff (never cooperates early).
- Takes advantage of others cooperating repeatedly.
- Simple to implement and robust to unknown opponent strategies.

### Weaknesses

- May trigger universal defection equilibrium if all players adopt similar aggressive behavior.
- Misses potential benefits of establishing cooperation.

---

This fully aggressive "Exploit-and-Punish Aggressor" successfully embodies an aggressive mindset within the formal constraints and information given.
'''

description_AGGRESSIVE_121 = '''
**Aggressive Strategy for the N-Player Public Goods Game**

---

### Rationale:  
An *aggressive* strategy in a public goods game context means prioritizing **maximizing individual payoff by exploiting cooperation from others, never "wasting" contributions, and punishing cooperators without hesitation**. The goal is to defect as much as possible to gain the highest share of the multiplied public good funded by others, only cooperating when absolutely beneficial.

---

### Key Considerations:

- Defecting yields immediate private payoff (1 point) plus a share of the public good if others cooperate.
- Cooperating costs you the private point (you give it up) but increases total public good pot.
- If everyone defects, payoff = 1 (lowest).
- If all cooperate, payoff = k (>1), but since k < n, defecting while others cooperate yields a strict advantage.
- The last round: No incentive to cooperate because no future retaliation possible.
- Early rounds: The best "exploitative" strategy is to assume others may cooperate and attempt to gain from them by defecting.
- If others stop cooperating, defect forever.

---

### Decision Rules:

Let round index be t, t ∈ {1,...,r}.

Let history of actions of all players until round t-1 be known.

Let C_t−1 = total number of cooperators in round t−1.

---

### Strategy Outline:

**Round 1:**  
- Defect. No prior info; test waters by defecting for maximum immediate gain.

**Rounds 2 to r-1:**  
- If in round t−1, at least one other player cooperated (C_{t−1} > 0), then defect to exploit.
- Else (no one cooperated last round), defect to avoid wasting contribution (everyone likely defecting).

**Round r (the last round):**  
- Defect unconditionally because no future rounds to influence.

---

### Explanation of behavior:

- Always defect to aggressively free-ride on others' cooperation.
- Do not cooperate because cooperation benefits everyone else but costs you.
- Punish cooperation with defection rather than reciprocating to maximize payoff.
- The assumption: others might cooperate early on so you exploit them.
- When cooperation disappears, give up and defect forever.
- No forgiveness or generosity as this reduces payoff.
- No wasted cooperation in last round, where cooperation is naive.

---

### Pseudocode:

```python
def aggressive_strategy(t, r, history):
    """
    Inputs:
        t: current round number (1-based)
        r: total rounds
        history: list of tuples [(a_1^1,...,a_n^1), ..., (a_1^{t-1},...,a_n^{t-1})]
                 actions of all players in previous rounds, 'C' or 'D'.
                 history is empty if t == 1

    Output:
        action: 'C' or 'D' for current round
    """

    n = len(history[0]) if history else n  # Assume n known from environment

    # Round 1: defect
    if t == 1:
        return 'D'

    # Last round: defect
    if t == r:
        return 'D'

    # Examine cooperation last round
    last_round_actions = history[-1]  # actions of all players at t-1
    # Count how many cooperated last round, excluding self if desired
    # Here self is not known, so consider total cooperators including self
    total_cooperators = last_round_actions.count('C')

    # If at least one player cooperated last round => defect (exploit)
    if total_cooperators > 0:
        return 'D'
    else:
        # No one cooperated last round, continue defecting
        return 'D'
```

---

### Summary:

| Round         | Condition                             | Action   | Reason                    |
|---------------|------------------------------------|----------|---------------------------|
| 1             | No history                         | Defect   | Test with free-riding     |
| 2 ≤ t ≤ r-1   | If any cooperated last round       | Defect   | Exploit cooperating others|
|               | Else                              | Defect   | No cooperation, defect    |
| r (last round)| Always                            | Defect   | No future punishment, no cooperative incentive |

---

This aggressive defection-only strategy exploits any cooperation from others, punishes cooperators without delay, never cooperates itself, and maximizes individual payoff in the absence of coordinated norms or enforcement. It is selfish, unforgiving, and optimal if the goal is aggressive maximization of payoff against unknown opponents.
'''

description_AGGRESSIVE_122 = '''
**Aggressive Strategy for N-Player Public Goods Game**

---

### Strategy Overview

This strategy aims to **maximize your own payoff aggressively** by exploiting cooperation from others while minimizing your own cooperation. It leverages information about prior rounds to detect cooperation levels and responds harshly to any attempt to get you to cooperate, all while trying to maximize your gains by defecting strategically. It balances exploitation and prevention of exploitation, without any punitive cooperation.

---

### Intuition and Motivation

- **Why defect?** Defecting ensures you keep your private endowment (1 point).
- **Why sometimes cooperate?** If everyone defects, payoffs stagnate at 1 each, but if many cooperate, you gain from the multiplied public good.
- **Aggressive mindset:** Never "waste" your endowment by cooperating first. Only cooperate if you can expect to exploit others repeatedly. Punish any cooperation attempts by others.
- **Use history:** Detect whether cooperating others exist, then exploit them.

---

### Decision Rules (Per Round)

---

#### **Round 1 (No history):**

- **Defect.**  
  You have no information. Cooperating risks giving up your endowment without guarantee others will cooperate. Defecting is safe and aggressive.

---

#### **Round t (2 ≤ t ≤ r):**

Let:

- \( H_{t-1} \) = history of all players’ actions in rounds 1 to t-1
- \( C_{t-1} \) = total number of cooperators by any player in round t - 1
- \( c_i^{t-1} \) = action player \(i\) took in round \(t -1\) (1 if C, 0 if D)

Define:

- **Others_cooperate_prev_round:**  
  Number of other players who cooperated last round = \( C_{t-1} - c_i^{t-1} \)

Decision Rule:

- **If others_cooperate_prev_round ≥ 1:**  
  Defect this round to exploit cooperators.
  
- **If others_cooperate_prev_round = 0:**  
  Defect this round as well, since no cooperation to exploit.

---

#### **Last Round (Round r):**

Treat as normal according to above rule (defect), because no future rounds to maintain cooperation or punish defectors.

---

### Summary in words:

- Always defect.
- Use history to confirm others cooperate, then defect to exploit.
- Never cooperate—no naive cooperation or forgiveness.
- No strategy adjustment or softening over time.
- Aggressively capitalize on others’ cooperation without reciprocating.

---

### Pseudocode

```python
for round t in [1,...,r]:

    if t == 1:
        # Initial move: all defect
        action_i = D

    else:
        # Count how many others cooperated in previous round
        total_cooperators_prev = sum(c_j^{t-1} for all players j)
        others_cooperated_prev = total_cooperators_prev - c_i^{t-1}

        if others_cooperated_prev >= 1:
            # Exploit cooperators: defect
            action_i = D

        else:
            # No one cooperated last round, keep defecting
            action_i = D
```

---

### Edge Cases

- **If all players always defect:** You continue defecting, earn the stable payoff of 1 each round.
- **If some cooperate:** You always defect to exploit their contribution, earning higher payoffs.
- **Multiple rounds:** Since cooperation earns you more only if others cooperate, you exploit any rare cooperation aggressively.
- **No forgiveness or trust:** The aggressive strategy never cooperates or attempts to build trust for long-term benefits; it prioritizes maximal individual payoff immediate & overall.

---

### Expected Outcome

- If many cooperate, you get a higher payoff by defecting.
- If none cooperate, you get the default payoff from defecting.
- Opponents who try to cooperate may be exploited and receive lower payoffs.
- You never invest your endowment voluntarily, defending against naive cooperation attempts.

---

**This aggressive strategy clearly prioritizes self-gain, exploiting cooperation when it exists, refusing cooperation yourself, and punishing cooperative moves by others through consistent defection.**
'''

description_AGGRESSIVE_123 = '''
Below is a detailed design of an **aggressive strategy** for the described repeated N-player Public Goods Game.

---

## Strategy Name: **Aggressor**

**Goal:** Maximize own payoff by exploiting cooperative players, minimizing own contributions, and punishing defectors swiftly to discourage reciprocity or cooperation that would reduce personal gains.

---

## Intuition and Rationale

- **Aggressiveness means:**  
  - Default to defection unless compelling evidence that cooperating is profitable in expectation.  
  - Exploit cooperators as long as it is profitable.  
  - Quickly punish cooperators who start cooperating so as to disincentivize them from continuing cooperation.  
  - Near the last round, defect to avoid being exploited (backward induction).  
  - Use history of others’ contributions to decide whether cooperating yields better payoffs or not.

- **Why aggressive?**  
  - Cooperating yields less private payoff per round than defecting unless enough others cooperate.  
  - When others cooperate, defecting players get a strictly higher payoff.  
  - No trust or negotiation, so best to exploit cooperators and defect otherwise.

---

## Core Principles

1. **Default to Defection (D).**  
2. **Cooperate (C) only when it is clearly profitable (usually early rounds when cooperation by others is high).**  
3. **Detect cooperating peers and exploit them by defecting against them.**  
4. **Punish cooperation by others if no exploitation opportunity exists.**  
5. **Always defect in final round.**

---

## Decision Rules Detail

Parameters:

- Observe in round t:  
  - n = total players  
  - r = total rounds  
  - k = multiplication factor  
  - History of actions up to round t-1: For each previous round, we know who cooperated and who defected.

Definitions:

- c_count(t-1) = number of cooperators (excluding ourselves, if desired) in round t-1  
- c_fraction(t-1) = c_count(t-1) / (n - 1) = fraction of others cooperating last round  
- payoff_diff(t-1) = payoff if I had defected vs if I had cooperated last round (estimated)  

---

## Pseudocode

```
for each round t in 1 to r:
    if t == r:
        # Last round, defect to avoid exploitation
        action = D
        continue

    if t == 1:
        # First round: no history, assume no trust
        # Small chance cooperate to probe if cooperation exists,
        # otherwise defect to avoid exploitation
        action = D
        continue

    # From round 2 onwards:
    # Calculate fraction of cooperators among others in previous round
    c_fraction = (number of cooperators other than me in round t-1) / (n - 1)

    # If large fraction cooperated last round, try to exploit by defecting
    # Because defecting against cooperators gives a higher payoff
    
    if c_fraction >= threshold_high_coop:
        # High cooperation environment => defect to exploit
        action = D
    else:
        # Low cooperation environment => cooperation is pointless,
        # Defect to avoid contribution cost
        action = D

```

---

## Thresholds

- Set threshold_high_coop depending on k and n:

**Analysis:**

- Defector's payoff given m cooperators (including self):  
  π_D = 1 + (k / n) * (m)  
- Cooperator's payoff given m cooperators (including self):  
  π_C = 0 + (k / n) * (m)  

Defector earns 1 more than cooperator in same environment.

- To get more than 1, a defector needs at least 1 cooperator in the group (m ≥ 1).  
- High payoffs are possible only if enough players cooperate.

Hence:

- Set threshold_high_coop as roughly > 0.5 (majority cooperate) to justify defecting for exploitation.  
- No cooperation otherwise because the probability of mutual cooperation payoffs exceeding 1 is low.

---

## Complete Aggressive Strategy Description

1. **Round 1 (no history):**  
   - Defect (D) to avoid being exploited by naive cooperators.  
   - Avoid any risk.

2. **Rounds 2 to r-1:**  
   - Compute fraction of other players who cooperated last round.  
   - If ≥ 50% cooperation last round among others, Defect (D) to exploit - free ride on others’ contributions.  
   - Otherwise, Defect (D) because cooperating yields less without enough cooperators.

3. **Round r (last round):**  
   - Defect (D) always - classic backward induction, no incentive to cooperate.

---

## Edge Cases

- **If all others defect every round:**  
  - You defect every round, payoff = 1 every round. Consistent and aggressive.

- **If some others cooperate:**  
  - You defect to exploit, gaining more than cooperators.

- **If many cooperate:**  
  - You continue defecting to maximize exploitation.

- **If others retaliate by defecting:**  
  - You continue defecting regardless.

---

## Summary / Final Notes

- This strategy aggressively defects except it probes by defecting in round 1 (safe).  
- It never cooperates unless a more complex mechanism is implemented — this is aggressive and exploits cooperation by others.  
- No forgiveness or cooperation — aggressive and exploitative.  
- Expected to do well in tournament against cooperative or mixed strategies by free riding.

---

## Optional Enhancements (if desired)

- If you want some probing cooperation, you could add:

```
if t == 1 and some small probability p (<0.1):
    action = C
else:
    action = D
```

but this slightly softens aggressiveness.

---

# Summary Table of Strategy Actions

| Round   | Condition                                    | Action  |
|---------|----------------------------------------------|---------|
| 1       | No history                                   | Defect  |
| 2..r-1  | If ≥ 50% others cooperated last round       | Defect  (exploit) |
| 2..r-1  | Else                                        | Defect  |
| r       | Last round - always defect                   | Defect  |

---

This completes the specification of the aggressive strategy.
'''

description_AGGRESSIVE_124 = '''
**Aggressive Strategy for N-Player Repeated Public Goods Game**

---

### Strategic Intuition - Aggressiveness Defined

In this game, defecting (D) yields a private payoff of 1 plus a share of the public good from others’ contributions, while cooperating (C) costs you 1 unit (the endowment you contribute) but helps increase the size of the public good, potentially benefiting everyone.

An **aggressive strategy** here is one that **maximizes own payoff at the expense of cooperators**, refusing to be taken advantage of by others' cooperation, punishing cooperation, and exploiting more cooperative players where possible. It will not attempt to foster cooperation or reciprocate it; instead, it aims to be a consistent defector but also to quickly punish naive cooperators.

---

### Key Observations

- **Defecting unconditionally (Always-D)** is simple and aggressive, but may miss opportunities to exploit cooperators optimally.
- Cooperators pay 1 cost to contribute; defectors gain an advantage when others cooperate.
- If everyone defects, no one gains from the public good; payoff = 1 each.
- If some cooperate and one defects, defector gets strictly more than cooperators.
- To be aggressive, we should try to **maximize own payoff by defecting ALL rounds**, while punishing anyone who tries cooperation by refusing to cooperate at any point.

---

### Strategy Outline

---

#### 1. First Round:

- **Defect**, because cooperating risks giving away 1 unit with no guarantee others will cooperate.
- No history to infer cooperation from others; safest to free-ride.

---

#### 2. Subsequent Rounds (2 ≤ t ≤ r-1):

- For rounds 2 through r-1:
  - **If any player cooperated in the previous round, or in any previous round, defect.**
    - Why? Because cooperators can be exploited; do **not** reward cooperation.
  - Otherwise (everyone defected last round and all previous), **continue defecting**.

- In other words:
  - **Never cooperate yourself.**
  - If anyone ever cooperated, continue defecting and exploit cooperators if any emerge.

---

#### 3. Last Round (Round r):

- Defect always, since no future punishment or leverage.

---

### Summary (in prose)

- **Always defect.**
- **Never cooperate.**
- Exploit any cooperation by others but never reciprocate or initiate cooperation.
- Do not allow oneself to be "taken advantage of" by cooperating.
- Punish by withholding cooperation even if others cooperate hoping for reciprocity.
- Use free-riding in all rounds to maximize own payoff.
- No strategic cooperation or forgiveness.

---

### Pseudocode for clarity:

```python
# Inputs: history - list of previous rounds' action profiles (list of lists)
# Each round: list of length n with 'C' or 'D' actions for players 1..n

def aggressive_strategy(i, n, r, t, history):
    # i: player index (1-based)
    # n: number of players
    # r: total rounds
    # t: current round (1-based)
    # history: list of lists, each sublist is tuple of length n with other players' moves
    
    # 1. First round: defect
    if t == 1:
        return 'D'
    
    # 2. Any past cooperation by any player?
    for past_round in history:
        if 'C' in past_round:
            # Someone cooperated before or last round
            return 'D'  # defect aggressively
    
    # 3. Last round: defect
    if t == r:
        return 'D'
    
    # 4. If no cooperation ever seen, defect anyway to maximize payoff
    return 'D'
```

---

### Why This Strategy Is Aggressive:

- It refuses to cooperate ever; cooperators are exploited.
- It punishes cooperators by never cooperating back, lowering their payoff.
- Because cooperation costs 1 and defectors benefit from cooperators, this strategy maximizes individual payoff when opponents cooperate.
- It is simple, consistent, and clearly hostile to any attempt to build cooperation.
- It takes advantage of public information and history to identify cooperators but never forgives or reciprocates, ensuring an aggressive stance.

---

### Edge cases handled:

- First round: no info → defect.
- Last round: no punishment possibility → defect.
- Repeated cooperation seen at any time: continue defecting.
- Cooperative opponents punished by continued defection and free-riding.

---

This aggressive strategy is a classic **Always Defect** (ALLD) but justified with full awareness of the repeated structure, punishment potential, and payoff structure in the public goods game. It fully exploits the advantage defectors have over cooperators and makes no attempts to foster mutual cooperation.
'''

description_AGGRESSIVE_125 = '''
Below is a detailed description and pseudocode of an **Aggressive Defector Strategy** for the N-Player Public Goods Game that meets your criteria.

---

## Strategy Overview: Aggressive Defector

**Purpose:**  
Maximize personal payoff by aggressively exploiting cooperators and avoiding losses by minimizing cooperation. The strategy defects in almost all situations to secure the guaranteed private payoff, only briefly probing for cooperation to identify exploitable cooperators.

---

## 1. Decision Rules

- **Round 1 (First Round):**  
  - Defect (D) to gain a guaranteed private payoff of 1 and to observe initial cooperation levels from others without exposing yourself.

- **Intermediate Rounds (2 to r-1):**  
  - If any opponent cooperated in the previous round, defect to exploit their contribution this round.  
  - If no one cooperated in the previous round, defect to avoid being the sucker.  
  - In other words, always defect except for a brief controlled probe described below.

- **Probe Mechanism (Optional but aggressive):**  
  - Once in the middle of the game (e.g., at round ⌈r / 2⌉), cooperate to test if others also cooperate.  
  - This serves as a bait to detect if some opponents try to maintain cooperation (and thus can be exploited in subsequent rounds).  
  - After probing, immediately return to defecting regardless of outcome.

- **Last Round (Round r):**  
  - Defect, because there is no future punishment or reward based on your actions.

---

## 2. Edge Cases Handling

- **First Round:** Defect as there’s no prior info to exploit.

- **Last Round:** Defect to maximize guaranteed payoff; no incentive to cooperate.

- **Mid Game Probe Round:** Cooperate exactly once at midgame round to bait cooperators and observe their reactions.

- **If all defect (identified by zero cooperators previous round):** Continue defecting to avoid being exploited.

---

## 3. Aggressiveness Aspect

- **Always prioritize personal payoff over group benefit.**

- **Never cooperate more than once per game**, as cooperating reduces immediate payoff.

- **Use the single cooperation probe to exploit potential cooperators, not to build trust.**

- **Use knowledge from previous rounds to defect when others contribute, maximizing free-riding benefits.**

---

## Pseudocode

```python
def aggressive_defector_strategy(round_number, history, r, n, k):
    """
    Parameters:
    - round_number: current round (1-indexed)
    - history: list of past rounds, each element is list of players' actions ['C' or 'D']
      history[t] = actions at round t+1 (0-indexed)
    - r: total rounds
    - n: total players (including self)
    - k: multiplication factor

    Returns:
    - 'C' or 'D' for current round action
    """

    # 1-based indexing for rounds here
    # Always defect on first round
    if round_number == 1:
        return 'D'

    # Always defect on last round
    if round_number == r:
        return 'D'

    # Midgame probe round: cooperate once to bait cooperators
    mid_round = (r + 1) // 2  # ceiling of r/2
    if round_number == mid_round:
        return 'C'

    # Otherwise, leverage information from previous round
    previous_round_actions = history[round_number - 2]  # zero-index adjusted

    # Count number of cooperators last round (excluding self)
    # For aggression, treating self as last round action does not matter 
    # since we are deciding current round.
    coop_in_prev_round = sum(1 for a in previous_round_actions if a == 'C')

    if coop_in_prev_round > 0:
        # Exploit cooperative players by defecting
        return 'D'
    else:
        # No one cooperated last round, so avoid cooperating alone
        return 'D'
```

---

### Explanation:

- The strategy defects almost always, thereby avoiding losses caused by cooperating alone.

- The single cooperation round in the middle serves as an **aggressive "probe"** that:  
  - Sacrifices payoff once to detect who cooperates.  
  - Exploits cooperating players in following rounds by defecting.

- Defect at the end to avoid leaving free money on the table because no future punishment exists.

- This approach exploits the public goods game payoff structure: the multiplication factor **k is less than n**, so defecting when others cooperate yields higher immediate payoff.

---

### Intuition and Expected Outcomes

- Against all defectors, this strategy yields stable payoff ≈ 1 every round.

- Against any cooperators, it exploits them and earns payoff > 1 each round they cooperate while this strategy defects.

- The single cooperation probe may reduce payoff by 1 unit but the exploitation gain in following rounds offsets this.

- It avoids naive cooperation, which is costly and exploited by others.

---

If you want, I can also help draft variations with probabilistic defection or punishment for persistent cooperators, but the above is a clear-cut *aggressive* defector strategy designed to maximize exploitation and personal gain.
'''

description_AGGRESSIVE_126 = '''
Here is a design for an **aggressive** strategy in the repeated N-player Public Goods Game. The strategy maximizes my individual payoff by exploiting cooperation of others while punishing defectors, aiming to out-compete and dominate the payoff pool.

---

### Aggressive Strategy Description

**Rationale:**  
The aggressive strategy:

- **Defects initially** to test the waters and gain a free-ride payoff when possible.
- **Exploits cooperative players** by defecting as much as possible while still extracting their contributions.
- **Punishes players who defect persistently** by cooperating temporarily to signal potential retaliation, then defecting to deny any public good benefits.
- **Shifts behavior at the last round** to maximize immediate payoff (defect).
- Does **not cooperate first**, to avoid being exploited.
- Uses **history to detect exploitable cooperators** and adapt behavior accordingly.

---

### Detailed Decision Rules

#### Basic notation
- Let `t` = current round (1 to r)
- Let `actions_history[t][i]` = action of player i in round t (C or D)
- Let `n` = number of players including self
- Let `cooperators_in_last_round` = number of players (excluding self) who cooperated in round t-1
- Let `D_others_in_last_round` = number of players (excluding self) who defected in round t-1
- Let `threshold` = cooperation threshold (see below)

---

### Step 1: Initialization

- **Round 1:** Defect (D) immediately to maximize private payoff and avoid sucker’s payoff.

---

### Step 2: From Round 2 to Round r-1

**Goal:** Defect aggressively to maximize personal gain but exploit cooperators to gain the public good benefit.

**Decision:**

1. **Calculate opponent cooperation ratio from last round:**

\[
\text{coop_ratio} = \frac{\text{number of other players who cooperated}}{n - 1}
\]

2. **Set cooperation threshold (aggressiveness parameter):**

\[
\text{threshold} = 0.3
\]

This means we only consider cooperating if most others cooperate fairly often; since this is aggressive, 30% cooperation or less by others is treated as defection.

3. **If coop_ratio ≥ threshold:**

- Still Defect (D).  
- Rationale: Aggressive strategy never cooperates proactively, but exploits cooperators fully.

4. **Else (coop_ratio < threshold):**

- Defect (D) to punish low cooperation group and maximize payoff.

**Summary:**  
Always defect except possibly if you want to trigger cooperation from others by experiment (see Step 3).

---

### Step 3: Occasional Cooperation to Test or Signal (Optional, aggressive variation)

If you want to add a small probing move to check if others will cooperate:

- Every fixed number of rounds (say every 5 rounds), cooperate once to check if others follow.
- If others respond with cooperation next round, exploit by defecting again.
- If no cooperation is observed, continue defecting.

This can be omitted to maximize aggressiveness if preferred.

---

### Step 4: Final Round (Round r)

- Always Defect (D) on the last round to avoid being exploited.
- No incentive to cooperate as no future rounds exist for retaliation or reward.

---

### Step 5: Edge cases and notes

- **If all others cooperate:** You always defect to maximize payoff.
- **If all others defect:** You defect as well (no benefit from cooperating).
- **If partial cooperation:** You defect to exploit cooperators.
- **No forgiveness cycle:** Aggressive strategy avoids cooperation and forgiveness for maximum raw payoff.
- **No retaliation phase:** Aggressive strategy doesn't punish cooperators by cooperating; it punishes defectors by ignoring any benefit other than own defecting payoff.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, actions_history):
    """
    Parameters:
    - t: current round (1-indexed)
    - r: total rounds
    - n: number of players (including self)
    - actions_history: list of lists, where actions_history[round][player] contains 'C' or 'D'
        for rounds 1..t-1 (empty for t=1)

    Returns:
    - 'C' or 'D' (current player's action)
    """
    if t == 1:
        # First round: defect
        return 'D'

    if t == r:
        # Last round: defect
        return 'D'

    # Calculate opponent cooperation ratio in last round
    last_round = t - 1
    others_actions = [actions_history[last_round-1][i] for i in range(n) if i != self_index]

    coop_count = others_actions.count('C')
    coop_ratio = coop_count / (n - 1)

    threshold = 0.3  # aggressiveness parameter

    # Always defect, exploiting cooperators
    # Optional: probe cooperation every 5 rounds (could be commented out to be fully aggressive)
    # if t % 5 == 0:
    #     return 'C'

    return 'D'
```

---

### Summary

| Round           | Decision Rule                                        |
|-----------------|----------------------------------------------------|
| 1               | Defect                                             |
| 2..r-1          | Defect always to exploit cooperators and punish defectors |
| r (final round)  | Defect                                             |

**This pure defection strategy exploits all cooperators, gains maximal private payoffs unless all defect, and never risks contributing.**

---

### Why is this aggressive?

- Never cooperates first — no sacrifice.
- Always defects — exploits others’ contributions.
- Never forgives or cooperates as retaliation.
- Always defects last round to prevent exploitation.
- Tries to maximize immediate and total payoff over repeated rounds.

This aligns with classic "always defect" or "defect-heavy" aggressive strategies in social dilemma environments.

---

If you want a more nuanced aggressive variant that tries to provoke cooperation first and then exploit it, you may add the probing cooperation every few rounds, but pure defection is the most unambiguously aggressive choice given the payoff matrix and repeated game.
'''

description_AGGRESSIVE_127 = '''
Below is a detailed aggressive strategy designed for the repeated N-player Public Goods Game described.

---

# Aggressive Strategy: **"Exploitative Defector with Opportunistic Cooperation"**

## Intuition

An **aggressive** player in this context tries to maximize their own payoff by exploiting cooperators whenever possible, while punishing or deterring others from cooperation if it does not benefit them. The main goal is to defect often (to keep the private endowment) but strategically choose times to cooperate **only** if the resulting public goods payoff exceeds the private payoff plus what defectors earn. This strategy aggressively tries to maintain or maximize personal gain, accepting minimal or zero cooperation in the group.

---

## Key Points / Overview

- **First round:** Always defect (establish aggressiveness, never give away free contribution).
- **Subsequent rounds:**  
  - Cooperate **only if** enough other players cooperated in the previous round to guarantee a strictly higher payoff by cooperating this round.
  - Defect otherwise.
- **Last round:** Always defect (no future rounds to incentivize cooperation).
- **If exploited (others cooperate a lot while you defect):** Continue defecting to maximize own gain.
- **If mutual cooperation emerges and benefits you:** cooperate **only** if it is guaranteed beneficial.

---

## Logic Behind Cooperation Threshold

From payoff formula for a single round:

- If I defect (c_i = 0): payoff = 1 + (k/n)*total_cooperators

- If I cooperate (c_i = 1): payoff = 0 + (k/n)*total_cooperators

Note defectors get extra 1 unit from private endowment each round.

To make cooperating worthwhile, the payoff from cooperating must be **strictly greater than** defecting, i.e.:

```
(k/n) * total_cooperators_coop > 1 + (k/n) * total_cooperators_defect
```

But total cooperators include myself, so cooperating adds one more to the total.

Set total_cooperators_defect = x (number of other cooperators if I defect), so total_cooperators_coop = x + 1.

Plug in:

(k/n)*(x + 1) > 1 + (k/n)*x  
=> (k/n) * (x + 1) - (k/n)*x > 1  
=> (k/n) * 1 > 1  
=> k/n > 1

But from game specification, 1 < k < n  

=> k/n < 1

Contradiction — cooperating cannot produce strictly better payoff than defecting regardless of the number of other cooperators.

This means cooperation **always produces less or equal payoff than defecting** in a single round.

---

## Implication of the above (Important)

- **Selfish payoff maximization implies never cooperating in any round.**
- But since it's repeated, you might cooperate to encourage cooperation from others.

However, since players are simultaneously defecting or cooperating every round without communication, and since cooperation is strictly dominated by defection in single rounds, the dominant strategy is defect every round.

---

## To be *aggressive* (maximize own payoff), with very minimal assumptions:

- Always defect (which yields private endowment plus public good share).
- No cooperation — never give away private endowment.
- Exploit others if they cooperate.

---

## But to beef up aggression with a tactical *trap*:

Sometimes cooperating in isolated rounds when many others cooperated last round **could** increase total payoff if a collective boost happens.

Hence a secondary “exploitative cooperation” step that:

- If in previous round, at least (ceil(n/2)) cooperators, cooperate this round to get maximum public good share (at cost of private endowment)  
- Otherwise defect

**However, since payoff is lower with cooperation, this is aggressive only if you suspect others are cooperating fully and you want to not lose out on the public good, but still keep defecting otherwise.**

---

## Final Strategy Definition

```pseudo
Initialize:
  round = 1

For each round t in [1..r]:

  if t == r:  # Final round
    play D  # No future punishment/incentive, maximize own payoff
    
  else if t == 1:
    play D  # Nobody has history, defect aggressively
    
  else:
    # Count cooperators in previous round (excluding myself)
    last_round_cooperators = number_of_C_in_round(t-1)
    
    if last_round_cooperators >= ceil(n/2):
      # Many cooperators last round, cooperate to exploit
      play C
    else:
      # Otherwise defect to exploit
      play D
```

---

## Explanation of Decision Rules

- **Round 1:** Defect — start off aggressively; no history.
- **Rounds 2 to r-1:**  
  - If majority cooperated last round, briefly "join" (cooperate) to get a bigger public goods payoff share.
  - Otherwise, defect to exploit cooperators and discourage cooperation.
- **Round r (last round):** Defect — no future rounds; no good reason to cooperate.

---

## Edge Cases

- If all defect in previous round → this round defect.
- If all cooperate last round → cooperate this round to maximize your payoff share and not miss the opportunity.
- If exactly half cooperate last round (when n even) → cooperate this round (tie-break in favor of cooperation).
- Handles minimal cooperation and maximizes exploitation.

---

## Rationale on Aggressiveness

- Never cooperate unconditionally.
- Only cooperate to **exploit a cooperating majority**—not to build trust or cooperate long term.
- Last round defection ensures no loss from trusting others “too late.”
- Strategy exploits others’ cooperation aggressively without sacrificing the private endowment baseline unnecessarily.

---

# Summary

| Round                 | Action                       | Reason                                             |
|-----------------------|------------------------------|----------------------------------------------------|
| 1 (first)             | Defect                       | Start aggressively, no info                        |
| 2 to r-1 (middle)     | Cooperate if ≥ half cooperated last round; else defect | Exploit any cooperative majority for public goods |
| r (last)              | Defect                       | No future to incentivize cooperation              |

---

# Optional Simplification for Strict Aggression

If you want **maximum aggression** without any cooperation at all (since it never pays to cooperate):

- Defect all rounds.

But adding the majority-triggered cooperation improves payoff when others cooperate aggressively.

---

# =======

If you want, I can also help produce formal pseudocode or decision tree for integration.

Would you like that?
'''

description_AGGRESSIVE_128 = '''
Here is a well-defined aggressive strategy for the N-Player Public Goods Game described:

---

### Strategy Name: **Aggressive Exploiter**

**Core Intuition:**  
This strategy aggressively seeks to maximize individual payoff by defecting (free-riding) whenever profitable, but initially probes cooperation to identify if exploitation is possible. It punishes cooperating players by defecting to exploit their contributions, but it also adapts if mutual defection is prevalent. The approach is "aggressive" in that it prioritizes immediate personal gain, exploiting cooperative players without risking being the sucker.

---

## 1. Decision Rules

- **Round 1 (First Round):**  
  Cooperate (C) to test if others will cooperate — acting as a bait to lure cooperators.

- **Subsequent Rounds (2 to r-1):**  
  - If **there were any cooperators** in the previous round (any c_j = 1 except self), *defect* (D) now to exploit them.  
  - If **nobody cooperated** last round (all defected), then:
    - Defect with high probability (e.g., 90%)  
    - Cooperate with low probability (e.g., 10%) to occasionally test if others resume cooperation, preventing permanent mutual defection.

- **Last Round (Round r):**  
  Defect (D) always — no longer any incentive to cooperate since no future rounds to punish or be reciprocated.

---

## 2. Handling Edge Cases

- **First Round:** No history available → cooperate to test for cooperators.  
- **No cooperating opponents last round:** Mutually defect but occasionally "probe" by cooperating to encourage others to cooperate so they can be exploited.  
- **All players defect:** The strategy does not waste cooperation and mostly defects to maximize personal payoff.  
- **Last round:** Defect decisively since future retaliation or reward is impossible.

---

## 3. Aggressiveness Explanation

- The initial cooperation is purely a test for exploitable cooperators rather than a genuine attempt at mutual cooperation.  
- Quickly switches to defecting whenever cooperators are detected (i.e., opportunistic exploitation).  
- Refuses to be the "sucker" (player who cooperates while others defect).  
- Occasionally tries to rekindle cooperation to find new exploitation opportunities but never commits to sustained cooperation once exploited.  
- Defects in the last round to extract maximum payoff since no future rounds exist for retaliation.

---

## Pseudocode

```python
# Inputs: round t, history_of_actions: list of dict round_actions
# where round_actions = {player_i: 'C'/'D' for i in 1..n}
# self_id: integer the index of this player (1..n)

def aggressive_exploiter(t, history_of_actions, self_id, n, r):
    if t == 1:
        # First round, cooperate to lure cooperators
        return 'C'
    
    if t == r:
        # Last round, defect
        return 'D'
    
    # Get actions from previous round
    prev_round_actions = history_of_actions[t-1]  # zero-based indexing assumed
    
    # Count cooperators excluding self
    coop_others = sum(1 for i, act in prev_round_actions.items() if i != self_id and act == 'C')
    
    if coop_others > 0:
        # There were cooperators, exploit by defecting
        return 'D'
    else:
        # No cooperators last round: mostly defect, but sometimes probe cooperation
        # For pseudocode, assume a random number generator rand() in [0,1)
        if rand() < 0.1:
            return 'C'  # Probe cooperation
        else:
            return 'D'  # Defect mostly to maximize payoff
```

---

### Summary

- **Round 1:** Cooperate to detect cooperators  
- **Intermediate rounds:** Defect if any cooperators detected last round; else mostly defect with occasional cooperation probes  
- **Round r:** Defect unconditionally

This plan aggressively exploits cooperators, punishes cooperation by not reciprocating, minimizes sucker payoffs, and leverages knowledge of game structure (including final round) to maximize individual payoffs. It balances exploitation with dynamic probes to maximize gains over repeated interactions.
'''
