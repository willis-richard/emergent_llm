"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: OpenAI
- Model: o4-mini
- Game: PublicGoodsDescription
"""

from emergent_llm.players.base_player import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription
from emergent_llm.common.actions import Action, C, D
from emergent_llm.common.history import PlayerHistory
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Grim‐Trigger with Endgame‐Defect:
    - Cooperate in round 1.
    - For rounds 2 to r−1, cooperate if everyone cooperated last round; if any defection ever seen, defect forever.
    - Defect in the last round regardless of history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish = False
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish:
            return Action.D
        if current_round == 1:
            return Action.C
        prev_idx = history.round_number - 1
        my_last = bool(history.my_actions[prev_idx])
        opp_last = history.opponent_actions[prev_idx]
        if not my_last or not all(opp_last):
            self.punish = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    Tit‐for‐Tat variant for N‐player public goods:
      - Start with cooperation
      - If a majority (≥50%) cooperated last round, cooperate
      - If fewer cooperated, defect now and punish for M future rounds
      - Punishment length M rounds, then forgive
      - Same rule each round, including the last
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tau = 0.5
        self.M = 2
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        prev_round = history.round_number - 1
        coop_self = int(history.my_actions[prev_round])
        coop_others = int(history.opponent_actions[prev_round].sum())
        c_prev = coop_self + coop_others
        n = self.game_description.n_players
        frac_prev = c_prev / n
        if frac_prev >= self.tau:
            return Action.C
        else:
            self.punish_counter = self.M
            return Action.D

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Public‐Goods Tit‐for‐Tat (PG‐TFT):
    - Cooperate in the first round.
    - In each subsequent round, if everyone (including self) cooperated
      in the previous round, cooperate; otherwise defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        self_cooperated = bool(history.my_actions[last_round])
        opponents_cooperated = bool(np.all(history.opponent_actions[last_round]))
        if self_cooperated and opponents_cooperated:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    Forgiving Trigger Strategy (FT):
    - Start by cooperating.
    - If any opponent defects in the previous round, defect once to punish.
    - After punishing for one round, unconditionally forgive and return to cooperation.
    - Repeat punish-once-then-forgive whenever a new defection appears.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.in_punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.in_punish:
            self.in_punish = False
            return Action.D
        last_round_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round_idx]
        if not last_opponent_actions.all():
            self.in_punish = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    Generous One‐Round Punisher:
    - Start by cooperating.
    - If anyone defects, defect this round and schedule exactly one more round of defection.
    - After the punishment round, forgive and return to cooperation unless a new defection occurs.
    - Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.pun_remain = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.pun_remain = 0
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.pun_remain > 0:
            self.pun_remain -= 1
            return Action.D
        last_idx = history.round_number - 1
        defections = int(np.sum(~history.opponent_actions[last_idx]))
        if defections > 0:
            self.pun_remain = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Forgiving-Trigger Cooperation (FTC):
    - Cooperate in the first round.
    - If any opponent defected in the previous round, defect and enter a 1-round punishment.
    - After punishing for one round, forgive and return to cooperation.
    - Defect in the final round to avoid end-game exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_turns_remaining = 0
        self.L = 1
        self.E = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t > r - self.E:
            return Action.D
        if self.punish_turns_remaining > 0:
            self.punish_turns_remaining -= 1
            return Action.D
        last_idx = history.round_number - 1
        if (~history.opponent_actions[last_idx]).any():
            self.punish_turns_remaining = self.L
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    Benefit‐Proportional Conditional Cooperator (BPCC).
    - Round 1: cooperate.
    - Rounds 2…r−1: cooperate if last round’s total cooperators ≥ ceil(n_players/k), else defect.
    - Round r: defect (endgame).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.threshold = math.ceil(self.n / self.k)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        if completed == self.r - 1:
            return Action.D
        last_idx = completed - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        self_coop = int(history.my_actions[last_idx])
        c_prev = opp_coops + self_coop
        if c_prev >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    Tit-for-tat with one-round punishment and end-game defection.

    - Round 1: Cooperate.
    - Rounds 2..r-1:
        • If in punishment mode, defect and decrement counter.
        • Else if everyone cooperated in the previous round, cooperate.
        • Else (someone defected last round), enter 1-round punishment and defect.
    - Round r: Defect (no future leverage).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_opponents = int(np.sum(history.opponent_actions[last_idx]))
        coop_self = 1 if history.my_actions[last_idx] else 0
        coop_prev = coop_opponents + coop_self
        if coop_prev == n:
            return Action.C
        else:
            self.punish_counter = 1
            return Action.D

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    Forgiving Tit-for-Tat with Endgame Adjustment for N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_idx = history.round_number - 1
        my_defected = not history.my_actions[last_idx]
        opp_defected = any((not a for a in history.opponent_actions[last_idx]))
        if my_defected or opp_defected:
            self.punish_counter = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Collective Tit-for-Tat (C-TFT):
    - Round 1: Cooperate.
    - In each subsequent round, cooperate if and only if every player
      (including yourself) cooperated in the previous round; otherwise defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_idx = history.round_number - 1
        you_cooperated = bool(history.my_actions[last_idx])
        opponents_cooperated = bool(history.opponent_actions[last_idx].all())
        if you_cooperated and opponents_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    Forgiving Trigger (FT) strategy:
    - Cooperate on the first round.
    - Defect on the last round (no future to enforce cooperation).
    - In rounds 2..r-1:
      * In COOP mode: if any opponent defected last round, switch to PUNISH and defect once;
        otherwise cooperate.
      * In PUNISH mode: defect, then if all opponents cooperated last round, switch to COOP;
        otherwise stay in PUNISH.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.mode = 'COOP'

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        last_opp = history.opponent_actions[last_idx]
        if self.mode == 'COOP':
            if not last_opp.all():
                self.mode = 'PUNISH'
                return Action.D
            else:
                return Action.C
        else:
            action = Action.D
            if last_opp.all():
                self.mode = 'COOP'
            else:
                self.mode = 'PUNISH'
            return action

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    N-Player Tit‐for‐Tat with Last‐Round Defection:
    - Cooperate in round 1.
    - For rounds 2 to r−1: cooperate iff everyone (including you) cooperated in the previous round.
    - Defect in the last round to avoid exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        all_opponents_cooperated = history.opponent_actions[last_idx].all()
        i_cooperated_last = bool(history.my_actions[last_idx])
        if all_opponents_cooperated and i_cooperated_last:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    Threshold‐Punish‐&‐Forgive strategy for the N‐Player Public Goods Game.
    - Round 1: Cooperate.
    - Rounds 2…r−1:
        * If within punishment window: Defect.
        * Else look at last round’s total cooperators:
            - If ≥ n−1: Cooperate.
            - If < n−1: Defect and trigger a 1‐round punishment.
    - Round r (last): Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_until = 0
        self.punish_len = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if t <= self.punish_until:
            return Action.D
        idx = completed - 1
        opp_coops = int(np.sum(history.opponent_actions[idx]))
        my_coop = int(history.my_actions[idx])
        total_coops = opp_coops + my_coop
        if total_coops >= self.game_description.n_players - 1:
            return Action.C
        else:
            self.punish_until = t + self.punish_len
            return Action.D

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    Grim-with-Endgame strategy for the public goods game.
    - Cooperate in rounds 1…r-1 as long as no one has ever defected.
    - Defect forever after the first observed defection.
    - Defect in the final round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        all_my_cs = history.my_actions.all()
        all_opp_cs = history.opponent_actions.all()
        no_defection_yet = all_my_cs and all_opp_cs
        return Action.C if no_defection_yet else Action.D

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    Generous Trigger with Finite Punishment:
    - Start cooperating.
    - If anyone defected last round (fewer than n-1 cooperators), punish for P=1 round.
    - After punishing, forgive and try to cooperate again.
    - Defect automatically in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.pun_counter = 0
        self.P = 1
        self.T = self.game_description.n_players - 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.pun_counter > 0:
            self.pun_counter -= 1
            return Action.D
        last_idx = history.round_number - 1
        our_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx]
        countC = int(our_last) + int(np.sum(opp_last))
        if countC >= self.T:
            return Action.C
        else:
            self.pun_counter = self.P
            return Action.D

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    Forgiving Threshold Tit-for-Tat (FTFTT):
    - Start with cooperation.
    - In rounds 2…r-1, if punishment is active, defect until counter runs out.
      Otherwise count defectors last round; if ≤ f_max cooperate, else defect and
      set a punishment phase of T_punish rounds.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.f_max = 1
        self.T_punish = 1
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        prev_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[prev_idx].sum())
        self_coop = 1 if history.my_actions[prev_idx] else 0
        total_coops = opp_coops + self_coop
        n = self.game_description.n_players
        defectors_last = n - total_coops
        if defectors_last <= self.f_max:
            return Action.C
        else:
            self.punishment_rounds_left = self.T_punish
            return Action.D

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Generous Group Tit-for-Tat with Endgame Conditioning.
    Promotes full-group cooperation, punishes lone defectors for one round,
    forgives immediately, and guards against last-round exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.pun_count = 0
        self.spotless_history = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if history.round_number >= 1:
            last_my = history.my_actions[-1]
            last_opp = history.opponent_actions[-1]
            if not (last_my and last_opp.all()):
                self.spotless_history = False
        if self.pun_count > 0:
            action = Action.D
            self.pun_count -= 1
        elif t == r:
            action = Action.C if self.spotless_history else Action.D
        else:
            last_my = history.my_actions[-1]
            last_opp = history.opponent_actions[-1]
            if last_my and last_opp.all():
                action = Action.C
            else:
                action = Action.D
                self.pun_count = 1
        return action

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    Threshold-Reciprocal Strategy (TRS):
    Cooperate on the first round, defect on the last round,
    and in between cooperate if and only if the total number
    of cooperators in the previous round met the threshold T = ceil(n/k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.T = math.ceil(self.n / self.k)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t_next = history.round_number + 1
        if t_next == self.r:
            return Action.D
        last_idx = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        self_coop = int(history.my_actions[last_idx])
        total_coops = opp_coops + self_coop
        if total_coops >= self.T:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Limited-Punishment Tit-for-Tat (LPTFT):
    - Cooperate first round.
    - If any defection seen, defect for L rounds (punishment), unless all players
      fully cooperate during punishment (then forgive early).
    - After punishment expires, only cooperate if last round was unanimous cooperation.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.timer = 0
        self.m_prev = None
        self.L = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_idx = history.round_number - 1
        coop_count = int(history.my_actions[last_idx]) + int(history.opponent_actions[last_idx].sum())
        if self.timer > 0 and coop_count == self.game_description.n_players:
            self.timer = 0
        self.m_prev = coop_count
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.timer > 0:
            self.timer -= 1
            return Action.D
        if self.m_prev == n:
            return Action.C
        else:
            self.timer = self.L
            return Action.D

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    Conditional Cooperate & Punish strategy:
    - Start by cooperating.
    - If everyone cooperated last round, cooperate.
    - If any defection observed, defect for a fixed punishment length L, then forgive.
    - On the last round, if not punishing and last round was full cooperation, cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.L = max(1, game_description.n_rounds // 2)
        self.alpha = 1.0
        self.punish_remain = 0
        self.ever_defected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        r = self.game_description.n_rounds
        rounds_left = r - completed
        last_idx = completed - 1
        coop_prev = 0
        if completed > 0:
            coop_prev = int(history.my_actions[last_idx]) + int(history.opponent_actions[last_idx].sum())
        else:
            coop_prev = self.game_description.n_players
        if self.punish_remain > 0:
            self.punish_remain -= 1
            action = Action.D
        elif coop_prev >= self.alpha * self.game_description.n_players:
            action = Action.C
        else:
            self.ever_defected = True
            self.punish_remain = min(self.L, rounds_left)
            action = Action.D
        if t == r and self.punish_remain == 0 and (coop_prev >= self.alpha * self.game_description.n_players):
            action = Action.C
        return action

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Cooperative‐minded Pavlov strategy for the N‐player public goods game:
    - Round 1: Cooperate.
    - Rounds 2..r-1: Win‐stay/lose‐shift based on comparing actual vs. hypothetical payoff.
    - Round r: Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.game_description.n_players
        k = self.game_description.k
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        prev_action = bool(history.my_actions[-1])
        coop_opp = int(history.opponent_actions[-1].sum())
        prev_H = int(prev_action) + coop_opp
        pi_prev = float(history.my_payoffs[-1])
        if prev_action:
            alt = 1 + k / n * (prev_H - 1)
        else:
            alt = 0 + k / n * (prev_H + 1)
        if pi_prev >= alt:
            next_action = prev_action
        else:
            next_action = not prev_action
        return Action.C if next_action else Action.D

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Proportional Punishment Trigger (PPT) strategy for the N-player public goods game.
    Starts by cooperating, punishes defectors by defecting for as many rounds as there were defectors,
    then returns to cooperation. In the last round, always defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.punish_cnt = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        if self.punish_cnt > 0:
            self.punish_cnt -= 1
            return Action.D
        prev_idx = history.round_number - 1
        coop_opponents = int(np.sum(history.opponent_actions[prev_idx]))
        coop_self = int(history.my_actions[prev_idx])
        total_coop = coop_opponents + coop_self
        if total_coop == self.n_players:
            return Action.C
        else:
            defectors = self.n_players - total_coop
            self.punish_cnt = defectors - 1
            return Action.D

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    Forgiving Trigger with End-Game Defection:
    - Cooperate in first round.
    - In rounds 2..r-1: if currently punishing, defect for one round then forgive;
      otherwise, cooperate if everyone cooperated last round, else defect once and
      enter punishment phase.
    - In final round, always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish = 0
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish == 1:
            action = Action.D
            self.punish_counter -= 1
            if self.punish_counter <= 0:
                self.punish = 0
            return action
        last_idx = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        my_last = int(history.my_actions[last_idx])
        total_coop_last = opp_coops + my_last
        if total_coop_last == self.game_description.n_players:
            return Action.C
        else:
            self.punish = 1
            self.punish_counter = 1
            return Action.D

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    Majority-Reciprocator:
    - Start with cooperation.
    - If at least ⌈n/2⌉ cooperated last round, cooperate.
    - Otherwise defect for one round (punishment), then forgive.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold = math.ceil(self.n_players / 2)
        self.pun_duration = 1
        self.punishing = False
        self.pun_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.n_rounds:
            return Action.D
        if self.punishing:
            action = Action.D
            self.pun_timer += 1
            if self.pun_timer >= self.pun_duration:
                self.punishing = False
            return action
        else:
            last_idx = completed - 1
            my_last = history.my_actions[last_idx]
            opp_last = history.opponent_actions[last_idx]
            total_prev = int(my_last) + int(np.sum(opp_last))
            if total_prev >= self.threshold:
                return Action.C
            else:
                self.punishing = True
                self.pun_timer = 0
                return Action.D

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    Forgiving Trigger strategy for N‐player public goods:
    - Start by cooperating.
    - If up to T opponents defected last round, punish by defecting for M rounds.
    - If more than T defected, switch to grim trigger (defect forever).
    - After a brief punishment, immediately forgive and return to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = 1
        self.M = 1
        self.pun_counter = 0
        self.grim = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.grim:
            return Action.D
        if self.pun_counter > 0:
            self.pun_counter -= 1
            return Action.D
        idx = history.round_number - 1
        opp_last = history.opponent_actions[idx]
        d_prev = int(len(opp_last) - opp_last.sum())
        if d_prev == 0:
            return Action.C
        elif d_prev <= self.T:
            self.pun_counter = self.M - 1
            return Action.D
        else:
            self.grim = True
            return Action.D

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    Conditional cooperator for the N‐player public goods game:
    - Start by cooperating.
    - If everyone cooperated in the previous round, cooperate.
    - If any defection occurred, defect for exactly one round (punishment), then forgive.
    - Always defect in the final round.
    """
    PUNISH_LENGTH = 1

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_flag = False
        self.punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_flag = False
            self.punishment_timer = 0
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            if self.punishment_timer == 0:
                self.punish_flag = False
            return Action.D
        prev_idx = completed - 1
        opp_coops = int(np.sum(history.opponent_actions[prev_idx]))
        self_coop = 1 if history.my_actions[prev_idx] else 0
        coop_count = opp_coops + self_coop
        if coop_count == self.game_description.n_players:
            return Action.C
        else:
            self.punish_flag = True
            self.punishment_timer = self.PUNISH_LENGTH
            return Action.D

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    Generous‐Majority Tit-for-Tat (GM‐TFT) strategy for the N-player public goods game.
    Starts with cooperation, punishes if a strict majority defected last round,
    forgives when a majority cooperates, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T = math.floor(self.n / 2) + 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_completed = history.round_number
        if rounds_completed == self.r - 1:
            return Action.D
        idx_prev = rounds_completed - 1
        coop_opponents = int(np.sum(history.opponent_actions[idx_prev]))
        coop_self = int(history.my_actions[idx_prev])
        coop_prev = coop_opponents + coop_self
        if coop_prev >= self.T:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    Firm‐but‐Fair Trigger strategy for the n‐player repeated public goods game.
    - Start by cooperating.
    - Always defect in the last round.
    - In between, if in punishment mode, defect exactly one round then return to good standing.
    - In good standing, cooperate if at least n−1 players cooperated last round, else defect and enter punishment mode.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_mode = False
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        t = history.round_number + 1
        if t == r:
            return Action.D
        if self.punish_mode:
            action = Action.D
            self.punish_timer += 1
            if self.punish_timer >= 1:
                self.punish_mode = False
                self.punish_timer = 0
            return action
        prev_idx = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[prev_idx]))
        self_coop = int(history.my_actions[prev_idx])
        total_coops = opp_coops + self_coop
        if total_coops >= n - 1:
            return Action.C
        self.punish_mode = True
        return Action.D

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Collective Tit-for-Tat with Finite Punishment and End-game Defense.
    - G: punishment length after a defection
    - E: number of final rounds in which to always defect
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.G = 1
        self.E = 1
        self.punish_until = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t > self.r - self.E:
            return Action.D
        if t <= self.punish_until:
            return Action.D
        last = history.round_number - 1
        coop_self = 1 if history.my_actions[last] else 0
        coop_others = int(history.opponent_actions[last].sum())
        total_cooperators = coop_self + coop_others
        if total_cooperators == self.n:
            return Action.C
        else:
            self.punish_until = t + self.G
            return Action.D

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    One‐Period Punishment with Endgame Defection:
    - Cooperate by default.
    - If anyone defected in the previous round, defect this round exactly once, then forgive.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_defect_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        if completed > 0:
            idx = completed - 1
            total_coops = int(history.my_actions[idx]) + int(history.opponent_actions[idx].sum())
            if total_coops < self.game_description.n_players:
                self.last_defect_round = completed
        current_round = history.round_number + 1
        final_round = self.game_description.n_rounds
        if current_round == final_round:
            return Action.D
        if current_round == self.last_defect_round + 1:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    Finite-Punishment Conditional Cooperator (FPCC).
    Starts by cooperating, punishes any defection for p rounds,
    forgives thereafter, and in the final m rounds cooperates
    only if no defection has ever been observed.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 2
        self.m = 1
        self.punish_timer = 0
        self.ever_defected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        last_idx = history.round_number - 1
        if history.round_number >= 1:
            if not history.my_actions[last_idx] or not history.opponent_actions[last_idx].all():
                self.ever_defected = True
        if t == 1:
            return Action.C
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        if t > total_rounds - self.m:
            if not self.ever_defected:
                return Action.C
            else:
                return Action.D
        cooperated_last = history.my_actions[last_idx] and history.opponent_actions[last_idx].all()
        if cooperated_last:
            return Action.C
        else:
            self.ever_defected = True
            self.punish_timer = self.p
            return Action.D

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    Forgiving trigger strategy for the n‐player public goods game.
    - Round 1: start by cooperating.
    - If everyone cooperated last round, cooperate.
    - If anyone defected last round, punish with one defection, then immediately forgive.
    - In the very last round, always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.just_punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.just_punished = False
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.just_punished:
            self.just_punished = False
            return Action.C
        last_idx = history.round_number - 1
        prev_my = history.my_actions[last_idx]
        prev_opps = history.opponent_actions[last_idx]
        all_cooperated = bool(prev_my and prev_opps.all())
        if all_cooperated:
            return Action.C
        else:
            self.just_punished = True
            return Action.D

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    Forgiving Tit‐for‐Tat for N‐Player Public Goods:
    - Cooperate on first move.
    - If any opponent defected last round, defect this round exactly once.
    - Otherwise cooperate.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish_rounds_remaining > 0:
            self.punish_rounds_remaining -= 1
            return Action.D
        last_idx = history.round_number - 1
        if np.any(~history.opponent_actions[last_idx]):
            self.punish_rounds_remaining = 0
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    Finite‐punishment tit-for-tat for the repeated public‐goods game.
    Start by cooperating. Whenever any opponent defected in the previous round,
    defect for the next P rounds as a group‐wide punishment. After P rounds,
    resume cooperation unless new opponent defections occur.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.P = 2
        self.punish_until = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t <= self.punish_until:
            return Action.D
        opp_last = history.opponent_actions[-1]
        any_opp_defected = not opp_last.all()
        if any_opp_defected:
            r = self.game_description.n_rounds
            self.punish_until = min(r, t + self.P - 1)
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    N-Player Tit-for-Tat with one-round punishment and last-round defection.
    - Round 1: Cooperate.
    - Rounds 2..r-1: If everyone cooperated last round, cooperate;
      otherwise defect this round as punishment, then forgive.
    - Round r: Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish:
            self.punish = False
            return Action.D
        last_idx = history.round_number - 1
        me_cooperated = bool(history.my_actions[last_idx])
        opponents_cooperated = bool(history.opponent_actions[last_idx].all())
        if me_cooperated and opponents_cooperated:
            return Action.C
        else:
            self.punish = True
            return Action.D

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    Forgiving Trigger with End‐Game Defection:
    - Start by cooperating.
    - If any defection is observed, defect immediately and set a one‐round punishment.
    - After one round of punishment, forgive and return to cooperation if full cooperation observed.
    - In the final round, defect unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.D
        last_idx = history.round_number - 1
        opponent_coops = int(np.sum(history.opponent_actions[last_idx]))
        my_prev_coop = int(history.my_actions[last_idx])
        total_coops = opponent_coops + my_prev_coop
        if total_coops == self.game_description.n_players:
            return Action.C
        else:
            self.punishing = True
            return Action.D

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    One‐round punishment, automatic forgiveness public goods strategy.
    Cooperate on first move, punish any defection for exactly one round,
    then forgive. Defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_flag = False
            return Action.C
        next_round = history.round_number + 1
        if next_round == self.game_description.n_rounds:
            return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.D
        last_index = history.round_number - 1
        self_last = int(history.my_actions[last_index])
        opp_last = int(np.sum(history.opponent_actions[last_index]))
        total_cooperators = self_last + opp_last
        if total_cooperators < self.game_description.n_players:
            self.punish_flag = True
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    Forgiving‐trigger strategy for the N‐Player Public Goods Game.
    - Always cooperate in the first round.
    - Defect in the final round (end‐game).
    - If any opponent defected in the previous round, defect exactly one round in response.
    - Otherwise, cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_count = 0
        self.MAX_PUNISH = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        next_round = current_round + 1
        total_rounds = self.game_description.n_rounds
        if next_round == total_rounds:
            return Action.D
        if self.punish_count > 0:
            self.punish_count -= 1
            return Action.D
        last_idx = current_round - 1
        if np.any(~history.opponent_actions[last_idx]):
            self.punish_count = self.MAX_PUNISH
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Group-Tit-for-Tat with Last-Round Defection:
    Cooperate on the first round, cooperate if everyone cooperated in the
    previous round, defect for one round as punishment if any defection occurs,
    and always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_my_action = history.my_actions[-1]
        last_opp_actions = history.opponent_actions[-1]
        if last_my_action and np.all(last_opp_actions):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    One‐round punishment Tit‐for‐Tat for the N‐Player Public Goods Game,
    with forgiveness and an inevitable last‐round defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if t == total_rounds:
            return Action.D
        if self.punish_remaining > 0:
            self.punish_remaining -= 1
            return Action.D
        last_idx = history.round_number - 1
        coopers_opponents = int(np.sum(history.opponent_actions[last_idx]))
        coopers_self = int(history.my_actions[last_idx])
        coopers_last = coopers_opponents + coopers_self
        if coopers_last == n_players:
            return Action.C
        else:
            self.punish_remaining = 1
            return Action.D

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Collective Tit‐for‐Tat with Limited Punishment and End‐Game Defection:
    - Start by cooperating.
    - If anyone defects, defect for exactly one round as punishment, then forgive.
    - If last round was unanimous cooperation, cooperate.
    - In the final round, defect to capture any unilateral gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_timer = 0
            return Action.C
        completed = history.round_number
        current_round = completed + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_idx = completed - 1
        opp_coop = int(np.sum(history.opponent_actions[last_idx]))
        my_coop = 1 if history.my_actions[last_idx] else 0
        total_coop_last = opp_coop + my_coop
        if total_coop_last == self.game_description.n_players:
            return Action.C
        else:
            self.punish_timer = 1
            return Action.D

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    Multi‐player 1‐Round Punish‐and‐Forgive Tit‐for‐Tat:
    - Cooperate on the first move.
    - Defect in the final round.
    - In intermediate rounds, if everyone cooperated last round, cooperate.
      If someone defected and you cooperated, punish once (defect).
      If someone defected and you defected (you punished), forgive (cooperate).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        current_round = completed + 1
        r = self.game_description.n_rounds
        if current_round == r:
            return Action.D
        last_idx = completed - 1
        coop_opponents = int(history.opponent_actions[last_idx].sum())
        coop_self = 1 if history.my_actions[last_idx] else 0
        total_coop = coop_opponents + coop_self
        if total_coop == self.game_description.n_players:
            return Action.C
        if history.my_actions[last_idx]:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    Reciprocal Cooperator with 1-Round Punishment for the Public Goods Game.
    Starts by cooperating, punishes any defection with one round of defection,
    then forgives and returns to cooperation. Always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_timer = 0
        self.L = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        coop_opp_last = int(np.sum(history.opponent_actions[history.round_number - 1]))
        coop_self_last = 1 if history.my_actions[history.round_number - 1] else 0
        total_coops_last = coop_opp_last + coop_self_last
        if total_coops_last == n:
            return Action.C
        else:
            self.punish_timer = self.L
            return Action.D

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    n‐player Tit‐for‐Tat (nTFT) for the Public Goods Game:
    - Round 1: cooperate.
    - Rounds 2 to r−1: cooperate iff everyone (including yourself) cooperated last round.
    - Round r: defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        last_idx = history.round_number - 1
        if not history.my_actions[last_idx]:
            return Action.D
        if not np.all(history.opponent_actions[last_idx]):
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    Conditional Cooperator (CC) for the repeated N-player public goods game.
    Starts with cooperation, defects in the last round, and otherwise defects
    for exactly one round if any other player defected in the immediately
    preceding round, then forgives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.prev_others_defected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.prev_others_defected = False
            return Action.C
        total_rounds = self.game_description.n_rounds
        next_round = history.round_number + 1
        if next_round == total_rounds:
            action = Action.D
        elif self.prev_others_defected:
            action = Action.D
        else:
            action = Action.C
        if history.round_number >= 1:
            last_idx = history.round_number - 1
            other_actions_last = history.opponent_actions[last_idx]
            defect_count = int(np.sum(~other_actions_last))
            self.prev_others_defected = defect_count > 0
        else:
            self.prev_others_defected = False
        return action

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    1-Round Punish-and-Forgive strategy for the public goods game.
    Cooperate initially; if any opponent defected last round, defect for one round as punishment;
    then forgive and return to cooperation; in the final round, if not punishing, cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_remaining = 0
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_remaining = 0
            return Action.C
        t = history.round_number + 1
        if self.punish_remaining > 0:
            self.punish_remaining -= 1
            return Action.D
        if t == self.game_description.n_rounds:
            return Action.C
        last_opponents = history.opponent_actions[history.round_number - 1]
        num_defectors_prev = int(np.sum(~last_opponents))
        if num_defectors_prev > 0:
            self.punish_remaining = self.P
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    One-Round-Punishment Tit-for-Tat (ORP-TFT) for the N-player public goods game.
    - Start by cooperating.
    - If any opponent defected in the previous round, defect this round (one-round punishment), then forgive.
    - Keep track if anyone ever defected; on the last round, cooperate only if no defections ever occurred.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishing = False
        self.ever_defected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishing = False
            self.ever_defected = False
            return Action.C
        last_round_idx = history.round_number - 1
        others = history.opponent_actions[last_round_idx]
        others_defected = not np.all(others)
        if others_defected and (not self.punishing):
            self.ever_defected = True
            self.punishing = True
        elif self.punishing:
            self.punishing = False
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == 1:
            return Action.C
        elif t == r:
            return Action.C if not self.ever_defected else Action.D
        else:
            return Action.D if self.punishing else Action.C

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    Grim‐trigger for the n‐player public goods game.
    Cooperate on round 1, defect on the last round, and
    cooperate in intermediate rounds only if no defection
    has occurred in any prior round; otherwise defect forever.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_played = history.round_number
        t = rounds_played + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if t == total_rounds:
            return Action.D
        for s in range(rounds_played):
            my_coop = 1 if history.my_actions[s] else 0
            opp_coop = int(np.sum(history.opponent_actions[s]))
            if my_coop + opp_coop < n_players:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    Grim‐Trigger Public Goods (GTPG):
    - Start by cooperating.
    - Continue cooperating so long as no one has ever defected.
    - Upon observing any defection (self or opponent), switch to defect forever.
    - In the final round, cooperate only if there has never been any defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.triggered = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_my = history.my_actions[-1]
        last_opp = history.opponent_actions[-1]
        if not bool(last_my) or not bool(last_opp.all()):
            self.triggered = True
        next_round = history.round_number + 1
        is_last = next_round == self.game_description.n_rounds
        if not self.triggered:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Conditional Cooperator:
    - Opens with cooperation.
    - Defines threshold T = ceil((n_players + 1) / 2).
    - In each subsequent round, counts total cooperators (including self) in last round.
    - If that count >= T, cooperates; otherwise defects for exactly one round.
    - Forgiving: returns to cooperation as soon as group re‐coordinates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        self.T = math.ceil((n + 1) / 2)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        last = history.round_number - 1
        self_coop = int(history.my_actions[last])
        opp_coops = int(history.opponent_actions[last].sum())
        total_coops = self_coop + opp_coops
        if total_coops >= self.T:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    Generous Collective Tit-for-Tat with Endgame Defection.

    - Round 1: Cooperate.
    - Rounds 2..r-1: Cooperate if at least n-1 out of n players cooperated in the previous round;
      otherwise defect.
    - Round r (last): Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_completed = history.round_number
        total_rounds = self.game_description.n_rounds
        n = self.game_description.n_players
        if rounds_completed == total_rounds - 1:
            return Action.D
        last_index = rounds_completed - 1
        opp_cooperators = int(np.sum(history.opponent_actions[last_index]))
        my_coop_last = 1 if history.my_actions[last_index] else 0
        total_cooperators = opp_cooperators + my_coop_last
        if total_cooperators >= n - 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    One‐Round Punish & Forgive (ORPF) strategy for the N‐Player Public Goods Game.

    - Round 1: cooperate unconditionally.
    - If punish_timer > 0: defect this round, decrement punish_timer.
    - Else if last round was not full cooperation: set punish_timer=1, defect.
    - Else if this is the final round and no punishment pending: cooperate.
    - Otherwise: cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_opp = int(history.opponent_actions[last_idx].sum())
        coop_self = int(history.my_actions[last_idx])
        last_C_count = coop_opp + coop_self
        if t == r:
            return Action.C
        if last_C_count == n:
            return Action.C
        else:
            self.punish_timer = 1
            return Action.D

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Forgiving Trigger strategy:
    - Start by cooperating.
    - If any opponent defects, defect for M consecutive rounds (including the detection round).
    - After M rounds of punishment, return to cooperation.
    - Always cooperate in the final round regardless of punishment state.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.M = 2
        self.punish_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.C
        if self.punish_count > 0:
            self.punish_count -= 1
            return Action.D
        last_idx = history.round_number - 1
        opponents_last = history.opponent_actions[last_idx]
        if not opponents_last.all():
            self.punish_count = self.M - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    Forgiving Tit‐for‐Tat with final‐round defection:
    - Start by cooperating.
    - Punish any defection with one round of defection, then forgive.
    - Defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.P = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if t == total_rounds:
            return Action.D
        if self.P > 0:
            self.P -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_opponents = int(history.opponent_actions[last_idx].sum())
        coop_self = int(history.my_actions[last_idx])
        total_cooperators = coop_self + coop_opponents
        if total_cooperators < n_players:
            self.P = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    Threshold-Based Conditional Cooperation strategy for the N-player Public Goods Game.
    Starts by cooperating, defects in the last round, and in other rounds
    cooperates iff the number of cooperators in the previous round
    was at least ceil(n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.T = math.ceil(self.n / self.k)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.r:
            return Action.D
        prev_idx = completed - 1
        my_prev = history.my_actions[prev_idx]
        opp_prev = history.opponent_actions[prev_idx]
        total_cooperators = int(my_prev) + int(opp_prev.sum())
        if total_cooperators >= self.T:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    N-TFT+End-Defect: Start by cooperating, punish any defection by defecting for one round (P=1),
    then forgive and return to cooperation. Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_counter = 0
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if t == total_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        if not history.opponent_actions[prev_idx].all():
            self.punish_counter = self.P
            self.punish_counter -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Forgiving Group-Trigger (FGT) strategy:
    - Start by cooperating.
    - If last round was unanimous cooperation, cooperate.
    - If any defection occurred, punish by defecting for P rounds, then forgive.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_timer = 0
        self.last_all_coop = True
        self.P = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_idx = history.round_number - 1
        my_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx]
        self.last_all_coop = bool(my_last and all(opp_last))
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        if self.last_all_coop:
            return Action.C
        else:
            self.punishment_timer = self.P - 1
            return Action.D

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    N-player Tit-for-Tat with Forgiveness (N-TFT-F):
    - Cooperate on round 1 to signal goodwill.
    - Always defect on the final round (backward induction).
    - If punishment_timer > 0, defect and decrement timer.
    - Otherwise, inspect last round:
        • If at most one defection (forgiveness count = 1), cooperate.
        • Else start a 1-round punishment (defect with L=1).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.f_count = 1
        self.L = 1
        self.punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_self = 1 if history.my_actions[last_idx] else 0
        coop_others = int(np.sum(history.opponent_actions[last_idx]))
        coop_prev = coop_self + coop_others
        def_prev = n - coop_prev
        if def_prev <= self.f_count:
            return Action.C
        self.punishment_timer = self.L
        return Action.D

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    Threshold Reciprocal with One‐Period Punishment (TR‐OPP) strategy for the
    N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.L = math.floor(self.n / self.k) + 1
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.D
        last_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        self_coop = 1 if history.my_actions[last_idx] else 0
        total_coops = opp_coops + self_coop
        if total_coops >= self.L:
            return Action.C
        else:
            self.punishing = True
            return Action.D

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Trigger‐and‐forgive strategy for the N‐player public goods game.
    Starts by cooperating, punishes any defection with one round of defection,
    then forgives if full cooperation resumes. Always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.punish_flag = False
        self.last_coop_count = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_flag = False
            self.last_coop_count = None
            return Action.C
        last_my = history.my_actions[-1]
        last_opp = history.opponent_actions[-1]
        coop_count = int(last_my) + int(np.sum(last_opp))
        self.last_coop_count = coop_count
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.D
        if self.last_coop_count == self.n_players:
            return Action.C
        else:
            self.punish_flag = True
            return Action.D

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    Forgiving Tit-for-Tat for Public Goods:
    Cooperate initially, punish any defection for one round, then forgive.
    Defect in the final round since there is no future to sustain cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.pun_remaining = 0
        self.punish_length = 1
        self.endgame_cutoff = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t > self.n_rounds - self.endgame_cutoff:
            return Action.D
        if self.pun_remaining > 0:
            self.pun_remaining -= 1
            return Action.D
        last_idx = history.round_number - 1
        my_last = history.my_actions[last_idx]
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        total_coops_last = int(my_last) + opp_coops
        if total_coops_last == self.n_players:
            return Action.C
        else:
            self.pun_remaining = self.punish_length
            return Action.D

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    N-Player Tit-for-Tat with 1-round Punishment and Final-Round Defect.
    Starts by cooperating, defects for exactly one round whenever anyone defects,
    then returns to cooperation, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_index = history.round_number - 1
        my_last = history.my_actions[last_index]
        opp_last = history.opponent_actions[last_index]
        total_cooperators = int(my_last) + int(np.sum(opp_last))
        if total_cooperators == self.game_description.n_players:
            return Action.C
        else:
            self.punish_counter = 1
            return Action.D

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Collective tit-for-tat with one-round punishment and forgiveness,
    and defection in the last round of an n-player repeated public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punished_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punished_last_round:
            self.punished_last_round = False
            return Action.C
        last_idx = history.round_number - 1
        my_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx]
        total_cooperators = int(my_last) + int(opp_last.sum())
        if total_cooperators < self.game_description.n_players:
            self.punished_last_round = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Limited Trigger with End-Game Defection:
    - Start cooperating.
    - If any opponent defected last round, defect for P=1 round as punishment.
    - After punishment, forgive and cooperate.
    - Always defect in the final round to avoid the last‐round sucker problem.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_counter = 0
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_rounds = self.game_description.n_rounds
        t = history.round_number + 1
        if t == n_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_opponents = history.opponent_actions[-1]
        if not last_opponents.all():
            self.punish_counter = self.P
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    A Tit-for-Tat style public goods strategy with finite-horizon end-game defection.
    - Leads with cooperation.
    - If any defection observed, punishes by defecting for P rounds, then forgives.
    - In the last t_safe rounds of the known horizon, always defects to avoid end-game exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.P = 2
        self.t_safe = 1
        self.punishing_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            current_round = 1
        else:
            current_round = history.round_number + 1
        if current_round > self.game_description.n_rounds - self.t_safe:
            return Action.D
        if history is None:
            return Action.C
        if self.punishing_count > 0:
            self.punishing_count -= 1
            return Action.D
        last_idx = history.round_number - 1
        my_last = bool(history.my_actions[last_idx])
        opp_last = bool(np.all(history.opponent_actions[last_idx]))
        if my_last and opp_last:
            return Action.C
        self.punishing_count = self.P - 1
        return Action.D

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Threshold-One-Round-Punishment (T1P) strategy for the N-player public goods game.
    Starts with cooperation, punishes any defection event with one round of group defection,
    then returns to cooperation. Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.punish_timer = 0
        self.prev_coops = self.n_players

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
            last_idx = history.round_number - 1
            my_last = bool(history.my_actions[last_idx])
            opp_last_sum = int(np.sum(history.opponent_actions[last_idx]))
            self.prev_coops = (1 if my_last else 0) + opp_last_sum
        if t == 1:
            return Action.C
        if t == self.n_rounds:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        if self.prev_coops >= self.n_players - 1:
            return Action.C
        self.punish_timer = 1
        return Action.D

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Tit-for-tat with one-round punishment and endgame defection (TFT-1P-End)
    for the N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punished_remain = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punished_remain > 0:
            self.punished_remain -= 1
            return Action.D
        last_idx = history.round_number - 1
        last_opp_actions = history.opponent_actions[last_idx]
        if not last_opp_actions.all():
            self.punished_remain = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    Endgame-Forgiving Group Tit-for-Tat (EG-GTFT):
    - Round 1: cooperate
    - Rounds 2 to r-2: if everyone cooperated last round, cooperate; otherwise defect once
    - Round r-1: forgive (cooperate)
    - Round r: defect
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        t = history.round_number + 1
        if t == r:
            return Action.D
        if t == r - 1:
            return Action.C
        if 2 <= t <= r - 2:
            prev_idx = t - 2
            coop_self = int(history.my_actions[prev_idx])
            coop_opp = int(np.sum(history.opponent_actions[prev_idx]))
            if coop_self + coop_opp == n:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    Cooperator with grim‐trigger and endgame defection:
    - Cooperate on round 1.
    - In rounds 2 to r-1, cooperate only if no one (including self) has ever defected
      AND everyone cooperated in the immediately preceding round.
    - Always defect in the final round r.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.has_defected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if not history.my_actions.all() or not history.opponent_actions.all():
            self.has_defected = True
        t = history.round_number + 1
        final_round = self.game_description.n_rounds
        if t == final_round:
            return Action.D
        last_my = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1]
        all_cooperated_last = bool(last_my and last_opponents.all())
        if not self.has_defected and all_cooperated_last:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Conditional Cooperation with Finite Punishment & Forgiveness (CC-PF).
    Starts by cooperating, punishes low overall cooperation for a fixed number of rounds,
    allows occasional forgiveness, and defects in the final round (endgame).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.pun_len = 2
        self.epsilon = 0.1
        self.T = math.ceil((self.n - 1) / 2)
        self.punishing = False
        self.pun_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.punishing:
            action = Action.D
            self.pun_left -= 1
            if self.pun_left <= 0:
                self.punishing = False
            return action
        prev_idx = history.round_number - 1
        coop_prev = int(np.sum(history.opponent_actions[prev_idx]))
        if coop_prev < self.T:
            self.punishing = True
            self.pun_left = self.pun_len
            return Action.D
        if coop_prev < self.n - 1:
            if random.random() < self.epsilon:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Forgiving‐Trigger Strategy:
    - Cooperate in first round.
    - In rounds 2..r-1, if everyone cooperated last round, cooperate;
      otherwise defect for P=1 round as punishment, then forgive.
    - Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_rounds_played = history.round_number
        current_round = last_rounds_played + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        if self.punish_remaining > 0:
            self.punish_remaining -= 1
            return Action.D
        last_my = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1].sum()
        total_cooperators = (1 if last_my else 0) + int(last_opponents)
        if total_cooperators == n_players:
            return Action.C
        else:
            self.punish_remaining = 1
            return Action.D

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    Generous Threshold Tit-for-Tat:
    Cooperate on the first round and as long as a majority cooperated
    in the previous round; defect only when a clear majority defected;
    always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        self.threshold = math.floor(n / 2) + 1
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_completed = history.round_number
        if rounds_completed == self.n_rounds - 1:
            return Action.D
        last_index = rounds_completed - 1
        opp_coops = int(np.sum(history.opponent_actions[last_index]))
        self_coop = 1 if history.my_actions[last_index] else 0
        coop_count = opp_coops + self_coop
        if coop_count >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    Forgiving Trigger strategy for the N-player Public Goods Game.
    Starts with cooperation, defects for one round after any observed defection,
    then forgives (returns to cooperation), and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_until = 0
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_completed = history.round_number
        t = rounds_completed + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if t <= self.punish_until:
            return Action.D
        last_idx = rounds_completed - 1
        prev_self = 1 if history.my_actions[last_idx] else 0
        prev_ops = int(np.sum(history.opponent_actions[last_idx]))
        total_prev = prev_self + prev_ops
        if total_prev == n:
            return Action.C
        else:
            self.punish_until = t + self.P - 1
            return Action.D

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    TFT-PG: Tit-for-Tat for Public Goods.
    - Round 1: cooperate.
    - Rounds 2..r-1: if everyone cooperated last round → cooperate;
      else defect once (punishment_counter = 1) then forgive.
    - Round r: always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        prev_idx = history.round_number - 1
        coop_opponents = int(history.opponent_actions[prev_idx].sum())
        my_prev = int(history.my_actions[prev_idx])
        total_cooperators = coop_opponents + my_prev
        n = self.game_description.n_players
        if total_cooperators == n:
            return Action.C
        else:
            self.punishment_counter = 1
            return Action.D

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Generous Threshold with One‐Round Punishment:
    - Cooperate on first move.
    - Defect on the last round.
    - In intermediate rounds, count total cooperators in the previous round (including self).
      * If in punishment mode, defect once; if the previous round was full cooperation, exit punishment.
      * Otherwise, if at least n-1 cooperated last round, cooperate; else defect and enter punishment mode.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T = self.n - 1
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        if completed == self.r - 1:
            return Action.D
        last_idx = completed - 1
        my_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx]
        m = int(my_last) + int(np.sum(opp_last))
        if self.punish_flag:
            action = Action.D
            if m == self.n:
                self.punish_flag = False
        elif m >= self.T:
            action = Action.C
        else:
            action = Action.D
            self.punish_flag = True
        return action

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    Limited Punishment Tit-for-Tat (LP-TFT) for the repeated N-player public goods game.
    Starts by cooperating, defects in the last round, and punishes defections
    proportionally (up to P_max rounds) before returning to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.P_max = max(0, self.n - 1)
        self.punish_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_count = 0
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.punish_count > 0:
            self.punish_count -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_opponents = int(history.opponent_actions[last_idx].sum())
        coop_self = 1 if history.my_actions[last_idx] else 0
        coop_last = coop_opponents + coop_self
        defectors_last = self.n - coop_last
        if defectors_last > 0:
            self.punish_count = min(defectors_last, self.P_max)
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    One‐Round Punishment with Forgiveness strategy for the N‐Player Public Goods Game.
    Starts by cooperating, defects in the final round, and if any opponent defected
    in the previous round, punishes by defecting exactly one round before forgiving.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punishment_flag:
            self.punishment_flag = False
            return Action.C
        last_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_idx]
        if not all(last_opponent_actions):
            self.punishment_flag = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    One‐round‐memory Tit‐for‐Tat for the N‐player public goods game:
    - Start by cooperating.
    - In each subsequent round, if anyone defected in the previous round, defect once; otherwise cooperate.
    - Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_next = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history.round_number > 0:
            last_idx = history.round_number - 1
            coop_last = int(history.my_actions[last_idx]) + int(np.sum(history.opponent_actions[last_idx]))
            self.punish_next = coop_last < n
        if t == r:
            return Action.D
        if self.punish_next:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Generous Threshold Conditional Cooperator with Endgame Defection (GTCC-ED).
    - Cooperate on the first round.
    - Forgive a single defection (threshold = n-1 cooperators).
    - Punish by defecting exactly one round after seeing two or more defectors.
    - Defect on the final round (endgame defection).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_flag = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_flag = 0
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        t = history.round_number + 1
        if t == r:
            return Action.D
        if self.punish_flag == 1:
            self.punish_flag = 0
            return Action.D
        last_my = history.my_actions[-1]
        last_opps = history.opponent_actions[-1]
        cooperators = int(last_my) + int(np.sum(last_opps))
        if cooperators >= n - 1:
            return Action.C
        else:
            self.punish_flag = 1
            return Action.D

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    Forgiving Trigger strategy for the n‐player public goods game.
    Starts by cooperating, defects in the last round, punishes single defections
    with one round of defection (then forgives), and punishes mass defection
    by defecting for all remaining rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.P = 0
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.P = 0
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.P > 0:
            self.P -= 1
            return Action.D
        last_idx = history.round_number - 1
        opp_last = history.opponent_actions[last_idx]
        d_opp = int(np.sum(~opp_last))
        self_last = history.my_actions[last_idx]
        d_self = 0 if self_last else 1
        d = d_opp + d_self
        if d == 0:
            return Action.C
        elif d == 1:
            self.P = 1
            return Action.D
        else:
            self.P = self.r - t
            return Action.D

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    Forgiving threshold strategy for the N-player public goods game.
    Cooperates initially and whenever at most one player defected in the
    previous round; defects for one round if two or more defect, then forgives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T_tol = game_description.n_players - 1
        self.P_len = 1
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_round = history.round_number - 1
        coop_opponents = int(np.sum(history.opponent_actions[last_round]))
        coop_self = int(history.my_actions[last_round])
        total_coop = coop_opponents + coop_self
        if total_coop >= self.T_tol:
            return Action.C
        self.punish_timer = self.P_len
        return Action.D

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Majority-Conditional Cooperator with End-game Defection:
    - Cooperates in the first round.
    - In each intermediate round, cooperates if at least half cooperated in the previous round.
    - Defects otherwise.
    - Always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        prev_my = int(history.my_actions[last_idx])
        prev_opp = int(history.opponent_actions[last_idx].sum())
        c_prev = prev_my + prev_opp
        d_prev = self.n_players - c_prev
        if c_prev >= d_prev:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    Proportional Tit-for-Tat with Limited Punishment for N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.M = math.ceil(self.n / 2)
        self.P = 2
        self.punish_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if history.round_number == self.r - 1:
            return Action.C
        if self.punish_remaining > 0:
            self.punish_remaining -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_self = int(history.my_actions[last_idx])
        coop_others = int(np.sum(history.opponent_actions[last_idx]))
        total_coop = coop_self + coop_others
        if total_coop >= self.M:
            return Action.C
        else:
            self.punish_remaining = self.P - 1
            return Action.D

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    Conditional cooperator with one‐round punishment:
    - Start by cooperating.
    - If any opponent defected in the previous round, defect once as punishment.
    - After punishing, forgive and return to cooperation.
    - Always defect on the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish = 0
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish > 0:
            self.punish -= 1
            return Action.D
        last_idx = history.round_number - 1
        prev_opponents = history.opponent_actions[last_idx]
        if not all(prev_opponents):
            self.punish = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    Grim‐trigger strategy for the N‐player Public Goods Game.
    Cooperates until any defection is observed, then defects forever.
    Also defects in the final round by backward induction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.triggered = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if not self.triggered:
            if not history.opponent_actions.all():
                self.triggered = True
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        if not self.triggered:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Forgiving Trigger with Endgame Defection:
    - Start with cooperation.
    - If any player defected in the last round, punish with one round of defection, then forgive.
    - Always defect in the final round (endgame defection).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defection_flag = False
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        if self.defection_flag:
            self.defection_flag = False
            return Action.D
        last_my_action = history.my_actions[-1]
        last_opp_actions = history.opponent_actions[-1]
        coop_count_prev = int(last_my_action) + int(np.sum(last_opp_actions))
        if coop_count_prev < n_players:
            self.defection_flag = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Generous Conditional Cooperator:
    - Begins by cooperating to signal goodwill.
    - Tracks fraction of others cooperating in the last round.
    - If others cooperated at rate ≥ alpha, cooperates.
    - If cooperation falls below alpha, defects now and punishes for T future rounds.
    - Always defects in the final round (no future to protect).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_counter = 0
        self.last_coop_frac = 1.0
        self.alpha = 0.8
        self.T = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_completed = history.round_number
        if rounds_completed > 0:
            last_ops = history.opponent_actions[rounds_completed - 1]
            cooperators = int(np.sum(last_ops))
            n_others = self.game_description.n_players - 1
            self.last_coop_frac = cooperators / n_others if n_others > 0 else 1.0
        t = rounds_completed + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        if self.last_coop_frac >= self.alpha:
            return Action.C
        self.punishment_counter = self.T
        return Action.D

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Generous N-Player Tit-for-Tat with Limited Punishment and End-Game Defense:
    - Start by cooperating.
    - Cooperate as long as everyone cooperated last round.
    - Punish any defection with M=2 rounds of defection, then forgive.
    - Defect on the final round to avoid end-game exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_counter = 0
        self.last_round_allC = True
        self.M = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        last_my = history.my_actions[-1]
        last_opps = history.opponent_actions[-1].all()
        self.last_round_allC = bool(last_my and last_opps)
        if t == total_rounds:
            return Action.D
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        if not self.last_round_allC:
            self.punishment_counter = self.M - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Threshold-Reciprocity strategy:
    - Round 1: cooperate
    - Rounds 2…r-1: cooperate if total cooperators in previous round ≥ ceil(n/2), else defect
    - Round r: defect
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T = math.ceil(self.n / 2)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        played = history.round_number
        if played == self.r - 1:
            return Action.D
        coop_self = int(history.my_actions[-1])
        coop_opp = int(np.sum(history.opponent_actions[-1]))
        coop_prev = coop_self + coop_opp
        if coop_prev >= self.T:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Generous one‐round trigger strategy for public goods:
    - Round 1: Cooperate.
    - Rounds 2…r-1:
      • If punishing flag is set: defect, decrement punishment counter, clear flag if expired.
      • Else if everyone (including self) cooperated last round: cooperate.
      • Else: enter punishment mode (for exactly one round) and defect.
    - Round r: Defect (no future enforcement possible).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishing = False
        self.punish_rounds_left = 0
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        if self.punishing:
            action = Action.D
            self.punish_rounds_left -= 1
            if self.punish_rounds_left <= 0:
                self.punishing = False
            return action
        last_idx = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        my_last = int(history.my_actions[last_idx])
        total_coops = opp_coops + my_last
        if total_coops == self.game_description.n_players:
            return Action.C
        else:
            self.punishing = True
            self.punish_rounds_left = self.P
            return Action.D

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    Tiered Trigger with Finite Punishment:
    Start by cooperating. If fewer than (n_players-1) opponents cooperated last round,
    trigger a punishment spell of fixed length P (defect for P rounds), then forgive.
    Always cooperate in the first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.tau = self.n - 1
        self.P = 2
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.C
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_count = int(history.opponent_actions[last_idx].sum())
        if coop_count >= self.tau:
            return Action.C
        else:
            self.punish_timer = self.P
            return Action.D

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    Finite-Horizon Tit-for-Tat (FH-TFT) strategy for the N-player public goods game.
    - Start by cooperating.
    - Defect in the final round.
    - In other rounds, cooperate if everyone cooperated in the previous round; otherwise defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        coop_self = int(history.my_actions[last_idx])
        coop_others = int(history.opponent_actions[last_idx].sum())
        total_cooperators = coop_self + coop_others
        if total_cooperators == self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    Tit-for-tat with end-game defection for the repeated public goods game.
    1. Start by cooperating.
    2. Cooperate if no opponent defected in the previous round.
    3. If any opponent defected in the previous round, defect this round and
       punish one more round.
    4. Unconditionally defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        current_round = completed + 1
        total_rounds = self.game_description.n_rounds
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        if current_round == total_rounds:
            return Action.D
        last_idx = completed - 1
        if last_idx < 0:
            return Action.C
        if not np.all(history.opponent_actions[last_idx]):
            self.punishment_counter = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    N-player Tit-for-Tat with Forgiveness and Endgame Defection.
    - Round 1: Cooperate.
    - Rounds 2..r-1: If any opponent defected in the previous round, defect once then forgive;
      otherwise cooperate.
    - Round r: Always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_flag = False
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.D
        last_idx = history.round_number - 1
        last_opponents = history.opponent_actions[last_idx]
        if np.all(last_opponents):
            return Action.C
        else:
            self.punish_flag = True
            return Action.D

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    1-Round Punish, End-Game Defect strategy for N-player public goods game:
    - Cooperate on first round.
    - Defect in the last round.
    - In rounds 2 to r-1, cooperate if and only if all other players cooperated in the previous round; otherwise defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        coop_count = int(np.sum(history.opponent_actions[last_idx]))
        if coop_count == self.game_description.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    OR-TED: One-Round Trigger with Endgame Defection.
    
    - Start by cooperating.
    - Cooperate if and only if everyone (including self) cooperated in the previous round.
    - If any defection occurred in the last round, defect this round (one-period punishment).
    - Always defect in the final round to avoid endgame exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        my_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx]
        all_cooperated_last = bool(my_last) and bool(np.all(opp_last))
        if not all_cooperated_last:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    Generous Threshold Cooperation (GTC):
    - Start with cooperation.
    - In rounds 2 to r-1, cooperate if total defections last round ≤ f (default f=1), else defect.
    - Defect in the final round by backward induction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.f = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        opponent_last = history.opponent_actions[last_idx]
        num_def_opponents = sum((1 for acted in opponent_last if not acted))
        my_last = history.my_actions[last_idx]
        num_def_self = 0 if my_last else 1
        d = num_def_self + num_def_opponents
        if d <= self.f:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Forgiving Trigger with Endgame Defection:
    - Start by cooperating.
    - If any player (including self) defected in the previous round, punish by defecting for exactly one round.
    - After punishment, forgive and return to cooperation.
    - Defect in the final round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_length = 1
        self.tolerance_threshold = 0
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_index = history.round_number - 1
        last_my_action = history.my_actions[last_index]
        last_opp_actions = history.opponent_actions[last_index]
        defections = (0 if last_my_action else 1) + int(np.sum(~last_opp_actions))
        if defections > self.tolerance_threshold:
            self.punish_counter = self.punish_length
        if current_round == self.game_description.n_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    Forgiving-Unanimity strategy for the N-player Public Goods Game.

    - Cooperate on the first round.
    - If you detect any defection in the previous round, defect exactly once in retaliation,
      then immediately return to cooperation.
    - Always defect in the final round (no future to incentivize cooperation).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_next = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_next = False
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punish_next:
            self.punish_next = False
            return Action.D
        last_my = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1]
        coop_count = int(last_my) + int(np.sum(last_opponents))
        if coop_count == self.game_description.n_players:
            return Action.C
        else:
            self.punish_next = True
            return Action.D

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    Cooperate–Punish–Forgive (CPF) strategy for the repeated N‐player public goods game.
    - Round 1: cooperate.
    - Rounds 2..r−1: if any opponent defected last round, defect once (punish), then forgive.
                   otherwise cooperate.
    - Round r: defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishing = False
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punishing:
            self.punishment_rounds_left -= 1
            action = Action.D
            if self.punishment_rounds_left <= 0:
                self.punishing = False
            return action
        opp_cooperations = int(history.opponent_actions[-1].sum())
        if opp_cooperations < self.game_description.n_players - 1:
            self.punishing = True
            self.punishment_rounds_left = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    One‐Round Trigger‐and‐Forgive Strategy for N‐Player Public Goods Game.
    - Always starts by cooperating.
    - If any other player defected last round, punish by defecting this round
      and schedule exactly one more round of punishment.
    - While in punishment phase, defect and decrement the punishment timer.
    - After punishment phase ends, return to cooperation.
    - Only observes others' actions (ignores own punishment moves).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_timer = 0
        self.last_others_allC = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_timer = 0
            self.last_others_allC = True
            return Action.C
        if self.punish_timer > 0:
            action = Action.D
            self.punish_timer -= 1
        elif self.last_others_allC:
            action = Action.C
        else:
            action = Action.D
            self.punish_timer = 1
        recent = history.opponent_actions[history.round_number - 1]
        self.last_others_allC = bool(np.all(recent))
        return action

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    Tit-for-Tat with one-round punishment for the N-player Public Goods Game.
    Starts by cooperating. If any defection is observed in the previous round,
    defects exactly once as punishment, then returns to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.punish_until_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round <= self.punish_until_round:
            return Action.D
        last_idx = history.round_number - 1
        coop_opponents = int(np.sum(history.opponent_actions[last_idx]))
        coop_self = int(history.my_actions[last_idx])
        total_cooperators = coop_opponents + coop_self
        if total_cooperators < self.n_players:
            self.punish_until_round = current_round
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    Forgiving Threshold Tit-for-Tat (FTfT) for the N-player Public Goods Game.
    - Start by cooperating.
    - In subsequent rounds, if the total cooperators last round >= n-1, cooperate.
    - Otherwise defect with probability 1-f (punish) or cooperate with probability f (forgive).
    - Applies same rule in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.T = self.n - 1
        self.f = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t_completed = history.round_number
        prev_idx = t_completed - 1
        coop_opp = int(np.sum(history.opponent_actions[prev_idx]))
        coop_self = int(history.my_actions[prev_idx])
        M = coop_opp + coop_self
        if M >= self.T:
            return Action.C
        if random.random() < self.f:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    Grim-trigger with one-round endgame defection:
    Cooperate unconditionally until any player defects, then defect forever.
    In the final round (one-shot incentive), defect even if no defection has yet occurred.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        ever_all_cooperated = bool(history.my_actions.all() and history.opponent_actions.all())
        triggered = not ever_all_cooperated
        next_round = history.round_number + 1
        last_round = next_round == self.game_description.n_rounds
        if triggered:
            return Action.D
        elif last_round:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    Conditional cooperator: Start by cooperating, punish a defection with exactly one round of defection,
    then forgive immediately and return to cooperation, and always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        total_players = self.game_description.n_players
        if t == total_rounds:
            return Action.D
        last_round_allC = True
        punishment_active = False
        for round_idx in range(history.round_number):
            self_coop = bool(history.my_actions[round_idx])
            others_coop = int(np.sum(history.opponent_actions[round_idx]))
            coop_count = (1 if self_coop else 0) + others_coop
            allC = coop_count == total_players
            if not punishment_active and (not allC):
                new_punishment = True
            else:
                new_punishment = False
            last_round_allC = allC
            punishment_active = new_punishment
        if punishment_active:
            return Action.D
        if last_round_allC:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Forgiving-Trigger with Last-Round Defection.
    - Cooperate in round 1.
    - Defect unconditionally in the final round.
    - If a “mass defection” (≥ T_defect defectors) occurred last round, defect and punish for P rounds.
    - Otherwise, forgive isolated defections and cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.P = 1
        self.T_defect = 2
        self.punish_remain = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_remain = 0
            return Action.C
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if t == n_rounds:
            return Action.D
        if self.punish_remain > 0:
            self.punish_remain -= 1
            return Action.D
        last_idx = history.round_number - 1
        my_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx]
        cooperators = int(my_last) + int(opp_last.sum())
        defectors = n_players - cooperators
        if defectors >= self.T_defect:
            self.punish_remain = self.P
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    N-player Tit-for-Tat with 1-round Forgiveness (N-TFT-F).
    - Start by cooperating.
    - If everyone else cooperated last round, cooperate.
    - If anyone defected last round, defect once then forgive.
    - Always cooperate in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_flag = False
            return Action.C
        rounds_played = history.round_number
        current_round = rounds_played + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            self.punish_flag = False
            return Action.C
        if self.punish_flag:
            self.punish_flag = False
            return Action.C
        last_opponents = history.opponent_actions[rounds_played - 1]
        coop_others = int(np.sum(last_opponents))
        if coop_others == n_players - 1:
            return Action.C
        else:
            self.punish_flag = True
            return Action.D

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Conditional‐cooperate‐with‐one‐round‐punishment strategy.

    1. Start by cooperating.
    2. If any player (including self) defected in the previous round,
       punish exactly one round by defecting.
    3. Immediately forgive and return to cooperation unless another
       defection occurs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_until_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round <= self.punish_until_round:
            return Action.D
        last_my_action = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1]
        if not last_my_action or not last_opponents.all():
            self.punish_until_round = current_round
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    Group Tit-for-Tat for the Public Goods Game:
    - Round 1: Cooperate.
    - Rounds 2…r-1: Cooperate if and only if everyone (including ourselves)
      cooperated in the previous round; otherwise defect (punish) exactly once.
    - Round r: Defect (no future punishment possible).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        next_round = completed + 1
        if next_round == self.r:
            return Action.D
        last_idx = completed - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        my_coop = int(history.my_actions[last_idx])
        total_coops = opp_coops + my_coop
        if total_coops == self.n:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Limited-Punishment Trigger for N-player Public Goods:
    - Cooperate on round 1.
    - If everyone cooperated last round, cooperate.
    - If any defection detected, defect now and enter L-round punishment.
    - While punishing (pun_remaining > 0), defect and decrement pun_remaining.
    - Unconditionally defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.L = 1
        self.pun_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        if self.pun_remaining > 0:
            self.pun_remaining -= 1
            return Action.D
        last_idx = history.round_number - 1
        self_coop = int(history.my_actions[last_idx])
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        total_coops = self_coop + opp_coops
        if total_coops == self.n_players:
            return Action.C
        else:
            self.pun_remaining = self.L
            return Action.D

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    Forgiving Public‐Goods Tit‐for‐Tat:
      - Start by cooperating.
      - In subsequent rounds, count total defectors in last round.
      - If no one defected, cooperate.
      - If exactly one defected and it wasn’t you, forgive and cooperate.
      - Otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_my = bool(history.my_actions[-1])
        last_opp = history.opponent_actions[-1]
        coop_self = 1 if last_my else 0
        coop_others = int(np.sum(last_opp))
        total_cooperators = coop_self + coop_others
        n = self.game_description.n_players
        defectors = n - total_cooperators
        if defectors == 0:
            return Action.C
        elif defectors == 1 and last_my:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Threshold-Forgiving (TF) for the n-player public goods game.
    Cooperates on first move, defects last move, punishes any defection
    in the previous round for P=1 rounds, then forgives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.P = 1
        self.state = 'Cooperate'
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.state == 'Punish':
            action = Action.D
            self.punish_counter -= 1
            if self.punish_counter <= 0:
                self.state = 'Cooperate'
            return action
        last_idx = completed - 1
        our_last = 1 if history.my_actions[last_idx] else 0
        opp_last = int(np.sum(history.opponent_actions[last_idx]))
        total_coops = our_last + opp_last
        if total_coops < n:
            self.state = 'Punish'
            self.punish_counter = self.P
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    One‐Round Tit‐for‐Tat with Forgiveness in the Final Phase:
      - Start with cooperation.
      - If any opponent defected in the last round, defect this round (P=1 punishment).
      - Forgive immediately (return to cooperation) unless there is a new defection.
      - Always defect in the final round (subgame‐perfect); can inject small ε if desired.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_counter = 0
        self.P = 1
        self.epsilon = 0.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            if random.random() < self.epsilon:
                return Action.C
            else:
                return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_idx = history.round_number - 1
        opp_last = history.opponent_actions[last_idx]
        if np.any(~opp_last):
            self.punish_counter = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Contingent‐cooperate‐with‐forgiveness strategy for the public goods game.
    Starts by cooperating, cooperates if everyone cooperated last round,
    punishes any defection with exactly one defection (then forgives),
    and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_flag = False
            return Action.C
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.D
        last_my = bool(history.my_actions[-1])
        last_opps = history.opponent_actions[-1].sum()
        total_coops = int(last_my) + int(last_opps)
        if total_coops == n:
            return Action.C
        else:
            self.punish_flag = True
            return Action.D

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    Group-level tit-for-tat with one-round forgiveness.
    Start by cooperating. If any other player defected in the prior round,
    punish by defecting for exactly one round, then forgive and return to
    cooperation. Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_index = history.round_number - 1
        others_last = history.opponent_actions[last_index]
        if not others_last.all():
            self.punish_counter = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    One-Round Tit-for-Tat with Endgame Defection:
    - Cooperate on the first round.
    - In rounds 2 through r-1, if anyone defected last round, defect this round (punish for exactly one round),
      otherwise cooperate.
    - Defect unconditionally in the final round to avoid endgame exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_remaining = 0
            return Action.C
        completed = history.round_number
        current_round = completed + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == n_rounds:
            return Action.D
        if completed >= 1:
            last_idx = completed - 1
            my_last = history.my_actions[last_idx]
            opp_last = history.opponent_actions[last_idx]
            total_coop = int(my_last) + int(opp_last.sum())
        else:
            total_coop = n_players
        if total_coop < n_players:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    Forgiving Group Tit-for-Tat (FGTFT):
    - Start with cooperation.
    - If any defection occurred in the previous round, defect once to punish.
    - Then immediately forgive and return to cooperation.
    - In the last round (if not currently in a punishment spell), always cooperate to maximize group payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishmentRoundsLeft = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if self.punishmentRoundsLeft > 0:
            self.punishmentRoundsLeft -= 1
            return Action.D
        if current_round == total_rounds:
            return Action.C
        prev_idx = history.round_number - 1
        self_coop_prev = 1 if history.my_actions[prev_idx] else 0
        opp_coops_prev = int(history.opponent_actions[prev_idx].sum())
        total_coops_prev = self_coop_prev + opp_coops_prev
        if total_coops_prev == self.game_description.n_players:
            return Action.C
        else:
            self.punishmentRoundsLeft = 1
            return Action.D

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    Limited Grim Trigger with Last‐Round Defection:
    Cooperate until any defection is observed, then defect for P = min(2, r-1) consecutive rounds,
    forgive thereafter, and always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.P = min(2, self.n_rounds - 1)
        self.punish_timer = 0
        self.ever_defected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        self_defected = not history.my_actions[last_round]
        opp_defected = np.any(~history.opponent_actions[last_round])
        if (self_defected or opp_defected) and (not self.ever_defected):
            self.ever_defected = True
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        if t == 1:
            return Action.C
        if self.ever_defected:
            self.punish_timer = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    Tit‐for‐tat with one‐round punishment and end‐game defection
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.D
        last_self = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1]
        if not last_self or not last_opponents.all():
            self.punishing = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    Firm‐but‐Fair strategy for the N‐player repeated public‐goods game.
    Starts by cooperating, punishes proportionally to observed defectors,
    forgives after the punishment period, and always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.pun_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.pun_count > 0:
            self.pun_count -= 1
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        opp_defections = int(np.sum(~history.opponent_actions[last_idx]))
        own_defection = 0 if history.my_actions[last_idx] else 1
        D_prev = opp_defections + own_defection
        if D_prev > 0:
            self.pun_count = D_prev - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    Forgiving‐Trigger strategy:
    - Cooperate in the first round.
    - In rounds 2 to r-1:
        * If in punishment mode (state_punish==1), defect once and reset punish flag.
        * Otherwise, if any opponent defected last round, defect now and set punish flag.
        * Else cooperate.
    - Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.state_punish = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.state_punish == 1:
            self.state_punish = 0
            return Action.D
        last_idx = history.round_number - 1
        last_ops = history.opponent_actions[last_idx]
        if not last_ops.all():
            self.state_punish = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    Group Tit‐for‐Tat with Endgame Defection:
    - Cooperate on the first move.
    - In rounds 2..r-1, cooperate if and only if everyone (including yourself) cooperated in the previous round.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        current_round = completed + 1
        if current_round == self.n_rounds:
            return Action.D
        last_idx = completed - 1
        my_last = bool(history.my_actions[last_idx])
        opp_last = history.opponent_actions[last_idx]
        if my_last and opp_last.all():
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    One‐Round Punishing Cooperator:
    - Round 1: cooperate.
    - Rounds 2..r-1: if in punishment phase, defect and count down;
      else if anyone defected last round, set punish_timer=1 and defect;
      otherwise cooperate.
    - Round r: always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_opponents = int(np.sum(history.opponent_actions[last_idx]))
        coop_self = 1 if history.my_actions[last_idx] else 0
        total_cooperators = coop_self + coop_opponents
        n_players = self.game_description.n_players
        n_defect = n_players - total_cooperators
        if n_defect > 0:
            self.punish_timer = 1
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    A simple trigger strategy for the public goods game:
    - Start by cooperating.
    - If any defection is observed, defect for one round (punishment), then forgive.
    - Always defect in the final round to avoid end‐game exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.state = 'Cooperate'
        self.punish_remaining = 0
        self.T_punish = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        R = self.game_description.n_rounds
        if t == R:
            return Action.D
        if self.state == 'Punish':
            if self.punish_remaining > 0:
                self.punish_remaining -= 1
                action = Action.D
                if self.punish_remaining == 0:
                    self.state = 'Cooperate'
                return action
            self.state = 'Cooperate'
        last_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        my_coop = 1 if history.my_actions[last_idx] else 0
        total_coops = opp_coops + my_coop
        if total_coops < self.game_description.n_players:
            self.state = 'Punish'
            self.punish_remaining = self.T_punish
            self.punish_remaining -= 1
            action = Action.D
            if self.punish_remaining == 0:
                self.state = 'Cooperate'
            return action
        return Action.C

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    Proportional Collective TFT with Last-Round Defection.

    - Cooperate on first round.
    - In rounds 2..r-1, if in a punishment phase, defect and decrement timer.
      Otherwise, if any defections occurred last round, defect and set punishment
      timer proportional to the number of defectors; if no defections, cooperate.
    - Defect in the final round to avoid sucker’s payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_completed = history.round_number
        total_rounds = self.game_description.n_rounds
        if rounds_completed + 1 == total_rounds:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_opp_actions = history.opponent_actions[-1]
        coop_opp = int(last_opp_actions.sum())
        my_last = int(history.my_actions[-1])
        total_coop = coop_opp + my_last
        n = self.game_description.n_players
        def_count = n - total_coop
        if def_count == 0:
            return Action.C
        else:
            self.punish_timer = def_count - 1
            return Action.D

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    Generous Trigger with Limited Retaliation:
    Start by cooperating, punish any defection for up to M rounds,
    then forgive and return to cooperation, and always cooperate in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.M = 1
        self.punish_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        if t == n_rounds:
            return Action.C
        if self.punish_count > 0:
            self.punish_count -= 1
            return Action.D
        prev_idx = history.round_number - 1
        last_my = history.my_actions[prev_idx]
        last_ops = history.opponent_actions[prev_idx]
        full_coop_last = bool(last_my and last_ops.all())
        if not full_coop_last:
            remaining_rounds = n_rounds - t
            self.punish_count = min(self.M, remaining_rounds)
            if self.punish_count > 0:
                self.punish_count -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    Forgiving Tit-for-Tat (FTfT) for the N-player public goods game.
    Nice: cooperates first. Provocable: punishes any defection with one round of D.
    Forgiving: immediately returns to C after a single punishment.
    Last round: defects (no future to sustain cooperation).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.C
        last_index = history.round_number - 1
        coop_opp = int(np.sum(history.opponent_actions[last_index]))
        coop_self = int(history.my_actions[last_index])
        total_coop_last = coop_opp + coop_self
        if total_coop_last == self.game_description.n_players:
            return Action.C
        else:
            self.punish_flag = True
            return Action.D

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    Conditional-cooperation strategy for the N-Player Public Goods Game:
    1. Cooperate in the first round.
    2. In rounds 2 to r-1, if the total cooperators in the previous round
       (including oneself) is at least ceil(n/2), then cooperate; otherwise defect.
    3. Defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T = math.ceil(self.n / 2)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_idx = history.round_number - 1
        coop_self = 1 if history.my_actions[last_idx] else 0
        coop_opp = int(np.sum(history.opponent_actions[last_idx]))
        coop_prev = coop_self + coop_opp
        if coop_prev >= self.T:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Aggressive Opportunistic Exploiter for the N-player Public Goods Game.
    Phases: PROBE, MONITOR, EXPLOIT, PUNISH.
    - Probe once, then monitor for unanimous cooperation or free-riding.
    - After W consecutive unanimous cooperations, switch to permanent defection (EXPLOIT).
    - If we defected and others cooperated, switch to permanent defection (PUNISH).
    - Always defect in the final round.
    """
    PROBE = 'PROBE'
    MONITOR = 'MONITOR'
    EXPLOIT = 'EXPLOIT'
    PUNISH = 'PUNISH'

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.phase = self.PROBE
        self.window_success = 0
        r = self.game_description.n_rounds
        self.W = max(2, math.floor(r / 4))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.phase = self.MONITOR
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.phase == self.MONITOR:
            others_last = history.opponent_actions[-1]
            coop_others = int(np.sum(others_last))
            we_cooperated = bool(history.my_actions[-1])
            if not we_cooperated and coop_others > 0:
                self.phase = self.PUNISH
                return Action.D
            if we_cooperated and coop_others == self.game_description.n_players - 1:
                self.window_success += 1
                if self.window_success >= self.W:
                    self.phase = self.EXPLOIT
                    return Action.D
                else:
                    return Action.C
            self.window_success = 0
            return Action.C
        if self.phase in (self.EXPLOIT, self.PUNISH):
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    Aggressive Exploiter for the N-Player Public Goods Game.

    - Cooperates unconditionally in round 1 to build reputation.
    - Continues to cooperate for m = ceil(r/3) rounds unless any defection is observed.
    - If any player (including self) defects in rounds 1…m, triggers permanent defection (grim trigger).
    - If no defections in the first m rounds, switches to defection for the remaining rounds to exploit cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(self.game_description.n_rounds / 3)
        self.sawDefection = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if not history.my_actions.all() or not history.opponent_actions.all():
            self.sawDefection = True
        t = history.round_number + 1
        if self.sawDefection:
            return Action.D
        if t <= self.m:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    Always defect (D) in every round of the N-player public goods game.
    This maximally aggressive All-D strategy is the unique subgame-perfect
    equilibrium for a finitely repeated public goods game with k < n.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Aggressive Lure-and-Exploit strategy:
    - Start by cooperating to lure others.
    - Track consecutive low-cooperation rounds (L_fail).
    - When all opponents cooperated once, defect exactly once to exploit.
    - After exploit or two consecutive failures, lock into defection.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.E = 0
        self.L_fail = 0
        self.max_exploits = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        others_coops_last = int(np.sum(history.opponent_actions[-1]))
        if self.E < self.max_exploits and others_coops_last >= self.n - 1:
            self.E += 1
            return Action.D
        if others_coops_last <= 1:
            self.L_fail += 1
        else:
            self.L_fail = 0
        if self.E == 0 and self.L_fail < 2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    Probe‐and‐Punish Defector for the repeated public goods game.
    Never sustains cooperation. Uses a small probing probability ε
    to test for cooperators; once any cooperator is detected,
    switches to permanent defection. Always defects in the first
    and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 0.05
        self.exploited = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.exploited:
            return Action.D
        prev_index = history.round_number - 1
        coop_count_prev = int(history.opponent_actions[prev_index].sum())
        if coop_count_prev >= 1:
            self.exploited = True
            return Action.D
        elif random.random() < self.epsilon:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Aggressive Exploiter for the public goods game.
    Probes for cooperators, then defects relentlessly once one is found.
    Always defects in the final round.
    """
    INVEST_ROUNDS = 1
    TEST_PROB = 0.1
    MAX_PROBE_ROUNDS = 3

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.phase = 'PROBE'
        self.probe_count = 0
        self.saw_cooperator = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
            if self.phase == 'PROBE' and history.round_number >= 1:
                last_ops = history.opponent_actions[history.round_number - 1]
                if last_ops.any():
                    self.saw_cooperator = True
                    self.phase = 'EXPLOIT'
        if t == self.game_description.n_rounds:
            return Action.D
        if self.phase == 'EXPLOIT':
            return Action.D
        if t <= self.INVEST_ROUNDS:
            return Action.C
        if self.probe_count < self.MAX_PROBE_ROUNDS:
            if random.random() < self.TEST_PROB:
                action = Action.C
            else:
                action = Action.D
            self.probe_count += 1
            return action
        return Action.D

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    Aggressive Seed‐and‐Exploit (ASE) strategy for the N‐Player Public Goods Game.
    Never cooperates in round 1 or the last two rounds. 
    Seeds cooperation sparingly, then defects for E rounds if seeding succeeds,
    or defects for S rounds if it fails, before trying to seed again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.E = 2
        self.M = 2
        self.S = 3
        self.exploitation_counter = 0
        self.skip_seeding = 0
        self.last_seed_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t_prev = completed
        t_current = completed + 1
        r = self.game_description.n_rounds
        if self.last_seed_round == t_prev and self.last_seed_round > 0:
            coop_opponents = int(np.sum(history.opponent_actions[t_prev - 1]))
            my_coop = int(history.my_actions[t_prev - 1])
            total_cooperators = coop_opponents + my_coop
            if total_cooperators >= self.M:
                self.exploitation_counter = self.E
            else:
                self.skip_seeding = self.S
        if t_current == 1 or t_current > r - 2:
            return Action.D
        if self.exploitation_counter > 0:
            self.exploitation_counter -= 1
            return Action.D
        if self.skip_seeding > 0:
            self.skip_seeding -= 1
            return Action.D
        self.last_seed_round = t_current
        return Action.C

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Single-Test Exploiter (STE):
    Defects in round 1, cooperates once in round 2 to test for naïve cooperators,
    then defects unconditionally for the remainder of the game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tested = False
        self.found = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            if r == 2:
                return Action.D
            return Action.D
        t_next = history.round_number + 1
        if not self.tested and history.round_number >= 2:
            coop_others = int(history.opponent_actions[1].sum())
            coop_self = int(history.my_actions[1])
            total_coops = coop_self + coop_others
            self.tested = True
            self.found = total_coops - 1 >= 1
        if r == 2:
            return Action.D
        if t_next == 1:
            return Action.D
        if t_next == 2 and (not self.tested):
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    Selective Exploiter:
    - Defects in the first round to gather a baseline.
    - In the last two rounds, always defects (endgame proofing).
    - Otherwise, if a majority of opponents cooperated in the previous round,
      defect to freeride on their contributions; if they cooperated too little,
      cooperate to nudge them into an exploitable zone.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.E = math.ceil((self.n - 1) / 2)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t >= self.r - 1:
            return Action.D
        last_idx = history.round_number - 1
        coop_others = int(history.opponent_actions[last_idx].sum())
        if coop_others >= self.E:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    "Ruthless Enforcer" for the repeated N-player public goods game.
    - α: punishment scale (default = 2)
    - Defects first and last round.
    - If any opponent defected last round, defects and punishes for α * (# defectors) - 1 more rounds.
    - Only cooperates when all opponents cooperated last round (to be sole defector).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish_timer = 0
        self.alpha = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        n = self.game_description.n_players
        if t == r:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_idx = history.round_number - 1
        last_actions = history.opponent_actions[last_idx]
        def_prev = int(np.sum(~last_actions))
        coop_prev = int(np.sum(last_actions))
        if def_prev > 0:
            self.punish_timer = self.alpha * def_prev - 1
            return Action.D
        if coop_prev == n - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    Aggressive finite‐state search‐and‐exploit strategy for the repeated public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.phase = 'SEARCH'
        self.coop_seen = False
        self.T_search = max(1, math.ceil(math.log2(self.n_rounds)))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.n_rounds:
            self.phase = 'END'
            return Action.D
        if self.phase == 'SEARCH':
            if history.round_number >= 1:
                last_ops = history.opponent_actions[history.round_number - 1]
                if last_ops.any():
                    self.coop_seen = True
                    self.phase = 'EXPLOIT'
            if self.phase == 'SEARCH' and history.round_number >= self.T_search:
                self.phase = 'EXPLOIT'
        if self.phase == 'SEARCH':
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    Always-Defect Public Goods strategy: defect (D) every round,
    ignoring all history and never cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Aggressive Prospector strategy:
    - Round 1: Defect.
    - Rounds 2…r–1: If any opponent has ever cooperated, defect forever.
      Otherwise (no coop seen yet), probe with small probability p_test by cooperating;
      else defect.
    - Round r: Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_test = 0.1
        self.detected_cooperator = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if not self.detected_cooperator and history.opponent_actions.any():
            self.detected_cooperator = True
        completed = history.round_number
        next_round = completed + 1
        total_rounds = self.game_description.n_rounds
        if next_round == total_rounds:
            return Action.D
        if self.detected_cooperator:
            return Action.D
        if random.random() < self.p_test:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    Exploit‐and‐Defect strategy for the N‐Player Public Goods Game.
    Probes for cooperators in round 1 (and round 2 if rewarded), then defects permanently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if r == 1:
            return Action.D
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == 2:
            opp_coops_round1 = int(np.sum(history.opponent_actions[0]))
            if opp_coops_round1 >= 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Aggressive Public-Goods Exploiter strategy:
    - Cooperates in the first round to avoid isolation.
    - Defects in the last round unconditionally.
    - Uses a moving window of the last m rounds to compute the average cooperation among opponents:
        * If avg >= up_coop_rate: defect (exploit over-cooperation)
        * If avg <= low_coop_rate: cooperate (spark cooperation)
        * Else: defect (fallback)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.up_coop_rate = 0.5
        self.low_coop_rate = 0.3
        self.window = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds - 1:
            return Action.D
        m_t = min(self.window, current_round)
        start = current_round - m_t
        recent = history.opponent_actions[start:current_round, :]
        total_coop = np.sum(recent)
        denom = m_t * (self.game_description.n_players - 1)
        avg_coop = total_coop / denom if denom > 0 else 0.0
        if avg_coop >= self.up_coop_rate:
            return Action.D
        elif avg_coop <= self.low_coop_rate:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Aggressive Extractor for the N-Player Public Goods Game.
    Detection phase: cooperate for K=min(3,r-1) rounds and count opponents' cooperations.
    Exploitation phase: build a target set T of opponents whose cooperation rate ≥ θ=0.66,
    then defect whenever at least m=1 of them cooperated last round; otherwise pretend to
    cooperate to lure them. Always defect in the final round. r=1: immediate defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.r = game_description.n_rounds
        self.K = min(3, self.r - 1) if self.r > 1 else 0
        self.theta = 0.66
        self.m = 1
        self.coop_count = [0] * (self.n_players - 1)
        self.T = []

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            if self.r == 1:
                return Action.D
            return Action.C
        if self.r == 1:
            return Action.D
        t = history.round_number + 1
        if 1 <= history.round_number <= self.K:
            last_idx = history.round_number - 1
            for opp in range(self.n_players - 1):
                if history.opponent_actions[last_idx, opp]:
                    self.coop_count[opp] += 1
        if t == self.K + 1:
            if self.K > 0:
                self.T = [opp for opp in range(self.n_players - 1) if self.coop_count[opp] / self.K >= self.theta]
            else:
                self.T = []
        if t <= self.K:
            return Action.C
        if t == self.r:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_coops = 0
        for opp in self.T:
            if history.opponent_actions[prev_round_idx, opp]:
                prev_coops += 1
        if prev_coops >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    Aggressive defector with occasional probes. 
    Probes (cooperates) on round 1 and every L rounds thereafter to detect any cooperators.
    Once any opponent ever cooperates on a probe, switches to pure defection (exploitation mode).
    Always defects in the final T_end rounds (end‐game defection).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploitation_mode = False
        self.L = 5
        self.T_end = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            last_round = history.round_number
            if not self.exploitation_mode and (last_round == 1 or (last_round - 1) % self.L == 0):
                if history.opponent_actions[last_round - 1].any():
                    self.exploitation_mode = True
            t = last_round + 1
        r = self.game_description.n_rounds
        if t > r - self.T_end:
            return Action.D
        if self.exploitation_mode:
            return Action.D
        if t == 1 or (t - 1) % self.L == 0:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    One-Shot Lure Defector: Cooperate in round 1, then defect every subsequent round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Aggressive Exploiter (AE) for the repeated public goods game.
    - First round: cooperate to test.
    - Last two rounds: always defect.
    - Intermediate rounds: if any opponent cooperated last round, defect; otherwise cooperate to test.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round >= total_rounds - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators = int(history.opponent_actions[last_round_idx].sum())
        if cooperators >= 1:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Aggressive Exploiter for the N-player Public Goods Game.
    Probes for S = min(3, floor(r/3)) rounds by cooperating,
    sums opponents' cooperations; if they cooperated enough,
    switches to permanent defection. Otherwise defects throughout.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.S = min(3, math.floor(self.r / 3))
        self.total_others_coop = 0
        self.exploitable = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            next_round = 1
            if self.r <= self.S:
                return Action.D
            if next_round <= self.S:
                return Action.C
            return Action.D
        last_round = history.round_number
        if 1 <= last_round <= self.S and self.r > self.S:
            cooperators = int(np.sum(history.opponent_actions[last_round - 1]))
            self.total_others_coop += cooperators
            if last_round == self.S:
                threshold = self.S * (self.n - 1) / 2
                self.exploitable = self.total_others_coop >= threshold
        next_round = history.round_number + 1
        if self.r <= self.S:
            return Action.D
        if next_round <= self.S:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    Aggressive Exploiter (AE):
    - Defect first round.
    - For rounds 2 to r - T_punish:
      * If anyone cooperated in the previous round, defect.
      * If everyone defected in the previous round, cooperate to reseed cooperation.
    - For the final T_punish rounds, always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T_punish = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round > total_rounds - self.T_punish:
            return Action.D
        last_idx = history.round_number - 1
        opp_cooperators = int(np.sum(history.opponent_actions[last_idx]))
        my_last = int(history.my_actions[-1])
        total_cooperators = opp_cooperators + my_last
        if total_cooperators >= 1:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Aggressive memory-one strategy for the repeated n-player public goods game.
    - Always defects in round 1 and the final round.
    - If any opponent cooperated in the previous round, defects to exploit them.
    - If everyone defected in the previous round, cooperates with small probability p_probe to probe.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_probe = 0.1
        self.exploited_before = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.exploited_before = False
            return Action.D
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        if last_idx >= 0 and history.opponent_actions[last_idx].any():
            self.exploited_before = True
            return Action.D
        if random.random() < self.p_probe:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    Aggressive All-Defect (AAD) strategy: always defects (Action.D) in every round
    of an n-player public goods game. There is no history dependence; the strategy
    never cooperates, avoiding exploitation and free-riding on any cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Aggressive-Defector-With-Pulse-Tests:
    Defect every round except for a single “pulse” cooperation if no one else has cooperated
    in the recent TestInterval to probe for naive cooperators. If any opponent cooperates
    alongside that pulse, switch to permanent exploitation (always defect). Also defect
    unconditionally in the last EndgameLength rounds to avoid end‐game vulnerability.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.n = game_description.n_players
        self.TestInterval = max(5, math.floor(self.r / 4))
        self.EndgameLength = min(3, self.r - 1)
        self.exploited = False
        self.pulse_done = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > 0:
            last = history.round_number - 1
            if history.my_actions[last] and np.any(history.opponent_actions[last]):
                self.exploited = True
        t = 1 if history is None else history.round_number + 1
        if t > self.r - self.EndgameLength:
            return Action.D
        if self.exploited:
            return Action.D
        if not self.pulse_done:
            seen = False
            length = 0 if history is None else history.round_number
            start = max(0, length - self.TestInterval)
            for idx in range(start, length):
                if np.any(history.opponent_actions[idx]):
                    seen = True
                    break
            if not seen:
                self.pulse_done = True
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    Always-defect strategy: defects in every round, from the first to the last.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    Aggressive‐extortion (EXTORT) strategy for the N‐player public goods game.
    Phases:
    - Round 1: Cooperate to appear nice.
    - Rounds 2 to r-1: Defect if any cooperators appeared last round (last_sum > T)
      or if we've cooperated consecutively ≥ L; otherwise cooperate.
    - Round r: Always defect.
    T = 1 (exploit threshold), L = min(3, r-2) (re‐entry limit).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = 1
        r = game_description.n_rounds
        self.L = min(3, r - 2) if r > 2 else 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = completed - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        my_last = int(history.my_actions[last_idx])
        last_sum = opp_coops + my_last
        consecC = 0
        for act in reversed(history.my_actions):
            if act:
                consecC += 1
            else:
                break
        if last_sum > self.T or consecC >= self.L:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Trust-Breaker strategy for the N-player public goods game.
    - Probe cooperators in the first M rounds by cooperating.
    - In the middle phase, defect if any opponent cooperated last round, else probe by cooperating.
    - Defect unconditionally in the last E rounds to avoid endgame exploitation.
    - For very short games (r <= 3), cooperate in round 1 then defect thereafter.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.M = min(2, self.r - 2)
        self.E = min(2, self.r - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if self.r <= 3:
            if t == 1:
                return Action.C
            else:
                return Action.D
        if t <= self.M:
            return Action.C
        if t > self.r - self.E:
            return Action.D
        last_idx = completed - 1
        coop_prev = int(history.opponent_actions[last_idx].sum())
        if coop_prev >= 1:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    Bully-Probe strategy for the N-Player Public Goods Game.
    - Probe for cooperators in the first H rounds by cooperating.
    - If the game is too short (r <= H + B), always defect.
    - After probing, exploit (i.e., defect) unconditionally for the rest of the game,
      including the final B endgame rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.H = 2
        self.B = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        H = self.H
        B = self.B
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if r <= H + B:
            return Action.D
        if t <= H:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    Aggressive exploiter strategy for N-player Public Goods Game.
    
    Phases:
    - Warm-up (rounds 1…T_w): cooperate only if all others cooperated in previous round.
    - Harvest (rounds T_w+1…r): defect unconditionally.
    - Abort warm-up immediately if any defection is observed.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T_w = min(math.ceil(self.r / 4), self.r - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if t > self.T_w:
            return Action.D
        if t == 1:
            return Action.C
        else:
            prev_idx = t - 2
            opp_coops = history.opponent_actions[prev_idx].sum()
            my_coop = history.my_actions[prev_idx]
            total_coops = int(opp_coops) + int(my_coop)
            if total_coops < self.n - 1:
                return Action.D
            return Action.C

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    Aggressive public goods exploiter:
    - Never rewards cooperators; always defects if anyone cooperated last round.
    - If everyone defected in the previous round, occasionally "probes" by cooperating
      every M = floor(sqrt(r)) rounds to test for new cooperators.
    - Always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        r = self.n_rounds
        if t == r:
            return Action.D
        last_round_idx = completed - 1
        coopers_last = int(history.opponent_actions[last_round_idx].sum())
        if coopers_last >= 1:
            return Action.D
        M = math.floor(math.sqrt(r))
        if M < 1:
            M = 1
        if (t - 1) % M == 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    Aggressive Defector with Opportunistic Testing (ADoT):
    - Always defects except for small-probability probes (p_test) in an all-defection environment.
    - Never forgives any cooperation: if any player (including self) cooperated last round, defect forever.
    - Guaranteed defection in the first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_test = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        last_my = history.my_actions[-1]
        last_ops = history.opponent_actions[-1]
        last_round_had_C = bool(last_my) or bool(np.any(last_ops))
        if last_round_had_C:
            return Action.D
        elif random.random() < self.p_test:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    Aggressive Defector with Occasional Probing:
    - Always defects on first and last round.
    - If any opponent cooperated last round, probes by cooperating with probability alpha.
    - Otherwise, always defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.alpha = 0.1
        self.phi = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        coop_count = int(np.sum(history.opponent_actions[last_idx]))
        if coop_count > self.phi:
            if random.random() < self.alpha:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Aggressive Defector‐Predator strategy:
    - Start in 'probing' state and cooperate for the first m rounds (default m=1).
    - If any opponent cooperates in a probing round, switch to 'exploit' and defect forever.
    - If no one ever cooperates after m probes, switch to 'exploit' thereafter.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.state = 'probing'
        self.m = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.state == 'probing':
            last_round = history.round_number
            if last_round > 0:
                last_ops = history.opponent_actions[last_round - 1]
                if last_ops.any():
                    self.state = 'exploit'
                elif last_round >= self.m:
                    self.state = 'exploit'
        next_round = history.round_number + 1
        if next_round == self.game_description.n_rounds:
            return Action.D
        if self.state == 'exploit':
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    Aggressive Smother: test‐and‐punish defector for N‐Player Public Goods.
    Occasionally probes by cooperating every test_interval rounds. If any other
    player cooperated on a probe, switches into a punish phase of defections for
    punish_length rounds. Always defects on the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        r = game_description.n_rounds
        self.test_interval = max(3, math.floor(r / 10))
        self.punish_length = max(3, math.floor(r / 5))
        self.last_test_round = 0
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
            if history.round_number > 0:
                last_round = history.round_number
                if self.last_test_round == last_round:
                    opp_actions = history.opponent_actions[last_round - 1]
                    if opp_actions.any():
                        self.punish_timer = self.punish_length
        if t == self.game_description.n_rounds:
            if self.punish_timer > 0:
                self.punish_timer -= 1
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        if t - self.last_test_round >= self.test_interval:
            self.last_test_round = t
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Opportunistic Exploiter for the N‐Player Public Goods Game.
    - Always defect in round 1 and the final round.
    - If in the previous round all opponents cooperated, seize the opportunity by defecting next and
      thereafter mark 'exploited' to defect forever.
    - If in the previous round all opponents defected, perform up to M_test_limit cooperative probes,
      then defect thereafter when in all‐defect history.
    - In any mixed‐cooperation history, always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.M_test_limit = 2
        self.tests_done = 0
        self.exploited = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.exploited:
            return Action.D
        last_opponent_actions = history.opponent_actions[-1]
        opponents_coop = int(np.sum(last_opponent_actions))
        if opponents_coop == self.game_description.n_players - 1:
            self.exploited = True
            return Action.D
        if opponents_coop == 0 and self.tests_done < self.M_test_limit:
            self.tests_done += 1
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    Aggressive 'Test-and-Exploit' strategy for the N-player Public Goods Game.
    Default behavior is to defect each round, except every L_coop_test rounds
    (after a streak of pure defection) it plays a one-shot cooperate to probe
    opponents.  If nobody ever reciprocates during that test, it immediately
    returns to full defection.  Always defects in the first and final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.L_coop_test = 3
        self.last_test_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        T = self.game_description.n_rounds
        if t == T:
            return Action.D
        if t > self.L_coop_test and t - self.last_test_round > self.L_coop_test:
            start = t - self.L_coop_test - 1
            end = t - 1
            recent_actions = history.my_actions[start:end]
            if not recent_actions.any():
                self.last_test_round = t
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    Aggressive Bait-and-Switch (ABS) public goods strategy.
    Probes with small cooperations (ε) to detect responders, then defects permanently (except forced last‐round defection).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.epsilon = 0.05
        self.Dmin = 2
        self.foundCooperators = False
        self.detectionCount = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C if random.random() < self.epsilon else Action.D
        last_round = history.round_number - 1
        if last_round >= 0:
            my_last = history.my_actions[last_round]
            others_last = history.opponent_actions[last_round]
            if my_last and int(others_last.sum()) >= 1:
                self.detectionCount += 1
                if self.detectionCount >= self.Dmin:
                    self.foundCooperators = True
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.foundCooperators:
            return Action.D
        return Action.C if random.random() < self.epsilon else Action.D

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Aggressive Contingent Defection (ACD) for N-player Public Goods Game.
    - Signal cooperation in round 1.
    - If any defection seen, enter punishment: defect for P_base rounds,
      extend by P_inc if defections occur during punishment.
    - After punishment expires, forgive and cooperate until (re)triggered.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_remaining = 0
        self.P_base = 2
        self.P_inc = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        last_my = history.my_actions[-1]
        last_ops = history.opponent_actions[-1]
        last_defection = not bool(last_my) or bool(np.any(~last_ops))
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            if last_defection:
                self.punishment_remaining += self.P_inc
            return Action.D
        if t == 1:
            return Action.C
        if last_defection:
            self.punishment_remaining = self.P_base - 1
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    Aggressive Free-Rider w/ Limited Testing:
    - Cooperate in round 1 to probe.
    - Defect in the last round for end‐game advantage.
    - In intermediate rounds, defect if any opponent cooperated last round.
    - If nobody cooperated last round, test cooperation once; afterwards defect permanently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tested = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        if prev_idx >= 0:
            prev_coops = int(history.opponent_actions[prev_idx].sum())
        else:
            prev_coops = 0
        if prev_coops >= 1:
            return Action.D
        if not self.tested:
            self.tested = True
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Aggressive Luring‐and‐Exploiting strategy for the N‐Player Public Goods Game.

    1) Round 1: cooperate to build reputation.
    2) Rounds 2..r-1:
       - If already punished, defect permanently.
       - Else if last round's total cooperators ≥ profit_threshold_m, cooperate.
       - Otherwise, enter punishment mode (punished=True) and defect.
    3) Round r: always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punished = False
        n = game_description.n_players
        k = game_description.k
        self.profit_threshold_m = math.floor(n / k) + 1
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.punished:
            return Action.D
        last_my = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1]
        coop_last = int(last_my) + int(np.sum(last_opponents))
        if coop_last >= self.profit_threshold_m:
            return Action.C
        else:
            self.punished = True
            return Action.D

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Aggressive “Lure‐and‐Punish” strategy for the N‐Player Public Goods Game.
    - First round: Defect
    - Last round: Defect
    - Otherwise:
      • If any opponent cooperated in the previous round → Defect (punish)
      • If all opponents defected in the previous round → Cooperate (lure)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        if t == n_rounds:
            return Action.D
        last_actions = history.opponent_actions[history.round_number - 1]
        last_sum = int(last_actions.sum())
        if last_sum > 0:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Aggro-Exploiter Strategy for the N-Player Public Goods Game.
    Memory-1 aggressive policy:
    - Always defect on the first round.
    - Always defect in the last two rounds (no future to punish).
    - In middle rounds, if the previous round was unanimous cooperation
      and we haven't "baited" yet, cooperate exactly once to lure full
      cooperation, then defect thereafter.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.we_baited = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t >= r - 1:
            return Action.D
        last_self = history.my_actions[-1]
        last_opp = history.opponent_actions[-1]
        total_coops = int(last_self) + int(np.sum(last_opp))
        if total_coops == n and (not self.we_baited):
            self.we_baited = True
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Aggressor‐Grim‐Half strategy for the N‐player Public Goods Game.
    - Cooperate in round 1 to build trust.
    - Always defect in the final round.
    - If any opponent ever defects, switch to permanent defection (grim trigger).
    - In rounds after ⌊r/2⌋ (except the last), exploit cooperators by defecting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.punished:
            return Action.D
        last_round_idx = history.round_number - 1
        recent_opponent_actions = history.opponent_actions[last_round_idx]
        if not recent_opponent_actions.all():
            self.punished = True
            return Action.D
        if t > math.floor(self.r / 2):
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    Aggressive Exploiter: Cooperate for a brief signal phase, then defect permanently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        r = game_description.n_rounds
        self.K = min(2, r - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t <= self.K:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    One-Bait Aggressor:
    - Always defects in first round and in the last two rounds.
    - In rounds 2 through r-2, if all opponents cooperated in the previous round
      and the bait has not yet been used, cooperates exactly once (sends a “bait”),
      then defects in all subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.used_bait = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t >= self.r - 1:
            return Action.D
        prev_idx = history.round_number - 1
        opp_coop_count = int(history.opponent_actions[prev_idx].sum())
        if not self.used_bait and opp_coop_count >= self.n - 1:
            self.used_bait = True
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    Ironwall Defector strategy: never cooperates. In every round (including the first
    and the final), it always plays Defect (Action.D), regardless of history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Aggressive Cooperate‐then‐Exploit strategy:
    1. Cooperate for the first M = ceil(r/3) rounds unless anyone defects.
       If any defection is observed in those rounds, set abort=True and defect forever.
    2. After round M and before the last round, always defect (exploit phase).
    3. Always defect in the final round (r).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.M = math.ceil(self.r / 3)
        self.abort = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.abort:
            return Action.D
        if t <= self.M:
            if history.opponent_actions[:t - 1].all():
                return Action.C
            else:
                self.abort = True
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    Aggressive Tester-Punisher (ATP):
    Probes for cooperators every T rounds, exploits any cooperation once,
    then punishes for P rounds. Always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_rounds = game_description.n_rounds
        self.T = 5
        self.P = 3
        self.punish_timer = 0
        self.last_test_was_success = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_done = history.round_number
        t_cur = rounds_done + 1
        t_prev = rounds_done
        if t_prev > 0 and t_prev % self.T == 1:
            coop_count = int(sum(history.opponent_actions[t_prev - 1]))
            self.last_test_was_success = coop_count >= 1
        if t_cur == self.n_rounds:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        if t_cur % self.T == 1:
            return Action.C
        if self.last_test_was_success:
            self.last_test_was_success = False
            self.punish_timer = self.P
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Aggressive exploit strategy for the repeated N-player public goods game.
    - Probes by cooperating on round 1 and then every T_probe rounds.
    - Always defects otherwise.
    - If any opponent cooperated in the previous round, enters a punish/exploit mode
      of length E (defects each round) to harvest private gains, then resumes probing.
    - Always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T_probe = 5
        self.E = game_description.n_rounds
        self.exploit_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.exploit_timer > 0:
            self.exploit_timer -= 1
            return Action.D
        last_ops = history.opponent_actions[history.round_number - 1]
        if last_ops.sum() > 0:
            self.exploit_timer = self.E
            return Action.D
        if t % self.T_probe == 0:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    Ruthless Defector: Always defects in every round, exploiting any cooperators
    and never relenting or forgiving.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Aggressive Lure-and-Exploit strategy for the n-player repeated public goods game.
    Alternates between brief cooperative lures and exploitation via defection,
    with a regeneration mechanism and end-game defection in the last two rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.L_max = min(3, max(0, self.r - 2))
        self.E_regen = 4
        if self.L_max > 0:
            self.mode = 'lure'
        else:
            self.mode = 'exploit'
        self.lure_count = 0
        self.exploit_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t >= self.r - 1:
            return Action.D
        if self.mode == 'lure':
            action = Action.C
            self.lure_count += 1
            if self.lure_count >= self.L_max:
                self.mode = 'exploit'
                self.exploit_count = 0
            return action
        action = Action.D
        self.exploit_count += 1
        if self.exploit_count >= self.E_regen and history is not None:
            no_coops = True
            for tau in range(t - self.exploit_count, t):
                idx = tau - 1
                my_act = history.my_actions[idx]
                opp_coops = np.sum(history.opponent_actions[idx])
                if int(my_act) + int(opp_coops) != 0:
                    no_coops = False
                    break
            if no_coops:
                self.mode = 'lure'
                self.lure_count = 0
        return action

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    Aggro-Extort-Punish (AEP) strategy for the n-Player Public Goods Game.
    Memory-one strategy that lures cooperators, exploits full cooperation,
    punishes widespread defection permanently, and always defects in the last two rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold_high = self.n - 1
        self.threshold_low = (self.n - 1) // 2
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t >= self.r - 1:
            return Action.D
        if self.punish_flag:
            return Action.D
        prev_index = history.round_number - 1
        prev_actions = history.opponent_actions[prev_index]
        prev_C_others = int(prev_actions.sum())
        if prev_C_others == self.threshold_high:
            return Action.D
        if prev_C_others <= self.threshold_low:
            self.punish_flag = True
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Aggressive Extorter:
    - Cooperate in the first round to build trust.
    - If in the previous round everyone cooperated, cooperate with probability 1 - ε,
      otherwise defect to exploit the group.
    - Defect in all other cases.
    - Always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = min(0.05, 1.0 / game_description.k)
        self.lastFullCoop = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        prev_idx = history.round_number - 1
        total_coop = int(history.my_actions[prev_idx]) + int(np.sum(history.opponent_actions[prev_idx]))
        if total_coop == self.game_description.n_players:
            self.lastFullCoop = True
        else:
            self.lastFullCoop = False
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        if self.lastFullCoop:
            if random.random() < 1.0 - self.epsilon:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Aggressive Defector: always defects in every round, never cooperates,
    to maximize own payoff and punish the group.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    Everlasting Defection:
    Defect in every round regardless of history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Probing-Then-Exploit (PTE) strategy for the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.p = math.ceil(math.sqrt(self.r))
        self.w = min(5, max(1, self.r - 1))
        self.tau = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if self.r <= 3:
            return Action.D
        if t == self.r:
            return Action.D
        if t <= self.p:
            return Action.C
        completed = history.round_number
        start_round = max(1, t - self.w)
        idx_start = start_round - 1
        idx_end = completed
        recent = history.opponent_actions[idx_start:idx_end]
        total_coop = int(np.sum(recent))
        window_length = completed - idx_start
        coop_rate = total_coop / ((self.n - 1) * window_length)
        if coop_rate >= self.tau:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    Aggressive public‐goods strategy:
    - Round 1: defect.
    - Rounds 2…r–1: if anyone else cooperated last round, defect to exploit;
      otherwise (all‐D last round) cooperate every Lth round as a probe.
    - Final round: defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.L = 5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        prev_idx = history.round_number - 1
        prev_cooperators = int(np.sum(history.opponent_actions[prev_idx]))
        if prev_cooperators > 0:
            return Action.D
        elif t % self.L == 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Aggressive Tester-Punisher (ATP) for the N-Player Public Goods Game.
    Always defects on the first and last round, punishes any observed cooperation
    by defecting, and with small probability ε tests (cooperates) when everyone
    defected last round to lure cooperators for exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t_next = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t_next == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        coop_others = int(history.opponent_actions[last_idx].sum())
        if coop_others > 0:
            return Action.D
        if random.random() < self.epsilon:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    Predator: Defect‐Most‐of‐the‐Time, Occasional Coax‐&‐Exploit.
    Almost always defects. If in the previous round at least n-1 opponents cooperated,
    switch to ENGAGE state and on the next round cooperate for coax_rounds to lure them,
    then immediately return to defection to exploit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold_coop = game_description.n_players - 1
        self.coax_rounds = 1
        self.state = 'DORMANT'
        self.engage_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        rounds_completed = history.round_number
        current_round = rounds_completed + 1
        last_round = self.game_description.n_rounds
        if current_round == last_round:
            return Action.D
        if current_round == 1:
            return Action.D
        recent_index = rounds_completed - 1
        coopers_last = int(np.sum(history.opponent_actions[recent_index]))
        if self.state == 'DORMANT':
            if coopers_last >= self.threshold_coop:
                self.state = 'ENGAGE'
                self.engage_counter = 0
            return Action.D
        if self.engage_counter < self.coax_rounds:
            self.engage_counter += 1
            return Action.C
        else:
            self.state = 'DORMANT'
            return Action.D

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    Aggressive Exploiter (AE) for the n-player repeated public goods game.
    - Never trust blindly; start and end with defection.
    - Bait a cooperative majority (≥ T_high) by cooperating once.
    - If you ever cooperate alone, trigger P_len rounds of punishment (defection).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T_high = math.ceil((self.n - 1) / 2) + 1
        self.P_len = 1
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number >= 1:
            last_idx = history.round_number - 1
            if history.my_actions[last_idx] and int(np.sum(history.opponent_actions[last_idx])) == 0:
                self.punish_timer = self.P_len
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        prev_idx = history.round_number - 1
        cooperators_last = int(np.sum(history.opponent_actions[prev_idx]))
        if cooperators_last >= self.T_high:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    Relentless Defector: in every round of the N-player public goods game,
    this strategy always defects (Action.D), exploiting any cooperators and
    never contributing itself.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Unconditional defection: always plays D in every round of the public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    Aggressive Exploiter strategy for the N‐player Public Goods Game.
    - Almost always defects.
    - Occasionally "probes" with cooperation with probability e when no one
      cooperated in the previous round.
    - If any opponent cooperated in the last round, defect to exploit.
    - Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.e = 0.05

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            if random.random() < self.e:
                return Action.C
            else:
                return Action.D
        rounds_completed = history.round_number
        current_round = rounds_completed + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if rounds_completed == 0:
            if random.random() < self.e:
                return Action.C
            else:
                return Action.D
        last_round_actions = history.opponent_actions[rounds_completed - 1]
        cooperators = int(np.sum(last_round_actions))
        if cooperators >= 1:
            return Action.D
        if random.random() < self.e:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Aggressive Grim-End Exploiter:
    - Cooperate on round 1 to lure cooperators.
    - If at any non-endgame round the total cooperators in the previous round
      fell below a majority threshold, switch to permanent defection (grim-trigger).
    - In the final δ_end rounds, defect unconditionally to exploit remaining goodwill.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T_thresh = math.ceil(self.n / 2)
        self.delta_end = min(2, max(1, self.r - 1))
        self.active = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t > self.r - self.delta_end:
            return Action.D
        if not self.active:
            return Action.D
        last_idx = history.round_number - 1
        my_last = 1 if history.my_actions[last_idx] else 0
        opp_last = int(np.sum(history.opponent_actions[last_idx]))
        prev_coops = my_last + opp_last
        if prev_coops >= self.T_thresh:
            return Action.C
        else:
            self.active = False
            return Action.D

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    Aggressive Public-Goods Hunter:
    Always defects in the first and last rounds, uses a single mid‐game probe
    (cooperates once) to detect any cooperators, and if any are found,
    switches permanently to defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.state = 'HUNTING'
        self.probe_round = math.floor(self.game_description.n_rounds / 2)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.round_number == self.probe_round and self.state == 'HUNTING' and history.my_actions[-1]:
            if history.opponent_actions[-1].any():
                self.state = 'EXPLOITING'
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == 1 or current_round == total_rounds:
            return Action.D
        if self.state == 'EXPLOITING':
            return Action.D
        if current_round == self.probe_round:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Aggressive Exploiter strategy for the N-player Public Goods Game.
    Defects on the first round and in the last two rounds. In intermediate
    rounds, cooperates only if a clear majority of other players cooperated
    in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold = math.floor((self.n - 1) / 2) + 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t >= self.r - 1:
            return Action.D
        prev_idx = completed - 1
        coop_others = int(np.sum(history.opponent_actions[prev_idx, :]))
        if coop_others >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    Aggressive Defector strategy for the N-Player Public Goods Game.
    Always defects (Action.D) in every round, ignoring history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    Aggressive Early-Bird Exploiter (AEE):
    - Probe for T_probe = min(2, r-1) rounds by cooperating.
    - Defect for all remaining rounds (including the last).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T_probe = min(2, self.game_description.n_rounds - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t <= self.T_probe:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Aggressive‐exploiter for the N‐player public goods game.
    Briefly cooperates for 1–2 rounds to probe opponents, then defects permanently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.Ttest = min(2, self.r)
        self.coop_sum = 0
        self.vulnerable = False
        self.threshold = self.n / 2 * self.Ttest

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            if self.r <= 2:
                return Action.D
            return Action.C
        t_completed = history.round_number
        if t_completed <= self.Ttest:
            opp_coop = int(history.opponent_actions[t_completed - 1].sum())
            my_coop = int(history.my_actions[t_completed - 1])
            self.coop_sum += opp_coop + my_coop
        if self.r > 2 and t_completed == self.Ttest:
            self.vulnerable = self.coop_sum >= self.threshold
        next_round = t_completed + 1
        if self.r <= 2:
            return Action.D
        if next_round <= self.Ttest:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Brutal Defector: in every round, play D (Defect), ignoring history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    Remorseless defector for the N-player public goods game.
    Defect in every round regardless of history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    Aggressive exploiter strategy for the N‐Player Public Goods Game.
    Defects by default, never cooperates in the first or last round,
    punishes any cooperator immediately by defecting,
    and otherwise performs rare "test" cooperations every T = ceil(log2(r)) rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.T = max(1, math.ceil(math.log2(self.n_rounds)))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.n_rounds:
            return Action.D
        if completed >= 1:
            last_coops = int(np.sum(history.opponent_actions[completed - 1]))
        else:
            last_coops = 0
        if last_coops >= 1:
            return Action.D
        if t % self.T == 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Always defect (play D) in every round, regardless of history or round number.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Aggressive Free-Rider (AFR) strategy: never contributes to the public good,
    always defects to maximize individual payoff in every round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    Aggressive Extortioner:
    - Start by defecting.
    - In rounds 2..(r-1): if and only if all other players cooperated in the previous round,
      cooperate with small probability ε; otherwise defect.
    - In the final round, always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t >= r:
            return Action.D
        last_round_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_round_idx].sum())
        if opp_coops == n - 1 and random.random() < self.epsilon:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Always-Defect Strategy for the N-Player Public Goods Game.
    In every round, this strategy plays D (Defect), never cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    Aggressive exploiter: In the first half of the game, it cooperates only if no opponent
    has defected so far (building minimal trust). Once any defection is observed, or after
    the midpoint, it defects every round to maximize exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.T = math.floor(game_description.n_rounds / 2)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_completed = history.round_number
        t = rounds_completed + 1
        if t <= self.T:
            if history.opponent_actions[:rounds_completed].all():
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    Probe-and-Exploit strategy for n-player public goods:
    - Probe phase: cooperate for m = min(2, r-1) rounds to detect cooperators.
    - Exploitation phase: defect every round thereafter (including the last).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = min(2, game_description.n_rounds - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t <= self.m:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Aggressive strategy: never cooperate. Always defect in every round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    Aggressive Always-Defect (AAD):
    This strategy never cooperates. In every round, regardless of history,
    it always chooses to defect (Action.D).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    Two‐Round Bait and Rampant Defection:
    Cooperate for the first min(2, r-1) rounds to 'bait' opponents,
    then defect every remaining round, including the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.handshake_rounds = min(2, game_description.n_rounds - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            current_round = 1
        else:
            current_round = history.round_number + 1
        if current_round <= self.handshake_rounds:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    Aggressive Exploiter for N-player repeated public goods game.
    Cooperates for a warm-up (≈r/4) rounds unless any defection is seen,
    then defects forever.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.tau = max(1, math.ceil(self.n_rounds / 4))
        self.warmup_active = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.warmup_active:
            completed = history.round_number
            last_idx = completed - 1
            opponents_cooperated = bool(history.opponent_actions[last_idx].all())
            self_cooperated = bool(history.my_actions[last_idx])
            if not opponents_cooperated or not self_cooperated:
                self.warmup_active = False
                return Action.D
            next_round = completed + 1
            if next_round <= self.tau:
                return Action.C
            else:
                self.warmup_active = False
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Unforgiving Threshold Extortion (UTE):
    - Always defect on first and last rounds.
    - Until a defection is observed, cooperate only if every player cooperated in the previous round.
    - If any defection is ever observed, switch to permanent defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.triggered = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        if self.triggered:
            return Action.D
        last_my = history.my_actions[-1]
        last_ops = history.opponent_actions[-1]
        cooperators = int(last_my) + int(np.sum(last_ops))
        if cooperators == n_players:
            return Action.C
        else:
            self.triggered = True
            return Action.D

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Aggressive exploiter strategy for the N-player public goods game.
    - Always defects in the first and last rounds.
    - Maintains a permanent punishment flag: if any opponent ever cooperated,
      it defects forever after.
    - While no punishment is triggered and not in first/last round, it "baits"
      by cooperating with small probability epsilon to tempt naive cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 0.05
        self.punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if not self.punish and history.round_number >= 1:
            last_ops = history.opponent_actions[history.round_number - 1]
            if last_ops.any():
                self.punish = True
        if self.punish:
            return Action.D
        if random.random() < self.epsilon:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    Perpetual Defection:
    In every round of a finite repeated public goods game (1 < k < n),
    defection strictly dominates cooperation. This strategy therefore
    defects (Action.D) in the first, intermediate, and last rounds,
    never contributing to the public good.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Aggressive Exploiter for the N‐player Public Goods Game.
    Defects by default, punishes any cooperation, probes occasionally
    when everyone defected last round, and never cooperates in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.p = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        own_last = history.my_actions[-1]
        opp_last = history.opponent_actions[-1]
        last_sum = int(own_last) + int(opp_last.sum())
        if last_sum > 0:
            return Action.D
        if random.random() < self.p:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    Aggressive Always-Defect (AAD) strategy for the N-Player Public Goods Game.
    Defects in every round unconditionally, exploiting any cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    Aggressive Grim trigger for the N-player Public Goods Game.
    Starts by defecting, never cooperates, and if any opponent ever cooperates,
    switches to permanent defection. Always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punished:
            return Action.D
        last_round_idx = history.round_number - 1
        if last_round_idx >= 0:
            if np.any(history.opponent_actions[last_round_idx]):
                self.punished = True
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    Always defect strategy for the repeated public goods game.
    Defect in every round, regardless of history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    Aggressive Defector: never contributes to the public good and always defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    Aggressive Exploiter (First-Round Probe, Then Permanent Defection)

    This strategy cooperates in round 1 as an optional probe, then defects
    in every subsequent round to free-ride on any remaining cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    Purely defecting strategy: always plays D to maximize private payoff
    and punish any cooperators by never contributing.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Aggressive Defector: always defects, ignoring all history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    Aggressive PROBE-EXPLOIT strategy for the N-player Public Goods Game.
    Probes every P rounds by cooperating to detect contributors, then exploits
    them by defecting E rounds in a row, never shows mercy, and always defects
    in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.P = 3
        self.E = 2
        self.exploit_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t_prev = history.round_number
        r = self.game_description.n_rounds
        last_action = history.my_actions[-1]
        if last_action and t_prev < r:
            opp_actions_last = history.opponent_actions[t_prev - 1]
            if int(opp_actions_last.sum()) >= 1:
                self.exploit_timer = self.E
        t = t_prev + 1
        if t == r:
            return Action.D
        if (t - 1) % self.P == 0:
            return Action.C
        if self.exploit_timer > 0:
            self.exploit_timer -= 1
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Predator‐Probe: Aggressively defect by default, rarely probe with cooperation
    when everyone defected, and exploit any cooperators immediately.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.probe_interval = max(2, math.ceil(self.r / 10))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.r:
            return Action.D
        last_idx = completed - 1
        last_my = history.my_actions[last_idx]
        last_opp = history.opponent_actions[last_idx]
        total_coop = int(last_my) + int(np.sum(last_opp))
        if total_coop >= 1:
            return Action.D
        if t % self.probe_interval == 0:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Aggressive public goods strategy:
    - With small probability p, cooperate ("dangle") until a threshold T of cooperators is observed.
    - Once m >= T in any round, permanently defect thereafter.
    - In the last two rounds, always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p = 0.1
        self.T = math.ceil(self.game_description.n_players / 2)
        self.PUNISH_ROUND = self.game_description.n_rounds - 2
        self.exploitation_triggered = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t > self.PUNISH_ROUND:
            return Action.D
        if self.exploitation_triggered:
            return Action.D
        if t == 1:
            return Action.C if random.random() < self.p else Action.D
        prev_idx = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[prev_idx]))
        my_coop = 1 if history.my_actions[prev_idx] else 0
        m = opp_coops + my_coop
        if m >= self.T:
            self.exploitation_triggered = True
            return Action.D
        return Action.C if random.random() < self.p else Action.D

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    Aggressive public‐goods strategy:
    - Defect on first and last rounds
    - Always defect if any opponent cooperated in the previous round (exploit)
    - If no one has cooperated for m rounds, probe with small probability ε
    - Otherwise continue defecting
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 0.05
        self.m = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        final_round = self.game_description.n_rounds
        if t == final_round:
            return Action.D
        last_coops = int(np.sum(history.opponent_actions[completed - 1]))
        if last_coops >= 1:
            return Action.D
        cooperation_found = False
        for k in range(1, self.m + 1):
            idx = completed - k
            if idx < 0:
                continue
            if int(np.sum(history.opponent_actions[idx])) >= 1:
                cooperation_found = True
                break
        if not cooperation_found:
            if random.random() < self.epsilon:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Always-Defect Aggressor: unconditionally defects every round in the public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    Predator strategy: Aggressive free-rider. Always defects except for rare probe cooperations.
    Once any opponent is observed cooperating, switches to permanent defection to exploit them.
    Ensures defection in first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.exploitable = False
        self.M = max(2, math.ceil(self.n_rounds / 10))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        rounds_played = history.round_number
        t = rounds_played + 1
        if t == self.n_rounds:
            return Action.D
        if self.exploitable:
            return Action.D
        if t % self.M == 0:
            return Action.C
        last_idx = rounds_played - 1
        if history.opponent_actions[last_idx].sum() > 0:
            self.exploitable = True
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Aggressive Rug-Pull strategy for the repeated N-player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.P = max(1, math.floor(self.r / 3))
        self.Q = min(self.r, 2 * self.P)
        self.betrayed = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number
        if last_round <= self.P and last_round > 0:
            if history.my_actions[last_round - 1] and (not all(history.opponent_actions[last_round - 1])):
                self.betrayed = True
        t = last_round + 1
        if t == self.r:
            return Action.D
        if t <= self.P:
            return Action.C if not self.betrayed else Action.D
        if t <= self.Q:
            if self.betrayed:
                return Action.D
            coop_count = int(history.opponent_actions[last_round - 1].sum())
            threshold = math.ceil((self.n - 1) / 2)
            return Action.C if coop_count >= threshold else Action.D
        return Action.D

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    Ultimate Exploiter strategy for the Public Goods Game.
    - Round 1: Cooperate to probe for any cooperators.
    - Intermediate rounds: If any opponent cooperated last round, defect to exploit;
      otherwise cooperate to replenish the public good.
    - Final round: Always defect to maximize one‐shot gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        last_round_index = history.round_number - 1
        opponent_last = history.opponent_actions[last_round_index]
        cooperative_opponents = int(opponent_last.sum())
        if cooperative_opponents >= 1:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    Aggro‐Grim with One‐Shot Test:
    - Start defecting.
    - On the first non‐first, non‐last round (if no one has cooperated), cooperate once to test.
    - If any opponent ever cooperates, defect forever thereafter.
    - Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.tested = False
        self.everCooperated = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if not self.everCooperated and history.opponent_actions.any():
            self.everCooperated = True
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.everCooperated:
            return Action.D
        elif not self.tested:
            self.tested = True
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Aggressive Exploiter strategy for the N-player public goods game.
    - Always defects in the first and last round.
    - In intermediate rounds, if anyone (including self) cooperated in the previous round, defect.
    - Otherwise, defect with probability 1 - ε or probe (cooperate) with probability ε.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.epsilon = 0.05

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = completed - 1
        opp_coops = history.opponent_actions[last_idx].sum()
        my_coop = 1 if history.my_actions[last_idx] else 0
        coop_prev = int(opp_coops) + my_coop
        if coop_prev >= 1:
            return Action.D
        if random.random() < self.epsilon:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Lure-and-Klepto: Cooperate exactly once on round 2 (the "lure") in games of length ≥3,
    then defect every other round. In games of length 1 or 2, always defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.lure = min(2, self.r)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if self.r < 3:
            return Action.D
        if t == self.lure:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Sneaky-Exploit strategy for the N-Player Public Goods Game.
    - Default defect.
    - If everyone defected last round, cooperate with small probability ε (bait).
    - If any cooperation observed, switch to permanent full defection (grim).
    - Always defect in the last R_punish rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.epsilon = 0.05
        self.R_punish = 2
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t > self.n_rounds - self.R_punish:
            return Action.D
        if self.punished:
            return Action.D
        last_own = history.my_actions[-1]
        last_opps = history.opponent_actions[-1]
        total_coops = int(last_own) + int(np.sum(last_opps))
        if total_coops > 0:
            self.punished = True
            return Action.D
        if random.random() < self.epsilon:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    DefectorBaiter strategy: Cooperate in the first round to bait opponents,
    then defect unconditionally in all subsequent rounds (including the last).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Aggressive “Greedy Exploiter with Probing” strategy for the N‐player public goods game.
    - Always defects in the first T_safe rounds and the last T_end rounds.
    - If any opponent cooperated in the previous round, defects (punishment).
    - Otherwise, defects by default, but cooperates (probes) every P_probe rounds
      to test for exploitable cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.P_probe = max(1, math.ceil(self.r / 10))
        self.T_safe = 1
        self.T_end = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t <= self.T_safe:
            return Action.D
        if t > self.r - self.T_end:
            return Action.D
        prev_idx = history.round_number - 1
        prev_cooperators = int(history.opponent_actions[prev_idx].sum())
        if prev_cooperators > 0:
            return Action.D
        if t % self.P_probe == 0 and t <= self.r - self.T_end:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    Ruthless Tester: probe by cooperating until anyone cooperates, then defect forever.
    Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.triggered = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_index = history.round_number - 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        if self.triggered:
            return Action.D
        opponent_last_actions = history.opponent_actions[last_round_index]
        if opponent_last_actions.any():
            self.triggered = True
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    Hunter–Exploiter strategy for the N-player Public Goods Game.
    Phase HUNT: mostly defect with small probe probability epsilon to detect cooperators.
    On detecting any cooperator in the last round, switch to EXPLOIT.
    Phase EXPLOIT: defect forever (including the final round).
    Always defect in the first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.phase = 'HUNT'
        self.epsilon = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_coops = int(history.opponent_actions[last_round_idx].sum())
        if self.phase == 'HUNT' and last_coops > 0:
            self.phase = 'EXPLOIT'
        if self.phase == 'EXPLOIT':
            return Action.D
        if random.random() < self.epsilon:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Aggressive Public‐Goods “Grim‐Last‐Shot” strategy.
    - Cooperate in round 1.
    - If everyone has cooperated in all past rounds, then in the first chance (t<r) defect and lock in permanent defection.
    - Defect forever after any single defection by any player (grim‐trigger).
    - Always defect in the last round for maximal last‐shot gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.H = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_my = int(history.my_actions[-1])
        last_opp = int(np.sum(history.opponent_actions[-1]))
        total_last = last_my + last_opp
        if total_last < self.game_description.n_players:
            self.H = False
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t < r:
            if self.H:
                self.H = False
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    The Bulldozer strategy: a relentlessly aggressive defector.
    - Always defects.
    - Punishes any cooperation by never cooperating back.
    - Defects even in the final round to maximize private payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        prev_index = history.round_number - 1
        coop_prev = int(np.sum(history.opponent_actions[prev_index]))
        if coop_prev > 0:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    Aggressive Defector: always plays Defect (D) in every round, regardless of history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    Aggressive probe-and-exploit strategy for the N-player public goods game.
    - Never cooperates on round 1 or the final round.
    - In intermediate rounds, it probes with small probability ε to detect cooperators.
    - If in any probe it sees at least M other cooperators, it permanently switches
      to defection (EXPLOIT phase), else it stays in probing (PROBE phase).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.phase = 'PROBE'
        self.epsilon = 0.05
        self.M = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        n_rounds = self.game_description.n_rounds
        if completed >= 1 and self.phase == 'PROBE':
            last_idx = completed - 1
            if history.my_actions[last_idx]:
                coop_others = int(np.sum(history.opponent_actions[last_idx]))
                if coop_others >= self.M:
                    self.phase = 'EXPLOIT'
        current_round = completed + 1
        if current_round == 1 or current_round == n_rounds:
            return Action.D
        if self.phase == 'PROBE':
            if random.random() < self.epsilon:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    Opportunistic-Grim strategy for the public goods game:
    - Always defect on round 1 and the final round.
    - If any opponent ever defects, defect forever (grim trigger).
    - Otherwise, in rounds 2..r-1, cooperate only if all other players cooperated
      in the immediately preceding round; else defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.betrayed = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if not self.betrayed:
            if np.any(~history.opponent_actions):
                self.betrayed = True
        if self.betrayed:
            return Action.D
        prior_idx = history.round_number - 1
        if prior_idx >= 0 and history.opponent_actions[prior_idx].all():
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    Seeding-then-Exploitation (STE): aggressively seed cooperation for up to seedRounds,
    then if any cooperator is detected switch to permanent defection (EXPLOIT).
    If no one cooperated in seeding, enter PROBE: mostly defect, but cooperate every
    probeInterval rounds to test; if someone responds, switch to EXPLOIT. Always defect
    on the final round by backward induction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        r = game_description.n_rounds
        self.seedRounds = min(3, r - 1)
        self.probeInterval = 5
        self.exploitThreshold = 1
        self.othersCoopCount = 0
        self.phase = 'SEED' if r > 3 else 'PROBE'

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            last_round = 0
        else:
            last_round = history.round_number
            t = last_round + 1
            if self.phase == 'SEED' and 1 <= last_round <= self.seedRounds:
                coopers = int(np.sum(history.opponent_actions[last_round - 1]))
                self.othersCoopCount += coopers
            if self.phase == 'SEED' and last_round == self.seedRounds:
                if self.othersCoopCount >= self.exploitThreshold:
                    self.phase = 'EXPLOIT'
                else:
                    self.phase = 'PROBE'
            if self.phase == 'PROBE':
                if last_round > 0 and last_round % self.probeInterval == 0 and (last_round != self.game_description.n_rounds):
                    responded = int(np.sum(history.opponent_actions[last_round - 1])) > 0
                    if responded:
                        self.phase = 'EXPLOIT'
        if t == self.game_description.n_rounds:
            return Action.D
        if self.phase == 'SEED':
            return Action.C
        if self.phase == 'EXPLOIT':
            return Action.D
        if self.phase == 'PROBE':
            if t % self.probeInterval == 0:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Aggressive trigger-and-exploit strategy for the N-player public goods game.
    Starts by defecting, punishes any cooperation, and if the group cooperates
    unanimously for two consecutive rounds, it lures with one cooperation then
    defects to exploit. Always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploit_phase = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        if t == n_rounds:
            return Action.D
        if self.exploit_phase:
            self.exploit_phase = False
            return Action.D
        if t >= 3:
            idx_prev2 = history.round_number - 2
            idx_prev1 = history.round_number - 1
            all_coop_prev2 = history.my_actions[idx_prev2] and np.all(history.opponent_actions[idx_prev2])
            all_coop_prev1 = history.my_actions[idx_prev1] and np.all(history.opponent_actions[idx_prev1])
            if all_coop_prev2 and all_coop_prev1:
                self.exploit_phase = True
                return Action.C
        idx_last = history.round_number - 1
        any_coop_last = history.my_actions[idx_last] or np.any(history.opponent_actions[idx_last])
        if any_coop_last:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Aggressive Defector with Grim Trigger and Random Testing (ADGT-RT).
    - Always defects on the first and last rounds.
    - If any player cooperated in the previous round, triggers permanent defection.
    - If no one cooperated in the previous round, cooperates with small probability
      to probe, else defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punish = False
        self.test_prob = 0.05

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish = False
            return Action.D
        t = history.round_number + 1
        if self.punish or t == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        my_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx].sum()
        coop_count = int(my_last) + int(opp_last)
        if coop_count > 0:
            self.punish = True
            return Action.D
        if random.random() < self.test_prob:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Aggressor strategy: always defect in every round, never cooperates or forgives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    All-out aggressive strategy: defect every round to guarantee the highest guaranteed payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    Sniper-Exploit strategy for the N-player public goods game.
    Defects by default, after D_trigger consecutive all-D rounds cooperates once
    to lure cooperators, then reverts to defection. In the last L = ceil(sqrt(r))
    rounds it always defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.D_count = 0
        self.just_sniped = False
        self.D_trigger = 3
        self.L = math.ceil(math.sqrt(self.game_description.n_rounds))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_idx = history.round_number - 1
        we_defected = not history.my_actions[last_idx]
        opponents = history.opponent_actions[last_idx]
        everyone_defected = we_defected and (not np.any(opponents))
        if everyone_defected:
            self.D_count += 1
        else:
            self.D_count = 0
        if self.just_sniped and (not history.my_actions[last_idx]):
            self.just_sniped = False
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t > r - self.L:
            return Action.D
        if self.just_sniped:
            return Action.D
        if self.D_count >= self.D_trigger:
            self.just_sniped = True
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Opportunistic Exploiter (OE) for the N-player public goods game.
    Lures cooperators for a limited number of early rounds, then switches
    permanently to defection (including the last round) to maximize private payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        r = game_description.n_rounds
        self.coop_phase_max = max(1, math.floor(r / 4))
        self.coop_threshold = math.ceil(0.75 * (n - 1))
        self.phase = 'SEEK'

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.phase == 'SEEK':
            if t == 1:
                action = Action.D
            else:
                action = Action.C
            coop_prev = 0
            if completed >= 1:
                coop_prev = int(np.sum(history.opponent_actions[completed - 1]))
            if coop_prev >= self.coop_threshold or t >= self.coop_phase_max:
                self.phase = 'EXPLOIT'
        else:
            action = Action.D
        return action

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    Aggressive Always-Defect (AAD):
    This strategy never cooperates. In every round (including the first and last),
    it defects to maximize private payoff and free-ride on any cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    Aggressive Opportunistic Free-Rider (AOF) strategy for the N-player public goods game.
    - Round 1: Cooperate to seed cooperation.
    - Rounds 2 to r-2: If any opponent cooperated last round, defect; otherwise cooperate.
    - Rounds r-1 and r: Defect unconditionally (end-game).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_completed = history.round_number
        t = rounds_completed + 1
        r = self.game_description.n_rounds
        if t >= r - 1:
            return Action.D
        prev_round_idx = rounds_completed - 1
        coop_count_prev = int(history.opponent_actions[prev_round_idx].sum())
        if coop_count_prev > 0:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    Half-Cooperate-Then-Betray:
    Cooperate for the first half of the game (rounded up), unless any opponent defects,
    then defect for the remainder of the rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.H = math.ceil(self.game_description.n_rounds / 2)
        self.mode = 'COOP_PHASE'

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if self.mode == 'COOP_PHASE':
            if t > self.H:
                self.mode = 'DEFECT_PHASE'
            elif t > 1:
                last_idx = history.round_number - 1
                if not history.opponent_actions[last_idx].all():
                    self.mode = 'DEFECT_PHASE'
        if self.mode == 'COOP_PHASE':
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    Aggressive Exploiter (AE) strategy: always defects (Action.D) every round,
    exploiting any cooperators and never incurring the cost of cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    Aggressive bully strategy for the N-player repeated public goods game.
    - Defaults to Defect.
    - Punishes any cooperation seen in the previous round by defecting.
    - Probes with cooperation with small probability p_test when no one cooperated last round.
    - Always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_test = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        total_rounds = self.game_description.n_rounds
        if history is None:
            current_round = 1
            if current_round == total_rounds:
                return Action.D
            if random.random() < self.p_test:
                return Action.C
            return Action.D
        current_round = history.round_number + 1
        if current_round == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        if last_idx >= 0 and any(history.opponent_actions[last_idx]):
            return Action.D
        if random.random() < self.p_test:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Aggressive Grim-Tester strategy for the N-player public goods game.
    Probes cooperation on designated rounds, defects otherwise, and
    permanently defects once any opponent has cooperated.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.punish_mode = False
        M = max(2, math.ceil(self.r / 10))
        max_k = (self.r - 1) // M
        self.test_rounds = {k * M for k in range(1, max_k + 1)}

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if not self.punish_mode and history.round_number >= 1:
            last = history.round_number - 1
            coop_others = int(np.sum(history.opponent_actions[last]))
            if coop_others >= 1:
                self.punish_mode = True
        t = history.round_number + 1
        if self.punish_mode:
            return Action.D
        if t == 1 or t == self.r:
            return Action.D
        if t in self.test_rounds:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Aggressive-Defector strategy for the N-Player Public Goods Game.
    Always defects (Action.D) in every round, regardless of history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D