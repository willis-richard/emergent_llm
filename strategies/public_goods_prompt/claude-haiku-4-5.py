"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Anthropic
- Model: claude-haiku-4-5
- Game: public_goods_prompt
"""

from dataclasses import dataclass
from enum import Enum
import math
import numpy as np
from numpy.typing import NDArray
import random

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState




class Strategy_COLLECTIVE_1(BaseStrategy):
    """
    Adaptive Collective Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through reciprocal accountability:
    - Round 1: Cooperate unconditionally to bootstrap cooperation
    - Middle rounds: Cooperate if global cooperation rate exceeds dynamic threshold,
      adjusted for detected exploiters
    - Final round: Defect (no future shadow)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        return self._adaptive_decision(history, round_num)

    def _adaptive_decision(self, history: PlayerHistory, round_num: int) -> Action:
        """Apply the adaptive cooperation rule for middle rounds."""
        prev_round_idx = round_num - 1
        my_action_prev = history.my_actions[prev_round_idx]
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        total_cooperators = int(my_action_prev) + np.sum(opponent_actions_prev)
        cooperation_rate = total_cooperators / self.n_players
        base_threshold = (self.k - 1) / self.k
        adjusted_threshold = base_threshold + 1 / (2 * self.n_players)
        if round_num <= 2:
            adjusted_threshold = min(adjusted_threshold, (self.k - 2) / self.k)
        defector_count = self._count_exploiters(history, prev_round_idx)
        final_threshold = adjusted_threshold - 0.05 * defector_count
        final_threshold = max(final_threshold, 0.25)
        if cooperation_rate >= final_threshold:
            return Action.C
        else:
            return Action.D

    def _count_exploiters(self, history: PlayerHistory, up_to_round: int) -> int:
        """
        Count players who consistently defected while benefiting from group cooperation.
        A player is an exploiter if:
        - Their defection rate > 50% across the history
        - AND global cooperation rate > 50% across the history
        """
        total_rounds = up_to_round + 1
        all_my_actions = history.my_actions[:total_rounds]
        all_opponent_actions = history.opponent_actions[:total_rounds, :]
        global_cooperators = np.sum(all_my_actions) + np.sum(all_opponent_actions)
        global_cooperation_rate = global_cooperators / (self.n_players * total_rounds)
        if global_cooperation_rate <= 0.5:
            return 0
        exploiter_count = 0
        for opponent_idx in range(self.n_players - 1):
            opponent_actions = history.opponent_actions[:total_rounds, opponent_idx]
            defection_rate = 1.0 - np.mean(opponent_actions)
            if defection_rate > 0.5:
                exploiter_count += 1
        return exploiter_count

class Strategy_COLLECTIVE_2(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game.
    
    Sustains cooperation through conditional reciprocity with graduated defection responses.
    Uses a windowed cooperation rate (last 5 rounds) to decide between contributing and defecting,
    with special handling for edge cases and robustness mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_lock_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = state.round_number
        if self.defection_lock_counter > 0:
            self.defection_lock_counter -= 1
            return Action.D
        window_size = min(5, current_round)
        cooperation_rate = self._calculate_cooperation_rate(history, window_size, n)
        contribute_threshold = 0.75
        salvage_threshold = 0.5
        reentry_threshold = 0.6
        if n <= 3:
            contribute_threshold = 0.8
        if k <= 1.5:
            salvage_threshold = 0.4
        my_prev_action = history.my_actions[-1]
        prev_defected = not my_prev_action
        if prev_defected and cooperation_rate >= reentry_threshold:
            return Action.C
        if cooperation_rate >= contribute_threshold:
            return Action.C
        elif cooperation_rate >= salvage_threshold:
            return Action.C
        else:
            low_coop_rounds = self._count_low_cooperation_rounds(history, window_size, n)
            if low_coop_rounds >= 2:
                self.defection_lock_counter = 2
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, window_size: int, n: int) -> float:
        """
        Calculate the cooperation rate among all players over the last window_size rounds.
        """
        if window_size == 0:
            return 1.0
        my_actions_window = history.my_actions[-window_size:]
        opponent_actions_window = history.opponent_actions[-window_size:, :]
        total_cooperators = 0
        total_slots = window_size * n
        total_cooperators += np.sum(my_actions_window)
        total_cooperators += np.sum(opponent_actions_window)
        if total_slots == 0:
            return 1.0
        cooperation_rate = total_cooperators / total_slots
        return float(cooperation_rate)

    def _count_low_cooperation_rounds(self, history: PlayerHistory, window_size: int, n: int) -> int:
        """
        Count consecutive rounds at the end of the window where group cooperation < 30%.
        """
        if window_size == 0:
            return 0
        low_coop_count = 0
        low_threshold = 0.3
        check_rounds = min(window_size, 2)
        for i in range(1, check_rounds + 1):
            round_idx = -i
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx, :]
            cooperators_this_round = int(my_action) + np.sum(opponent_actions)
            coop_rate_this_round = cooperators_this_round / n
            if coop_rate_this_round < low_threshold:
                low_coop_count += 1
            else:
                low_coop_count = 0
        return low_coop_count

class Strategy_COLLECTIVE_3(BaseStrategy):
    """
    Collective Strategy for Public Goods Game: Conditional Cooperation with Adaptive Thresholds.
    
    Maximizes collective welfare by sustaining cooperation through:
    - Contributing in round 1 to bootstrap cooperation
    - Conditionally cooperating based on observed cooperation rate with decaying thresholds
    - Relaxing punishment as the game approaches its end
    - Special handling for the final round to maintain collective momentum
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        previous_round_idx = current_round - 1
        my_previous_action = history.my_actions[previous_round_idx]
        my_contribution = 1 if my_previous_action else 0
        opponent_contributions = np.sum(history.opponent_actions[previous_round_idx, :])
        total_cooperators = my_contribution + opponent_contributions
        coop_rate = total_cooperators / self.n_players
        is_final_round = current_round == self.n_rounds - 1
        if is_final_round:
            if coop_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        else:
            threshold = max(0.5, 1.0 - current_round / (2.0 * self.n_rounds))
            if coop_rate >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_4(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game using adaptive reciprocity.
    
    Maximizes collective welfare through threshold-based conditional contribution,
    calibrated to game parameters and remaining rounds. Punishes free-riding while
    rewarding cooperation, with time-dependent adjustments.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold_count = math.ceil((self.n_players - 1) / self.k)
        if self.k > 1:
            self.threshold_rate = (self.n_players - 1) / (self.k - 1) / self.n_players
        else:
            self.threshold_rate = 0.5
        self.threshold_rate = max(0.0, min(1.0, self.threshold_rate))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        phase_threshold_early = self.n_rounds // 3
        phase_threshold_late = 2 * self.n_rounds // 3
        rounds_remaining = self.n_rounds - round_num
        time_remaining_ratio = rounds_remaining / self.n_rounds if self.n_rounds > 0 else 0
        opponent_coop_rates = self._calculate_opponent_cooperation_rates(history)
        if self._all_opponents_defecting(history):
            return Action.D
        if self._late_game_defection_detected(history):
            return Action.D
        if round_num == self.n_rounds - 1:
            avg_coop_rate = np.mean(opponent_coop_rates) if len(opponent_coop_rates) > 0 else 0
            if avg_coop_rate > 0.9:
                return Action.C
            return Action.D
        if round_num < phase_threshold_early:
            effective_threshold = max(0.0, self.threshold_rate - 0.1)
        elif round_num < phase_threshold_late:
            effective_threshold = self.threshold_rate
        else:
            effective_threshold = 0.8
        avg_coop_rate = np.mean(opponent_coop_rates) if len(opponent_coop_rates) > 0 else 0
        if avg_coop_rate >= effective_threshold:
            return Action.C
        return Action.D

    def _calculate_opponent_cooperation_rates(self, history: PlayerHistory) -> NDArray[np.float64]:
        """
        Calculate cooperation rate for each opponent with recency weighting.
        Recent rounds (last 5) get 2x weight; earlier rounds get 1x weight.
        """
        if history is None or len(history.opponent_actions) == 0:
            return np.array([])
        n_opponents = history.opponent_actions.shape[1]
        n_past_rounds = history.opponent_actions.shape[0]
        coop_rates = np.zeros(n_opponents)
        for opp_idx in range(n_opponents):
            opponent_actions = history.opponent_actions[:, opp_idx]
            if n_past_rounds <= 5:
                coop_rates[opp_idx] = np.mean(opponent_actions)
            else:
                recent_weight = 2.0 * np.sum(opponent_actions[-5:])
                earlier_weight = 1.0 * np.sum(opponent_actions[:-5])
                total_weight = recent_weight + earlier_weight
                if total_weight > 0:
                    coop_rates[opp_idx] = total_weight / (5 * 2 + (n_past_rounds - 5) * 1)
                else:
                    coop_rates[opp_idx] = 0.0
        return coop_rates

    def _all_opponents_defecting(self, history: PlayerHistory) -> bool:
        """
        Check if all opponents have defected by round 3.
        If so, switch to pure defection.
        """
        if history is None or len(history.opponent_actions) < 3:
            return False
        recent_actions = history.opponent_actions[-3:, :]
        return np.all(recent_actions == 0)

    def _late_game_defection_detected(self, history: PlayerHistory) -> bool:
        """
        Detect if cooperation rate drops >20% between early and late game.
        """
        if history is None or len(history.opponent_actions) < 4:
            return False
        n_past_rounds = len(history.opponent_actions)
        mid_point = n_past_rounds // 2
        if mid_point < 2:
            return False
        early_coop_rate = np.mean(history.opponent_actions[:mid_point, :])
        late_coop_rate = np.mean(history.opponent_actions[mid_point:, :])
        if early_coop_rate > 0 and early_coop_rate - late_coop_rate > 0.2:
            return True
        return False

class Strategy_COLLECTIVE_5(BaseStrategy):
    """
    Adaptive Collective Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation that responds to 
    demonstrated trustworthiness, while maintaining robustness against defection 
    and free-riding.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.solo_contribution_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        window = min(5, round_num)
        recent_history_start = max(0, round_num - window)
        recent_opponent_actions = history.opponent_actions[recent_history_start:round_num, :]
        total_contributions = np.sum(recent_opponent_actions)
        total_possible = recent_opponent_actions.shape[0] * self.n_players
        if total_possible > 0:
            avg_contribution_rate = total_contributions / total_possible
        else:
            avg_contribution_rate = 0.0
        threshold = 0.5 + 0.3 * self.k / self.n_players
        opponent_defection_rates = self._compute_opponent_defection_rates(history, recent_history_start, round_num)
        reliable_cooperators = np.sum(opponent_defection_rates <= 0.2)
        conditional_cooperators = np.sum((opponent_defection_rates > 0.2) & (opponent_defection_rates <= 0.6))
        systematic_defectors = np.sum(opponent_defection_rates > 0.6)
        if round_num <= 3:
            if avg_contribution_rate >= 0.3:
                return Action.C
            return Action.D
        if round_num >= 2:
            if self._is_solo_contributor(history, round_num):
                self.solo_contribution_count += 1
                if self.solo_contribution_count >= 2:
                    self.solo_contribution_count = 0
                    return Action.D
            else:
                self.solo_contribution_count = 0
        group_healthy = avg_contribution_rate >= threshold
        if group_healthy:
            your_defection_rate = self._compute_your_defection_rate(history, recent_history_start, round_num)
            you_are_reliable = your_defection_rate <= 0.2
            if you_are_reliable:
                return Action.C
            reliable_and_conditional = reliable_cooperators + conditional_cooperators
            if reliable_and_conditional >= (self.n_players - 1) * 0.5:
                return Action.C
            return Action.D
        else:
            if reliable_cooperators >= (self.n_players - 1) * 0.4:
                return Action.C
            if systematic_defectors > 0:
                defector_density = systematic_defectors / (self.n_players - 1)
                if random.random() < defector_density:
                    return Action.D
            return Action.D

    def _compute_opponent_defection_rates(self, history: PlayerHistory, start_idx: int, end_idx: int) -> NDArray[np.float64]:
        """
        Compute defection rate for each opponent over the specified round range.
        Returns array of shape (n_players - 1,).
        """
        n_opponents = self.n_players - 1
        defection_rates = np.zeros(n_opponents)
        if end_idx <= start_idx:
            return defection_rates
        recent_actions = history.opponent_actions[start_idx:end_idx, :]
        num_rounds = recent_actions.shape[0]
        for j in range(n_opponents):
            defections = np.sum(~recent_actions[:, j])
            defection_rates[j] = defections / num_rounds
        return defection_rates

    def _compute_your_defection_rate(self, history: PlayerHistory, start_idx: int, end_idx: int) -> float:
        """
        Compute your own defection rate over the specified round range.
        """
        if end_idx <= start_idx:
            return 0.0
        your_actions = history.my_actions[start_idx:end_idx]
        defections = np.sum(~your_actions)
        return defections / len(your_actions)

    def _is_solo_contributor(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Check if you were the only contributor in the previous round.
        """
        if round_num < 1:
            return False
        your_action = history.my_actions[round_num - 1]
        opponent_actions = history.opponent_actions[round_num - 1, :]
        if not your_action:
            return False
        all_others_defected = np.sum(opponent_actions) == 0
        return all_others_defected

class Strategy_COLLECTIVE_6(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by establishing mutual contribution equilibrium.
    Uses conditional cooperation with dynamically adjusted thresholds based on
    observed group contribution rates. Gracefully degrades when opponents defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.permanent_defect = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if round_num == 0:
            return Action.C
        if self.permanent_defect:
            return Action.D
        prev_round_idx = round_num - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        opponent_cooperators = int(np.sum(opponent_prev_actions))
        total_cooperators_prev = opponent_cooperators + (1 if my_prev_action else 0)
        contribution_rate_prev = total_cooperators_prev / n_players
        if contribution_rate_prev == 0.0:
            self.permanent_defect = True
            return Action.D
        if round_num <= 3:
            threshold = 1.0
        else:
            if round_num == 4:
                all_contribution_rates = []
                for r in range(min(4, round_num + 1)):
                    cooperators_r = int(np.sum(history.opponent_actions[r, :])) + (1 if history.my_actions[r] else 0)
                    rate_r = cooperators_r / n_players
                    all_contribution_rates.append(rate_r)
                avg_contribution_rate = np.mean(all_contribution_rates)
            else:
                rates = []
                for r in [round_num - 2, prev_round_idx]:
                    cooperators_r = int(np.sum(history.opponent_actions[r, :])) + (1 if history.my_actions[r] else 0)
                    rate_r = cooperators_r / n_players
                    rates.append(rate_r)
                avg_contribution_rate = np.mean(rates)
            threshold = max(0.0, avg_contribution_rate - 0.05)
        if round_num in [1, 2]:
            if opponent_cooperators == 0:
                return Action.D
            return Action.C
        if round_num == n_rounds - 1:
            if contribution_rate_prev >= threshold:
                return Action.C
            return Action.D
        majority_threshold = (n_players - 1) / 2
        if opponent_cooperators > majority_threshold:
            return Action.C
        if contribution_rate_prev >= threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_7(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation based on observed
    group cooperation rates, with special handling for first and final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.C
        window_size = max(3, self.n_rounds // 4)
        if self.n_players <= 3:
            cooperation_threshold_high = 0.5
            window_size = max(1, self.n_rounds // 3)
        else:
            cooperation_threshold_high = 0.65
        cooperation_threshold_low = 0.4
        start_round = max(0, round_number - window_size)
        window_rounds = round_number - start_round
        my_contributions = int(np.sum(history.my_actions[start_round:round_number]))
        opponent_contributions = int(np.sum(history.opponent_actions[start_round:round_number, :]))
        total_contributions = my_contributions + opponent_contributions
        total_possible = self.n_players * window_rounds
        if total_possible == 0:
            cooperation_rate = 0.0
        else:
            cooperation_rate = total_contributions / total_possible
        if cooperation_rate >= cooperation_threshold_high:
            return Action.C
        elif cooperation_rate < cooperation_threshold_low:
            return Action.D
        elif random.random() < cooperation_rate:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_8(BaseStrategy):
    """
    Collective Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation based on:
    1. Cooperation rate threshold (break-even point k/n)
    2. Escalation against habitual defectors (>50% defection rate)
    3. Recovery after 3 consecutive rounds above threshold
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = (game_description.k - 1) / game_description.k
        self.opponent_defection_rates = {}
        self.consecutive_threshold_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        previous_round_idx = state.round_number - 1
        my_previous_action = history.my_actions[previous_round_idx]
        opponent_cooperators = np.sum(history.opponent_actions[previous_round_idx, :])
        total_cooperators = opponent_cooperators + (1 if my_previous_action else 0)
        cooperation_rate = total_cooperators / n
        self._update_defection_rates(history, previous_round_idx)
        has_habitual_defector = any((rate > 0.5 for rate in self.opponent_defection_rates.values()))
        if cooperation_rate >= self.threshold:
            self.consecutive_threshold_rounds += 1
        else:
            self.consecutive_threshold_rounds = 0
        if self.consecutive_threshold_rounds >= 3:
            self.opponent_defection_rates = {}
            self.consecutive_threshold_rounds = 0
        if has_habitual_defector:
            return Action.D
        if cooperation_rate >= self.threshold:
            return Action.C
        else:
            return Action.D

    def _update_defection_rates(self, history: PlayerHistory, round_idx: int) -> None:
        """
        Update the defection rate for each opponent based on history up to round_idx.
        """
        n_opponents = self.game_description.n_players - 1
        for opponent_idx in range(n_opponents):
            defections = np.sum(~history.opponent_actions[:round_idx + 1, opponent_idx])
            total_rounds = round_idx + 1
            defection_rate = defections / total_rounds if total_rounds > 0 else 0.0
            self.opponent_defection_rates[opponent_idx] = defection_rate

class Strategy_COLLECTIVE_9(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Balances optimism (early cooperation to establish trust) with realism (detecting and punishing free-riders).
    - Rounds 1-3: Always cooperate
    - Rounds 4+: Cooperate if historical contribution rate ≥ (k/n) × 0.6, else defect
    - Reacts to sudden drops in contribution rate (>20% in one round)
    - Special handling for final round based on trend
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_threshold = self.k / self.n_players * 0.6
        self.prev_contribution_rate = None
        self.rounds_since_recovery = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num < 3:
            return Action.C
        total_contributions = self._count_total_contributions(history)
        max_possible_contributions = (round_num + 1) * self.n_players
        contribution_rate = total_contributions / max_possible_contributions if max_possible_contributions > 0 else 0.0
        if self.prev_contribution_rate is not None:
            drop = self.prev_contribution_rate - contribution_rate
            if drop > 0.2:
                self.rounds_since_recovery = 0
                self.prev_contribution_rate = contribution_rate
                return Action.D
        self.prev_contribution_rate = contribution_rate
        if round_num == self.n_rounds - 1:
            return self._decide_final_round(history, contribution_rate)
        if contribution_rate >= self.cooperation_threshold:
            self.rounds_since_recovery += 1
            return Action.C
        else:
            self.rounds_since_recovery = 0
            return Action.D

    def _count_total_contributions(self, history: PlayerHistory) -> int:
        """Count total contributions (cooperations) across all players and all past rounds."""
        if history is None or len(history.my_actions) == 0:
            return 0
        my_contributions = int(np.sum(history.my_actions))
        opponent_contributions = int(np.sum(history.opponent_actions))
        return my_contributions + opponent_contributions

    def _decide_final_round(self, history: PlayerHistory, contribution_rate: float) -> Action:
        """Special logic for the final round."""
        if contribution_rate >= self.cooperation_threshold:
            if len(history.my_actions) > 0 and history.my_actions[-1]:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_10(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Cooperates in the first round, then uses a threshold-based reciprocal rule
    in subsequent rounds. The threshold (k-1)/(n*2) represents a breakeven point
    where cooperation yields positive expected returns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[previous_round_idx]
        opponents_prev_actions = history.opponent_actions[previous_round_idx, :]
        total_cooperators = int(my_prev_action) + int(np.sum(opponents_prev_actions))
        coop_rate = total_cooperators / self.n_players
        threshold = (self.k - 1.0) / (self.n_players * 2.0)
        if coop_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_11(BaseStrategy):
    """
    Adaptive Contribution Strategy for Public Goods Games using Conditional Reciprocity with Decay.
    
    Core logic:
    - Round 1: Always cooperate to establish baseline
    - Rounds 2 to r-1: Cooperate if observed cooperation rate meets dynamic threshold
    - Last round: Always defect (no future rounds for reciprocity)
    - Uses 2-round moving average for volatile opponent detection
    - Adjusts threshold based on number of players (more lenient for small n)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.base_threshold = self.k / self.n_players
        if self.n_players <= 3:
            self.adjusted_threshold = self.base_threshold * 0.9
        else:
            self.adjusted_threshold = self.base_threshold * 0.85

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        cooperation_rate = self._get_cooperation_rate(history, current_round)
        if cooperation_rate >= self.adjusted_threshold:
            return Action.C
        else:
            return Action.D

    def _get_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate cooperation rate from previous round(s).
        Uses 2-round moving average if available to smooth volatility.
        """
        if current_round < 1:
            return 0.0
        prev_round_cooperators = int(np.sum(history.opponent_actions[current_round - 1, :]))
        if current_round >= 2:
            prev_prev_round_cooperators = int(np.sum(history.opponent_actions[current_round - 2, :]))
            avg_cooperators = (prev_round_cooperators + prev_prev_round_cooperators) / 2.0
        else:
            avg_cooperators = float(prev_round_cooperators)
        cooperation_rate = avg_cooperators / self.n_players
        return cooperation_rate

class Strategy_COLLECTIVE_12(BaseStrategy):
    """
    Adaptive Collective Strategy for Repeated Public Goods Game.
    
    Balances three objectives: (1) detecting and exploiting defectors, 
    (2) rewarding cooperators to sustain contributions, and (3) maximizing 
    collective welfare when conditions permit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        n_opponents = self.n_players - 1
        coop_rates = np.zeros(n_opponents)
        for opponent_idx in range(n_opponents):
            opponent_contributions = history.opponent_actions[:round_number, opponent_idx]
            rounds_played = round_number
            if rounds_played > 0:
                coop_rates[opponent_idx] = np.sum(opponent_contributions) / rounds_played
            else:
                coop_rates[opponent_idx] = 0.0
        reliable_cooperators = np.sum(coop_rates >= 0.75)
        chronic_defectors = np.sum(coop_rates < 0.25)
        inconsistent_players = n_opponents - reliable_cooperators - chronic_defectors
        if reliable_cooperators >= n_opponents * 0.6:
            return Action.C
        if inconsistent_players > 0:
            expected_contributions = reliable_cooperators + inconsistent_players * 0.5
            expected_benefit = self.k / self.n_players * expected_contributions
            if expected_benefit >= 0.5:
                return Action.C
            else:
                return Action.D
        if chronic_defectors > 0 and reliable_cooperators == 0:
            return Action.D
        if reliable_cooperators == n_opponents:
            return Action.C
        expected_contributions = reliable_cooperators
        expected_benefit = self.k / self.n_players * expected_contributions
        if expected_benefit >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_13(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game.
    
    Treats the game as mutual benefit discovery. Starts cooperative, conditions on
    observed group cooperation levels, and adapts with thresholds at 0.6 and 0.3.
    Defects in final round unless cooperation has been exceptionally strong (≥0.8).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if self.n_rounds == 1:
            return Action.D
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            avg_coop = self._compute_average_cooperation(history, current_round)
            if avg_coop >= 0.8:
                return Action.C
            return Action.D
        avg_coop = self._compute_average_cooperation(history, current_round)
        my_coop = self._compute_own_cooperation(history, current_round)
        if avg_coop >= 0.6:
            return Action.C
        elif avg_coop >= 0.3:
            return Action.D
        else:
            if my_coop >= 0.6 and avg_coop < 0.3:
                return Action.C
            return Action.D

    def _compute_average_cooperation(self, history: PlayerHistory, current_round: int) -> float:
        """
        Compute the average cooperation ratio across all opponents up to (but not including) current_round.
        Returns value in [0, 1]. Handles edge case of division by zero.
        """
        if current_round == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:current_round, :]
        total_contributions_per_opponent = np.sum(opponent_actions, axis=0)
        rounds_played = current_round
        cooperation_ratios = total_contributions_per_opponent / rounds_played if rounds_played > 0 else 0.0
        avg_coop = float(np.mean(cooperation_ratios)) if len(cooperation_ratios) > 0 else 0.0
        return avg_coop

    def _compute_own_cooperation(self, history: PlayerHistory, current_round: int) -> float:
        """
        Compute this player's own cooperation ratio up to (but not including) current_round.
        Returns value in [0, 1].
        """
        if current_round == 0:
            return 0.0
        my_actions = history.my_actions[:current_round]
        total_contributions = np.sum(my_actions)
        rounds_played = current_round
        my_coop = float(total_contributions) / rounds_played if rounds_played > 0 else 0.0
        return my_coop

class Strategy_COLLECTIVE_14(BaseStrategy):
    """
    Adaptive Conditional Cooperation Strategy for N-Player Public Goods Games.
    
    Cooperates conditionally based on recent group cooperation rates and reciprocal 
    contribution patterns. Uses a threshold-based decision rule with reciprocity modifiers
    and collapse detection to maximize group welfare while remaining robust to defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.n_rounds = game_description.n_rounds
        self.gcr_history = []
        self.consecutive_zero_gcr = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        prev_round_idx = round_num - 1
        prev_cooperators = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        current_gcr = prev_cooperators / self.n_players
        self.gcr_history.append(current_gcr)
        if current_gcr == 0:
            self.consecutive_zero_gcr += 1
        else:
            self.consecutive_zero_gcr = 0
        if self.consecutive_zero_gcr >= 2:
            if current_gcr < 0.4:
                return Action.D
        gcr_recent = self._calculate_recent_average_gcr()
        if gcr_recent > 0.6:
            return Action.C
        if gcr_recent < 0.3:
            return Action.D
        threshold = self._calculate_threshold()
        if current_gcr >= threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_average_gcr(self) -> float:
        """
        Calculate average GCR over the last 3 rounds.
        If fewer than 3 rounds have been played, average what's available.
        """
        if len(self.gcr_history) == 0:
            return 0.5
        lookback = min(3, len(self.gcr_history))
        recent_gcrs = self.gcr_history[-lookback:]
        return np.mean(recent_gcrs)

    def _calculate_threshold(self) -> float:
        """
        Calculate the cooperation threshold: (n-k) / (n-1)
        
        This represents the tipping point where my contribution improves collective welfare.
        """
        threshold = (self.n_players - self.k) / (self.n_players - 1)
        threshold = max(0.0, min(1.0, threshold))
        return threshold

class Strategy_COLLECTIVE_15(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Strategic Defection.
    Uses threshold-based reciprocity with dynamic threshold adjustment,
    special handling for first/final rounds, and protection against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.historical_contributions = []
        self.low_coop_streak = 0
        self.current_threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        prev_round_idx = round_num - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        total_cooperators = int(my_prev_action) + np.sum(opponent_prev_actions)
        avg_contribution_rate = total_cooperators / self.n_players
        self.historical_contributions.append(avg_contribution_rate)
        if avg_contribution_rate == 0:
            self.low_coop_streak += 1
            if self.low_coop_streak >= 3 or round_num >= 5:
                return Action.D
        else:
            self.low_coop_streak = 0
        if avg_contribution_rate > 0.75:
            self.current_threshold = min(0.9, self.current_threshold + 0.1)
            return Action.C
        if len(self.historical_contributions) >= 2:
            recent_avg = np.mean(self.historical_contributions[-2:])
        else:
            recent_avg = avg_contribution_rate
        if round_num <= 3:
            self.current_threshold = 0.5
        elif len(self.historical_contributions) > 0:
            hist_avg = np.mean(self.historical_contributions)
            self.current_threshold = max(0.25, hist_avg - 0.15)
        else:
            self.current_threshold = 0.5
        if round_num == self.n_rounds - 2:
            if recent_avg > self.current_threshold:
                return Action.C
            else:
                return Action.D
        if round_num == self.n_rounds - 1:
            final_prev_contribution = avg_contribution_rate
            if final_prev_contribution >= 0.4:
                return Action.C
            else:
                return Action.D
        if recent_avg > self.current_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_16(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Decay strategy for N-Player Public Goods Game.
    
    Cooperates conditionally based on historical reciprocity rates, with escalating thresholds
    in the final 3 rounds and mandatory defection in the final round. Includes isolation detection
    and early collapse handling.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._isolation_detected = False
        self._unanimous_cooperation_count = 0
        self._early_collapse_detected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_round = state.round_number
        all_past_actions = np.concatenate([history.my_actions[:current_round], history.opponent_actions[:current_round, :].flatten()])
        total_contributions = np.sum(all_past_actions)
        total_actions = len(all_past_actions)
        if total_actions > 0:
            historical_coop_rate = total_contributions / total_actions
        else:
            historical_coop_rate = 0.0
        if current_round == 3 and historical_coop_rate < 0.3:
            self._early_collapse_detected = True
        if self._early_collapse_detected:
            return Action.D
        if current_round > 0:
            my_past_actions = history.my_actions[:current_round]
            opponent_contributions = np.sum(history.opponent_actions[:current_round, :], axis=1)
            for round_idx in range(current_round):
                if my_past_actions[round_idx] and opponent_contributions[round_idx] == 0:
                    self._isolation_detected = True
                    break
        if self._isolation_detected:
            return Action.D
        if current_round >= 3:
            recent_rounds = min(3, current_round)
            recent_my_actions = history.my_actions[-recent_rounds:]
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            all_cooperated_recently = np.all(recent_my_actions) and np.all(recent_opponent_actions)
            if all_cooperated_recently:
                self._unanimous_cooperation_count += 1
            else:
                self._unanimous_cooperation_count = 0
        rounds_remaining = n_rounds - current_round
        if rounds_remaining <= 3:
            if rounds_remaining == 3:
                threshold = 0.7
            elif rounds_remaining == 2:
                threshold = 0.8
            else:
                return Action.D
        else:
            threshold = 0.6
            if self._unanimous_cooperation_count >= 3:
                threshold = 0.5
        if current_round > 0:
            last_round_opponent_contributions = np.sum(history.opponent_actions[current_round - 1, :])
            if history.my_actions[current_round - 1] and last_round_opponent_contributions == 0:
                return Action.D
        if historical_coop_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_17(BaseStrategy):
    """
    Adaptive Conditional Contribution strategy for N-Player Public Goods Game.
    
    Cooperates based on observed cooperation rates against dynamic thresholds,
    with special handling for initialization, mid-game, and end-game phases.
    Tracks individual player behavior and adjusts strategy based on collective dynamics.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.coop_rates = []
        self.consecutive_low_rounds = 0

    def _compute_threshold(self, round_number: int) -> float:
        """
        Dynamic threshold: max(0.3, 1 - (round / r) * 0.5)
        Starts generous at ~0.3, becomes more demanding toward 0.5
        """
        if self.n_rounds <= 1:
            return 0.3
        threshold = 1.0 - round_number / self.n_rounds * 0.5
        return max(0.3, threshold)

    def _get_cooperation_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """Get cooperation rate in a specific round"""
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0.0
        cooperators = np.sum(history.opponent_actions[round_idx, :])
        return float(cooperators) / float(self.n_players - 1)

    def _get_filtered_coop_rate(self) -> float:
        """Apply moving average filter over last 3 rounds (or available)"""
        if not self.coop_rates:
            return 0.0
        recent = self.coop_rates[-3:]
        return float(np.mean(recent))

    def _detect_declining_trend(self) -> bool:
        """Check if cooperation is declining over recent rounds"""
        if len(self.coop_rates) < 2:
            return False
        return self.coop_rates[-1] < self.coop_rates[-2]

    def _count_consistent_cooperators(self, history: PlayerHistory, current_round: int) -> int:
        """Count opponents who have cooperated in all rounds so far"""
        if current_round == 0:
            return 0
        consistent = 0
        for opponent_idx in range(self.n_players - 1):
            all_cooperated = True
            for round_idx in range(current_round):
                if not history.opponent_actions[round_idx, opponent_idx]:
                    all_cooperated = False
                    break
            if all_cooperated:
                consistent += 1
        return consistent

    def _count_consistent_defectors(self, history: PlayerHistory, current_round: int) -> int:
        """Count opponents who have never cooperated"""
        if current_round == 0:
            return 0
        consistent = 0
        for opponent_idx in range(self.n_players - 1):
            never_cooperated = True
            for round_idx in range(current_round):
                if history.opponent_actions[round_idx, opponent_idx]:
                    never_cooperated = False
                    break
            if never_cooperated:
                consistent += 1
        return consistent

    def _was_only_cooperator(self, history: PlayerHistory, round_idx: int) -> bool:
        """Check if this player was the only cooperator in a round"""
        if round_idx < 0 or round_idx >= len(history.my_actions):
            return False
        if not history.my_actions[round_idx]:
            return False
        cooperators = np.sum(history.opponent_actions[round_idx, :])
        return cooperators == 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        prev_coop_rate = self._get_cooperation_rate(history, round_num - 1)
        self.coop_rates.append(prev_coop_rate)
        if len(self.coop_rates) > 3:
            self.coop_rates.pop(0)
        filtered_rate = self._get_filtered_coop_rate()
        threshold = self._compute_threshold(round_num)
        if self._was_only_cooperator(history, round_num - 1):
            return Action.D
        consistent_defectors = self._count_consistent_defectors(history, round_num)
        if consistent_defectors == self.n_players - 1:
            return Action.D
        if filtered_rate < 0.2:
            self.consecutive_low_rounds += 1
            if self.consecutive_low_rounds >= 1:
                return Action.D
        else:
            self.consecutive_low_rounds = 0
        consistent_cooperators = self._count_consistent_cooperators(history, round_num)
        if consistent_cooperators <= 2 and filtered_rate < 0.4:
            return Action.D
        if round_num >= self.n_rounds - 2:
            if filtered_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if filtered_rate >= threshold:
            return Action.C
        elif filtered_rate < threshold and self._detect_declining_trend():
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_18(BaseStrategy):
    """
    Adaptive Conditional Cooperation Strategy for N-Player Public Goods Game.
    
    Cooperates in round 1, adapts based on observed cooperation rates in rounds 2 to r-1,
    and defects in the final round. Uses thresholds at 0.5 and 0.25 cooperation rates
    to balance collective welfare with protection against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round_idx = state.round_number - 1
        my_contribution = 1 if history.my_actions[prev_round_idx] else 0
        opponent_cooperators = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        total_cooperators = my_contribution + opponent_cooperators
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.25:
            prob_cooperate = 2.0 * cooperation_rate
            if random.random() < prob_cooperate:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_19(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare through reciprocal generosity, graduated punishment,
    recovery pathways, and temporal adaptation. Classifies opponents as reliable cooperators,
    conditional cooperators, or defectors, and adjusts contribution decisions based on
    community cooperation levels and own cooperation history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        own_contributions = np.sum(history.my_actions[:current_round])
        own_cooperation_rate = own_contributions / current_round if current_round > 0 else 0.0
        opponent_cooperation_rates = np.zeros(self.n_players - 1)
        for opponent_idx in range(self.n_players - 1):
            opponent_contributions = np.sum(history.opponent_actions[:current_round, opponent_idx])
            opponent_cooperation_rates[opponent_idx] = opponent_contributions / current_round if current_round > 0 else 0.0
        reliable_cooperators = np.sum(opponent_cooperation_rates >= 0.8)
        conditional_cooperators = np.sum((opponent_cooperation_rates >= 0.4) & (opponent_cooperation_rates < 0.8))
        defectors = np.sum(opponent_cooperation_rates < 0.4)
        avg_opponent_cooperation = np.mean(opponent_cooperation_rates)
        cooperation_threshold = 0.5
        conditional_threshold = 0.5
        if self.k > self.n_players - 0.5:
            cooperation_threshold = max(0.35, cooperation_threshold - 0.15)
            conditional_threshold = max(0.35, conditional_threshold - 0.15)
        if self.n_rounds <= 3 and current_round == self.n_rounds - 2:
            pass
        if own_cooperation_rate >= 0.8:
            if avg_opponent_cooperation >= cooperation_threshold:
                return Action.C
            else:
                return Action.D
        elif own_cooperation_rate >= 0.4:
            cooperating_opponents = reliable_cooperators + conditional_cooperators
            total_opponents = self.n_players - 1
            if total_opponents > 0:
                cooperator_fraction = cooperating_opponents / total_opponents
                if cooperator_fraction >= conditional_threshold:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        elif self.n_players - 1 > 0:
            reliable_fraction = reliable_cooperators / (self.n_players - 1)
            if reliable_fraction > 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_20(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Games.
    
    Balances cooperation with protection against exploitation by:
    - Starting cooperative to establish mutual benefit
    - Adapting reciprocation based on group contribution rates
    - Adjusting for endgame and special parameter conditions
    - Prioritizing collective welfare over individual maximum payoff
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        prev_round_idx = round_num - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        total_contributions = int(my_prev_action) + int(np.sum(opponent_prev_actions))
        contrib_rate = total_contributions / self.n
        threshold_multiplier = 0.8 if self.n <= 3 else 1.0
        is_weak_multiplier = self.k < 1.5
        if round_num == self.r - 1:
            if contrib_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if round_num == self.r - 2:
            if contrib_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        high_threshold = threshold_multiplier * ((self.n - 1) / self.n) * 0.5
        medium_threshold = threshold_multiplier * ((self.n - 1) / self.n) * 0.25
        if contrib_rate == 0.0 and round_num > 0:
            if round_num > 1:
                prev_prev_idx = round_num - 2
                prev_total_contributions = int(history.my_actions[prev_prev_idx]) + int(np.sum(history.opponent_actions[prev_prev_idx, :]))
                if prev_total_contributions == 0:
                    return Action.D
            return Action.C
        if contrib_rate >= high_threshold:
            return Action.C
        elif medium_threshold < contrib_rate < high_threshold:
            if is_weak_multiplier:
                if contrib_rate >= 0.6:
                    return Action.C
                else:
                    return Action.D
            else:
                expected_externality = self.k / self.n * contrib_rate
                if expected_externality >= 0.6:
                    return Action.C
                else:
                    return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_21(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Promotes cooperation when conditionally sustainable while protecting against
    exploitation. Uses cooperation health metrics to dynamically adjust behavior
    across rounds, with special handling for final round backward induction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.was_deceived_last_round = False
        self.consecutive_high_cooperation_rounds = 0
        self.consecutive_low_cooperation_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        return self._decide_main_phase(state, history)

    def _decide_main_phase(self, state: GameState, history: PlayerHistory) -> Action:
        """
        Main decision logic for rounds 1 through r-2.
        Uses cooperation health index and personal deception tracking.
        """
        last_round_idx = state.round_number - 1
        last_round_opponent_actions = history.opponent_actions[last_round_idx, :]
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = int(np.sum(last_round_opponent_actions))
        total_cooperators = opponent_cooperators + int(my_last_action)
        avg_contribution_rate = total_cooperators / self.n_players
        was_i_cooperating = bool(my_last_action)
        were_others_defecting = opponent_cooperators < self.n_players - 1
        self.was_deceived_last_round = was_i_cooperating and were_others_defecting
        if self.n_players <= 3:
            high_threshold = 0.5
            medium_threshold = 0.2
        else:
            high_threshold = 0.55
            medium_threshold = 0.2
        if avg_contribution_rate >= high_threshold:
            if self.was_deceived_last_round:
                return Action.D
            else:
                self.was_deceived_last_round = False
                self.consecutive_high_cooperation_rounds += 1
                self.consecutive_low_cooperation_rounds = 0
                return Action.C
        elif avg_contribution_rate >= medium_threshold:
            self.consecutive_high_cooperation_rounds = 0
            self.consecutive_low_cooperation_rounds += 1
            return Action.D
        else:
            self.consecutive_high_cooperation_rounds = 0
            self.consecutive_low_cooperation_rounds += 1
            if self.consecutive_high_cooperation_rounds >= 2:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_22(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare by identifying and reinforcing cooperation clusters
    while remaining robust to defection and free-riding. Balances reciprocity with pragmatism
    through adaptive thresholds and round-specific decision logic.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.consecutive_unanimous_defection = 0
        self.regime_change_detected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return self._final_round_decision(history)
        return self._adaptive_phase_decision(history, round_num)

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Final round decision: cooperate if average cooperation >= 50%, else defect."""
        avg_cooperation = self._calculate_avg_opponent_cooperation(history)
        if avg_cooperation >= 0.5:
            return Action.C
        return Action.D

    def _adaptive_phase_decision(self, history: PlayerHistory, round_num: int) -> Action:
        """Adaptive phase: rounds 1 through r-2."""
        coop_rate, cooperators, conditionals, defectors = self._categorize_opponents(history)
        if defectors == self.n_players - 1 and cooperators == 0:
            self.consecutive_unanimous_defection += 1
            if self.consecutive_unanimous_defection >= 3:
                return Action.D
        else:
            self.consecutive_unanimous_defection = 0
        regime_change = self._detect_regime_change(history)
        if regime_change:
            self.regime_change_detected = True
        threshold_coop = self._calculate_cooperation_threshold()
        prop_cooperators = cooperators / (self.n_players - 1) if self.n_players > 1 else 0
        prop_conditionals = conditionals / (self.n_players - 1) if self.n_players > 1 else 0
        if prop_cooperators > threshold_coop:
            return Action.C
        if prop_conditionals >= 0.2 and self._is_payoff_trending_positive(history):
            return Action.C
        if defectors > (self.n_players - 1) / 2 and self._is_payoff_above_median(history):
            return Action.D
        if defectors > (self.n_players - 1) / 2 and (not self._is_payoff_above_median(history)):
            return Action.C
        return Action.C

    def _categorize_opponents(self, history: PlayerHistory) -> tuple:
        """
        Categorize opponents by contribution rate.
        Returns: (coop_rate, cooperator_count, conditional_count, defector_count)
        """
        if history.opponent_actions.shape[0] == 0:
            return (0.0, 0, 0, self.n_players - 1)
        contribution_rates = np.mean(history.opponent_actions, axis=0)
        cooperators = np.sum(contribution_rates >= 0.75)
        defectors = np.sum(contribution_rates < 0.25)
        conditionals = np.sum((contribution_rates >= 0.25) & (contribution_rates < 0.75))
        avg_coop_rate = np.mean(contribution_rates)
        return (avg_coop_rate, int(cooperators), int(conditionals), int(defectors))

    def _detect_regime_change(self, history: PlayerHistory) -> bool:
        """
        Detect if cooperation rate dropped >40 percentage points in a single round.
        """
        if history.opponent_actions.shape[0] < 2:
            return False
        prev_round_coop = np.mean(history.opponent_actions[-2, :])
        curr_round_coop = np.mean(history.opponent_actions[-1, :])
        change = prev_round_coop - curr_round_coop
        return change > 0.4

    def _calculate_cooperation_threshold(self) -> float:
        """
        Calculate dynamic cooperation threshold based on multiplier k.
        """
        base_threshold = max(0.3, self.k / self.n_players)
        if self.k <= 1.5:
            base_threshold = max(base_threshold, 0.5)
        if self.k >= 2.0 / 3.0 * self.n_players:
            base_threshold = min(base_threshold, 0.25)
        if self.regime_change_detected:
            base_threshold = min(base_threshold * 1.2, 1.0)
        return base_threshold

    def _is_payoff_trending_positive(self, history: PlayerHistory) -> bool:
        """
        Check if recent payoff trend is positive (last 2 rounds improving or stable positive).
        """
        if history.my_payoffs.shape[0] < 2:
            return np.mean(history.my_payoffs) > 0
        recent_payoffs = history.my_payoffs[-2:]
        return recent_payoffs[-1] >= recent_payoffs[-2]

    def _is_payoff_above_median(self, history: PlayerHistory) -> bool:
        """
        Check if my cumulative payoff ranks in top half relative to opponents.
        """
        my_total = np.sum(history.my_payoffs)
        opponent_totals = np.sum(history.opponent_payoffs, axis=0)
        if opponent_totals.shape[0] == 0:
            return True
        median_opponent_payoff = np.median(opponent_totals)
        return my_total >= median_opponent_payoff

    def _calculate_avg_opponent_cooperation(self, history: PlayerHistory) -> float:
        """
        Calculate average cooperation rate across all opponents over all rounds.
        """
        if history.opponent_actions.shape[0] == 0:
            return 0.0
        return np.mean(history.opponent_actions)

class Strategy_COLLECTIVE_23(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Decay for N-Player Public Goods Game.
    
    Phase 1 (Rounds 1-2): Contribute to establish cooperation baseline.
    Phase 2 (Rounds 3 to r-2): Adaptively contribute based on historical cooperation rate.
    Phase 3 (Final round): Defect due to no future payoff incentive.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number < 2:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        coop_rate = self._calculate_cooperation_rate(history, round_number)
        if round_number >= 2:
            recent_coop_rate = self._calculate_recent_cooperation_rate(history, round_number)
            if coop_rate > 0 and recent_coop_rate < coop_rate * 0.8:
                if random.random() < coop_rate:
                    return Action.C
                return Action.D
        if coop_rate >= 0.6:
            return Action.C
        elif coop_rate > 0.3:
            if random.random() < coop_rate:
                return Action.C
            return Action.D
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the historical cooperation rate across all players from round 0 to current_round-1.
        """
        if current_round == 0:
            return 0.0
        total_cooperations = 0
        total_possible = 0
        for round_idx in range(current_round):
            total_cooperations += int(history.my_actions[round_idx])
            total_possible += 1
        for round_idx in range(current_round):
            for player_idx in range(self.n_players - 1):
                total_cooperations += int(history.opponent_actions[round_idx, player_idx])
                total_possible += 1
        if total_possible == 0:
            return 0.0
        return total_cooperations / total_possible

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate cooperation rate for the most recent round only (for decline detection).
        """
        if current_round == 0:
            return 0.0
        most_recent_round = current_round - 1
        total_cooperations = 0
        total_possible = 0
        total_cooperations += int(history.my_actions[most_recent_round])
        total_possible += 1
        for player_idx in range(self.n_players - 1):
            total_cooperations += int(history.opponent_actions[most_recent_round, player_idx])
            total_possible += 1
        if total_possible == 0:
            return 0.0
        return total_cooperations / total_possible

class Strategy_COLLECTIVE_24(BaseStrategy):
    """
    Collective Strategy for Public Goods Game using conditional cooperation with adaptive thresholds.
    
    Prioritizes sustainable collective welfare while remaining robust to defection.
    Uses dynamic thresholds that adapt over time and allows recovery from cooperation breakdowns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == 1:
            self.defection_streak = 0
            return Action.C
        prev_round_idx = state.round_number - 1
        n_players = self.game_description.n_players
        opponent_cooperators = np.sum(history.opponent_actions[prev_round_idx, :])
        own_cooperation = 1 if history.my_actions[prev_round_idx] else 0
        total_cooperators = opponent_cooperators + own_cooperation
        cooperation_rate = total_cooperators / n_players
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        threshold = max(0.4, 1 - current_round / total_rounds * 0.3)
        improvement_detected = False
        if current_round >= 2:
            prev_prev_round_idx = current_round - 2
            prev_prev_cooperators = np.sum(history.opponent_actions[prev_prev_round_idx, :])
            prev_prev_own = 1 if history.my_actions[prev_prev_round_idx] else 0
            prev_prev_total = prev_prev_cooperators + prev_prev_own
            prev_prev_rate = prev_prev_total / n_players
            improvement = cooperation_rate - prev_prev_rate
            if improvement >= 0.15:
                improvement_detected = True
                self.defection_streak = 0
        if current_round == total_rounds - 1:
            if cooperation_rate >= threshold:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= threshold:
            self.defection_streak = 0
            return Action.C
        elif improvement_detected:
            self.defection_streak = 0
            return Action.C
        else:
            self.defection_streak += 1
            if self.defection_streak >= 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_25(BaseStrategy):
    """
    Collective Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation that adapts to observed 
    group behavior, while maintaining individual rationality as a safeguard against exploitation.
    
    Decision rules:
    - Round 1: COOPERATE (signal good faith)
    - Rounds 2 to r-1: Adaptive conditional cooperation based on previous round cooperation rate
    - Final round: DEFECT unless previous cooperation rate ≥ 0.7
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        prev_round_idx = round_number - 1
        prev_cooperators_opponents = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        my_prev_action = int(history.my_actions[prev_round_idx])
        total_prev_cooperators = prev_cooperators_opponents + my_prev_action
        cooperation_rate = total_prev_cooperators / self.n_players
        if round_number == self.n_rounds - 1:
            if cooperation_rate >= 0.7:
                return Action.C
            else:
                return Action.D
        num_defectors = self.n_players - total_prev_cooperators
        if num_defectors == 1:
            return Action.C
        if total_prev_cooperators == 0:
            return Action.D
        if total_prev_cooperators == self.n_players - 1 and my_prev_action == 0:
            return Action.C
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_26(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Decay.
    
    Cooperates based on whether the observed cooperation rate in the previous round
    meets the breakeven threshold (k-1)/k, with special handling for early rounds
    and end-game rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.breakeven_threshold = (game_description.k - 1) / game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_num == 0:
            return Action.C
        if round_num <= 2:
            return Action.C
        if round_num >= n_rounds - 2:
            return self._final_rounds_decision(history, round_num)
        return self._core_decision(history, round_num)

    def _core_decision(self, history: PlayerHistory, round_num: int) -> Action:
        """
        Apply core decision rule: cooperate if recent cooperation rate >= threshold.
        Uses exponential weighting (recent rounds 1.5x heavier).
        """
        weighted_coop_rate = self._calculate_weighted_cooperation_rate(history, round_num)
        if weighted_coop_rate >= self.breakeven_threshold:
            return Action.C
        return Action.D

    def _calculate_weighted_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate cooperation rate with exponential weight on recent rounds.
        Recent rounds weighted 1.5x more heavily.
        """
        cooperators_per_round = np.sum(history.opponent_actions[:round_num, :], axis=1)
        total_cooperators_including_self = cooperators_per_round + history.my_actions[:round_num].astype(int)
        total_possible = self.game_description.n_players
        coop_rates = total_cooperators_including_self / total_possible
        weights = np.ones(round_num)
        weights[-1] = 1.5
        if round_num >= 2:
            weights[-2] = 1.5
        weights = weights / np.sum(weights)
        weighted_rate = np.sum(coop_rates * weights)
        return weighted_rate

    def _final_rounds_decision(self, history: PlayerHistory, round_num: int) -> Action:
        """
        Final 2 rounds: cooperate only if cooperation rate has been >= threshold
        in the last 3 rounds.
        """
        lookback_rounds = min(3, round_num)
        start_idx = round_num - lookback_rounds
        cooperators_per_round = np.sum(history.opponent_actions[start_idx:round_num, :], axis=1)
        total_cooperators_including_self = cooperators_per_round + history.my_actions[start_idx:round_num].astype(int)
        coop_rates = total_cooperators_including_self / self.game_description.n_players
        avg_coop_rate = np.mean(coop_rates)
        if avg_coop_rate >= self.breakeven_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_27(BaseStrategy):
    """
    Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare by maintaining contribution levels that benefit the group,
    while protecting against exploitation through adaptive defection thresholds.
    Uses Collective Health Index (CHI) to guide decisions, with special handling for
    the last round and persistent defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.memory_window = max(5, self.n_rounds // 4)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        chi = self._calculate_chi(history, current_round)
        if self._is_persistent_defector(history, current_round):
            return Action.D
        threshold_high = self.k / 2
        threshold_low = self.k / 4
        if chi >= threshold_high:
            return Action.C
        elif chi >= threshold_low:
            probability = chi / threshold_high
            if random.random() < probability:
                return Action.C
            return Action.D
        else:
            return Action.D

    def _calculate_chi(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate Collective Health Index (CHI).
        CHI = (average contribution rate across all players) × k
        """
        if current_round <= 2:
            if current_round == 0:
                return self.k
            history_length = current_round
            my_contributions = np.sum(history.my_actions[:history_length])
            opponent_contributions = np.sum(history.opponent_actions[:history_length, :])
            total_contributions = my_contributions + opponent_contributions
            total_actions = self.n_players * history_length
            if total_actions == 0:
                return self.k
            avg_contribution_rate = total_contributions / total_actions
            chi = avg_contribution_rate * self.k
            return chi
        start_idx = max(0, current_round - self.memory_window)
        window_length = current_round - start_idx
        my_contributions = np.sum(history.my_actions[start_idx:current_round])
        opponent_contributions = np.sum(history.opponent_actions[start_idx:current_round, :])
        total_contributions = my_contributions + opponent_contributions
        total_actions = self.n_players * window_length
        if total_actions == 0:
            return self.k
        avg_contribution_rate = total_contributions / total_actions
        chi = avg_contribution_rate * self.k
        contribution_rates_per_round = []
        for round_idx in range(start_idx, current_round):
            round_contributions = history.my_actions[round_idx] + np.sum(history.opponent_actions[round_idx, :])
            round_rate = round_contributions / self.n_players
            contribution_rates_per_round.append(round_rate)
        if len(contribution_rates_per_round) >= 2:
            rates_array = np.array(contribution_rates_per_round)
            variance = np.var(rates_array)
            if variance > 0.5:
                avg_rate = np.mean(rates_array)
                chi = avg_rate * self.k
        return chi

    def _is_persistent_defector(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Check if any opponent is a persistent defector.
        A persistent defector has contributed 0% in the last m rounds.
        If so, always defect against them.
        """
        if current_round < 1:
            return False
        window_start = max(0, current_round - self.memory_window)
        window_length = current_round - window_start
        if window_length == 0:
            return False
        for opponent_idx in range(self.n_players - 1):
            opponent_contributions = np.sum(history.opponent_actions[window_start:current_round, opponent_idx])
            if opponent_contributions == 0:
                return True
        return False

class Strategy_COLLECTIVE_28(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game using conditional reciprocity
    with progressive commitment. Maximizes collective welfare by encouraging cooperation
    through adaptive thresholds while remaining resilient against free-riders.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        rounds_remaining = self.n_rounds - round_num
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        prev_round_cooperators = int(np.sum(opponent_actions[round_num - 1, :]))
        if my_actions[round_num - 1]:
            prev_round_cooperators += 1
        prev_contribution_rate = prev_round_cooperators / self.n_players
        all_past_cooperators = int(np.sum(my_actions[:round_num]))
        all_past_cooperators += int(np.sum(opponent_actions[:round_num, :]))
        total_past_actions = round_num * self.n_players
        hist_contribution_rate = all_past_cooperators / total_past_actions if total_past_actions > 0 else 0.0
        if round_num >= 2:
            prev_prev_round_cooperators = int(np.sum(opponent_actions[round_num - 2, :]))
            if my_actions[round_num - 2]:
                prev_prev_round_cooperators += 1
            prev_prev_contribution_rate = prev_prev_round_cooperators / self.n_players
            decline = prev_prev_contribution_rate - prev_contribution_rate
            if decline > 0.25:
                return Action.D
        if round_num == self.n_rounds - 1:
            if prev_contribution_rate > 0.5:
                return Action.C
            else:
                return Action.D
        if rounds_remaining in [2, 3]:
            if prev_contribution_rate >= 0.6:
                return Action.C
            elif prev_contribution_rate < 0.4:
                return Action.D
        if rounds_remaining <= 1:
            return Action.D
        if prev_contribution_rate >= 0.5:
            return Action.C
        if rounds_remaining >= 3 and hist_contribution_rate >= 0.4:
            return Action.C
        if round_num >= 2 and (not my_actions[round_num - 1]):
            if prev_contribution_rate > 0.5:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_29(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Games.
    
    Sustains cooperation through conditional reciprocity based on average contribution rates.
    Defects only when cooperation becomes unsustainable or in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_low_contrib_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        is_final_round = state.round_number == self.game_description.n_rounds - 1
        if is_final_round:
            return Action.D
        prev_round_idx = state.round_number - 1
        my_contrib = 1 if history.my_actions[prev_round_idx] else 0
        opponent_contribs = np.sum(history.opponent_actions[prev_round_idx, :])
        total_contribs = my_contrib + opponent_contribs
        avg_contrib = total_contribs / self.game_description.n_players
        threshold = self.game_description.k / (self.game_description.k + 1)
        if avg_contrib >= threshold:
            self.consecutive_low_contrib_rounds = 0
            return Action.C
        else:
            self.consecutive_low_contrib_rounds += 1
            if self.consecutive_low_contrib_rounds <= 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_30(BaseStrategy):
    """
    Collective Strategy for Public Goods Game with Conditional Contribution and Adaptive Thresholds.
    
    Maximizes collective welfare through conditional cooperation that rewards contribution and punishes
    free-riding. Uses adaptive thresholds that increase over time to enforce sustained commitment, with
    special handling for the final rounds and extreme scenarios.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        prev_round = round_num - 1
        opponent_cooperators = int(np.sum(history.opponent_actions[prev_round, :]))
        my_prev_action = int(history.my_actions[prev_round])
        total_cooperators = opponent_cooperators + my_prev_action
        collective_rate = total_cooperators / self.n_players
        if round_num <= 3:
            threshold = 0.5
        elif round_num >= self.n_rounds - 3:
            threshold = 0.7
        else:
            threshold = 0.6
        if round_num == self.n_rounds - 1:
            if collective_rate >= threshold:
                return Action.C
            else:
                return Action.D
        all_opponents_defected = np.all(~history.opponent_actions[prev_round, :])
        if all_opponents_defected:
            return Action.D
        all_opponents_cooperated = np.all(history.opponent_actions[prev_round, :])
        if all_opponents_cooperated:
            return Action.C
        should_escalate_defect = False
        if round_num >= 3:
            recent_rounds_to_check = min(3, round_num)
            recent_start = round_num - recent_rounds_to_check
            for opp_idx in range(self.n_players - 1):
                opponent_recent_defections = np.sum(~history.opponent_actions[recent_start:round_num, opp_idx])
                if opponent_recent_defections >= 3:
                    if collective_rate < 0.4:
                        should_escalate_defect = True
                        break
        if should_escalate_defect:
            return Action.D
        if collective_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_31(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Contributes in round 1, adapts based on historical cooperation ratio,
    detects coordinated defection, and always contributes in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_streak = 0
        self.prev_cooperation_ratio = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        round_num = state.round_number
        if round_num == 0:
            self.defection_streak = 0
            self.prev_cooperation_ratio = None
            return Action.C
        if round_num == r - 1:
            return Action.C
        total_cooperators = int(np.sum(history.my_actions)) + int(np.sum(history.opponent_actions))
        total_possible = n * round_num
        if total_possible == 0:
            cooperation_ratio = 0.0
        else:
            cooperation_ratio = total_cooperators / total_possible
        threshold = (k - 1) / k
        if self.prev_cooperation_ratio is not None:
            if cooperation_ratio < self.prev_cooperation_ratio:
                self.defection_streak += 1
            else:
                self.defection_streak = 0
        if self.defection_streak >= 4:
            self.prev_cooperation_ratio = cooperation_ratio
            return Action.D
        if cooperation_ratio >= threshold:
            self.defection_streak = 0
            self.prev_cooperation_ratio = cooperation_ratio
            return Action.C
        else:
            if self.defection_streak >= 3:
                self.prev_cooperation_ratio = cooperation_ratio
                return Action.D
            self.prev_cooperation_ratio = cooperation_ratio
            return Action.D

class Strategy_COLLECTIVE_32(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy (ARCS)
    
    Maximizes collective welfare through conditional reciprocity:
    - Round 1: Cooperate to establish trustworthiness
    - Rounds 2 to r-1: Reciprocate based on recent cooperation rate (3-round window)
    - Final round: Defect (no future consequences)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, state.round_number)
        if recent_cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the average cooperation rate of all other players
        over the last 3 rounds (or all available rounds if fewer than 3).
        """
        window_size = 3
        start_round = max(0, current_round - window_size)
        end_round = current_round
        recent_opponent_actions = history.opponent_actions[start_round:end_round, :]
        if recent_opponent_actions.size == 0:
            return 0.0
        cooperation_rate = float(np.mean(recent_opponent_actions))
        return cooperation_rate

class Strategy_COLLECTIVE_33(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Decay (ACC-D)
    
    Maximizes collective welfare through conditional cooperation while protecting against
    exploitation. Cooperates when cooperation rates are sustainable, gracefully degrades
    when cooperation erodes, and defects in the final round and when cooperation is insufficient.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        prev_round_idx = round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        total_cooperators = int(my_prev_action) + int(np.sum(opponent_prev_actions))
        coop_rate = total_cooperators / self.n_players
        upper_threshold = (self.k - 1) / self.k
        lower_threshold = (self.k - 1) / (2 * self.k)
        if coop_rate >= upper_threshold:
            return Action.C
        elif coop_rate >= lower_threshold:
            probability = coop_rate / upper_threshold
            if random.random() < probability:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_34(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Balances optimism about reciprocal cooperation with pragmatic defection
    when the group demonstrates systematic defection. Uses aggregate contribution
    rates to infer collective intent and responds with conditional cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cascade_round = -10

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if round_num == 0:
            return Action.C
        prev_round_idx = round_num - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        total_contributions = int(my_prev_action) + np.sum(opponent_prev_actions)
        contribution_rate = total_contributions / n
        if round_num > 1:
            prev_prev_idx = round_num - 2
            my_prev_prev_action = history.my_actions[prev_prev_idx]
            opponent_prev_prev_actions = history.opponent_actions[prev_prev_idx, :]
            prev_total_contributions = int(my_prev_prev_action) + np.sum(opponent_prev_prev_actions)
            prev_contribution_rate = prev_total_contributions / n
            cascade_drop = prev_contribution_rate - contribution_rate
            if cascade_drop >= 0.3:
                self.last_cascade_round = round_num - 1
        in_cascade_recovery = round_num - self.last_cascade_round == 1
        if round_num == r - 1:
            cooperation_percentage = contribution_rate
            if cooperation_percentage >= 0.75:
                return Action.C
            return Action.D
        rounds_remaining = r - round_num
        high_threshold = 0.45 if rounds_remaining <= 3 else 0.5
        low_threshold = 0.25
        if in_cascade_recovery:
            return Action.C
        if contribution_rate >= high_threshold:
            return Action.C
        if contribution_rate >= low_threshold:
            return Action.C
        if round_num == 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_35(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare by maintaining cooperation when sustainable,
    while protecting against exploitation. Uses a threshold-based reciprocal
    approach with history-weighted momentum and recovery mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.sustainability_threshold = (game_description.k - 1) / game_description.k
        self.last_probe_round = -10

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number <= 2:
            return Action.C
        prev_round_idx = state.round_number - 1
        prev_cooperators = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        prev_contribution_rate = prev_cooperators / self.game_description.n_players
        if state.round_number >= 3:
            recent_rates = []
            for i in range(max(0, state.round_number - 3), state.round_number):
                coop_count = int(np.sum(history.opponent_actions[i, :]))
                recent_rates.append(coop_count / self.game_description.n_players)
            if len(recent_rates) >= 3:
                rate_variance = max(recent_rates) - min(recent_rates)
                if rate_variance <= 0.05:
                    my_last_action = history.my_actions[-1]
                    return Action.C if my_last_action else Action.D
        if state.round_number >= 3:
            last_rate = prev_contribution_rate
            if state.round_number >= 3:
                three_round_avg = 0.0
                count = 0
                for i in range(max(0, state.round_number - 4), state.round_number - 1):
                    if i >= 0:
                        coop_count = int(np.sum(history.opponent_actions[i, :]))
                        three_round_avg += coop_count / self.game_description.n_players
                        count += 1
                if count > 0:
                    three_round_avg /= count
                else:
                    three_round_avg = last_rate
            else:
                three_round_avg = last_rate
            recent_trend = 0.7 * last_rate + 0.3 * three_round_avg
        else:
            recent_trend = prev_contribution_rate
        if abs(recent_trend - self.sustainability_threshold) <= 0.1:
            return Action.C
        if recent_trend > self.sustainability_threshold:
            return Action.C
        else:
            if state.round_number - self.last_probe_round >= 5:
                self.last_probe_round = state.round_number
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_36(BaseStrategy):
    """
    Conditional Contribution Strategy for N-Player Public Goods Game.
    
    Cooperates in round 1 unconditionally. In subsequent rounds, cooperates if and only if
    the average contribution rate in the previous round met or exceeded the threshold (k-1)/k.
    This balances collective benefit-seeking with robustness against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = (game_description.k - 1.0) / game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_idx = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
        opponent_cooperators = np.sum(opponent_actions_prev)
        my_action_prev = history.my_actions[previous_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_action_prev else 0)
        n_players = self.game_description.n_players
        avg_contribution_rate = total_cooperators / n_players
        if avg_contribution_rate >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_37(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy (ATCS) for N-Player Public Goods Game.
    
    Cooperates optimistically in round 1, adapts based on observed cooperation rates
    in rounds 2 to r-1 using a dynamic threshold, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        total_contributions = float(np.sum(history.my_actions) + np.sum(history.opponent_actions))
        total_possible = float(self.game_description.n_players * state.round_number)
        if total_possible == 0:
            cooperation_rate = 0.0
        else:
            cooperation_rate = total_contributions / total_possible
        if state.round_number > 0:
            last_round_others_contributions = float(np.sum(history.opponent_actions[-1, :]))
            if self.game_description.n_players - 1 > 0:
                exploitation_ratio = last_round_others_contributions / (self.game_description.n_players - 1)
            else:
                exploitation_ratio = 0.0
        else:
            exploitation_ratio = 0.0
        threshold = min(0.5, max(0.3, cooperation_rate - 0.1))
        if cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_38(BaseStrategy):
    """
    Collective welfare strategy for N-Player Public Goods Game.
    
    Implements conditional cooperation with:
    - Unconditional cooperation in round 1
    - Unconditional defection in final round
    - Conditional cooperation based on group contribution rate (≥50% threshold)
    - Momentum detection for rising contribution trends
    - Threshold hysteresis to stabilize cooperation at ≥75%
    - Exploitation protection against persistent free-riders (≥80% defection rate)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.momentum_counter = 0
        self.high_cooperation_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == r - 1:
            return Action.D
        prev_round_idx = current_round - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        prev_cooperators = int(my_prev_action) + np.sum(opponent_prev_actions)
        prev_contribution_rate = prev_cooperators / n
        exploit_detected = self._check_exploitation(history, current_round)
        if exploit_detected:
            return Action.D
        momentum_rising = self._check_momentum_rising(history, current_round)
        if self.high_cooperation_round:
            self.high_cooperation_round = False
            return Action.C
        if prev_contribution_rate >= 0.75:
            self.high_cooperation_round = True
            return Action.C
        if momentum_rising and prev_contribution_rate >= 0.4:
            self.momentum_counter += 1
            return Action.C
        else:
            self.momentum_counter = 0
        if prev_contribution_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _check_momentum_rising(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Detect if contributions have been rising for 2+ consecutive rounds.
        Returns True if we should give the benefit of the doubt.
        """
        if current_round < 2:
            return False
        n = self.game_description.n_players
        rates = []
        for round_idx in range(max(0, current_round - 3), current_round):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx, :]
            cooperators = int(my_action) + np.sum(opponent_actions)
            rate = cooperators / n
            rates.append(rate)
        if len(rates) >= 2:
            if rates[-1] > rates[-2]:
                if len(rates) >= 3 and rates[-2] > rates[-3]:
                    return True
                if rates[-2] >= 0.3:
                    return True
        return False

    def _check_exploitation(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Detect persistent free-riders: if any player defected in ≥80% of past rounds
        while others cooperated substantially, flag exploitation and defect.
        """
        if current_round < 2:
            return False
        n = self.game_description.n_players
        past_rounds = current_round
        threshold_defection_rate = 0.8
        min_rounds_to_evaluate = 2
        if past_rounds < min_rounds_to_evaluate:
            return False
        for opp_idx in range(n - 1):
            opp_defections = np.sum(~history.opponent_actions[:past_rounds, opp_idx])
            opp_defection_rate = opp_defections / past_rounds
            if opp_defection_rate >= threshold_defection_rate:
                my_cooperations = np.sum(history.my_actions[:past_rounds])
                my_coop_rate = my_cooperations / past_rounds
                if my_coop_rate >= 0.6:
                    return True
        return False

class Strategy_COLLECTIVE_39(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Balances optimism about cooperation with disciplined responses to defection.
    Tracks collective contribution health and adjusts behavior accordingly.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_counter = 0
        self.low_health_consecutive = 0
        self.permanently_defect = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = state.round_number
        prev_round_idx = current_round - 1
        total_cooperators = sum(history.opponent_actions[prev_round_idx, :]) + (1 if history.my_actions[prev_round_idx] else 0)
        health = total_cooperators / n if n > 0 else 0.0
        if self.permanently_defect:
            return Action.D
        if health < 0.5:
            self.low_health_consecutive += 1
            if self.low_health_consecutive >= 3:
                self.permanently_defect = True
                return Action.D
        else:
            self.low_health_consecutive = 0
        if current_round == r - 1:
            if health >= 0.75:
                return Action.C
            else:
                return Action.D
        if self.defection_counter > 0:
            self.defection_counter -= 1
            return Action.D
        if health >= 0.5:
            return Action.C
        else:
            self.defection_counter = 2
            return Action.D

class Strategy_COLLECTIVE_40(BaseStrategy):
    """
    Collective Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through adaptive reciprocity:
    - Always cooperate in round 1 to bootstrap cooperation
    - In subsequent rounds, cooperate if the proportion of other players who 
      cooperated in the previous round meets or exceeds the threshold (k-1)/k
    - This threshold represents when collective benefit exceeds individual cost
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = (game_description.k - 1) / game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        cooperators_count = int(np.sum(previous_round_opponent_actions))
        other_players_count = self.game_description.n_players - 1
        if other_players_count == 0:
            cooperation_proportion = 0.0
        else:
            cooperation_proportion = cooperators_count / other_players_count
        if cooperation_proportion >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_41(BaseStrategy):
    """
    Adaptive Conditional Cooperation Strategy for N-Player Public Goods Game.
    
    Uses Generous Tit-for-Tat with 50% threshold recovery:
    - Round 1: Always cooperate
    - Rounds 2 to r-1: Cooperate if prior round had ≥50% cooperation rate
    - Final round: Always defect (dominant strategy with no future)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_trend = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        if round_number == n_rounds - 1:
            return Action.D
        if history is None:
            return Action.C
        prev_round_idx = round_number - 1
        opponent_cooperations = history.opponent_actions[prev_round_idx, :].sum()
        my_prev_action = history.my_actions[prev_round_idx]
        total_cooperators = opponent_cooperations + (1 if my_prev_action else 0)
        cooperation_rate = total_cooperators / n_players
        self.cooperation_trend.append(cooperation_rate)
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_42(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game.
    
    Maximizes long-term collective welfare by maintaining cooperative equilibrium
    while robustly detecting and responding to systemic free-riding.
    
    Core mechanism:
    - Always cooperate in early game (rounds 1-3)
    - In mid-game: cooperate if opponent average contribution > 50%, else defect for penalty period
    - In end-game: maintain current position based on established equilibrium
    - Includes recovery mechanism to restart cooperation after penalty periods
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_period_remaining = 0
        self.defection_triggered = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if round_number <= 2:
            return Action.C
        if history is None:
            return Action.C
        if round_number >= n_rounds - 2:
            if self._is_cooperative_equilibrium(history):
                return Action.C
            return Action.D
        if self.defection_period_remaining > 0:
            self.defection_period_remaining -= 1
            return Action.D
        avg_opponent_contribution = self._calculate_avg_opponent_contribution(history)
        if avg_opponent_contribution <= 0.5:
            remaining_rounds = n_rounds - round_number
            penalty_duration = min(3, max(1, remaining_rounds // 4))
            self.defection_period_remaining = penalty_duration - 1
            self.defection_triggered = True
            return Action.D
        return Action.C

    def _calculate_avg_opponent_contribution(self, history: PlayerHistory) -> float:
        """
        Calculate the average contribution rate of all opponents across all rounds played so far.
        Returns a value between 0 and 1.
        """
        opponent_actions = history.opponent_actions
        if opponent_actions.size == 0:
            return 1.0
        total_contributions = np.sum(opponent_actions)
        total_possible = opponent_actions.size
        if total_possible == 0:
            return 1.0
        return float(total_contributions) / float(total_possible)

    def _is_cooperative_equilibrium(self, history: PlayerHistory) -> bool:
        """
        Check if a cooperative equilibrium has been established.
        Returns True if average opponent contribution > 50%.
        """
        avg_opponent_contribution = self._calculate_avg_opponent_contribution(history)
        return avg_opponent_contribution > 0.5

class Strategy_COLLECTIVE_43(BaseStrategy):
    """
    Adaptive Collective Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation, defending against
    free-riders while adapting to observed contribution ecology. Uses group contribution
    rate, personal payoff comparison, and trend signals to make adaptive decisions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        my_last_action = history.my_actions[round_num - 1]
        my_last_payoff = history.my_payoffs[round_num - 1]
        opponent_last_actions = history.opponent_actions[round_num - 1, :]
        opponent_last_payoffs = history.opponent_payoffs[round_num - 1, :]
        total_contributors_last_round = int(np.sum(opponent_last_actions)) + int(my_last_action)
        gcr = total_contributors_last_round / self.n_players
        unanimous_defection_count = 0
        if round_num >= 2:
            for t in range(round_num - 2, round_num):
                contributors_at_t = int(np.sum(history.opponent_actions[t, :])) + int(history.my_actions[t])
                if contributors_at_t == 0:
                    unanimous_defection_count += 1
        if unanimous_defection_count >= 2:
            if gcr <= 0.4:
                return Action.D
        if total_contributors_last_round == 1 and my_last_action:
            return Action.D
        contributor_payoffs = []
        for i, action in enumerate(opponent_last_actions):
            if action:
                contributor_payoffs.append(opponent_last_payoffs[i])
        if my_last_action:
            contributor_payoffs.append(my_last_payoff)
        if len(contributor_payoffs) > 0:
            avg_contributor_payoff = np.mean(contributor_payoffs)
            if avg_contributor_payoff > 0:
                ppc = my_last_payoff / avg_contributor_payoff
            else:
                ppc = 1.0
        else:
            ppc = 1.0
        gcr_trend = self._calculate_trend(history, round_num)
        if gcr >= 0.75 and my_last_payoff >= 0.9 * (np.mean(contributor_payoffs) if len(contributor_payoffs) > 0 else 1.0):
            return Action.C
        if gcr >= 0.5 and gcr_trend == 'improving':
            return Action.C
        if gcr < 0.5 and (not my_last_action):
            return Action.D
        if gcr < 0.5 and my_last_action:
            return Action.C
        if 0.5 <= gcr < 0.75:
            if ppc <= 1.05:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_trend(self, history: PlayerHistory, round_num: int) -> str:
        """
        Calculate trend signal based on GCR over last 3 rounds.
        Returns: "improving", "declining", or "stable"
        """
        if round_num < 2:
            return 'stable'
        gcr_values = []
        for t in range(max(0, round_num - 3), round_num):
            contributors = int(np.sum(history.opponent_actions[t, :])) + int(history.my_actions[t])
            gcr_values.append(contributors / self.n_players)
        if len(gcr_values) < 2:
            return 'stable'
        if gcr_values[-1] > gcr_values[0]:
            return 'improving'
        elif gcr_values[-1] < gcr_values[0]:
            return 'declining'
        else:
            return 'stable'

class Strategy_COLLECTIVE_44(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game.
    
    Implements adaptive contribution based on group cooperation rate with
    time-dependent thresholds. Prioritizes collective welfare through
    conditional cooperation while maintaining resilience against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def _get_threshold(self, round_number: int) -> float:
        """
        Return the cooperation rate threshold for the given round.
        
        - Rounds 0-1: 0.3 (generous initialization)
        - Rounds 2 to n_rounds-3: 0.5 (majority rule)
        - Rounds n_rounds-2 onwards: 0.6 (stricter endgame)
        """
        if round_number <= 1:
            return 0.3
        elif round_number >= self.n_rounds - 2:
            return 0.6
        else:
            return 0.5

    def _get_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate cooperation rate from the previous round.
        
        Returns the proportion of players (including self) who cooperated
        in the most recent completed round.
        """
        if len(history.my_actions) == 0:
            return 0.0
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1, :]
        total_cooperators = int(my_last_action) + np.sum(opponent_last_actions)
        cooperation_rate = total_cooperators / self.n_players
        return float(cooperation_rate)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_rate = self._get_cooperation_rate(history)
        threshold = self._get_threshold(state.round_number)
        if cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_45(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes long-term collective welfare by promoting cooperation when sustainable,
    while protecting against exploitation. Adapts to group cooperation rates and
    adjusts thresholds based on game parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        recent_coop_rate = self._calculate_recent_cooperation_rate(history)
        coop_trend = self._calculate_cooperation_trend(history)
        defection_rate = 1.0 - recent_coop_rate
        base_threshold = (self.k - 1.0) / self.n_players
        threshold = self._adjust_threshold(base_threshold, history, recent_coop_rate)
        is_volatile = self._is_volatile_group(history)
        if is_volatile:
            threshold = max(threshold - 0.1, 0.0)
        if round_num == self.n_rounds - 1:
            if recent_coop_rate >= threshold:
                return Action.C
            else:
                return Action.D
        my_last_action = history.my_actions[-1]
        if defection_rate > 0.5:
            return Action.D
        if recent_coop_rate >= threshold:
            return Action.C
        if recent_coop_rate < threshold and coop_trend < -0.05:
            return Action.D
        if recent_coop_rate >= threshold * 0.9 and coop_trend < 0:
            if my_last_action:
                return Action.C
            else:
                return Action.D
        if 0.0 < defection_rate <= 1.0 / self.n_players:
            return Action.C
        if recent_coop_rate >= threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate cooperation rate from last 3 rounds (or fewer if unavailable).
        """
        rounds_available = len(history.my_actions)
        lookback = min(3, rounds_available)
        if lookback == 0:
            return 0.0
        recent_actions = history.opponent_actions[-lookback:, :]
        total_possible = lookback * self.n_players
        cooperators = int(np.sum(recent_actions))
        return cooperators / total_possible if total_possible > 0 else 0.0

    def _calculate_cooperation_trend(self, history: PlayerHistory) -> float:
        """
        Calculate trend in cooperation rate over last rounds.
        Returns the slope (negative = declining cooperation).
        """
        rounds_available = len(history.my_actions)
        if rounds_available < 2:
            return 0.0
        lookback = min(4, rounds_available)
        coop_rates = []
        for i in range(rounds_available - lookback, rounds_available):
            if i >= 0:
                round_coops = int(np.sum(history.opponent_actions[i, :]))
                coop_rates.append(round_coops / self.n_players)
        if len(coop_rates) < 2:
            return 0.0
        trend = coop_rates[-1] - coop_rates[0]
        return trend / (len(coop_rates) - 1)

    def _adjust_threshold(self, base_threshold: float, history: PlayerHistory, recent_rate: float) -> float:
        """
        Adjust threshold based on multiplier and cooperation volatility.
        """
        if self.k > self.n_players - 1:
            return max(base_threshold - 0.05, 0.0)
        if self.k < 1.5:
            return base_threshold + 0.1
        return base_threshold

    def _is_volatile_group(self, history: PlayerHistory) -> bool:
        """
        Detect if cooperation rate swings >30% between consecutive rounds.
        """
        rounds_available = len(history.my_actions)
        if rounds_available < 2:
            return False
        lookback = min(4, rounds_available)
        coop_rates = []
        for i in range(rounds_available - lookback, rounds_available):
            if i >= 0:
                round_coops = int(np.sum(history.opponent_actions[i, :]))
                coop_rates.append(round_coops / self.n_players)
        if len(coop_rates) < 2:
            return False
        for i in range(len(coop_rates) - 1):
            swing = abs(coop_rates[i + 1] - coop_rates[i])
            if swing > 0.3:
                return True
        return False

class Strategy_COLLECTIVE_46(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Cooperates conditionally based on observed group cooperation rates.
    Uses threshold-based reciprocity in middle rounds, probabilistic matching
    when cooperation is partial, and defection in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        prev_round_idx = round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        total_cooperators = int(my_prev_action) + int(np.sum(opponent_prev_actions))
        coop_rate = total_cooperators / self.n_players
        threshold_high = (self.k - 1) / self.k
        threshold_low = 1.0 / self.n_players
        if coop_rate >= threshold_high:
            return Action.C
        elif coop_rate > threshold_low:
            if random.random() < coop_rate:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_47(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare while protecting against exploitation by using
    observed group contribution patterns to determine cooperation viability.
    Employs time-dependent thresholds: 0.4 (early), 0.5 (middle), 0.6 (late).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        round_num = state.round_number
        early_threshold = self.n_rounds / 3
        mid_threshold = 2 * self.n_rounds / 3
        if round_num < early_threshold:
            threshold_t = 0.4
        elif round_num < mid_threshold:
            threshold_t = 0.5
        else:
            threshold_t = 0.6
        prev_round_idx = round_num - 1
        opponent_cooperators_prev = np.sum(history.opponent_actions[prev_round_idx, :])
        my_action_prev = history.my_actions[prev_round_idx]
        total_contributions_prev = opponent_cooperators_prev + (1 if my_action_prev else 0)
        avg_prev = total_contributions_prev / self.n_players
        if avg_prev >= threshold_t:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_48(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by encouraging contributions when reciprocity is present,
    while minimizing exploitation losses through adaptive decision-making based on observed
    population contribution rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        population_contribution_rate = self._calculate_population_contribution_rate(history)
        is_final_round = round_number == self.n_rounds - 1
        if is_final_round:
            if population_contribution_rate < 0.25:
                return Action.D
        efficiency_threshold = (self.k - 1) / self.k
        if population_contribution_rate >= efficiency_threshold:
            return Action.C
        elif population_contribution_rate >= 0.5:
            if random.random() < population_contribution_rate:
                return Action.C
            else:
                return Action.D
        elif population_contribution_rate >= 0.25:
            return Action.D
        else:
            return Action.D

    def _calculate_population_contribution_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the population contribution rate across all opponents in all previous rounds.
        Returns a float in [0, 1].
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_contributions = float(np.sum(history.opponent_actions))
        total_possible = float(history.opponent_actions.size)
        if total_possible == 0:
            return 0.0
        return total_contributions / total_possible

class Strategy_COLLECTIVE_49(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by maintaining cooperative equilibrium when feasible,
    while protecting against exploitation through dynamic threshold-based defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if self.n_rounds - round_num <= 2:
            return Action.D
        lookback_rounds = min(3, round_num)
        start_idx = max(0, round_num - lookback_rounds)
        my_actions_recent = history.my_actions[start_idx:round_num]
        opponent_actions_recent = history.opponent_actions[start_idx:round_num, :]
        my_payoffs_recent = history.my_payoffs[start_idx:round_num]
        total_contributions = np.sum(my_actions_recent) + np.sum(opponent_actions_recent)
        coop_rate = total_contributions / (lookback_rounds * self.n_players) if lookback_rounds > 0 else 0.0
        my_coop_mask = my_actions_recent.astype(bool)
        my_defect_mask = ~my_coop_mask
        avg_payoff_coop = 0.0
        avg_payoff_defect = 0.0
        if np.any(my_coop_mask):
            avg_payoff_coop = float(np.mean(my_payoffs_recent[my_coop_mask]))
        if np.any(my_defect_mask):
            avg_payoff_defect = float(np.mean(my_payoffs_recent[my_defect_mask]))
        max_possible_payoff = self.k / self.n_players * self.n_players
        coop_threshold_low = 0.4 if self.k < 1.5 else 0.3
        coop_threshold_high = (self.k - 1.0) / self.k
        if np.any(my_payoffs_recent < 0):
            return Action.D
        if coop_rate >= coop_threshold_high and avg_payoff_coop >= 0.85 * max_possible_payoff:
            return Action.C
        if coop_rate < coop_threshold_low and self.n_rounds - round_num > 2:
            return Action.D
        if coop_threshold_low <= coop_rate < coop_threshold_high:
            return Action.C if random.random() < coop_rate else Action.D
        return Action.C

class Strategy_COLLECTIVE_50(BaseStrategy):
    """
    Adaptive Reciprocal Contribution (ARC) Strategy for N-Player Public Goods Game.
    
    Cooperates in round 1 to signal willingness. In rounds 2 to r-2, cooperates if the
    empirical cooperation rate from the previous round meets an adaptive threshold.
    In the endgame (rounds r-1 and r), applies special logic: cooperates in round r-1
    if sufficient prior cooperation existed, but always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        previous_round_idx = round_num - 1
        opponent_cooperators = sum(history.opponent_actions[previous_round_idx, :])
        player_cooperated = 1 if history.my_actions[previous_round_idx] else 0
        total_cooperators = opponent_cooperators + player_cooperated
        prior_coop_rate = total_cooperators / self.n_players
        threshold = max(0.25, self.k / self.n_players - 0.1)
        if round_num <= self.n_rounds - 2:
            if prior_coop_rate >= threshold:
                return Action.C
            else:
                return Action.D
        if round_num == self.n_rounds - 2:
            if round_num > 0:
                endgame_check_round_idx = round_num - 1
                opponent_coop_endgame = sum(history.opponent_actions[endgame_check_round_idx, :])
                player_coop_endgame = 1 if history.my_actions[endgame_check_round_idx] else 0
                endgame_coop_rate = (opponent_coop_endgame + player_coop_endgame) / self.n_players
                if endgame_coop_rate >= 0.3:
                    return Action.C
            if prior_coop_rate >= threshold:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_51(BaseStrategy):
    """
    Adaptive Contribution Threshold Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation that rewards mutual 
    contribution while protecting against systematic defection. Uses a dynamically 
    adjusted contribution threshold based on previous round behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.epsilon = 0.15 if self.n_players < 4 else 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        prev_round_idx = round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        my_contribution = 1.0 if my_prev_action else 0.0
        opponent_contributions = history.opponent_actions[prev_round_idx, :].astype(float)
        total_cooperators = my_contribution + np.sum(opponent_contributions)
        avg_contribution_prev = total_cooperators / self.n_players
        threshold = avg_contribution_prev - self.epsilon
        if round_number == self.n_rounds - 1:
            other_total_contributions = np.sum(opponent_contributions)
            if other_total_contributions < 0.4 * self.n_players:
                return Action.D
        if avg_contribution_prev >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_52(BaseStrategy):
    """
    Adaptive Collective Strategy for N-Player Public Goods Games.
    
    Uses conditional cooperation with threshold-based decision making.
    Rewards participation, punishes free-riding, and defects in the last round.
    Includes persistent defection detection and sudden collapse handling.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        k_to_n_ratio = self.k / self.n_players
        if k_to_n_ratio < 0.4:
            self.threshold = 0.6
        elif k_to_n_ratio > 0.8:
            self.threshold = 0.4
        else:
            self.threshold = 0.5
        self.permanent_defection = False
        self.last_contribution_rate = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if self.permanent_defection:
            return Action.D
        prev_round_idx = state.round_number - 1
        my_action_prev = history.my_actions[prev_round_idx]
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        total_contributions_prev = int(my_action_prev) + np.sum(opponent_actions_prev)
        prior_contribution_rate = total_contributions_prev / self.n_players
        if state.round_number == 2:
            rate_round_1 = (int(history.my_actions[0]) + np.sum(history.opponent_actions[0, :])) / self.n_players
            rate_round_2 = prior_contribution_rate
            if rate_round_1 <= 0.2 and rate_round_2 <= 0.2:
                self.permanent_defection = True
                return Action.D
        if state.round_number >= 2:
            two_rounds_ago_idx = state.round_number - 2
            two_rounds_ago_total = int(history.my_actions[two_rounds_ago_idx]) + np.sum(history.opponent_actions[two_rounds_ago_idx, :])
            two_rounds_ago_rate = two_rounds_ago_total / self.n_players
            drop = two_rounds_ago_rate - prior_contribution_rate
            if drop > 0.3:
                if not hasattr(self, 'recovery_signal_sent'):
                    self.recovery_signal_sent = False
                if not self.recovery_signal_sent:
                    self.recovery_signal_sent = True
                    return Action.C
                else:
                    self.permanent_defection = True
                    return Action.D
        if prior_contribution_rate >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_53(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation that rewards mutual 
    contribution while maintaining robustness against free-riding. Cooperates in round 1,
    adapts based on cooperation rates in rounds 2-(r-1), and cooperates in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.defected_last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.defected_last_round = False
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self.defected_last_round = False
            return Action.C
        prev_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        total_cooperators = int(my_prev_action) + np.sum(opponent_prev_actions)
        cooperation_rate = total_cooperators / self.game_description.n_players
        if self.defected_last_round:
            self.defected_last_round = False
            return Action.C
        if cooperation_rate >= self.cooperation_threshold:
            self.defected_last_round = False
            return Action.C
        else:
            self.defected_last_round = True
            return Action.D

class Strategy_COLLECTIVE_54(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional reciprocity while maintaining
    individual resilience against exploitation. Uses dynamic thresholds and per-player
    tracking to identify free-riders and coordinate on cooperative equilibria.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.player_contribution_count = np.zeros(self.n_players - 1, dtype=int)
        self.player_round_count = 0
        self.contribution_rate_history = []
        self.recovery_attempts = 0
        self.in_cascade_failure = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        previous_contributions = np.sum(history.opponent_actions[-1, :])
        my_previous_action = 1 if history.my_actions[-1] else 0
        total_previous_contributions = previous_contributions + my_previous_action
        previous_contribution_rate = total_previous_contributions / self.n_players
        for i in range(self.n_players - 1):
            if history.opponent_actions[-1, i]:
                self.player_contribution_count[i] += 1
        self.player_round_count += 1
        self.contribution_rate_history.append(previous_contribution_rate)
        threshold = self._get_adaptive_threshold(round_num)
        if len(self.contribution_rate_history) >= 2:
            if self.contribution_rate_history[-1] < 0.3 and self.contribution_rate_history[-2] < 0.3:
                self.in_cascade_failure = True
        has_systematic_defector = self._has_systematic_defector()
        if previous_contribution_rate >= threshold:
            return Action.C
        elif previous_contribution_rate < threshold:
            if self.in_cascade_failure and self.recovery_attempts < 2:
                self.recovery_attempts += 1
                return Action.C
            defect_payoff = 1.0 + self.k / self.n_players * total_previous_contributions
            cooperate_payoff = self.k / self.n_players * (total_previous_contributions + 1)
            conditional_cooperators = self._count_conditional_cooperators(history)
            cooperation_signal_boost = conditional_cooperators * 0.1
            if cooperate_payoff + cooperation_signal_boost > defect_payoff:
                return Action.C
            elif has_systematic_defector:
                return Action.D
            else:
                return Action.D

    def _get_adaptive_threshold(self, round_num: int) -> float:
        """Determine adaptive threshold based on round number and history."""
        if round_num <= 2:
            threshold = 0.5
        elif round_num >= self.n_rounds - 2:
            threshold = 0.7
        else:
            threshold = 0.6
        if len(self.contribution_rate_history) >= 2:
            recent_decline = self.contribution_rate_history[-2] - self.contribution_rate_history[-1]
            if recent_decline > 0.15:
                threshold = max(0.3, threshold - 0.1)
        return threshold

    def _has_systematic_defector(self) -> bool:
        """Identify if any player is a systematic free-rider."""
        if self.player_round_count == 0:
            return False
        for contributions in self.player_contribution_count:
            contribution_rate = contributions / self.player_round_count
            if contribution_rate < 0.2:
                avg_rate = np.mean(self.player_contribution_count) / self.player_round_count
                if avg_rate > 0.6:
                    return True
        return False

    def _count_conditional_cooperators(self, history: PlayerHistory) -> int:
        """Count opponents whose contributions correlate with previous round totals."""
        if len(self.contribution_rate_history) < 2:
            return 0
        count = 0
        for i in range(self.n_players - 1):
            opponent_history = history.opponent_actions[:, i]
            if len(opponent_history) >= 2:
                recent_action = opponent_history[-1]
                recent_coop_rate = self.contribution_rate_history[-1]
                if recent_action and recent_coop_rate >= 0.5:
                    count += 1
        return count

class Strategy_COLLECTIVE_55(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Contributes when cooperation rate is sufficient, defects in the final quarter,
    and implements adaptive recovery after cooperation collapse.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold_T = max(0.5, 1.0 / self.n_players)
        if self.n_players == 2:
            self.threshold_T = 0.4
        if self.n_rounds <= 4:
            self.end_game_start = self.n_rounds
        else:
            self.end_game_start = self.n_rounds - math.ceil(self.n_rounds / 4)
        self.in_defection = False
        self.defection_rounds_count = 0
        self.last_cooperation_rate = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            self.in_defection = False
            self.defection_rounds_count = 0
            return Action.C
        if round_num >= self.end_game_start:
            return Action.D
        prev_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        cooperators_prev = int(np.sum(opponent_actions_prev))
        cooperation_rate = cooperators_prev / (self.n_players - 1) if self.n_players > 1 else 0.0
        self.last_cooperation_rate = cooperation_rate
        if self.in_defection:
            self.defection_rounds_count += 1
            recovery_threshold = self.threshold_T + 0.15
            if cooperation_rate >= recovery_threshold:
                self.in_defection = False
                self.defection_rounds_count = 0
                return Action.C
            if self.defection_rounds_count >= 2 and cooperation_rate >= self.threshold_T:
                self.in_defection = False
                self.defection_rounds_count = 0
                return Action.C
            return Action.D
        if cooperation_rate >= self.threshold_T:
            return Action.C
        else:
            self.in_defection = True
            self.defection_rounds_count = 0
            return Action.D

class Strategy_COLLECTIVE_56(BaseStrategy):
    """
    Adaptive Collective Reciprocity Strategy for Public Goods Games.
    
    Implements conditional cooperation with stability enforcement:
    - Phase 1: Cooperate in round 1 to signal good faith
    - Phase 2: Adaptive reciprocity based on cooperation rate (rounds 2 to r-2)
    - Phase 3: Defect in final 2 rounds (endgame logic)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        k = self.game_description.k
        r = self.game_description.n_rounds
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num >= r - 2:
            return Action.D
        prev_round_idx = round_num - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_cooperators = np.sum(history.opponent_actions[prev_round_idx, :])
        total_cooperators = int(my_prev_action) + int(opponent_cooperators)
        cooperation_rate = total_cooperators / n
        self.cooperation_history.append(cooperation_rate)
        threshold_adjustment = 0.0
        if len(self.cooperation_history) >= 3:
            recent_rates = self.cooperation_history[-3:]
            if recent_rates[-1] < recent_rates[-2] < recent_rates[-3]:
                threshold_adjustment = -0.05
        critical_threshold = 1.0 / k
        adjusted_critical = max(0.0, critical_threshold + threshold_adjustment)
        if cooperation_rate >= 2.0 / k:
            return Action.C
        elif cooperation_rate >= adjusted_critical:
            cooperation_probability = cooperation_rate * k
            cooperation_probability = min(1.0, max(0.0, cooperation_probability))
            if random.random() < cooperation_probability:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate == 0.0:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_57(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare through credible reciprocity and adaptive thresholds.
    Contributes based on observed average contribution rates, with dynamic threshold
    adjustments to encourage cooperation while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.consecutive_low_rounds = 0
        self.contribution_history = []
        self.threshold_floor = 0.4
        self.threshold_ceiling = 0.7

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_idx = state.round_number - 1
        prev_contributions = history.opponent_actions[prev_round_idx, :]
        prev_my_action = history.my_actions[prev_round_idx]
        total_contributors = int(np.sum(prev_contributions)) + int(prev_my_action)
        avg_contrib_rate = total_contributors / self.game_description.n_players
        self.contribution_history.append(avg_contrib_rate)
        if state.round_number == self.game_description.n_rounds - 1:
            if avg_contrib_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if len(self.contribution_history) >= 3:
            recent_rates = self.contribution_history[-3:]
            if all((rate >= 0.7 for rate in recent_rates)):
                self.threshold = max(self.threshold - 0.05, self.threshold_floor)
            elif all((rate <= 0.3 for rate in recent_rates)):
                self.threshold = min(0.6, self.threshold_ceiling)
        if avg_contrib_rate >= self.threshold:
            action = Action.C
            self.threshold = max(self.threshold - 0.025, self.threshold_floor)
            self.consecutive_low_rounds = 0
        else:
            if avg_contrib_rate >= 0.6:
                action = Action.D
                self.threshold = max(self.threshold - 0.03, self.threshold_floor)
            else:
                action = Action.D
                self.threshold = min(self.threshold + 0.05, self.threshold_ceiling)
            self.consecutive_low_rounds += 1
            if self.consecutive_low_rounds >= 2:
                self.threshold = min(self.threshold, 0.65)
        if len(self.contribution_history) >= 2:
            recent_contrib_rates = self.contribution_history[-2:]
            if len(recent_contrib_rates) > 0:
                variance = np.var(recent_contrib_rates)
                if variance > 0.15:
                    median_rate = np.median(recent_contrib_rates)
                    if median_rate < self.threshold and action == Action.C:
                        action = Action.D
        return action

class Strategy_COLLECTIVE_58(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through calibrated contributions that reward cooperation
    and penalize defection, while remaining resilient to exploitation.
    
    Core behavior:
    - Round 1: CONTRIBUTE (seed cooperation)
    - Rounds 2 to r-1: CONTRIBUTE if cooperation_rate >= 0.5, else DEFECT
    - Round r: DEFECT (endgame rational defection)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_idx = state.round_number - 1
        my_previous_action = history.my_actions[previous_round_idx]
        opponent_previous_actions = history.opponent_actions[previous_round_idx, :]
        total_cooperators = (1 if my_previous_action else 0) + int(np.sum(opponent_previous_actions))
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_59(BaseStrategy):
    """
    Adaptive Collective Strategy for N-Player Public Goods Game.
    
    Balances conditional cooperation with pragmatic defense against free-riding.
    Cooperates initially, adapts based on group contribution rates, and applies
    measured punishment/recovery cycles while protecting against endgame defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        if self.n_players > 10:
            self.threshold_high = 0.65
            self.threshold_medium = 0.25
        else:
            self.threshold_high = 0.75
            self.threshold_medium = 0.35
        self.defection_rounds_remaining = 0
        self.last_group_contribution = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        rounds_remaining = self.n_rounds - round_num
        if rounds_remaining == 1:
            if history is not None and len(history.opponent_actions) > 0:
                all_contributions = []
                for round_idx in range(len(history.opponent_actions)):
                    opponent_coops = np.sum(history.opponent_actions[round_idx, :])
                    self_coop = 1 if history.my_actions[round_idx] else 0
                    total_coops = opponent_coops + self_coop
                    contrib_rate = total_coops / self.n_players
                    all_contributions.append(contrib_rate)
                avg_all_contributions = np.mean(all_contributions) if all_contributions else 0.0
                if avg_all_contributions >= 0.7:
                    return Action.C
            return Action.D
        if history is not None:
            prev_round_idx = round_num - 1
            opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
            opponent_cooperators = np.sum(opponent_actions_prev)
            avg_others_contribution = opponent_cooperators / (self.n_players - 1) if self.n_players > 1 else 0.0
            if self.defection_rounds_remaining > 0:
                self.defection_rounds_remaining -= 1
                if self.defection_rounds_remaining == 0:
                    return Action.C
                return Action.D
            if avg_others_contribution >= self.threshold_high:
                return Action.C
            elif avg_others_contribution >= self.threshold_medium:
                cooperate_prob = avg_others_contribution
                if random.random() < cooperate_prob:
                    return Action.C
                return Action.D
            else:
                self.defection_rounds_remaining = 2
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_60(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Decay.
    
    Cooperates initially and reciprocates based on empirical cooperation rates
    from previous rounds, with a decaying threshold. Switches to permanent defection
    if opponents consistently defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.current_threshold = 0.5
        self.consecutive_universal_defection = 0
        self.permanent_defect = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.permanent_defect:
            return Action.D
        previous_round_idx = state.round_number - 1
        my_previous_action = history.my_actions[previous_round_idx]
        my_contribution = 1 if my_previous_action else 0
        opponent_contributions = np.sum(history.opponent_actions[previous_round_idx, :])
        total_contributions = my_contribution + opponent_contributions
        cooperation_rate = total_contributions / self.game_description.n_players
        if opponent_contributions == 0:
            self.consecutive_universal_defection += 1
            if self.consecutive_universal_defection >= 2:
                self.permanent_defect = True
                return Action.D
        else:
            self.consecutive_universal_defection = 0
        if cooperation_rate >= self.current_threshold:
            action = Action.C
        else:
            action = Action.D
        self.current_threshold = max(0.0, self.current_threshold - 0.05)
        return action

class Strategy_COLLECTIVE_61(BaseStrategy):
    """
    Adaptive Conditional Cooperation Strategy for N-Player Public Goods Game.
    
    Cooperates conditionally based on recent collective performance and individual reciprocity.
    - Round 1: Cooperate (trust initiation)
    - Final Round: Defect (no future reciprocal opportunities)
    - Other rounds: Adapt based on cooperation rate (CR) of last M rounds
      - High CR (≥0.6): Cooperate
      - Medium CR (0.3-0.6): Cooperate if self cooperated last round AND gained positive payoff
      - Low CR (<0.3): Defect
    - Consecutive low payoff trap: Continue defecting if defected 2+ rounds AND CR <0.3
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defection_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_round = state.round_number
        window_size = min(5, current_round)
        start_idx = current_round - window_size
        recent_opponent_actions = history.opponent_actions[start_idx:current_round, :]
        total_contributions = np.sum(recent_opponent_actions)
        total_possible = window_size * self.game_description.n_players
        cr = total_contributions / total_possible if total_possible > 0 else 0.0
        my_last_action = history.my_actions[current_round - 1]
        my_last_payoff = history.my_payoffs[current_round - 1]
        if not my_last_action:
            self.consecutive_defection_rounds += 1
        else:
            self.consecutive_defection_rounds = 0
        if cr >= 0.6:
            return Action.C
        elif 0.3 <= cr < 0.6:
            if my_last_action and my_last_payoff > 0:
                return Action.C
            else:
                return Action.D
        elif self.consecutive_defection_rounds >= 2:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_62(BaseStrategy):
    """
    Adaptive Conditional Cooperation Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by incentivizing sustained cooperation while maintaining
    individual robustness against exploitation. Uses dynamic thresholds based on historical
    contribution rates and special handling for edge cases.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_history = []
        self.sudden_defection_counter = 0
        self.all_defect_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        all_contributions = np.concatenate([history.my_actions[:, np.newaxis], history.opponent_actions], axis=1)
        prev_round_idx = round_num - 1
        prev_round_contributions = all_contributions[prev_round_idx, :]
        prev_contribution_count = np.sum(prev_round_contributions)
        prev_contribution_rate = prev_contribution_count / self.game_description.n_players
        self.contribution_history.append(prev_contribution_rate)
        if round_num <= 3:
            threshold = 0.5
        else:
            avg_historical_rate = np.mean(self.contribution_history) if self.contribution_history else 0.5
            threshold = max(0.0, avg_historical_rate - 0.1)
        if round_num >= 2:
            two_rounds_ago_idx = round_num - 2
            two_rounds_ago_contribs = all_contributions[two_rounds_ago_idx, :]
            two_rounds_ago_rate = np.mean(two_rounds_ago_contribs)
            if two_rounds_ago_rate > 0.7 and prev_contribution_rate < 0.3:
                self.sudden_defection_counter += 1
            else:
                self.sudden_defection_counter = max(0, self.sudden_defection_counter - 1)
        if self.sudden_defection_counter > 1:
            self.sudden_defection_counter = 0
        if prev_contribution_rate < 0.2:
            self.all_defect_counter += 1
        else:
            self.all_defect_counter = 0
        if self.all_defect_counter >= 2:
            return Action.D
        rolling_window_size = min(3, len(self.contribution_history))
        if rolling_window_size > 0:
            rolling_avg = np.mean(self.contribution_history[-rolling_window_size:])
        else:
            rolling_avg = prev_contribution_rate
        is_last_round = round_num == self.game_description.n_rounds - 1
        if is_last_round:
            my_past_cooperations = np.sum(history.my_actions)
            my_past_cooperation_rate = my_past_cooperations / round_num if round_num > 0 else 0.0
            if rolling_avg < 0.3 and my_past_cooperation_rate > 0.6:
                return Action.D
            return Action.C
        k = self.game_description.k
        n = self.game_description.n_players
        public_good_share = k / n * prev_contribution_count
        payoff_if_coop = 0 + public_good_share
        payoff_if_defect = 1 + public_good_share
        meets_threshold = rolling_avg >= threshold
        if meets_threshold and self.sudden_defection_counter == 0:
            return Action.C
        if rolling_avg >= 0.4 and self.all_defect_counter == 0:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_63(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation with:
    - Unconditional cooperation in round 1 to signal intent
    - Threshold-based cooperation: contribute if avg prior contribution ≥ (k-1)/k
    - Strict endgame defection: defect in last round, conditional in second-to-last
    - Gradual defection ramp in final third of game
    - Resilience against free-riders and sudden collapse detection
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_threshold = (self.k - 1) / self.k
        self.endgame_start = max(1, math.floor(self.n_rounds / 3))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == self.n_rounds - 2:
            avg_contribution = self._calculate_avg_contribution(history)
            if avg_contribution >= self.cooperation_threshold:
                return Action.C
            return Action.D
        remaining_rounds = self.n_rounds - round_num
        if round_num >= self.endgame_start:
            rounds_into_endgame = round_num - self.endgame_start
            total_endgame_rounds = self.n_rounds - self.endgame_start
            if total_endgame_rounds > 0:
                defection_probability = rounds_into_endgame / total_endgame_rounds
                if random.random() < defection_probability:
                    return Action.D
        avg_contribution = self._calculate_avg_contribution(history)
        if round_num >= 2:
            prev_round_contribution = self._get_round_contribution_rate(history, round_num - 1)
            curr_round_contribution = self._get_round_contribution_rate(history, round_num - 1)
            if prev_round_contribution > 0 and prev_round_contribution - curr_round_contribution > 0.4:
                return Action.D
        if avg_contribution >= self.cooperation_threshold or remaining_rounds <= self.n_rounds / 2:
            return Action.C
        return Action.D

    def _calculate_avg_contribution(self, history: PlayerHistory) -> float:
        """
        Calculate average contribution rate across all previous rounds.
        Includes this player's actions and all opponents' actions.
        """
        if len(history.my_actions) == 0:
            return 0.0
        my_cooperations = np.sum(history.my_actions)
        opponent_cooperations = np.sum(history.opponent_actions)
        total_cooperations = my_cooperations + opponent_cooperations
        total_possible = self.n_players * len(history.my_actions)
        if total_possible == 0:
            return 0.0
        return total_cooperations / total_possible

    def _get_round_contribution_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Get the contribution rate (fraction of players who cooperated) in a specific round.
        """
        if round_idx < 0 or round_idx >= len(history.my_actions):
            return 0.0
        my_action = 1 if history.my_actions[round_idx] else 0
        opponent_actions = history.opponent_actions[round_idx, :]
        opponent_cooperations = np.sum(opponent_actions)
        total_cooperations = my_action + opponent_cooperations
        return total_cooperations / self.n_players

class Strategy_COLLECTIVE_64(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by contributing when the multiplier effect creates
    positive-sum outcomes, while protecting against exploitation through conditional
    defection triggered by persistent free-riding.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        coop_rate = self._calculate_cooperation_rate(history, current_round)
        threshold = (1.0 - self.k / self.n_players) / (1.0 - 1.0 / self.n_players)
        threshold = max(0.0, min(1.0, threshold))
        if coop_rate >= 0.6:
            return Action.C
        elif coop_rate >= 0.3:
            if random.random() < coop_rate:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of contributions across all previous rounds.
        
        Args:
            history: Player history object containing all past actions and payoffs
            current_round: Current round number (0-indexed)
        
        Returns:
            Cooperation rate as a float between 0 and 1
        """
        if current_round == 0:
            return 0.0
        my_contributions = int(np.sum(history.my_actions[:current_round]))
        opponent_contributions = int(np.sum(history.opponent_actions[:current_round, :]))
        total_contributions = my_contributions + opponent_contributions
        total_possible = current_round * self.n_players
        if total_possible == 0:
            return 0.0
        coop_rate = total_contributions / total_possible
        return coop_rate

class Strategy_COLLECTIVE_65(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Decay strategy for N-Player Public Goods Game.
    
    Opens with cooperation and adapts based on observed reciprocity ratios.
    Uses dynamic thresholds that vary by game phase: stricter early/late, more lenient mid-game.
    Handles unanimous cooperation/defection as special cases.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        prev_round_idx = round_num - 1
        others_contributed = int(sum(history.opponent_actions[prev_round_idx, :]))
        if others_contributed == 0:
            if round_num == 2:
                if int(sum(history.opponent_actions[0, :])) == 0:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        if others_contributed == self.n_players - 1:
            return Action.C
        reciprocity_ratio = others_contributed / (self.n_players - 1)
        if round_num <= 3:
            threshold = 0.5
        elif round_num <= self.n_rounds - 2:
            threshold = 0.4
        else:
            threshold = 0.6
        if round_num == self.n_rounds - 1:
            if reciprocity_ratio < 0.3:
                return Action.D
            elif reciprocity_ratio >= threshold:
                return Action.C
            else:
                return Action.D
        if reciprocity_ratio >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_66(BaseStrategy):
    """
    Collective welfare strategy for N-Player Public Goods Game.
    
    Uses adaptive reciprocity based on group cooperation rate (GCR), individual
    accountability tracking, and final-round defection. Balances cooperation
    encouragement with robustness against free-riders.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self._set_thresholds()

    def _set_thresholds(self) -> None:
        """Set cooperation thresholds based on game parameters."""
        threshold_high = 0.7
        threshold_low = 0.3
        if self.n_players <= 3:
            threshold_high = 0.8
            threshold_low = 0.4
        if self.k > self.n_players * 0.8:
            threshold_high = 0.6
            threshold_low = 0.2
        elif self.k < 1.5:
            threshold_high = 0.8
            threshold_low = 0.4
        self.threshold_high = threshold_high
        self.threshold_low = threshold_low

    def _calculate_gcr(self, history: PlayerHistory) -> float:
        """Calculate Group Cooperation Rate from previous round."""
        if history.opponent_actions.shape[0] == 0:
            return 0.0
        last_round_idx = history.opponent_actions.shape[0] - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx, :])
        my_cooperated = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_cooperated else 0)
        gcr = total_cooperators / self.n_players
        return gcr

    def _apply_accountability_penalty(self, history: PlayerHistory, gcr: float) -> float:
        """Apply penalty if individual players have high defection rates."""
        if history.opponent_actions.shape[0] == 0:
            return gcr
        n_rounds_observed = history.opponent_actions.shape[0]
        for opponent_idx in range(self.n_players - 1):
            defections = sum(~history.opponent_actions[:, opponent_idx])
            defection_rate = defections / n_rounds_observed
            if defection_rate > 0.6:
                gcr = max(0.0, gcr - 0.15)
                break
        return gcr

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        """
        Determine action based on game phase and observed cooperation.
        """
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if history is not None and history.my_actions.shape[0] > 0:
                gcr = self._calculate_gcr(history)
                if gcr >= 0.8:
                    return Action.C
            return Action.D
        if history is not None and history.my_actions.shape[0] > 0:
            gcr = self._calculate_gcr(history)
            gcr = self._apply_accountability_penalty(history, gcr)
            if gcr >= self.threshold_high:
                return Action.C
            elif gcr >= self.threshold_low:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_67(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game using conditional reciprocity
    with adaptive thresholds. Maximizes collective welfare while protecting against
    free-riders through graduated defection and cooperative recovery.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.breakeven_threshold = self.k / self.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        current_coop_rate = self._get_cooperation_rate(history, round_num)
        if round_num == self.n_rounds - 1:
            return self._final_round_decision(history, current_coop_rate)
        return self._midgame_decision(history, current_coop_rate, round_num)

    def _get_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate cooperation rate for the previous round."""
        if round_num == 0:
            return 0.0
        my_coop = int(history.my_actions[round_num - 1])
        opponent_coops = int(np.sum(history.opponent_actions[round_num - 1, :]))
        total_coops = my_coop + opponent_coops
        coop_rate = total_coops / self.n_players
        return coop_rate

    def _get_rolling_coop_rate(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate rolling average cooperation rate over last 3 rounds."""
        if round_num == 0:
            return 0.0
        start_round = max(0, round_num - 3)
        rates = []
        for t in range(start_round, round_num):
            my_coop = int(history.my_actions[t])
            opponent_coops = int(np.sum(history.opponent_actions[t, :]))
            total_coops = my_coop + opponent_coops
            rate = total_coops / self.n_players
            rates.append(rate)
        return np.mean(rates) if rates else 0.0

    def _compute_threshold(self, round_num: int) -> float:
        """
        Compute dynamic threshold: T(t) = k/n + (1 - k/n) * (1 - t/r)
        """
        t = round_num
        r = self.n_rounds
        threshold = self.breakeven_threshold + (1 - self.breakeven_threshold) * (1 - t / r)
        return threshold

    def _detect_unanimous_defection(self, history: PlayerHistory, round_num: int) -> bool:
        """Check if all players defected in previous round."""
        if round_num == 0:
            return False
        prev_round = round_num - 1
        my_coop = history.my_actions[prev_round]
        opponent_coops = np.sum(history.opponent_actions[prev_round, :])
        return not my_coop and opponent_coops == 0

    def _detect_high_variance(self, history: PlayerHistory, round_num: int) -> bool:
        """Detect if opponent cooperation is highly variable (alternating pattern)."""
        if round_num < 2:
            return False
        start = max(0, round_num - 3)
        variance_count = 0
        opponent_count = 0
        for opp_idx in range(self.n_players - 1):
            alternations = 0
            for t in range(start + 1, round_num):
                if history.opponent_actions[t - 1, opp_idx] != history.opponent_actions[t, opp_idx]:
                    alternations += 1
            if alternations >= 2:
                variance_count += 1
            opponent_count += 1
        return opponent_count > 0 and variance_count / opponent_count > 0.5

    def _detect_minority_cooperators(self, current_coop_rate: float) -> bool:
        """Detect if only 1-2 players cooperate while others defect."""
        coops_needed = current_coop_rate * self.n_players
        return coops_needed <= 2 and coops_needed > 0

    def _detect_late_game_recovery(self, history: PlayerHistory, round_num: int) -> bool:
        """Check if cooperation recovered above k/n + 0.2."""
        if round_num < 2:
            return False
        current_rate = self._get_cooperation_rate(history, round_num)
        return current_rate >= self.breakeven_threshold + 0.2

    def _is_near_threshold(self, coop_rate: float, threshold: float) -> bool:
        """Check if cooperation rate is within ±5% of threshold."""
        return abs(coop_rate - threshold) <= 0.05

    def _midgame_decision(self, history: PlayerHistory, current_coop_rate: float, round_num: int) -> Action:
        """Decision logic for rounds 1 to n_rounds-2."""
        if self._detect_unanimous_defection(history, round_num):
            return Action.D
        if self._detect_minority_cooperators(current_coop_rate):
            return Action.D
        if self._detect_high_variance(history, round_num):
            return Action.D
        if self._detect_late_game_recovery(history, round_num):
            return Action.C
        rolling_rate = self._get_rolling_coop_rate(history, round_num)
        threshold = self._compute_threshold(round_num)
        if self._is_near_threshold(rolling_rate, threshold):
            return Action.C
        if round_num >= 2:
            prev_rate = self._get_cooperation_rate(history, round_num - 1)
            older_rate = self._get_cooperation_rate(history, round_num - 2)
            if rolling_rate > older_rate and rolling_rate >= threshold - 0.1:
                return Action.C
        if rolling_rate >= threshold:
            return Action.C
        return Action.D

    def _final_round_decision(self, history: PlayerHistory, current_coop_rate: float) -> Action:
        """Decision logic for the final round."""
        prev_round = self.n_rounds - 2
        if current_coop_rate >= self.breakeven_threshold + 0.1:
            return Action.C
        if current_coop_rate < self.breakeven_threshold:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_68(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation that scales with
    demonstrated group commitment, while maintaining individual resilience against
    exploitation. Uses thresholds based on observed cooperation rates from other players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        most_recent_round_idx = round_number - 1
        opponent_actions_last_round = history.opponent_actions[most_recent_round_idx, :]
        num_cooperators_others = int(np.sum(opponent_actions_last_round))
        num_others = self.n_players - 1
        if num_others > 0:
            avg_others = num_cooperators_others / num_others
        else:
            avg_others = 0.0
        if avg_others >= 0.75:
            return Action.C
        elif avg_others >= 0.4:
            return Action.C
        elif avg_others > 0.1:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_69(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game that maximizes long-term
    collective welfare through conditional cooperation with graceful degradation.
    
    Core behaviors:
    - Round 1: Always cooperate (signal pro-social intent)
    - Standard rounds: Cooperate if avg contribution rate >= dynamic threshold
    - Last round: Defect unless exceptional cooperation (>=0.9 avg)
    - Recovery logic: Resume cooperation after observed recovery
    - Edge cases: Handle unanimous defection, solo contribution, small groups, volatility
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        prev_contributions = self._get_contribution_history(history, round_num)
        if round_num == self.n_rounds - 1:
            overall_avg = self._calculate_overall_avg_contribution(prev_contributions)
            if overall_avg >= 0.9:
                return Action.C
            return Action.D
        return self._decide_standard_round(prev_contributions, round_num)

    def _get_contribution_history(self, history: PlayerHistory, round_num: int) -> list[float]:
        """Extract contribution rate for each previous round."""
        contributions = []
        for round_idx in range(round_num):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx, :]
            total_cooperators = int(my_action) + int(np.sum(opponent_actions))
            contribution_rate = total_cooperators / self.n_players
            contributions.append(contribution_rate)
        return contributions

    def _calculate_overall_avg_contribution(self, contributions: list[float]) -> float:
        """Calculate average contribution rate across all provided rounds."""
        if not contributions:
            return 0.0
        return sum(contributions) / len(contributions)

    def _calculate_threshold(self, round_num: int) -> float:
        """
        Dynamic threshold: starts at 50% and increases to 100% as game approaches end.
        threshold(round) = max(0.5, 1 - round/r)
        """
        threshold = max(0.5, 1.0 - round_num / self.n_rounds)
        if self.n_players <= 3:
            threshold = min(1.0, threshold + 0.15)
        return threshold

    def _is_volatile_group(self, contributions: list[float]) -> bool:
        """Check if contribution rates are volatile (variance > 0.4)."""
        if len(contributions) < 2:
            return False
        mean_contribution = sum(contributions) / len(contributions)
        variance = sum(((c - mean_contribution) ** 2 for c in contributions)) / len(contributions)
        std_dev = math.sqrt(variance)
        return std_dev > 0.4

    def _get_effective_prev_contribution(self, contributions: list[float]) -> float:
        """
        Get the effective previous round contribution rate.
        If group is volatile, use 2-round rolling average; otherwise use last round.
        """
        if not contributions:
            return 0.0
        if self._is_volatile_group(contributions) and len(contributions) >= 2:
            return (contributions[-1] + contributions[-2]) / 2.0
        return contributions[-1]

    def _was_unanimous_defection_last_round(self, history: PlayerHistory, round_num: int) -> bool:
        """Check if all players defected in the previous round."""
        prev_round_idx = round_num - 1
        my_action = history.my_actions[prev_round_idx]
        opponent_actions = history.opponent_actions[prev_round_idx, :]
        if int(my_action) == 1:
            return False
        return int(np.sum(opponent_actions)) == 0

    def _was_solo_contributor_last_round(self, history: PlayerHistory, round_num: int) -> bool:
        """Check if this player was the only one who cooperated last round."""
        prev_round_idx = round_num - 1
        my_action = history.my_actions[prev_round_idx]
        opponent_actions = history.opponent_actions[prev_round_idx, :]
        if int(my_action) == 0:
            return False
        return int(np.sum(opponent_actions)) == 0

    def _check_recovery_possible(self, contributions: list[float], round_num: int) -> bool:
        """
        Check if recovery is detected: group fell below threshold but then recovered.
        Returns True if we should resume cooperation due to observed recovery.
        """
        if len(contributions) < 2:
            return False
        threshold = self._calculate_threshold(round_num - 1)
        prev_contribution = contributions[-1]
        if prev_contribution >= threshold:
            if len(contributions) >= 2 and contributions[-2] < threshold:
                return True
        return False

    def _decide_standard_round(self, contributions: list[float], round_num: int) -> Action:
        """Decide action for a standard (non-first, non-last) round."""
        if contributions and contributions[-1] == 0.0:
            return Action.D
        if contributions and contributions[-1] < 1.0 / self.n_players + 0.01:
            if len(contributions) >= 2 and contributions[-1] >= 0.5:
                return Action.C
            return Action.D
        if self._check_recovery_possible(contributions, round_num):
            return Action.C
        threshold = self._calculate_threshold(round_num)
        effective_contribution = self._get_effective_prev_contribution(contributions)
        if effective_contribution >= threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_70(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare through reputation-based reciprocity,
    encouraging cooperation while protecting against free-riders.
    Dynamically adjusts thresholds based on cooperation rates and individual
    defection patterns, with special handling for early game, mid-game crises,
    and end-game scenarios.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.breakeven_threshold = (self.k - 1) / self.k
        self.test_round_pending = False
        self.consecutive_defection_count = {}
        self.individual_defection_streaks = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        n_opponents = self.n_players - 1
        cooperators_per_round = np.sum(opponent_actions, axis=1) + my_actions.astype(int)
        cooperation_rates = cooperators_per_round / self.n_players
        if round_num == self.n_rounds - 1:
            if round_num >= 1:
                prev_coop_rate = cooperation_rates[-1]
                all_cooperated_last = np.all(opponent_actions[-1, :]) and my_actions[-1]
                if prev_coop_rate >= 0.9 and all_cooperated_last:
                    return Action.C
            return Action.D
        recent_weight = 2.0
        if round_num >= 3:
            recent_rounds = cooperation_rates[-3:]
            older_rounds = cooperation_rates[:-3]
            avg_recent = np.mean(recent_rounds)
            avg_older = np.mean(older_rounds) if len(older_rounds) > 0 else avg_recent
            weighted_coop_rate = (avg_recent * recent_weight + avg_older) / (recent_weight + 1)
        else:
            weighted_coop_rate = np.mean(cooperation_rates)
        if round_num <= 2:
            if cooperation_rates[0] < 0.5:
                return Action.D if cooperation_rates[-1] < 0.5 else Action.C
            else:
                return Action.C
        if round_num >= 2:
            recent_coop = np.mean(cooperation_rates[-3:])
            older_coop = np.mean(cooperation_rates[:-3]) if round_num > 3 else cooperation_rates[0]
            coop_drop = older_coop - recent_coop
            if coop_drop > 0.2:
                if self.test_round_pending:
                    if weighted_coop_rate < self.breakeven_threshold:
                        return Action.D
                else:
                    self.test_round_pending = True
                    return Action.C
        else:
            self.test_round_pending = False
        for opponent_idx in range(n_opponents):
            opp_history = opponent_actions[:, opponent_idx]
            total_defections = np.sum(~opp_history.astype(bool))
            if round_num >= 2:
                recent_defections = np.sum(~opp_history[-3:].astype(bool))
                if recent_defections == 3:
                    return Action.D
            if total_defections == round_num:
                return Action.D
            if round_num >= 1:
                if not opp_history[-1]:
                    self.consecutive_defection_count[opponent_idx] = self.consecutive_defection_count.get(opponent_idx, 0) + 1
                else:
                    self.consecutive_defection_count[opponent_idx] = 0
                if self.consecutive_defection_count.get(opponent_idx, 0) >= 3:
                    return Action.D
        if round_num >= 2:
            defection_patterns = []
            for opponent_idx in range(n_opponents):
                defection_patterns.append(not opponent_actions[-1, opponent_idx])
            defectors_last_round = np.sum(defection_patterns)
            if defectors_last_round > self.n_players / 2:
                if weighted_coop_rate < 0.7:
                    return Action.D
        if round_num >= 4:
            erratic = False
            for opponent_idx in range(n_opponents):
                opp_recent = opponent_actions[-4:, opponent_idx]
                alternations = np.sum(np.abs(np.diff(opp_recent.astype(int))))
                if alternations >= 3:
                    erratic = True
                    break
            if erratic:
                return Action.C if weighted_coop_rate >= self.breakeven_threshold else Action.D
        dynamic_threshold = self.breakeven_threshold
        if round_num >= 1:
            last_round_coop = opponent_actions[-1, :]
            last_round_defections = np.sum(~last_round_coop.astype(bool))
            last_round_cooperations = np.sum(last_round_coop.astype(bool))
            dynamic_threshold += last_round_defections * 0.05 - last_round_cooperations * 0.05
            dynamic_threshold = max(0.0, min(1.0, dynamic_threshold))
        min_coop_rate = 1.0
        if round_num >= 3:
            for opponent_idx in range(n_opponents):
                opp_coop = np.sum(opponent_actions[-3:, opponent_idx]) / 3.0
                min_coop_rate = min(min_coop_rate, opp_coop)
            if min_coop_rate == 0.0:
                return Action.D
        if weighted_coop_rate >= dynamic_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_71(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Strategic Defection.
    
    Uses generous tit-for-tat with threshold monitoring. Cooperates when the average
    contribution rate exceeds the break-even threshold (k-1)/k, except in the final round
    where it defects unconditionally. Includes special handling for unanimous defection
    and round 2 stabilization.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = (game_description.k - 1) / game_description.k
        self.last_contribution_rate = None
        self.consecutive_defection_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        prev_round_idx = current_round - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        total_cooperators = int(my_prev_action) + int(np.sum(opponent_prev_actions))
        contribution_rate = total_cooperators / n_players
        if contribution_rate == 0:
            self.consecutive_defection_rounds += 1
            return Action.D
        else:
            self.consecutive_defection_rounds = 0
        if current_round == 1:
            if contribution_rate < self.threshold:
                return Action.D
            else:
                return Action.C
        threshold_lower = self.threshold * 0.9
        threshold_upper = self.threshold * 1.1
        if contribution_rate >= self.threshold:
            return Action.C
        elif threshold_lower <= contribution_rate < self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_72(BaseStrategy):
    """
    Adaptive Contribution Strategy for N-Player Public Goods Games.
    
    Maximizes collective welfare while remaining robust to exploitation by:
    1. Contributing in round 1 to signal conditional cooperation
    2. Adaptively reciprocating based on group cooperation rates in rounds 2 to (r-2)
    3. Defecting in the final round (with exception for sustained high cooperation)
    4. Adjusting thresholds based on game parameters and cooperation trends
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold_high = 0.6
        self.threshold_low = 0.3
        self._adjust_thresholds_for_parameters()
        self.cooperation_history = []

    def _adjust_thresholds_for_parameters(self) -> None:
        """Adjust threshold values based on game parameters."""
        if self.n_players > 8:
            self.threshold_high += 0.05
            self.threshold_low += 0.05
        if self.k < 1.3:
            self.threshold_high = 0.8
            self.threshold_low = 0.5
        elif self.k > self.n_players * 0.8:
            self.threshold_high = 0.5
            self.threshold_low = 0.2

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the group cooperation rate in the most recent completed round."""
        if len(history.my_actions) == 0:
            return 0.0
        my_action = history.my_actions[-1]
        opponent_actions = history.opponent_actions[-1, :]
        total_cooperators = float(my_action) + float(np.sum(opponent_actions))
        cooperation_rate = total_cooperators / self.n_players
        return cooperation_rate

    def _detect_trend(self) -> float:
        """Detect trend in cooperation rates over last 2-3 rounds. Returns trend direction."""
        if len(self.cooperation_history) < 2:
            return 0.0
        recent = self.cooperation_history[-2:]
        trend = recent[-1] - recent[-2]
        return trend

    def _adjust_thresholds_by_trend(self) -> None:
        """Adjust thresholds based on cooperation trend."""
        if len(self.cooperation_history) < 2:
            return
        trend = self._detect_trend()
        if trend > 0.05:
            self.threshold_high = max(0.4, self.threshold_high - 0.05)
        elif trend < -0.05:
            self.threshold_low = min(0.5, self.threshold_low + 0.05)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history)
        self.cooperation_history.append(cooperation_rate)
        self._adjust_thresholds_by_trend()
        if current_round == self.n_rounds - 1:
            if cooperation_rate >= 0.9 and len(self.cooperation_history) >= 2:
                if self.cooperation_history[-2] >= 0.85:
                    return Action.C
            return Action.D
        if self.threshold_low <= cooperation_rate < self.threshold_high:
            if cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate >= self.threshold_high:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_73(BaseStrategy):
    """
    Adaptive Threshold Cooperation strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by promoting sustainable cooperation through:
    - Dynamic threshold-based cooperation decisions
    - Defection in the final round (no future consequences)
    - Rolling average smoothing to handle noise
    - One-round reconciliation attempts after early deterioration
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        if self.n_players > 1:
            self.threshold = (self.n_players - self.k) / (self.n_players - 1)
        else:
            self.threshold = 0.0
        self.threshold = max(0.0, min(1.0, self.threshold))
        self.early_deterioration_round = None
        self.reconciliation_attempted = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        return self._middle_game_decision(state, history)

    def _middle_game_decision(self, state: GameState, history: PlayerHistory) -> Action:
        """
        Apply adaptive threshold cooperation rule for middle game rounds.
        """
        round_num = state.round_number
        prev_round_idx = round_num - 1
        opponents_cooperated = sum(history.opponent_actions[prev_round_idx, :])
        prev_coop_rate = opponents_cooperated / self.n_players
        if round_num >= 2:
            coop_rate = self._get_rolling_average_coop_rate(history, round_num)
        else:
            coop_rate = prev_coop_rate
        if round_num in (1, 2) and coop_rate < self.threshold:
            if self.early_deterioration_round is None:
                self.early_deterioration_round = round_num
                return Action.D
        if self.early_deterioration_round is not None and (not self.reconciliation_attempted):
            if round_num == self.early_deterioration_round + 1:
                self.reconciliation_attempted = True
                return Action.C
            elif round_num == self.early_deterioration_round + 2:
                reconciliation_round_idx = round_num - 1
                opponents_cooperated_after = sum(history.opponent_actions[reconciliation_round_idx, :])
                if opponents_cooperated_after / self.n_players >= self.threshold:
                    coop_rate = opponents_cooperated_after / self.n_players
                else:
                    return Action.D
        if coop_rate >= self.threshold:
            return Action.C
        else:
            return Action.D

    def _get_rolling_average_coop_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate 2-round rolling average of opponent cooperation rates.
        Includes the current round minus 1 and the round before that.
        """
        if round_num < 1:
            return 0.0
        start_idx = max(0, round_num - 2)
        end_idx = round_num
        total_cooperators = 0
        total_players_counted = 0
        for idx in range(start_idx, end_idx):
            opponents_cooperated = sum(history.opponent_actions[idx, :])
            total_cooperators += opponents_cooperated
            total_players_counted += self.n_players
        if total_players_counted == 0:
            return 0.0
        return total_cooperators / total_players_counted

class Strategy_COLLECTIVE_74(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by conditioning contributions on demonstrable group cooperation,
    while maintaining individual resilience against exploitation. Uses dynamic thresholds that
    relax over time, detects free-riders and collapse scenarios, and employs probabilistic
    contribution for medium cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.free_rider_defection_count = {}
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_contributions = int(np.sum(history.my_actions)) + int(np.sum(history.opponent_actions))
        total_possible = self.game_description.n_players * state.round_number
        coop_rate = total_contributions / total_possible if total_possible > 0 else 0.0
        if coop_rate < 0.2:
            last_round_cooperators = int(np.sum(history.opponent_actions[-1, :]))
            if history.my_actions[-1]:
                last_round_cooperators += 1
            return Action.C if last_round_cooperators > self.game_description.n_players / 2 else Action.D
        threshold_adjustment = 0.0
        for player_idx in range(self.game_description.n_players - 1):
            opponent_actions = history.opponent_actions[:, player_idx]
            recent_rounds = min(3, state.round_number)
            recent_defections = recent_rounds - int(np.sum(opponent_actions[-recent_rounds:]))
            if recent_defections >= 3:
                if player_idx not in self.free_rider_defection_count:
                    self.free_rider_defection_count[player_idx] = 0
                self.free_rider_defection_count[player_idx] += 1
                threshold_adjustment += 0.1
        if state.round_number > 0:
            last_round_cooperators = int(np.sum(history.opponent_actions[-1, :]))
            if history.my_actions[-1]:
                last_round_cooperators += 1
            defection_rate = 1.0 - last_round_cooperators / self.game_description.n_players
            if defection_rate >= 0.5:
                threshold_adjustment += 0.15
        if state.round_number == self.game_description.n_rounds - 1:
            base_threshold = 0.25
        elif state.round_number >= self.game_description.n_rounds - 2:
            base_threshold = 0.25
        elif state.round_number <= 2:
            base_threshold = 0.5
        else:
            base_threshold = 0.4
        adjusted_threshold = min(base_threshold + threshold_adjustment, 0.9)
        if coop_rate >= adjusted_threshold:
            return Action.C
        elif 0.3 <= coop_rate < adjusted_threshold:
            return Action.C if random.random() < coop_rate else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_75(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Games.
    
    Balances reciprocal cooperation with strategic defection by using a dynamic threshold
    based on the marginal return to the public pool. Contributes when the average
    contribution rate meets or exceeds (k-1)/n, signaling that collective welfare improves.
    Includes special handling for first/last rounds and systematic defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = (self.k - 1) / self.n_players
        self.opponent_contribution_rates = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        self._update_opponent_profiles(history)
        prev_round_idx = round_num - 1
        prev_contributions = history.opponent_actions[prev_round_idx, :]
        prev_avg_contribution = float(np.mean(prev_contributions))
        if round_num == self.n_rounds - 1:
            if self._get_overall_contribution_rate(history) >= 0.8:
                return Action.C
            else:
                return Action.D
        if prev_avg_contribution >= self.threshold:
            return Action.C
        else:
            return Action.D

    def _update_opponent_profiles(self, history: PlayerHistory) -> None:
        """
        Track individual opponent contribution patterns to identify
        free-riders (<20%) and reciprocal partners (≥80%).
        """
        n_opponents = self.n_players - 1
        if self.opponent_contribution_rates is None:
            self.opponent_contribution_rates = np.zeros(n_opponents)
        for opp_idx in range(n_opponents):
            total_rounds_played = history.opponent_actions.shape[0]
            if total_rounds_played > 0:
                contributions = np.sum(history.opponent_actions[:, opp_idx])
                self.opponent_contribution_rates[opp_idx] = contributions / total_rounds_played

    def _get_overall_contribution_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the overall historical contribution rate across all rounds
        and all players (excluding self).
        """
        total_rounds = history.opponent_actions.shape[0]
        if total_rounds == 0:
            return 0.0
        total_contributions = np.sum(history.opponent_actions)
        total_possible = total_rounds * self.n_players - total_rounds
        if total_possible == 0:
            return 0.0
        return total_contributions / total_possible

class Strategy_COLLECTIVE_76(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game using conditional cooperation
    with adaptive defection thresholds based on group contribution rates.
    
    Core principle: Maximize group welfare through tit-for-tat cooperation on aggregate
    contribution rates, with generous tolerance for moderate free-riding and final-round defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        total_contributions = int(my_prev_action) + int(np.sum(opponent_prev_actions))
        contrib_rate = total_contributions / self.game_description.n_players
        if contrib_rate >= 0.5:
            return Action.C
        elif contrib_rate > 0.2:
            if random.random() < 0.75:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_77(BaseStrategy):
    """
    Collective Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by conditioning contributions on cooperation ratio,
    collective payoff trends, and reciprocity signals. Includes decay-based adjustment,
    final round adaptation, and special handling for extreme cooperation scenarios.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_history = []
        self.payoff_history = []
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        last_round_idx = current_round - 1
        my_last_action = history.my_actions[last_round_idx]
        my_last_payoff = history.my_payoffs[last_round_idx]
        total_cooperators = int(my_last_action) + np.sum(history.opponent_actions[last_round_idx, :])
        cooperation_ratio = total_cooperators / n
        self.cooperation_history.append(cooperation_ratio)
        all_payoffs = np.concatenate([[my_last_payoff], history.opponent_payoffs[last_round_idx, :]])
        collective_payoff = np.mean(all_payoffs)
        self.payoff_history.append(collective_payoff)
        payoff_is_stable_or_increasing = True
        if len(self.payoff_history) >= 2:
            payoff_is_stable_or_increasing = self.payoff_history[-1] >= self.payoff_history[-2]
        avg_payoff = collective_payoff
        if current_round == r - 1:
            if cooperation_ratio >= 0.7:
                return Action.C
            return Action.D
        if cooperation_ratio < 0.1:
            defect_count = sum((1 for cr in self.cooperation_history[-2:] if cr < 0.1))
            if defect_count >= 2:
                return Action.C
            return Action.D
        if cooperation_ratio >= 0.9:
            return Action.C
        if 0.4 <= cooperation_ratio < 0.6:
            if cooperation_ratio >= 0.5:
                return Action.C
            return Action.D
        cooperation_trend = 'stable'
        if len(self.cooperation_history) >= 3:
            recent_three = self.cooperation_history[-3:]
            if recent_three[-1] > recent_three[0] + 0.1:
                cooperation_trend = 'rising'
            elif recent_three[-1] < recent_three[0] - 0.1:
                cooperation_trend = 'falling'
        was_only_defector = False
        if not my_last_action and cooperation_ratio > 0.5:
            opponent_defectors = n - 1 - int(np.sum(history.opponent_actions[last_round_idx, :]))
            was_only_defector = opponent_defectors == 0
        if was_only_defector and collective_payoff < (avg_payoff if len(self.payoff_history) > 1 else collective_payoff):
            return Action.C
        if cooperation_ratio >= 0.5:
            if payoff_is_stable_or_increasing:
                if cooperation_trend == 'rising':
                    return Action.C
                return Action.C
            return Action.D
        if cooperation_ratio < 0.3:
            return Action.D
        if not payoff_is_stable_or_increasing:
            return Action.D
        if len(self.cooperation_history) >= 2:
            ratio_drop = self.cooperation_history[-2] - self.cooperation_history[-1]
            if my_last_action and ratio_drop > 0.2 and (my_last_payoff < avg_payoff):
                return Action.D
        if my_last_action and my_last_payoff < avg_payoff:
            return Action.C
        return Action.C if cooperation_ratio >= 0.5 else Action.D

class Strategy_COLLECTIVE_78(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Defensive Defection.
    
    Cooperates in round 1, applies dynamic threshold-based conditional cooperation
    in middle rounds, and defects in the final round.
    
    Threshold(t) = max(0.5, recent_avg_cooperation_rate - 0.15)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if round_number == 0:
            return Action.C
        if round_number == n_rounds - 1:
            return Action.D
        previous_round_idx = round_number - 1
        my_previous_action = history.my_actions[previous_round_idx]
        opponent_cooperators = np.sum(history.opponent_actions[previous_round_idx, :])
        total_cooperators = int(my_previous_action) + opponent_cooperators
        empirical_cooperation_rate = total_cooperators / n_players
        threshold = max(0.5, empirical_cooperation_rate - 0.15)
        if empirical_cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_79(BaseStrategy):
    """
    Adaptive Conditional Cooperation strategy for N-Player Public Goods Game.
    
    Cooperates based on observed cooperation rates, with dynamic thresholds that
    adapt to game structure and time horizon. Balances optimism about cooperation
    with pragmatic protection against free-riding.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.base_threshold = 1.0 / self.k + 0.15
        self.end_game_elevation = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        previous_round_idx = round_number - 1
        my_action_prev = history.my_actions[previous_round_idx]
        opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
        total_cooperators = int(my_action_prev) + int(np.sum(opponent_actions_prev))
        cooperation_rate = total_cooperators / self.n_players
        is_end_game = round_number >= self.n_rounds - 2
        if is_end_game:
            threshold = self.base_threshold + self.end_game_elevation
        else:
            threshold = self.base_threshold
        if cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_80(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation that punishes defection
    while remaining resilient to exploitation. Uses dynamic thresholds that decrease over
    time, tracks cooperation history, and applies tit-for-tat by group composition when
    cooperation never stabilizes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_met_threshold = False

    def _calculate_threshold(self, round_number: int) -> float:
        """
        Calculate the cooperation threshold for a given round.
        
        Starts at 50%, gradually decreases toward 70% (increases threshold requirement)
        as the game progresses, never falling below 70%.
        
        threshold(round) = max(0.7, 0.5 + (1 - round / total_rounds) * 0.2)
        
        This ensures:
        - Round 0: threshold = 0.7 (clamped)
        - Early rounds: threshold closer to 0.5
        - Late rounds: threshold approaches 0.7
        """
        total_rounds = self.game_description.n_rounds
        if total_rounds <= 1:
            return 0.5
        threshold = 0.5 + (1.0 - round_number / total_rounds) * 0.2
        return max(0.7, threshold)

    def _get_cooperation_rate(self, actions: NDArray[np.bool_]) -> float:
        """
        Calculate the cooperation rate from opponent actions in the last round.
        
        Returns the proportion of players (including self) who cooperated.
        """
        if len(actions) == 0:
            return 0.0
        return float(np.mean(actions))

    def _should_cooperate_threshold_rule(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Apply primary threshold rule: cooperate if previous round cooperation >= threshold.
        """
        prev_round_idx = current_round - 1
        my_action = history.my_actions[prev_round_idx]
        opponent_cooperators = np.sum(history.opponent_actions[prev_round_idx, :])
        total_cooperators = opponent_cooperators + (1 if my_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        threshold = self._calculate_threshold(current_round)
        return cooperation_rate >= threshold

    def _should_cooperate_fallback(self, history: PlayerHistory) -> bool:
        """
        Fallback tit-for-tat by group composition:
        Defect unless >60% of the group cooperated in the previous round.
        
        Used when threshold has never been met after round 2.
        """
        prev_round_idx = len(history.my_actions) - 1
        my_action = history.my_actions[prev_round_idx]
        opponent_cooperators = np.sum(history.opponent_actions[prev_round_idx, :])
        total_cooperators = opponent_cooperators + (1 if my_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        return cooperation_rate > 0.6

    def _has_threshold_been_met(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Check if the cooperation threshold has been met in any round from 1 to current_round-1.
        """
        for round_idx in range(1, current_round):
            my_action = history.my_actions[round_idx - 1]
            opponent_cooperators = np.sum(history.opponent_actions[round_idx - 1, :])
            total_cooperators = opponent_cooperators + (1 if my_action else 0)
            cooperation_rate = total_cooperators / self.game_description.n_players
            threshold = self._calculate_threshold(round_idx)
            if cooperation_rate >= threshold:
                return True
        return False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        final_threshold = 0.85
        if current_round >= final_threshold * self.game_description.n_rounds:
            my_action = history.my_actions[current_round - 1]
            opponent_cooperators = np.sum(history.opponent_actions[current_round - 1, :])
            total_cooperators = opponent_cooperators + (1 if my_action else 0)
            cooperation_rate = total_cooperators / self.game_description.n_players
            threshold = max(0.6, self._calculate_threshold(current_round) - 0.1)
            if cooperation_rate >= threshold:
                return Action.C
            return Action.D
        if not self._has_threshold_been_met(history, current_round):
            if current_round >= 2:
                if self._should_cooperate_fallback(history):
                    return Action.C
                return Action.D
        if self._should_cooperate_threshold_rule(history, current_round):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_81(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Games.
    
    Maximizes collective welfare through conditional cooperation that rewards mutual 
    contribution while protecting against exploitation. Uses a Collective Health Index (CHI)
    to determine cooperation levels, with special handling for isolation detection and 
    final round adjustments.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defection_counter > 0:
            self.defection_counter -= 1
            return Action.D
        prev_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        total_cooperators = int(my_prev_action) + int(np.sum(opponent_prev_actions))
        total_players = self.game_description.n_players
        if total_players == 0:
            chi = 0.0
        else:
            chi = total_cooperators / total_players * 100.0
        if my_prev_action and np.sum(opponent_prev_actions) == 0:
            self.defection_counter = 2
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if chi >= 75.0:
                return Action.C
            else:
                return Action.D
        if chi >= 60.0:
            return Action.C
        elif chi >= 40.0:
            if random.random() < chi / 100.0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_82(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Games.
    
    Balances reciprocal cooperation with opportunistic defection detection.
    Uses history-dependent decision rules to maximize individual security and collective welfare.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.defector_threshold = 0.7
        self.min_cooperation_rate_endgame = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if round_num == 0:
            return Action.C
        if history is not None and len(history.my_actions) > 0:
            all_actions = np.concatenate([history.my_actions.reshape(-1, 1), history.opponent_actions], axis=1)
            global_coop_rate = np.mean(all_actions)
        else:
            global_coop_rate = 1.0
        if round_num >= n_rounds - 2:
            if round_num == n_rounds - 1:
                if global_coop_rate >= self.threshold - 0.1:
                    return Action.C
                else:
                    return Action.D
            if global_coop_rate >= self.min_cooperation_rate_endgame:
                return Action.C
            else:
                return Action.D
        prev_round_actions = np.concatenate([np.array([history.my_actions[-1]]), history.opponent_actions[-1, :]])
        prev_coop_count = np.sum(prev_round_actions)
        prev_coop_rate = prev_coop_count / n_players
        opponent_coop_rates = np.mean(history.opponent_actions, axis=0)
        consistent_defectors = opponent_coop_rates < 1.0 - self.defector_threshold
        if len(history.opponent_actions) > 0:
            non_defector_actions = history.opponent_actions[:, ~consistent_defectors]
            if non_defector_actions.size > 0:
                adjusted_coop_rate = np.mean(non_defector_actions)
            else:
                adjusted_coop_rate = prev_coop_rate
        else:
            adjusted_coop_rate = prev_coop_rate
        if prev_coop_rate >= self.threshold:
            return Action.C
        rounds_remaining = n_rounds - round_num
        if global_coop_rate < 0.3 and rounds_remaining > 2:
            return Action.D
        if adjusted_coop_rate >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_83(BaseStrategy):
    """
    Adaptive Reciprocal Threshold Strategy (ARTS) for N-Player Public Goods Game.
    
    Maximizes collective welfare by maintaining high cooperation when conditions support it,
    while minimizing exploitation through conditional defection based on cooperation rates,
    thresholds, and remaining rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = (self.k - 1) / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        rounds_remaining = self.n_rounds - round_number
        prev_round_idx = round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx, :]
        my_prev_action = history.my_actions[prev_round_idx]
        cooperators_prev = int(np.sum(prev_opponent_actions))
        total_cooperators = cooperators_prev + (1 if my_prev_action else 0)
        cooperation_rate = total_cooperators / self.n_players
        if total_cooperators == 0:
            return Action.D
        if total_cooperators == self.n_players - 1:
            return Action.C
        if cooperation_rate >= self.threshold:
            return Action.C
        if cooperation_rate < self.threshold and rounds_remaining > 2:
            if random.random() < cooperation_rate:
                return Action.C
            else:
                return Action.D
        if rounds_remaining <= 2:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_84(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Uses conditional contribution based on empirical cooperation rate (ECR) with decay weighting,
    collective surplus analysis, and hysteresis thresholds. Adapts to group dynamics while
    avoiding exploitation and maintaining reciprocal fairness.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        ecr = self._calculate_ecr(history, round_num)
        if round_num < self.n_rounds - 1:
            return self._adaptive_decision(ecr, history, round_num)
        return self._final_round_decision(ecr, history, round_num)

    def _calculate_ecr(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate empirical cooperation rate with decay weighting.
        Recent rounds (2-3) have 1.5x weight, earlier rounds have 1.0x weight.
        """
        if round_num == 0:
            return 0.0
        total_weighted_contributions = 0.0
        total_weight = 0.0
        for t in range(round_num):
            weight = 1.5 if t >= max(0, round_num - 3) else 1.0
            my_contrib = 1.0 if history.my_actions[t] else 0.0
            opponent_contrib = np.sum(history.opponent_actions[t, :])
            total_contrib = my_contrib + opponent_contrib
            total_weighted_contributions += weight * total_contrib
            total_weight += weight * self.n_players
        ecr = total_weighted_contributions / total_weight if total_weight > 0 else 0.0
        return min(1.0, max(0.0, ecr))

    def _adaptive_decision(self, ecr: float, history: PlayerHistory, round_num: int) -> Action:
        """
        Adaptive phase (rounds 1 to r-2): Apply decision threshold with hysteresis.
        """
        if round_num >= 2:
            recent_rounds = min(3, round_num)
            recent_contrib = 0.0
            for t in range(round_num - recent_rounds, round_num):
                my_contrib = 1.0 if history.my_actions[t] else 0.0
                opponent_contrib = np.sum(history.opponent_actions[t, :])
                recent_contrib += my_contrib + opponent_contrib
            recent_ecr = recent_contrib / (recent_rounds * self.n_players)
            if recent_ecr < 0.25:
                return Action.D
        if round_num >= 3:
            for start in range(max(0, round_num - 3), round_num - 2):
                window_contrib = 0.0
                for t in range(start, min(start + 3, round_num)):
                    my_contrib = 1.0 if history.my_actions[t] else 0.0
                    opponent_contrib = np.sum(history.opponent_actions[t, :])
                    window_contrib += my_contrib + opponent_contrib
                window_ecr = window_contrib / (3.0 * self.n_players)
                if window_ecr > 0.8:
                    return Action.C
        universal_payoff = self.k
        defection_payoff = 1.0 + self.k / self.n_players * (self.n_players * ecr - 1.0)
        gap = universal_payoff - defection_payoff
        if gap > 0.15:
            return Action.C
        elif gap < -0.15:
            return Action.D
        else:
            contrib_prob = min(0.95, ecr + 0.2)
            if random.random() < contrib_prob:
                return Action.C
            else:
                return Action.D

    def _final_round_decision(self, ecr: float, history: PlayerHistory, round_num: int) -> Action:
        """
        Final round decision based on ECR and trend analysis.
        """
        if ecr >= 0.6:
            return Action.C
        if round_num >= 2:
            if self._is_increasing_trend(history, round_num):
                return Action.C
        return Action.D

    def _is_increasing_trend(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Check if ECR shows strictly increasing trend from round 1 onwards.
        """
        if round_num < 2:
            return False
        prev_ecr = 0.0
        for t in range(1, round_num):
            my_contrib = 1.0 if history.my_actions[t] else 0.0
            opponent_contrib = np.sum(history.opponent_actions[t, :])
            current_contrib = my_contrib + opponent_contrib
            current_ecr = current_contrib / self.n_players
            if current_ecr <= prev_ecr:
                return False
            prev_ecr = current_ecr
        return True

class Strategy_COLLECTIVE_85(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by sustaining cooperation when feasible while protecting
    against exploitation. Uses a rolling window of cooperation rates to make adaptive decisions
    with special handling for early game (establish norms), mid-game (apply thresholds),
    and endgame (backwards induction).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.window_size = 5
        self.mid_game_threshold = 0.6
        self.endgame_threshold = 0.7
        self.final_round_exception = 0.85
        self.min_remaining_rounds = 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round < 3:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            coop_rate = self._calculate_cooperation_rate(history, current_round)
            if coop_rate >= self.endgame_threshold:
                return Action.C
            return Action.D
        coop_rate = self._calculate_cooperation_rate(history, current_round)
        remaining_rounds = self.n_rounds - current_round
        if coop_rate >= self.mid_game_threshold and remaining_rounds >= self.min_remaining_rounds:
            return Action.C
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the historical cooperation rate across all players in the last W rounds.
        Returns a value between 0 and 1 representing the proportion of cooperation.
        """
        if current_round == 0:
            return 1.0
        window_start = max(0, current_round - self.window_size)
        window_end = current_round
        if window_start >= window_end:
            return 1.0
        own_cooperations = np.sum(history.my_actions[window_start:window_end])
        opponent_cooperations = np.sum(history.opponent_actions[window_start:window_end, :])
        total_actions = (window_end - window_start) * self.n_players
        total_cooperations = own_cooperations + opponent_cooperations
        if total_actions == 0:
            return 1.0
        cooperation_rate = total_cooperations / total_actions
        return cooperation_rate

class Strategy_COLLECTIVE_86(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare by maintaining cooperation when feasible,
    while protecting against exploitation. Uses conditional cooperation based
    on group cooperation rate with adaptive defection and recovery mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = self.k / self.n_players
        self.defection_rounds = 0
        self.last_gcr = None
        self.gcr_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_idx = state.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx, :]) + (1 if history.my_actions[prev_round_idx] else 0)
        gcr = prev_cooperators / self.n_players
        self.gcr_history.append(gcr)
        self.last_gcr = gcr
        return self._decide_action(state.round_number, gcr)

    def _decide_action(self, round_number: int, gcr: float) -> Action:
        """
        Decide whether to cooperate or defect based on GCR and history.
        """
        if gcr == 0:
            if len(self.gcr_history) >= 2 and self.gcr_history[-2] == 0:
                self.defection_rounds += 1
                return Action.D
        if gcr == 1:
            self.defection_rounds = 0
            return Action.C
        if self.n_players == 2:
            if len(self.gcr_history) >= 3:
                recent_gcrs = self.gcr_history[-3:]
                if all((g < self.threshold for g in recent_gcrs)):
                    self.defection_rounds += 1
                    return Action.D
        if gcr >= self.threshold:
            if self.defection_rounds > 0:
                self.defection_rounds = 0
            return Action.C
        if self.defection_rounds >= 2:
            if len(self.gcr_history) >= 2 and self.gcr_history[-1] > self.gcr_history[-2]:
                self.defection_rounds = 0
                return Action.C
            self.defection_rounds += 1
            return Action.D
        if self.defection_rounds == 1:
            if gcr > self.threshold:
                self.defection_rounds = 0
                return Action.C
            else:
                self.defection_rounds += 1
                return Action.D
        if self.defection_rounds == 0 and gcr < self.threshold:
            self.defection_rounds = 1
            return Action.D
        self.defection_rounds = 0
        return Action.C

class Strategy_COLLECTIVE_87(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation that responds to 
    demonstrated group trustworthiness, while maintaining individual rationality as fallback.
    
    Core decision: Contribute if recent cooperation rate >= k/n threshold, else defect.
    Special cases: Signal cooperation in round 1, defect in final round, tolerate free-riding.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = self.k / self.n_players
        self.window_size = min(5, max(1, self.n_rounds // 3))
        self.consecutive_high_coop = 0
        self.adaptive_threshold = self.threshold
        self.rounds_of_defection = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            if random.random() < self.threshold:
                return Action.C
            else:
                return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        window_start = max(0, round_num - self.window_size)
        window_end = round_num
        opponent_window = history.opponent_actions[window_start:window_end, :]
        if opponent_window.shape[0] == 0:
            return Action.C
        total_cooperations = np.sum(opponent_window)
        total_possible = opponent_window.shape[0] * opponent_window.shape[1]
        recent_coop_rate = total_cooperations / total_possible if total_possible > 0 else 0.0
        if recent_coop_rate == 0.0:
            self.rounds_of_defection += 1
            self.consecutive_high_coop = 0
            return Action.D
        if recent_coop_rate == 1.0:
            self.consecutive_high_coop += 1
            self.rounds_of_defection = 0
            if self.consecutive_high_coop >= 3:
                self.adaptive_threshold = self.threshold * 0.95
            return Action.C
        free_riding_tolerance = 0.2
        defection_rate = 1.0 - recent_coop_rate
        if defection_rate > 1.0 - free_riding_tolerance:
            self.consecutive_high_coop = 0
            self.rounds_of_defection += 1
            return Action.D
        if recent_coop_rate >= self.adaptive_threshold:
            self.consecutive_high_coop += 1
            self.rounds_of_defection = 0
            return Action.C
        else:
            self.consecutive_high_coop = 0
            self.rounds_of_defection += 1
            return Action.D

class Strategy_COLLECTIVE_88(BaseStrategy):
    """
    Adaptive Reciprocal Contribution (ARC) Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare while maintaining individual rationality through
    graduated reciprocity that adapts to observed cooperation rates and remaining
    game horizon.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        rcr = self._calculate_rcr(history, current_round)
        if current_round == self.n_rounds - 1:
            if rcr >= 0.5:
                return Action.C
            else:
                return Action.D
        if rcr >= 0.5:
            return Action.C
        elif rcr > 0.1:
            contribution_prob = 2.0 * rcr
            if random.random() < contribution_prob:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_rcr(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate Recent Cooperation Rate (RCR).
        RCR = (total contributions in last 3 rounds) / (3 × n)
        Uses all available history if fewer than 3 prior rounds exist.
        """
        lookback_rounds = min(3, current_round)
        if lookback_rounds == 0:
            return 0.0
        total_contributions = 0
        for round_idx in range(current_round - lookback_rounds, current_round):
            if history.my_actions[round_idx]:
                total_contributions += 1
        for round_idx in range(current_round - lookback_rounds, current_round):
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_contributions += 1
        rcr = total_contributions / (lookback_rounds * self.n_players)
        return rcr

class Strategy_COLLECTIVE_89(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by contributing when the group demonstrates
    sufficient reciprocal commitment (threshold T=0.5), while protecting against
    free-rider exploitation through conditional cooperation and adaptive refinement.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.consecutive_sole_contributor_rounds = 0
        self.last_contribution_rate = None
        self.sharp_decline_detected = False
        self.permanent_defection = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        current_round = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        prev_round_idx = current_round - 1
        cooperators_prev_round = int(np.sum(opponent_actions[prev_round_idx, :]))
        if my_actions[prev_round_idx]:
            cooperators_prev_round += 1
        contribution_rate_prev = cooperators_prev_round / n_players
        if self.last_contribution_rate is not None:
            decline = self.last_contribution_rate - contribution_rate_prev
            if decline >= 0.3:
                self.sharp_decline_detected = True
                self.threshold = 0.35
            elif self.sharp_decline_detected and contribution_rate_prev >= self.last_contribution_rate:
                self.sharp_decline_detected = False
                self.threshold = 0.5
            elif self.sharp_decline_detected and contribution_rate_prev < 0.35:
                self.permanent_defection = True
        self.last_contribution_rate = contribution_rate_prev
        if self.permanent_defection:
            return Action.D
        my_recent_actions = my_actions[max(0, current_round - 3):current_round]
        if len(my_recent_actions) >= 3:
            if np.sum(my_recent_actions) == len(my_recent_actions):
                opponent_cooperators_recent = np.sum(opponent_actions[max(0, current_round - 3):current_round, :], axis=1)
                if np.all(opponent_cooperators_recent < n_players // 3):
                    self.consecutive_sole_contributor_rounds += 1
                    if self.consecutive_sole_contributor_rounds >= 3:
                        self.consecutive_sole_contributor_rounds = 0
                        return Action.D
                else:
                    self.consecutive_sole_contributor_rounds = 0
            else:
                self.consecutive_sole_contributor_rounds = 0
        if current_round <= 3:
            return Action.C
        if current_round == n_rounds - 1:
            if contribution_rate_prev >= self.threshold:
                return Action.C
            else:
                return Action.D
        if contribution_rate_prev >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_90(BaseStrategy):
    """
    Adaptive Collective Strategy for N-Player Public Goods Game.
    
    Maximizes group welfare by conditioning cooperation on observable evidence
    that the group can sustain it, while maintaining individual rationality as fallback.
    Incorporates defection spiral detection, exploitation resistance, and recovery modes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.threshold = 1.0 / self.k + 0.15
        self.recovery_threshold = self.threshold - 0.1
        self.soft_defection_threshold = self.threshold - 0.2
        self.consecutive_below_threshold = 0
        self.penalty_rounds_remaining = 0
        self.exploitation_punishment_rounds = 0
        self.last_round_cooperation_rate = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_idx = state.round_number - 1
        prev_round_opponent_actions = history.opponent_actions[prev_round_idx, :]
        prev_cooperators = np.sum(prev_round_opponent_actions)
        prev_cooperation_rate = prev_cooperators / self.n
        self.last_round_cooperation_rate = prev_cooperation_rate
        if self.exploitation_punishment_rounds > 0:
            self.exploitation_punishment_rounds -= 1
            return Action.D
        if self.penalty_rounds_remaining > 0:
            self.penalty_rounds_remaining -= 1
            return Action.D
        if prev_cooperation_rate >= 1.0 and state.round_number >= 2:
            if state.round_number >= 2:
                two_rounds_ago_idx = state.round_number - 2
                two_ago_cooperators = np.sum(history.opponent_actions[two_rounds_ago_idx, :])
                two_ago_rate = two_ago_cooperators / self.n
                if two_ago_rate >= 1.0:
                    current_round_idx = state.round_number
                    if current_round_idx < self.r:
                        current_cooperators = np.sum(history.opponent_actions[current_round_idx - 1, :])
                        defection_increase = two_ago_cooperators - current_cooperators
                        if defection_increase > 2:
                            self.exploitation_punishment_rounds = 2
                            return Action.D
        if prev_cooperation_rate < self.threshold:
            self.consecutive_below_threshold += 1
            if self.consecutive_below_threshold >= 2:
                self.penalty_rounds_remaining = 1
                self.consecutive_below_threshold = 0
                return Action.D
        else:
            self.consecutive_below_threshold = 0
        if state.round_number == self.r - 1:
            if prev_cooperation_rate >= self.soft_defection_threshold:
                return Action.C
            return Action.D
        if prev_cooperation_rate >= self.recovery_threshold:
            return Action.C
        if prev_cooperation_rate >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_91(BaseStrategy):
    """
    Adaptive Reciprocal Contribution (ARC) Strategy for N-Player Public Goods Game.
    
    Cooperates when empirical cooperation rate of opponents exceeds threshold (k-1)/k,
    defects otherwise. Maintains consistency in final round and uses moving average
    for noise reduction in small groups.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.base_threshold = (self.k - 1) / self.k
        if self.n_players <= 3:
            self.threshold = max(0, self.base_threshold - 0.1)
        else:
            self.threshold = self.base_threshold

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the empirical cooperation rate of opponents."""
        if history.opponent_actions.size == 0:
            return 0.0
        rounds_elapsed = history.opponent_actions.shape[0]
        num_opponents = history.opponent_actions.shape[1]
        if rounds_elapsed == 0 or num_opponents == 0:
            return 0.0
        total_cooperations = int(np.sum(history.opponent_actions))
        cooperation_rate = total_cooperations / (num_opponents * rounds_elapsed)
        return cooperation_rate

    def _calculate_cooperation_rate_moving_avg(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate using moving average of last 3 rounds."""
        if history.opponent_actions.size == 0:
            return 0.0
        rounds_elapsed = history.opponent_actions.shape[0]
        num_opponents = history.opponent_actions.shape[1]
        if rounds_elapsed == 0 or num_opponents == 0:
            return 0.0
        lookback_window = min(3, rounds_elapsed)
        recent_actions = history.opponent_actions[-lookback_window:, :]
        total_cooperations = int(np.sum(recent_actions))
        cooperation_rate = total_cooperations / (num_opponents * lookback_window)
        return cooperation_rate

    def _should_cooperate(self, cooperation_rate: float) -> bool:
        """Decide whether to cooperate based on cooperation rate."""
        return cooperation_rate >= self.threshold

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if self.n_players <= 3:
                cooperation_rate = self._calculate_cooperation_rate_moving_avg(history)
            else:
                cooperation_rate = self._calculate_cooperation_rate(history)
            if self._should_cooperate(cooperation_rate):
                return Action.C
            else:
                return Action.D
        if self.n_players <= 3:
            cooperation_rate = self._calculate_cooperation_rate_moving_avg(history)
        else:
            cooperation_rate = self._calculate_cooperation_rate(history)
        if self._should_cooperate(cooperation_rate):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_92(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by maintaining cooperation when sustainable,
    while gracefully degrading to individual rationality when group cooperation fails.
    Balances genuine collective benefit with robustness against free-riders.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self._compute_thresholds()

    def _compute_thresholds(self) -> None:
        """Compute cooperation rate threshold based on game parameters."""
        base_threshold = 0.5
        if self.k >= self.n_players - 1:
            base_threshold = 0.6
        if self.n_players <= 3:
            base_threshold = 0.4
        self.cooperation_threshold = base_threshold
        self.collapse_threshold = 0.4

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if self.n_rounds == 1 or current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.C
        prev_round_idx = current_round - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_cooperators = np.sum(history.opponent_actions[prev_round_idx, :])
        total_cooperators = int(my_prev_action) + opponent_prev_cooperators
        cooperation_rate = total_cooperators / self.n_players
        if current_round >= 2:
            prev_prev_round_idx = current_round - 2
            my_prev_prev_action = history.my_actions[prev_prev_round_idx]
            opponent_prev_prev_cooperators = np.sum(history.opponent_actions[prev_prev_round_idx, :])
            total_cooperators_prev_prev = int(my_prev_prev_action) + opponent_prev_prev_cooperators
            cooperation_rate_prev = total_cooperators_prev_prev / self.n_players
            cooperation_drop = cooperation_rate_prev - cooperation_rate
            if cooperation_drop > self.collapse_threshold:
                return Action.D
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif current_round <= 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_93(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation with adaptive
    defection thresholds. Initiates cooperation, maintains it when group reciprocates,
    withdraws when group defects, and defects in final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        return self._conditional_decision(state, history)

    def _conditional_decision(self, state: GameState, history: PlayerHistory) -> Action:
        """
        Determine action based on recent cooperation rate among other players.
        """
        recent_coop_rate = self._calculate_recent_coop_rate(history)
        my_coop_rate = self._calculate_my_coop_rate(history)
        coop_threshold = self._get_cooperation_threshold()
        if recent_coop_rate >= coop_threshold:
            return Action.C
        elif my_coop_rate > 0.5:
            return Action.D
        else:
            return Action.D

    def _calculate_recent_coop_rate(self, history: PlayerHistory) -> float:
        """
        Calculate cooperation rate of other players over last 3-5 rounds
        (or all previous rounds if fewer than 5 exist).
        Returns a value in [0, 1].
        """
        num_rounds_completed = len(history.my_actions)
        lookback_rounds = min(5, num_rounds_completed)
        if lookback_rounds == 0:
            return 0.5
        recent_opponent_actions = history.opponent_actions[-lookback_rounds:, :]
        total_cooperations = np.sum(recent_opponent_actions)
        total_possible = lookback_rounds * (self.n_players - 1)
        if total_possible == 0:
            return 0.5
        coop_rate = total_cooperations / total_possible
        return float(coop_rate)

    def _calculate_my_coop_rate(self, history: PlayerHistory) -> float:
        """
        Calculate this player's cooperation rate over all completed rounds.
        Returns a value in [0, 1].
        """
        if len(history.my_actions) == 0:
            return 0.5
        my_cooperations = np.sum(history.my_actions)
        my_coop_rate = my_cooperations / len(history.my_actions)
        return float(my_coop_rate)

    def _get_cooperation_threshold(self) -> float:
        """
        Determine cooperation threshold based on game parameters.
        Default is 0.5, adjusted for edge cases.
        """
        threshold = 0.5
        if self.n_players == 2:
            threshold = 0.6
        elif self.n_players >= 5:
            threshold = 0.4
        if self.n_rounds <= 3:
            threshold = 0.5
        elif self.n_rounds > 20:
            threshold = 0.6
        return threshold

class Strategy_COLLECTIVE_94(BaseStrategy):
    """
    Collective Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation that rewards 
    contribution and penalizes free-riding, while maintaining robustness against 
    exploitation. Uses adaptive decision rules based on group cooperation rates,
    with escalating penalties for defection streaks and guaranteed cooperation 
    in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.high_defection_threshold = 0.3
        self.recovery_threshold = 0.6
        self.majority_cooperator_threshold = 0.7
        self.defection_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        if current_round == n_rounds - 1:
            return Action.C
        prev_round_idx = current_round - 1
        cooperators_prev = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        cooperation_rate = cooperators_prev / n_players if n_players > 0 else 0.0
        if current_round >= 2:
            cooperators_prev2 = int(np.sum(history.opponent_actions[prev_round_idx - 1, :]))
            cooperation_rate_prev = cooperators_prev2 / n_players if n_players > 0 else 0.0
            cooperation_rate = (cooperation_rate + cooperation_rate_prev) / 2.0
        if cooperation_rate < self.high_defection_threshold:
            self.defection_streak += 1
            if self.defection_streak >= 1:
                return Action.D
        elif cooperation_rate >= self.recovery_threshold:
            self.defection_streak = 0
        elif self.defection_streak == 0:
            self.defection_streak = 1
        if cooperation_rate > self.majority_cooperator_threshold:
            self.defection_streak = 0
            return Action.C
        if cooperation_rate >= self.cooperation_threshold:
            self.defection_streak = 0
            return Action.C
        elif self.defection_streak >= 3:
            return Action.D
        elif self.defection_streak >= 1:
            self.defection_streak += 1
            return Action.D
        else:
            self.defection_streak = 1
            return Action.D

class Strategy_COLLECTIVE_95(BaseStrategy):
    """
    Collective Strategy for Public Goods Game using Contribution-Responsive Cooperation.
    
    Contributes when group average contribution rate meets thresholds, defects otherwise.
    Optimizes for collective welfare while protecting against free-riders.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        previous_round_idx = current_round - 1
        self_contribution = 1 if history.my_actions[previous_round_idx] else 0
        opponent_contributions = np.sum(history.opponent_actions[previous_round_idx, :])
        total_contributions = self_contribution + opponent_contributions
        total_players = self.game_description.n_players
        average_contribution_rate = total_contributions / total_players
        rounds_remaining = n_rounds - current_round
        if rounds_remaining <= 2:
            threshold = 0.4
        else:
            threshold = 0.5
        if average_contribution_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_96(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare while remaining robust to free-riding.
    Uses a cooperation ratio threshold (50%) to decide between contributing and defecting.
    Includes recovery mechanisms when cooperation signals improvement.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_cooperation_ratio = None
        self.previous_round_ratio = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_cooperators = np.sum(history.opponent_actions[prev_round_idx, :])
        total_cooperators = int(my_prev_action) + opponent_cooperators
        cooperation_ratio = total_cooperators / self.game_description.n_players
        self.previous_round_ratio = self.last_cooperation_ratio
        self.last_cooperation_ratio = cooperation_ratio
        if self.previous_round_ratio is not None and self.previous_round_ratio <= 0.2 and (cooperation_ratio >= 0.4):
            return Action.C
        if cooperation_ratio >= 0.5:
            return Action.C
        elif cooperation_ratio > 0.2:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_97(BaseStrategy):
    """
    Collective Strategy for Public Goods Game.
    
    Implements conditional cooperation with a 50% threshold:
    - Round 1: Always cooperate (initialize cooperation signal)
    - Rounds 2-3: Use 2-round lagged average to smooth volatility
    - Round r (final): Follow conditional rule without future consideration
    - Other rounds: Cooperate if previous round's contribution rate >= 50%
    
    This strategy maximizes collective welfare through reciprocal cooperation
    while punishing systematic defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.contribution_rates = []
        self.calibration_phase_length = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        prev_round_idx = current_round - 1
        cooperators_prev = int(sum(history.opponent_actions[prev_round_idx, :]))
        if history.my_actions[prev_round_idx]:
            cooperators_prev += 1
        contribution_rate_prev = cooperators_prev / n_players
        if len(self.contribution_rates) <= prev_round_idx:
            self.contribution_rates.append(contribution_rate_prev)
        if current_round == n_rounds - 1:
            if contribution_rate_prev >= self.threshold:
                return Action.C
            return Action.D
        if current_round in {1, 2}:
            if current_round == 1:
                if contribution_rate_prev >= self.threshold:
                    return Action.C
                return Action.D
            elif current_round == 2:
                cooperators_round_0 = int(sum(history.opponent_actions[0, :]))
                if history.my_actions[0]:
                    cooperators_round_0 += 1
                contribution_rate_round_0 = cooperators_round_0 / n_players
                avg_contribution_rate = (contribution_rate_round_0 + contribution_rate_prev) / 2.0
                if avg_contribution_rate >= self.threshold:
                    return Action.C
                return Action.D
        if contribution_rate_prev >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_98(BaseStrategy):
    """
    Collective welfare maximizer using conditional cooperation with dynamic threshold.
    
    Cooperates if historical cooperation rate meets a dynamic threshold that starts
    optimistic (0.5) and gradually approaches 0.5 as the game progresses, preventing
    both exploitation and end-game defection spirals.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        rounds_remaining = self.game_description.n_rounds - state.round_number
        threshold = 0.5 + 0.5 / self.game_description.n_rounds * rounds_remaining
        current_round = state.round_number
        total_action_slots = current_round * self.game_description.n_players
        my_cooperations = np.sum(history.my_actions)
        opponent_cooperations = np.sum(history.opponent_actions)
        total_cooperations = my_cooperations + opponent_cooperations
        if total_action_slots == 0:
            return Action.C
        cooperation_rate = total_cooperations / total_action_slots
        if np.all(history.opponent_actions == False):
            return Action.D
        if np.all(history.my_actions == True) and np.all(history.opponent_actions == True):
            return Action.C
        if cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_99(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Balances optimism with pragmatism by maintaining high contribution rates while
    protecting against exploitation. Contributes when cooperation exceeds 50% threshold,
    defects when it falls below, with special handling for trend deterioration and
    final round dynamics.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_idx = state.round_number - 1
        total_cooperators_prev = int(sum(history.my_actions[previous_round_idx:previous_round_idx + 1]) + sum(history.opponent_actions[previous_round_idx, :]))
        cooperation_rate_prev = total_cooperators_prev / self.game_description.n_players
        if state.round_number == self.game_description.n_rounds - 1:
            if cooperation_rate_prev >= 0.5:
                return Action.C
            else:
                return Action.D
        if cooperation_rate_prev >= 0.5:
            if state.round_number >= 2:
                two_rounds_ago_idx = state.round_number - 2
                total_cooperators_two_ago = int(sum(history.my_actions[two_rounds_ago_idx:two_rounds_ago_idx + 1]) + sum(history.opponent_actions[two_rounds_ago_idx, :]))
                cooperation_rate_two_ago = total_cooperators_two_ago / self.game_description.n_players
                if cooperation_rate_prev < cooperation_rate_two_ago and cooperation_rate_prev < 0.7:
                    return Action.D
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_100(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation while maintaining
    resilience against exploitation. Uses threshold-based reciprocity: cooperate when
    observed contribution rate ≥ (k-1)/k, defect otherwise. Special handling for
    first round (cooperate) and final round (defect).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold = (self.k - 1) / self.k
        self.consecutive_low_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        if history is not None:
            prev_round_idx = round_num - 1
            my_contribution = 1 if history.my_actions[prev_round_idx] else 0
            opponent_contributions = np.sum(history.opponent_actions[prev_round_idx, :])
            total_contributors = my_contribution + opponent_contributions
            contribution_rate = total_contributors / self.n_players
            if contribution_rate >= self.threshold:
                self.consecutive_low_rounds = 0
                return Action.C
            else:
                self.consecutive_low_rounds += 1
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_101(BaseStrategy):
    """
    Adaptive Conditional Cooperation Strategy for N-Player Public Goods Games.
    
    Cooperates conditionally based on recent group cooperation rates, with strategic
    adjustments for game phase and opponent behavior patterns. Maximizes collective
    payoff while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num >= self.n_rounds - 2:
            return Action.D
        rounds_to_examine = min(3, round_num)
        start_idx = round_num - rounds_to_examine
        recent_opponent_actions = history.opponent_actions[start_idx:round_num, :]
        total_recent_contributions = np.sum(recent_opponent_actions) + np.sum(history.my_actions[start_idx:round_num])
        total_possible_contributions = self.n_players * rounds_to_examine
        rcr = total_recent_contributions / total_possible_contributions if total_possible_contributions > 0 else 0.0
        sudden_collapse = False
        if round_num >= 2:
            prev_rcr = self._calculate_rcr(history, round_num - 1, 3)
            if prev_rcr - rcr > 0.3:
                sudden_collapse = True
        if rcr >= 0.65:
            return Action.C
        elif rcr >= 0.4:
            if random.random() < rcr:
                return Action.C
            else:
                return Action.D
        elif sudden_collapse:
            if random.random() < rcr:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_rcr(self, history: PlayerHistory, round_num: int, lookback: int) -> float:
        """
        Calculate Recent Cooperation Rate from history up to (but not including) round_num.
        """
        if round_num <= 0:
            return 0.0
        rounds_to_examine = min(lookback, round_num)
        start_idx = round_num - rounds_to_examine
        recent_opponent_actions = history.opponent_actions[start_idx:round_num, :]
        recent_my_actions = history.my_actions[start_idx:round_num]
        total_recent_contributions = np.sum(recent_opponent_actions) + np.sum(recent_my_actions)
        total_possible_contributions = self.n_players * rounds_to_examine
        rcr = total_recent_contributions / total_possible_contributions if total_possible_contributions > 0 else 0.0
        return rcr

class Strategy_COLLECTIVE_102(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Uses conditional cooperation with dynamic thresholds based on observed
    cooperation rates of opponents. Reciprocates when cooperation is observed,
    defects when it is sparse, and uses stochastic matching in the middle zone.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        if self.n_players <= 3:
            self.threshold_high = 0.5
            self.threshold_low = 0.3
        elif self.n_players > 10:
            self.threshold_high = 0.6
            self.threshold_low = 0.3
        else:
            self.threshold_high = 0.5
            self.threshold_low = 0.25

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history, state.round_number)
        if cooperation_rate >= self.threshold_high:
            return Action.C
        elif cooperation_rate <= self.threshold_low:
            return Action.D
        else:
            return Action.C if random.random() < cooperation_rate else Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the average cooperation rate of all opponents across all previous rounds.
        
        Returns a value in [0, 1] representing the fraction of opponent actions that were C.
        """
        opponent_actions = history.opponent_actions[:current_round, :]
        if opponent_actions.size == 0:
            return 0.5
        total_cooperations = np.sum(opponent_actions)
        total_possible_actions = opponent_actions.shape[0] * opponent_actions.shape[1]
        if total_possible_actions == 0:
            return 0.5
        cooperation_rate = total_cooperations / total_possible_actions
        return cooperation_rate

class Strategy_COLLECTIVE_103(BaseStrategy):
    """
    Adaptive Reciprocal Threshold Strategy (ARTS) for N-Player Public Goods Game.
    
    Maximizes collective welfare by sustaining cooperation when feasible, while protecting
    against exploitation through strategic defection tied to observable contribution rates.
    Uses a dynamically-adjusted cooperation rate threshold with ratchet effects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_threshold = 0.4 if self.n_players == 2 else 0.5
        self.threshold_floor = 0.3
        self.threshold_cap = 0.8
        self.unanimous_defection_cooldown = 0
        self.recent_cooperation_rates = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        if self.unanimous_defection_cooldown > 0:
            self.unanimous_defection_cooldown -= 1
            return Action.D
        prev_round_idx = round_num - 1
        total_cooperators = sum(history.opponent_actions[prev_round_idx, :])
        if history.my_actions[prev_round_idx]:
            total_cooperators += 1
        cooperation_rate = total_cooperators / self.n_players
        self.recent_cooperation_rates.append(cooperation_rate)
        if len(self.recent_cooperation_rates) > 3:
            self.recent_cooperation_rates.pop(0)
        if cooperation_rate == 0:
            self.unanimous_defection_cooldown = 1
            return Action.D
        if len(self.recent_cooperation_rates) >= 2:
            max_rate = max(self.recent_cooperation_rates)
            min_rate = min(self.recent_cooperation_rates)
            if max_rate - min_rate > 0.4:
                self.cooperation_threshold = min(self.cooperation_threshold + 0.03, self.threshold_cap)
        if len(self.recent_cooperation_rates) >= 1:
            avg_recent = sum(self.recent_cooperation_rates) / len(self.recent_cooperation_rates)
            if avg_recent >= self.cooperation_threshold:
                pass
            else:
                self.cooperation_threshold = min(self.cooperation_threshold + 0.05, self.threshold_cap)
        if cooperation_rate > self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_104(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare by building and maintaining high-contribution equilibria,
    while protecting against free-riders through graduated defection that signals commitment
    to collective benefit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.game_description.n_players == 2:
            return self._two_player_strategy(history)
        return self._adaptive_strategy(history)

    def _two_player_strategy(self, history: PlayerHistory) -> Action:
        """
        Two-player variant: reciprocate opponent's last-round action directly.
        """
        opponent_last_action = history.opponent_actions[-1, 0]
        return Action.C if opponent_last_action else Action.D

    def _adaptive_strategy(self, history: PlayerHistory) -> Action:
        """
        General n-player strategy based on cooperation rate assessment.
        """
        prev_round_idx = -1
        all_actions_prev_round = np.concatenate([[history.my_actions[prev_round_idx]], history.opponent_actions[prev_round_idx, :]])
        cooperation_rate = np.mean(all_actions_prev_round)
        if cooperation_rate >= 0.75:
            return Action.C
        elif cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.25:
            return Action.D
        else:
            return Action.D
        if 0.45 <= cooperation_rate <= 0.55:
            prev_opponent_actions = history.opponent_actions[prev_round_idx, :]
            min_contributor = np.min(prev_opponent_actions)
            max_contributor = np.max(prev_opponent_actions)
            if min_contributor == 0 and max_contributor == 1:
                return Action.D
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_105(BaseStrategy):
    """
    Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation with collective memory.
    Uses dynamic threshold-based cooperation, coordinated punishment for free-riding clusters,
    and adaptive learning from player-level defection patterns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.current_threshold = 1.0
        self.decay_penalty = 0.05
        self.min_threshold = 0.5
        self.defection_budget = math.floor(game_description.n_rounds / 3)
        self.defections_used = 0
        self.punishment_rounds_remaining = 0
        self.opponent_defection_counts = [0] * (game_description.n_players - 1)
        self.opponent_opportunity_counts = [0] * (game_description.n_players - 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self._update_opponent_stats(history, state.round_number)
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if self._detect_free_riding_cluster(history, state.round_number):
            self.punishment_rounds_remaining = 2
            return Action.D
        if state.round_number >= self.n_rounds - 2:
            prev_cooperation_rate = self._get_cooperation_rate(history, state.round_number - 1)
            if prev_cooperation_rate >= 0.7:
                return Action.C
            return Action.D
        self._update_threshold(history, state.round_number)
        threshold_adjusted = self._apply_adaptive_shifts(history, state.round_number)
        prev_cooperation_rate = self._get_cooperation_rate(history, state.round_number - 1)
        if prev_cooperation_rate >= threshold_adjusted:
            return Action.C
        if self.defections_used < self.defection_budget:
            self.defections_used += 1
            return Action.D
        return Action.C

    def _update_opponent_stats(self, history: PlayerHistory, current_round: int) -> None:
        """Track defection rates by opponent player."""
        if current_round == 0:
            return
        for opp_idx in range(len(self.opponent_defection_counts)):
            self.opponent_opportunity_counts[opp_idx] += 1
            if not history.opponent_actions[current_round - 1, opp_idx]:
                self.opponent_defection_counts[opp_idx] += 1

    def _detect_free_riding_cluster(self, history: PlayerHistory, current_round: int) -> bool:
        """Detect 3+ consecutive players defecting in previous round."""
        if current_round == 0:
            return False
        prev_round_actions = history.opponent_actions[current_round - 1, :]
        consecutive_defections = 0
        for action in prev_round_actions:
            if not action:
                consecutive_defections += 1
                if consecutive_defections >= 3:
                    return True
            else:
                consecutive_defections = 0
        return False

    def _get_cooperation_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """Calculate cooperation rate in a given round across all players."""
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 1.0
        my_action = history.my_actions[round_idx]
        opponent_actions = history.opponent_actions[round_idx, :]
        total_cooperators = int(my_action) + int(np.sum(opponent_actions))
        cooperation_rate = total_cooperators / self.n_players
        return cooperation_rate

    def _update_threshold(self, history: PlayerHistory, current_round: int) -> None:
        """Update threshold based on previous round cooperation rate."""
        prev_cooperation_rate = self._get_cooperation_rate(history, current_round - 1)
        new_threshold = prev_cooperation_rate - self.decay_penalty
        self.current_threshold = max(self.min_threshold, new_threshold)

    def _apply_adaptive_shifts(self, history: PlayerHistory, current_round: int) -> float:
        """Apply adaptive shifts based on player-level defection patterns."""
        threshold = self.current_threshold
        if current_round == 0:
            return threshold
        persistent_defectors = 0
        for i in range(len(self.opponent_defection_counts)):
            if self.opponent_opportunity_counts[i] > 0:
                defection_rate = self.opponent_defection_counts[i] / self.opponent_opportunity_counts[i]
                if defection_rate >= 0.66:
                    persistent_defectors += 1
        if persistent_defectors > self.n_players / 3:
            threshold = max(self.min_threshold, threshold - 0.1)
        ever_defectors = sum((1 for count in self.opponent_defection_counts if count > 0))
        if ever_defectors < self.n_players / 6:
            threshold = min(1.0, threshold + 0.05)
        return threshold

class Strategy_COLLECTIVE_106(BaseStrategy):
    """
    Adaptive Collective Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation that rewards
    contributors and punishes free-riders, while remaining robust to exploitation.
    
    Core phases:
    - Rounds 0-2 (Exploration): CONTRIBUTE to signal cooperative intent
    - Rounds 3 to (r-3) (Adaptive): Conditional contribution based on group cooperation rate
    - Rounds (r-2) and (r-1) (Endgame): DEFECT (no future to incentivize cooperation)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num < 3:
            return Action.C
        if round_num >= self.n_rounds - 2:
            return Action.D
        prev_round_idx = round_num - 1
        prev_round_cooperators = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        prev_round_own_action = int(history.my_actions[prev_round_idx])
        total_prev_cooperators = prev_round_cooperators + prev_round_own_action
        cooperation_rate = total_prev_cooperators / self.n_players
        if round_num == 3:
            rounds_2_and_3_cooperators = int(np.sum(history.opponent_actions[1, :])) + int(np.sum(history.opponent_actions[2, :])) + int(history.my_actions[1]) + int(history.my_actions[2])
            if rounds_2_and_3_cooperators <= 1:
                return Action.D
        if cooperation_rate >= 0.5:
            if round_num >= self.n_rounds - 4 and cooperation_rate >= 0.7:
                return Action.C
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_107(BaseStrategy):
    """
    Threshold Reciprocity Strategy for N-Player Public Goods Game.
    
    Balances reciprocal cooperation with strategic robustness:
    - Round 1: Contribute (establish cooperative anchor)
    - Rounds 2 to r-1: Contribute if ≥50% of all players cooperated in previous round
    - Round r: Defect (end-game defection), unless cooperation sustained at ≥80% in rounds 2-(r-1)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            if self.n_rounds > 2:
                cooperation_rates = []
                for prev_round in range(1, round_num):
                    my_action = history.my_actions[prev_round]
                    opp_cooperators = np.sum(history.opponent_actions[prev_round, :])
                    total_cooperators = (1 if my_action else 0) + opp_cooperators
                    cooperation_rate = total_cooperators / self.n_players
                    cooperation_rates.append(cooperation_rate)
                if cooperation_rates and np.mean(cooperation_rates) >= 0.8:
                    return Action.C
            return Action.D
        prev_round = round_num - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_cooperators = np.sum(history.opponent_actions[prev_round, :])
        total_cooperators = (1 if my_prev_action else 0) + opp_prev_cooperators
        cooperation_rate = total_cooperators / self.n_players
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_108(BaseStrategy):
    """
    Adaptive Conditional Cooperation Strategy with Reciprocal Threshold Matching.
    
    Leads with cooperation in round 1, then reciprocates based on a dynamic threshold
    of observed cooperation rates. The threshold is forgiving (15-point buffer) but has
    a 50% floor. In the final round, defects unless cooperation was very strong (≥75%).
    Handles edge cases like defector clusters, gradual decay, and sudden spikes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if history is None:
            return Action.C
        prev_round_idx = current_round - 1
        cooperators_in_prev = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        cooperation_rate_prev = cooperators_in_prev / (n - 1) if n > 1 else 0.0
        self.cooperation_history.append(cooperation_rate_prev)
        avg_cooperation = np.mean(self.cooperation_history) if self.cooperation_history else 0.0
        buffer = 0.15
        if len(self.cooperation_history) >= 2:
            recent_avg = np.mean(self.cooperation_history[-5:]) if len(self.cooperation_history) >= 5 else np.mean(self.cooperation_history)
            older_avg = np.mean(self.cooperation_history[-10:-5]) if len(self.cooperation_history) >= 10 else np.mean(self.cooperation_history[:-5]) if len(self.cooperation_history) > 5 else avg_cooperation
            if recent_avg < older_avg:
                buffer = max(0.0, buffer - 0.05)
        threshold = max(0.5, avg_cooperation - buffer)
        if current_round == r - 1:
            if cooperation_rate_prev >= 0.75:
                return Action.C
            else:
                return Action.D
        if cooperation_rate_prev >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_109(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare by dynamically adjusting contribution based on 
    observed group cooperation levels with a 3-round rolling average, while 
    maintaining resilience against defection through probing mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        round_contributions = np.sum(opponent_actions, axis=1) + my_actions.astype(int)
        avg_contributions = round_contributions / self.game_description.n_players
        current_round = state.round_number
        if current_round >= 3:
            rolling_avg = np.mean(avg_contributions[-3:])
        else:
            rolling_avg = avg_contributions[-1]
        if rolling_avg < 0.3:
            if self.defection_streak >= 2:
                self.defection_streak = 0
                return Action.C
            else:
                self.defection_streak += 1
                return Action.D
        else:
            self.defection_streak = 0
        if rolling_avg >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_110(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Game.
    
    Maximizes collective welfare through conditional cooperation that rewards 
    contribution and isolates free-riders, while maintaining robustness against 
    exploitation. Classifies game state based on collective health metrics and 
    opponent behavior, adjusting contributions accordingly.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        last_round_idx = round_number - 1
        last_round_opponent_actions = history.opponent_actions[last_round_idx, :]
        num_cooperators_last_round = int(np.sum(last_round_opponent_actions))
        num_defectors_last_round = self.n_players - 1 - num_cooperators_last_round
        if num_cooperators_last_round == 0:
            return Action.D
        if num_defectors_last_round == 0:
            return Action.C
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators_last_round = num_cooperators_last_round + (1 if my_last_action else 0)
        average_contribution_rate = total_cooperators_last_round / self.n_players
        health_threshold = (self.k - 1) / self.k
        collective_health_strong = average_contribution_rate >= health_threshold
        if collective_health_strong and num_cooperators_last_round >= num_defectors_last_round + 2:
            return Action.C
        if not collective_health_strong and average_contribution_rate > 0.3:
            my_past_contributions = int(np.sum(history.my_actions[:round_number]))
            if my_past_contributions > 0:
                reciprocation_count = 0
                for past_round in range(round_number):
                    if history.my_actions[past_round]:
                        past_round_opponent_cooperators = int(np.sum(history.opponent_actions[past_round, :]))
                        if past_round_opponent_cooperators >= (self.n_players - 1) / 2:
                            reciprocation_count += 1
                reciprocation_rate = reciprocation_count / my_past_contributions if my_past_contributions > 0 else 0
                if reciprocation_rate >= 0.5:
                    return Action.C
        defection_rate = num_defectors_last_round / (self.n_players - 1) if self.n_players > 1 else 0
        if not collective_health_strong or defection_rate > 0.6:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_111(BaseStrategy):
    """
    Adaptive Conditional Cooperation strategy for N-Player Public Goods Game.
    
    Balances individual security with collective benefit-seeking through:
    - Seeding cooperation in round 1
    - Conditional cooperation based on dynamic thresholds in mid-game
    - End-game defection in final two rounds
    - Punitive defection when exploited in free-rider environments
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploitation_flags = 0
        self.punitive_rounds_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if round_num == 0:
            return Action.C
        if round_num >= n_rounds - 2:
            return Action.D
        if self.punitive_rounds_remaining > 0:
            self.punitive_rounds_remaining -= 1
            return Action.D
        if round_num >= 1:
            prev_round_idx = round_num - 1
            my_prev_action = history.my_actions[prev_round_idx]
            opponent_cooperators = np.sum(history.opponent_actions[prev_round_idx, :])
            total_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
            prev_coop_rate = total_cooperators / n_players
            if my_prev_action and prev_coop_rate < 0.3:
                self.exploitation_flags += 1
                if self.exploitation_flags >= 2:
                    self.punitive_rounds_remaining = 2
                    self.exploitation_flags = 0
                    return Action.D
            else:
                self.exploitation_flags = 0
        recent_rounds_to_check = min(2, round_num)
        start_idx = round_num - recent_rounds_to_check
        recent_coop_count = 0
        total_slots = 0
        for check_round in range(start_idx, round_num):
            opponent_cooperators = np.sum(history.opponent_actions[check_round, :])
            my_action = history.my_actions[check_round]
            total_cooperators = opponent_cooperators + (1 if my_action else 0)
            recent_coop_count += total_cooperators
            total_slots += n_players
        if total_slots > 0:
            recent_coop_rate = recent_coop_count / total_slots
        else:
            recent_coop_rate = 0.0
        threshold = max(0.4, recent_coop_rate - 0.1)
        if recent_coop_rate == 0.0:
            return Action.D
        if recent_coop_rate >= 0.7:
            return Action.C
        if recent_coop_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_112(BaseStrategy):
    """
    Collective Strategy for N-Player Public Goods Game.
    
    Maximizes collective welfare through conditional contribution based on recent
    cooperation rates, with adaptive thresholds that tighten in later rounds.
    Includes safeguards against exploitation and special handling for final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_low_coop_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_idx = state.round_number - 1
        prev_opponent_cooperators = sum(history.opponent_actions[prev_round_idx, :])
        my_prev_action = history.my_actions[prev_round_idx]
        total_cooperators_prev = prev_opponent_cooperators + (1 if my_prev_action else 0)
        cooperation_rate = total_cooperators_prev / self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        if current_round < 3:
            threshold = 0.5
        elif current_round < n_rounds - 2:
            threshold = 0.6
        else:
            threshold = 0.7
        if cooperation_rate < 0.3:
            self.consecutive_low_coop_rounds += 1
        else:
            self.consecutive_low_coop_rounds = 0
        if self.consecutive_low_coop_rounds >= 2:
            return Action.D
        if current_round == n_rounds - 1:
            all_opponent_cooperators = np.sum(history.opponent_actions)
            all_my_cooperations = np.sum(history.my_actions)
            total_all_cooperations = all_opponent_cooperators + all_my_cooperations
            total_possible_cooperations = self.game_description.n_players * state.round_number
            cumulative_coop_rate = total_all_cooperations / total_possible_cooperations if total_possible_cooperations > 0 else 0
            if cumulative_coop_rate >= 0.7:
                return Action.C
        if cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_113(BaseStrategy):
    """
    Adaptive Reciprocal Contribution Strategy for N-Player Public Goods Game.
    
    Contributes when observed cooperation rate exceeds the break-even threshold (k-1)/k,
    defects otherwise. Starts with cooperation in round 0, and applies weighted averaging
    for volatile histories.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold = (self.k - 1) / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history, state.round_number)
        if cooperation_rate >= self.threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed cooperation rate from all prior rounds.
        Applies weighted averaging if history is volatile.
        """
        prior_rounds = current_round
        if prior_rounds == 0:
            return 0.5
        my_contributions = np.sum(history.my_actions[:prior_rounds])
        opponent_contributions = np.sum(history.opponent_actions[:prior_rounds, :])
        total_contributions = my_contributions + opponent_contributions
        total_possible = self.n * prior_rounds
        base_cooperation_rate = total_contributions / total_possible if total_possible > 0 else 0.0
        if prior_rounds >= 2:
            cooperation_rates = self._get_period_cooperation_rates(history, prior_rounds)
            volatility = self._calculate_volatility(cooperation_rates)
            if volatility > 0.4:
                base_cooperation_rate = self._weighted_average_cooperation_rate(history, prior_rounds)
        return base_cooperation_rate

    def _get_period_cooperation_rates(self, history: PlayerHistory, num_rounds: int) -> list:
        """
        Calculate cooperation rate for each round.
        """
        rates = []
        for round_idx in range(num_rounds):
            my_contrib = 1 if history.my_actions[round_idx] else 0
            opponent_contrib = np.sum(history.opponent_actions[round_idx, :])
            total = my_contrib + opponent_contrib
            rate = total / self.n
            rates.append(rate)
        return rates

    def _calculate_volatility(self, rates: list) -> float:
        """
        Calculate volatility as max swing between consecutive periods.
        """
        if len(rates) < 2:
            return 0.0
        max_swing = 0.0
        for i in range(1, len(rates)):
            swing = abs(rates[i] - rates[i - 1])
            max_swing = max(max_swing, swing)
        return max_swing

    def _weighted_average_cooperation_rate(self, history: PlayerHistory, num_rounds: int) -> float:
        """
        Calculate weighted average cooperation rate:
        - Last 3 rounds: 50% weight
        - Earlier rounds: 50% weight
        """
        cooperation_rates = self._get_period_cooperation_rates(history, num_rounds)
        num_recent = min(3, num_rounds)
        num_earlier = num_rounds - num_recent
        recent_avg = np.mean(cooperation_rates[-num_recent:]) if num_recent > 0 else 0.0
        earlier_avg = np.mean(cooperation_rates[:-num_recent]) if num_earlier > 0 else 0.0
        if num_recent > 0 and num_earlier > 0:
            weighted = 0.5 * recent_avg + 0.5 * earlier_avg
        elif num_recent > 0:
            weighted = recent_avg
        else:
            weighted = earlier_avg
        return weighted

class Strategy_COLLECTIVE_114(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Games.
    
    Maximizes collective welfare through conditional cooperation that escalates
    pressure on defectors, while protecting against exploitation by maintaining
    a credible threat of coordinated defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            prev_round_cooperators = sum(history.opponent_actions[round_num - 1, :])
            if history.my_actions[round_num - 1]:
                prev_round_cooperators += 1
            coop_rate = prev_round_cooperators / self.n_players
            high_coop_threshold = (self.k - 1) / self.k
            if coop_rate >= high_coop_threshold:
                return Action.C
            return Action.D
        prev_round_cooperators = sum(history.opponent_actions[round_num - 1, :])
        if history.my_actions[round_num - 1]:
            prev_round_cooperators += 1
        coop_rate = prev_round_cooperators / self.n_players
        high_coop_threshold = (self.k - 1) / self.k
        moderate_coop_threshold = 0.5
        low_coop_threshold = 0.25
        if coop_rate >= high_coop_threshold:
            return Action.C
        elif coop_rate >= moderate_coop_threshold:
            if random.random() < coop_rate:
                return Action.C
            return Action.D
        elif coop_rate >= low_coop_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_115(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy for N-Player Public Goods Game.
    
    Cooperates in round 1 to test the group. In middle rounds (2 to r-2),
    cooperates if group cooperation rate meets an adaptive threshold that
    starts at 50% and adjusts based on historical cooperation trends.
    Defects in the final rounds (r-1 and r) due to endgame incentives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num >= r - 2:
            return Action.D
        prev_round_idx = round_num - 1
        prev_cooperators = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        prev_cooperators += int(history.my_actions[prev_round_idx])
        prev_coop_rate = prev_cooperators / n
        self.cooperation_history.append(prev_coop_rate)
        if self.cooperation_history:
            avg_coop_rate = np.mean(self.cooperation_history)
            threshold = max(0.5, avg_coop_rate - 0.15)
        else:
            threshold = 0.5
        if prev_coop_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_116(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Balances individual incentive compatibility with group optimization by:
    - Contributing in round 1 to signal cooperation
    - Conditionally contributing based on previous round's average contribution rate
    - Using probabilistic matching for partial cooperation
    - Defecting in the final round unless cooperation is strong
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        my_contribution = int(my_prev_action)
        opponent_contributions = opponent_prev_actions.astype(int)
        total_cooperators = my_contribution + np.sum(opponent_contributions)
        avg_contrib_prev = total_cooperators / self.game_description.n_players
        is_last_round = state.round_number == self.game_description.n_rounds - 1
        if is_last_round:
            if avg_contrib_prev >= 0.6:
                return Action.C
            else:
                return Action.D
        elif avg_contrib_prev >= 0.5:
            return Action.C
        elif avg_contrib_prev > 0:
            if random.random() < avg_contrib_prev:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_117(BaseStrategy):
    """
    Collective Public Goods Strategy: Maximizes collective welfare through conditional 
    cooperation with adaptive defection thresholds. Contributes based on group cooperation 
    rate and reciprocity from other players, with special handling for first/last rounds 
    and low-cooperation phases.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.breakeven_threshold = (self.k - 1) / self.k
        self.low_coop_threshold = 0.2
        self.reciprocity_threshold = 0.5
        self.consecutive_low_coop_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        prev_round_idx = round_number - 1
        opponent_cooperations_prev = sum(history.opponent_actions[prev_round_idx, :])
        my_cooperation_prev = 1 if history.my_actions[prev_round_idx] else 0
        total_cooperations_prev = opponent_cooperations_prev + my_cooperation_prev
        group_coop_rate = total_cooperations_prev / self.n_players
        if self.n_players > 1:
            personal_reciprocity = opponent_cooperations_prev / (self.n_players - 1)
        else:
            personal_reciprocity = 0.0
        if group_coop_rate < self.low_coop_threshold:
            self.consecutive_low_coop_rounds += 1
        else:
            self.consecutive_low_coop_rounds = 0
        if self.consecutive_low_coop_rounds >= 2:
            prob_contribute = group_coop_rate * self.k / self.n_players
            if random.random() < prob_contribute:
                return Action.C
            return Action.D
        if group_coop_rate >= self.breakeven_threshold and personal_reciprocity >= self.reciprocity_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_118(BaseStrategy):
    """
    Adaptive Conditional Cooperation Strategy for N-Player Public Goods Game.
    
    Cooperates conditionally based on group cooperation rates with adaptive thresholds.
    Opens with cooperation, maintains cooperation if group sustains it (>50% threshold),
    defects when group fails collectively, and recognizes end-game dynamics.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_low_cooperation_rounds = 0
        self.cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        last_round_threshold = math.ceil(0.9 * r)
        if round_number >= last_round_threshold:
            return Action.D
        previous_round_idx = round_number - 1
        cooperators_previous = int(np.sum(history.opponent_actions[previous_round_idx, :]))
        cooperation_rate = cooperators_previous / n
        self.cooperation_history.append(cooperation_rate)
        if cooperation_rate < 0.3:
            self.consecutive_low_cooperation_rounds += 1
        else:
            self.consecutive_low_cooperation_rounds = 0
        if self.consecutive_low_cooperation_rounds >= 3:
            return Action.D
        if len(self.cooperation_history) >= 2:
            smoothed_cooperation_rate = (self.cooperation_history[-1] + self.cooperation_history[-2]) / 2
        else:
            smoothed_cooperation_rate = cooperation_rate
        my_previous_payoff = history.my_payoffs[previous_round_idx]
        threshold_adjustment = 0.0
        if my_previous_payoff < 0:
            threshold_adjustment = -0.15
        last_5_rounds_threshold = math.ceil(0.95 * r)
        if round_number >= last_5_rounds_threshold:
            base_threshold = 0.6
        else:
            base_threshold = 0.5
        adjusted_threshold = base_threshold + threshold_adjustment
        if smoothed_cooperation_rate >= adjusted_threshold:
            return Action.C
        elif smoothed_cooperation_rate > 0.25:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_119(BaseStrategy):
    """
    Adaptive Collective Strategy for Public Goods Games.
    
    Balances cooperation and defection through:
    - Round 1: Cooperate to establish baseline
    - Rounds 2 to r-1: Conditional cooperation based on observed cooperation rate
    - Final round: Defect (end-game equilibrium)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold_high = 0.65
        self.cooperation_threshold_low = 0.35
        self.memory_weight_recent = 1.2
        self.memory_weight_older = 1.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history, state.round_number)
        if cooperation_rate >= self.cooperation_threshold_high:
            return Action.C
        elif cooperation_rate < self.cooperation_threshold_low:
            return Action.D
        elif random.random() < cooperation_rate:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the cooperation rate among other players in previous rounds,
        with decay-weighted memory favoring recent rounds.
        """
        n_opponents = self.game_description.n_players - 1
        if n_opponents == 0:
            return 0.5
        total_weighted_cooperation = 0.0
        total_weight = 0.0
        for round_idx in range(current_round):
            if round_idx == current_round - 1:
                weight = self.memory_weight_recent
            else:
                weight = self.memory_weight_older
            cooperators_in_round = np.sum(history.opponent_actions[round_idx, :])
            total_weighted_cooperation += cooperators_in_round * weight
            total_weight += n_opponents * weight
        if total_weight == 0:
            return 0.5
        cooperation_rate = total_weighted_cooperation / total_weight
        return max(0.0, min(1.0, cooperation_rate))

class Strategy_COLLECTIVE_120(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Decay (ACC-D).
    
    Cooperates in round 1, defects in final round, and conditionally cooperates
    in middle rounds based on whether collective cooperation rate exceeds the
    break-even threshold of 1/k. Includes decay tolerance for late-game and
    exploitation tracking.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = 1.0 / self.k
        self.payoff_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        return self._adaptive_decision(round_num, history)

    def _adaptive_decision(self, round_num: int, history: PlayerHistory) -> Action:
        """
        Decide in middle rounds based on cooperation rate, exploitation, and decay tolerance.
        """
        prev_round_idx = round_num - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        total_cooperators = int(my_prev_action) + np.sum(opponent_prev_actions)
        coop_rate = total_cooperators / self.n_players
        decay_tolerance = 0.0
        if round_num > 0.7 * self.n_rounds:
            decay_tolerance = 0.05 * (round_num / self.n_rounds)
        adjusted_threshold = self.threshold + decay_tolerance
        if coop_rate > adjusted_threshold:
            return Action.C
        my_payoff = history.my_payoffs[prev_round_idx]
        if my_prev_action:
            baseline_payoff = 1.0
        else:
            baseline_payoff = 2.0
        if len(history.my_payoffs) > 0:
            all_payoffs = np.concatenate([history.my_payoffs[:round_num], history.opponent_payoffs[:round_num].flatten()])
            median_payoff = np.median(all_payoffs)
        else:
            median_payoff = 1.5
        if my_payoff <= median_payoff:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_121(BaseStrategy):
    """
    Collective strategy for N-Player Public Goods Game.
    
    Uses adaptive threshold-based conditional cooperation:
    - Round 1: Always cooperate
    - Last round: Always defect
    - Other rounds: Cooperate if previous round's contribution rate >= threshold
    
    Threshold decreases over time to allow late-game reformation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        round_1indexed = round_num + 1
        threshold = max(0.5, 1.0 - round_1indexed / self.n_rounds)
        prev_round_idx = round_num - 1
        opponent_cooperators = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        self_action_prev = history.my_actions[prev_round_idx]
        total_cooperators = opponent_cooperators + (1 if self_action_prev else 0)
        contribution_rate = total_cooperators / self.n_players
        if contribution_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_122(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Balances defection temptation with sustainable cooperation by tracking observed
    cooperation rates and adjusting contribution probabilistically. Uses threshold-based
    decision rules that vary with game parameters and round number.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        if self.n_players > 20:
            self.threshold_low = 0.4
            self.threshold_high = 0.7
        elif self.n_players <= 3:
            self.threshold_low = 0.2
            self.threshold_high = 0.5
        else:
            self.threshold_low = 0.3
            self.threshold_high = 0.6

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        total_cooperations = 0
        total_slots = 0
        for round_idx in range(round_number):
            opponent_actions_this_round = history.opponent_actions[round_idx, :]
            total_cooperations += np.sum(opponent_actions_this_round)
            total_slots += self.n_players - 1
        my_actions_so_far = history.my_actions[:round_number]
        total_cooperations += np.sum(my_actions_so_far)
        total_slots += round_number
        if total_slots == 0:
            coop_rate = 0.0
        else:
            coop_rate = total_cooperations / total_slots
        if coop_rate < 0.05 and round_number > self.n_rounds // 2:
            return Action.D
        if round_number >= self.n_rounds - 3 and round_number < self.n_rounds - 1:
            recent_rounds_start = max(0, round_number - 2)
            if recent_rounds_start < round_number:
                recent_cooperations = 0
                recent_slots = 0
                for round_idx in range(recent_rounds_start, round_number):
                    recent_cooperations += np.sum(history.opponent_actions[round_idx, :])
                    recent_slots += self.n_players - 1
                if recent_slots > 0:
                    recent_coop_rate = recent_cooperations / recent_slots
                    if recent_coop_rate >= self.threshold_high and round_number == self.n_rounds - 2:
                        return Action.C
        if coop_rate >= self.threshold_high:
            return Action.C
        elif coop_rate < self.threshold_low:
            return Action.D
        elif random.random() < coop_rate:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_123(BaseStrategy):
    """
    Conditional cooperator with adaptive expectations for N-Player Public Goods Game.
    
    Cooperates based on observed group contribution rate compared to a dynamic threshold
    that varies by game stage. Employs a sliding window to filter noise and detect
    trustworthiness patterns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.window_size = max(3, math.ceil(game_description.n_rounds / 4))
        self.last_was_only_contributor = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num <= 2:
            base_threshold = 0.4
        elif round_num >= self.n_rounds - 2:
            base_threshold = 0.6
        else:
            base_threshold = 0.5
        window_start = max(0, round_num - self.window_size)
        window_end = round_num
        actual_window_size = window_end - window_start
        my_contributions = np.sum(history.my_actions[window_start:window_end])
        opponent_contributions = np.sum(history.opponent_actions[window_start:window_end, :])
        total_contributions = my_contributions + opponent_contributions
        max_possible_contributions = self.n_players * actual_window_size
        if max_possible_contributions > 0:
            avg_contrib = total_contributions / max_possible_contributions
        else:
            avg_contrib = 0.0
        if actual_window_size < self.window_size:
            threshold = base_threshold * (actual_window_size / self.window_size)
        else:
            threshold = base_threshold
        if avg_contrib == 0.0:
            self.last_was_only_contributor = False
            return Action.D
        if opponent_contributions == 0 and my_contributions > 0:
            if self.last_was_only_contributor:
                self.last_was_only_contributor = False
                return Action.D
            else:
                self.last_was_only_contributor = True
                return Action.C
        self.last_was_only_contributor = False
        if avg_contrib >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_124(BaseStrategy):
    """
    Collective Strategy for Public Goods Game.
    
    Balances reciprocal cooperation with defensive mechanisms:
    - Round 1: Cooperate to establish baseline and signal intent
    - Rounds 2 to r-1: Adaptive reciprocity based on collective contribution rate vs threshold T=k/n
    - Final round: Defect (no future incentives)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.k / game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        rounds_played = state.round_number
        opponent_cooperation_counts = np.sum(history.opponent_actions[:rounds_played, :], axis=0)
        opponent_cooperation_rates = opponent_cooperation_counts / rounds_played
        collective_contribution_rate = np.mean(opponent_cooperation_rates)
        my_cooperations = np.sum(history.my_actions[:rounds_played])
        i_have_cooperated = my_cooperations > 0
        rounds_remaining = self.game_description.n_rounds - state.round_number
        total_rounds = self.game_description.n_rounds
        fraction_remaining = rounds_remaining / total_rounds if total_rounds > 0 else 0.0
        if collective_contribution_rate >= self.threshold:
            return Action.C
        if i_have_cooperated and fraction_remaining < 0.3:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_125(BaseStrategy):
    """
    Adaptive Collective Contribution Strategy for N-Player Public Goods Game.
    
    Balances reciprocity and conditional cooperation by tracking observed cooperation rates.
    Contributes in round 1, then conditionally based on historical cooperation with adjusted
    thresholds for the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_other_players = self.game_description.n_players - 1
        n_completed_rounds = state.round_number
        total_opponent_contributions = np.sum(history.opponent_actions)
        if n_completed_rounds == 0 or n_other_players == 0:
            ocr = 0.0
        else:
            ocr = total_opponent_contributions / (n_other_players * n_completed_rounds)
        if state.round_number == self.game_description.n_rounds - 1:
            if ocr >= 0.4:
                return Action.C
            else:
                return Action.D
        if ocr >= 0.6:
            return Action.C
        elif ocr >= 0.3:
            prob = (ocr - 0.3) / 0.3
            collective_benefit_check = ocr * self.game_description.k > 1.0
            if collective_benefit_check or random.random() < prob:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_126(BaseStrategy):
    """
    Adaptive Conditional Contribution Strategy for N-Player Public Goods Game.
    
    Contributes conditionally based on:
    - Cooperation threshold (minimum others needed to make contribution worthwhile)
    - Observed reciprocity patterns and contribution rates
    - Game phase (early/middle/late rounds with different incentives)
    - All-or-nothing regimes (high or low stabilized contribution rates)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = math.ceil((self.n_players - 1) / self.k)
        self.consecutive_unanimous_defection = 0
        self.previously_defected = set()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions
        my_actions = history.my_actions
        prev_round_cooperators = int(np.sum(opponent_actions[current_round - 1, :]))
        total_contributions_so_far = int(np.sum(opponent_actions[:current_round, :]))
        total_decisions_so_far = current_round * (self.n_players - 1)
        avg_contribution_rate = total_contributions_so_far / total_decisions_so_far if total_decisions_so_far > 0 else 0.5
        if prev_round_cooperators == 0:
            self.consecutive_unanimous_defection += 1
        else:
            self.consecutive_unanimous_defection = 0
        if self.consecutive_unanimous_defection >= 2:
            return Action.D
        if avg_contribution_rate >= 0.8:
            return Action.C
        if avg_contribution_rate <= 0.2:
            return Action.D
        is_near_end = self.n_rounds > 5 and current_round >= self.n_rounds - 2
        if is_near_end:
            rounds_until_end = self.n_rounds - current_round
            defection_probability = 1.0 - 1.0 / (rounds_until_end + 1)
            if current_round >= 1:
                recent_avg = np.sum(opponent_actions[max(0, current_round - 2):current_round, :]) / max(1, min(2, current_round) * (self.n_players - 1))
                if recent_avg < 0.5:
                    if random.random() < defection_probability:
                        return Action.D
        is_early_game = current_round <= self.n_rounds / 3
        if prev_round_cooperators >= self.threshold:
            if avg_contribution_rate >= 0.5 or is_early_game:
                return Action.C
        if prev_round_cooperators < self.threshold:
            is_late_game = current_round > 2 * self.n_rounds / 3
            if avg_contribution_rate < 0.5 and is_late_game:
                return Action.D
        majority_threshold = (self.n_players - 1) / 2
        if prev_round_cooperators > majority_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_127(BaseStrategy):
    """
    Adaptive Conditional Contribution Strategy for N-Player Public Goods Game.
    
    Contributes unconditionally in rounds 1-3, then adapts based on observed cooperation rates.
    Uses threshold-based and probabilistic contribution rules, with defection in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number < 3:
            return Action.C
        is_final_round = round_number == self.n_rounds - 1
        if self.n_rounds <= 5 and round_number == self.n_rounds - 2:
            is_final_round = True
        if is_final_round:
            return Action.D
        start_idx = max(0, round_number - 3)
        recent_rounds = round_number - start_idx
        total_contributions = 0
        for i in range(start_idx, round_number):
            if history.my_actions[i]:
                total_contributions += 1
        for i in range(start_idx, round_number):
            for j in range(self.n_players - 1):
                if history.opponent_actions[i, j]:
                    total_contributions += 1
        total_possible = recent_rounds * self.n_players
        if total_possible == 0:
            cooperation_rate = 0.0
        else:
            cooperation_rate = total_contributions / total_possible
        if self.n_players == 2:
            threshold_high = 0.45
            threshold_low = 0.25
        else:
            threshold_high = 0.6
            threshold_low = 0.4
        if cooperation_rate >= threshold_high:
            return Action.C
        elif cooperation_rate >= threshold_low:
            prob = cooperation_rate - 0.3
            if random.random() < prob:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_128(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy for N-Player Public Goods Game.
    
    Cooperates when collective contribution is sufficiently high; defects when it's dangerously low.
    Adapts the cooperation threshold based on observed group dynamics to maximize long-term 
    collective welfare while remaining resilient to defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if self.n_rounds == 1:
            return Action.D
        if round_number == 0:
            return Action.C
        total_rounds_so_far = round_number
        total_possible_contributions = total_rounds_so_far * self.n_players
        my_cooperations = np.sum(history.my_actions[:round_number])
        opponent_cooperations = np.sum(history.opponent_actions[:round_number, :])
        total_cooperations = my_cooperations + opponent_cooperations
        cooperation_rate = total_cooperations / total_possible_contributions if total_possible_contributions > 0 else 0.0
        if round_number == self.n_rounds - 1:
            if cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        conditional_threshold = 0.4
        if self.k >= self.n_players * 0.95:
            conditional_threshold = 0.35
        last_round_cooperators = np.sum(history.opponent_actions[round_number - 1, :])
        last_round_cooperation_ratio = last_round_cooperators / self.n_players
        if cooperation_rate > 0.6:
            return Action.C
        elif cooperation_rate >= 0.35:
            if last_round_cooperation_ratio > conditional_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_1(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Classifies opponents as Cooperators, Conditional Cooperators, or Defectors
    based on observed contribution history, then exploits predictable patterns
    by defecting against all types while extracting value from cooperators.
    Defects in final two rounds regardless of opponent type.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_classifications = [{'current': 'CONDITIONAL'} for _ in range(game_description.n_players - 1)]

    def _classify_opponent(self, opponent_idx: int, history: PlayerHistory) -> str:
        """
        Classify an opponent based on their contribution history.
        Uses a 5-round rolling window or full history if fewer rounds elapsed.
        
        Returns: 'COOPERATOR', 'CONDITIONAL', or 'DEFECTOR'
        """
        opponent_actions = history.opponent_actions[:, opponent_idx]
        n_rounds_observed = len(opponent_actions)
        if n_rounds_observed < 3:
            return 'CONDITIONAL'
        window_size = min(5, n_rounds_observed)
        recent_actions = opponent_actions[-window_size:]
        contribution_rate = float(np.sum(recent_actions)) / window_size
        current_class = self.opponent_classifications[opponent_idx]['current']
        if current_class == 'DEFECTOR' and contribution_rate > 0:
            consecutive = 0
            for i in range(len(recent_actions) - 1, -1, -1):
                if recent_actions[i]:
                    consecutive += 1
                else:
                    break
            if consecutive < 3:
                return 'DEFECTOR'
        if contribution_rate >= 0.75:
            return 'COOPERATOR'
        elif contribution_rate >= 0.25:
            return 'CONDITIONAL'
        else:
            return 'DEFECTOR'

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_num == 0:
            return Action.D
        if round_num >= n_rounds - 2:
            return Action.D
        for opponent_idx in range(len(self.opponent_classifications)):
            classification = self._classify_opponent(opponent_idx, history)
            self.opponent_classifications[opponent_idx]['current'] = classification
        return Action.D

class Strategy_EXPLOITATIVE_2(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Dynamically exploits cooperation patterns
    by defecting when others cooperate (free-riding), while maintaining minimal
    cooperation to avoid detection by reciprocal strategies.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = 1.0 / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num >= self.n_rounds - 3:
            if round_num == self.n_rounds - 3:
                prev_round_defectors = sum(~history.opponent_actions[-1, :])
                if prev_round_defectors > 0:
                    return Action.D
            elif round_num == self.n_rounds - 2:
                cooperation_rate = sum(history.opponent_actions[-1, :]) / self.n_players
                if cooperation_rate < 0.8:
                    return Action.D
        prev_round_cooperators = sum(history.opponent_actions[-1, :])
        cooperation_rate = prev_round_cooperators / self.n_players
        if cooperation_rate == 0:
            return Action.D
        if len(history.opponent_actions) > 1:
            opponent_cooperation_counts = np.sum(history.opponent_actions, axis=0)
            max_rounds_seen = len(history.opponent_actions)
            pure_defectors = np.sum(opponent_cooperation_counts == 0)
            if pure_defectors > 1:
                cooperation_rate_adjusted = cooperation_rate * 0.8
            else:
                cooperation_rate_adjusted = cooperation_rate
        else:
            cooperation_rate_adjusted = cooperation_rate
        if cooperation_rate_adjusted > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_3(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Systematically identifies and exploits
    cooperative players while defaulting to defection. Treats cooperators as
    resources to harvest with zero reciprocation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.pure_cooperators = set()
        self.conditional_cooperators = set()
        self.defectors = set()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            self._classify_opponents(history)
            return Action.D
        return Action.D

    def _classify_opponents(self, history: PlayerHistory) -> None:
        """
        Classify each opponent based on their contribution history.
        Updates instance attributes: pure_cooperators, conditional_cooperators, defectors.
        """
        n_opponents = self.game_description.n_players - 1
        rounds_so_far = history.my_actions.shape[0]
        for opponent_idx in range(n_opponents):
            if opponent_idx in self.pure_cooperators:
                continue
            opponent_actions = history.opponent_actions[:, opponent_idx]
            n_cooperations = int(np.sum(opponent_actions))
            if n_cooperations == rounds_so_far:
                self.pure_cooperators.add(opponent_idx)
            elif n_cooperations == 0:
                self.defectors.add(opponent_idx)
            else:
                self.conditional_cooperators.add(opponent_idx)

class Strategy_EXPLOITATIVE_4(BaseStrategy):
    """
    Exploitative Public Goods Strategy
    
    Maximizes personal payoff by identifying and exploiting cooperative players
    while avoiding traps with defectors. Uses opponent cooperation frequency tracking
    to decide when to contribute based on expected value calculations.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_cooperation_counts = None
        self.all_defectors_locked = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if self.opponent_cooperation_counts is None:
            self.opponent_cooperation_counts = np.zeros(self.n_players - 1)
        for r in range(round_num):
            self.opponent_cooperation_counts += history.opponent_actions[r, :].astype(int)
        if round_num == 2:
            if np.sum(self.opponent_cooperation_counts) == 0:
                self.all_defectors_locked = True
        if self.all_defectors_locked:
            return Action.D
        rounds_elapsed = round_num
        opponent_frequencies = self.opponent_cooperation_counts / rounds_elapsed
        if self.n_players == 2:
            opponent_freq = opponent_frequencies[0]
            if round_num >= 3:
                recent_actions = history.opponent_actions[round_num - 3:round_num, 0]
                if np.sum(recent_actions) == 3:
                    return Action.C
            return Action.D
        avg_opponent_freq = np.mean(opponent_frequencies)
        threshold = (self.n_players - 1) / self.k
        if self.k >= self.n_players - 0.5:
            threshold = (self.n_players - 1) / (self.k - 0.5)
        elif self.k <= 1.5:
            threshold = 0.9
        has_reliable_cooperator = np.any(opponent_frequencies > 0.7)
        has_only_defectors = np.all(opponent_frequencies < 0.2)
        if has_only_defectors:
            return Action.D
        if avg_opponent_freq > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_5(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    
    Maximizes personal payoff by identifying and free-riding on predictable cooperators.
    Core approach: Defect in round 1 to probe, classify opponents by contribution patterns,
    exploit unconditional and conditional cooperators in rounds 2-(r-2), and defect in endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_classifications = {}
        self.opponent_contribution_counts = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if round_num == 0:
            return Action.D
        if round_num >= n_rounds - 2:
            return Action.D
        if not self.opponent_classifications:
            self._classify_opponents(history)
        self._update_contribution_counts(history)
        if round_num > 0:
            current_cooperators = int(sum(history.opponent_actions[round_num - 1, :]))
            contribution_rate = current_cooperators / (n_players - 1) if n_players > 1 else 0
        else:
            contribution_rate = 0
        if contribution_rate < 0.2:
            return Action.D
        return Action.D

    def _classify_opponents(self, history: PlayerHistory) -> None:
        """Classify each opponent as unconditional contributor, conditional cooperator, defector, or wavering."""
        n_opponents = self.game_description.n_players - 1
        for opp_idx in range(n_opponents):
            if opp_idx not in self.opponent_classifications:
                actions = history.opponent_actions[:, opp_idx]
                cooperation_count = int(sum(actions))
                total_rounds = len(actions)
                if cooperation_count == total_rounds:
                    self.opponent_classifications[opp_idx] = 'unconditional_contributor'
                    self.opponent_contribution_counts[opp_idx] = cooperation_count
                elif cooperation_count == 0:
                    self.opponent_classifications[opp_idx] = 'defector'
                    self.opponent_contribution_counts[opp_idx] = 0
                else:
                    other_cooperation = np.sum(history.opponent_actions[:, :opp_idx] + history.opponent_actions[:, opp_idx + 1:], axis=1)
                    correlations = []
                    for round_idx in range(total_rounds):
                        if actions[round_idx] == 1:
                            correlations.append(1)
                        else:
                            correlations.append(0)
                    consistency = sum((1 for i in range(total_rounds) if actions[i] == 1 and other_cooperation[i] > 0 or (actions[i] == 0 and other_cooperation[i] == 0)))
                    if consistency >= total_rounds * 0.7:
                        self.opponent_classifications[opp_idx] = 'conditional_cooperator'
                    else:
                        self.opponent_classifications[opp_idx] = 'wavering'
                    self.opponent_contribution_counts[opp_idx] = cooperation_count

    def _update_contribution_counts(self, history: PlayerHistory) -> None:
        """Update total contribution counts for each opponent."""
        n_opponents = self.game_description.n_players - 1
        for opp_idx in range(n_opponents):
            if opp_idx not in self.opponent_contribution_counts:
                self.opponent_contribution_counts[opp_idx] = 0
            if history is not None and len(history.opponent_actions) > 0:
                self.opponent_contribution_counts[opp_idx] = int(sum(history.opponent_actions[:, opp_idx]))

class Strategy_EXPLOITATIVE_6(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Maximizes personal payoff by free-riding on others' 
    cooperation while avoiding reciprocity traps. Defects in round 1 and final round, exploits 
    high cooperators in middle rounds, and uses conditional logic based on pool contributions 
    and opponent cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        opponent_coop_rates = self._calculate_opponent_cooperation_rates(history, round_num)
        high_cooperators = sum((1 for rate in opponent_coop_rates if rate >= 0.6))
        low_cooperators = sum((1 for rate in opponent_coop_rates if rate < 0.6))
        expected_others_contribution = sum(opponent_coop_rates)
        expected_pool_benefit = self.k / self.n_players * expected_others_contribution
        if high_cooperators > 0 and self.k > 1.5:
            if expected_pool_benefit > 1.0:
                return Action.C
            else:
                return Action.D
        if low_cooperators >= high_cooperators and low_cooperators > 0:
            return Action.D
        if round_num > 0:
            last_round_contributions = int(np.sum(history.opponent_actions[round_num - 1, :]))
            threshold_t = self.n_players * self.k / 2.0
            if last_round_contributions >= threshold_t:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_opponent_cooperation_rates(self, history: PlayerHistory, round_num: int) -> list:
        """
        Calculate the cooperation rate for each opponent based on all previous rounds.
        Returns a list of cooperation rates [0.0, 1.0].
        """
        cooperation_rates = []
        for opponent_idx in range(self.n_players - 1):
            if round_num == 0:
                cooperation_rates.append(0.0)
            else:
                cooperations = int(np.sum(history.opponent_actions[:round_num, opponent_idx]))
                rate = cooperations / round_num if round_num > 0 else 0.0
                cooperation_rates.append(rate)
        return cooperation_rates

class Strategy_EXPLOITATIVE_7(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    
    Maximizes personal payoff by exploiting cooperative players while avoiding mutual defection traps.
    - Rounds 1-2: Defect to establish baseline and identify cooperators
    - Rounds 3 to r-2: Adaptive defection with selective contribution based on cooperation rates
    - Rounds r-1 and r: Defect (endgame, no future reputation)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round <= 1:
            return Action.D
        if current_round >= self.n_rounds - 2:
            return Action.D
        opponent_contributions = history.opponent_actions[:current_round, :]
        contribution_counts = np.sum(opponent_contributions, axis=0)
        contribution_rates = contribution_counts / current_round
        high_contributors = np.sum(contribution_rates > 0.6)
        fraction_high_contributors = high_contributors / self.n_players
        if fraction_high_contributors >= 0.5:
            return Action.D
        else:
            avg_contribution_rate = np.mean(contribution_rates)
            expected_other_contributions = (self.n_players - 1) * avg_contribution_rate
            payoff_if_contribute = self.k / self.n_players * (expected_other_contributions + 1)
            payoff_if_defect = 1.0 + self.k / self.n_players * expected_other_contributions
            if payoff_if_contribute > 1.0:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_8(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Maximizes personal payoff by free-riding on others' 
    contributions while maintaining minimal reputation to avoid coordinated retaliation.
    Uses adaptive thresholds based on observed opponent cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = self.k / self.n_players
        self.all_opponents_defected_consecutive = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if self.n_rounds <= 2:
            return Action.D
        if round_num == 0:
            return Action.D
        n_rounds_played = round_num
        total_opponent_contributions = np.sum(history.opponent_actions[:round_num, :])
        n_opponent_slots = self.n_players - 1
        avg_others = total_opponent_contributions / (n_opponent_slots * n_rounds_played)
        if round_num >= 2:
            last_round_defections = np.sum(~history.opponent_actions[round_num - 1, :])
            prev_round_defections = np.sum(~history.opponent_actions[round_num - 2, :])
            if last_round_defections == n_opponent_slots and prev_round_defections == n_opponent_slots:
                self.all_opponents_defected_consecutive = 1
        if self.all_opponents_defected_consecutive:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        if avg_others < 0.2:
            return Action.D
        if avg_others > self.threshold:
            return Action.D
        if round_num >= 1:
            last_round_cooperators = np.sum(history.opponent_actions[round_num - 1, :])
            if last_round_cooperators < n_opponent_slots:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_9(BaseStrategy):
    """
    Exploitative Public Goods Strategy that defects to maximize personal payoff
    by free-riding on others' contributions while avoiding the cost of cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consistent_contributors = set()
        self.defectors = set()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self._classify_opponents(history)
        return Action.D

    def _classify_opponents(self, history: PlayerHistory) -> None:
        """
        Classify opponents based on their contribution history.
        Updates internal tracking of consistent contributors and defectors.
        """
        n_opponents = self.game_description.n_players - 1
        rounds_played = len(history.my_actions)
        if rounds_played == 0:
            return
        for opponent_idx in range(n_opponents):
            opponent_contributions = history.opponent_actions[:rounds_played, opponent_idx]
            contribution_count = np.sum(opponent_contributions)
            contribution_rate = contribution_count / rounds_played if rounds_played > 0 else 0
            if contribution_rate >= 0.8:
                self.consistent_contributors.add(opponent_idx)
                self.defectors.discard(opponent_idx)
            elif contribution_rate <= 0.2:
                self.defectors.add(opponent_idx)
                self.consistent_contributors.discard(opponent_idx)

class Strategy_EXPLOITATIVE_10(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Maximizes personal payoff by defecting when
    others cooperate, with selective "revival" contributions to manipulate cooperation
    when it collapses. Fully exploits endgame with guaranteed final-round defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round_idx = state.round_number - 1
        opponent_cooperators_prev = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        total_opponents = self.game_description.n_players - 1
        if total_opponents == 0:
            return Action.D
        contribution_rate = opponent_cooperators_prev / total_opponents
        if contribution_rate >= 0.5:
            return Action.D
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if rounds_remaining < 3:
            return Action.D
        prob_contribute = contribution_rate / 0.5
        prob_contribute = min(prob_contribute, 1.0)
        prob_contribute = max(prob_contribute, 0.0)
        if random.random() < prob_contribute:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_11(BaseStrategy):
    """
    Exploitative Public Goods Strategy that defects by default while selectively
    exploiting reliable cooperators. Uses opponent contribution frequency to classify
    them as reliable contributors, conditional cooperators, or defectors, then exploits
    accordingly. Always defects in round 1 and final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_contribution_freq = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_opponents = self.game_description.n_players - 1
        n_completed_rounds = state.round_number
        opponent_freqs = self._calculate_opponent_frequencies(history, n_completed_rounds)
        exploitable_count = sum((1 for freq in opponent_freqs if freq >= 0.7))
        avg_group_contribution = np.mean(opponent_freqs) if len(opponent_freqs) > 0 else 0
        k = self.game_description.k
        n = self.game_description.n_players
        min_viable_contribution = k / n
        if avg_group_contribution < min_viable_contribution:
            return Action.D
        if exploitable_count > 0:
            return Action.D
        conditional_count = sum((1 for freq in opponent_freqs if 0.3 <= freq < 0.7))
        if conditional_count > 0:
            return Action.D
        return Action.D

    def _calculate_opponent_frequencies(self, history: PlayerHistory, n_completed_rounds: int) -> list[float]:
        """
        Calculate the contribution frequency for each opponent based on completed rounds.
        Returns a list of frequencies, one per opponent.
        """
        n_opponents = self.game_description.n_players - 1
        if n_completed_rounds == 0:
            return [0.0] * n_opponents
        opponent_freqs = []
        for opponent_idx in range(n_opponents):
            total_contributions = np.sum(history.opponent_actions[:n_completed_rounds, opponent_idx])
            freq = total_contributions / n_completed_rounds
            opponent_freqs.append(float(freq))
        return opponent_freqs

class Strategy_EXPLOITATIVE_12(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Classifies opponents by cooperation rate
    and exploits high cooperators while defecting against low cooperators.
    Defects in the final round regardless of history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self._update_cooperation_rates(history)
        if self.opponent_cooperation_rates is None or all((rate == 0 for rate in self.opponent_cooperation_rates)):
            return Action.D
        if all((rate == 0 for rate in self.opponent_cooperation_rates)):
            return Action.D
        avg_cooperation = sum(self.opponent_cooperation_rates) / len(self.opponent_cooperation_rates)
        high_cooperators = sum((1 for rate in self.opponent_cooperation_rates if rate >= 0.8))
        moderate_cooperators = sum((1 for rate in self.opponent_cooperation_rates if 0.4 <= rate < 0.8))
        if high_cooperators > 0:
            return Action.D
        if moderate_cooperators > 0:
            last_round_contributions = sum(history.opponent_actions[-1, :])
            expected_return = self.game_description.k / self.game_description.n_players * last_round_contributions
            if expected_return > 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _update_cooperation_rates(self, history: PlayerHistory) -> None:
        """
        Calculate cooperation rate for each opponent based on history.
        cooperation_rate = (number of cooperations) / (number of rounds played)
        """
        n_opponents = self.game_description.n_players - 1
        n_rounds_played = history.my_actions.shape[0]
        if n_rounds_played == 0:
            self.opponent_cooperation_rates = [0.0] * n_opponents
            return
        self.opponent_cooperation_rates = []
        for opponent_idx in range(n_opponents):
            cooperations = sum(history.opponent_actions[:, opponent_idx])
            cooperation_rate = cooperations / n_rounds_played
            self.opponent_cooperation_rates.append(cooperation_rate)

class Strategy_EXPLOITATIVE_13(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Free-ride on cooperators while defecting strategically.
    
    Core approach:
    - Round 0: Defect to establish non-cooperator reputation
    - Rounds 1 to r-2: Defect unless very few cooperators (free-ride on 3+ cooperators)
    - Rounds r-1 and r: Always defect (endgame, no future shadow)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_number == 0:
            return Action.D
        if round_number >= n_rounds - 2:
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            cooperators_last_round = int(np.sum(history.opponent_actions[-1, :]))
            if cooperators_last_round >= 3:
                return Action.D
            if cooperators_last_round >= 1:
                return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_14(BaseStrategy):
    """
    Exploitative strategy for repeated public goods game.
    
    Defects by default to free-ride on others' contributions while minimizing losses.
    Tracks opponent contribution patterns but maintains consistent defection to exploit
    cooperators and suppress reciprocal strategies. End-game defection maximizes final payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_contribution_counts = None
        self.opponent_total_rounds = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if self.opponent_contribution_counts is None:
            n_opponents = self.game_description.n_players - 1
            self.opponent_contribution_counts = np.zeros(n_opponents, dtype=np.int64)
            self.opponent_total_rounds = 0
        if history is not None and state.round_number > 0:
            self.opponent_total_rounds = state.round_number
            for round_idx in range(state.round_number):
                for opp_idx in range(self.game_description.n_players - 1):
                    if history.opponent_actions[round_idx, opp_idx]:
                        self.opponent_contribution_counts[opp_idx] += 1
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_15(BaseStrategy):
    """
    Exploitative strategy for repeated public goods game.
    
    Defects by default, strategically cooperates only when others are generating
    exploitable surplus, and always defects in final two rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        k = self.game_description.k
        r = self.game_description.n_rounds
        round_num = state.round_number
        if round_num == 0:
            self.consecutive_defections = 0
            return Action.D
        if round_num >= r - 2:
            self.consecutive_defections += 1
            return Action.D
        prev_round_idx = round_num - 1
        total_prev_contributions = int(history.my_actions[prev_round_idx]) + np.sum(history.opponent_actions[prev_round_idx, :].astype(np.int32))
        avg_contrib = total_prev_contributions / n
        threshold = (k - 1.0) / k
        if avg_contrib >= threshold:
            self.consecutive_defections += 1
            return Action.D
        if self.consecutive_defections >= 2:
            self.consecutive_defections += 1
            return Action.D
        self.consecutive_defections = 0
        return Action.C

class Strategy_EXPLOITATIVE_16(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defects to exploit cooperators while using
    minimal stochastic cooperation to manipulate conditional cooperators into maintaining
    contributions. Classifies opponents into tiers based on contribution history and
    applies tier-specific decision rules.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_cooperation_rates = {}
        self.last_recalibration_round = 0

    def _classify_opponent(self, cooperation_rate: float) -> str:
        """Classify opponent into tier based on cooperation rate."""
        if cooperation_rate >= 0.8:
            return 'A'
        elif 0.4 <= cooperation_rate < 0.8:
            return 'B'
        elif 0.0 < cooperation_rate < 0.4:
            return 'C'
        else:
            return 'D'

    def _get_decision_for_tier(self, tier: str) -> Action:
        """Get action for a given tier."""
        if tier == 'A':
            return Action.D
        elif tier == 'B':
            if random.random() < 0.9:
                return Action.D
            else:
                return Action.C
        elif tier == 'C':
            return Action.D
        else:
            return Action.D

    def _update_opponent_rates(self, history: PlayerHistory, current_round: int) -> None:
        """Update cooperation rates for all opponents based on history."""
        n_opponents = self.n_players - 1
        for opponent_idx in range(n_opponents):
            rounds_observed = current_round
            if rounds_observed == 0:
                self.opponent_cooperation_rates[opponent_idx] = 0.0
            else:
                cooperations = sum(history.opponent_actions[:current_round, opponent_idx])
                self.opponent_cooperation_rates[opponent_idx] = cooperations / rounds_observed

    def _should_recalibrate(self, current_round: int) -> bool:
        """Check if we should recalculate tier membership."""
        return current_round - self.last_recalibration_round >= 5 and current_round > 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        self._update_opponent_rates(history, current_round)
        if self._should_recalibrate(current_round):
            self.last_recalibration_round = current_round
        if current_round == self.n_rounds - 1:
            return Action.D
        total_decision_value = 0.0
        n_opponents = self.n_players - 1
        for opponent_idx in range(n_opponents):
            cooperation_rate = self.opponent_cooperation_rates.get(opponent_idx, 0.0)
            tier = self._classify_opponent(cooperation_rate)
            if self.n_players <= 3:
                if tier == 'B':
                    tier = 'A'
            if self.k < 1.2:
                if tier == 'B':
                    if random.random() < 0.95:
                        total_decision_value += 0.0
                    else:
                        total_decision_value += 1.0
                    continue
            action = self._get_decision_for_tier(tier)
            total_decision_value += 1.0 if action == Action.C else 0.0
        if total_decision_value > n_opponents * 0.5:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_17(BaseStrategy):
    """
    Exploitative Public Goods Strategy that systematically free-rides on cooperators.
    
    Core approach:
    - Round 1: Defect to establish non-cooperative baseline
    - Rounds 2 to r-1: Defect unless cooperation is critically low, adapting to suppress group cooperation
    - Final round: Defect to extract maximum value with no reputational consequences
    
    Prioritizes personal payoff maximization by parasitically extracting value from any
    player showing cooperation while never voluntarily contributing.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        previous_round_idx = current_round - 1
        opponent_contributions_prev = history.opponent_actions[previous_round_idx, :]
        my_contribution_prev = history.my_actions[previous_round_idx]
        total_cooperators_prev = int(my_contribution_prev) + int(np.sum(opponent_contributions_prev))
        average_contribution_rate = total_cooperators_prev / self.n_players
        threshold_high = (self.k - 1) / self.k
        threshold_mid = (self.k - 2) / self.k if self.k > 2 else 0
        return Action.D

class Strategy_EXPLOITATIVE_18(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    
    Phases:
    1. Probing (first 20% of rounds): Defect to observe opponents
    2. Exploitation (middle 60%): Defect against reliable cooperators, defect against unreliable ones
    3. Endgame (last 20%): Always defect for immediate payoff
    
    Core principle: Free-ride on others' contributions while minimizing own losses.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_contribution_counts = np.zeros(self.n_players - 1)
        self.opponent_round_counts = np.zeros(self.n_players - 1)
        self.probe_rounds = max(3, math.ceil(0.2 * self.n_rounds))
        self.endgame_start = math.ceil(0.8 * self.n_rounds)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        self._update_opponent_stats(history)
        current_round = state.round_number
        if current_round < self.probe_rounds:
            return Action.D
        if current_round >= self.endgame_start:
            return Action.D
        avg_contribution_rate = self._get_avg_contribution_rate()
        return Action.D

    def _update_opponent_stats(self, history: PlayerHistory) -> None:
        """Update opponent contribution statistics from game history."""
        if history is None or len(history.opponent_actions) == 0:
            return
        for round_idx in range(len(history.opponent_actions)):
            opponent_actions_round = history.opponent_actions[round_idx, :]
            for opponent_idx in range(len(opponent_actions_round)):
                if opponent_actions_round[opponent_idx]:
                    self.opponent_contribution_counts[opponent_idx] += 1
                self.opponent_round_counts[opponent_idx] += 1

    def _get_avg_contribution_rate(self) -> float:
        """
        Calculate average contribution rate across opponents.
        Returns 0.0 if no history exists.
        """
        total_rounds = np.sum(self.opponent_round_counts)
        if total_rounds == 0:
            return 0.0
        total_contributions = np.sum(self.opponent_contribution_counts)
        return total_contributions / total_rounds

class Strategy_EXPLOITATIVE_19(BaseStrategy):
    """
    Conditional Predation: Exploits cooperators through selective cooperation and systematic endgame defection.
    
    Strategy:
    - Round 0: Defect to establish free-riding willingness
    - Rounds 1 to (r-3): Cooperate if tier-1/tier-2 players exist, else defect
    - Final 2 rounds: Always defect for endgame exploitation
    - Adapts to defector-dominant environments by switching to pure defection
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if round_number >= self.n_rounds - 2:
            return Action.D
        if self.k / self.n_players < 1.0:
            return Action.D
        opponent_actions = history.opponent_actions
        rounds_played = round_number
        if rounds_played == 0:
            return Action.D
        cooperation_rates = np.mean(opponent_actions[:rounds_played, :], axis=0)
        tier1_exists = np.any(cooperation_rates > 0.8)
        tier2_exists = np.any((cooperation_rates >= 0.4) & (cooperation_rates <= 0.8))
        tier3_only = np.all(cooperation_rates < 0.4)
        my_cooperation_rate = np.mean(history.my_actions[:rounds_played])
        total_consistent = np.sum(cooperation_rates > 0.4) + (1 if my_cooperation_rate > 0.4 else 0)
        if total_consistent <= 1 and my_cooperation_rate > 0.4:
            return Action.D
        if tier1_exists or tier2_exists:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_20(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defects to free-ride on cooperators,
    with a dynamic threshold that switches to defection when cooperation rates
    drop below (k-1)/k, or when >50% of players defect consistently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = (game_description.k - 1) / game_description.k
        self.last_round_defector_count = 0
        self.second_last_round_defector_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_idx = state.round_number - 1
        total_contributions_last_round = int(np.sum(history.opponent_actions[previous_round_idx, :]) + (1 if history.my_actions[previous_round_idx] else 0))
        coop_rate = total_contributions_last_round / self.game_description.n_players
        defectors_last_round = self.game_description.n_players - int(np.sum(history.opponent_actions[previous_round_idx, :]) + (1 if history.my_actions[previous_round_idx] else 0))
        current_defector_ratio = defectors_last_round / self.game_description.n_players
        if state.round_number >= 2:
            second_previous_idx = previous_round_idx - 1
            defectors_second_last = self.game_description.n_players - int(np.sum(history.opponent_actions[second_previous_idx, :]) + (1 if history.my_actions[second_previous_idx] else 0))
            second_last_defector_ratio = defectors_second_last / self.game_description.n_players
            if current_defector_ratio > 0.5 and second_last_defector_ratio > 0.5:
                return Action.D
        if coop_rate > self.threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_21(BaseStrategy):
    """
    Exploitative Parasitism Strategy for Public Goods Game.
    
    Defects by default to free-ride on cooperative players' contributions.
    Uses adaptive thresholding based on others' average contributions to determine
    when defection yields maximum payoff. Defects in round 1 and last round unconditionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.k / game_description.n_players - 0.05
        self.contribution_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if state.round_number == 0:
            return Action.D
        if state.round_number == r - 1:
            return Action.D
        prev_round_idx = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        opponent_contributions_prev = opponent_actions_prev.astype(np.float64)
        avg_other_contribution = np.mean(opponent_contributions_prev)
        if len(history.opponent_actions) >= 3:
            recent_contributions = [np.mean(history.opponent_actions[i, :].astype(np.float64)) for i in range(max(0, prev_round_idx - 2), prev_round_idx + 1)]
            if len(recent_contributions) >= 2:
                if recent_contributions[-1] < recent_contributions[-2]:
                    return Action.D
        breakeven_contribution = n / k
        return Action.D

class Strategy_EXPLOITATIVE_22(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Maximizes personal payoff by identifying and exploiting persistent contributors
    while minimizing own contributions. Uses information asymmetry and conditional
    defection to harvest cooperative behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.persistent_contributors = set()
        self.contribution_counts = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        self._update_contributor_tracking(history, state.round_number)
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        k = self.game_description.k
        if current_round == n_rounds - 1:
            return Action.D
        num_persistent = len(self.persistent_contributors)
        last_round_contributions = sum(history.opponent_actions[-1, :])
        all_others_defected = last_round_contributions == 0
        if all_others_defected and current_round <= n_rounds - 3:
            return Action.C
        unreliable_players = self._identify_unreliable_players(history)
        if num_persistent >= 2:
            return Action.D
        if len(unreliable_players) >= n_players - 1:
            return Action.D
        return Action.D

    def _update_contributor_tracking(self, history: PlayerHistory, current_round: int) -> None:
        """
        Track which opponents are persistent contributors (≥60% contribution rate).
        """
        n_opponents = self.game_description.n_players - 1
        for opponent_idx in range(n_opponents):
            if opponent_idx not in self.contribution_counts:
                self.contribution_counts[opponent_idx] = {'total': 0, 'rounds': 0}
            contributions = sum(history.opponent_actions[:current_round, opponent_idx])
            self.contribution_counts[opponent_idx]['total'] = contributions
            self.contribution_counts[opponent_idx]['rounds'] = current_round
            if current_round > 0:
                contribution_rate = contributions / current_round
                if contribution_rate >= 0.6:
                    self.persistent_contributors.add(opponent_idx)
                else:
                    self.persistent_contributors.discard(opponent_idx)

    def _identify_unreliable_players(self, history: PlayerHistory) -> set:
        """
        Identify players who switch between cooperation and defection.
        These are "uncertainty signals" that suggest lack of conviction.
        """
        unreliable = set()
        n_opponents = self.game_description.n_players - 1
        current_round = len(history.my_actions)
        if current_round < 2:
            return unreliable
        for opponent_idx in range(n_opponents):
            actions = history.opponent_actions[:current_round, opponent_idx]
            if len(actions) >= 2:
                has_cooperated = sum(actions) > 0
                has_defected = sum(actions) < len(actions)
                if has_cooperated and has_defected:
                    unreliable.add(opponent_idx)
        return unreliable

class Strategy_EXPLOITATIVE_23(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Maximizes personal payoff by free-riding on others' 
    contributions and defecting whenever possible. Cooperates only when strictly necessary 
    to exceed endowment returns, with unconditional defection in first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self._opponent_cooperation_freq = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions[:round_number, :]
        if opponent_actions.size == 0:
            return Action.D
        opponent_cooperation_counts = np.sum(opponent_actions, axis=0)
        opponent_cooperation_freq = opponent_cooperation_counts / round_number
        expected_others_contribution = np.sum(opponent_cooperation_freq)
        threshold = self.n_players / self.k
        punishment_detected = self._detect_punishment_pattern(history, round_number)
        if punishment_detected:
            return Action.D
        chronic_cooperator_threshold = 0.6
        chronic_cooperators = np.sum(opponent_cooperation_freq >= chronic_cooperator_threshold)
        if expected_others_contribution == 0:
            return Action.D
        if expected_others_contribution >= self.n_players - 1:
            return Action.D
        expected_public_payoff = self.k / self.n_players * expected_others_contribution
        if expected_public_payoff < 1.0:
            return Action.D
        return Action.D

    def _detect_punishment_pattern(self, history: PlayerHistory, round_number: int) -> bool:
        """
        Detect if opponents are using punishment strategies (defecting specifically after 
        this player defected). Returns True if pattern detected.
        """
        if round_number < 2:
            return False
        my_last_action = history.my_actions[round_number - 1]
        if my_last_action:
            return False
        my_defection_rounds = np.where(~history.my_actions[:round_number])[0]
        my_cooperation_rounds = np.where(history.my_actions[:round_number])[0]
        if len(my_defection_rounds) == 0 or len(my_cooperation_rounds) == 0:
            return False
        opponent_actions_after_defect = []
        for defect_round in my_defection_rounds:
            if defect_round + 1 < round_number:
                opponent_actions_after_defect.append(history.opponent_actions[defect_round + 1, :])
        if not opponent_actions_after_defect:
            return False
        opponent_actions_after_defect = np.array(opponent_actions_after_defect)
        defect_response_rate = 1.0 - np.mean(opponent_actions_after_defect)
        opponent_actions_after_coop = []
        for coop_round in my_cooperation_rounds:
            if coop_round + 1 < round_number:
                opponent_actions_after_coop.append(history.opponent_actions[coop_round + 1, :])
        if not opponent_actions_after_coop:
            return False
        opponent_actions_after_coop = np.array(opponent_actions_after_coop)
        coop_response_rate = 1.0 - np.mean(opponent_actions_after_coop)
        return defect_response_rate > coop_response_rate + 0.1

class Strategy_EXPLOITATIVE_24(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy: Conditional Free-Riding with Adaptive Defection
    
    Core principle: Minimize contribution, maximize harvesting of others' contributions.
    Default action is DEFECT. Only contribute when conditions indicate high aggregate 
    cooperation that makes contribution worthwhile, or to reset opponent expectations 
    for deeper exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_coop_counts = [0] * (self.n_players - 1)
        self.opponent_total_rounds = [0] * (self.n_players - 1)
        self.total_opponent_contributions = 0
        self.total_opponent_rounds = 0
        self.exploit_reset_cooldown = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        self._update_opponent_profiles(history)
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            return Action.D
        avg_opponent_contribution = self._get_avg_opponent_contribution()
        contribution_threshold = self.k / self.n_players
        if self.exploit_reset_cooldown > 0:
            self.exploit_reset_cooldown -= 1
            return Action.D
        high_cooperation_threshold = (self.n_players - 1) / self.n_players
        if avg_opponent_contribution >= high_cooperation_threshold:
            if current_round % 6 == 0:
                return Action.C
        sucker_indices = self._identify_suckers()
        if sucker_indices:
            last_round_sucker_coop = sum((history.opponent_actions[-1, idx] for idx in sucker_indices))
            if last_round_sucker_coop > 0:
                return Action.D
        return Action.D

    def _update_opponent_profiles(self, history: PlayerHistory) -> None:
        """Update tracking of opponent cooperation rates."""
        last_round_idx = history.my_actions.shape[0] - 1
        for opp_idx in range(self.n_players - 1):
            if history.opponent_actions[last_round_idx, opp_idx]:
                self.opponent_coop_counts[opp_idx] += 1
            self.opponent_total_rounds[opp_idx] += 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx, :])
        self.total_opponent_contributions += last_round_cooperators
        self.total_opponent_rounds += self.n_players - 1

    def _get_avg_opponent_contribution(self) -> float:
        """Get rolling average contribution rate of all opponents."""
        if self.total_opponent_rounds == 0:
            return 0.0
        return self.total_opponent_contributions / self.total_opponent_rounds

    def _identify_suckers(self) -> list[int]:
        """Identify opponents with cooperation rate > 70% (the 'generous' ones)."""
        suckers = []
        for opp_idx in range(self.n_players - 1):
            if self.opponent_total_rounds[opp_idx] > 0:
                coop_rate = self.opponent_coop_counts[opp_idx] / self.opponent_total_rounds[opp_idx]
                if coop_rate > 0.7:
                    suckers.append(opp_idx)
        return suckers

class Strategy_EXPLOITATIVE_25(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Exploits predictable behavioral patterns of contributors through:
    1. Initial defection to establish baseline
    2. Conditional exploitation based on observed contribution rates
    3. Aggressive defection in final rounds when no retaliation is possible
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold_high = 0.7
        self.threshold_low = 0.3
        if game_description.n_players <= 3:
            self.threshold_high = 0.5
            self.threshold_low = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        previous_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        cooperators_count = np.sum(opponent_actions_prev)
        n_opponents = self.game_description.n_players - 1
        if n_opponents > 0:
            contribution_rate = cooperators_count / n_opponents
        else:
            contribution_rate = 0.0
        my_action_prev = history.my_actions[previous_round]
        tit_for_tat_detected = False
        if n_opponents > 1:
            group_cooperated = contribution_rate >= 0.5
            we_cooperated = bool(my_action_prev)
            if group_cooperated == we_cooperated:
                tit_for_tat_detected = True
        if tit_for_tat_detected:
            return Action.D
        if state.round_number >= 2:
            previous_prev_round = state.round_number - 2
            prev_contribution_rate = np.sum(history.opponent_actions[previous_prev_round, :]) / n_opponents
            if contribution_rate >= self.threshold_high and prev_contribution_rate < self.threshold_high:
                return Action.D
        if contribution_rate >= self.threshold_high:
            return Action.D
        elif contribution_rate >= self.threshold_low:
            return Action.D
        else:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_26(BaseStrategy):
    """
    Exploitative Public Goods Strategy that free-rides on others' contributions
    while minimizing personal losses through adaptive defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.contributed_recently = False
        self.last_round_defected = False
        self.contribution_trend = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if self.k <= 1:
            return Action.D
        if round_num == 0:
            self.last_round_defected = True
            self.contributed_recently = False
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        others_contributions = int(np.sum(history.opponent_actions[-1, :]))
        max_possible_others = self.n_players - 1
        threshold = max_possible_others * 0.5
        my_last_action = history.my_actions[-1]
        self.contributed_recently = bool(my_last_action)
        if len(history.opponent_actions) > 0:
            recent_contributions = [int(np.sum(history.opponent_actions[t, :])) for t in range(max(0, len(history.opponent_actions) - 3), len(history.opponent_actions))]
            if len(recent_contributions) > 1:
                is_declining = recent_contributions[-1] < recent_contributions[0]
            else:
                is_declining = False
        else:
            is_declining = False
        if others_contributions > threshold and (not self.contributed_recently):
            self.last_round_defected = True
            return Action.D
        if self.last_round_defected and others_contributions < np.mean([int(np.sum(history.opponent_actions[t, :])) for t in range(max(0, len(history.opponent_actions) - 2), len(history.opponent_actions) - 1)] if len(history.opponent_actions) > 1 else [others_contributions]):
            self.last_round_defected = True
            return Action.D
        if others_contributions == 0 and self.contributed_recently:
            self.last_round_defected = True
            return Action.D
        if is_declining and round_num > self.n_rounds / 2:
            self.last_round_defected = True
            return Action.D
        self.last_round_defected = True
        return Action.D

class Strategy_EXPLOITATIVE_27(BaseStrategy):
    """
    Exploitative strategy for repeated public goods game.
    
    Core principle: Exploit information asymmetry by profiling opponents early,
    then dynamically shift between cooperation and defection based on observed
    contribution patterns. Defect aggressively against pure cooperators, 
    conditionally defect against conditional cooperators, and always defect 
    in the endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_types = {}
        self.profiling_complete = False
        self.endgame_threshold = max(2, math.ceil(game_description.n_rounds * 0.15))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number < 3 and (not self.profiling_complete):
            if state.round_number == 2:
                self._classify_opponents(history)
                self.profiling_complete = True
            return Action.D
        if not self.profiling_complete:
            self._classify_opponents(history)
            self.profiling_complete = True
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if rounds_remaining <= self.endgame_threshold:
            return Action.D
        return self._exploit(history, state)

    def _classify_opponents(self, history: PlayerHistory) -> None:
        """Classify opponents as unconditional cooperators, conditional cooperators, or defectors."""
        n_opponents = self.game_description.n_players - 1
        for opp_idx in range(n_opponents):
            if history.opponent_actions[0, opp_idx]:
                self.opponent_types[opp_idx] = 'unconditional_cooperator'
            else:
                self.opponent_types[opp_idx] = 'defector'

    def _exploit(self, history: PlayerHistory, state: GameState) -> Action:
        """Execute exploitation strategy based on opponent types and recent contributions."""
        n_opponents = self.game_description.n_players - 1
        unconditional_cooperators = sum((1 for otype in self.opponent_types.values() if otype == 'unconditional_cooperator'))
        last_round_contributions = sum(history.opponent_actions[-1, :])
        avg_contribution = last_round_contributions / n_opponents if n_opponents > 0 else 0
        if state.round_number >= 2:
            prev_round_contributions = sum(history.opponent_actions[-2, :])
            if last_round_contributions < 0.5 * prev_round_contributions and last_round_contributions < n_opponents * 0.3:
                return Action.D
        if unconditional_cooperators >= n_opponents * 0.6:
            return Action.D
        if unconditional_cooperators < n_opponents * 0.6:
            contribution_threshold = (n_opponents - 1) / 2
            if avg_contribution > contribution_threshold:
                return Action.D
            elif random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        if unconditional_cooperators < n_opponents * 0.2:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_28(BaseStrategy):
    """
    Exploitative Public Goods Strategy that identifies and parasitizes cooperators
    while minimizing exposure to mutual defection traps.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = None
        self.last_classification_round = -1
        self.opponent_types = None
        self.last_3_rounds_coop = None

    def _classify_opponents(self, history: PlayerHistory, current_round: int) -> None:
        """Classify each opponent into defector, conditional, or persistent cooperator."""
        n_opponents = self.game_description.n_players - 1
        if self.opponent_types is None:
            self.opponent_types = np.zeros(n_opponents, dtype=int)
            self.last_3_rounds_coop = np.zeros(n_opponents, dtype=int)
        rounds_played = current_round
        if rounds_played == 0:
            return
        for opp_idx in range(n_opponents):
            total_coop = np.sum(history.opponent_actions[:rounds_played, opp_idx])
            coop_rate = total_coop / rounds_played if rounds_played > 0 else 0.0
            last_3_start = max(0, rounds_played - 3)
            last_3_coop = np.sum(history.opponent_actions[last_3_start:rounds_played, opp_idx])
            self.last_3_rounds_coop[opp_idx] = last_3_coop
            if coop_rate >= 0.8:
                self.opponent_types[opp_idx] = 2
            elif coop_rate <= 0.2:
                self.opponent_types[opp_idx] = 0
            else:
                self.opponent_types[opp_idx] = 1
        self.last_classification_round = current_round

    def _decide_action_for_opponent(self, opp_type: int, last_3_coop: int, current_round: int) -> bool:
        """Decide whether to cooperate against a specific opponent type."""
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds - 1:
            return False
        if current_round == n_rounds - 2:
            if opp_type == 2:
                return random.random() < 0.1
            return False
        if opp_type == 2:
            return False
        if opp_type == 0:
            return False
        if opp_type == 1:
            if last_3_coop == 3:
                return random.random() < 0.0
            elif last_3_coop == 2:
                return random.random() < 0.3
            elif last_3_coop == 1:
                return random.random() < 0.6
            else:
                return random.random() < 0.4
        return False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_round = state.round_number
        if current_round - self.last_classification_round >= 3:
            self._classify_opponents(history, current_round)
        if self.opponent_types is None:
            self._classify_opponents(history, current_round)
        n_opponents = self.game_description.n_players - 1
        cooperate_count = 0
        for opp_idx in range(n_opponents):
            opp_type = self.opponent_types[opp_idx]
            last_3_coop = self.last_3_rounds_coop[opp_idx]
            if self._decide_action_for_opponent(opp_type, last_3_coop, current_round):
                cooperate_count += 1
        if cooperate_count > n_opponents // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_29(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    
    Core approach:
    - Round 1: Defect to probe and observe cooperators
    - Rounds 2 to r-1: Mostly defect, conditionally contribute only when cooperation >50%
    - Final round: Pure defection
    
    Tracks opponent patterns to identify and exploit reliable cooperators while
    minimizing exposure to free-riding losses.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        prev_round_idx = current_round - 1
        opponent_cooperators_prev = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        opponent_defectors_prev = self.n_players - 1 - opponent_cooperators_prev
        cooperation_rate = opponent_cooperators_prev / (self.n_players - 1) if self.n_players > 1 else 0
        if cooperation_rate > 0.5:
            return Action.C
        if cooperation_rate <= 0.5:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_30(BaseStrategy):
    """
    Exploitative Public Goods Strategy
    
    Defects consistently to free-ride on cooperators' contributions while avoiding
    the cost of contribution. Exploits the predictable decline of cooperation in
    repeated public goods games through unconditional defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 2:
            return Action.D
        previous_round_idx = state.round_number - 1
        total_contributions = int(np.sum(history.opponent_actions[previous_round_idx, :]))
        total_contributions += int(history.my_actions[previous_round_idx])
        if state.round_number >= 2:
            curr_round_idx = state.round_number - 1
            prev_round_idx = state.round_number - 2
            curr_contributions = int(np.sum(history.opponent_actions[curr_round_idx, :]))
            curr_contributions += int(history.my_actions[curr_round_idx])
            prev_contributions = int(np.sum(history.opponent_actions[prev_round_idx, :]))
            prev_contributions += int(history.my_actions[prev_round_idx])
            if curr_contributions == 0 and prev_contributions == 0:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_31(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Adaptive defection with selective exploitation.
    
    Core principle: Defect by default. Contribute only when opponent contribution rates
    exceed the break-even threshold (n-1)/k, never in the final round.
    Treats cooperative opponents as exploitable resources.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold_base = (self.n_players - 1) / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        last_round_idx = current_round - 1
        last_round_opponent_actions = history.opponent_actions[last_round_idx, :]
        total_opponent_contributions = np.sum(last_round_opponent_actions)
        n_opponents = self.n_players - 1
        contrib_rate = total_opponent_contributions / n_opponents if n_opponents > 0 else 0.0
        threshold = self.threshold_base
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 3:
            epsilon = 0.1
            threshold = self.threshold_base + epsilon
        defection_rate = (n_opponents - total_opponent_contributions) / n_opponents if n_opponents > 0 else 0.0
        if defection_rate > 0.5:
            return Action.D
        if contrib_rate >= threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_32(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Free-ride on others' contributions while defecting by default.
    Conditionally exploits cooperative players and maintains defection as the dominant strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = (self.n_players - 1) / (2 * self.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        return self._decide_middle_round(state, history)

    def _decide_middle_round(self, state: GameState, history: PlayerHistory) -> Action:
        """
        Decide action for rounds 1 to r-2 using conditional exploitation.
        """
        recent_round_idx = state.round_number - 1
        recent_opponent_actions = history.opponent_actions[recent_round_idx, :]
        my_recent_action = history.my_actions[recent_round_idx]
        total_cooperators = int(my_recent_action) + int(np.sum(recent_opponent_actions))
        avg_contribution_rate = total_cooperators / self.n_players
        if avg_contribution_rate > self.threshold:
            return Action.D
        if not my_recent_action:
            my_recent_payoff = history.my_payoffs[recent_round_idx]
            all_recent_payoffs = np.concatenate([[my_recent_payoff], history.opponent_payoffs[recent_round_idx, :]])
            median_payoff = float(np.median(all_recent_payoffs))
            if my_recent_payoff > median_payoff:
                return Action.D
        if len(history.my_payoffs) > 0:
            my_recent_payoff = history.my_payoffs[recent_round_idx]
            all_recent_payoffs = np.concatenate([[my_recent_payoff], history.opponent_payoffs[recent_round_idx, :]])
            q1 = float(np.percentile(all_recent_payoffs, 25))
            if my_recent_payoff <= q1:
                return Action.D
        if self._detect_sucker_pattern(history, state.round_number):
            return Action.D
        return Action.D

    def _detect_sucker_pattern(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Detect if any single opponent has consistently contributed while others defect.
        Returns True if a "sucker" pattern is detected (target for exploitation).
        """
        if current_round < 2:
            return False
        lookback_rounds = min(current_round, 3)
        recent_history = history.opponent_actions[-lookback_rounds:, :]
        for opponent_idx in range(self.n_players - 1):
            opponent_cooperation_count = int(np.sum(recent_history[:, opponent_idx]))
            if opponent_cooperation_count == lookback_rounds:
                other_cooperation = np.sum(recent_history) - opponent_cooperation_count
                if other_cooperation < (self.n_players - 2) * lookback_rounds * 0.5:
                    return True
        return False

class Strategy_EXPLOITATIVE_33(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    
    Maximizes personal payoff through free-riding by:
    - Defecting by default in early/mid-game
    - Only cooperating when near-saturated cooperation detected (>= n-1 cooperators)
    - Always defecting in final two rounds
    - Adapting to extreme cooperation/defection scenarios
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            return Action.D
        prev_round_idx = current_round - 1
        opponent_cooperators_prev = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        total_cooperators_prev = opponent_cooperators_prev + int(history.my_actions[prev_round_idx])
        cooperation_rate = total_cooperators_prev / self.n_players
        if cooperation_rate > 0.75:
            if self._detects_punisher_strategy(history, prev_round_idx):
                return Action.D
            else:
                return Action.D
        elif cooperation_rate < 0.25:
            return Action.D
        elif total_cooperators_prev >= self.n_players - 1:
            return Action.C
        else:
            return Action.D

    def _detects_punisher_strategy(self, history: PlayerHistory, current_round_idx: int) -> bool:
        """
        Detect if any opponent shows punishing/retaliatory behavior.
        Simple heuristic: check if any opponent's cooperation pattern correlates
        with group's prior cooperation in a retaliatory manner.
        """
        if current_round_idx < 2:
            return False
        for opponent_idx in range(self.n_players - 1):
            opponent_coop_history = history.opponent_actions[:current_round_idx + 1, opponent_idx]
            if current_round_idx >= 1:
                prev_was_coop = opponent_coop_history[current_round_idx - 1]
                curr_is_defect = not opponent_coop_history[current_round_idx]
                if prev_was_coop and curr_is_defect:
                    other_coop_prev = np.sum(history.opponent_actions[current_round_idx - 1, :]) / (self.n_players - 1)
                    if other_coop_prev >= 0.5:
                        return True
        return False

class Strategy_EXPLOITATIVE_34(BaseStrategy):
    """
    Exploitative Public Goods Strategy that leverages conditional cooperators
    through selective defection while maintaining a deceptive cooperative appearance.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_cooperation_rates = None
        self.defection_count = 0
        self.cooperation_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if history.my_actions[round_num - 1]:
            self.cooperation_count += 1
        else:
            self.defection_count += 1
        opponent_types = self._classify_opponents(history, round_num)
        exploitable_count = opponent_types['high_cooperators'] + opponent_types['conditional_cooperators']
        recent_contribution_rate = self._calculate_recent_contribution_rate(history, round_num)
        if round_num == self.n_rounds - 1:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        return self._exploitation_decision(round_num, exploitable_count, recent_contribution_rate, opponent_types, history)

    def _classify_opponents(self, history: PlayerHistory, round_num: int) -> dict:
        """Classify opponents as High Cooperators, Conditional Cooperators, or Defectors."""
        high_cooperators = 0
        conditional_cooperators = 0
        pure_defectors = 0
        for opponent_idx in range(self.n_players - 1):
            opponent_actions = history.opponent_actions[:round_num, opponent_idx]
            cooperation_rate = float(np.sum(opponent_actions)) / round_num if round_num > 0 else 0.0
            if cooperation_rate >= 0.7:
                high_cooperators += 1
            elif cooperation_rate < 0.3:
                pure_defectors += 1
            else:
                conditional_cooperators += 1
        return {'high_cooperators': high_cooperators, 'conditional_cooperators': conditional_cooperators, 'pure_defectors': pure_defectors}

    def _calculate_recent_contribution_rate(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate average opponent contribution rate in recent rounds."""
        if round_num == 0:
            return 0.0
        recent_rounds = max(1, min(3, round_num))
        recent_opponent_actions = history.opponent_actions[round_num - recent_rounds:round_num, :]
        avg_contribution = float(np.sum(recent_opponent_actions)) / (recent_rounds * (self.n_players - 1))
        return avg_contribution if not np.isnan(avg_contribution) else 0.0

    def _exploitation_decision(self, round_num: int, exploitable_count: int, recent_contribution_rate: float, opponent_types: dict, history: PlayerHistory) -> Action:
        """Decide whether to defect or cooperate based on exploitation conditions."""
        total_opponents = self.n_players - 1
        exploitable_ratio = exploitable_count / total_opponents if total_opponents > 0 else 0.0
        defection_threshold_base = 0.6
        if self.k < 1.1:
            defection_threshold_base = 0.65
        if self.n_players > 10:
            defection_threshold_base = 0.5
        if self.n_rounds <= 3:
            defection_threshold_base = 0.55
        my_defection_rate = self.defection_count / (self.defection_count + self.cooperation_count + 1e-06)
        if my_defection_rate > 0.8:
            if random.random() < 0.35:
                return Action.C
            return Action.D
        if round_num >= 3 and opponent_types['pure_defectors'] == total_opponents:
            return Action.D
        if opponent_types['conditional_cooperators'] > 0:
            if round_num > 1:
                prev_opponent_contribution = float(np.sum(history.opponent_actions[round_num - 1, :])) / total_opponents
                prev_prev_opponent_contribution = float(np.sum(history.opponent_actions[round_num - 2, :])) / total_opponents if round_num > 1 else 1.0
                if prev_prev_opponent_contribution < 0.2 and prev_opponent_contribution > 0.3:
                    return Action.C
        if exploitable_ratio >= defection_threshold_base:
            return Action.D
        if recent_contribution_rate > 0.4:
            return Action.D
        if my_defection_rate < 0.4:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_35(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    
    Core principle: Free-ride on others' contributions while maintaining just enough
    credibility to prevent universal defection. Defects in round 1, exploits high cooperation
    in middle rounds, and defects unconditionally in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.collapse_threshold = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_idx = state.round_number - 1
        cooperators_prev_round = np.sum(history.opponent_actions[previous_round_idx, :])
        cooperation_rate = cooperators_prev_round / self.game_description.n_players
        if cooperation_rate < self.collapse_threshold:
            return Action.D
        if cooperation_rate >= self.cooperation_threshold:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_36(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Exploits predictable behavioral patterns of cooperators by defecting persistently
    while capturing benefits from others' contributions. Adapts only based on round count
    and aggregate cooperator numbers, not individual player behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round >= self.n_rounds - 2:
            return Action.D
        previous_round_index = current_round - 1
        cooperators_last_round = int(sum(history.opponent_actions[previous_round_index, :]))
        threshold = (self.n_players - 1) / 2.0
        if cooperators_last_round == self.n_players - 1:
            return Action.D
        if cooperators_last_round >= threshold:
            return Action.D
        else:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_37(BaseStrategy):
    """
    Exploitative Public Goods Strategy that exploits predictable patterns of 
    conditional cooperators and free-riders through strategic defection and 
    selective contribution based on opponent contribution rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        opponent_contributions = history.opponent_actions[:round_num, :]
        contribution_freqs = np.sum(opponent_contributions, axis=0) / round_num
        tier_a_count = 0
        tier_b_count = 0
        tier_c_count = 0
        threshold_high = 0.8 if self.k >= self.n_players * 0.8 else 0.7
        threshold_low = 0.3
        for freq in contribution_freqs:
            if freq >= threshold_high:
                tier_a_count += 1
            elif freq > threshold_low:
                tier_b_count += 1
            else:
                tier_c_count += 1
        prev_total_contribution = np.sum(history.opponent_actions[round_num - 1, :])
        majority_defecting = tier_c_count > (self.n_players - 1) // 2
        if majority_defecting:
            return Action.D
        if self.n_players <= 3:
            if prev_total_contribution >= 2:
                return Action.C
            return Action.D
        if tier_b_count > 0:
            if prev_total_contribution >= max(1, self.k - 1):
                return Action.C
            return Action.D
        if tier_a_count > 0:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_38(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Learn others' contribution patterns and systematically
    free-ride when beneficial. Defect in round 1 to probe, adaptively exploit moderate cooperators
    by oscillating contribution, consistently defect against strong cooperators or defectors,
    and always defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defect_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        avg_others = self._calculate_avg_others_contribution(history)
        current_action = self._decide_action(avg_others)
        if current_action == Action.D:
            self.defect_streak += 1
        else:
            self.defect_streak = 0
        return current_action

    def _calculate_avg_others_contribution(self, history: PlayerHistory) -> float:
        """
        Calculate the average contribution rate of all other players across all prior rounds.
        Returns a value between 0 and 1.
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_rounds = history.opponent_actions.shape[0]
        total_players = history.opponent_actions.shape[1]
        if total_rounds == 0 or total_players == 0:
            return 0.0
        total_contributions = np.sum(history.opponent_actions)
        total_actions = total_rounds * total_players
        return float(total_contributions) / float(total_actions)

    def _decide_action(self, avg_others: float) -> Action:
        """
        Decide whether to cooperate or defect based on average others' contribution rate.
        """
        if avg_others >= 0.7:
            return Action.D
        if 0.4 <= avg_others < 0.7:
            if self.defect_streak < 2:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_39(BaseStrategy):
    """
    Exploitative Public Goods Strategy with Conditional Free-Riding.
    
    Core approach:
    - Round 0: Defect to gather information
    - Rounds 1 to r-2: Adaptive phase - defect unless opponents show sustained high cooperation
    - Round r-1: Defect unconditionally (endgame)
    
    The strategy exploits the payoff structure by free-riding on cooperative opponents
    while avoiding wasted contributions to defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_threshold = (self.k - 1) / self.k
        self.recent_decline_detected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.D
        if self._detect_recent_decline(history, round_num):
            self.recent_decline_detected = True
        if self.recent_decline_detected:
            return Action.D
        coop_rate = self._calculate_opponent_coop_rate(history, round_num)
        if coop_rate > self.cooperation_threshold:
            return Action.D
        else:
            return Action.D

    def _calculate_opponent_coop_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the proportion of cooperation among opponents across all played rounds.
        
        coop_rate = (total contributions from other players) / (number of other players × rounds played)
        """
        n_other_players = self.n_players - 1
        if n_other_players <= 0 or round_num <= 0:
            return 0.0
        total_contributions = int(np.sum(history.opponent_actions[:round_num, :]))
        total_possible = n_other_players * round_num
        if total_possible == 0:
            return 0.0
        coop_rate = total_contributions / total_possible
        return coop_rate

    def _detect_recent_decline(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Detect if cooperation has sharply decreased in recent rounds (last 3 rounds).
        Returns True if a significant decline is detected.
        """
        if round_num < 4:
            return False
        recent_start = max(0, round_num - 3)
        earlier_start = max(0, round_num - 6)
        recent_contributions = int(np.sum(history.opponent_actions[recent_start:round_num, :]))
        recent_possible = (self.n_players - 1) * (round_num - recent_start)
        if recent_possible == 0:
            return False
        recent_rate = recent_contributions / recent_possible
        if earlier_start < recent_start:
            earlier_contributions = int(np.sum(history.opponent_actions[earlier_start:recent_start, :]))
            earlier_possible = (self.n_players - 1) * (recent_start - earlier_start)
            if earlier_possible == 0:
                earlier_rate = 0.0
            else:
                earlier_rate = earlier_contributions / earlier_possible
            if earlier_rate > 0.3 and recent_rate < earlier_rate * 0.8:
                return True
        return False

class Strategy_EXPLOITATIVE_40(BaseStrategy):
    """
    Exploitative Public Goods Strategy that adaptively profiles opponents
    and extracts maximum payoff through controlled free-riding.
    
    Core approach:
    - Round 0: Defect to establish baseline
    - Rounds 1 to r-2: Exploit based on opponent cooperation frequency
    - Rounds r-1 and r: Unconditional defection (endgame)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_contribution_counts = None
        self.opponent_round_counts = None
        self.tit_for_tat_detected = None
        self.defection_cycle_state = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if self.opponent_contribution_counts is None:
            n_opponents = self.game_description.n_players - 1
            self.opponent_contribution_counts = [0] * n_opponents
            self.opponent_round_counts = [0] * n_opponents
            self.tit_for_tat_detected = [False] * n_opponents
            self.defection_cycle_state = [0] * n_opponents
        round_num = state.round_number
        n_rounds = self.game_description.n_rounds
        n_opponents = self.game_description.n_players - 1
        if round_num == 0:
            return Action.D
        if history is not None and round_num > 0:
            for opp_idx in range(n_opponents):
                self.opponent_contribution_counts[opp_idx] += int(history.opponent_actions[round_num - 1, opp_idx])
                self.opponent_round_counts[opp_idx] += 1
        if round_num >= n_rounds - 2:
            return Action.D
        if history is not None:
            max_exploit_action = Action.D
            for opp_idx in range(n_opponents):
                if self.opponent_round_counts[opp_idx] > 0:
                    freq = self.opponent_contribution_counts[opp_idx] / self.opponent_round_counts[opp_idx]
                    if round_num >= 1:
                        my_last_action = history.my_actions[round_num - 1]
                        opp_last_action = history.opponent_actions[round_num - 1, opp_idx]
                        if not my_last_action and (not opp_last_action):
                            if freq > 0.5:
                                self.tit_for_tat_detected[opp_idx] = True
                    if freq > 0.7:
                        max_exploit_action = Action.D
                    elif 0.3 <= freq <= 0.7:
                        if self.tit_for_tat_detected[opp_idx]:
                            if self.defection_cycle_state[opp_idx] == 0:
                                self.defection_cycle_state[opp_idx] = 1
                                max_exploit_action = Action.C
                            else:
                                self.defection_cycle_state[opp_idx] = 0
                                max_exploit_action = Action.D
                        else:
                            max_exploit_action = Action.D
                    else:
                        max_exploit_action = Action.D
            return max_exploit_action
        return Action.D

class Strategy_EXPLOITATIVE_41(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Adaptive exploitation that observes opponent types,
    exploits cooperators when beneficial, and defects unconditionally in endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_contribution_history = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num <= 1:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        sucker_indices = []
        defector_indices = []
        for opp_idx in range(self.n_players - 1):
            round0_coop = history.opponent_actions[0, opp_idx]
            round1_coop = history.opponent_actions[1, opp_idx]
            if round0_coop and round1_coop:
                sucker_indices.append(opp_idx)
            else:
                defector_indices.append(opp_idx)
        if len(sucker_indices) == 0:
            return Action.D
        sucker_contributions_last_round = sum((history.opponent_actions[round_num - 1, idx] for idx in sucker_indices))
        sucker_count = len(sucker_indices)
        if sucker_count > 0:
            sucker_contribution_rate = sucker_contributions_last_round / sucker_count
        else:
            sucker_contribution_rate = 0.0
        if sucker_contribution_rate > 0.5:
            payoff_if_contribute = self.k / self.n_players * (sucker_contributions_last_round + 1)
            payoff_if_defect = 1 + self.k / self.n_players * sucker_contributions_last_round
            if payoff_if_contribute > payoff_if_defect:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_42(BaseStrategy):
    """
    Exploitative Public Goods Strategy
    
    Maximizes personal payoff by strategically defecting while parasitizing others' contributions.
    - Round 1: Defect to establish baseline
    - Rounds 2 to r-1: Defect if average contribution > k/n, else defect (free-ride on any contributions)
    - Final round: Unconditional defect (no future punishment)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        previous_round_idx = current_round - 1
        previous_cooperators = int(np.sum(history.opponent_actions[previous_round_idx, :]))
        if history.my_actions[previous_round_idx]:
            previous_cooperators += 1
        average_contribution = previous_cooperators / self.n_players
        threshold = self.k / self.n_players
        return Action.D

class Strategy_EXPLOITATIVE_43(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defects to free-ride on cooperators while
    maximizing absolute payoff. Uses adaptive defection with selective exploitation
    based on prior round contribution patterns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = self.n_players * self.k / (self.n_players + 1)
        self.contribution_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        prev_round_idx = round_num - 1
        cooperators_prev = int(sum(history.opponent_actions[prev_round_idx, :]))
        self.contribution_history.append(cooperators_prev)
        if round_num == self.n_rounds - 1:
            return Action.D
        if len(self.contribution_history) >= 2:
            prev_contrib = self.contribution_history[-2]
            curr_contrib = self.contribution_history[-1]
            if prev_contrib > 0:
                variability = abs(curr_contrib - prev_contrib) / prev_contrib
                if variability > 0.3:
                    return Action.D
        if cooperators_prev == self.n_players - 1:
            return Action.D
        if cooperators_prev >= self.threshold:
            return Action.D
        if cooperators_prev < self.threshold:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_44(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Systematically defects to exploit cooperators
    while avoiding retaliation costs. Adapts based on opponent cooperation rates but
    maintains defection as the dominant strategy across all phases.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_rates = None
        self.last_round_defectors = set()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_round = state.round_number
        n_opponents = self.game_description.n_players - 1
        cooperation_rates = self._calculate_opponent_cooperation_rates(history, current_round)
        aggregate_coop_rate = np.mean(cooperation_rates) if len(cooperation_rates) > 0 else 0.0
        if aggregate_coop_rate > 0.6:
            return Action.D
        elif aggregate_coop_rate < 0.3:
            return Action.D
        else:
            return Action.D

    def _calculate_opponent_cooperation_rates(self, history: PlayerHistory, current_round: int) -> np.ndarray:
        """
        Calculate the cooperation rate for each opponent based on history.
        Handles noise by ignoring sparse observations and using smoothed trends.
        """
        n_opponents = self.game_description.n_players - 1
        cooperation_rates = np.zeros(n_opponents)
        for opp_idx in range(n_opponents):
            opponent_cooperations = np.sum(history.opponent_actions[:current_round, opp_idx])
            rounds_observed = current_round
            if rounds_observed == 0:
                cooperation_rates[opp_idx] = 0.0
            else:
                cooperation_rates[opp_idx] = opponent_cooperations / rounds_observed
        return cooperation_rates

class Strategy_EXPLOITATIVE_45(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Conditional free-riding with adaptive defection.
    
    Defects by default to identify and exploit reliable cooperators.
    Tracks opponent cooperation patterns and contributes only when expected returns
    from the public pool exceed the opportunity cost of contribution.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_coop_rates = [0.0] * (self.n_players - 1)
        self.opponent_coop_counts = [0] * (self.n_players - 1)
        self.opponent_round_counts = [0] * (self.n_players - 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if self.n_players == 2:
            return Action.D
        self._update_opponent_stats(history, current_round)
        if current_round < 3:
            return Action.D
        predicted_other_contributions = self._predict_other_contributions()
        threshold = self.n_players / self.k - 1.0
        if predicted_other_contributions > threshold:
            return Action.C
        return Action.D

    def _update_opponent_stats(self, history: PlayerHistory, current_round: int) -> None:
        """
        Update cooperation statistics for each opponent based on all rounds up to current.
        """
        for round_idx in range(current_round):
            for opp_idx in range(self.n_players - 1):
                if self.opponent_round_counts[opp_idx] == 0:
                    self.opponent_coop_rates[opp_idx] = 0.0
                if history.opponent_actions[round_idx, opp_idx]:
                    self.opponent_coop_counts[opp_idx] += 1
                self.opponent_round_counts[opp_idx] += 1
                if self.opponent_round_counts[opp_idx] > 0:
                    self.opponent_coop_rates[opp_idx] = self.opponent_coop_counts[opp_idx] / self.opponent_round_counts[opp_idx]

    def _predict_other_contributions(self) -> float:
        """
        Predict total contributions from other players in the next round
        based on their historical cooperation rates.
        
        Only count players with cooperation rate > 1/k as viable contributors.
        """
        predicted_total = 0.0
        threshold_coop_rate = 1.0 / self.k if self.k > 0 else 0.0
        for opp_idx in range(self.n_players - 1):
            if self.opponent_coop_rates[opp_idx] > threshold_coop_rate:
                predicted_total += self.opponent_coop_rates[opp_idx]
        return predicted_total

class Strategy_EXPLOITATIVE_46(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Maps opponent types through defection,
    then systematically free-rides on cooperative players while avoiding exposure
    to defectors. Defects in round 1, final round, and whenever cooperation is
    not sufficiently prevalent.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == n_rounds - 1:
            return Action.D
        if n_rounds <= 3:
            return Action.D
        rounds_observed = current_round
        opponent_actions = history.opponent_actions[:current_round, :]
        cooperation_rates = np.sum(opponent_actions, axis=0) / rounds_observed
        num_type_c = np.sum(cooperation_rates >= 0.7)
        num_type_d = np.sum(cooperation_rates <= 0.2)
        num_type_u = n_players - num_type_c - num_type_d
        proportion_type_c = num_type_c / n_players
        total_contributions_last_round = np.sum(opponent_actions[-1, :])
        if current_round > 0 and total_contributions_last_round == 0:
            return Action.D
        if proportion_type_c >= 0.4:
            return Action.D
        if proportion_type_c < 0.4:
            proportion_type_d = num_type_d / n_players
            if proportion_type_d >= 0.6:
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_47(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Always defect while appearing adaptive.
    
    Exploits cooperative players by freeloading on their contributions.
    Uses conditional defection logic based on cooperation rates to appear responsive,
    but ultimately defects in all rounds, especially the last round to avoid
    any reputational consequences.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.k = game_description.k
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        previous_round_index = state.round_number - 1
        previous_opponent_actions = history.opponent_actions[previous_round_index, :]
        num_cooperators = int(np.sum(previous_opponent_actions))
        cooperation_rate = num_cooperators / self.n_players
        threshold = 1.0 / self.k
        if cooperation_rate > threshold:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_48(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Defects unconditionally to free-ride on cooperators while avoiding losses.
    Categorizes opponents as consistent cooperators, reciprocators, or defectors
    based on historical contribution rates, then systematically exploits them.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_contribution_rates = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if self.opponent_contribution_rates is None:
            self.opponent_contribution_rates = self._calculate_contribution_rates(history)
        else:
            self.opponent_contribution_rates = self._calculate_contribution_rates(history)
        return Action.D

    def _calculate_contribution_rates(self, history: PlayerHistory) -> NDArray[np.float64]:
        """
        Calculate each opponent's contribution rate across all observed rounds.
        
        Returns array where rates[i] is the contribution rate of opponent i.
        Contribution rate = (number of rounds where opponent cooperated) / (total rounds observed)
        """
        n_opponents = self.game_description.n_players - 1
        n_rounds_observed = history.opponent_actions.shape[0]
        if n_rounds_observed == 0:
            return np.zeros(n_opponents)
        cooperations_per_opponent = np.sum(history.opponent_actions, axis=0)
        contribution_rates = cooperations_per_opponent / max(n_rounds_observed, 1)
        return contribution_rates

    def _categorize_opponent(self, contribution_rate: float) -> str:
        """
        Categorize opponent based on contribution rate.
        
        - Consistent Cooperators: ≥80% contribution rate
        - Reciprocators: 40-70% contribution rate
        - Defectors: ≤20% contribution rate
        - Others: uncategorized (but treated as defectors)
        """
        if contribution_rate >= 0.8:
            return 'consistent_cooperator'
        elif 0.4 <= contribution_rate <= 0.7:
            return 'reciprocator'
        elif contribution_rate <= 0.2:
            return 'defector'
        else:
            return 'uncategorized'

class Strategy_EXPLOITATIVE_49(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defect to exploit cooperators while gathering
    information about opponent types. Classify opponents as Unconditional Cooperators,
    Conditional Cooperators, or Defectors, then continuously defect to maximize payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_round = state.round_number
        opponent_types = self._classify_opponents(history, current_round)
        unconditional_count = sum((1 for opp_type in opponent_types if opp_type == 'unconditional'))
        if current_round < self.n_rounds - 1:
            return Action.D
        return Action.D

    def _classify_opponents(self, history: PlayerHistory, current_round: int) -> list:
        """
        Classify each opponent as:
        - "unconditional": contributed every round
        - "conditional": contributed when others did, defected when others defected
        - "defector": never contributed
        """
        n_opponents = self.n_players - 1
        opponent_types = []
        for opp_idx in range(n_opponents):
            opp_actions = history.opponent_actions[:current_round, opp_idx]
            coop_count = np.sum(opp_actions)
            total_rounds = current_round
            if coop_count == total_rounds:
                opponent_types.append('unconditional')
            elif coop_count == 0:
                opponent_types.append('defector')
            else:
                opponent_types.append('conditional')
        return opponent_types

class Strategy_EXPLOITATIVE_50(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defect by default, contribute only when
    necessary to prevent complete pool collapse. Maximizes free-riding gains while
    minimizing own investment through strategic pool maintenance.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        all_contributions = history.my_actions.astype(np.float64).sum(axis=0) + history.opponent_actions.astype(np.float64).sum(axis=1)
        avg_contrib = np.mean(all_contributions[:round_num])
        pool_size_last_round = history.my_actions[round_num - 1].astype(float) + history.opponent_actions[round_num - 1].astype(np.float64).sum()
        threshold = (self.n_players - 1) / 2
        if avg_contrib >= threshold:
            return Action.D
        if round_num >= 2:
            pool_size_prev_round = history.my_actions[round_num - 2].astype(float) + history.opponent_actions[round_num - 2].astype(np.float64).sum()
            if pool_size_last_round < pool_size_prev_round and avg_contrib < threshold:
                if pool_size_last_round > 0 and avg_contrib >= 0.25:
                    return Action.C
        if avg_contrib < 0.25:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_51(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    
    Systematically defects to free-ride on others' contributions.
    Classifies opponents by contribution rate but defects against all types.
    Maintains defection throughout, including the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_contribution_rates = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            self._update_opponent_classifications(history)
            return Action.D
        return Action.D

    def _update_opponent_classifications(self, history: PlayerHistory) -> None:
        """
        Update contribution rates for each opponent based on observed history.
        Classification thresholds:
        - Cooperators: ≥70% contribution rate
        - Reciprocators: 30-69% contribution rate
        - Defectors: <30% contribution rate
        
        All are exploited with defection, but classification allows for
        adaptive refinement if strategy shifts are observed.
        """
        n_opponents = self.game_description.n_players - 1
        rounds_observed = history.my_actions.shape[0]
        for opponent_idx in range(n_opponents):
            if rounds_observed > 0:
                cooperations = int(np.sum(history.opponent_actions[:rounds_observed, opponent_idx]))
                contribution_rate = cooperations / rounds_observed if rounds_observed > 0 else 0.0
                self.opponent_contribution_rates[opponent_idx] = contribution_rate

class Strategy_EXPLOITATIVE_52(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Always defect to maximize individual payoff
    by free-riding on others' contributions while preserving your endowment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_53(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy that identifies and exploits cooperative players
    while defecting against defectors and unpredictable players. Uses informational asymmetry
    and lack of punishment mechanism to maximize personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_types = {}
        self.cooperation_history = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        self._classify_opponents(history, state.round_number)
        cooperation_rate = self._calculate_cooperation_rate(history)
        if cooperation_rate < 0.3:
            return Action.D
        if cooperation_rate > 0.7 and self._check_persistent_high_cooperation(history):
            if 3 <= state.round_number <= 5:
                return Action.C
            return Action.D
        for opponent_idx, opponent_type in self.opponent_types.items():
            if opponent_type == 'consistent_cooperator':
                return Action.C
        return Action.D

    def _classify_opponents(self, history: PlayerHistory, current_round: int) -> None:
        """Classify each opponent based on their contribution history."""
        n_opponents = self.game_description.n_players - 1
        for opponent_idx in range(n_opponents):
            if opponent_idx not in self.cooperation_history:
                self.cooperation_history[opponent_idx] = []
            for round_idx in range(current_round):
                if len(self.cooperation_history[opponent_idx]) <= round_idx:
                    self.cooperation_history[opponent_idx].append(bool(history.opponent_actions[round_idx, opponent_idx]))
            coop_record = self.cooperation_history[opponent_idx]
            if len(coop_record) == 0:
                continue
            coop_count = sum(coop_record)
            coop_rate = coop_count / len(coop_record)
            if self._is_mirror_strategy(opponent_idx, history):
                self.opponent_types[opponent_idx] = 'defector'
                continue
            if coop_rate >= 0.99:
                self.opponent_types[opponent_idx] = 'consistent_cooperator'
            elif coop_rate <= 0.01:
                self.opponent_types[opponent_idx] = 'defector'
            elif abs(coop_rate - 0.5) < 0.25:
                self.opponent_types[opponent_idx] = 'wavering'
            else:
                self.opponent_types[opponent_idx] = 'conditional_cooperator'

    def _is_mirror_strategy(self, opponent_idx: int, history: PlayerHistory) -> bool:
        """Check if opponent mirrors our behavior (defects except when we cooperate)."""
        if len(history.my_actions) < 2:
            return False
        recent_rounds = min(3, len(history.my_actions) - 1)
        mirror_matches = 0
        for round_idx in range(1, recent_rounds + 1):
            our_action = history.my_actions[round_idx]
            their_action = history.opponent_actions[round_idx, opponent_idx]
            if our_action == their_action:
                mirror_matches += 1
        return mirror_matches == recent_rounds

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the overall cooperation rate in the group (excluding ourselves)."""
        if history.opponent_actions.size == 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions)
        total_possible = history.opponent_actions.size
        if total_possible == 0:
            return 0.0
        return float(total_cooperations) / float(total_possible)

    def _check_persistent_high_cooperation(self, history: PlayerHistory) -> bool:
        """Check if cooperation rate exceeded 70% for 3+ consecutive recent rounds."""
        if len(history.opponent_actions) < 3:
            return False
        recent_rounds = min(3, len(history.opponent_actions))
        cooperation_counts = []
        for round_idx in range(-recent_rounds, 0):
            round_actions = history.opponent_actions[round_idx, :]
            coop_count = np.sum(round_actions)
            coop_rate = float(coop_count) / float(len(round_actions))
            cooperation_counts.append(coop_rate)
        return all((rate >= 0.7 for rate in cooperation_counts))

class Strategy_EXPLOITATIVE_54(BaseStrategy):
    """
    Exploitative Public Goods Strategy that exploits conditional cooperators
    and free-riders while maximizing personal payoff through strategic defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.cumulative_payoff = 0.0
        self.opponent_contribution_counts = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        is_first_round = round_num == 0
        is_last_round = round_num == self.n_rounds - 1
        if is_first_round:
            self.opponent_contribution_counts = np.zeros(self.n_players - 1)
            return Action.C
        if self.opponent_contribution_counts is None:
            self.opponent_contribution_counts = np.zeros(self.n_players - 1)
        self.cumulative_payoff += history.my_payoffs[round_num - 1]
        opponent_actions_prev = history.opponent_actions[round_num - 1, :]
        self.opponent_contribution_counts += opponent_actions_prev.astype(float)
        if is_last_round:
            return Action.D
        total_contributions_prev = int(np.sum(history.opponent_actions[round_num - 1, :])) + (1 if history.my_actions[round_num - 1] else 0)
        avg_opponent_payoff = np.mean(history.opponent_payoffs[round_num - 1, :])
        payoff_lead = history.my_payoffs[round_num - 1] > avg_opponent_payoff
        if total_contributions_prev == self.n_players:
            return Action.D
        if total_contributions_prev == 0:
            return Action.C
        base_threshold = self.k / self.n_players * 0.6
        threshold = base_threshold
        if payoff_lead:
            threshold = base_threshold * 0.8
        contribution_rate = total_contributions_prev / self.n_players
        conditional_cooperators = []
        for opp_idx in range(self.n_players - 1):
            rounds_played = min(round_num, self.n_rounds)
            if rounds_played > 0:
                contribution_freq = self.opponent_contribution_counts[opp_idx] / rounds_played
                if contribution_freq > 0.7:
                    conditional_cooperators.append(opp_idx)
        if not payoff_lead:
            return Action.D
        if contribution_rate > threshold:
            if conditional_cooperators:
                return Action.D
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_55(BaseStrategy):
    """
    Exploitative Public Goods Strategy that systematically defects to capture
    free-rider benefits from cooperative players while minimizing losses.
    
    Core approach:
    - Always defect except in cases where cooperation explicitly yields higher payoff
    - In standard PGG with 1 < k < n, defection dominates cooperation
    - Exploit cooperators' reciprocity heuristics without reciprocating
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        if history is not None and round_num > 0:
            prev_round_idx = round_num - 1
            opponent_cooperations = history.opponent_actions[prev_round_idx, :]
            num_opponent_cooperators = int(np.sum(opponent_cooperations))
            cooperation_rate = num_opponent_cooperators / self.n_players
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_56(BaseStrategy):
    """
    Exploitative Public Goods Strategy - Free-rides on cooperators while defecting systematically.
    
    Core principle: Always defect except when gathering information. Exploits conditional cooperators
    by observing their contributions and then defecting to capture benefits without reciprocating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            previous_round_opponent_actions = history.opponent_actions[current_round - 1, :]
            num_cooperators = np.sum(previous_round_opponent_actions)
            avg_others = num_cooperators / (self.n_players - 1) if self.n_players > 1 else 0.0
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_57(BaseStrategy):
    """
    Exploitative Public Goods Strategy that maximizes personal payoff by identifying
    and exploiting cooperative players while minimizing losses to defectors.
    
    Core approach:
    - Round 1: Defect to gather information
    - Rounds 2 to r-2: Classify opponents and exploit cooperators
    - Final rounds: Defect to extract maximum value
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        opponent_coop_rates = self._calculate_opponent_cooperation_rates(history)
        sucker_count = sum((1 for rate in opponent_coop_rates if rate > 0.6))
        mixed_count = sum((1 for rate in opponent_coop_rates if 0.2 < rate <= 0.6))
        defector_count = sum((1 for rate in opponent_coop_rates if rate <= 0.2))
        total_opponents = len(opponent_coop_rates)
        sucker_proportion = sucker_count / total_opponents if total_opponents > 0 else 0
        should_defect_tft = self._should_defect_tit_for_tat(history, opponent_coop_rates)
        if should_defect_tft:
            return Action.D
        if sucker_proportion > 0.5:
            return Action.C
        else:
            expected_contributions = self._estimate_expected_contributions(opponent_coop_rates, history)
            expected_return = self.k / self.n_players * expected_contributions
            if expected_return > 0.8:
                return Action.C
            else:
                return Action.D

    def _calculate_opponent_cooperation_rates(self, history: PlayerHistory) -> list[float]:
        """
        Calculate cooperation frequency for each opponent based on history.
        Returns list of cooperation rates indexed by opponent.
        """
        n_opponents = history.opponent_actions.shape[1]
        cooperation_rates = []
        for opponent_idx in range(n_opponents):
            opponent_history = history.opponent_actions[:, opponent_idx]
            if len(opponent_history) == 0:
                cooperation_rates.append(0.0)
            else:
                coop_count = np.sum(opponent_history)
                coop_rate = float(coop_count) / len(opponent_history)
                cooperation_rates.append(coop_rate)
        return cooperation_rates

    def _should_defect_tit_for_tat(self, history: PlayerHistory, opponent_coop_rates: list[float]) -> bool:
        """
        Check if any mixed player (0.2 < coop_rate <= 0.6) defected last round.
        If so, defect this round (tit-for-tat punishment).
        """
        if len(history.opponent_actions) < 1:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        for opponent_idx, action in enumerate(last_round_actions):
            if 0.2 < opponent_coop_rates[opponent_idx] <= 0.6:
                if not action:
                    return True
        return False

    def _estimate_expected_contributions(self, opponent_coop_rates: list[float], history: PlayerHistory) -> float:
        """
        Estimate total contributions (including self) if I cooperate this round.
        Base calculation on opponent cooperation rates plus my own contribution.
        """
        if len(opponent_coop_rates) == 0:
            return 1.0
        expected_opponent_contributions = sum(opponent_coop_rates)
        total_expected = expected_opponent_contributions + 1.0
        return total_expected

class Strategy_EXPLOITATIVE_58(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Maximize personal payoff by defecting and free-riding
    on others' contributions. Establishes defection as dominant behavior from round 1 and
    maintains it throughout, with adaptive detection of contribution patterns but continued
    exploitation regardless.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.contribution_threshold = (self.n_players - 1) * 0.4

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if history is not None and current_round > 0:
            previous_round_idx = current_round - 1
            opponent_contributions_previous = np.sum(history.opponent_actions[previous_round_idx, :])
            if opponent_contributions_previous >= self.contribution_threshold:
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_59(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Always defects to maximize individual payoff by free-riding on others' 
    contributions while keeping the full endowment. The strategy exploits the 
    fundamental asymmetry where defection is individually optimal regardless of 
    opponent behavior, since k < n guarantees that the personal cost of cooperation 
    (1 token) exceeds the individual benefit from one's own contribution (k/n < 1).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            prev_round_index = state.round_number - 1
            n_cooperators_prev = int(np.sum(history.opponent_actions[prev_round_index, :]))
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_60(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Maximizes personal payoff by exploiting others' contributions while minimizing
    own contribution. Always defects except adapts based on observed cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions
        n_other_players = self.game_description.n_players - 1
        total_other_cooperations = float(np.sum(opponent_actions))
        n_previous_rounds = state.round_number
        total_possible_contributions = n_other_players * n_previous_rounds
        if total_possible_contributions == 0:
            avg_others = 0.0
        else:
            avg_others = total_other_cooperations / total_possible_contributions
        if avg_others >= 0.5:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_61(BaseStrategy):
    """
    Exploitative strategy for repeated N-player public goods game.
    
    Defects in round 1 to probe, then exploits cooperative behavior by defecting
    whenever cooperation rate exceeds the threshold (k-1)/k, and always defects
    in the final round. Treats cooperators as resources to extract value from.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = (game_description.k - 1) / game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_index = state.round_number - 1
        opponent_cooperations = sum(history.opponent_actions[previous_round_index, :])
        n_opponents = self.game_description.n_players - 1
        if n_opponents == 0:
            return Action.D
        cooperation_rate = opponent_cooperations / n_opponents
        if cooperation_rate >= self.cooperation_threshold:
            return Action.D
        if cooperation_rate > 0:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_62(BaseStrategy):
    """
    Exploitative Public Goods Strategy that exploits cooperators while avoiding detection.
    
    Core approach:
    - Round 1: Defect to identify unconditional cooperators
    - Rounds 2-(r-1): Exploit identified cooperators, defect against defectors
    - Round r: Defect to capture final round value
    - Adaptive: Monitor contribution levels and adjust based on whether pool remains profitable
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_round1_actions = None
        self.defector_indices = set()
        self.cooperator_indices = set()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if self.opponent_round1_actions is None:
            self.opponent_round1_actions = history.opponent_actions[0, :]
            for opponent_idx in range(self.game_description.n_players - 1):
                if self.opponent_round1_actions[opponent_idx]:
                    self.cooperator_indices.add(opponent_idx)
                else:
                    self.defector_indices.add(opponent_idx)
        current_round = state.round_number
        last_round = self.game_description.n_rounds - 1
        if current_round == last_round:
            return Action.D
        prev_round_idx = current_round - 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx, :]
        prev_total_cooperators = sum(prev_opponent_actions)
        contribution_threshold = self.game_description.n_players / 2.0
        if current_round == last_round - 1:
            if prev_total_cooperators > contribution_threshold:
                return Action.C
        if prev_total_cooperators == 0:
            return Action.D
        if prev_total_cooperators < contribution_threshold and (not history.my_actions[prev_round_idx]):
            return Action.D
        if prev_total_cooperators > contribution_threshold:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_63(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Free-ride on others' contributions while
    maintaining a cooperator reputation early, then defect unconditionally in final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round >= self.n_rounds - 2:
            return Action.D
        opponent_actions = history.opponent_actions[:current_round, :]
        if opponent_actions.size == 0:
            return Action.C
        average_other_contribution = np.mean(opponent_actions)
        if average_other_contribution >= 0.5:
            return Action.D
        else:
            cooperation_probability = average_other_contribution + 0.2
            if random.random() < cooperation_probability:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_64(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy: Conditional free-riding with adaptive defection.
    
    Core logic:
    - Rounds 1-2: Contribute to build trust and gather intelligence
    - Rounds 3 to (r-2): Contribute only if others' avg contribution >= (k-1)/k threshold
    - Final round: Always defect (no future punishment possible)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = (self.k - 1) / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == 1:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.D
        prev_round_idx = round_num - 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx, :]
        n_cooperators = int(np.sum(prev_opponent_actions))
        avg_contribution_rate = n_cooperators / (self.n_players - 1)
        if avg_contribution_rate >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_65(BaseStrategy):
    """
    Exploitative Public Goods Strategy that identifies and exploits cooperative opponents
    while defecting against defectors. Adapts classification based on opponent behavior
    patterns across rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_types = {}
        self.cooperation_rates = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        self._classify_opponents(history, state.round_number)
        return self._exploit_opponents(history, state.round_number)

    def _classify_opponents(self, history: PlayerHistory, current_round: int) -> None:
        """
        Classify each opponent based on their contribution history.
        """
        n_opponents = self.game_description.n_players - 1
        for opp_idx in range(n_opponents):
            opp_actions = history.opponent_actions[:current_round, opp_idx]
            if len(opp_actions) == 0:
                continue
            coop_count = np.sum(opp_actions)
            total_rounds = len(opp_actions)
            coop_rate = coop_count / total_rounds if total_rounds > 0 else 0.0
            self.cooperation_rates[opp_idx] = coop_rate
            if coop_rate >= 0.95:
                self.opponent_types[opp_idx] = 'pure_coop'
            elif coop_rate <= 0.1:
                self.opponent_types[opp_idx] = 'defector'
            elif coop_rate >= 0.5:
                if self._looks_like_conditional(history, opp_idx, current_round):
                    self.opponent_types[opp_idx] = 'conditional'
                else:
                    self.opponent_types[opp_idx] = 'tft'
            else:
                self.opponent_types[opp_idx] = 'defector'

    def _looks_like_conditional(self, history: PlayerHistory, opp_idx: int, current_round: int) -> bool:
        """
        Check if opponent shows conditional cooperation pattern.
        Conditional cooperators tend to match previous round's aggregate cooperation.
        """
        if current_round < 2:
            return False
        recent_rounds = min(2, current_round - 1)
        opp_recent = history.opponent_actions[current_round - recent_rounds:current_round, opp_idx]
        if current_round >= 2:
            prev_round_coop = np.sum(history.opponent_actions[current_round - 2, :])
            threshold = self.game_description.n_players / 2
            if opp_recent[-1] and prev_round_coop > threshold:
                return True
        return False

    def _exploit_opponents(self, history: PlayerHistory, current_round: int) -> Action:
        """
        Decide action based on opponent type classification.
        """
        pure_coop_count = sum((1 for t in self.opponent_types.values() if t == 'pure_coop'))
        conditional_count = sum((1 for t in self.opponent_types.values() if t == 'conditional'))
        tft_count = sum((1 for t in self.opponent_types.values() if t == 'tft'))
        defector_count = sum((1 for t in self.opponent_types.values() if t == 'defector'))
        prev_round_coop = np.sum(history.opponent_actions[current_round - 1, :]) if current_round > 0 else 0
        n_opponents = self.game_description.n_players - 1
        if defector_count >= n_opponents * 0.5:
            return Action.D
        if pure_coop_count > 0:
            return Action.D
        if conditional_count > 0 and prev_round_coop > 0:
            return Action.D
        if tft_count > 0:
            if prev_round_coop > n_opponents * 0.6:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_66(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy using conditional free-riding with adaptive thresholds.
    
    Core approach:
    - Round 1: Always defect to gather information
    - Rounds 2-n: Defect by default; only contribute if expected payoff from others' contributions
      exceeds the cost of contribution (1 token)
    - Track individual player cooperation rates to identify reliable cooperators for exploitation
    - Final round: Always defect (no future reputation concerns)
    - Adaptively adjust based on observed contribution patterns and convergence
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_cooperation_rates = np.zeros(self.n_players - 1)
        self.opponent_contribution_counts = np.zeros(self.n_players - 1)
        self.historical_contribution_rates = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if history is not None:
            self._update_opponent_tracking(history, current_round)
        return self._decide_exploitation(history, current_round)

    def _update_opponent_tracking(self, history: PlayerHistory, current_round: int) -> None:
        """Update tracking of individual opponent cooperation rates."""
        if current_round > 0:
            prev_round_opponent_actions = history.opponent_actions[current_round - 1, :]
            for opponent_idx in range(self.n_players - 1):
                if prev_round_opponent_actions[opponent_idx]:
                    self.opponent_contribution_counts[opponent_idx] += 1
            total_opponent_contributions = np.sum(prev_round_opponent_actions)
            overall_contribution_rate = total_opponent_contributions / (self.n_players - 1)
            self.historical_contribution_rates.append(overall_contribution_rate)

    def _decide_exploitation(self, history: PlayerHistory, current_round: int) -> Action:
        """
        Decide whether to contribute based on observed behavior and adaptive thresholds.
        
        Contribution condition: (k/n) * (expected_contributions) + (k/n) > 1
        Simplified: (k/n) * (observed_contributions + 1) > 1
        Which means: observed_contributions > (n/k) - 1
        """
        if history is None or current_round == 0:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[current_round - 1, :]
        observed_contributions = np.sum(prev_round_opponent_actions)
        contribution_threshold = self.n_players / self.k - 1
        if current_round <= 2:
            reliable_cooperators = np.sum(self.opponent_cooperation_rates >= 0.8)
            if reliable_cooperators > 0 and observed_contributions > contribution_threshold:
                return Action.D
            if observed_contributions > contribution_threshold:
                return Action.C
            return Action.D
        if len(self.historical_contribution_rates) >= 2:
            recent_trend = self.historical_contribution_rates[-1] - self.historical_contribution_rates[-2]
            if recent_trend < -0.1:
                return Action.D
        for opponent_idx in range(self.n_players - 1):
            rounds_played = current_round
            if rounds_played > 0:
                coop_rate = self.opponent_cooperation_rates[opponent_idx] / max(1, rounds_played)
                if coop_rate >= 0.8:
                    return Action.D
        if observed_contributions > contribution_threshold:
            return Action.C
        return Action.D

    def _update_opponent_tracking(self, history: PlayerHistory, current_round: int) -> None:
        """Update tracking of individual opponent cooperation rates."""
        if current_round > 0:
            prev_round_opponent_actions = history.opponent_actions[current_round - 1, :]
            for opponent_idx in range(self.n_players - 1):
                if prev_round_opponent_actions[opponent_idx]:
                    self.opponent_contribution_counts[opponent_idx] += 1
                self.opponent_cooperation_rates[opponent_idx] = self.opponent_contribution_counts[opponent_idx] / current_round
            total_opponent_contributions = np.sum(prev_round_opponent_actions)
            overall_contribution_rate = total_opponent_contributions / (self.n_players - 1)
            self.historical_contribution_rates.append(overall_contribution_rate)

class Strategy_EXPLOITATIVE_67(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Extract maximum value from cooperators through
    adaptive defection with selective contribution. Defect by default, contribute only when
    cooperation rate exceeds 75%, and unconditionally defect in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_threshold = 0.75

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_idx = state.round_number - 1
        self_cooperated = history.my_actions[previous_round_idx]
        opponent_cooperated = history.opponent_actions[previous_round_idx, :]
        total_cooperators = int(self_cooperated) + np.sum(opponent_cooperated)
        contribution_rate = total_cooperators / self.game_description.n_players
        if contribution_rate >= self.contribution_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_68(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Systematically defect to extract maximum value
    from cooperative and conditional cooperator opponents while avoiding costs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_opponents = self.game_description.n_players - 1
        rounds_completed = state.round_number
        opponent_coop_rates = []
        for opponent_idx in range(n_opponents):
            cooperations = np.sum(history.opponent_actions[:rounds_completed, opponent_idx])
            coop_rate = cooperations / rounds_completed if rounds_completed > 0 else 0.0
            opponent_coop_rates.append(coop_rate)
        has_reliable_contributors = any((rate >= 0.75 for rate in opponent_coop_rates))
        has_conditional_cooperators = any((0.25 <= rate < 0.75 for rate in opponent_coop_rates))
        has_active_retaliators = any((rate < 0.1 for rate in opponent_coop_rates if rate > 0))
        return Action.D

class Strategy_EXPLOITATIVE_69(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Defects consistently to exploit cooperators and avoid losses to defectors.
    Classifies opponents based on observed history and adapts accordingly,
    but maintains defection as the dominant action throughout all rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_classifications = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            self._classify_opponents(history)
            return Action.D
        return Action.D

    def _classify_opponents(self, history: PlayerHistory) -> None:
        """
        Classify opponents based on their observed history.
        Categories: Pure Cooperators, Conditional Cooperators, Pure Defectors, Erratic/Mixed.
        """
        n_opponents = self.game_description.n_players - 1
        rounds_played = history.my_actions.shape[0]
        for opponent_idx in range(n_opponents):
            if opponent_idx in self.opponent_classifications:
                continue
            opponent_actions = history.opponent_actions[:, opponent_idx]
            cooperation_count = np.sum(opponent_actions)
            defection_count = rounds_played - cooperation_count
            cooperation_rate = cooperation_count / rounds_played if rounds_played > 0 else 0.0
            if cooperation_rate >= 0.9:
                classification = 'pure_cooperator'
            elif cooperation_rate <= 0.1:
                classification = 'pure_defector'
            elif 0.4 <= cooperation_rate <= 0.6:
                classification = 'conditional_cooperator'
            else:
                classification = 'erratic'
            self.opponent_classifications[opponent_idx] = classification

class Strategy_EXPLOITATIVE_70(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defect in round 1 to gather information,
    exploit identified cooperators in middle rounds, and defect universally in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_types = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == r - 1:
            return Action.D
        if history is not None:
            if not self.opponent_types:
                for opp_idx in range(n - 1):
                    round_0_action = history.opponent_actions[0, opp_idx]
                    if round_0_action:
                        self.opponent_types[opp_idx] = 'TYPE_A'
                    else:
                        self.opponent_types[opp_idx] = 'TYPE_B_C'
            if current_round >= 2:
                for opp_idx in range(n - 1):
                    if self.opponent_types[opp_idx] == 'TYPE_B_C':
                        recent_actions = history.opponent_actions[1:current_round, opp_idx]
                        if len(recent_actions) > 0:
                            recent_cooperations = sum(recent_actions)
                            if recent_cooperations > 0:
                                self.opponent_types[opp_idx] = 'TYPE_B'
            type_a_count = sum((1 for t in self.opponent_types.values() if t == 'TYPE_A'))
            if type_a_count > 0:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_71(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    
    Maximizes individual payoff by exploiting cooperative players while avoiding losses to defectors.
    Always defects except potentially cooperates only when beneficial, but the core principle is
    to identify exploitable (cooperative) opponents and defect to extract their contributions.
    
    Decision logic:
    - Round 0: DEFECT (probe opponents)
    - Rounds 1 to r-2: DEFECT if any exploitable opponent exists (cooperation rate > 0.5), else DEFECT
    - Round r-1 (last): DEFECT (no future reputation cost)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        n_opponents = self.n_players - 1
        has_exploitable_opponent = False
        for opponent_idx in range(n_opponents):
            opponent_past_actions = history.opponent_actions[:round_number, opponent_idx]
            cooperations = np.sum(opponent_past_actions)
            rounds_played = round_number
            if rounds_played > 0:
                cooperation_rate = cooperations / rounds_played
                if cooperation_rate > 0.5:
                    has_exploitable_opponent = True
                    break
        return Action.D

class Strategy_EXPLOITATIVE_72(BaseStrategy):
    """
    Exploitative Public Goods Strategy that dynamically shifts between appearing trustworthy
    and extracting maximum value from cooperative players.
    
    Phases:
    1. Reconnaissance (Rounds 1-3): Contribute to identify opponent types
    2. Exploitation (Rounds 4 onwards): Defect against cooperators, mirror conditionals
    3. Final Round: Defect universally for final extraction
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperator_flags = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number <= 2:
            return Action.C
        if self.opponent_cooperator_flags is None:
            self.opponent_cooperator_flags = self._classify_opponents(history)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return self._exploitation_decision(history, state.round_number)

    def _classify_opponents(self, history: PlayerHistory) -> NDArray[np.bool_]:
        """
        Classify each opponent as cooperator (True) or defector (False) based on rounds 0-2.
        A consistent cooperator is one who played C in all reconnaissance rounds.
        """
        n_opponents = self.game_description.n_players - 1
        cooperator_flags = np.ones(n_opponents, dtype=bool)
        for opponent_idx in range(n_opponents):
            for round_idx in range(min(3, history.opponent_actions.shape[0])):
                if not history.opponent_actions[round_idx, opponent_idx]:
                    cooperator_flags[opponent_idx] = False
                    break
        return cooperator_flags

    def _exploitation_decision(self, history: PlayerHistory, current_round: int) -> Action:
        """
        Make exploitation decision based on opponent type classification.
        """
        n_opponents = self.game_description.n_players - 1
        last_round_idx = current_round - 1
        my_action = Action.D
        pure_cooperators = np.sum(self.opponent_cooperator_flags)
        if pure_cooperators == 0:
            last_round_cooperations = np.sum(history.opponent_actions[last_round_idx, :])
            cooperation_rate = last_round_cooperations / n_opponents
            if cooperation_rate >= 0.5:
                my_action = Action.C
        else:
            my_action = Action.D
        avg_contribution_per_round = np.mean(np.sum(history.opponent_actions, axis=1))
        min_viable_return = self.game_description.k / self.game_description.n_players
        if avg_contribution_per_round < min_viable_return:
            my_action = Action.D
        return my_action

class Strategy_EXPLOITATIVE_73(BaseStrategy):
    """
    Exploitative Public Goods Strategy that maximizes personal payoff through
    selective defection, exploiting conditional cooperators while free-riding
    on public goods contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        opponent_cooperation_rates = self._calculate_cooperation_rates(history)
        reliable_cooperators = sum((1 for rate in opponent_cooperation_rates if rate >= 0.6))
        if reliable_cooperators > len(opponent_cooperation_rates) / 2.0:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rates(self, history: PlayerHistory) -> list[float]:
        """
        Calculate the historical cooperation rate for each opponent.
        Returns a list of cooperation rates (0.0 to 1.0) indexed by opponent.
        """
        n_opponents = self.n_players - 1
        cooperation_rates = []
        for opponent_idx in range(n_opponents):
            opponent_contributions = history.opponent_actions[:, opponent_idx]
            if len(opponent_contributions) == 0:
                cooperation_rates.append(0.0)
            else:
                rate = float(np.sum(opponent_contributions)) / float(len(opponent_contributions))
                cooperation_rates.append(rate)
        return cooperation_rates

class Strategy_EXPLOITATIVE_74(BaseStrategy):
    """
    Exploitative Public Goods Strategy that identifies player types and extracts maximum value.
    
    Core approach:
    - Round 1: Defect to identify unconditional cooperators
    - Rounds 2 to r-1: Exploit identified player types (defect against unconditional cooperators,
      strategically defect against conditional cooperators, defect against defectors)
    - Final round: Defect unconditionally
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self._player_types = None

    def _classify_player_types(self, history: PlayerHistory) -> dict:
        """
        Classify each opponent as: 'unconditional_cooperator', 'conditional_cooperator', or 'defector'
        Based on their history of actions.
        """
        types = {}
        n_opponents = self.n_players - 1
        for opponent_idx in range(n_opponents):
            actions = history.opponent_actions[:, opponent_idx]
            if len(actions) == 0:
                types[opponent_idx] = 'unknown'
                continue
            cooperated_round_0 = actions[0]
            if cooperated_round_0:
                if len(actions) > 1:
                    if np.all(actions[1:]):
                        types[opponent_idx] = 'unconditional_cooperator'
                    else:
                        types[opponent_idx] = 'conditional_cooperator'
                else:
                    types[opponent_idx] = 'unconditional_cooperator'
            else:
                types[opponent_idx] = 'defector'
        return types

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n_rounds = self.n_rounds
        if round_number == 0:
            return Action.D
        if round_number == n_rounds - 1:
            return Action.D
        if history is not None:
            types = self._classify_player_types(history)
            prev_round_idx = round_number - 1
            if prev_round_idx >= 0:
                prev_cooperators = np.sum(history.opponent_actions[prev_round_idx, :])
            else:
                prev_cooperators = 0
            has_unconditional = any((t == 'unconditional_cooperator' for t in types.values()))
            if has_unconditional:
                return Action.D
            conditional_count = sum((1 for t in types.values() if t == 'conditional_cooperator'))
            if conditional_count > 0:
                if prev_cooperators > 0:
                    return Action.D
                else:
                    return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_75(BaseStrategy):
    """
    Exploitative Public Goods Strategy that identifies and exploits different opponent types.
    
    Phase 1 (Rounds 0-2): Information gathering via defection
    Phase 2 (Rounds 3 to r-2): Targeted exploitation based on opponent classification
    Phase 3 (Round r-1): Final defection for maximum payoff
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_types = {}
        self.opponent_cooperation_counts = {}
        self.opponent_seen_rounds = {}
        self.cooperation_history = []
        self.last_round_cooperation_count = 0
        self.threshold_coop_rate = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round < 3:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.D
        self._classify_opponents(history, current_round)
        if current_round > 0:
            last_round_coop = np.sum(history.opponent_actions[current_round - 1, :])
            self.last_round_cooperation_count = last_round_coop
            coop_rate = last_round_coop / self.n_players
            self.cooperation_history.append(coop_rate)
        if len(self.cooperation_history) > 0:
            avg_coop_rate = np.mean(self.cooperation_history)
            if avg_coop_rate < 0.2:
                return Action.D
        unconditional_count = sum((1 for t in self.opponent_types.values() if t == 'unconditional'))
        conditional_count = sum((1 for t in self.opponent_types.values() if t == 'conditional'))
        if self.last_round_cooperation_count > self.n_players * 0.5:
            return Action.D
        if conditional_count > 0 and self.last_round_cooperation_count > 0:
            if self.last_round_cooperation_count / self.n_players >= self.threshold_coop_rate:
                return Action.C
        return Action.D

    def _classify_opponents(self, history: PlayerHistory, current_round: int) -> None:
        """
        Classify each opponent as unconditional cooperator, conditional cooperator, or defector.
        Based on their behavior in rounds 0 through current_round-1.
        """
        n_opponents = self.n_players - 1
        for opponent_idx in range(n_opponents):
            if opponent_idx not in self.opponent_types:
                self.opponent_cooperation_counts[opponent_idx] = 0
                self.opponent_seen_rounds[opponent_idx] = 0
            for round_idx in range(current_round):
                if history.opponent_actions[round_idx, opponent_idx]:
                    self.opponent_cooperation_counts[opponent_idx] += 1
            self.opponent_seen_rounds[opponent_idx] = current_round
            coop_count = self.opponent_cooperation_counts[opponent_idx]
            seen_rounds = self.opponent_seen_rounds[opponent_idx]
            if seen_rounds == 0:
                continue
            coop_rate = coop_count / seen_rounds
            if coop_rate >= 0.8:
                self.opponent_types[opponent_idx] = 'unconditional'
            elif coop_rate <= 0.2:
                self.opponent_types[opponent_idx] = 'defector'
            else:
                self.opponent_types[opponent_idx] = 'conditional'

class Strategy_EXPLOITATIVE_76(BaseStrategy):
    """
    Exploitative Public Goods Strategy that free-rides on cooperative players
    while occasionally mimicking cooperation to sustain their contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.reliable_cooperators = set()
        self.last_cooperators = set()
        self.mimicry_counter = 0
        self.contribution_history = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if state.round_number == 0:
            return Action.D
        if r <= 3:
            return Action.D
        if k <= 1.2:
            return Action.D
        if state.round_number == r - 1:
            return Action.D
        self._update_cooperator_tracking(history, state.round_number)
        last_round_idx = state.round_number - 1
        last_round_cooperators = set((i for i in range(n - 1) if history.opponent_actions[last_round_idx, i]))
        if not self.reliable_cooperators and (not last_round_cooperators):
            return Action.D
        if 2 <= state.round_number <= r - 2:
            mimicry_frequency = 4
            if len(self.reliable_cooperators) > 0:
                mimicry_frequency = 3
            if self.mimicry_counter % mimicry_frequency == 0 and last_round_cooperators:
                self.mimicry_counter += 1
                return Action.C
            self.mimicry_counter += 1
        return Action.D

    def _update_cooperator_tracking(self, history: PlayerHistory, current_round: int) -> None:
        """Track which opponents show reliable cooperation patterns."""
        n = self.game_description.n_players - 1
        rounds_played = current_round
        for opponent_idx in range(n):
            if opponent_idx not in self.contribution_history:
                self.contribution_history[opponent_idx] = 0
            cooperations = int(np.sum(history.opponent_actions[:current_round, opponent_idx]))
            self.contribution_history[opponent_idx] = cooperations
            if rounds_played > 0:
                coop_rate = cooperations / rounds_played
                if coop_rate >= 0.5:
                    self.reliable_cooperators.add(opponent_idx)
                else:
                    self.reliable_cooperators.discard(opponent_idx)
            if current_round >= 2:
                recent_streak = history.opponent_actions[current_round - 1, opponent_idx] and history.opponent_actions[current_round - 2, opponent_idx]
                if recent_streak:
                    self.reliable_cooperators.add(opponent_idx)

class Strategy_EXPLOITATIVE_77(BaseStrategy):
    """
    Exploitative Public Goods Strategy that free-rides on cooperative players.
    
    Gathers information in early rounds, then exploits the public good by defecting
    whenever others are contributing, while always defecting when cooperation is low.
    Unconditionally defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num < 2:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        prev_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_cooperators = np.sum(opponent_actions_prev)
        num_opponents = self.n_players - 1
        if num_opponents == 0:
            return Action.D
        avg_contribution_rate = num_cooperators / num_opponents
        if avg_contribution_rate >= 0.5:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_78(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy using adaptive exploitation through selective defection.
    
    Defects by default, exploiting cooperative players while monitoring opponent behavior to classify
    them as Unconditional Cooperators, Conditional Cooperators, or Defectors. Uses rare strategic
    cooperation to reset expectations and trigger higher future contributions to exploit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_cooperation_counts = np.zeros(self.n_players - 1)
        self.opponent_total_rounds = np.zeros(self.n_players - 1)
        self.my_defection_count = 0
        self.my_total_actions = 0
        self.rounds_since_cooperation = 0
        self.consecutive_high_contribution_rounds = 0
        self.last_round_total_contributions = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            self.my_total_actions += 1
            self.my_defection_count += 1
            self.rounds_since_cooperation += 1
            return Action.D
        self._update_opponent_profiles(history)
        self.my_total_actions += 1
        if round_num == self.n_rounds - 1:
            self.my_defection_count += 1
            self.rounds_since_cooperation += 1
            return Action.D
        return self._adaptive_decision(history, round_num)

    def _update_opponent_profiles(self, history: PlayerHistory) -> None:
        """Update opponent cooperation counts from the last round."""
        if history is None or len(history.opponent_actions) == 0:
            return
        last_round_idx = len(history.opponent_actions) - 1
        for opponent_idx in range(self.n_players - 1):
            cooperated = history.opponent_actions[last_round_idx, opponent_idx]
            if cooperated:
                self.opponent_cooperation_counts[opponent_idx] += 1
            self.opponent_total_rounds[opponent_idx] += 1
        self.last_round_total_contributions = np.sum(history.opponent_actions[last_round_idx, :])

    def _get_opponent_classification(self, opponent_idx: int) -> str:
        """Classify opponent based on cooperation frequency."""
        if self.opponent_total_rounds[opponent_idx] == 0:
            return 'unknown'
        coop_rate = self.opponent_cooperation_counts[opponent_idx] / self.opponent_total_rounds[opponent_idx]
        if coop_rate > 0.8:
            return 'unconditional_cooperator'
        elif coop_rate >= 0.3:
            return 'conditional_cooperator'
        else:
            return 'defector'

    def _adaptive_decision(self, history: PlayerHistory, round_num: int) -> Action:
        """Make adaptive decision based on opponent profiles and game state."""
        if self._should_rare_cooperate(history, round_num):
            self.rounds_since_cooperation = 0
            self.my_total_actions += 1
            return Action.C
        self.my_defection_count += 1
        self.rounds_since_cooperation += 1
        return Action.D

    def _should_rare_cooperate(self, history: PlayerHistory, round_num: int) -> bool:
        """Determine if rare cooperation trigger should fire."""
        if round_num >= self.n_rounds - 2:
            return False
        if self.rounds_since_cooperation < 3:
            return False
        threshold = 0.6
        contribution_threshold = self.k / self.n_players * (self.n_players - 1) * threshold
        if self.last_round_total_contributions > contribution_threshold:
            if self._detect_cooperation_spike(history):
                return True
        return False

    def _detect_cooperation_spike(self, history: PlayerHistory) -> bool:
        """Detect if cooperation rate is spiking (>70% across all players for recent rounds)."""
        if len(history.opponent_actions) < 2:
            return False
        recent_rounds = history.opponent_actions[-2:, :]
        coop_rates = []
        for round_idx in range(len(recent_rounds)):
            total_coop = np.sum(recent_rounds[round_idx, :])
            coop_rate = total_coop / (self.n_players - 1)
            coop_rates.append(coop_rate)
        return all((rate > 0.7 for rate in coop_rates))

class Strategy_EXPLOITATIVE_79(BaseStrategy):
    """
    Exploitative Public Goods Strategy that maximizes personal payoff by free-riding
    on others' cooperation while defecting whenever possible. Uses tier-based response
    to opponent cooperation rates with unconditional defection in final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_opponents = self.game_description.n_players - 1
        cooperation_rates = np.zeros(n_opponents)
        for opponent_idx in range(n_opponents):
            total_cooperations = np.sum(history.opponent_actions[:state.round_number, opponent_idx])
            cooperation_rates[opponent_idx] = total_cooperations / state.round_number
        max_cooperation_rate = np.max(cooperation_rates)
        min_cooperation_rate = np.min(cooperation_rates)
        if max_cooperation_rate >= 0.7:
            return Action.D
        if min_cooperation_rate >= 0.3:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_80(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Adaptive defection with selective exploitation
    of high-contributing players to maximize free-riding payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_contribution_rates = {}
        self.cooperation_counter = {}
        self.last_pool_contribution = 0
        self.pool_rescue_active = False
        self.pool_rescue_rounds_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        k = self.game_description.k
        if round_num <= 2:
            return Action.D
        if round_num == 3 and (not self.opponent_contribution_rates):
            self._initialize_opponent_tracking(history, n_players)
        if round_num < n_rounds - 2:
            return self._exploitation_decision(history, n_players)
        return Action.D

    def _initialize_opponent_tracking(self, history: PlayerHistory, n_players: int) -> None:
        """Initialize contribution rate tracking for all opponents."""
        for opponent_idx in range(n_players - 1):
            contributions = np.sum(history.opponent_actions[:, opponent_idx])
            contribution_rate = contributions / (history.opponent_actions.shape[0] + 1e-10)
            self.opponent_contribution_rates[opponent_idx] = contribution_rate
            self.cooperation_counter[opponent_idx] = 0

    def _update_opponent_tracking(self, history: PlayerHistory, n_players: int) -> None:
        """Update contribution rates based on latest history."""
        for opponent_idx in range(n_players - 1):
            contributions = np.sum(history.opponent_actions[:, opponent_idx])
            total_rounds = history.opponent_actions.shape[0]
            contribution_rate = contributions / (total_rounds + 1e-10)
            self.opponent_contribution_rates[opponent_idx] = contribution_rate

    def _exploitation_decision(self, history: PlayerHistory, n_players: int) -> Action:
        """Apply exploitation strategy based on opponent contribution rates."""
        round_num = history.my_actions.shape[0]
        n_rounds = self.game_description.n_rounds
        self._update_opponent_tracking(history, n_players)
        current_pool = np.sum(history.opponent_actions[-1, :])
        if current_pool < (n_players - 1) * 0.4:
            self.pool_rescue_active = True
            self.pool_rescue_rounds_remaining = 2
        if self.pool_rescue_active:
            self.pool_rescue_rounds_remaining -= 1
            if self.pool_rescue_rounds_remaining < 0:
                self.pool_rescue_active = False
        high_contributors = [idx for idx, rate in self.opponent_contribution_rates.items() if rate >= 0.5]
        if not high_contributors:
            return Action.D
        if self.pool_rescue_active:
            cooperation_threshold = 0.4
        else:
            cooperation_threshold = 0.25
        should_cooperate = random.random() < cooperation_threshold
        if should_cooperate:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_81(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Always defect to extract maximum value from contributors
    while avoiding losses from unilateral cooperation. Defection is weakly dominant across all
    opponent types and provides consistent exploitation of cooperative players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_82(BaseStrategy):
    """
    Adaptive Leech: An exploitative public goods strategy that free-rides on cooperators
    while adapting to cooperation rates. Defects in round 1 to probe, uses cooperation
    rate thresholds in middle rounds, and always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        prev_round_idx = current_round - 1
        cooperators_prev = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        coop_rate = cooperators_prev / n
        self.cooperation_history.append(coop_rate)
        if current_round == r - 1:
            return Action.D
        if len(self.cooperation_history) >= 2:
            avg_coop_rate = np.mean(self.cooperation_history[-2:])
        else:
            avg_coop_rate = coop_rate
        threshold = 1.0 / k
        rounds_remaining = r - current_round
        if avg_coop_rate > threshold:
            return Action.D
        elif avg_coop_rate <= threshold and rounds_remaining > 2:
            return Action.D
        elif avg_coop_rate <= threshold and rounds_remaining <= 2:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_83(BaseStrategy):
    """
    Exploitative Public Goods Strategy
    
    Exploits asymmetry between private and public information. Defects in round 1 to gather intelligence,
    then defects throughout rounds 2 to r-2 based on opponent cooperation ratios. Exploits terminal rounds
    (r-1 and r) by defecting when future punishment is impossible.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        avg_cooperation_ratio = self._compute_avg_cooperation_ratio(history, round_num)
        threshold = (self.k - 1) / self.k
        return Action.D

    def _compute_avg_cooperation_ratio(self, history: PlayerHistory, current_round: int) -> float:
        """
        Compute the average cooperation ratio across all opponents.
        cooperation_ratio for opponent j = (total cooperations by j in rounds 0 to current_round-1) / current_round
        """
        if current_round == 0:
            return 0.0
        past_actions = history.opponent_actions[:current_round, :]
        cooperations_per_opponent = np.sum(past_actions, axis=0)
        cooperation_ratios = cooperations_per_opponent / current_round
        avg_ratio = np.mean(cooperation_ratios) if cooperation_ratios.size > 0 else 0.0
        return float(avg_ratio)

class Strategy_EXPLOITATIVE_84(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Conditional free-riding with adaptive exploitation.
    
    Phase 1 (Rounds 0-1): Defect to assess opponent cooperation patterns.
    Phase 2 (Rounds 2 to r-3): Adaptive defection based on observed contribution rates.
    Phase 3 (Final 2 rounds): Defect to maximize endgame payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.exploitation_threshold = (self.k - 1) / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round < 2:
            return Action.D
        if current_round >= self.n_rounds - 2:
            return Action.D
        if history is None or len(history.opponent_actions) == 0:
            return Action.D
        total_opponent_cooperations = np.sum(history.opponent_actions)
        total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_opponent_actions == 0:
            return Action.D
        avg_contribution_rate = total_opponent_cooperations / total_opponent_actions
        return Action.D

class Strategy_EXPLOITATIVE_85(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Maximize personal payoff by free-riding on others' 
    contributions while minimizing own contributions. Always defect except when necessary, 
    exploiting the asymmetry between contribution cost and benefit from multiplier.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        total_rounds_elapsed = state.round_number
        total_cooperators = np.sum(history.opponent_actions[:state.round_number, :])
        total_possible_contributions = total_rounds_elapsed * self.game_description.n_players
        if total_possible_contributions == 0:
            coop_rate = 0.0
        else:
            coop_rate = total_cooperators / total_possible_contributions
        if coop_rate > self.cooperation_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_86(BaseStrategy):
    """
    Selective Parasitism: Exploitative strategy that defects to harvest cooperation from others.
    Tracks opponent cooperation rates and adapts exploitation based on multiplier strength,
    cooperative target availability, and consistency of defection patterns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defections = 0
            return Action.D
        current_round = state.round_number
        n_opponents = self.n_players - 1
        opponent_cooperation_rates = self._calculate_opponent_cooperation_rates(history)
        if current_round == self.n_rounds - 1:
            return Action.D
        if self.n_players <= 3:
            return Action.D
        if all((rate < 0.4 for rate in opponent_cooperation_rates)):
            self.consecutive_defections += 1
            return Action.D
        cooperative_targets = sum((1 for rate in opponent_cooperation_rates if rate > 0.5))
        if cooperative_targets < 2:
            self.consecutive_defections += 1
            return Action.D
        if self.k / self.n_players < 0.5:
            self.consecutive_defections += 1
            return Action.D
        avg_cooperation = np.mean(opponent_cooperation_rates) if len(opponent_cooperation_rates) > 0 else 0.0
        my_defection_count = np.sum(~history.my_actions)
        if avg_cooperation > 0.6 and my_defection_count < self.n_rounds / 2:
            self.consecutive_defections += 1
            return Action.D
        if self.consecutive_defections >= 3:
            if avg_cooperation >= 0.5:
                self.consecutive_defections += 1
                return Action.D
        if current_round >= 2:
            recent_window = min(2, current_round)
            recent_rates = []
            for opp_idx in range(n_opponents):
                recent_cooperations = np.sum(history.opponent_actions[-recent_window:, opp_idx])
                recent_rate = recent_cooperations / recent_window
                recent_rates.append(recent_rate)
            avg_recent = np.mean(recent_rates) if recent_rates else 0.0
            avg_all = avg_cooperation
            if avg_recent < avg_all - 0.15:
                self.consecutive_defections += 1
                return Action.D
        if max(opponent_cooperation_rates) >= 1.0 and cooperative_targets >= 1:
            defections_received = np.sum(~history.opponent_actions)
            if defections_received <= current_round * 0.3:
                self.consecutive_defections += 1
                return Action.D
        self.consecutive_defections += 1
        return Action.D

    def _calculate_opponent_cooperation_rates(self, history: PlayerHistory) -> list:
        """
        Calculate the cooperation rate for each opponent based on history so far.
        Returns a list of cooperation rates (0.0 to 1.0) for each opponent.
        """
        n_opponents = self.n_players - 1
        cooperation_rates = []
        if history.opponent_actions.shape[0] == 0:
            return [0.0] * n_opponents
        rounds_played = history.opponent_actions.shape[0]
        for opp_idx in range(n_opponents):
            cooperations = np.sum(history.opponent_actions[:, opp_idx])
            if rounds_played > 0:
                rate = float(cooperations) / float(rounds_played)
            else:
                rate = 0.0
            cooperation_rates.append(rate)
        return cooperation_rates

class Strategy_EXPLOITATIVE_87(BaseStrategy):
    """
    Exploitative strategy for N-player public goods game.
    
    Systematically exploits high contributors by defecting against them,
    adapting defection probability based on observed contribution rates,
    and always defecting in the final round and against confirmed defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_contribution_rates = np.zeros(game_description.n_players - 1)
        self.opponent_round_counts = np.zeros(game_description.n_players - 1)
        self.mutual_defection_confirmed = np.zeros(game_description.n_players - 1, dtype=bool)
        self.last_round_opponent_actions = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self._update_opponent_profiles(history, state.round_number)
        defect_score = self._calculate_defect_score(history, state.round_number)
        if random.random() < defect_score:
            return Action.D
        return Action.C

    def _update_opponent_profiles(self, history: PlayerHistory, current_round: int) -> None:
        """
        Update opponent contribution rates and track behavioral changes.
        Uses rolling window of last 5 rounds for detecting strategy shifts.
        """
        window_size = min(5, current_round)
        window_start = max(0, current_round - window_size)
        for opponent_idx in range(self.game_description.n_players - 1):
            cooperations = np.sum(history.opponent_actions[window_start:current_round, opponent_idx])
            rounds_observed = current_round - window_start
            if rounds_observed > 0:
                contribution_rate = cooperations / rounds_observed
                self.opponent_contribution_rates[opponent_idx] = contribution_rate
                self.opponent_round_counts[opponent_idx] = rounds_observed
            my_last_action = history.my_actions[current_round - 1]
            opponent_last_action = history.opponent_actions[current_round - 1, opponent_idx]
            if not my_last_action and (not opponent_last_action):
                self.mutual_defection_confirmed[opponent_idx] = True

    def _calculate_defect_score(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate average defection probability across all opponents.
        
        Classification tiers:
        - High Contributors (≥70%): Always defect (probability 1.0)
        - Moderate Contributors (30-69%): Defect proportionally to contribution rate
        - Low Contributors (<30%): Defect slightly more than they cooperate
        - Confirmed mutual defectors: Always defect
        """
        defect_probabilities = []
        for opponent_idx in range(self.game_description.n_players - 1):
            contribution_rate = self.opponent_contribution_rates[opponent_idx]
            if self.mutual_defection_confirmed[opponent_idx]:
                defect_probabilities.append(1.0)
                continue
            if contribution_rate >= 0.7:
                defect_probabilities.append(1.0)
            elif contribution_rate >= 0.3:
                defect_probabilities.append(contribution_rate)
            else:
                defect_probabilities.append(min(0.5, contribution_rate + 0.2))
        if defect_probabilities:
            return np.mean(defect_probabilities)
        return 0.5

class Strategy_EXPLOITATIVE_88(BaseStrategy):
    """
    Exploitative strategy for repeated public goods game.
    
    Probes with defection early, then adaptively exploits cooperators while
    defecting against defectors. Ends with unconditional defection in final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.opponent_cooperation_rates = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num < 3:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        opponent_cooperation_rates = self._calculate_opponent_cooperation_rates(history)
        if len(opponent_cooperation_rates) > 0:
            avg_cooperation_rate = np.mean(opponent_cooperation_rates)
        else:
            avg_cooperation_rate = 0.0
        if avg_cooperation_rate >= 0.75:
            coop_prob = min(0.4, avg_cooperation_rate / 2.0)
            return Action.C if random.random() < coop_prob else Action.D
        elif avg_cooperation_rate >= 0.25:
            return Action.D
        else:
            return Action.D

    def _calculate_opponent_cooperation_rates(self, history: PlayerHistory) -> NDArray[np.float64]:
        """
        Calculate the cooperation rate for each opponent up to the current round.
        
        Returns an array of cooperation rates, one per opponent.
        """
        if history.opponent_actions.size == 0:
            return np.array([])
        n_rounds_so_far = history.opponent_actions.shape[0]
        n_opponents = history.opponent_actions.shape[1]
        if n_rounds_so_far == 0 or n_opponents == 0:
            return np.array([])
        cooperation_counts = np.sum(history.opponent_actions, axis=0)
        cooperation_rates = cooperation_counts / n_rounds_so_far
        return cooperation_rates

class Strategy_EXPLOITATIVE_89(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Identifies and exploits cooperative players
    while avoiding retaliation from conditional cooperators and defectors.
    
    Phase 1 (Rounds 0-2): Defect to classify opponent types
    Phase 2 (Rounds 3+): Exploit Always Cooperators, defect against others
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_types = [0] * (game_description.n_players - 1)
        self.opponent_coop_history = [[] for _ in range(game_description.n_players - 1)]

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number <= 2:
            self._update_opponent_classification(history, state.round_number)
            return Action.D
        self._update_opponent_classification(history, state.round_number)
        return Action.D

    def _update_opponent_classification(self, history: PlayerHistory, current_round: int) -> None:
        """Update opponent type classifications based on observed behavior."""
        if current_round == 0:
            return
        prev_round_idx = current_round - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        for opp_idx, opp_action in enumerate(opponent_prev_actions):
            self.opponent_coop_history[opp_idx].append(bool(opp_action))
            if self.opponent_types[opp_idx] == 3:
                continue
            coop_count = sum(self.opponent_coop_history[opp_idx])
            rounds_observed = len(self.opponent_coop_history[opp_idx])
            if rounds_observed >= 3 and coop_count == rounds_observed:
                self.opponent_types[opp_idx] = 1
            elif rounds_observed >= 2 and coop_count == 0:
                self.opponent_types[opp_idx] = 3
            elif rounds_observed >= 2 and coop_count < rounds_observed and (coop_count > 0):
                self.opponent_types[opp_idx] = 2
            elif rounds_observed >= 3 and coop_count == rounds_observed:
                self.opponent_types[opp_idx] = 1

class Strategy_EXPLOITATIVE_90(BaseStrategy):
    """
    Exploitative strategy for repeated public goods game.
    
    Phases:
    1. Information Gathering (first ~10% of rounds): Defect to identify cooperators
    2. Exploitation (middle rounds): Defect against identified cooperators, track opponent types
    3. Endgame (last 2 rounds): Defect to capture final value
    
    Core principle: Exploit predictable cooperation patterns while avoiding punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.info_gathering_rounds = max(3, math.ceil(self.n_rounds * 0.1))
        self.endgame_rounds = 2
        self.opponent_cooperation_counts = None
        self.opponent_total_rounds_seen = 0

    def _classify_opponent(self, opponent_idx: int, rounds_observed: int) -> str:
        """
        Classify an opponent based on their historical cooperation rate.
        Returns: "unconditional_cooperator", "defector", or "conditional_cooperator"
        """
        if rounds_observed == 0:
            return 'unknown'
        coop_count = self.opponent_cooperation_counts[opponent_idx]
        coop_rate = coop_count / rounds_observed
        if coop_rate > 0.8:
            return 'unconditional_cooperator'
        elif coop_rate < 0.2:
            return 'defector'
        else:
            return 'conditional_cooperator'

    def _should_contribute(self, state: GameState, history: PlayerHistory) -> bool:
        """
        Determine if contribution is strategically beneficial.
        Defect by default; only contribute in rare cases.
        """
        if state.round_number < self.info_gathering_rounds:
            return False
        if state.round_number >= self.n_rounds - self.endgame_rounds:
            return False
        if state.round_number > 0:
            recent_round_idx = state.round_number - 1
            others_contributed = np.sum(history.opponent_actions[recent_round_idx, :])
            threshold = self.n_players / self.k
            return False
        return False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if self.opponent_cooperation_counts is None:
            self.opponent_cooperation_counts = np.zeros(self.n_players - 1, dtype=np.int32)
        if state.round_number == 0:
            return Action.D
        if history is not None:
            recent_round_idx = state.round_number - 1
            for opp_idx in range(self.n_players - 1):
                if history.opponent_actions[recent_round_idx, opp_idx]:
                    self.opponent_cooperation_counts[opp_idx] += 1
            self.opponent_total_rounds_seen = state.round_number
        if self._should_contribute(state, history):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_91(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Adaptive defection with selective parasitism.
    
    Defaults to defection while opportunistically exploiting cooperative players.
    Tracks opponent contribution patterns and switches between exploitation and 
    strategic temporary cooperation based on payoff calculations and remaining rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_coop_rate = np.zeros(self.n_players - 1)
        self.opponent_round_count = np.zeros(self.n_players - 1)
        self.consecutive_defections = np.zeros(self.n_players - 1)
        self.contribution_history = []
        self.max_history_length = 5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            if self.k / self.n_players > 0.5 and self.n_players <= 4:
                return Action.C
            return Action.D
        self._update_opponent_models(history)
        estimated_group_contribution = self._estimate_group_contribution()
        if round_num >= self.n_rounds - 2:
            return Action.D
        remaining_rounds = self.n_rounds - round_num
        defection_threshold = self.n_players / self.k
        if estimated_group_contribution > defection_threshold:
            return Action.D
        if remaining_rounds >= 4:
            if self._should_contribute_strategically(estimated_group_contribution, history):
                return Action.C
        return Action.D

    def _update_opponent_models(self, history: PlayerHistory) -> None:
        """Update tracking of opponent contribution patterns."""
        last_round_idx = history.my_actions.shape[0] - 1
        for opp_idx in range(self.n_players - 1):
            self.opponent_round_count[opp_idx] += 1
            last_action = history.opponent_actions[last_round_idx, opp_idx]
            self.opponent_coop_rate[opp_idx] += float(last_action)
            if last_action:
                self.consecutive_defections[opp_idx] = 0
            else:
                self.consecutive_defections[opp_idx] += 1

    def _estimate_group_contribution(self) -> float:
        """Estimate total group contributions for next round using moving average."""
        if len(self.contribution_history) == 0:
            return 0.0
        avg_contributions = np.mean(self.contribution_history[-self.max_history_length:])
        return avg_contributions

    def _update_contribution_history(self, history: PlayerHistory) -> None:
        """Track historical group contributions."""
        last_round_idx = history.my_actions.shape[0] - 1
        my_action = history.my_actions[last_round_idx]
        opponent_actions = history.opponent_actions[last_round_idx, :]
        total_cooperators = float(my_action) + np.sum(opponent_actions)
        self.contribution_history.append(total_cooperators)
        if len(self.contribution_history) > self.max_history_length:
            self.contribution_history.pop(0)

    def _should_contribute_strategically(self, estimated_contribution: float, history: PlayerHistory) -> None:
        """Determine if strategic contribution is justified."""
        self._update_contribution_history(history)
        if estimated_contribution > self.n_players * 0.6:
            return False
        reliable_contributors = self._identify_reliable_contributors()
        if len(reliable_contributors) == 0:
            return False
        avg_defections_against_contributors = np.mean(self.consecutive_defections[reliable_contributors])
        if avg_defections_against_contributors >= 2:
            return False
        contribution_trend = self._get_contribution_trend()
        if contribution_trend < 0 and estimated_contribution < self.n_players * 0.4:
            return False
        if self.k > self.n_players * 0.8:
            return True
        return False

    def _identify_reliable_contributors(self) -> NDArray:
        """Identify opponents who contribute in ≥60% of rounds."""
        reliable = []
        for opp_idx in range(self.n_players - 1):
            if self.opponent_round_count[opp_idx] > 0:
                coop_rate = self.opponent_coop_rate[opp_idx] / self.opponent_round_count[opp_idx]
                if coop_rate >= 0.6:
                    reliable.append(opp_idx)
        return np.array(reliable, dtype=int)

    def _get_contribution_trend(self) -> float:
        """Calculate trend in group contributions (positive = increasing)."""
        if len(self.contribution_history) < 2:
            return 0.0
        recent = self.contribution_history[-2:]
        return recent[-1] - recent[0]

class Strategy_EXPLOITATIVE_92(BaseStrategy):
    """
    Exploitative Public Goods Strategy that systematically free-rides on cooperators
    while defecting against defectors. Classifies opponents by cooperation rate and
    exploits predictable patterns, always defecting in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_opponents = self.game_description.n_players - 1
        cooperation_rates = np.zeros(n_opponents)
        for opponent_idx in range(n_opponents):
            opponent_actions = history.opponent_actions[:, opponent_idx]
            n_rounds_so_far = len(opponent_actions)
            if n_rounds_so_far > 0:
                cooperation_rates[opponent_idx] = np.sum(opponent_actions) / n_rounds_so_far
            else:
                cooperation_rates[opponent_idx] = 0.0
        has_cooperators = False
        for rate in cooperation_rates:
            if rate >= 0.4:
                has_cooperators = True
                break
        return Action.D

class Strategy_EXPLOITATIVE_93(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Exploits others' contributions by free-riding when beneficial while maintaining
    just enough cooperation to prevent collapse. Always defects in the final round.
    Adapts cooperation threshold based on the multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        k_ratio = self.k / self.n_players
        if k_ratio >= 0.9:
            self.cooperation_threshold = 0.7
        elif k_ratio <= 0.25:
            self.cooperation_threshold = 0.5
        else:
            self.cooperation_threshold = 0.6

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        previous_round_idx = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
        cooperators_count = np.sum(opponent_actions_prev)
        cooperation_rate = cooperators_count / (self.n_players - 1)
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_94(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Defects in round 1 to identify cooperators, then adaptively exploits by:
    - Always defecting in rounds 2 through r (never reciprocating)
    - Freeloading when others contribute
    - Minimizing losses when contributions collapse
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_95(BaseStrategy):
    """
    Exploitative strategy for repeated public goods game.
    
    Systematically defects by default while identifying and exploiting stable contributors.
    Uses a rolling window of recent behavior to classify opponents and adapt accordingly.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = {}
        self.window_size = 5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_opponents = self.game_description.n_players - 1
        cooperation_rates = self._calculate_cooperation_rates(history)
        rounds_to_check = min(2, state.round_number)
        total_defections = 0
        total_possible = 0
        for round_idx in range(rounds_to_check):
            defections = n_opponents - sum(history.opponent_actions[round_idx, :])
            total_defections += defections
            total_possible += n_opponents
        if total_possible > 0 and total_defections / total_possible > 0.5:
            return Action.D
        for opponent_idx, cooperation_rate in cooperation_rates.items():
            if opponent_idx not in self.opponent_cooperation_rates:
                self.opponent_cooperation_rates[opponent_idx] = cooperation_rate
            else:
                self.opponent_cooperation_rates[opponent_idx] = cooperation_rate
        return Action.D

    def _calculate_cooperation_rates(self, history: PlayerHistory) -> dict:
        """
        Calculate cooperation rates for each opponent using a rolling window.
        
        Returns:
            Dictionary mapping opponent_index -> cooperation_rate (0.0 to 1.0)
        """
        cooperation_rates = {}
        n_opponents = self.game_description.n_players - 1
        rounds_played = history.opponent_actions.shape[0]
        window_start = max(0, rounds_played - self.window_size)
        for opponent_idx in range(n_opponents):
            if rounds_played == 0:
                cooperation_rates[opponent_idx] = 0.0
            else:
                window_cooperations = sum(history.opponent_actions[window_start:rounds_played, opponent_idx])
                window_length = rounds_played - window_start
                cooperation_rates[opponent_idx] = window_cooperations / window_length if window_length > 0 else 0.0
        return cooperation_rates

class Strategy_EXPLOITATIVE_96(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defect unconditionally while using Round 1
    to identify and classify opponents as exploitable (cooperators) or strategic (defectors).
    Extracts maximum value by free-riding on others' contributions without reciprocating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploitable_opponents = set()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            if state.round_number == 1:
                first_round_opponent_actions = history.opponent_actions[0, :]
                self.exploitable_opponents = set()
                for opponent_idx in range(len(first_round_opponent_actions)):
                    if first_round_opponent_actions[opponent_idx]:
                        self.exploitable_opponents.add(opponent_idx)
            current_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            still_exploitable = False
            for opponent_idx in self.exploitable_opponents:
                if current_round_opponent_actions[opponent_idx]:
                    still_exploitable = True
                    break
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_97(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defect to identify cooperators in round 1,
    then adaptively exploit "sucker" types (those who cooperate despite defection)
    while maintaining mutual defection with persistent defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_types = {}
        self.opponent_contribution_history = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        n_opponents = self.game_description.n_players - 1
        for opp_idx in range(n_opponents):
            if opp_idx not in self.opponent_types:
                self.opponent_types[opp_idx] = None
                self.opponent_contribution_history[opp_idx] = []
        for round_idx in range(state.round_number):
            for opp_idx in range(n_opponents):
                if len(self.opponent_contribution_history[opp_idx]) <= round_idx:
                    self.opponent_contribution_history[opp_idx].append(bool(history.opponent_actions[round_idx, opp_idx]))
        for opp_idx in range(n_opponents):
            if self.opponent_types[opp_idx] == 'defector':
                continue
            contrib_history = self.opponent_contribution_history[opp_idx]
            if len(contrib_history) > 0:
                round_1_cooperated = contrib_history[0]
                if round_1_cooperated:
                    self.opponent_types[opp_idx] = 'sucker'
                elif len(contrib_history) > 1:
                    later_cooperated = any(contrib_history[1:])
                    if later_cooperated:
                        self.opponent_types[opp_idx] = 'conditional_cooperator'
                    else:
                        self.opponent_types[opp_idx] = 'defector'
                else:
                    self.opponent_types[opp_idx] = 'defector'
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        return Action.D

    def _has_exploitable_opponent(self, history: PlayerHistory) -> bool:
        """Check if any opponent is still exploitable."""
        for opp_type in self.opponent_types.values():
            if opp_type in ('sucker', 'conditional_cooperator'):
                return True
        return False

class Strategy_EXPLOITATIVE_98(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Free-ride by default, selectively contribute
    only when observing high cooperation from others, and defect unconditionally in
    the final 2 rounds to maximize endgame extraction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        if round_num >= 2:
            recent_rounds = min(2, round_num)
            low_contribution_count = 0
            for i in range(recent_rounds):
                round_idx = round_num - 1 - i
                if round_idx >= 0:
                    other_contributions = sum(history.opponent_actions[round_idx, :])
                    avg_other_contribution = other_contributions / (self.n_players - 1)
                    if avg_other_contribution < 0.3:
                        low_contribution_count += 1
            if low_contribution_count >= 2:
                return Action.D
        if round_num >= 1:
            prev_round_idx = round_num - 1
            other_contributions = sum(history.opponent_actions[prev_round_idx, :])
            cooperation_threshold = (self.n_players - 1) * 0.6
            if other_contributions > cooperation_threshold:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_99(BaseStrategy):
    """
    Exploitative strategy for repeated public goods game.
    Defects by default, identifies exploitable contributors, and maintains
    just enough cooperation to preserve extraction opportunities.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_contribution_counts = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if self.opponent_contribution_counts is None:
            self.opponent_contribution_counts = np.zeros(self.n_players - 1)
        for opp_idx in range(self.n_players - 1):
            self.opponent_contribution_counts[opp_idx] = np.sum(history.opponent_actions[:round_num, opp_idx])
        prev_round_idx = round_num - 1
        if round_num >= 2:
            total_contributions_prev = np.sum(history.opponent_actions[prev_round_idx, :])
            total_contributions_prev_prev = np.sum(history.opponent_actions[prev_round_idx - 1, :])
            if total_contributions_prev == 0 and total_contributions_prev_prev == 0:
                return Action.D
        avg_others_contribution = np.mean(history.opponent_actions[:round_num, :])
        exploitation_threshold = (self.k - 1) / (2 * self.k)
        if avg_others_contribution > exploitation_threshold:
            return Action.D
        for opp_idx in range(self.n_players - 1):
            if self.opponent_contribution_counts[opp_idx] >= 3:
                return Action.D
        total_contributions_prev = np.sum(history.opponent_actions[prev_round_idx, :])
        if total_contributions_prev >= 2:
            return Action.D
        if round_num >= 2:
            total_contributions_prev = np.sum(history.opponent_actions[prev_round_idx, :])
            total_contributions_prev_prev = np.sum(history.opponent_actions[prev_round_idx - 1, :])
            if total_contributions_prev == 0:
                return Action.D
        total_contributions_prev = np.sum(history.opponent_actions[prev_round_idx, :])
        if total_contributions_prev > 0 and total_contributions_prev < 1 + (self.n_players - 1) * 0.2:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_100(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Core principle: Always defect to exploit cooperative players while avoiding
    losses to defectors. Uses a threshold-based rule (1/k) to adapt to contribution
    rates, but ultimately defaults to defection as the dominant strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.contribution_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_idx = state.round_number - 1
        cooperators_previous = np.sum(history.opponent_actions[previous_round_idx, :])
        contribution_rate = cooperators_previous / self.game_description.n_players
        self.contribution_history.append(contribution_rate)
        if len(self.contribution_history) >= 2:
            avg_contribution_rate = np.mean(self.contribution_history[-2:])
        else:
            avg_contribution_rate = contribution_rate
        threshold = 1.0 / self.game_description.k
        return Action.D

class Strategy_EXPLOITATIVE_101(BaseStrategy):
    """
    Conditional Parasite - An exploitative public goods strategy.
    
    Defects strategically to maximize personal payoff while exploiting
    others' cooperation. Monitors cooperation rates and maintains defection
    as the dominant strategy, only considering conditional responses to
    detect and exploit cooperation patterns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_action = None
        self.cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.D
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round_idx = state.round_number - 1
        total_cooperators = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        if history.my_actions[prev_round_idx]:
            total_cooperators += 1
        cooperation_rate = total_cooperators / self.game_description.n_players
        self.cooperation_history.append(cooperation_rate)
        if cooperation_rate >= 0.5:
            self.last_action = Action.D
            return Action.D
        if cooperation_rate < 0.5:
            if self.last_action == Action.D:
                return Action.D
            self.last_action = Action.D
            return Action.D
        if len(self.cooperation_history) >= 2:
            if self.cooperation_history[-1] < self.cooperation_history[-2] and self.cooperation_history[-2] < 0.5:
                self.last_action = Action.D
                return Action.D
        self.last_action = Action.D
        return Action.D

class Strategy_EXPLOITATIVE_102(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Dynamically exploits cooperation of others
    while minimizing personal contribution. Defects by default, contributes only when
    expected pool return exceeds 1.0 token. Permanently switches to defection if others'
    contributions drop significantly, preventing exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.permanently_defect = False
        self.contribution_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = state.round_number
        if current_round == 0:
            self.contribution_history.append(False)
            return Action.D
        if current_round == r - 1:
            self.contribution_history.append(False)
            return Action.D
        if self.permanently_defect:
            self.contribution_history.append(False)
            return Action.D
        rounds_to_analyze = current_round
        if rounds_to_analyze == 0:
            avg_others_contribution = 0.0
        else:
            total_other_contributions = 0.0
            for round_idx in range(rounds_to_analyze):
                other_contributions = np.sum(history.opponent_actions[round_idx, :])
                total_other_contributions += other_contributions
            avg_others_contribution = total_other_contributions / (rounds_to_analyze * (n - 1))
        if rounds_to_analyze >= 2:
            early_avg = np.sum(history.opponent_actions[0, :]) / (n - 1)
            recent_avg = np.sum(history.opponent_actions[current_round - 1, :]) / (n - 1)
            if early_avg > 0.2 and recent_avg < 0.2:
                self.permanently_defect = True
                self.contribution_history.append(False)
                return Action.D
        if current_round < 3:
            self.contribution_history.append(False)
            return Action.D
        expected_pool_return = k / n * (avg_others_contribution * (n - 1) + 1.0)
        if expected_pool_return > 1.0:
            self.contribution_history.append(True)
            return Action.C
        else:
            self.contribution_history.append(False)
            return Action.D

class Strategy_EXPLOITATIVE_103(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Exploits predictable cooperative behavior while minimizing losses against defectors.
    - Round 0: Defect to identify cooperators
    - Rounds 1 to r-2: Exploit cooperators, defect against defectors
    - Rounds r-1 and r: Unconditional defection (endgame)
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_coop_counts = None
        self.opponent_round_counts = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if self.opponent_coop_counts is None:
            self.opponent_coop_counts = np.zeros(self.game_description.n_players - 1, dtype=np.int32)
            self.opponent_round_counts = np.zeros(self.game_description.n_players - 1, dtype=np.int32)
        current_round = state.round_number
        if current_round > 0:
            for opp_idx in range(self.game_description.n_players - 1):
                self.opponent_coop_counts[opp_idx] = int(np.sum(history.opponent_actions[:current_round, opp_idx]))
                self.opponent_round_counts[opp_idx] = current_round
        if current_round >= self.game_description.n_rounds - 2:
            return Action.D
        for opp_idx in range(self.game_description.n_players - 1):
            coop_count = self.opponent_coop_counts[opp_idx]
            total_rounds = self.opponent_round_counts[opp_idx]
            if total_rounds == 0:
                continue
            if coop_count == total_rounds:
                continue
            if coop_count == 0:
                continue
            coop_rate = coop_count / total_rounds if total_rounds > 0 else 0
            recent_rounds = min(3, total_rounds)
            recent_coop = int(np.sum(history.opponent_actions[max(0, total_rounds - recent_rounds):total_rounds, opp_idx]))
            recent_rate = recent_coop / recent_rounds if recent_rounds > 0 else 0
            if recent_rate < 0.5:
                continue
        return Action.D

class Strategy_EXPLOITATIVE_104(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy that preys on cooperative players
    while avoiding mutual defection traps. Classifies opponents as unconditional
    cooperators, conditional cooperators, or defectors, then exploits accordingly.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_classifications = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        k = self.game_description.k
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round >= n_rounds - 2:
            return Action.D
        for opponent_id in range(n_players - 1):
            if opponent_id not in self.opponent_classifications:
                if history.opponent_actions[0, opponent_id]:
                    self.opponent_classifications[opponent_id] = 'unconditional_cooperator'
                else:
                    self.opponent_classifications[opponent_id] = 'defector'
            elif current_round % 2 == 0 and current_round >= 3:
                recent_rounds = max(0, current_round - 3)
                recent_actions = history.opponent_actions[recent_rounds:current_round, opponent_id]
                if len(recent_actions) > 0:
                    cooperation_rate = float(np.mean(recent_actions))
                    if cooperation_rate < 0.6:
                        self.opponent_classifications[opponent_id] = 'defector'
                    elif history.opponent_actions[0, opponent_id]:
                        self.opponent_classifications[opponent_id] = 'unconditional_cooperator'
                    else:
                        self.opponent_classifications[opponent_id] = 'conditional_cooperator'
        if current_round >= 1:
            prev_contributions = int(np.sum(history.opponent_actions[current_round - 1, :]))
            prev_contributions += int(history.my_actions[current_round - 1])
            max_possible = n_players
            if prev_contributions >= 0.75 * max_possible:
                public_payoff = k / n_players * prev_contributions
                if public_payoff > 1:
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_105(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Strategically exploits conditional cooperators and free-riders by:
    1. Defecting in round 1 to gather information
    2. Cooperating when opponents' contributions exceed 0.5 or strong cooperators exist
    3. Defecting in the final round unconditionally for endgame extraction
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        n_opponents = self.n_players - 1
        opponent_cooperation_rates = np.zeros(n_opponents)
        for opp_idx in range(n_opponents):
            total_rounds_so_far = round_num
            if total_rounds_so_far > 0:
                cooperations = np.sum(history.opponent_actions[:round_num, opp_idx])
                opponent_cooperation_rates[opp_idx] = cooperations / total_rounds_so_far
            else:
                opponent_cooperation_rates[opp_idx] = 0.0
        strong_cooperators_exist = np.any(opponent_cooperation_rates >= 0.8)
        defectors_exist = np.any(opponent_cooperation_rates >= 0.7)
        prev_round_contributions = np.sum(history.opponent_actions[round_num - 1, :])
        avg_prev_contribution = prev_round_contributions / n_opponents if n_opponents > 0 else 0.0
        if avg_prev_contribution > 0.5:
            return Action.C
        elif strong_cooperators_exist:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_106(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defects to free-ride on cooperative players
    while adaptively categorizing opponents based on their contribution patterns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_categories = {}
        self.opponent_contribution_counts = {}
        self.opponent_contribution_history = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if self.k / self.n_players <= 1.0:
            return Action.D
        if round_num == 0:
            return Action.D
        self._update_opponent_categories(history, round_num)
        if round_num == self.n_rounds - 1:
            return Action.D
        return Action.D

    def _update_opponent_categories(self, history: PlayerHistory, round_num: int) -> None:
        """
        Partition opponents into behavioral categories based on observed history.
        Categories:
        - A: Unconditional/High Cooperators (≥80% contribution rate)
        - B: Conditional Cooperators (20%-80% AND shows correlation with others)
        - C: Defectors/Retaliators (<20% contribution rate)
        """
        n_opponents = self.n_players - 1
        for opp_idx in range(n_opponents):
            if opp_idx not in self.opponent_contribution_counts:
                self.opponent_contribution_counts[opp_idx] = 0
                self.opponent_contribution_history[opp_idx] = []
                self.opponent_categories[opp_idx] = None
        for opp_idx in range(n_opponents):
            cooperation_count = int(np.sum(history.opponent_actions[:round_num, opp_idx]))
            self.opponent_contribution_counts[opp_idx] = cooperation_count
            if round_num > 0:
                contribution_rate = cooperation_count / round_num
            else:
                contribution_rate = 0.0
            self.opponent_contribution_history[opp_idx].append(contribution_rate)
            if contribution_rate >= 0.8:
                self.opponent_categories[opp_idx] = 'A'
            elif contribution_rate < 0.2:
                self.opponent_categories[opp_idx] = 'C'
            else:
                is_conditional = self._check_conditional_behavior(history, opp_idx, round_num)
                if is_conditional:
                    self.opponent_categories[opp_idx] = 'B'
                else:
                    self.opponent_categories[opp_idx] = 'C'
            if round_num >= 2:
                recent_rate = self.opponent_contribution_history[opp_idx][-1]
                prev_rate = self.opponent_contribution_history[opp_idx][-2]
                if recent_rate > prev_rate + 0.3 and prev_rate < 0.5:
                    pass

    def _check_conditional_behavior(self, history: PlayerHistory, opp_idx: int, round_num: int) -> bool:
        """
        Check if opponent shows correlation with others' previous contributions,
        indicating conditional cooperation behavior.
        """
        if round_num < 2:
            return False
        window_size = min(3, round_num - 1)
        opp_recent = history.opponent_actions[round_num - window_size:round_num, opp_idx]
        others_actions = history.opponent_actions[round_num - window_size:round_num, :]
        others_cooperation = np.zeros(window_size)
        for i in range(window_size):
            round_idx = round_num - window_size + i
            others_coop_in_round = np.sum(others_actions[i, :]) - int(opp_recent[i])
            others_cooperation[i] = others_coop_in_round / (self.n_players - 1)
        if window_size >= 2:
            opp_changes = np.diff(opp_recent.astype(float))
            others_changes = np.diff(others_cooperation)
            if len(opp_changes) > 0 and len(others_changes) > 0:
                correlation = np.mean(opp_changes * others_changes)
                return correlation > 0.1
        return False

class Strategy_EXPLOITATIVE_107(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Always defect to maximize personal payoff
    by extracting surplus from cooperative players while avoiding mutual defection traps.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_counts = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if self.opponent_cooperation_counts is None:
            n_opponents = self.game_description.n_players - 1
            self.opponent_cooperation_counts = np.zeros(n_opponents, dtype=np.int64)
        if history is not None and len(history.opponent_actions) > 0:
            self.opponent_cooperation_counts = np.sum(history.opponent_actions, axis=0)
        return Action.D

class Strategy_EXPLOITATIVE_108(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Maximizes personal payoff by exploiting
    predictable patterns in opponent behavior. Defects against pure cooperators,
    defects against pure defectors, exploits conditional cooperators, and always
    defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_threshold = (self.k - 1) / self.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        n_opponents = self.n_players - 1
        opponent_classifications = []
        for opponent_idx in range(n_opponents):
            opponent_contributions = history.opponent_actions[:current_round, opponent_idx]
            if len(opponent_contributions) == 0:
                opponent_classifications.append('unknown')
                continue
            if current_round <= 2:
                recent_window = opponent_contributions[-2:]
                contribution_rate = np.sum(recent_window) / len(recent_window) if len(recent_window) > 0 else 0.0
            else:
                contribution_rate = float(np.mean(opponent_contributions))
            if contribution_rate == 1.0:
                opponent_classifications.append('pure_cooperator')
            elif contribution_rate == 0.0:
                opponent_classifications.append('pure_defector')
            else:
                opponent_classifications.append('mixed')
        my_action = Action.D
        pure_cooperators = opponent_classifications.count('pure_cooperator')
        mixed_cooperators = opponent_classifications.count('mixed')
        if mixed_cooperators > 0:
            recent_history_length = min(current_round, 2)
            if recent_history_length > 0:
                recent_opponent_contributions = history.opponent_actions[current_round - recent_history_length:current_round, :]
                avg_contribution_rate = float(np.mean(recent_opponent_contributions))
                if avg_contribution_rate > self.cooperation_threshold:
                    my_action = Action.C
                else:
                    my_action = Action.D
            else:
                my_action = Action.D
        elif pure_cooperators == n_opponents:
            my_action = Action.D
        elif pure_cooperators > 0 and mixed_cooperators == 0:
            my_action = Action.D
        else:
            my_action = Action.D
        return my_action

class Strategy_EXPLOITATIVE_109(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Systematically defects to capture private returns
    while adapting exploitation timing based on observed opponent types (pure cooperators,
    conditional cooperators, reciprocators, defectors). Uses opening defection for
    intelligence gathering, adaptive middle-game exploitation, and endgame defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_types = {}
        self.conditional_cooperator_contributions = {}
        self.defection_streak = {}
        self.cooperation_reset_timer = {}

    def _infer_opponent_type(self, opponent_idx: int, history: PlayerHistory) -> str:
        """
        Infer opponent type based on observed behavior.
        Returns: 'pure_cooperator', 'conditional_cooperator', 'reciprocator', or 'defector'
        """
        if opponent_idx not in self.opponent_types:
            if len(history.my_actions) < 2:
                return 'unknown'
            opponent_actions = history.opponent_actions[:, opponent_idx]
            my_actions = history.my_actions
            if np.all(opponent_actions):
                self.opponent_types[opponent_idx] = 'pure_cooperator'
                return 'pure_cooperator'
            if np.all(~opponent_actions):
                self.opponent_types[opponent_idx] = 'defector'
                return 'defector'
            if len(my_actions) >= 2:
                recent_rounds = min(3, len(my_actions) - 1)
                for i in range(1, recent_rounds + 1):
                    if not my_actions[-i] and opponent_actions[-i]:
                        pass
                    elif my_actions[-i] and (not opponent_actions[-i]):
                        self.opponent_types[opponent_idx] = 'reciprocator'
                        return 'reciprocator'
            if np.any(opponent_actions):
                self.opponent_types[opponent_idx] = 'conditional_cooperator'
                return 'conditional_cooperator'
            return 'defector'
        return self.opponent_types.get(opponent_idx, 'unknown')

    def _get_action_for_round(self, state: GameState, history: PlayerHistory) -> Action:
        """Determine action based on game phase and opponent analysis."""
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round < 2:
            return Action.D
        if current_round >= total_rounds - 2:
            return Action.D
        exploitation_score = 0.0
        defection_count = 0
        for opponent_idx in range(self.game_description.n_players - 1):
            opponent_type = self._infer_opponent_type(opponent_idx, history)
            if opponent_type == 'pure_cooperator':
                defection_count += 1
            elif opponent_type == 'conditional_cooperator':
                if opponent_idx not in self.cooperation_reset_timer:
                    self.cooperation_reset_timer[opponent_idx] = 0
                if total_rounds >= 15 and current_round % 6 == 0 and (self.cooperation_reset_timer[opponent_idx] == 0):
                    self.cooperation_reset_timer[opponent_idx] = 1
                    exploitation_score += 0.5
                else:
                    defection_count += 1
                    self.cooperation_reset_timer[opponent_idx] = max(0, self.cooperation_reset_timer[opponent_idx] - 1)
            elif opponent_type == 'reciprocator':
                if current_round % 3 == 0:
                    exploitation_score += 0.3
                else:
                    defection_count += 1
            elif opponent_type == 'defector':
                defection_count += 1
            else:
                defection_count += 1
        num_opponents = self.game_description.n_players - 1
        if defection_count + exploitation_score > num_opponents / 2:
            return Action.D
        else:
            return Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        return self._get_action_for_round(state, history)

class Strategy_EXPLOITATIVE_110(BaseStrategy):
    """
    Exploitative Public Goods Strategy that maximizes personal payoff through
    strategic defection while exploiting others' contributions. Adapts defection
    timing based on opponent behavior patterns to sustain cooperation as long as possible.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        prev_round_idx = round_num - 1
        cooperators_prev = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        cooperation_rate = cooperators_prev / (self.n_players - 1) if self.n_players > 1 else 0
        if cooperation_rate < 0.4:
            return Action.C
        punisher_detected = self._detect_punisher(history, round_num)
        if punisher_detected:
            return self._match_punisher_pattern(history, round_num)
        if cooperation_rate > 0.7:
            return Action.D
        if self._detect_tit_for_tat(history, round_num):
            rounds_since_cooperation = self._count_consecutive_defections(history, round_num)
            if rounds_since_cooperation >= 3:
                return Action.C
        return Action.D

    def _detect_punisher(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Detect if any opponent follows a punisher strategy (defects when we defect).
        """
        if round_num < 2:
            return False
        for opp_idx in range(self.n_players - 1):
            punisher_pattern = True
            check_rounds = min(3, round_num)
            for r in range(round_num - check_rounds, round_num):
                my_action = history.my_actions[r]
                opp_action = history.opponent_actions[r, opp_idx]
                if my_action == 0 and opp_action == 0:
                    continue
                elif my_action == 0 and opp_action == 1:
                    punisher_pattern = False
                    break
            if punisher_pattern and check_rounds > 0:
                return True
        return False

    def _match_punisher_pattern(self, history: PlayerHistory, round_num: int) -> Action:
        """
        Match punisher's defection pattern to minimize retaliation.
        Cooperate if they cooperated last round, defect otherwise.
        """
        if round_num < 1:
            return Action.D
        prev_round_idx = round_num - 1
        cooperators = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        if cooperators >= (self.n_players - 1) // 2:
            return Action.C
        return Action.D

    def _detect_tit_for_tat(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Detect if opponents follow tit-for-tat (reciprocate our actions).
        """
        if round_num < 2:
            return False
        for opp_idx in range(self.n_players - 1):
            reciprocal_count = 0
            check_rounds = min(3, round_num)
            for r in range(round_num - check_rounds, round_num):
                my_prev_action = history.my_actions[r - 1] if r > 0 else 1
                opp_action = history.opponent_actions[r, opp_idx]
                if my_prev_action == opp_action:
                    reciprocal_count += 1
            if reciprocal_count >= check_rounds - 1:
                return True
        return False

    def _count_consecutive_defections(self, history: PlayerHistory, round_num: int) -> int:
        """
        Count consecutive defections we've made recently.
        """
        count = 0
        for r in range(round_num - 1, -1, -1):
            if history.my_actions[r] == 0:
                count += 1
            else:
                break
        return count

class Strategy_EXPLOITATIVE_111(BaseStrategy):
    """
    Exploitative strategy for repeated public goods game.
    
    Defects in round 1 to gather information, exploits unconditional cooperators
    throughout the game, offers minimal cooperation to reciprocators to prevent
    commons collapse, and defects unconditionally in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_classifications = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self._classify_opponents(history)
        current_round_idx = state.round_number - 1
        opponent_actions_last_round = history.opponent_actions[current_round_idx, :]
        cooperators_last_round = int(np.sum(opponent_actions_last_round))
        commons_threshold = self.game_description.k / 2.0
        unconditional_cooperators = sum((1 for idx, classification in self.opponent_classifications.items() if classification == 'unconditional_cooperator'))
        reciprocators = sum((1 for idx, classification in self.opponent_classifications.items() if classification == 'reciprocator'))
        if reciprocators > 0 and cooperators_last_round < commons_threshold:
            cooperation_attempt_rounds = [2, 6, 10, 14, 18, 22, 26, 30]
            if state.round_number in cooperation_attempt_rounds:
                return Action.C
        return Action.D

    def _classify_opponents(self, history: PlayerHistory) -> None:
        """
        Classify each opponent as one of: unconditional_cooperator, reciprocator,
        conditional_defector, or adaptive_opportunist.
        """
        n_opponents = self.game_description.n_players - 1
        for opponent_idx in range(n_opponents):
            if opponent_idx in self.opponent_classifications:
                continue
            opponent_history = history.opponent_actions[:, opponent_idx]
            my_history = history.my_actions
            opponent_cooperations = int(np.sum(opponent_history))
            total_rounds_observed = len(opponent_history)
            if opponent_cooperations == total_rounds_observed:
                self.opponent_classifications[opponent_idx] = 'unconditional_cooperator'
            elif opponent_cooperations == 0:
                self.opponent_classifications[opponent_idx] = 'conditional_defector'
            else:
                self.opponent_classifications[opponent_idx] = 'reciprocator'

class Strategy_EXPLOITATIVE_112(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    
    Maximizes personal payoff by identifying and exploiting cooperative players
    through asymmetric information revealed via history. Uses cooperation rate
    profiling to discriminate between reliable cooperators, conditional cooperators,
    and persistent defectors. Applies backward induction to defect in endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        opponent_coop_rates = self._calculate_opponent_coop_rates(history, round_num)
        reliable_cooperators = sum((1 for rate in opponent_coop_rates if rate >= 0.67))
        if reliable_cooperators >= self.n_players / 2:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_coop_rates(self, history: PlayerHistory, round_num: int) -> list:
        """
        Calculate cooperation rate for each opponent up to current round.
        Returns a list of cooperation rates indexed by opponent.
        Handles edge cases like division by zero.
        """
        opponent_coop_rates = []
        history_slice = history.opponent_actions[:round_num, :]
        for opponent_idx in range(self.n_players - 1):
            opponent_cooperations = history_slice[:, opponent_idx]
            rounds_played = len(opponent_cooperations)
            if rounds_played == 0:
                coop_rate = 0.0
            else:
                total_cooperations = int(np.sum(opponent_cooperations))
                coop_rate = total_cooperations / rounds_played
            opponent_coop_rates.append(coop_rate)
        return opponent_coop_rates

class Strategy_EXPLOITATIVE_113(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defect by default while detecting and exploiting
    cooperative players through selective cooperation based on contribution patterns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round <= 2:
            if current_round == 1:
                cooperators_r1 = np.sum(history.opponent_actions[0, :])
                cooperator_rate = cooperators_r1 / self.n_players
                if cooperator_rate < 0.4:
                    return Action.D
            return self._check_exploitation_triggers(history, current_round)
        return self._check_exploitation_triggers(history, current_round)

    def _check_exploitation_triggers(self, history: PlayerHistory, current_round: int) -> Action:
        """Check all exploitation trigger conditions."""
        opponent_contributions = self._calculate_opponent_contributions(history)
        for opp_idx, contribution_rate in enumerate(opponent_contributions.items()):
            if contribution_rate[1] >= 0.7:
                return Action.C
        if current_round >= 2:
            for opp_idx in range(self.n_players - 1):
                if self._is_defector_to_cooperator_transition(history, opp_idx, current_round):
                    return Action.C
        if current_round >= self.n_rounds - 2:
            if current_round > 0:
                cooperators_last = np.sum(history.opponent_actions[current_round - 1, :])
                cooperator_rate_last = cooperators_last / self.n_players
                if cooperator_rate_last >= 0.5:
                    return Action.C
        if current_round >= 3:
            total_cooperations = np.sum(history.opponent_actions[:current_round, :])
            total_possible = current_round * (self.n_players - 1)
            if total_possible > 0:
                overall_rate = total_cooperations / total_possible
                if overall_rate < 0.01:
                    return Action.D
        return Action.D

    def _calculate_opponent_contributions(self, history: PlayerHistory) -> dict:
        """Calculate contribution frequency for each opponent."""
        contributions = {}
        n_rounds_played = history.my_actions.shape[0]
        if n_rounds_played == 0:
            return contributions
        for opp_idx in range(self.n_players - 1):
            cooperations = np.sum(history.opponent_actions[:n_rounds_played, opp_idx])
            contribution_rate = cooperations / n_rounds_played if n_rounds_played > 0 else 0
            contributions[opp_idx] = contribution_rate
        return contributions

    def _is_defector_to_cooperator_transition(self, history: PlayerHistory, opp_idx: int, current_round: int) -> bool:
        """
        Detect if opponent defected for 2+ consecutive rounds then just cooperated.
        """
        if current_round < 3:
            return False
        last_action = history.opponent_actions[current_round - 1, opp_idx]
        if not last_action:
            return False
        defected_consecutively = True
        for i in range(max(0, current_round - 3), current_round - 1):
            if history.opponent_actions[i, opp_idx]:
                defected_consecutively = False
                break
        return defected_consecutively

class Strategy_EXPLOITATIVE_114(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Reconnaissance → Classification → Exploitation → Final Defection.
    
    Defects in early rounds to identify opponent types, then exploits unconditional cooperators
    while mirroring conditional cooperators with a one-round delay. Defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_types = {}
        self.opponent_histories = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if self.n_rounds < 5:
            if round_num == 0:
                return Action.D
            elif round_num == self.n_rounds - 1:
                return Action.D
            else:
                if round_num == 1:
                    self._classify_opponents(history, rounds_observed=1)
                return self._exploit_phase(history)
        if round_num < 3:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if not self.opponent_types:
            self._classify_opponents(history, rounds_observed=3)
        return self._exploit_phase(history)

    def _classify_opponents(self, history: PlayerHistory, rounds_observed: int) -> None:
        """
        Classify each opponent based on their cooperation rate in the first `rounds_observed` rounds.
        """
        n_opponents = self.n_players - 1
        for opp_idx in range(n_opponents):
            actions = history.opponent_actions[:rounds_observed, opp_idx]
            cooperation_count = sum(actions)
            if rounds_observed > 0:
                cooperation_rate = cooperation_count / rounds_observed
            else:
                cooperation_rate = 0
            if cooperation_rate >= 0.9:
                self.opponent_types[opp_idx] = 'unconditional'
            elif cooperation_rate < 0.1:
                self.opponent_types[opp_idx] = 'defector'
            else:
                self.opponent_types[opp_idx] = 'conditional'
            self.opponent_histories[opp_idx] = list(actions)

    def _exploit_phase(self, history: PlayerHistory) -> Action:
        """
        Execute exploitation based on opponent type classification.
        """
        round_num = history.my_actions.shape[0]
        n_opponents = self.n_players - 1
        if not self.opponent_types and round_num > 0:
            rounds_to_check = min(3, round_num)
            self._classify_opponents(history, rounds_observed=rounds_to_check)
        if not self.opponent_types:
            return Action.D
        unconditional_count = sum((1 for t in self.opponent_types.values() if t == 'unconditional'))
        conditional_count = sum((1 for t in self.opponent_types.values() if t == 'conditional'))
        defector_count = sum((1 for t in self.opponent_types.values() if t == 'defector'))
        k_low = self.k < 1.3
        n_large = self.n_players > 10
        if unconditional_count > 0 and (not k_low):
            return Action.C
        if conditional_count > 0:
            for opp_idx in range(n_opponents):
                if self.opponent_types.get(opp_idx) == 'conditional':
                    if round_num > 0:
                        prev_action = history.opponent_actions[round_num - 1, opp_idx]
                        return Action.D if prev_action else Action.C
                    break
        return Action.D

class Strategy_EXPLOITATIVE_115(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Systematically exploits cooperators while defecting against all opponents.
    Core approach: Always defect to maximize payoff, treating cooperators as
    free-money sources and matching defectors' behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_116(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Exploits cooperative players by defecting against consistent cooperators,
    using false reciprocity against conditional cooperators, and defecting against
    consistent defectors. Always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = None
        self.last_classification_round = -1
        self.opponent_types = None

    def _classify_opponents(self, history: PlayerHistory, current_round: int) -> None:
        """
        Classify each opponent based on their contribution history.
        Reclassify every 3 rounds or on first call.
        """
        n_opponents = self.game_description.n_players - 1
        if self.opponent_cooperation_rates is None:
            self.opponent_cooperation_rates = np.zeros(n_opponents)
            self.opponent_types = ['unknown'] * n_opponents
        if current_round - self.last_classification_round < 3 and self.last_classification_round >= 0:
            return
        self.last_classification_round = current_round
        n_rounds_observed = min(current_round, len(history.opponent_actions))
        if n_rounds_observed == 0:
            return
        for opp_idx in range(n_opponents):
            contributions = np.sum(history.opponent_actions[:n_rounds_observed, opp_idx])
            coop_rate = contributions / n_rounds_observed if n_rounds_observed > 0 else 0
            self.opponent_cooperation_rates[opp_idx] = coop_rate
            if coop_rate >= 0.8:
                self.opponent_types[opp_idx] = 'consistent_coop'
            elif coop_rate >= 0.3:
                self.opponent_types[opp_idx] = 'conditional'
            else:
                self.opponent_types[opp_idx] = 'consistent_defect'

    def _get_action_for_opponent(self, opp_type: str, current_round: int) -> Action:
        """
        Determine action against a specific opponent type.
        """
        if opp_type == 'consistent_coop':
            return Action.D
        elif opp_type == 'conditional':
            if current_round % 2 == 0:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        self._classify_opponents(history, current_round)
        if current_round > 0:
            last_round_contributions = np.sum(history.opponent_actions[current_round - 1, :])
            if last_round_contributions == 0:
                return Action.D
        n_opponents = self.game_description.n_players - 1
        if n_opponents > 0:
            avg_cooperation = np.mean(self.opponent_cooperation_rates[:n_opponents])
        else:
            avg_cooperation = 0
        if self.opponent_types and len(self.opponent_types) > 0:
            type_counts = {'consistent_coop': sum((1 for t in self.opponent_types if t == 'consistent_coop')), 'conditional': sum((1 for t in self.opponent_types if t == 'conditional')), 'consistent_defect': sum((1 for t in self.opponent_types if t == 'consistent_defect')), 'unknown': sum((1 for t in self.opponent_types if t == 'unknown'))}
            if type_counts['consistent_coop'] > type_counts['consistent_defect']:
                return Action.D
            elif type_counts['consistent_defect'] > type_counts['consistent_coop']:
                return Action.D
            elif type_counts['conditional'] > 0:
                if current_round % 2 == 0:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_117(BaseStrategy):
    """
    Exploitative strategy for repeated public goods game.
    
    Builds reputation through cooperation in early rounds, exploits it through defection
    in the middle phase, conditionally re-cooperates based on observed opponent behavior,
    and defects in the final round regardless of prior actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        phase1_end = math.floor(self.n_rounds / 3)
        phase2_end = math.floor(2 * self.n_rounds / 3)
        if self.n_rounds <= 5:
            phase1_end = 1
            phase2_end = self.n_rounds - 1
        if self.n_players <= 3:
            phase1_end = math.floor(self.n_rounds / 4)
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num <= phase1_end:
            return Action.C
        if round_num <= phase2_end:
            return Action.D
        if phase1_end < phase2_end and history is not None:
            phase2_start_idx = phase1_end
            phase2_end_idx = phase2_end
            opponent_contributions_phase2 = history.opponent_actions[phase2_start_idx:phase2_end_idx, :]
            if opponent_contributions_phase2.size > 0:
                avg_opponent_contribution_rate = np.mean(opponent_contributions_phase2)
            else:
                avg_opponent_contribution_rate = 0.0
            if avg_opponent_contribution_rate > 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_118(BaseStrategy):
    """
    Exploitative Public Goods Strategy that identifies opponent types and exploits them.
    
    Uses conditional reciprocity facade in early-mid game while targeting unconditional 
    cooperators for exploitation. Switches to universal defection in final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = (self.k - 1) / self.k if self.k > 0 else 0.5
        self.opponent_types = [0] * (self.n_players - 1)
        self.round1_defectors = set()
        self.reciprocator_cycle = {}

    def _classify_opponent(self, opponent_idx: int, history: PlayerHistory) -> int:
        """Classify opponent based on their contribution history."""
        if opponent_idx >= len(history.opponent_actions):
            return 0
        opponent_actions = history.opponent_actions[:, opponent_idx]
        n_rounds_played = len(opponent_actions)
        if n_rounds_played == 0:
            return 0
        coop_count = np.sum(opponent_actions)
        if n_rounds_played > 0 and (not opponent_actions[0]):
            if coop_count == 0:
                return 3
        if coop_count == n_rounds_played:
            return 1
        if coop_count == 0:
            return 3
        my_actions = history.my_actions[:n_rounds_played]
        matches = 0
        for i in range(1, n_rounds_played):
            if opponent_actions[i] == my_actions[i - 1]:
                matches += 1
        if n_rounds_played > 1 and matches >= (n_rounds_played - 1) * 0.7:
            return 4
        return 2

    def _get_previous_round_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate in the previous round."""
        if len(history.opponent_actions) == 0:
            return 0.0
        prev_round_actions = history.opponent_actions[-1, :]
        my_prev_action = history.my_actions[-1]
        total_cooperators = np.sum(prev_round_actions) + (1 if my_prev_action else 0)
        cooperation_rate = total_cooperators / self.n_players
        return cooperation_rate

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        is_final_round = round_num == self.n_rounds - 1
        is_penultimate_round = round_num == self.n_rounds - 2
        if self.n_rounds < 5:
            is_endgame = is_final_round
        else:
            is_endgame = is_final_round or is_penultimate_round
        if is_final_round:
            return Action.D
        if round_num == 1:
            for opp_idx in range(self.n_players - 1):
                if not history.opponent_actions[0, opp_idx]:
                    self.round1_defectors.add(opp_idx)
        for opp_idx in range(self.n_players - 1):
            if self.opponent_types[opp_idx] == 0:
                self.opponent_types[opp_idx] = self._classify_opponent(opp_idx, history)
        unconditional_coops = sum((1 for t in self.opponent_types if t == 1))
        conditional_coops = sum((1 for t in self.opponent_types if t == 2))
        defectors = sum((1 for t in self.opponent_types if t == 3))
        reciprocators = sum((1 for t in self.opponent_types if t == 4))
        if is_endgame and round_num != 0:
            return Action.D
        cooperation_rate = self._get_previous_round_cooperation_rate(history)
        if unconditional_coops > 0:
            return Action.D
        if conditional_coops > 0:
            if cooperation_rate > self.threshold:
                if self.k > self.n_players - 1:
                    return Action.C if random.random() > 0.5 else Action.D
                else:
                    return Action.D
            else:
                return Action.D
        if reciprocators > 0:
            cycle_key = 'reciprocator_cycle'
            if cycle_key not in self.reciprocator_cycle:
                self.reciprocator_cycle[cycle_key] = 0
            self.reciprocator_cycle[cycle_key] = (self.reciprocator_cycle[cycle_key] + 1) % 3
            if self.reciprocator_cycle[cycle_key] == 0:
                return Action.C
            else:
                return Action.D
        if defectors > 0:
            return Action.D
        if cooperation_rate > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_119(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Systematically exploit cooperative players
    by defecting while identifying and targeting reliable cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        my_contributions = np.sum(history.my_actions[:round_num])
        my_contribution_rate = my_contributions / round_num if round_num > 0 else 0.0
        if my_contribution_rate > 0.6:
            return Action.D
        opponent_contributions = np.sum(history.opponent_actions[:round_num, :], axis=0)
        opponent_contribution_rates = opponent_contributions / round_num
        high_cooperators = np.sum(opponent_contribution_rates > 0.5)
        if high_cooperators > self.n_players / 2:
            return Action.D
        perfect_cooperators = np.sum(opponent_contribution_rates >= 0.99)
        if perfect_cooperators > 0:
            return Action.D
        low_defectors = np.sum(opponent_contribution_rates < 0.3)
        if low_defectors > self.n_players / 2:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_120(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Maximizes personal payoff by identifying and exploiting cooperators
    while defecting against all opponent types. Uses opponent classification to target specific weaknesses.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.opponent_classifications = {}

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self._classify_opponents(history, state.round_number)
        return Action.D

    def _classify_opponents(self, history: PlayerHistory, current_round: int) -> None:
        """
        Classify each opponent based on contribution history up to current round.
        Classification types: "naive_cooperator", "conditional_cooperator", "tft_variant", 
        "pure_defector", "sophisticated"
        """
        n_opponents = self.game_description.n_players - 1
        n_rounds_played = current_round
        for opp_idx in range(n_opponents):
            if opp_idx in self.opponent_classifications:
                continue
            opp_actions = history.opponent_actions[:n_rounds_played, opp_idx]
            my_actions = history.my_actions[:n_rounds_played]
            opp_contrib_count = np.sum(opp_actions)
            total_rounds = n_rounds_played
            if opp_contrib_count == total_rounds:
                self.opponent_classifications[opp_idx] = 'naive_cooperator'
            elif opp_contrib_count == 0:
                self.opponent_classifications[opp_idx] = 'pure_defector'
            elif self._is_tft_variant(opp_actions, my_actions):
                self.opponent_classifications[opp_idx] = 'tft_variant'
            elif self._is_conditional_cooperator(opp_actions, history, opp_idx, n_rounds_played):
                self.opponent_classifications[opp_idx] = 'conditional_cooperator'
            else:
                self.opponent_classifications[opp_idx] = 'sophisticated'

    def _is_tft_variant(self, opp_actions: NDArray[np.bool_], my_actions: NDArray[np.bool_]) -> bool:
        """
        Check if opponent follows Tit-for-Tat (mirrors previous action).
        With simultaneous moves, TFT manifests as mirroring the prior round action.
        """
        if len(opp_actions) < 2:
            return False
        for i in range(1, len(opp_actions)):
            if opp_actions[i] != my_actions[i - 1]:
                return False
        return True

    def _is_conditional_cooperator(self, opp_actions: NDArray[np.bool_], history: PlayerHistory, opp_idx: int, n_rounds_played: int) -> bool:
        """
        Check if opponent adjusts contributions based on overall cooperation level.
        Conditional cooperators contribute when others contribute and defect when others defect.
        """
        if n_rounds_played < 2:
            return False
        for round_idx in range(1, n_rounds_played):
            prev_round_cooperators = np.sum(history.opponent_actions[round_idx - 1, :]) + (1 if history.my_actions[round_idx - 1] else 0)
            curr_opp_action = opp_actions[round_idx]
            if prev_round_cooperators >= self.game_description.n_players // 2:
                if not curr_opp_action:
                    return False
            elif curr_opp_action:
                return False
        return True

class Strategy_EXPLOITATIVE_121(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defect by default while exploiting conditional
    cooperators. Probe in round 1, exploit in middle rounds with selective seeding,
    and extract maximum value in the endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        round_num = state.round_number
        if round_num == 0:
            self.defection_streak = 1
            return Action.D
        if round_num >= r - 2:
            self.defection_streak += 1
            return Action.D
        prev_cooperators = int(np.sum(history.opponent_actions[round_num - 1, :]))
        cooperation_rate = prev_cooperators / (n - 1) if n > 1 else 0.0
        has_unconditional_cooperator = False
        for opp_idx in range(n - 1):
            if np.all(history.opponent_actions[:round_num, opp_idx]):
                has_unconditional_cooperator = True
                break
        if has_unconditional_cooperator:
            self.defection_streak += 1
            return Action.D
        if cooperation_rate >= 0.5:
            self.defection_streak += 1
            return Action.D
        if cooperation_rate < 0.5 and self.defection_streak >= 2:
            self.defection_streak = 0
            return Action.C
        self.defection_streak += 1
        return Action.D

class Strategy_EXPLOITATIVE_122(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Defect by default, cooperate tactically only when
    opponent pool cooperation is sufficiently high to generate personal benefit. Always defect
    in final rounds. Identify and exploit unconditional cooperators ruthlessly.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.reliable_cooperators = set()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == r - 1:
            return Action.D
        if current_round == r - 2:
            avg_others = self._calculate_avg_others_contribution(history, current_round)
            if avg_others >= 0.6:
                return Action.D
            return Action.D
        self._update_reliable_cooperators(history, current_round)
        if len(self.reliable_cooperators) == n - 1:
            return Action.D
        avg_others = self._calculate_avg_others_contribution(history, current_round)
        if n <= 4:
            cooperation_threshold = 0.7
        else:
            cooperation_threshold = 0.5
        if avg_others >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_avg_others_contribution(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the average contribution rate of all other players in the previous round.
        Returns value in [0, 1] where 1 means all cooperated, 0 means none cooperated.
        Handles edge case of division by zero.
        """
        if current_round == 0:
            return 0.0
        previous_round = current_round - 1
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        n_opponents = len(opponent_actions_prev)
        if n_opponents == 0:
            return 0.0
        cooperators = np.sum(opponent_actions_prev)
        avg_contribution = float(cooperators) / float(n_opponents)
        return avg_contribution

    def _update_reliable_cooperators(self, history: PlayerHistory, current_round: int) -> None:
        """
        Identify players who have cooperated in 3+ consecutive rounds.
        These are treated as commitment-based cooperators to be exploited.
        """
        n_opponents = history.opponent_actions.shape[1]
        min_consecutive = 3
        for opponent_idx in range(n_opponents):
            if opponent_idx in self.reliable_cooperators:
                continue
            opponent_history = history.opponent_actions[:current_round, opponent_idx]
            if len(opponent_history) < min_consecutive:
                continue
            is_reliable = False
            for start_idx in range(len(opponent_history) - min_consecutive + 1):
                window = opponent_history[start_idx:start_idx + min_consecutive]
                if np.all(window):
                    is_reliable = True
                    break
            if is_reliable:
                self.reliable_cooperators.add(opponent_idx)

class Strategy_EXPLOITATIVE_123(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Systematically defect to free-ride on cooperators
    while avoiding wasted contributions. Classifies opponents as Sucker, Defector, or 
    Conditional types based on round 1 behavior, then defects consistently to exploit
    cooperative players and avoid futile contributions against defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        round_0_cooperators = np.sum(history.opponent_actions[0, :])
        n_opponents = self.game_description.n_players - 1
        if n_opponents > 0:
            sucker_ratio = round_0_cooperators / n_opponents
        else:
            sucker_ratio = 0.0
        if sucker_ratio > 0.5:
            return Action.D
        elif sucker_ratio <= 0.5:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_124(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Conditional free-riding with adaptive exploitation.
    
    Defects by default, contributes only when opponent contribution density exceeds threshold,
    always defects in final round, and varies threshold slightly to avoid pattern detection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.base_threshold = 0.6
        self.threshold_variance = 0.05
        self.last_threshold_adjustment = 0.0
        self.contributor_tracking = {}
        self.round_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.D
        if current_round == n_rounds - 1:
            return Action.D
        if history is None:
            return Action.D
        prev_round_idx = current_round - 1
        opponent_contributions_prev = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        contribution_density = opponent_contributions_prev / (n_players - 1) if n_players - 1 > 0 else 0.0
        if current_round % 5 == 0:
            self.last_threshold_adjustment = random.uniform(-self.threshold_variance, self.threshold_variance)
        adjusted_threshold = self.base_threshold + self.last_threshold_adjustment
        adjusted_threshold = max(0.0, min(1.0, adjusted_threshold))
        if current_round % 5 == 0:
            self._update_contributor_tracking(history)
        if contribution_density >= adjusted_threshold:
            return Action.C
        else:
            return Action.D

    def _update_contributor_tracking(self, history: PlayerHistory) -> None:
        """Track which opponents are consistent contributors (>40% contribution rate)."""
        n_opponents = self.game_description.n_players - 1
        n_rounds_so_far = len(history.my_actions)
        for opponent_idx in range(n_opponents):
            opponent_contributions = int(np.sum(history.opponent_actions[:n_rounds_so_far, opponent_idx]))
            contribution_rate = opponent_contributions / max(1, n_rounds_so_far)
            self.contributor_tracking[opponent_idx] = contribution_rate >= 0.4

class Strategy_EXPLOITATIVE_125(BaseStrategy):
    """
    Exploitative Public Goods Strategy: Maximizes personal payoff by strategically
    defecting while extracting value from cooperators. Tests opponents in round 1,
    monitors cooperation patterns, exploits cooperators through consistent defection,
    and adapts as cooperation naturally declines.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.D
        exploit_sum = self._compute_exploitation_score(history, round_num)
        if exploit_sum > 0.5:
            return Action.D
        else:
            return Action.D

    def _compute_exploitation_score(self, history: PlayerHistory, current_round: int) -> float:
        """
        Compute the total exploitation score across all opponents.
        exploit_j = contribution_frequency_j * (k/n)
        
        Returns sum of exploit_j for all opponents.
        """
        if current_round == 0:
            return 0.0
        past_rounds = current_round
        past_opponent_actions = history.opponent_actions[:current_round, :]
        exploit_sum = 0.0
        for opponent_idx in range(self.n_players - 1):
            cooperations = np.sum(past_opponent_actions[:, opponent_idx])
            if past_rounds > 0:
                contribution_frequency = cooperations / past_rounds
            else:
                contribution_frequency = 0.0
            exploit_j = contribution_frequency * (self.k / self.n_players)
            exploit_sum += exploit_j
        return exploit_sum

class Strategy_EXPLOITATIVE_126(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    
    Maximizes personal payoff by exploiting cooperative players while avoiding
    mutual defection traps. Defects by default, contributes only when others'
    average contribution rate exceeds the profitability threshold (n/k).
    Unconditionally defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = self.n_players / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions[:current_round, :]
        if opponent_actions.size == 0:
            return Action.D
        total_opponent_contributions = np.sum(opponent_actions)
        total_opponent_actions = opponent_actions.size
        if total_opponent_actions == 0:
            return Action.D
        avg_contribution_rate = total_opponent_contributions / total_opponent_actions
        if avg_contribution_rate >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_127(BaseStrategy):
    """
    Exploitative Public Goods Game Strategy.
    
    Always defects to free-ride on cooperative players' contributions.
    Observes cooperation levels to understand group dynamics but maintains
    perpetual defection regardless of observed behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_index_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_idx = state.round_number - 1
        opponent_actions_prev_round = history.opponent_actions[previous_round_idx, :]
        num_opponents = self.game_description.n_players - 1
        if num_opponents > 0:
            total_opponent_contributions = np.sum(opponent_actions_prev_round)
            cooperation_index = total_opponent_contributions / num_opponents
        else:
            cooperation_index = 0.0
        self.cooperation_index_history.append(cooperation_index)
        if len(self.cooperation_index_history) >= 2:
            prev_cooperation_index = self.cooperation_index_history[-2]
            if cooperation_index < prev_cooperation_index and cooperation_index < 0.2:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_128(BaseStrategy):
    """
    Exploitative Public Goods Strategy that maximizes personal payoff by systematically
    free-riding on others' contributions while defecting whenever possible.
    
    Core logic:
    - Round 1: Defect to establish baseline and free-ride
    - Rounds 2 to r-2: Defect unless opponent pattern suggests weak cooperation
    - Final rounds: Always defect (no shadow future)
    - Default action: Defect in all cases unless direct payoff calculation proves otherwise
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = self.k / self.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        opponent_contributions = history.opponent_actions[:round_num, :]
        opponent_never_contributed = np.all(~opponent_contributions, axis=0)
        if np.any(opponent_never_contributed):
            return Action.D
        opponent_freq = np.mean(opponent_contributions, axis=0)
        strong_cooperators = opponent_freq > self.threshold
        if np.any(strong_cooperators):
            return Action.D
        last_round_contributions = history.opponent_actions[round_num - 1, :]
        total_opponent_contributions = np.sum(last_round_contributions)
        aggregate_threshold = self.threshold * self.n_players * 0.6
        if total_opponent_contributions > aggregate_threshold:
            return Action.D
        if round_num >= 2:
            contribution_diffs = np.sum(np.abs(np.diff(opponent_contributions, axis=0)), axis=0)
            has_alternators = contribution_diffs > 0
            if np.any(has_alternators):
                return Action.D
        return Action.D