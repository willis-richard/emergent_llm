"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: OpenAI
- Model: deepseek/deepseek-r1-distill-llama-70b
- Game: public_goods_prompt
"""

from dataclasses import dataclass
from enum import Enum
import math
import numpy as np
from numpy.typing import NDArray
import random

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState




class Strategy_COLLECTIVE_1(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy:
    - Cooperate in the first round.
    - Cooperate in intermediate rounds if the collective benefit meets or exceeds 1.
    - Defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_last_action = history.my_actions[previous_round]
        opponent_last_actions = history.opponent_actions[previous_round, :]
        total_contributions = int(my_last_action) + opponent_last_actions.sum()
        threshold = self.game_description.k / self.game_description.n_players * total_contributions
        return Action.C if threshold >= 1.0 else Action.D

class Strategy_COLLECTIVE_2(BaseStrategy):
    """
    A threshold-based strategy for the repeated Public Goods Game.
    Cooperates if the previous round's cooperation level exceeds n/k.
    Inherits from BaseStrategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            prev_my_action = history.my_actions[prev_round]
            prev_opponent_actions = history.opponent_actions[prev_round, :]
            T_prev = sum(prev_opponent_actions) + (1 if prev_my_action else 0)
            T_threshold = self.n_players / self.k
            if T_prev > T_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_3(BaseStrategy):
    """
    A strategy that balances individual and collective welfare through reciprocal behavior.
    Cooperates in the first round, mimics the majority's previous action in middle rounds,
    and defects in the last round to maximize personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round, :]
            total_coop_prev = (1 if my_prev_action else 0) + sum(opponents_prev)
            if total_coop_prev > self.n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_4(BaseStrategy):
    """
    Adaptive Forgiving Tit-for-Tat Strategy:
    - Cooperate in the first round.
    - Every 3 rounds, cooperate to forgive.
    - Otherwise, cooperate if the previous round's average cooperation is above 50%; else, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number % 3 == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        total_coop = my_prev_action + np.sum(opponents_prev_actions)
        avg_coop = total_coop / self.game_description.n_players
        if avg_coop > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_5(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy for Public Goods Game.
    
    - Cooperates in the first round.
    - Subsequently cooperates if the majority of players cooperated in the previous round.
    - After three consecutive rounds of majority defection, 20% chance to cooperate again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defection_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        cooperators = my_prev_action + np.sum(opponent_prev_actions)
        threshold = self.game_description.n_players / 2
        if cooperators > threshold:
            self.consecutive_defection_rounds = 0
            return Action.C
        else:
            self.consecutive_defection_rounds += 1
            if self.consecutive_defection_rounds >= 3:
                if random.random() < 0.2:
                    self.consecutive_defection_rounds = 0
                    return Action.C
            return Action.D

class Strategy_COLLECTIVE_6(BaseStrategy):
    """Adaptive Cooperative Punishment Strategy: Cooperates initially, then 
    cooperates if others' average cooperation is above a threshold, defects 
    otherwise. Defects in the last round to maximize personal gain."""

    def __init__(self, game_description: PublicGoodsDescription):
        """Initialize the strategy with game parameters."""
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        """Determine the action based on the current state and history."""
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[previous_round, :]
            sum_coop = np.sum(opponent_actions_prev)
            n_others = self.game_description.n_players - 1
            average = sum_coop / n_others if n_others != 0 else 0.0
            threshold = 0.5
            if average >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_7(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Forgiveness (ATTF) strategy for the Public Goods Game.
    Cooperates initially, defects in the last round, and adapts based on collective
    behavior with a forgiveness mechanism to prevent perpetual defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        if history is None:
            return Action.C
        sum_self = history.my_actions[prev_round]
        sum_others = np.sum(history.opponent_actions[prev_round, :])
        average_contribution = (sum_self + sum_others) / self.game_description.n_players
        threshold = self.game_description.k / self.game_description.n_players * 0.5
        if average_contribution > threshold:
            return Action.C
        elif random.random() < 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_8(BaseStrategy):
    """
    A cooperative strategy for the Public Goods Game that starts by cooperating, 
    then adapts based on the number of cooperators in the previous round.
    Cooperates if the number meets or exceeds half the players, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my = history.my_actions[-1]
        prev_opp = sum(history.opponent_actions[-1])
        prev_coops = prev_opp + prev_my
        if prev_coops >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_9(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy for Public Goods Game.

    The strategy begins by cooperating in the first round. In subsequent rounds,
    it cooperates if the total contributions in the previous round were at least k,
    and defects in the final round to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            t = state.round_number - 1
            my_past_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t, :]
            sum_cj = my_past_action + np.sum(opponent_actions)
            if sum_cj >= self.game_description.k:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_10(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on the number of contributors in previous rounds, using a threshold calculated from the game's parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        n = self.game_description.n_players
        k = self.game_description.k
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        total_c = my_prev_action + np.sum(opponent_prev_actions)
        threshold = k / (k + 1) * n
        if total_c >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_11(BaseStrategy):
    """
    A strategy that begins by Cooperating, then uses a threshold based on 
    previous contributions to decide actions in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.theta = game_description.k / (game_description.k + 1)
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_prev = history.my_actions[-1]
            opp_prev = history.opponent_actions[-1]
            sum_cj = int(my_prev) + opp_prev.sum()
            average_c = sum_cj / self.n_players
            if average_c >= self.theta:
                return Action.C
            else:
                p = 1 - average_c
                if random.random() < p:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_12(BaseStrategy):
    """
    Adaptive Reciprocity Strategy for N-Player Public Goods Game.

    - Cooperates in the first round.
    - In subsequent rounds, cooperates if more than half of the players contributed in the previous round; otherwise, defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        total_coop = my_prev_action + opp_prev_actions.sum()
        if total_coop > self.n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_13(BaseStrategy):
    """
    Adaptive Collective Contributions strategy.
    
    Cooperates initially, then reciprocates based on collective contributions
    in previous rounds, forgives defectors under certain conditions, and 
    defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_actions = history.opponent_actions[prev_round, :]
            prev_cooperations = my_prev_action + opp_actions.sum()
            if prev_cooperations == self.n_players:
                return Action.C
            elif my_prev_action:
                return Action.D
            elif prev_cooperations == 0:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_14(BaseStrategy):
    """
    A strategy that promotes cooperation based on the number of cooperators in the previous round.
    Cooperates if the number of cooperators in the previous round meets or exceeds a threshold.
    The threshold is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.threshold = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last = history.my_actions[-1]
        opponent_last = history.opponent_actions[-1].sum()
        total_coop = my_last + opponent_last
        if total_coop >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_15(BaseStrategy):
    """
    Adaptive Cooperative Threshold (ACT) Strategy for Public Goods Game.

    This strategy starts by cooperating to encourage others. In subsequent rounds, 
    it adapts based on the average contribution rate in the previous round. It 
    defects in the final round to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            total_contrib = my_prev_action + np.sum(opp_prev_actions)
            average = total_contrib / self.game_description.n_players
            if average >= 0.8:
                return Action.C
            elif average >= 0.5:
                if random.random() < 0.75:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_16(BaseStrategy):
    """
    Adaptive Cooperation Strategy (ACS) for N-player Public Goods Game.

    In the first round, always cooperates. Subsequent rounds: cooperate if at least 50% of players contributed in the previous round, else defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        sum_opponent = np.sum(history.opponent_actions[prev_round])
        my_contribution = int(history.my_actions[prev_round])
        total_coop = sum_opponent + my_contribution
        n = self.game_description.n_players
        coop_rate = total_coop / n
        if coop_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_17(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        t = state.round_number - 1
        my_prev_action = history.my_actions[t]
        sum_opponents_prev = sum(history.opponent_actions[t])
        sum_prev = my_prev_action + sum_opponents_prev
        threshold = self.game_description.n_players / 2.0
        if sum_prev > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_18(BaseStrategy):
    """
    A strategy that starts with cooperation, mirrors the group's past contributions,
    forgives if cooperation resumes, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        total_coop = np.sum(opponent_prev_actions) + my_prev_action
        avg_coop = total_coop / self.game_description.n_players
        if avg_coop > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_19(BaseStrategy):
    """
    Cooperative Tit-for-Tat with Reintroduction strategy for the Public Goods Game.

    This strategy starts by Cooperating in the first round. In subsequent rounds,
    it cooperates if the average contribution in the previous round was at least 0.5,
    otherwise it defects. It reintroduces cooperation if the average rises again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opponent_prev_actions = history.opponent_actions[t_prev]
        my_coop = 1 if my_prev_action else 0
        opponent_coop = sum(opponent_prev_actions)
        total_coop = my_coop + opponent_coop
        average = total_coop / self.game_description.n_players
        if average >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_20(BaseStrategy):
    """
    Adaptive Collective Contribution (ACC) strategy for the N-Player Public Goods Game.
    The strategy starts by cooperating, then adapts based on the group's contribution rate,
    adjusting a threshold to determine future contributions. It defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.hist_avg_payoff = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        r_rounds = self.game_description.n_rounds
        s = state.round_number
        if s == 0:
            action = Action.C
        elif s == r_rounds - 1:
            action = Action.D
        else:
            prev_round = s - 1
            prev_my_action = history.my_actions[prev_round]
            prev_opponent_actions = history.opponent_actions[prev_round, :]
            sum_contrib = prev_my_action + np.sum(prev_opponent_actions)
            avg_contrib = sum_contrib / n_players
            if avg_contrib >= self.threshold:
                action = Action.C
            else:
                action = Action.D
        if s > 0 and history is not None:
            prev_round = s - 1
            prev_my_payoff = history.my_payoffs[prev_round]
            prev_opponent_payoffs = history.opponent_payoffs[prev_round, :]
            sum_payoff = prev_my_payoff + np.sum(prev_opponent_payoffs)
            avg_payoff = sum_payoff / n_players
            self.hist_avg_payoff.append(avg_payoff)
            if len(self.hist_avg_payoff) >= 2:
                last_payoff = self.hist_avg_payoff[-1]
                second_last_payoff = self.hist_avg_payoff[-2]
                if last_payoff > second_last_payoff:
                    self.threshold *= 0.95
                else:
                    self.threshold *= 1.05
            self.threshold = max(0.2, min(self.threshold, 0.8))
        return action

class Strategy_COLLECTIVE_21(BaseStrategy):
    """
    Implements the Adaptive Collective Cooperation strategy. This strategy 
    promotes cooperation when beneficial by coordinating contributions based on 
    the previous round's average contribution rate. It defectes in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            my_contribution = history.my_actions[previous_round]
            opponents_contrib = history.opponent_actions[previous_round, :]
            total_coop = my_contribution + np.sum(opponents_contrib)
            average = total_coop / self.game_description.n_players
            if average > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_22(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) strategy for the N-Player Public Goods Game.
    This strategy promotes cooperation by adapting to group dynamics, rewarding collective cooperation,
    and employing a forgiveness mechanism to avoid perpetual defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.coop_count_history = []
        self.consecutive_d_count = 0
        self.threshold = self.n_players // 2
        self.forgive_after = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        prev_opponent_actions = history.opponent_actions[-1, :]
        prev_my_action = history.my_actions[-1]
        prev_coop = np.sum(prev_opponent_actions) + prev_my_action
        self.coop_count_history.append(prev_coop)
        window_size = 3
        if len(self.coop_count_history) > window_size:
            avg_coop = sum(self.coop_count_history[-window_size:]) / window_size
        else:
            avg_coop = sum(self.coop_count_history) / len(self.coop_count_history)
        if avg_coop > self.n_players / 2:
            self.threshold = max(1, self.threshold - 1)
        else:
            self.threshold = min(self.n_players, self.threshold + 1)
        if prev_coop >= self.threshold:
            action = Action.C
            self.consecutive_d_count = 0
        else:
            action = Action.D
            self.consecutive_d_count += 1
        if self.consecutive_d_count >= self.forgive_after:
            action = Action.C
            self.consecutive_d_count = 0
        return action

class Strategy_COLLECTIVE_23(BaseStrategy):
    """
    Implements the Majority Cooperation strategy for the Public Goods Game.
    Players cooperate if a majority of players contributed in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        me_prev = history.my_actions[previous_round]
        opponents_prev = history.opponent_actions[previous_round]
        opponents_contributed = np.sum(opponents_prev)
        total_cooperators = me_prev + opponents_contributed
        threshold = self.game_description.n_players // 2 + 1
        if total_cooperators >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_24(BaseStrategy):
    """
    A strategy that adapts to group behavior by balancing cooperation and self-interest.
    Cooperates initially, defects in the last round, and adjusts cooperation probability
    in middle rounds based on previous contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[previous_round, :]
            sum_o = np.sum(opponent_actions_prev)
            my_prev = history.my_actions[previous_round]
            sum_my = 1 if my_prev else 0
            total_c = sum_o + sum_my
            average_c = total_c / self.n_players
            probability = average_c * (self.k / (self.n_players - 1))
            probability = max(0.0, min(probability, 1.0))
            if random.random() < probability:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_25(BaseStrategy):
    """Adaptive Collective Cooperation strategy.
    
    This strategy encourages cooperation by rewarding past contributions.
    It cooperates in the first round and continues if at least k-1 players
    contributed in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_contributions = history.opponent_actions[prev_round, :].sum()
            total_contributions = opponent_contributions + (1 if my_prev_action else 0)
            k = self.game_description.k
            if total_contributions >= k - 1:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_26(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness (ACF) strategy for the N-Player Public Goods Game.
    This strategy encourages cooperation while adapting to others' behavior and forgiving when appropriate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.my_prev_action = None
        self.prev_avg_cr_defected = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.my_prev_action = Action.C
            return Action.C
        window_size = 3
        end_round = state.round_number - 1
        start_round = max(0, end_round - window_size + 1)
        cr_list = []
        for r in range(start_round, end_round + 1):
            if r < len(history.my_actions):
                my_C = history.my_actions[r]
                opponent_C = np.sum(history.opponent_actions[r, :])
                round_C = my_C + opponent_C
                round_cr = round_C / self.n_players
                cr_list.append(round_cr)
        avg_cr = np.mean(cr_list) if cr_list else 0.0
        if avg_cr >= 0.75:
            intended = Action.C
        elif avg_cr <= 0.5:
            intended = Action.D
        elif cr_list:
            last_cr = cr_list[-1]
            intended = Action.C if last_cr >= 0.5 else Action.D
        else:
            intended = Action.D
        if self.my_prev_action == Action.D:
            if self.prev_avg_cr_defected is not None:
                if avg_cr > self.prev_avg_cr_defected:
                    intended = Action.C
        if state.round_number == self.n_rounds - 1:
            total_cr = 0.0
            for r in range(0, state.round_number):
                if r < len(history.my_actions):
                    my_C = history.my_actions[r]
                    opponent_C = np.sum(history.opponent_actions[r, :])
                    round_C = my_C + opponent_C
                    round_cr = round_C / self.n_players
                    total_cr += round_cr
            avg_total_cr = total_cr / state.round_number if state.round_number > 0 else 0.0
            intended = Action.C if avg_total_cr >= 0.75 else Action.D
        if intended == Action.D:
            self.prev_avg_cr_defected = avg_cr
        self.my_prev_action = intended
        return intended

class Strategy_COLLECTIVE_27(BaseStrategy):
    """
    A strategy for the repeated N-Player Public Goods Game that promotes cooperation by adapting to the group's past contributions.
    It starts with cooperation and adjusts based on the average contribution of all players in the previous round.
    If the average contribution was 0.5 or higher, it contributes (C); otherwise, it defects (D).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        sum_opponent_c = sum(opponent_prev_actions)
        total_c = sum_opponent_c + (1 if my_prev_action else 0)
        average_c = total_c / self.n_players
        if average_c >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_28(BaseStrategy):
    """
    Adaptive Contribution Based on Past Performance Strategy.
    
    Cooperates in the first round to encourage initial cooperation. 
    In subsequent rounds, it contributes if the total contributions from the previous round meet or exceed a threshold (n/k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_last = history.my_actions[prev_round]
        my_contribution = 1 if my_last else 0
        opponent_contributions = np.sum(history.opponent_actions[prev_round, :])
        T = my_contribution + opponent_contributions
        n = self.game_description.n_players
        k = self.game_description.k
        threshold = n / k
        if T >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_29(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that encourages cooperation
    by mirroring others' behavior, adapting to group dynamics, avoiding exploitation,
    and including exploration to sustain cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.averages = []
        self.contribution_prob = 1.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            total_coop = sum(history.my_actions) + history.opponent_actions.sum()
            overall_avg = total_coop / (self.n * self.r)
            return Action.C if overall_avg > 0.5 else Action.D
        if state.round_number % 5 == 4:
            return Action.C if random.random() < 0.2 else Action.D
        if state.round_number >= 2:
            prev2 = state.round_number - 2
            prev1 = state.round_number - 1
            my_action_prev2 = history.my_actions[prev2]
            opp_actions_prev2 = history.opponent_actions[prev2, :]
            total_prev2 = my_action_prev2 + opp_actions_prev2.sum()
            my_action_prev1 = history.my_actions[prev1]
            opp_actions_prev1 = history.opponent_actions[prev1, :]
            total_prev1 = my_action_prev1 + opp_actions_prev1.sum()
            sole_prev2 = total_prev2 == 1 and my_action_prev2
            sole_prev1 = total_prev1 == 1 and my_action_prev1
            if sole_prev2 and sole_prev1:
                return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        total_prev = my_prev_action + opp_prev_actions.sum()
        avg = total_prev / self.n
        self.averages.append(avg)
        if len(self.averages) >= 2:
            avg_prev = self.averages[-2]
            avg_current = self.averages[-1]
            if avg_current > avg_prev:
                self.contribution_prob = min(self.contribution_prob + 0.1, 1.0)
            elif avg_current < avg_prev:
                self.contribution_prob = max(self.contribution_prob - 0.1, 0.0)
        if avg > 0.5:
            if random.random() < self.contribution_prob:
                return Action.C
            else:
                return Action.D
        elif random.random() < 1 - self.contribution_prob:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_30(BaseStrategy):
    """
    A collective strategy for the Public Goods Game that encourages initial cooperation,
    sanctions low contributions, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            others_prev_actions = history.opponent_actions[prev_round, :]
            sum_cj = my_prev_action + np.sum(others_prev_actions)
            threshold = self.n_players / 2
            if sum_cj >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_31(BaseStrategy):
    """
    Adaptive Contribution Based on Threshold Strategy.

    This strategy encourages cooperation by rewarding past contributions while protecting
    against exploitation. It adapts based on previous rounds' outcomes and handles edge
    cases like the first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round, :]
            count_total = my_prev + np.sum(opponents_prev)
            if count_total >= self.game_description.k:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_32(BaseStrategy):
    """
    A strategy for the Public Goods Game that promotes mutual cooperation by initiating 
    contribution in the first round, evaluating the effectiveness of contributions in 
    subsequent rounds, and defecting in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        sum_cj = my_prev_action + opponent_prev_actions.sum()
        k = self.game_description.k
        n = self.game_description.n_players
        threshold = k / n * sum_cj
        return Action.C if threshold >= 1 else Action.D

class Strategy_COLLECTIVE_33(BaseStrategy):
    """
    Optimistic Reciprocator with Endgame Discounting Strategy.
    Cooperates in the first round, defects in the last, and adapts based on the previous round's cooperation rate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        else:
            current_round = state.round_number
            if current_round == self.game_description.n_rounds - 1:
                return Action.D
            else:
                prev_round = current_round - 1
                my_coop_prev = history.my_actions[prev_round]
                opponents_coop_prev = sum(history.opponent_actions[prev_round])
                total_coop = my_coop_prev + opponents_coop_prev
                cooperation_rate = total_coop / self.game_description.n_players
                threshold = self.game_description.k / self.game_description.n_players
                if cooperation_rate > threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_34(BaseStrategy):
    """
    Adaptive Collective Cooperation with Selective Retaliation strategy.
    Cooperates in the first and last rounds. For other rounds, cooperates if
    >=90% of players cooperated previously, or if >=50% cooperated and the
    contribution would increase public good. Defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        prev_opponent_coop = sum(history.opponent_actions[-1, :])
        my_prev_coop = 1 if history.my_actions[-1] else 0
        prev_coop = prev_opponent_coop + my_prev_coop
        prev_coop_percent = prev_coop / self.game_description.n_players * 100
        if prev_coop_percent >= 90:
            return Action.C
        elif prev_coop_percent >= 50:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_35(BaseStrategy):
    """
    Adaptive strategy for the Public Goods Game. Cooperates initially, 
    then responds based on the group's contribution rate and opposes 
    if any player never contributes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            prev_round = state.round_number - 1
            my_contribution = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round, :]
            total = my_contribution + np.sum(opponents_prev)
            avg = total / n_players
            return Action.C if avg > 0.5 else Action.D
        else:
            n_opponents = n_players - 1
            for opponent in range(n_opponents):
                sum_actions = np.sum(history.opponent_actions[:, opponent])
                if sum_actions == 0:
                    return Action.D
            prev_round = state.round_number - 1
            my_contribution = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round, :]
            total = my_contribution + np.sum(opponents_prev)
            avg = total / n_players
            return Action.C if avg > 0.5 else Action.D

class Strategy_COLLECTIVE_37(BaseStrategy):
    """
    Cooperate in the first round. In subsequent rounds, cooperate if at least half of the opponents cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        threshold = self.game_description.n_players // 2
        if cooperators >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_38(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that promotes sustained cooperation
    through initial cooperation, mirroring group behavior, and endgame handling.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.n = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        if history is None:
            return Action.C
        if t >= self.r - 2:
            if t == self.r - 1:
                return Action.D
            prev_my = history.my_actions[t - 1]
            prev_op = history.opponent_actions[t - 1, :]
            total_coops = prev_my + np.sum(prev_op)
            prev_avg = total_coops / self.n
            threshold = 0.4
            if prev_avg > threshold:
                return Action.C
            else:
                return Action.D
        else:
            prev_my = history.my_actions[t - 1]
            prev_op = history.opponent_actions[t - 1, :]
            total_coops = prev_my + np.sum(prev_op)
            prev_avg = total_coops / self.n
            if self.r <= 2:
                threshold = 0.5
            else:
                threshold_step = 0.5 / (self.r - 2)
                threshold = 0.5 + (t - 1) * threshold_step
            if prev_avg > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_39(BaseStrategy):
    """
    Adaptive Cooperative Threshold (ACT) Strategy.

    This strategy starts by cooperating in the first round to establish cooperation.
    In subsequent rounds, it cooperates if the majority of players cooperated in the previous round.
    In the last round, it always cooperates to maximize collective welfare.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            prev_my_action = history.my_actions[state.round_number - 1]
            prev_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            sum_contributions = prev_my_action + prev_opponent_actions.sum()
            n_players = self.game_description.n_players
            coop_rate = sum_contributions / n_players
            if coop_rate > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_40(BaseStrategy):
    """Adaptive Cooperation with Endgame Defection strategy. Cooperates initially, 
    adapts based on previous cooperation levels, and defects in the last round."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.C
        elif current_round == n_rounds - 1:
            return Action.D
        else:
            prev_round = current_round - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round]
            my_contribution = 1 if my_prev_action else 0
            opponents_contribution = np.sum(opponents_prev_actions)
            total_contribution = my_contribution + opponents_contribution
            average = total_contribution / n_players
            if average >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_41(BaseStrategy):
    """
    A strategy that cooperates if the majority of players cooperated in the previous round.
    Starts by cooperating in the first round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_last = history.opponent_actions[prev_round]
        sum_opponents = np.sum(opponent_actions_last)
        self_last = history.my_actions[prev_round]
        sum_self = 1 if self_last else 0
        total_coop = sum_opponents + sum_self
        if total_coop > self.n / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_42(BaseStrategy):
    """
    Conditional Cooperation with Gradual Escalation strategy. Starts with cooperation, 
    gradually defects if cooperation is low, and forgives when others start contributing.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.punishment_counter = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        last_round = state.round_number - 1
        if history is not None:
            my_last_action = history.my_actions[last_round]
            opponent_actions_last_round = history.opponent_actions[last_round, :]
            n_coop_opponents = np.sum(opponent_actions_last_round)
            total_coop = int(my_last_action) + n_coop_opponents
        else:
            total_coop = 0
        threshold = (self.n_players + 1) // 2
        if total_coop >= threshold:
            self.punishment_counter = 0
            return Action.C
        elif self.punishment_counter < 2:
            self.punishment_counter += 1
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_43(BaseStrategy):
    """
    Adaptive Group Reciprocity Strategy: Cooperates initially, adapts based on previous round's cooperation rate,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        my_prev_action = history.my_actions[state.round_number - 1]
        opponent_prev_actions = history.opponent_actions[state.round_number - 1, :]
        sum_prev = (1 if my_prev_action else 0) + np.sum(opponent_prev_actions)
        if 2 * sum_prev > self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_44(BaseStrategy):
    """
    Strategy implementing initial cooperation, contribution threshold, and final round defection.
    Cooperates in the first round, defects in the last, and cooperates if at least half of the players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my = history.my_actions[prev_round]
        prev_opp = history.opponent_actions[prev_round, :]
        total_coop = prev_my + np.sum(prev_opp)
        n_players = self.game_description.n_players
        if 2 * total_coop >= n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_45(BaseStrategy):
    """
    A conditional cooperation strategy where the player cooperates in the first round and in subsequent rounds
    cooperates if at least half of the opponents cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        threshold = self.game_description.n_players // 2
        if cooperators >= threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_46(BaseStrategy):
    """
    A strategy that begins by cooperating in the first round and then follows the majority's contribution from the previous round.
    Cooperates if the majority contributed in the last round; otherwise, defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponents_last_actions = history.opponent_actions[last_round]
        total_C = sum(opponents_last_actions) + (1 if my_last_action else 0)
        threshold = self.game_description.n_players // 2
        if total_C > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_47(BaseStrategy):
    """
    Adaptive Collective Cooperation strategy that balances individual and collective interests.
    
    The strategy involves:
    1. Cooperating in the first round to establish trust.
    2. Adapting based on the majority behavior from the previous round.
    3. Defecting in the final round to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round_number = state.round_number - 1
            my_prev_action = history.my_actions[prev_round_number]
            op_prev_actions = history.opponent_actions[prev_round_number]
            total_c = my_prev_action + op_prev_actions.sum()
            if total_c > self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_48(BaseStrategy):
    """
    Adaptive Collective Cooperation strategy for N-Player Public Goods Game.
    Cooperates if majority of players cooperated in the previous round; defects otherwise.
    Initiates cooperation in the first round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_coop = history.my_actions[prev_round]
        sum_opponent_coop = sum(history.opponent_actions[prev_round])
        total_coop = int(my_coop) + sum_opponent_coop
        if total_coop > self.n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_49(BaseStrategy):
    """
    A strategy for the N-Player Public Goods game where players initially cooperate and 
    subsequently base their cooperation on the previous round's total contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_last_action = history.my_actions[-1]
            opponents_last_actions = history.opponent_actions[-1, :]
            total_c = (1 if my_last_action else 0) + sum(opponents_last_actions)
            threshold = self.game_description.n_players / self.game_description.k
            if total_c >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_50(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) Strategy.

    This strategy aims to balance individual and collective welfare by adapting to others' cooperation levels.
    It starts by cooperating, continues if the group contributes sufficiently, and cooperates in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.threshold = 0.5 * self.n_players
        self.recent_contributions = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if history is None:
            return Action.D
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_actions = history.opponent_actions[last_round]
        num_c = sum(opponent_actions) + (1 if my_last_action else 0)
        if len(self.recent_contributions) == 0:
            current_threshold = self.threshold
        else:
            current_threshold = sum(self.recent_contributions) / len(self.recent_contributions)
        if num_c >= current_threshold:
            action = Action.C
        else:
            action = Action.D
        self.recent_contributions.append(num_c)
        if self.recent_contributions:
            self.threshold = sum(self.recent_contributions) / len(self.recent_contributions)
        else:
            self.threshold = 0.5 * self.n_players
        return action

class Strategy_COLLECTIVE_51(BaseStrategy):
    """
    Adaptive Contribution Strategy (ACS) for Public Goods Game.
    Cooperates in the first round, cooperates if the last three rounds'
    average contribution is at least 50%, otherwise defects, and defects
    in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        elif current_round == n_rounds - 1:
            return Action.D
        else:
            start_round = max(0, current_round - 3)
            end_round = current_round - 1
            if start_round > end_round:
                avg_contribution = 0.0
            else:
                total_contributions = 0
                for r in range(start_round, end_round + 1):
                    my_contribution = 1 if history.my_actions[r] else 0
                    opponent_contributions = np.sum(history.opponent_actions[r])
                    total_contributions += my_contribution + opponent_contributions
                count_of_rounds = end_round - start_round + 1
                if count_of_rounds == 0:
                    avg_contribution = 0.0
                else:
                    avg_contribution = total_contributions / (count_of_rounds * n_players)
            if avg_contribution >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_52(BaseStrategy):
    """
    A strategy for the N-player Public Goods Game that balances cooperation and self-interest.
    It cooperates in the first round, reciprocates based on majority contribution in subsequent rounds,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_actions = history.opponent_actions[-1, :]
            cooperators = np.sum(prev_actions)
            threshold = (self.game_description.n_players + 1) // 2
            if cooperators >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_53(BaseStrategy):
    """
    Cooperative Reciprocity with Punishment and Adjustment (CRPA) strategy.
    Cooperates in the first round, defects in the last. Punishes defectors and
    adjusts cooperation based on previous payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.theta = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        any_opp_defect = np.any(opponent_actions_prev == False)
        if any_opp_defect:
            return Action.D
        my_prev_action = history.my_actions[prev_round]
        opp_actions_prev = history.opponent_actions[prev_round, :]
        cooperators_prev = 0
        if my_prev_action:
            cooperators_prev += 1
        cooperators_prev += np.sum(opp_actions_prev)
        avg_coop_prev = cooperators_prev / self.game_description.n_players
        my_payoff_prev = history.my_payoffs[prev_round]
        opponent_payoffs_prev = history.opponent_payoffs[prev_round, :]
        all_payoffs_prev = np.insert(opponent_payoffs_prev, 0, my_payoff_prev)
        collective_avg_payoff = np.mean(all_payoffs_prev)
        if my_payoff_prev < collective_avg_payoff:
            if my_payoff_prev == 0:
                adjustment_ratio = 2.0
            else:
                adjustment_ratio = collective_avg_payoff / (my_payoff_prev + 1e-09)
            adjusted_theta = self.theta * adjustment_ratio
        else:
            adjusted_theta = self.theta
        adjusted_theta = max(0.0, min(adjusted_theta, 1.0))
        if avg_coop_prev >= adjusted_theta:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_54(BaseStrategy):
    """
    The Eclipse strategy for the Public Goods Game. It starts with cooperation and adapts based on previous rounds' results.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.threshold = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_actions_prev = history.opponent_actions[previous_round]
        total_c = my_prev_action + np.sum(opponent_actions_prev)
        if total_c >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_55(BaseStrategy):
    """
    Collective Strategy for Public Goods Game.

    Cooperates in the first round, defects in the last round, and cooperates in subsequent rounds if at least k players contributed in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        if state.round_number == 0:
            return Action.C
        if state.round_number == n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = sum(history.opponent_actions[prev_round, :])
        total_prev = my_prev + opp_prev
        k = self.game_description.k
        if total_prev >= k:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_56(BaseStrategy):
    """
    A strategy that cooperates conditionally based on the majority's previous actions.
    Cooperates in the first round and continues if the majority cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_last_actions = history.opponent_actions[-1]
        sum_opponents = sum(opponents_last_actions)
        my_last_action = int(history.my_actions[-1])
        total_cooperators = sum_opponents + my_last_action
        n_players = self.game_description.n_players
        if total_cooperators > n_players / 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_57(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        opponent_actions = history.opponent_actions[-1, :]
        sum_coops = sum(opponent_actions)
        threshold = n_players / 2
        if sum_coops > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_58(BaseStrategy):
    """
    Implements the Conditional Cooperation with Endgame Defection strategy.
    Cooperates initially, defects in the last round, and cooperates in middle rounds 
    only if a majority of players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            prev_total_coop = my_prev_action + sum(opponents_prev_actions)
            n_players = self.game_description.n_players
            if prev_total_coop > n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_59(BaseStrategy):
    """
    Adaptive Tit-for-Group Strategy: Cooperate initially and adapt based on collective contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            n = self.game_description.n_players
            k = self.game_description.k
            T = math.ceil(n / k)
            my_prev = history.my_actions[-1]
            opponent_prev = np.sum(history.opponent_actions[-1, :])
            contributors = my_prev + opponent_prev
            return Action.C if contributors >= T else Action.D

class Strategy_COLLECTIVE_60(BaseStrategy):
    """
    A strategy for the repeated Public Goods Game that encourages cooperation
    while deterring free-riding. It cooperates in the first and final rounds,
    mirrors the group's previous cooperation rate in middle rounds, and
    includes a second chance mechanism if cooperation improves.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        prev_t = state.round_number - 1
        my_prev_action = history.my_actions[prev_t]
        opponent_prev_actions = history.opponent_actions[prev_t]
        num_coop = my_prev_action + np.sum(opponent_prev_actions)
        acr = num_coop / self.game_description.n_players
        if acr > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_61(BaseStrategy):
    """
    A strategy for the Public Goods Game that encourages cooperation
    based on the contributions of previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_contribution = 1 if history.my_actions[previous_round] else 0
        opponent_contributions = np.sum(history.opponent_actions[previous_round, :])
        T = my_contribution + opponent_contributions
        threshold = math.ceil(self.n / self.k)
        if T >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_62(BaseStrategy):
    """
    A Collective Strategy for the Repeated Public Goods Game that balances cooperation 
    and punishment, adapting to group behavior to maximize collective welfare while 
    discouraging exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.in_punishment = False
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        n = self.game_description.n_players
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            total_coop = 0
            current_round = state.round_number
            for t in range(current_round):
                my_c = history.my_actions[t]
                opp_c = np.sum(history.opponent_actions[t, :])
                total_coop += my_c + opp_c
            avg_coop = total_coop / (n * current_round)
            return Action.C if avg_coop >= 0.5 else Action.D
        if self.in_punishment:
            self.punishment_remaining -= 1
            if self.punishment_remaining == 0:
                self.in_punishment = False
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = np.sum(history.opponent_actions[prev_round, :])
        prev_coop = my_prev + opp_prev
        threshold_tit = n / 2
        if prev_coop >= threshold_tit:
            return Action.C
        threshold_punish = 0.3 * n
        if prev_coop < threshold_punish:
            self.in_punishment = True
            self.punishment_remaining = 2
        return Action.D

class Strategy_COLLECTIVE_63(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation based on the collective behavior of all players.
    Cooperates in the first round and uses the average cooperation rate from the previous round to decide subsequent actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_coop = history.my_actions[previous_round]
        opp_coop = history.opponent_actions[previous_round, :].sum()
        total_coop = my_coop + opp_coop
        n_players = self.game_description.n_players
        average_coop = total_coop / n_players
        if average_coop >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_65(BaseStrategy):
    """
    Implements the Conditional Contribution Threshold strategy for the Public Goods Game.

    In the first round, the player cooperates. In subsequent rounds, the player cooperates if at least n/k (rounded up) players contributed in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1]
        sum_coop_prev = my_prev_action + np.sum(opponent_prev_actions)
        if sum_coop_prev >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_66(BaseStrategy):
    """
    Adaptive Collective Contributions with Threshold (ACCT)
    
    This strategy promotes initial cooperation, adapts based on group behavior,
    and defects when contributions are insufficient or in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.threshold = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.r - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_act = history.my_actions[prev_round]
            opponents_prev_acts = history.opponent_actions[prev_round, :]
            c_prev = int(my_prev_act) + np.sum(opponents_prev_acts)
            if c_prev >= self.threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_67(BaseStrategy):
    """
    Adaptive Cooperation with Sanctions (ACS) strategy. Cooperates if previous round's 
    cooperation rate is above 50%, otherwise defects. Always cooperates in the first round 
    and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        my_last = history.my_actions[-1]
        opponent_last = history.opponent_actions[-1]
        total_coop = my_last + sum(opponent_last)
        avg_coop = total_coop / self.game_description.n_players
        if avg_coop >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_68(BaseStrategy):
    """
    A strategy that adapts based on the level of cooperation in previous rounds.
    Cooperates if the majority contributed in the previous round, defects otherwise.
    In the last round, contributes if the group maintained high cooperation overall.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            total_coops = 0.0
            for t in range(current_round):
                my_action = history.my_actions[t]
                others = history.opponent_actions[t, :]
                coops = my_action + np.sum(others)
                total_coops += coops
            avg_coops = total_coops / current_round
            threshold = n_players / 2.0
            return Action.C if avg_coops > threshold else Action.D
        else:
            prev_round = current_round - 1
            my_prev_action = history.my_actions[prev_round]
            others_prev = history.opponent_actions[prev_round, :]
            prev_coops = my_prev_action + np.sum(others_prev)
            threshold = n_players / 2.0
            return Action.C if prev_coops > threshold else Action.D

class Strategy_COLLECTIVE_69(BaseStrategy):
    """
    Adaptive Cooperative Punisher Strategy.
    
    - Cooperate in the first 3 rounds to encourage initial cooperation.
    - Cooperate if the previous round's average contribution is at least 50%.
    - Defect for one round if the previous round's average contribution drops below 50%, then revert to cooperation.
    - Defect in the last round to maximize personal payoff.
    - Defect if all other players are consistently defecting to minimize loss.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.initial_phase = 2
        self.in_punishment = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number <= self.initial_phase:
            return Action.C
        if self.in_punishment:
            self.in_punishment = False
            return Action.D
        previous_round = round_number - 1
        if history is None:
            return Action.C
        my_actions = history.my_actions[previous_round]
        opponent_actions = history.opponent_actions[previous_round, :]
        total_coop = my_actions + opponent_actions.sum()
        avg_coop = total_coop / self.n_players
        if avg_coop < 0.5:
            self.in_punishment = True
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_70(BaseStrategy):
    """
    Starts with Cooperation (C) in the first round. For each subsequent round, 
    calculates the average contribution of all players. Cooperates if the average 
    is above 50%, otherwise Defects. In the final round, uses the overall average 
    contribution from previous rounds to decide.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        previous_rounds = state.round_number
        sum_contributions = 0.0
        for round in range(previous_rounds):
            my_action = history.my_actions[round]
            opponent_actions_round = history.opponent_actions[round]
            my_contribution = 1 if my_action else 0
            opponent_contribution = np.sum(opponent_actions_round)
            sum_contributions += my_contribution + opponent_contribution
        average = sum_contributions / (n_players * previous_rounds)
        if average > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_71(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that balances cooperation and defection.
    Cooperates initially, imitates majority behavior, punishes non-cooperation, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            my_last_action = history.my_actions[-1]
            opponent_last_actions = history.opponent_actions[-1]
            sum_contrib = my_last_action + np.sum(opponent_last_actions)
            n_players = self.game_description.n_players
            if sum_contrib / n_players >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_72(BaseStrategy):
    """
    This strategy promotes cooperation in the Public Goods Game by using an adaptive approach based on the previous round's outcomes.
    It starts with cooperation, adapts based on majority behavior, enforces a contribution threshold, includes exploration,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        prev_round = current_round - 1
        my_prev_action = history.my_actions[prev_round]
        op_prev_actions = history.opponent_actions[prev_round, :]
        total_coop_last = sum(op_prev_actions) + my_prev_action
        majority = self.n_players // 2
        if total_coop_last > majority:
            base_action = Action.C
        elif total_coop_last >= self.k:
            base_action = Action.C
        else:
            base_action = Action.D
        if base_action == Action.D:
            if random.random() < 0.1:
                return Action.C
        return base_action

class Strategy_COLLECTIVE_73(BaseStrategy):
    """
    A strategy for the Public Goods Game that promotes collective cooperation
    through an adaptive threshold based on the number of contributors.
    Cooperates initially, defects in the last round, and adapts based on previous cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        elif round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            cooperators = my_prev_action + np.sum(opponents_prev_actions)
            if cooperators >= self.k:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_74(BaseStrategy):
    """
    A strategy that begins with cooperation, adapts based on others' cooperation, 
    and ensures cooperation in the final rounds to maximize collective payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number >= self.game_description.n_rounds - 2:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            my_prev_value = 1 if my_prev else 0
            opp_prev = history.opponent_actions[prev_round, :]
            opp_prev_sum = np.sum(opp_prev)
            total_coop = my_prev_value + opp_prev_sum
            threshold = self.game_description.n_players / 2
            if total_coop >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_75(BaseStrategy):
    """
    Adaptive Cooperation with Endgame Defection Strategy.
    
    Cooperates in the first round, responds to average cooperation in middle rounds,
    and defects in the last round to balance collective welfare with individual gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        elif t == self.n_rounds - 1:
            return Action.D
        else:
            total_c = 0
            for round_num in range(t):
                my_c = history.my_actions[round_num]
                opponent_c = np.sum(history.opponent_actions[round_num, :])
                total_c += my_c + opponent_c
            avg_coop = total_c / (self.n_players * t)
            if avg_coop > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_76(BaseStrategy):
    """
    ResponsiveContributor strategy implements a dynamic approach where players initially
    cooperate and then adapt based on the collective contribution levels in previous rounds.
    If the total contributions in the previous round meet or exceed a threshold (n/k), the
    player cooperates; otherwise, they defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_action = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round, :]
        total_contributions = my_action + np.sum(opponent_actions)
        threshold = self.game_description.n_players / self.game_description.k
        if total_contributions >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_77(BaseStrategy):
    """
    A strategy that uses collective reciprocity in repeated Public Goods Game.
    Cooperates in the first round and subsequently cooperates if the number of
    cooperators in the previous round exceeds half of all players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        sum_opponent_C = np.sum(opponent_actions_prev)
        my_action_prev = history.my_actions[previous_round]
        total_C = sum_opponent_C + (1 if my_action_prev else 0)
        threshold = self.game_description.n_players / 2
        if total_C > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_78(BaseStrategy):
    """
    A strategy that begins by cooperating and subsequently cooperates if at least k players contributed in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_coop = history.my_actions[-1]
        opp_coops = sum(history.opponent_actions[-1, :])
        total_coop = opp_coops + (1 if my_coop else 0)
        if total_coop >= self.k:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_79(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        others_actions = history.opponent_actions[prev_round, :]
        sum_others = np.sum(others_actions)
        n_others = self.game_description.n_players - 1
        others_avg = sum_others / n_others
        if others_avg >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_80(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        n = self.game_description.n_players
        max_rounds = min(2, state.round_number)
        recent_rounds = range(max(0, state.round_number - max_rounds), state.round_number)
        rates = []
        for t in recent_rounds:
            my_c = my_actions[t]
            opponent_coop = opponent_actions[t]
            sum_opponent = np.sum(opponent_coop)
            total_c = my_c + sum_opponent
            rate = total_c / n
            rates.append(rate)
        avg_rate = np.mean(rates) if rates else 0.0
        if avg_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_81(BaseStrategy):
    """
    Adaptive Majority-Based Cooperation Strategy.
    
    This strategy cooperates in the first round, defects in the last round,
    and bases its decision in intermediate rounds on whether the majority
    of players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round, :]
        total_cooperators = prev_my_action + np.sum(prev_opponent_actions)
        n_players = self.game_description.n_players
        if total_cooperators > n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_82(BaseStrategy):
    """
    Adaptive Cooperation strategy for N-Player Public Goods Game.
    Balances individual incentives with collective welfare, adapting based on others' actions,
    with noise to prevent exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            return Action.C
        if self.n <= 3:
            return Action.C
        previous_round = state.round_number - 1
        my_contrib = history.my_actions[previous_round]
        opponents_contrib = np.sum(history.opponent_actions[previous_round, :])
        sum_contrib = my_contrib + opponents_contrib
        proportion = sum_contrib / self.n
        if proportion >= 0.5:
            action = Action.C
        else:
            action = Action.D
        if random.random() < 0.1:
            action = Action.C
        return action

class Strategy_COLLECTIVE_83(BaseStrategy):
    """
    Conditional Cooperation Strategy:
    Cooperates in the first round and continues to cooperate in subsequent rounds
    if the number of contributors in the previous round meets or exceeds the threshold k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_contribution = history.my_actions[prev_round]
        opponent_contributions = history.opponent_actions[prev_round, :]
        t_prev = my_contribution + np.sum(opponent_contributions)
        if t_prev >= self.k:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_84(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation while 
    adapting to others' behavior. It uses reciprocity to maintain contributions and 
    defects in the final rounds to maximize personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.next_forced_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        if self.next_forced_action is not None:
            action = Action.C if self.next_forced_action == 'C' else Action.D
            self.next_forced_action = None
            return action
        previous_round = state.round_number - 1
        my_contribution = 1 if history.my_actions[previous_round] else 0
        opponent_contributions = sum(history.opponent_actions[previous_round])
        total_contribution = my_contribution + opponent_contributions
        average = total_contribution / self.game_description.n_players
        if average > 0.5:
            return Action.C
        else:
            self.next_forced_action = 'C'
            return Action.D

class Strategy_COLLECTIVE_85(BaseStrategy):
    """
    A strategy that fosters cooperation through initial cooperation, 
    punishes insufficient contributions, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_c = 1 if my_prev_action else 0
            opponent_c = sum(history.opponent_actions[prev_round, :])
            total_c = my_c + opponent_c
            if total_c >= self.game_description.k:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_86(BaseStrategy):
    """
    A strategy that reciprocates cooperation based on the average contribution of all players.
    Cooperates in the first round. In subsequent rounds, cooperates if at least 50% contributed,
    otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_actions_prev = history.opponent_actions[-1]
        sum_opponent = np.sum(opponent_actions_prev)
        total_coops = sum_opponent + my_prev_action
        avg_contribution = total_coops / self.game_description.n_players
        if avg_contribution >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_87(BaseStrategy):
    """
    A strategy based on collective reciprocity with forgiveness. It starts by cooperating, 
    then reciprocates based on the proportion of cooperators in the previous round relative 
    to a threshold defined by k. If enough players cooperate again after some defection, 
    it switches back to cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        sum_other = history.opponent_actions[prev_round].sum()
        total_cooperators = my_prev_action + sum_other
        threshold = self.game_description.k
        if total_cooperators >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_88(BaseStrategy):
    """
    Adaptive Cooperation Threshold (ACT) Strategy:
    Cooperates in the first round, and in subsequent rounds cooperates if the previous round's
    average contribution is at least 50%. This promotes sustained cooperation while adapting to
    group behavior and allowing forgiveness if cooperation levels improve.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            others_prev_actions = history.opponent_actions[prev_round, :]
            total_c = my_prev_action + np.sum(others_prev_actions)
            average = total_c / self.game_description.n_players
            if average >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_90(BaseStrategy):
    """
    Strategy that cooperates initially and adapts based on comparing average payoffs of cooperators and defectors in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_action_prev = history.my_actions[t_prev]
        opp_actions_prev = history.opponent_actions[t_prev]
        all_actions = np.insert(opp_actions_prev, 0, my_action_prev)
        my_payoff_prev = history.my_payoffs[t_prev]
        opp_payoffs_prev = history.opponent_payoffs[t_prev]
        all_payoffs = np.insert(opp_payoffs_prev, 0, my_payoff_prev)
        c_total = 0.0
        d_total = 0.0
        c_count = 0
        d_count = 0
        for action, payoff in zip(all_actions, all_payoffs):
            if action:
                c_total += payoff
                c_count += 1
            else:
                d_total += payoff
                d_count += 1
        c_avg = c_total / c_count if c_count != 0 else 0.0
        d_avg = d_total / d_count if d_count != 0 else 0.0
        if c_avg > d_avg:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_91(BaseStrategy):
    """
    Adaptive Collective Cooperation with Punishment (ACCP) strategy.
    Cooperates in the first round, uses previous round's cooperation rate for subsequent rounds,
    and assesses overall contribution trend in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        if state.round_number == self.game_description.n_rounds - 1:
            total_c = 0
            for t in range(state.round_number):
                if t < len(history.my_actions) and t < len(history.opponent_actions):
                    my_contrib = 1 if history.my_actions[t] else 0
                    opponent_contrib = sum(history.opponent_actions[t, :])
                    sum_c = my_contrib + opponent_contrib
                    total_c += sum_c
            avg_c = total_c / (state.round_number * n_players) if state.round_number * n_players != 0 else 0
            return Action.C if avg_c >= 0.5 else Action.D
        else:
            prev_round = state.round_number - 1
            my_contrib = 1 if history.my_actions[prev_round] else 0
            opponent_contrib = sum(history.opponent_actions[prev_round, :])
            sum_c_prev = my_contrib + opponent_contrib
            avg_prev = sum_c_prev / n_players
            return Action.C if avg_prev >= 0.5 else Action.D

class Strategy_COLLECTIVE_92(BaseStrategy):
    """
    Adaptive Cooperator with Punishment (ACAP) Strategy.
    Cooperates initially, then cooperates if the previous round's contribution rate was at least 50%.
    Defects otherwise, with the last round always cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if round_number == 0 or round_number == n_rounds - 1:
            return Action.C
        previous_round = round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round]
        total_coop = my_prev_action + np.sum(opponent_prev_actions)
        threshold = n_players / 2.0
        if total_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_93(BaseStrategy):
    """
    A strategy for the N-player public goods game that encourages cooperation 
    while penalizing defection. It starts with cooperation, monitors the group's 
    cooperation rate, and defects for a penalty period if the rate falls below a 
    threshold. The strategy adapts in the last round based on overall cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.cooperation_threshold = 0.5
        self.penalty_duration = 2
        self.in_penalty = False
        self.penalty_remaining = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.in_penalty:
            self.penalty_remaining -= 1
            if self.penalty_remaining <= 0:
                self.in_penalty = False
                self.penalty_remaining = 0
            return Action.D
        elif state.round_number == self.n_rounds - 1:
            total_coop = 0
            for round in range(state.round_number):
                my_action = history.my_actions[round]
                opponent_actions = history.opponent_actions[round, ...]
                total_coop += (1 if my_action else 0) + np.sum(opponent_actions)
            total_actions = state.round_number * self.n_players
            average_coop = total_coop / total_actions if total_actions > 0 else 1.0
            if average_coop >= self.cooperation_threshold:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, ...]
            total_coop_prev = (1 if my_prev_action else 0) + np.sum(opp_prev_actions)
            rate_prev = total_coop_prev / self.n_players
            if rate_prev < self.cooperation_threshold:
                self.in_penalty = True
                self.penalty_remaining = self.penalty_duration
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_94(BaseStrategy):
    """
    A strategy for the Public Goods Game that encourages cooperation based on others' contributions.
    Cooperates initially, defects if contributions are too low, but can forgive and resume cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round == 0:
            self.last_action = Action.C
            return Action.C
        if current_round == r - 1:
            self.last_action = Action.D
            return Action.D
        prev_round = current_round - 1
        prev_opponent_actions = history.opponent_actions[prev_round, :]
        sum_prev = sum(prev_opponent_actions)
        avg_prev = sum_prev / (n - 1) if n - 1 != 0 else 0.0
        if self.last_action == Action.D:
            prev_prev_round = current_round - 2
            if prev_prev_round >= 0 and prev_prev_round < len(history.opponent_actions):
                prev_prev_actions = history.opponent_actions[prev_prev_round, :]
                sum_prev_prev = sum(prev_prev_actions)
                avg_prev_prev = sum_prev_prev / (n - 1) if n - 1 != 0 else 0.0
            else:
                avg_prev_prev = 0.0
            if avg_prev > avg_prev_prev:
                action = Action.C
            else:
                action = Action.D
        elif avg_prev >= 0.5:
            action = Action.C
        else:
            action = Action.D
        self.last_action = action
        return action

class Strategy_COLLECTIVE_95(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy.
    Cooperates initially and in subsequent rounds if the average contribution
    in the last few rounds is sufficiently high; defects otherwise.
    Always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.window_size = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        if current_round == r - 1:
            return Action.D
        window_size = self.window_size
        available_rounds = min(window_size, current_round)
        start_round = max(0, current_round - window_size)
        total_contributions = 0
        for s in range(start_round, current_round):
            my_contrib = 1 if history.my_actions[s] else 0
            opponent_contrib = np.sum(history.opponent_actions[s, :])
            total_contributions += my_contrib + opponent_contrib
        avg_contrib = total_contributions / (n * available_rounds)
        if avg_contrib >= 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_96(BaseStrategy):
    """
    Public Goods Game "k-Threshold Cooperation" strategy.
    Cooperates if the number of contributors in the previous round meets or exceeds k.
    Initiates cooperation in the first round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        sum_coop = int(my_prev_action) + opponent_actions_prev.sum()
        if sum_coop >= self.game_description.k:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_97(BaseStrategy):
    """
    Implementation of the Adaptive Forgiver strategy for the Public Goods Game.
    Cooperates initially, then adapts based on the number of contributors in previous rounds.
    Defects if contributions fall below 50%, forgives when contributions rebound, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            count = history.my_actions[prev_round] + np.sum(history.opponent_actions[prev_round])
            if count * 2 >= self.game_description.n_players:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_98(BaseStrategy):
    """
    A strategy that starts with cooperation, defects when cooperation falls below 70%, 
    forgives once, and defects in the last three rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.state = 'cooperate'

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round >= self.n_rounds - 3:
            return Action.D
        prev_round = current_round - 1
        if prev_round < 0:
            return Action.D
        opp_actions_prev = history.opponent_actions[prev_round, :]
        opp_coop_prev = np.sum(opp_actions_prev)
        my_prev_action = history.my_actions[prev_round]
        total_coop_prev = opp_coop_prev + (1 if my_prev_action else 0)
        if opp_coop_prev == 0:
            return Action.D
        threshold = 0.7 * self.n_players
        if self.state == 'defected':
            if total_coop_prev >= threshold:
                self.state = 'cooperate'
                return Action.C
            else:
                return Action.D
        elif total_coop_prev >= threshold:
            return Action.C
        else:
            self.state = 'defected'
            return Action.D

class Strategy_COLLECTIVE_100(BaseStrategy):
    """
    A strategy that cooperates in the first round, and in subsequent rounds 
    cooperates if at least half of the players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        opponent_actions = history.opponent_actions[last_round, :]
        opponent_coops = sum(opponent_actions)
        my_coop = history.my_actions[last_round]
        total_coops = opponent_coops + (1 if my_coop else 0)
        threshold = self.game_description.n_players // 2
        if total_coops >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_101(BaseStrategy):
    """
    Adaptive Collective Reciprocity Strategy:
    Cooperates initially, defects in the last round, and reciprocates based on the group's average cooperation rate in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            t_prev = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[t_prev]
            opponent_coop = np.sum(opponent_actions_prev)
            my_prev_action = history.my_actions[t_prev]
            my_coop = 1 if my_prev_action else 0
            total_coop = opponent_coop + my_coop
            avg_coop = total_coop / self.game_description.n_players
            return Action.C if avg_coop > 0.5 else Action.D

class Strategy_COLLECTIVE_102(BaseStrategy):
    """
    Adaptive Collective Contribution (ACC) Strategy for Public Goods Game.
    Cooperates in the first round. In subsequent rounds, cooperates if the average
    contribution of all other players in the previous round is above 0.5;
    otherwise, defects. Forgiveness is inherent in adapting based on others' contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        sum_other_c = np.sum(opponent_actions_prev)
        n_other = self.game_description.n_players - 1
        avg_other = sum_other_c / n_other
        if avg_other > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_103(BaseStrategy):
    """
    Public Goods Game Strategy: Adaptive Contributions Based on Previous Round's Total.
    
    This strategy encourages cooperation by starting with a cooperative action, then
    adapting based on the total contributions from all players in the previous round.
    In the final round, it defects to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        others_prev = history.opponent_actions[prev_round, :]
        t = (1 if my_prev else 0) + np.sum(others_prev)
        if t >= self.game_description.k:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_104(BaseStrategy):
    """
    Threshold-Based Cooperation with Endgame Defection strategy for N-Player Public Goods Game.
    Contribute initially, continue if previous round's contributions exceed n/k, defect in last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            prev_contributors = 0
            if history is not None:
                my_contribution = history.my_actions[prev_round]
                opponent_contributions = np.sum(history.opponent_actions[prev_round, :])
                prev_contributors = my_contribution + opponent_contributions
            threshold = self.game_description.n_players / self.game_description.k
            if prev_contributors > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_105(BaseStrategy):
    """
    Strategy that begins by Cooperating, then reciprocates based on the previous round's cooperative behavior.
    Forgiveness is incorporated by re-initiating cooperation if group cooperation levels are satisfactory.
    In the last round, the strategy decides based on the majority of previous rounds' cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            m = state.round_number
            coop_count = 0
            for round_num in range(m):
                my_coop = history.my_actions[round_num]
                opponent_coop = np.sum(history.opponent_actions[round_num, :])
                total_coop = my_coop + opponent_coop
                if total_coop >= self.n_players / 2:
                    coop_count += 1
            if coop_count > m // 2:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_coop_prev = history.my_actions[prev_round]
            opponent_coop_prev = np.sum(history.opponent_actions[prev_round, :])
            total_coop_prev = my_coop_prev + opponent_coop_prev
            if total_coop_prev / self.n_players >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_106(BaseStrategy):
    """
    Optimistic Reciprocation Strategy for Public Goods Game:
    Cooperates initially, reciprocates based on average contribution rates,
    and adapts dynamically to foster cooperation while defending against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            t = state.round_number
            count_acr_over_half = 0
            n_players = self.game_description.n_players
            for s in range(t):
                my_action = history.my_actions[s]
                my_c = 1 if my_action else 0
                their_actions = history.opponent_actions[s, :]
                their_c = sum(their_actions)
                total_c = my_c + their_c
                acr = total_c / n_players
                if acr >= 0.5:
                    count_acr_over_half += 1
            if count_acr_over_half > t / 2:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_c_prev = 1 if my_prev_action else 0
            their_prev_actions = history.opponent_actions[prev_round, :]
            their_c_prev = sum(their_prev_actions)
            total_c_prev = my_c_prev + their_c_prev
            prev_acr = total_c_prev / self.game_description.n_players
            if prev_acr >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_107(BaseStrategy):
    """
    Implements a strategy for the Public Goods Game combining initial cooperation, reciprocal behavior, 
    and a punishment mechanism. The strategy promotes cooperation, punishes defection, and adapts based 
    on group dynamics.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.in_punishment = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            sum_me = sum(history.my_actions)
            sum_opp = history.opponent_actions.sum()
            t = state.round_number
            past_rounds = t
            total_contrib = sum_me + sum_opp
            avg = total_contrib / (self.game_description.n_players * past_rounds)
            if avg >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            sum_me = sum(history.my_actions)
            sum_opp = history.opponent_actions.sum()
            t = state.round_number
            past_rounds = t
            total_contrib = sum_me + sum_opp
            avg = total_contrib / (self.game_description.n_players * past_rounds)
            if avg < 0.5:
                if not self.in_punishment:
                    self.in_punishment = True
                return Action.D
            else:
                if self.in_punishment:
                    self.in_punishment = False
                last_me = history.my_actions[-1]
                last_opp = history.opponent_actions[-1]
                n_coop_last = sum(last_opp) + (1 if last_me else 0)
                n_players = self.game_description.n_players
                if n_coop_last > n_players / 2:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_108(BaseStrategy):
    """
    A collective strategy for the public goods game that encourages cooperation, 
    punishes defection, and allows for recovery.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_coop_prev = history.my_actions[history.my_actions.size - 1]
            opponent_actions_prev = history.opponent_actions[history.opponent_actions.shape[0] - 1, :]
            sum_coop_prev = my_coop_prev + np.sum(opponent_actions_prev)
            if sum_coop_prev == 0:
                return Action.C
            else:
                avg = sum_coop_prev / self.game_description.n_players
                if avg > 0.5:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_109(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and punishment.
    Cooperates initially, reciprocates cooperation, punishes defectors, and adjusts in endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.is_punishing = False
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.C
        if current_round >= n_rounds - 3:
            sum_coop = 0
            for r in range(current_round):
                my_c = int(history.my_actions[r])
                others_c = sum(history.opponent_actions[r, :])
                sum_coop += my_c + others_c
            total_rounds = current_round
            avg_coop = sum_coop / (n_players * total_rounds)
            if avg_coop >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            prev_coop = int(history.my_actions[current_round - 1])
            prev_coop_opponents = sum(history.opponent_actions[current_round - 1, :])
            prev_coop_total = prev_coop + prev_coop_opponents
            if prev_coop_total >= n_players * 0.5:
                self.is_punishing = False
                self.punishment_remaining = 0
                return Action.C
            elif not self.is_punishing:
                self.is_punishing = True
                self.punishment_remaining = 3
                return Action.D
            else:
                prev_prev_coop = int(history.my_actions[current_round - 1])
                prev_prev_opponents = sum(history.opponent_actions[current_round - 1, :])
                prev_prev_total = prev_prev_coop + prev_prev_opponents
                if prev_prev_total >= n_players * 0.5:
                    self.is_punishing = False
                    self.punishment_remaining = 0
                    return Action.C
                else:
                    self.punishment_remaining -= 1
                    if self.punishment_remaining <= 0:
                        self.is_punishing = False
                    return Action.D

class Strategy_COLLECTIVE_110(BaseStrategy):
    """
    Conditional Cooperation with Punishment and Forgiveness Strategy.
    Cooperates initially, then reciprocates others' cooperation level with
    a forgiveness mechanism, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            prev_actions = history.opponent_actions[prev_round, :]
            sum_c = np.sum(prev_actions)
            n_others = self.game_description.n_players - 1
            avg = sum_c / n_others
            if avg >= 0.5:
                return Action.C
            elif random.random() < 0.2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_111(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.
    Cooperates initially, defects in the last round, and adapts based on others' cooperation rate.
    Includes a forgiveness mechanism to re-establish cooperation when group dynamics improve.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        others_coop = sum(history.opponent_actions[previous_round, :])
        num_opponents = self.n_players - 1
        others_coop_rate = others_coop / num_opponents if num_opponents > 0 else 0.0
        if others_coop_rate >= 0.5:
            return Action.C
        else:
            my_action_t1 = history.my_actions[previous_round]
            my_action_t1_bool = my_action_t1 == Action.C
            group_coop_t1 = (my_action_t1_bool + sum(history.opponent_actions[previous_round, :])) / self.n_players
            if previous_round >= 1:
                my_action_t2 = history.my_actions[previous_round - 1]
                my_action_t2_bool = my_action_t2 == Action.C
                opponent_actions_t2 = history.opponent_actions[previous_round - 1, :]
                group_coop_t0 = (my_action_t2_bool + sum(opponent_actions_t2)) / self.n_players
            else:
                group_coop_t0 = 0.0
            if group_coop_t1 >= 0.5 and group_coop_t1 > group_coop_t0:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_112(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy.
    Cooperates initially and in subsequent rounds mirrors the majority's previous actions, defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1, :]
        total_coop = prev_my_action + np.sum(prev_opponent_actions)
        n_players = self.game_description.n_players
        if total_coop > n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_113(BaseStrategy):
    """
    Collective Reciprocity Strategy for Public Goods Game:
    - Cooperates initially.
    - Reciprocates based on the previous round's contributions, defecting if less than 50% cooperated.
    - Forgives and reverts to cooperation if contributions rebound after a decline.
    - Maximizes payoff in the final round if preceded by full cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        if history is None:
            return Action.C
        if current_round == n_rounds - 1:
            prev_round = current_round - 1
            prev_my_action = history.my_actions[prev_round]
            prev_opp_actions = history.opponent_actions[prev_round, :]
            total_prev_c = sum(prev_opp_actions) + (1 if prev_my_action else 0)
            if total_prev_c == n_players:
                return Action.C
            else:
                contribution_ratio = total_prev_c / n_players
                if contribution_ratio >= 0.5:
                    return Action.C
                else:
                    return Action.D
        else:
            prev_round = current_round - 1
            prev_my_action = history.my_actions[prev_round]
            prev_opp_actions = history.opponent_actions[prev_round, :]
            total_prev_c = sum(prev_opp_actions) + (1 if prev_my_action else 0)
            contribution_ratio = total_prev_c / n_players
            if contribution_ratio >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_114(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that starts with cooperation and adapts based on the number 
    of contributors in the previous round. It cooperates if the total contributions exceed n/k and defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        sum_opponents = np.sum(history.opponent_actions[prev_round, :])
        total_contributions = int(my_prev_action) + sum_opponents
        threshold = self.game_description.n_players / self.game_description.k
        if total_contributions > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_115(BaseStrategy):
    """
    A strategy that encourages cooperation while protecting against exploitation,
    adapting based on past contributions and game parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        my_last_action = history.my_actions[-1]
        my_last_contribution = 1 if my_last_action else 0
        opponent_last_actions = history.opponent_actions[-1, :]
        opponent_contributions = sum(opponent_last_actions)
        total_contributions = my_last_contribution + opponent_contributions
        threshold = self.game_description.n_players / self.game_description.k
        if total_contributions >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_116(BaseStrategy):
    """
    A strategy for the Public Goods Game that adapts based on previous round's cooperation level.
    Cooperates initially, then continues if previous round's average contribution was at least 50%.
    Defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            prev_my_action = history.my_actions[prev_round]
            prev_opponent_actions = history.opponent_actions[prev_round]
            total_coop = 1 if prev_my_action else 0
            total_coop += np.sum(prev_opponent_actions)
            avg_coop = total_coop / self.game_description.n_players
            if avg_coop >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_117(BaseStrategy):
    """
    Conditional Cooperate Strategy.
    Cooperates in the first round. In subsequent rounds, cooperates if the average contribution 
    in the previous round was at least 0.5, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        my_contribution = int(my_prev_action)
        opponents_contribution = np.sum(opponents_prev_actions)
        total_cooperators = my_contribution + opponents_contribution
        avg_contribution = total_cooperators / self.n_players
        if avg_contribution >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_118(BaseStrategy):
    """
    A strategy where the player Cooperates if at least half of the players (including themselves) Cooperated in the previous round; otherwise, Defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round]
        sum_opponent_coop = np.sum(opponent_actions_prev)
        total_coop_prev = sum_opponent_coop + my_prev_action
        threshold = self.game_description.n_players // 2
        if total_coop_prev >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_119(BaseStrategy):
    """
    Strategy: Adaptive Reciprocity with Endgame Adjustment
    - Cooperates in the first round.
    - Defects in the last round.
    - Cooperates if in the previous round a majority of players cooperated and no player defected.
    - Defects if any player defected in the previous round or the majority did not cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            my_defected = not my_prev_action
            sum_opponent_Ds = np.sum(1 - opp_prev_actions)
            any_opponent_defected = sum_opponent_Ds > 0
            any_defected = my_defected or any_opponent_defected
            if any_defected:
                return Action.D
            else:
                my_coop = 1 if my_prev_action else 0
                opponents_coop = np.sum(opp_prev_actions)
                total_coop = my_coop + opponents_coop
                majority_threshold = math.ceil(self.game_description.n_players / 2)
                if total_coop >= majority_threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_120(BaseStrategy):
    """
    Cooperative Reciprocity with Forgiveness and Endgame Adaptation strategy.
    Cooperates initially, reciprocates with defection when others defect, forgives,
    and adapts in endgame rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        r = self.game_description.n_rounds
        n = self.game_description.n_players
        if current_round in (r - 2, r - 1):
            if history is None:
                return Action.C
            if current_round == r - 2:
                prev_rounds = current_round
                opp_actions = history.opponent_actions[:prev_rounds, :] if prev_rounds > 0 else history.opponent_actions
                cooperation_rates = np.mean(opp_actions, axis=0)
                opponents_below_half = np.sum(cooperation_rates < 0.5)
                if opponents_below_half >= (n - 1) / 2:
                    return Action.D
                return Action.C
            else:
                prev_rounds = current_round
                opp_actions = history.opponent_actions[:prev_rounds, :] if prev_rounds > 0 else history.opponent_actions
                total_c_per_opponent = np.sum(opp_actions, axis=0)
                average = np.mean(total_c_per_opponent)
                if average >= 0.5:
                    return Action.C
                else:
                    return Action.D
        else:
            prev_round = current_round - 1
            if history is None or prev_round < 0:
                return Action.C
            all_coop_prev = True
            my_prev_action = history.my_actions[prev_round]
            if not my_prev_action:
                all_coop_prev = False
            for opp_action in history.opponent_actions[prev_round, :]:
                if not opp_action:
                    all_coop_prev = False
                    break
            if all_coop_prev:
                return Action.C
            if not my_prev_action:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_121(BaseStrategy):
    """
    A strategy that promotes cooperation based on majority contribution in previous rounds.
    Cooperates in the first round and continues if at least 50% of players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_round = state.round_number - 1
            my_prev = history.my_actions[last_round]
            opp_prev = history.opponent_actions[last_round]
            total_c = int(my_prev) + int(opp_prev.sum())
            threshold = self.game_description.n_players / 2.0
            if total_c >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_122(BaseStrategy):
    """
    Adaptive Cooperation with Punishment and Forgiveness strategy. 
    Cooperates initially, punishes when contributions drop below 50%, and forgives when cooperation resumes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        r_prev = state.round_number - 1
        my_contrib = int(history.my_actions[r_prev])
        opponents_contrib = history.opponent_actions[r_prev].sum()
        total_contrib = my_contrib + opponents_contrib
        n = self.game_description.n_players
        average = total_contrib / n
        if average > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_123(BaseStrategy):
    """
    Conditional Cooperation Based on Contribution Threshold (CCCT)
    Strategy that cooperates if the number of contributors in the previous round meets or exceeds k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_contrib = 1 if history.my_actions[previous_round] else 0
        opponents_contrib = sum(history.opponent_actions[previous_round, :])
        total_contrib = my_contrib + opponents_contrib
        if total_contrib >= self.game_description.k:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_124(BaseStrategy):
    """Group-Reciprocity with Threshold (GRT) Strategy implementation."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = current_round - 1
            my_last = history.my_actions[prev_round]
            opponent_last = history.opponent_actions[prev_round]
            total_coop = my_last + sum(opponent_last)
            threshold = self.n_players / 2.0
            if total_coop >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_125(BaseStrategy):
    """
    Cooperative Punisher with Consistency strategy for Public Goods Game.

    Cooperates in the first round. In subsequent rounds, contributes if the average
    contribution meets the threshold k/n; otherwise, defects to encourage higher
    contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        sum_c = int(my_prev_action) + np.sum(opponents_prev_actions)
        if sum_c >= self.k:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_127(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy.
    Cooperates if previous round had at least 50% cooperation, otherwise defects.
    After defecting, cooperates again in the next round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        else:
            previous_round = state.round_number - 1
            if history is None or previous_round >= len(history.my_actions):
                return Action.D
            sum_coop_prev = sum(history.opponent_actions[previous_round, :]) + (1 if history.my_actions[previous_round] else 0)
            n_players = self.game_description.n_players
            threshold = n_players / 2
            if self.last_action == Action.D:
                current_action = Action.C
            elif sum_coop_prev >= threshold:
                current_action = Action.C
            else:
                current_action = Action.D
            self.last_action = current_action
            return current_action

class Strategy_COLLECTIVE_128(BaseStrategy):
    """
    Strategy implementing Collective Reciprocity with Adaptive Threshold.
    Cooperates if the average contribution meets or exceeds k/n.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.r = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        threshold = self.k / self.n
        if current_round == self.r - 1:
            my_contrib = sum(history.my_actions)
            opponent_contrib = history.opponent_actions.sum()
            sum_total = my_contrib + opponent_contrib
            m = current_round
            avg = sum_total / (self.n * m)
        else:
            prev_my = history.my_actions[-1]
            prev_opponents = history.opponent_actions[-1]
            sum_prev = prev_my + prev_opponents.sum()
            avg = sum_prev / self.n
        if avg >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_1(BaseStrategy):
    """
    Adaptive Exploitation in Public Goods Game.
    
    This strategy starts by cooperating to encourage initial cooperation. 
    It then adaptively decides based on the average contribution rate and 
    recent majority behavior, with a consideration for inconsistent opponent 
    behavior, defecting in the last round to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        opponent_actions = history.opponent_actions
        opp_interest = opponent_actions[:prev_round + 1, :]
        inconsistent = False
        for opp_idx in range(opp_interest.shape[1]):
            actions = opp_interest[:, opp_idx]
            if len(actions) < 2:
                changes = 0
            else:
                changes = np.sum(actions[1:] != actions[:-1])
            if changes > 2:
                inconsistent = True
                break
        if inconsistent:
            return Action.D
        my_prev_action = history.my_actions[prev_round]
        prev_opponents = opponent_actions[prev_round]
        sum_others = np.sum(prev_opponents)
        sum_contrib = my_prev_action + sum_others
        average = sum_contrib / self.n_players
        if average > 0.5:
            return Action.C
        elif sum_contrib > self.n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_2(BaseStrategy):
    """
    Adaptive Cooperation with Final Round Defection Strategy.

    This strategy starts by cooperating in the first round. In subsequent rounds, it cooperates if the average contribution in the previous round exceeds 50% and defects otherwise. The strategy defects in the final round to maximize personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_my_action = history.my_actions[-1]
            prev_opponent_actions = history.opponent_actions[-1]
            sum_c = prev_my_action + np.sum(prev_opponent_actions)
            avg_c = sum_c / self.game_description.n_players
            if avg_c > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_3(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACPP) strategy. 
    Cooperates initially, then cooperates if others' contribution is above 50%, 
    defects otherwise apart from the final round where it always cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions = history.opponent_actions[prev_round]
        n_coop = sum(opponent_actions)
        avg = n_coop / (self.game_description.n_players - 1)
        if avg > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_4(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) strategy for the N-Player Public Goods Game.
    Cooperates if the average contribution rate is 50% or higher in the previous round,
    except in the last round where it considers the majority of all previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            count_majority = 0
            for t in range(current_round):
                my_action = history.my_actions[t]
                opp_actions = history.opponent_actions[t]
                total_coop = my_action + sum(opp_actions)
                avg = total_coop / n_players
                if avg >= 0.5:
                    count_majority += 1
            majority_required = current_round / 2
            if count_majority >= majority_required:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = current_round - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round]
            total_coop_prev = my_prev_action + sum(opp_prev_actions)
            avg_prev = total_coop_prev / n_players
            if avg_prev >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_5(BaseStrategy):
    """
    An exploitative strategy in the N-player public goods game. 
    The strategy starts by cooperating in the first round, defects in the last round, 
    and uses the average cooperation rate of others to decide actions in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prior_rounds = state.round_number
            n_opponents = self.game_description.n_players - 1
            opponent_actions = history.opponent_actions[:prior_rounds, :]
            total_contributions = np.sum(opponent_actions)
            avg_others_c = total_contributions / (prior_rounds * n_opponents)
            if avg_others_c > 0.5:
                return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_6(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        in_endgame = state.round_number >= self.n_rounds - 3
        if in_endgame:
            endgame_rounds = min(3, state.round_number)
            start = max(0, state.round_number - endgame_rounds)
            others_in_endgame = history.opponent_actions[start:state.round_number]
            others_avg = np.mean(others_in_endgame)
            if others_avg >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            prev_my_action = history.my_actions[state.round_number - 1]
            prev_others_actions = history.opponent_actions[state.round_number - 1]
            prev_others_avg = np.mean(prev_others_actions)
            if prev_my_action and prev_others_avg < 0.5:
                return Action.D
            else:
                opponents_so_far = history.opponent_actions[:state.round_number]
                others_avg = np.mean(opponents_so_far)
                if others_avg >= 0.5:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_7(BaseStrategy):
    """
    An exploitative strategy for the Public Goods Game that balances cooperation and exploitation.
    Cooperates in the first round, then adapts based on others' cooperation rate, defecting if the rate
    exceeds a threshold (0.5). Defects in the final round to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_opponent_actions = history.opponent_actions[-1, :]
            n_opponents = self.game_description.n_players - 1
            sum_coop = np.sum(prev_opponent_actions)
            avg_coop = sum_coop / n_opponents
            if avg_coop > self.threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_8(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy.

    This strategy starts by cooperating in the first round. In subsequent rounds, 
    it calculates a cooperation threshold based on the game parameters and the 
    average cooperation rate of all players. If the average meets or exceeds the 
    threshold, the player cooperates; otherwise, they defect. In the last 5% of 
    rounds, the player always defects to maximize their gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        r = self.n_rounds
        cutoff_round = math.ceil(0.95 * r)
        if state.round_number >= cutoff_round:
            return Action.D
        n = self.n_players
        T = self.k / (n + 1)
        sum_my = history.my_actions[:state.round_number].sum()
        sum_opponents = history.opponent_actions[:state.round_number, :].sum()
        total_c = sum_my + sum_opponents
        average = total_c / (state.round_number * n)
        if average >= T:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_9(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game. Starts with cooperation,
    defects in the last round, and bases middle round decisions on the previous round's
    contributions using a threshold of (k/n) * previous contributors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round]
        m = int(my_prev) + opponents_prev.sum()
        k = self.game_description.k
        n = self.game_description.n_players
        if k * m / n >= 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_10(BaseStrategy):
    """
    The Adaptive Exploiter strategy for the Public Goods Game.
    Cooperates initially, then adapts based on others' contributions.
    Defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            t_prev = state.round_number
            n_opponents = self.n_players - 1
            sum_contributions = np.sum(history.opponent_actions)
            average_contribution = sum_contributions / (n_opponents * t_prev)
            threshold = (self.n_players - self.k) / self.n_players
            if average_contribution >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_11(BaseStrategy):
    """
    Adaptive Cooperate-or-Defect strategy for the N-Player Public Goods Game.

    The strategy starts by Cooperating in the first round, defects in the last round,
    and decides based on the contribution average of all players in the previous round
    for the intermediate rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round]
            average_contribution = (my_prev_action + np.sum(opp_prev_actions)) / self.game_description.n_players
            threshold = 1.0 / self.game_description.k
            if average_contribution >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_12(BaseStrategy):
    """
    An exploitative strategy for the Public Goods Game that balances cooperation and punishment to maximize payoffs.
    Cooperates initially, then adapts based on others' contributions, punishes insufficient cooperation, and reverts after punishment.
    Defects in the final round to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (game_description.n_players - 1) // 2 + 1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_actions_last_round = history.opponent_actions[-1]
        last_coop_count = np.sum(opponent_actions_last_round)
        if last_coop_count >= self.m:
            return Action.C
        elif not history.my_actions[-1]:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_13(BaseStrategy):
    """
    A strategy for the Public Goods Game that balances cooperation and defection based on past contributions.
    It starts with cooperation, adapts based on the majority's past actions, and defects in the final round.
    Uses a moving average of past contributions to determine cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            sum_props = 0.0
            for round_idx in range(state.round_number):
                my_coop = history.my_actions[round_idx]
                opponent_coop = np.sum(history.opponent_actions[round_idx, :])
                total_coop = int(my_coop) + opponent_coop
                prop = total_coop / self.game_description.n_players
                sum_props += prop
            avg_prop = sum_props / state.round_number
            if avg_prop >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_14(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game.
    - Cooperates in the first round.
    - In subsequent rounds, cooperates if the average contribution of other players in the previous round exceeds 50%, otherwise defects.
    - Defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        sum_last_round = np.sum(history.opponent_actions[-1])
        n_other_players = self.game_description.n_players - 1
        if sum_last_round / n_other_players > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_15(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            sum_coop = int(my_prev_action) + np.count_nonzero(opponents_prev_actions)
            avg = sum_coop / self.game_description.n_players
            if avg >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_16(BaseStrategy):
    """
    A strategy designed to adapt based on the majority of previous contributions and relative payoff.
    Cooperates initially, defects in the last round, and adjusts based on majority and average payoff in middle rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            sum_opponents_coop = np.sum(history.opponent_actions[-1])
            my_coop_last = 1 if history.my_actions[-1] else 0
            sum_coop_last_round = sum_opponents_coop + my_coop_last
            majority_last = sum_coop_last_round > self.game_description.n_players // 2
            sum_opponent_payoffs = np.sum(history.opponent_payoffs[-1])
            my_last_payoff = history.my_payoffs[-1]
            sum_group_payoff = sum_opponent_payoffs + my_last_payoff
            average_payoff = sum_group_payoff / self.game_description.n_players
            if majority_last and my_last_payoff > average_payoff:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_17(BaseStrategy):
    """
    Adaptive Contributor strategy for N-Player Public Goods Game.
    Cooperates initially, defects in the last round, and adapts based on others' contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.punishment_active = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif self.punishment_active:
            return Action.D
        else:
            my_prev_action = history.my_actions[-1]
            if my_prev_action:
                return Action.D
            else:
                sum_others = np.sum(history.opponent_actions[-1])
                avg = sum_others / (self.n_players - 1)
                if avg < 0.3:
                    self.punishment_active = True
                    return Action.D
                elif avg > 0.5:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_18(BaseStrategy):
    """
    Adaptive Contribution Strategy for Public Goods Game.

    This strategy starts by Cooperating in the first round. In subsequent rounds,
    it calculates the average contribution rate over the last 3 rounds. If the
    average is above 50%, it Cooperates; otherwise, it Defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = 3

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        start_round = max(0, state.round_number - self.m)
        end_round = state.round_number - 1
        total_rounds = end_round - start_round + 1
        sum_c = 0.0
        for r in range(start_round, end_round + 1):
            my_contrib = history.my_actions[r]
            opponents_contrib = np.sum(history.opponent_actions[r, :])
            sum_c += my_contrib + opponents_contrib
        if total_rounds == 0:
            avg_contrib = 0.0
        else:
            avg_contrib = sum_c / (total_rounds * self.n_players)
        if avg_contrib > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_19(BaseStrategy):
    """
    Adaptive Cooperate-to-Defect strategy for the Public Goods Game.
    
    This strategy begins cooperatively and adapts based on others' actions,
    defecting in the final round to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opp_actions_prev = history.opponent_actions[prev_round, :]
            cooperators = np.sum(opp_actions_prev)
            n_opponents = self.game_description.n_players - 1
            average_contribution = cooperators / n_opponents
            if average_contribution >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_20(BaseStrategy):
    """
    Exploitative Adaptor strategy for the N-Player Public Goods Game.
    Dynamically adjusts contributions based on the majority behavior of other players.
    Defects in the first and last rounds, and adapts behavior in intermediate rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            my_last_action = history.my_actions[previous_round]
            opponent_actions = history.opponent_actions[previous_round, :]
            total_c = my_last_action + np.sum(opponent_actions)
            n_players = self.game_description.n_players
            if total_c > n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_21(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game that 
    contributes initially and adapts based on the previous round's public good benefit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        sum_prev = history.my_actions[prev_round] + np.sum(history.opponent_actions[prev_round])
        average_benefit = self.game_description.k / self.game_description.n_players * sum_prev
        if average_benefit > 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_22(BaseStrategy):
    """
    A strategy that follows initial cooperation, cooperation if average contribution is above 50%, 
    defecting otherwise. Punishes non-cooperators by defecting if contributions have been below 
    50% for three consecutive rounds. Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_below = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round]
        total_C = my_prev_action + np.sum(opponent_prev_actions)
        average = total_C / self.game_description.n_players
        if average > 0.5:
            self.consecutive_below = 0
            return Action.C
        else:
            self.consecutive_below += 1
            if self.consecutive_below >= 3:
                action = Action.D
                self.consecutive_below = 0
            else:
                action = Action.D
            return action

class Strategy_EXPLOITATIVE_23(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on the average contributions of others, 
    and defects in the final round to maximize individual payoff in a repeated Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            sum_contrib = 0
            n_prev_rounds = state.round_number
            for s in range(n_prev_rounds):
                my_coop = int(history.my_actions[s])
                opponent_coop = np.sum(history.opponent_actions[s, :])
                sum_contrib += my_coop + opponent_coop
            average_contrib = sum_contrib / n_prev_rounds
            threshold = self.game_description.n_players / self.game_description.k
            if average_contrib >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_24(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy.

    This strategy starts by cooperating in the first round. In subsequent rounds, 
    it cooperates if the average contribution from the previous round meets or 
    exceeds a threshold, which increases by 0.1 if not met. It defects in the 
    last round to maximize personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        prev_my_c = history.my_actions[prev_round]
        opponents_c = history.opponent_actions[prev_round, :].sum()
        total_contributions = prev_my_c + opponents_c
        avg_contribution = total_contributions / self.game_description.n_players
        if avg_contribution >= self.threshold:
            return Action.C
        else:
            self.threshold += 0.1
            return Action.D

class Strategy_EXPLOITATIVE_25(BaseStrategy):
    """Adaptive Exploitative Strategy for Public Goods Game."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            opponent_actions_prev = history.opponent_actions[-1, :]
            opponent_coop = sum(opponent_actions_prev)
            my_last = history.my_actions[-1]
            total_coop = opponent_coop + (1 if my_last else 0)
            avg = total_coop / self.game_description.n_players
            if avg >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_26(BaseStrategy):
    """
    A strategy that starts by Cooperating, then adapts based on the previous round's total contributions,
    Defects in the last round to maximize payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            t_prev = state.round_number - 1
            my_prev = history.my_actions[t_prev]
            opponent_prev = history.opponent_actions[t_prev]
            my_contribution = int(my_prev)
            sum_opp = np.sum(opponent_prev)
            tc_prev = my_contribution + sum_opp
            if tc_prev >= self.k:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_27(BaseStrategy):
    """
    A strategy for the Public Goods Game that initially cooperates, adapts based on others' contributions, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        elif round_number == self.r - 1:
            return Action.D
        else:
            opponent_actions = history.opponent_actions[-1, :]
            sum_others = sum(opponent_actions)
            n_others = self.n - 1
            avg_contribution = sum_others / n_others if n_others != 0 else 0
            threshold = self.k / self.n
            if avg_contribution >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_28(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game that adapts based on the group's past cooperation rate.
    Cooperates initially and continues if the average contribution is at least 50%, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_prev_rounds = state.round_number
        n_players = self.game_description.n_players
        total_contributions = 0.0
        for round_idx in range(n_prev_rounds):
            my_action = history.my_actions[round_idx]
            opponents = history.opponent_actions[round_idx, :]
            my_contrib = 1 if my_action else 0
            opponents_contrib = np.sum(opponents)
            total_contributions += my_contrib + opponents_contrib
        average = total_contributions / (n_prev_rounds * n_players)
        return Action.C if average >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_29(BaseStrategy):
    """
    Gradual Reciprocity with Endgame Exploitation strategy.
    Cooperates initially, retaliates if others defect while it cooperates,
    cooperates if others have contributed more than half on average,
    and defects in the last two rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        if t >= self.n_rounds - 2:
            return Action.D
        my_prev_action = history.my_actions[t - 1]
        opponent_prev_actions = history.opponent_actions[t - 1, :]
        sum_C_prev = np.sum(opponent_prev_actions)
        n_opponents = self.n_players - 1
        if my_prev_action and sum_C_prev < n_opponents:
            return Action.D
        else:
            sum_C_total = np.sum(history.opponent_actions[:t, :])
            avg_C = sum_C_total / (t * n_opponents) if t != 0 else 0
            if avg_C > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_30(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on others' contribution rates.
    Cooperates if others' average contribution exceeds a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        sum_c = np.sum(history.opponent_actions[:t])
        count = (self.n_players - 1) * t
        c_avg = sum_c / count
        threshold = (self.n_players / self.k - 1) / (self.n_players - 1)
        if c_avg > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_31(BaseStrategy):
    """
    This strategy initially cooperates, then retaliates based on others' defections.
    It calculates a threshold based on the game's parameters to decide when to defect.
    In the final round, it always defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.n_rounds = game_description.n_rounds
        self.T = (self.n - self.k) / self.n

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round]
        my_prev_defect = 0 if my_prev_action else 1
        opponent_defect_count = len(opponent_actions_prev) - sum(opponent_actions_prev)
        total_defectors = my_prev_defect + opponent_defect_count
        defection_rate = total_defectors / self.n
        if opponent_defect_count == len(opponent_actions_prev):
            return Action.D
        if defection_rate > self.T:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_32(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on majority previous actions,
    and defects in the final round to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round, :]
            total_coop = sum(opponent_prev_actions) + my_prev_action
            if total_coop > self.n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_33(BaseStrategy):
    """
    Exploitative Strategy for Public Goods Game:
    - Cooperate in the first round.
    - Cooperate in subsequent rounds if previous round's total contributions yield a sufficient payoff (k/n * c_j  1).
    - Defect in the final round.
    Inherits from BaseStrategy, implements __call__ to determine action based on game state and history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            return Action.D
        previous_round = current_round - 1
        my_prev_action = history.my_actions[previous_round]
        my_contribution = 1 if my_prev_action else 0
        opponent_contributions = sum(history.opponent_actions[previous_round])
        total_contrib = my_contribution + opponent_contributions
        threshold = self.k / self.n_players * total_contrib
        if threshold >= 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_34(BaseStrategy):
    """
    Adaptive Cooperate-and-Punish with Forgiveness strategy.
    Cooperates initially, punishes if average contribution is low,
    forgives if others cooperate despite previous punishment,
    and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        n_players = self.game_description.n_players
        my_prev_action = history.my_actions[prev_round]
        my_contribution = 1 if my_prev_action else 0
        sum_opponents = sum(history.opponent_actions[prev_round, :])
        sum_prev = my_contribution + sum_opponents
        avg_prev = sum_prev / n_players
        if avg_prev > 0.5:
            return Action.C
        elif not my_prev_action:
            sum_others_prev = sum_prev
            avg_others_prev = sum_others_prev / (n_players - 1)
            if avg_others_prev > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_35(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game that 
    adapts based on others' previous contributions to maximize personal gain.
    Cooperates initially, follows majority in middle rounds, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            sum_opponent_prev = sum(history.opponent_actions[-1])
            n_other = self.game_description.n_players - 1
            if sum_opponent_prev > n_other / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_36(BaseStrategy):
    """
    A strategy that starts by cooperating, adapts based on the group's past contributions,
    and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        elif t == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_t = t - 1
            my_prev = history.my_actions[prev_t]
            opponents_prev = history.opponent_actions[prev_t, :]
            my_contribution = 1 if my_prev else 0
            opponents_contribution = sum(opponents_prev)
            total_contrib = my_contribution + opponents_contribution
            avg_contrib = total_contrib / self.game_description.n_players
            if avg_contrib > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_37(BaseStrategy):
    """
    Adaptive Exploitation strategy for Public Goods Game.
    Cooperates in the first round, defects in the last round, and in middle rounds,
    cooperates if the average contribution rate is above 50%, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        sum_my_c = history.my_actions.sum()
        sum_opp_c = history.opponent_actions.sum(axis=1).sum()
        total_c = sum_my_c + sum_opp_c
        t_rounds = state.round_number
        average = total_c / (t_rounds * self.n_players)
        if average > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_38(BaseStrategy):
    """
    A threshold-based strategy that cooperates if at least half of the opponents cooperated in the previous round.
    Starts with cooperation in the first round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round_opponent_actions = history.opponent_actions[-1, :]
        num_coop = sum(last_round_opponent_actions)
        threshold = self.game_description.n_players // 2
        if num_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_39(BaseStrategy):
    """
    Cooperative Punisher with Adaptive Learning Strategy.

    This strategy begins by cooperating in the first round to encourage trust.
    In subsequent rounds, it adapts based on the majority's actions:
    - Cooperate if the majority cooperated previously.
    - Defect if the majority defected.
    - In case of an exact tie (50% contribution), cooperate if the previous round's contribution exceeded the historical average.
    The strategy promotes cooperation while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n = self.game_description.n_players
        if current_round == 0:
            return Action.C
        t_prev = current_round - 1
        opp_actions_last = history.opponent_actions[t_prev, :]
        my_action_last = history.my_actions[t_prev]
        cooperators_last = sum(opp_actions_last) + (1 if my_action_last else 0)
        threshold = n / 2
        if cooperators_last > threshold:
            return Action.C
        elif cooperators_last < threshold:
            return Action.D
        else:
            avg_contribution = 0.0
            if t_prev > 0:
                total = 0.0
                for r in range(t_prev):
                    opp_acts = history.opponent_actions[r, :]
                    my_act = history.my_actions[r]
                    coops = sum(opp_acts) + (1 if my_act else 0)
                    total += coops / n
                count = t_prev
                avg_contribution = total / count if count > 0 else 0.0
            current_rate = cooperators_last / n
            if current_rate > avg_contribution:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_40(BaseStrategy):
    """
    A strategy that starts by Cooperating to foster a positive environment, 
    adapts based on the majority's previous actions, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_history = []

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        total_coop_prev = my_prev_action + np.sum(opp_prev_actions)
        majority_coop = total_coop_prev >= self.game_description.n_players / 2
        if majority_coop:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_41(BaseStrategy):
    """
    An adaptive and exploitative strategy for the Public Goods Game.
    Cooperates initially, defects in the last round, and cooperates in subsequent rounds
    based on the average contribution of other players in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            opponent_actions_prev = history.opponent_actions[-1, :]
            sum_C = opponent_actions_prev.sum()
            average = sum_C / (self.game_description.n_players - 1)
            if average > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_42(BaseStrategy):
    """
    Adaptive Exploitation Strategy for N-Player Public Goods Game.
    Cooperates initially, then adapts based on others' contributions, defecting in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            op_actions_prev = history.opponent_actions[prev_round]
            sum_prev = sum(op_actions_prev)
            n_other_players = self.game_description.n_players - 1
            avg_prev = sum_prev / n_other_players
            if avg_prev > self.threshold:
                self.threshold = max(0.0, self.threshold - 0.05)
                return Action.C
            else:
                self.threshold = min(1.0, self.threshold + 0.05)
                return Action.D

class Strategy_EXPLOITATIVE_43(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number % 3 == 0 and state.round_number != 0:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round]
            sum_opp_coop = np.sum(opp_prev_actions)
            total_coop = sum_opp_coop + (1 if my_prev_action else 0)
            avg_coop = total_coop / self.game_description.n_players
            if avg_coop < 0.5:
                return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        total_actions = np.concatenate((opp_prev_actions, [my_prev_action]))
        n_defectors = np.count_nonzero(total_actions == False)
        if n_defectors > self.game_description.n_players / 2:
            return Action.D
        sum_opp_coop = np.sum(opp_prev_actions)
        total_coop = sum_opp_coop + (1 if my_prev_action else 0)
        avg_coop = total_coop / self.game_description.n_players
        if avg_coop > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_44(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Public Goods Game.

    The strategy begins with cooperation, tracks others' contributions, mirrors behavior
    if cooperation is above a threshold, punishes non-cooperation for a set number of rounds,
    forgives if cooperation resumes, and defects in the final round to maximize payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.is_punishing = False
        self.punishment_rounds_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.is_punishing:
            prev_avg = np.mean(history.opponent_actions[-1, :])
            if prev_avg >= self.threshold:
                self.is_punishing = False
                self.punishment_rounds_remaining = 0
            else:
                self.punishment_rounds_remaining -= 1
                if self.punishment_rounds_remaining <= 0:
                    self.is_punishing = False
            return Action.D
        else:
            prev_avg = np.mean(history.opponent_actions[-1, :])
            if prev_avg > self.threshold:
                return Action.C
            else:
                self.is_punishing = True
                self.punishment_rounds_remaining = 2
                return Action.D

class Strategy_EXPLOITATIVE_45(BaseStrategy):
    """
    Adaptive Contribution with Last Round Exploitation strategy for Public Goods Game.
    Cooperates initially, adapts based on others' cooperation, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        round_num = state.round_number
        if round_num == n_rounds - 1:
            return Action.D
        if round_num == 0:
            return Action.C
        prev_round = round_num - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        sum_prev_coop = my_prev_action + np.sum(opponent_prev_actions)
        cooperation_rate = sum_prev_coop / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_46(BaseStrategy):
    """
    A strategy that adapts to others' cooperation by contributing if cooperation is sufficient, 
    defecting otherwise, and always defecting in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            my_coop = 1 if my_prev else 0
            opponent_actions_prev = history.opponent_actions[prev_round]
            opponent_coop = np.sum(opponent_actions_prev)
            total_coop = my_coop + opponent_coop
            avg = total_coop / self.n_players
            if avg >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_47(BaseStrategy):
    """
    Adaptive Cooperation Threshold (ACT) Strategy:
    - Cooperates in the first round.
    - In subsequent rounds, cooperates if the number of cooperators in the previous round meets or exceeds a threshold.
    - The threshold starts at 50% of players and decreases by 10% of the player count each time cooperation falls below it, down to a minimum of 0.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players * 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_round = state.round_number - 1
            my_last_action = history.my_actions[last_round]
            opponent_actions_last_round = history.opponent_actions[last_round]
            my_last_coop = 1 if my_last_action else 0
            opponent_coops = np.sum(opponent_actions_last_round)
            total_coops = my_last_coop + opponent_coops
            if total_coops >= self.threshold:
                return Action.C
            else:
                decrement = 0.1 * self.game_description.n_players
                self.threshold = max(self.threshold - decrement, 0.0)
                return Action.D

class Strategy_EXPLOITATIVE_48(BaseStrategy):
    """
    A strategy for the Public Goods Game that encourages cooperation and adaptively responds to others' behavior.
    Cooperates in the first round, defects in the final round, and cooperates if others' average contribution
    in the previous round meets or exceeds the player's own contribution.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_contribution = 1 if my_prev_action else 0
        others_actions = history.opponent_actions[prev_round, :]
        others_contrib = sum(others_actions)
        n_others = self.n_players - 1
        others_avg = others_contrib / n_others
        if others_avg >= my_contribution:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_49(BaseStrategy):
    """
    Tit for Tat adapted for Public Goods Game. Cooperates initially, continues 
    if enough players contribute, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            total_c = my_prev_action + opp_prev_actions.sum()
            if total_c >= self.k:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_50(BaseStrategy):
    """
    This strategy starts by cooperating in the first round. In subsequent rounds, it cooperates if at least half of the other players cooperated in the previous round; otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        last_actions = history.opponent_actions[last_round, :]
        cooperators = sum(last_actions)
        threshold = self.game_description.n_players // 2
        if cooperators >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_51(BaseStrategy):
    """
    A strategy that starts with cooperation, then reciprocates based on the majority's previous actions, defecting in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            last_round = state.round_number - 1
            my_last_action = history.my_actions[last_round]
            others_actions = history.opponent_actions[last_round, :]
            opponent_coop_count = np.sum(others_actions)
            total_coop = opponent_coop_count + (1 if my_last_action else 0)
            n = self.game_description.n_players
            if total_coop > n / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_52(BaseStrategy):
    """
    A strategy that starts by Cooperating, defects in the last round, 
    and adapts based on the majority's previous round decision.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            their_actions_prev = history.opponent_actions[prev_round]
            total_coop = int(my_prev_action) + their_actions_prev.sum()
            if total_coop > self.n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_53(BaseStrategy):
    """
    Cooperative Punisher with Endgame Defection strategy.
    Cooperates initially, punishes if cooperation drops below 50%, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round]
        total_c = (1 if my_prev_action else 0) + opponents_prev_actions.sum()
        average = total_c / self.game_description.n_players
        if average >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_54(BaseStrategy):
    """
    Adaptive Exploitation in Public Goods Game Strategy.
    
    This strategy starts by cooperating in the first round. In subsequent rounds, it cooperates if the majority of players cooperated in the previous round. In the last round, it cooperates if the average contribution across all players up to the penultimate round is above 0.5.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == r - 1:
            sum_contrib = 0.0
            for t in range(current_round):
                my_action = history.my_actions[t]
                opponent_actions = history.opponent_actions[t, :]
                my_part = 1 if my_action else 0
                sum_opponents = sum(opponent_actions)
                sum_contrib += my_part + sum_opponents
            avg = sum_contrib / current_round
            return Action.C if avg > 0.5 else Action.D
        else:
            t_prev = current_round - 1
            my_prev = history.my_actions[t_prev]
            opponent_prev = history.opponent_actions[t_prev, :]
            my_part = 1 if my_prev else 0
            sum_opponents_prev = sum(opponent_prev)
            sum_prev = my_part + sum_opponents_prev
            if sum_prev > n / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_55(BaseStrategy):
    """
    Exploitative strategy for the Public Goods Game. Cooperates initially, then adapts based on others' contributions.
    Cooperates if others' average contribution exceeds 0.5, otherwise defects. Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions = history.opponent_actions[prev_round, :]
            sum_coop = np.sum(opponent_actions)
            n_opponents = self.game_description.n_players - 1
            average = sum_coop / n_opponents
            if average > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_56(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Public Goods Game.

    Cooperates initially to gauge others' behavior, adapts based on others' contributions,
    punishes when exploited, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            previous_opponent_actions = history.opponent_actions[-1, :]
            opponents_count = np.sum(previous_opponent_actions)
            num_opponents = self.game_description.n_players - 1
            avg_contribution = opponents_count / num_opponents
            my_previous_action = history.my_actions[-1]
            if my_previous_action and avg_contribution < 0.5:
                return Action.D
            else:
                return Action.C if avg_contribution >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_57(BaseStrategy):
    """
    Public Goods Game (PGG) Exploitative Strategy.
    Cooperates in the first round, defects in the last round.
    For subsequent rounds, cooperates if the average contribution from the previous round exceeds k/n; otherwise, defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        k = self.game_description.k
        n_rounds = self.game_description.n_rounds
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == n_rounds - 1:
            return Action.D
        prev_round = round_num - 1
        sum_opponents = np.sum(history.opponent_actions[prev_round])
        my_last_action = history.my_actions[prev_round]
        total_contributions = sum_opponents + (1 if my_last_action else 0)
        average = total_contributions / n_players
        threshold = k / n_players
        if average > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_58(BaseStrategy):
    """
    Win-Stay Lose-Shift Strategy (WSLS) Adaptation for Public Goods Game.
    Cooperates initially, then adapts based on the average contribution rate of the previous round.
    Defects in the last round to maximize personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_prev = history.my_actions[previous_round]
        opponents_prev = history.opponent_actions[previous_round, :]
        sum_coops = int(my_prev) + np.sum(opponents_prev)
        n_players = self.game_description.n_players
        avg = sum_coops / n_players * 100
        if avg >= 50:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_59(BaseStrategy):
    """
    Exploitative Majority Response (EMR) Strategy:
    Cooperates in the first round, defects in the last round, and cooperates if a majority
    of all players cooperated in the previous round, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_my_action = history.my_actions[state.round_number - 1]
            prev_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            total_coops = 1 if prev_my_action else 0
            total_coops += np.sum(prev_opponent_actions)
            if total_coops > self.n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_60(BaseStrategy):
    """
    Adaptive Exploitation Strategy: Cooperates initially, then adapts based on previous round's contributions.
    Defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            my_prev = history.my_actions[previous_round]
            opponents_prev = history.opponent_actions[previous_round]
            sum_prev = my_prev + opponents_prev.sum()
            average = sum_prev / self.game_description.n_players
            threshold = self.game_description.k / self.game_description.n_players
            if average < threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_61(BaseStrategy):
    """
    Exploitative Tit-for-Tat with Endgame Optimization (ETTEO) strategy.
    Cooperates initially, defects in the endgame, adapts based on others' contribution levels, 
    and introduces randomness to counter exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif random.random() < 0.2:
            return Action.C
        else:
            previous_round = state.round_number - 1
            opponent_actions = history.opponent_actions[previous_round]
            sum_coop = sum(opponent_actions)
            n_opponents = len(opponent_actions)
            avg = sum_coop / n_opponents
            if avg > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_62(BaseStrategy):
    """
    A strategy that starts by cooperating, adapts based on majority previous contributions,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            sum_me = int(history.my_actions[prev_round])
            sum_others = sum(history.opponent_actions[prev_round, :])
            total_c = sum_me + sum_others
            threshold = self.n_players // 2
            if total_c > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_63(BaseStrategy):
    """
    Strategy that initially cooperates, exploits when others cooperate sufficiently,
    punishes when cooperation drops below a threshold, and defects in endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        elif state.round_number <= 2:
            return Action.C
        elif self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        else:
            n_players = self.game_description.n_players
            last_three_rounds = history.opponent_actions[-3:]
            total_c = np.sum(last_three_rounds)
            average_c = total_c / (3 * (n_players - 1))
            if average_c >= 0.5:
                return Action.D
            else:
                self.punishment_remaining = 2
                return Action.D

class Strategy_EXPLOITATIVE_64(BaseStrategy):
    """
    A strategy that cooperates in the first round and then cooperates in subsequent rounds 
    if at least half of the opponents cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_65(BaseStrategy):
    """
    Implements the Adaptive Cooperate-to-Defect strategy, which starts with cooperation, 
    adapts based on the group's average contribution, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_contrib = 1 if history.my_actions[previous_round] else 0
        opponent_contrib = sum(history.opponent_actions[previous_round])
        total_contrib = my_contrib + opponent_contrib
        avg_contrib = total_contrib / self.n_players
        if avg_contrib >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_66(BaseStrategy):
    """
    Exploitative Adaptive Cooperation (EAC) strategy for N-Player Public Goods Game.
    Cooperates initially, adapts based on opponents' past cooperation, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            sum_me = 1 if history.my_actions[prev_round] else 0
            sum_others = np.sum(history.opponent_actions[prev_round])
            total = sum_me + sum_others
            avg_coop = total / self.game_description.n_players
            if avg_coop > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_67(BaseStrategy):
    """
    Always Defect strategy. The player will always choose to Defect in every round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_68(BaseStrategy):
    """
    Public Goods Game Exploitative Strategy.
    
    Cooperate in the first round. In subsequent rounds, cooperate if the previous round's average payoff is at least 1 + k/n, otherwise defect. Defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            last_round = state.round_number - 1
            my_payoff = history.my_payoffs[last_round]
            opponents_payoffs = history.opponent_payoffs[last_round]
            total_payoff = my_payoff + np.sum(opponents_payoffs)
            average_payoff = total_payoff / self.n_players
            threshold = 1 + self.k / self.n_players
            if average_payoff >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_69(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Repeated Public Goods Game.
    
    Description:
    Cooperate in the first round, defect in the final round, and adapt based on others' contributions.
    If the average contribution of others in the previous round exceeds k/n, defect to exploit,
    otherwise continue cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opp_actions_prev = history.opponent_actions[prev_round]
            sum_coop = np.sum(opp_actions_prev)
            other_players = self.game_description.n_players - 1
            avg_prev = sum_coop / other_players
            threshold = self.game_description.k / self.game_description.n_players
            if avg_prev > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_70(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        k = self.game_description.k
        if state.round_number == 0:
            return Action.C
        if state.round_number == n_rounds - 1:
            return Action.D
        if history is None:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        sum_opponent_coop = sum(opponent_prev_actions)
        n_opponents = n_players - 1
        condition1 = sum_opponent_coop > n_opponents / 2
        condition2 = False
        if my_prev_action:
            sum_coop = int(my_prev_action) + sum_opponent_coop
            actual_payoff = history.my_payoffs[prev_round]
            sum_defect = sum_opponent_coop
            defect_payoff = 1.0 + k / n_players * sum_defect
            condition2 = actual_payoff > defect_payoff
        if condition1 or condition2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_71(BaseStrategy):
    """
    Adaptive Exploitation strategy for Public Goods Game.
    Starts with cooperation, adapts based on others' contributions and own payoff trends.
    Defects in last round unless others' cooperation is high.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            n = self.game_description.n_players
            rounds = state.round_number
            total_others = 0
            for r in range(rounds):
                total_others += sum(history.opponent_actions[r])
            avg_others = total_others / (rounds * (n - 1)) if rounds * (n - 1) != 0 else 0
            if avg_others >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            n = self.game_description.n_players
            current_round = state.round_number
            total_others = 0
            for r in range(current_round):
                total_others += sum(history.opponent_actions[r])
            avg_others = total_others / (current_round * (n - 1)) if current_round * (n - 1) != 0 else 0
            if avg_others > 0.5:
                return Action.C
            else:
                payoff_history = history.my_payoffs
                if len(payoff_history) >= 2:
                    last_payoff = payoff_history[-1]
                    second_last_payoff = payoff_history[-2]
                    if last_payoff > second_last_payoff:
                        return Action.D
                    else:
                        return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_72(BaseStrategy):
    """
    This strategy employs Adaptive Exploitation in the Public Goods Game.
    It starts with cooperation, adapts based on others' contributions with a decaying threshold,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.decay_factor = 0.9

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            others_prev_actions = history.opponent_actions[prev_round, :]
            prev_coop = my_prev_action.astype(int) + others_prev_actions.sum()
            average_prev = prev_coop / self.n_players
            initial_threshold = self.k / self.n_players
            t = state.round_number - 1
            threshold = initial_threshold * self.decay_factor ** t
            if average_prev >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_73(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy.

    Cooperates in the first round, defects in the final round.
    In subsequent rounds, contribute if more than 50% contributed previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_action = history.my_actions[prev_round]
            opponent_actions = history.opponent_actions[prev_round]
            sum_coop = int(my_action) + int(opponent_actions.sum())
            threshold = 0.5 * self.n_players
            return Action.C if sum_coop > threshold else Action.D

class Strategy_EXPLOITATIVE_74(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game that adaptively responds to others' behavior.
    It starts with cooperation, uses a contribution threshold based on others' average contribution,
    defects in the final round, and retaliates against consistent defectors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_count = [0] * (game_description.n_players - 1)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        m = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if m == 0:
            return Action.C
        if m == n_rounds - 1:
            return Action.D
        opponent_count = n_players - 1
        total_contrib = 0
        for t in range(m):
            actions_t = history.opponent_actions[t]
            contrib_t = np.sum(actions_t)
            total_contrib += contrib_t
            for j in range(opponent_count):
                if actions_t[j]:
                    self.coop_count[j] += 1
        average_contrib = total_contrib / (m * opponent_count)
        defectors = 0
        for coop in self.coop_count:
            if coop / m < 0.5:
                defectors += 1
        if defectors > opponent_count / 2:
            return Action.D
        if average_contrib >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_75(BaseStrategy):
    """
    Adaptive Exploitation Strategy (AES) for Repeated Public Goods Game.
    
    The strategy starts by Cooperating in the first round. In subsequent rounds,
    it monitors the opponents' actions in the past two rounds. If the majority of
    opponents have Defected at least once in those rounds, the player Defects;
    otherwise, they Cooperate. In the final round, the player Defects to maximize
    their payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        if state.round_number == 0:
            return Action.C
        elif state.round_number == n_rounds - 1:
            return Action.D
        else:
            n_opponents = self.game_description.n_players - 1
            count_defected = 0
            for opponent in range(n_opponents):
                defected = False
                for delta in [1, 2]:
                    r = state.round_number - delta
                    if r < 0:
                        continue
                    if not history.opponent_actions[r, opponent]:
                        defected = True
                        break
                if defected:
                    count_defected += 1
            if count_defected > n_opponents / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_76(BaseStrategy):
    """
    Adaptive Exploitation Strategy (AES) for Public Goods Game.
    Cooperates for the first 3 rounds, then contributes based on the average 
    contribution of others compared to a threshold T.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number < 3:
            return Action.C
        current_round = state.round_number
        n_players = self.n_players
        k = self.k
        total_others = 0.0
        for round in range(current_round):
            opponent_actions = history.opponent_actions[round, :]
            sum_opponent_actions = np.sum(opponent_actions)
            total_others += sum_opponent_actions
        denominator = current_round * (n_players - 1)
        average_others = total_others / denominator
        T = (n_players - k) / n_players
        if average_others + 1e-09 >= T:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_77(BaseStrategy):
    """
    Exploit-Mirror-Punish Strategy for N-Player Public Goods Game.

    The strategy cooperates in the first round, mirrors opponents' contributions in subsequent rounds
    based on their previous round contributions, switches to permanent defection if opponents' average
    contribution drops below a threshold, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_mode = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        elif round_number == n_rounds - 1:
            return Action.D
        elif not self.punishment_mode:
            prev_round = round_number - 1
            opp_actions_prev = history.opponent_actions[prev_round, :]
            sum_contrib = np.sum(opp_actions_prev)
            n_opponents = self.game_description.n_players - 1
            avg_contrib = sum_contrib / n_opponents
            if avg_contrib >= 0.5:
                return Action.C
            else:
                self.punishment_mode = True
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_78(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Final Round Defection strategy.
    Cooperates in the first round, then follows majority contribution in subsequent rounds,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round, :]
        total_c = my_prev + opp_prev.sum()
        if total_c > self.n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_79(BaseStrategy):
    """
    Adaptive Exploitation strategy for Public Goods Game.
    Cooperates initially, then adapts based on others' contributions,
    defecting when cooperation is low and re-entering cooperation when others start contributing.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defects = 0
        self.defect_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        if self.consecutive_defects >= 3:
            self.consecutive_defects += 1
            return Action.D
        if self.defect_remaining > 0:
            self.defect_remaining -= 1
            self.consecutive_defects += 1
            return Action.D
        prev_round = current_round - 1
        my_prev_action = history.my_actions[prev_round]
        others_prev_actions = history.opponent_actions[prev_round, :]
        total_contrib = (1 if my_prev_action else 0) + sum(others_prev_actions)
        major_threshold = n_players / 2
        minor_threshold = max(1, n_players // 4)
        if total_contrib > major_threshold:
            self.consecutive_defects = 0
            return Action.C
        elif total_contrib <= minor_threshold:
            self.defect_remaining = 2
            self.consecutive_defects += 1
            return Action.D
        else:
            self.consecutive_defects += 1
            return Action.D

class Strategy_EXPLOITATIVE_80(BaseStrategy):
    """
    Exploitative Gradient Strategy (EGS) for the Public Goods Game.
    Cooperates initially, adapts based on the average contribution rate,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_action = history.my_actions[previous_round]
        opponent_actions = history.opponent_actions[previous_round, :]
        total_coop = my_action + sum(opponent_actions)
        avg_coop = total_coop / self.game_description.n_players
        if avg_coop >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_81(BaseStrategy):
    """Adaptive Exploitation with Dynamic Thresholding (AEDT) strategy for N-player public goods game."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = state.round_number
        if n == 1:
            return Action.D
        if current_round == r - 1:
            return Action.D
        last_round = current_round - 1
        my_actions = history.my_actions
        my_payoffs = history.my_payoffs
        opponent_actions = history.opponent_actions
        opponent_payoffs = history.opponent_payoffs
        defectors = 0
        my_last_action = my_actions[last_round]
        if not my_last_action:
            defectors += 1
        opp_last_actions = opponent_actions[last_round, :]
        defectors += sum((1 for action in opp_last_actions if not action))
        if defectors > n / 2:
            return Action.D
        if len(my_payoffs) >= 3:
            last_three_payoffs = my_payoffs[-3:]
            if last_three_payoffs[-1] < last_three_payoffs[-2] and last_three_payoffs[-2] < last_three_payoffs[-3]:
                return Action.D
        num_opponents = opponent_actions.shape[1] if opponent_actions.shape[0] > 0 else 0
        last_three = [current_round - 1 - i for i in range(3) if current_round - 1 - i >= 0]
        opponent_coops = np.zeros(num_opponents)
        for rd in last_three:
            coop = opponent_actions[rd, :].astype(int)
            opponent_coops += coop
        if num_opponents > 0:
            avg_coop = opponent_coops.mean(axis=0)
            if np.any(avg_coop < 0.3):
                return Action.D
            elif np.any(avg_coop > 0.7):
                return Action.D
        if last_round >= 1:
            avg_last = (my_payoffs[last_round] + opponent_payoffs[last_round, :].sum()) / n
            avg_before = (my_payoffs[last_round - 1] + opponent_payoffs[last_round - 1, :].sum()) / n
            if avg_last > avg_before:
                self.t = max(0.3, self.t - 0.1)
            else:
                self.t = min(0.8, self.t + 0.1)
        my_last = my_actions[last_round]
        coop_last_round = int(my_last) + opponent_actions[last_round, :].sum()
        avg_contribution = coop_last_round / n
        return Action.C if avg_contribution > self.t else Action.D

class Strategy_EXPLOITATIVE_82(BaseStrategy):
    """
    Public Goods Game Exploitative Strategy.
    
    This strategy begins by cooperating in the first round to encourage mutual cooperation.
    In subsequent rounds, it calculates the average cooperation rate of other players from the previous round.
    If the average is 0.5 or higher, it cooperates; otherwise, it defects.
    In the final round, it defects to maximize personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions = history.opponent_actions[prev_round]
            coop_sum = np.sum(opponent_actions)
            avg = coop_sum / (self.game_description.n_players - 1)
            return Action.C if avg >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_83(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Public Goods Game.
    Cooperates initially, defects in the last round, and adapts based on others' average contribution rate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        t = state.round_number
        opponent_actions = history.opponent_actions
        sum_contributions = opponent_actions[0:t, :].sum()
        n_opponents = self.game_description.n_players - 1
        avg = sum_contributions / (t * n_opponents)
        if avg > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_84(BaseStrategy):
    """
    A strategy that begins by cooperating, then adapts based on the group's average cooperation rate.
    Cooperates if the majority (50%) cooperate in the previous round, defects otherwise.
    Always cooperates in the first and last rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        cooperators_prev = my_prev_action + np.sum(opponents_prev_actions)
        average_prev = cooperators_prev / self.game_description.n_players
        return Action.C if average_prev >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_85(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that starts with cooperation, 
    then adapts based on others' average contribution rate, defecting if the rate 
    falls below 0.5, with special handling for the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            prev_round_actions = history.opponent_actions[-1]
            sum_coop = np.sum(prev_round_actions)
            n_others = prev_round_actions.shape[0]
            avg_last_round = sum_coop / n_others
            return Action.C if avg_last_round > 0.5 else Action.D
        else:
            sum_all = np.sum(history.opponent_actions)
            n_others = history.opponent_actions.shape[1]
            n_rounds_in_history = history.opponent_actions.shape[0]
            avg = sum_all / (n_others * n_rounds_in_history)
            return Action.C if avg > 0.5 else Action.D

class Strategy_EXPLOITATIVE_86(BaseStrategy):
    """
    Adaptive strategy for the N-Player Public Goods Game that balances cooperation and exploitation.
    Cooperates initially, defects in the last round, and adapts based on others' contributions.
    Includes random donations to encourage group cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.delta = 0.5 * (1 - self.k / self.n_players)
        self.random_donation_prob = 0.15

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        sum_contribs = np.sum(history.opponent_actions, axis=(0, 1))
        total_opportunities = (self.n_players - 1) * state.round_number
        average_contribution = sum_contribs / total_opportunities
        if average_contribution > self.delta:
            action = Action.C
        else:
            action = Action.D
        if random.random() < self.random_donation_prob:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_87(BaseStrategy):
    """
    An exploitative strategy for the Public Goods Game that adapts based on others' cooperation.
    Cooperates initially, defects in the last round, and switches based on previous contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        sum_opponents = np.sum(history.opponent_actions[prev_round])
        my_c = 1 if history.my_actions[prev_round] else 0
        total_c = sum_opponents + my_c
        threshold = self.game_description.n_players / 2.0
        if total_c > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_88(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Public Goods Game.

    The strategy starts by cooperating in the first round. In subsequent rounds, it adapts based on the contributions of other players.
    It defects if fewer than two players contributed in the previous round, or if the average contribution of other players is 0.5 or below.
    In the last round, it always defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        previous_opponent_actions = history.opponent_actions[-1]
        sum_opponent_coop = sum(previous_opponent_actions)
        my_previous_action = history.my_actions[-1]
        total_contributors = sum_opponent_coop + (1 if my_previous_action else 0)
        if total_contributors < 2:
            return Action.D
        avg_contribution = sum_opponent_coop / (self.n_players - 1)
        if avg_contribution > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_89(BaseStrategy):
    """
    An exploitative strategy for the Public Goods Game that adapts based on previous contributions.
    Cooperates initially, adapts subsequent contributions based on the previous round's total,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.r - 1:
            return Action.D
        else:
            my_prev = history.my_actions[-1]
            opponent_prev = history.opponent_actions[-1, :]
            sum_prev = my_prev + np.sum(opponent_prev)
            threshold = self.n / self.k
            if sum_prev > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_90(BaseStrategy):
    """
    Adaptive Exploitation strategy for the N-Player Public Goods Game.

    This strategy starts by cooperating, then adapts based on the majority contribution 
    in the previous round. Every third round, it tests cooperation if currently defecting.
    The last round uses the average contribution rate to decide.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if round_number == total_rounds - 1:
            total = 0.0
            for t in range(round_number):
                me_contribution = 1.0 if history.my_actions[t] else 0.0
                opponents_contribution = history.opponent_actions[t].sum()
                total += me_contribution + opponents_contribution
            avg = total / (round_number * n)
            return Action.C if avg >= 0.5 else Action.D
        else:
            last_round = round_number - 1
            me_contribution = 1.0 if history.my_actions[last_round] else 0.0
            opponents_contribution = history.opponent_actions[last_round].sum()
            total_last = me_contribution + opponents_contribution
            action = Action.C if total_last > n / 2 else Action.D
            renewal_round = (round_number + 1) % 3 == 0
            if renewal_round:
                last_action = history.my_actions[last_round]
                if not last_action:
                    action = Action.C
            return action

class Strategy_EXPLOITATIVE_91(BaseStrategy):
    """
    A strategy designed to maximize personal payoff by exploiting others' contributions in a Public Goods Game.
    It adapts based on others' previous actions, cooperating if others contribute significantly and defecting otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        sum_coop = np.sum(history.opponent_actions[prev_round, :])
        n_opponents = self.game_description.n_players - 1
        average = sum_coop / n_opponents
        if average > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_92(BaseStrategy):
    """
    A strategy that always chooses to defect (D), contributing 0 tokens in every round.
    This maximizes individual payoff by exploiting others' contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_93(BaseStrategy):
    """
    A strategy for the Public Goods Game that balances cooperation and defection.
    Cooperates initially, continues if others do, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            my_c = 1 if my_prev else 0
            opp_prev = history.opponent_actions[prev_round]
            opp_c = np.sum(opp_prev)
            c_prev_total = my_c + opp_c
            if c_prev_total >= self.k:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_94(BaseStrategy):
    """
    Adaptive Cooperativeness with Last-Round Defection Strategy.
    
    - Cooperates in the first round.
    - Cooperates in subsequent rounds if at least half of the players cooperated in the previous round.
    - Defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round]
            opponent_coop = np.sum(opponent_actions_prev)
            own_coop = 1 if history.my_actions[prev_round] else 0
            total_coop = opponent_coop + own_coop
            required = math.ceil(self.game_description.n_players / 2)
            if total_coop >= required:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_95(BaseStrategy):
    """
    Always defect in every round, regardless of others' actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_96(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Public Goods Game.

    This strategy starts with cooperation in the first round, then adapts based on the 
    group's average contribution rate. It defects when contributions are high to exploit,
    cooperates again if contributions fall below a threshold, and makes the last round
    decision based on average payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold_high = 0.6
        self.threshold_low = 0.3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            total_payoff = 0.0
            for t in range(state.round_number):
                my_payoff = history.my_payoffs[t]
                opp_payoffs = np.sum(history.opponent_payoffs[t, :])
                total_payoff += my_payoff + opp_payoffs
            avg_payoff = total_payoff / (self.n_players * state.round_number)
            if avg_payoff > self.k:
                return Action.C
            else:
                return Action.D
        else:
            avg_contribution = 0.0
            for t in range(state.round_number):
                my_contribution = 1 if history.my_actions[t] else 0
                opp_contribution = np.sum(history.opponent_actions[t, :])
                total = my_contribution + opp_contribution
                avg_contribution += total / self.n_players
            avg_contribution /= state.round_number
            if avg_contribution > self.threshold_high:
                return Action.D
            elif avg_contribution < self.threshold_low:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_97(BaseStrategy):
    """
    A strategy for the Public Goods Game that starts with cooperation, adapts based on 
    the previous round's cooperation rate, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_coop = 1 if my_prev_action else 0
            opp_actions_prev = history.opponent_actions[prev_round, :]
            opp_coop = sum(opp_actions_prev)
            total_coop = my_coop + opp_coop
            cooperation_rate = total_coop / self.n_players
            if cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_98(BaseStrategy):
    """
    Win-Stay, Lose-Shift Strategy for Public Goods Game.
    Defects in the first round. In subsequent rounds, cooperates if (k/n)*sum_prev > 1, else defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            sum_prev = my_prev_action + np.sum(opponents_prev_actions)
            threshold = self.k / self.n_players * sum_prev
            if threshold > 1:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_99(BaseStrategy):
    """
    Strategy that always defects in the Public Goods Game.
    This strategy maximizes individual payoff by exploiting others' contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_100(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Public Goods Game.
    
    Cooperates initially, then adapts based on the average contribution in the previous round.
    Cooperates if the average contribution is above 50%, otherwise Defects.
    Always Defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_my_action = history.my_actions[-1]
            prev_opponent_actions = history.opponent_actions[-1]
            total_coop = int(prev_my_action) + np.sum(prev_opponent_actions)
            average = total_coop / self.game_description.n_players
            if average > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_101(BaseStrategy):
    """
    Adaptive Exploiter Strategy for N-Player Public Goods Game.
    
    Strategy:
    - Defect in the first and last rounds.
    - In intermediate rounds, cooperate if the average contribution in the previous round is 0.5 or less; otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        n_rounds = self.game_description.n_rounds
        if t == 0:
            return Action.D
        if t == n_rounds - 1:
            return Action.D
        prev_round = t - 1
        my_contribution_prev = int(history.my_actions[prev_round])
        others_contribution_prev = np.sum(history.opponent_actions[prev_round])
        total_contrib = my_contribution_prev + others_contribution_prev
        average_contrib = total_contrib / self.game_description.n_players
        if average_contrib > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_102(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.

    This strategy starts by cooperating in the first round. In subsequent rounds, it considers the cooperation rate of all players.
    If more than half of the players have cooperated more than half the time, it continues to cooperate. Otherwise, it defects.
    Additionally, it cooperates every three rounds (forgiveness mechanism) and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if state.round_number == total_rounds - 1:
            return Action.D
        if state.round_number % 3 == 0:
            return Action.C
        t = state.round_number
        cooperation_count = 0
        for player_index in range(n_players):
            if player_index == 0:
                my_actions = history.my_actions
                sum_coop = np.sum(my_actions[:t])
            else:
                opponent_actions = history.opponent_actions[:t, player_index - 1]
                sum_coop = np.sum(opponent_actions)
            if sum_coop > t / 2:
                cooperation_count += 1
        majority_threshold = n_players / 2
        if cooperation_count > majority_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_103(BaseStrategy):
    """
    A strategy that always defects, taking advantage of others' cooperation to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_104(BaseStrategy):
    """
    The History-Responsive Cooperation (HRC) strategy starts by cooperating in the first round. 
    In middle rounds, it cooperates if at least half of the players contributed in the previous round. 
    It defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = int(history.my_actions[prev_round])
            opponents_prev = history.opponent_actions[prev_round]
            total_contributors = my_prev + np.sum(opponents_prev)
            threshold = self.n_players / 2.0
            if total_contributors >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_105(BaseStrategy):
    """
    Exploitative Strategy for Public Goods Game (PGG). Cooperates in the first round,
    cooperates in intermediate rounds if average cooperation meets or exceeds 50%,
    and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        total_coop = 0
        for t in range(current_round):
            my_action = history.my_actions[t]
            opp_actions = history.opponent_actions[t]
            coop_count = my_action + np.sum(opp_actions)
            total_coop += coop_count
        avg_coop = total_coop / (current_round * self.game_description.n_players)
        if avg_coop >= 0.5:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_106(BaseStrategy):
    """
    Exploitative Strategy for Public Goods Game (PGG). This strategy adapts based on the number of contributors in the previous round.
    Cooperates if the number of contributors meets or exceeds the threshold calculated as ceil(n/k), otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.threshold = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_last_action = history.my_actions[prev_round]
            my_contribution = 1 if my_last_action else 0
            opponent_contributions = sum(history.opponent_actions[prev_round])
            t_prev = my_contribution + opponent_contributions
            if t_prev >= self.threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_107(BaseStrategy):
    """
    Adaptive Exploitation strategy for Public Goods Game.
    Cooperates initially, punishes if contribution is low, resumes cooperation if others start contributing again,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.is_punishing = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            last_round_num = state.round_number - 1
            my_last_action = history.my_actions[last_round_num]
            opponents_last_actions = history.opponent_actions[last_round_num, :]
            sum_opponents = np.sum(opponents_last_actions)
            total_contrib = my_last_action + sum_opponents
            proportion = total_contrib / self.n_players
            if not self.is_punishing:
                if proportion >= 0.5:
                    return Action.C
                else:
                    self.is_punishing = True
                    return Action.D
            elif proportion >= 0.5:
                self.is_punishing = False
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_108(BaseStrategy):
    """
    Reciprocate & Punish Strategy for Public Goods Game.
    
    - Cooperates in the first round.
    - Cooperates if average contribution of others is 50%, otherwise defects.
    - Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        t = state.round_number
        sum_coop = np.sum(history.opponent_actions[:t, :])
        n_other = self.game_description.n_players - 1
        average = sum_coop / (t * n_other)
        return Action.C if average >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_109(BaseStrategy):
    """
    Adaptive Exploiter with Punishment and Reward strategy for the N-Player Public Goods Game.
    Cooperates initially, defects in the last round, and adapts based on others' actions with punishing/rewarding mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_other = self.game_description.n_players - 1
        my_prev_action = history.my_actions[-1]
        opp_actions_prev = history.opponent_actions[-1]
        prev_o_coop = sum(opp_actions_prev)
        majority_other_c = prev_o_coop > n_other // 2
        majority_other_d = n_other - prev_o_coop > n_other // 2
        if majority_other_c and (not my_prev_action):
            return Action.D
        elif majority_other_d and my_prev_action:
            return Action.C
        count_coop = prev_o_coop
        if count_coop > n_other // 2:
            return Action.C
        elif n_other - count_coop > n_other // 2:
            return Action.D
        else:
            k = self.game_description.k
            n = self.game_description.n_players
            sum_opponent_c_prev = count_coop
            pi_c = k / n * (sum_opponent_c_prev + 1)
            pi_d = 1.0 + k / n * sum_opponent_c_prev
            if pi_c > pi_d:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_110(BaseStrategy):
    """
    Exploitative Strategy for Public Goods Game:
    - Cooperate in the first round.
    - Cooperate if the average contribution in the previous round was above 50% (otherwise defect).
    - Always defect in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            c_me = 1 if history.my_actions[prev_round] else 0
            sum_others = np.sum(history.opponent_actions[prev_round, :])
            total_contrib = c_me + sum_others
            avg_contrib = total_contrib / self.n_players
            if avg_contrib > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_111(BaseStrategy):
    """
    Always Defect strategy. The player defects in every round, maximizing individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_112(BaseStrategy):
    """
    Adaptive Cooperator with Endgame Defection strategy.

    Cooperates in the first round, then adapts based on the average cooperation rate in previous rounds,
    defecting in the last round to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if round_number == 0:
            return Action.C
        elif round_number == n_rounds - 1:
            return Action.D
        else:
            total_coop = 0.0
            for rn in range(round_number):
                total_coop += history.my_actions[rn]
                total_coop += history.opponent_actions[rn].sum()
            average_coop = total_coop / (round_number * n_players)
            return Action.C if average_coop > 0.5 else Action.D

class Strategy_EXPLOITATIVE_113(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.r - 1:
            return Action.D
        else:
            prev_my_action = history.my_actions[-1]
            prev_opponent_actions = history.opponent_actions[-1, :]
            m = int(prev_my_action) + np.sum(prev_opponent_actions)
            threshold = self.n / self.k
            if m > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_114(BaseStrategy):
    """
    Win-Stay, Lose-Shift strategy for Public Goods Game.
    Cooperates when contribution rate is >=50%, else Defects. Forgives if after Defecting, others' cooperation rate is >=50%.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.last_action = action
            return action
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
            self.last_action = action
            return action
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        my_contribution = 1 if my_prev_action else 0
        opponent_contribution = np.sum(opponent_actions_prev)
        total_coop = my_contribution + opponent_contribution
        contribution_rate = total_coop / self.game_description.n_players
        if self.last_action == Action.D and contribution_rate >= 0.5:
            new_action = Action.C
        elif contribution_rate >= 0.5:
            new_action = Action.C
        else:
            new_action = Action.D
        self.last_action = new_action
        return new_action

class Strategy_EXPLOITATIVE_115(BaseStrategy):
    """
    Adaptive Contribution with Forgiveness strategy.

    Cooperates initially, forgives once if cooperation drops, 
    and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.has_forgiven = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        total_cooperators = my_prev_action + sum(opponent_prev_actions)
        avg = total_cooperators / self.game_description.n_players
        if avg >= 0.5:
            return Action.C
        elif not self.has_forgiven:
            self.has_forgiven = True
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_116(BaseStrategy):
    """
    A strategy that adapts based on the cooperation levels of other players,
    punishing when contributions fall below a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.consecutive_below = 0
        self.punishment_remaining = 0
        self.in_punishment = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if self.in_punishment and self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            if self.punishment_remaining == 0:
                self.in_punishment = False
            return Action.D
        else:
            my_prev = history.my_actions[-1]
            opponent_prev = history.opponent_actions[-1, :]
            total_contributions = my_prev + opponent_prev.sum()
            c_prev = total_contributions / self.n_players
            if c_prev >= 0.5:
                self.consecutive_below = 0
                self.in_punishment = False
                return Action.C
            else:
                self.consecutive_below += 1
                if self.consecutive_below >= 2:
                    self.in_punishment = True
                    self.punishment_remaining = 2
                return Action.D

class Strategy_EXPLOITATIVE_118(BaseStrategy):
    """
    Adaptive Exploitation Strategy for N-Player Public Goods Game.
    
    This strategy aims to maximize individual payoff by exploiting opponents' contributions,
    cooperating initially, defecting in intermediate rounds based on others' behavior,
    and defecting in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            prev_opponent_actions = history.opponent_actions[prev_round]
            sum_coop = np.sum(prev_opponent_actions)
            n_opponents = self.game_description.n_players - 1
            average = sum_coop / n_opponents
            if average > 0.5:
                return Action.D
            elif average < 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_119(BaseStrategy):
    """
    Strategy that starts with cooperation, adapts based on others' contributions, 
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        sum_C = np.sum(history.opponent_actions[-1, :])
        threshold = self.game_description.n_players / 2
        if sum_C >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_120(BaseStrategy):
    """
    A strategy that starts by cooperating, then adapts based on the average contribution 
    of others over the last 3 rounds, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.m = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            max_round = state.round_number - 1
            start_round = max(0, max_round - self.m + 1)
            relevant_rounds = history.opponent_actions[start_round:max_round + 1]
            sum_c = np.sum(relevant_rounds)
            total_actions = relevant_rounds.size
            average = sum_c / total_actions
            if average > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_121(BaseStrategy):
    """
    Adaptive Exploitation strategy for the N-Player Public Goods Game.
    Cooperates initially, adapts based on average contributions in middle rounds, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        me_coop = history.my_actions[prev_round]
        me_contribution = 1 if me_coop else 0
        opponents_contrib = np.sum(history.opponent_actions[prev_round, :])
        total_c = me_contribution + opponents_contrib
        avg_contribution = total_c / self.game_description.n_players
        if avg_contribution >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_122(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t == 0:
            return Action.C
        elif t == r - 1:
            return Action.D
        else:
            sum_my = history.my_actions.sum()
            sum_opp = history.opponent_actions.sum()
            total_c = sum_my + sum_opp
            avg = total_c / (n * t)
            if avg > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_123(BaseStrategy):
    """
    A strategy designed for the N-Player Public Goods Game that adapts to other players' contributions.
    Cooperates in the first round, defects in the last, and adapts based on the average contribution of others in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        opponents_actions = history.opponent_actions[previous_round, :]
        total_coop = sum(opponents_actions)
        n_opponents = self.game_description.n_players - 1
        avg_coop = total_coop / n_opponents if n_opponents > 0 else 0
        if avg_coop > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_124(BaseStrategy):
    """
    Adaptive Exploitation in Public Goods Game Strategy.
    
    This strategy starts by cooperating in the first round, defects in the last round, 
    and adapts based on the average contribution from the previous round relative to a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        others_prev_actions = history.opponent_actions[prev_round, :]
        others_coop = np.sum(others_prev_actions)
        my_coop = 1 if my_prev_action else 0
        total_coop = my_coop + others_coop
        average_coop = total_coop / self.game_description.n_players
        threshold = 1.0 / self.game_description.k
        if average_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_125(BaseStrategy):
    """
    A strategy that combines initial cooperation, mirroring past behavior, 
    a forgiveness mechanism, and adaptive endgame decision-making.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.consecutive_defections = 0
        self.rng = np.random.default_rng()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            total_cooperators = 0
            for t in range(state.round_number):
                my_action = history.my_actions[t]
                opponent_actions = history.opponent_actions[t, :]
                sum_prev = my_action + int(opponent_actions.sum())
                total_cooperators += sum_prev
            average = total_cooperators / state.round_number
            threshold = self.n_players / 2
            return Action.C if average >= threshold else Action.D
        else:
            t_prev = state.round_number - 1
            my_prev = history.my_actions[t_prev]
            opponent_prev = history.opponent_actions[t_prev, :]
            sum_prev = my_prev + int(opponent_prev.sum())
            n_players = self.n_players
            threshold = n_players / 2
            if sum_prev > threshold:
                self.consecutive_defections = 0
                return Action.C
            else:
                self.consecutive_defections += 1
                if self.rng.random() < 0.2:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_126(BaseStrategy):
    """
    This strategy cooperates initially, then adapts based on others' contributions, defecting in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_actions = history.opponent_actions[-1]
            sum_c = sum(prev_actions)
            n_opponents = len(prev_actions)
            avg = sum_c / n_opponents
            return Action.C if avg >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_127(BaseStrategy):
    """A strategy that starts cooperatively, adapts based on others' contributions, and defects in the last round."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        r = self.game_description.n_rounds
        if state.round_number == r - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_coop = history.my_actions[prev_round]
        others_coops = np.sum(history.opponent_actions[prev_round, :])
        total_coops = my_coop + others_coops
        n = self.game_description.n_players
        if total_coops >= n / 2.0:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_128(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Public Goods Game.
    Cooperates initially, mirrors opponents if in pairs unless opponent consistently defects,
    follows majority cooperation for larger groups, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.game_description.n_players == 2:
            opponent_prev_actions = history.opponent_actions[:state.round_number, 0]
            opponent_all_D = all((not a for a in opponent_prev_actions))
            if opponent_all_D:
                return Action.D
            else:
                last_opponent_action = history.opponent_actions[state.round_number - 1, 0]
                return Action.C if last_opponent_action else Action.D
        else:
            previous_round = state.round_number - 1
            my_last = history.my_actions[previous_round]
            opponent_last = np.sum(history.opponent_actions[previous_round, :])
            total_coop = my_last + opponent_last
            threshold = self.game_description.n_players / 2
            if total_coop > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_36(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on the group's contribution level,
    and includes a grace period to retest cooperation after defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.next_grace_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            total_contrib = 0
            if history is not None:
                for t in range(state.round_number):
                    my_action = history.my_actions[t]
                    opp_actions = history.opponent_actions[t, :]
                    contrib = 1 if my_action else 0
                    contrib += sum(opp_actions)
                    total_contrib += contrib
            n_players = self.game_description.n_players
            avg_contrib = total_contrib / (state.round_number * n_players)
            threshold = self.game_description.k / n_players
            if avg_contrib > threshold:
                return Action.C
            else:
                return Action.D
        elif state.round_number == self.next_grace_round:
            self.next_grace_round = -1
            return Action.C
        elif state.round_number == 0:
            return Action.C
        else:
            if history is None:
                return Action.C
            prev_round = state.round_number - 1
            my_last_action = history.my_actions[prev_round]
            opp_actions = history.opponent_actions[prev_round, :]
            total_last = 1 if my_last_action else 0
            total_last += sum(opp_actions)
            avg_last = total_last / self.game_description.n_players
            threshold = self.game_description.k / self.game_description.n_players
            if avg_last > threshold:
                return Action.C
            else:
                self.next_grace_round = state.round_number + 1
                return Action.D

class Strategy_COLLECTIVE_64(BaseStrategy):
    """Adaptive Contribution Threshold strategy."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sum_coop = np.sum(history.opponent_actions)
        number_rounds = state.round_number
        average_coop = sum_coop / number_rounds
        threshold = self.game_description.k / self.game_description.n_players * (self.game_description.n_players - 1)
        if average_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_89(BaseStrategy):
    """
    An adaptive strategy for the Public Goods Game, balancing cooperation and reciprocity.
    Cooperates initially, reciprocates based on others' contributions, escalates defection when cooperation is low,
    and reverts when others cooperate. Always cooperates in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.currently_defecting = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif not self.currently_defecting:
            prev_round = state.round_number - 1
            other_actions = history.opponent_actions[prev_round]
            other_coop = np.sum(other_actions)
            n_other = self.game_description.n_players - 1
            threshold = 0.8 * n_other
            if other_coop >= threshold:
                return Action.C
            else:
                self.currently_defecting = True
                return Action.D
        else:
            prev_round = state.round_number - 1
            other_actions = history.opponent_actions[prev_round]
            other_coop = np.sum(other_actions)
            n_other = self.game_description.n_players - 1
            threshold = 0.8 * n_other
            if other_coop >= threshold:
                self.currently_defecting = False
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_99(BaseStrategy):
    """
    Adaptive Collective Cooperation with Gradual Punishment strategy.
    Cooperates initially, then uses average cooperation rates to decide actions,
    with gradual punishment for defection and adaptation in threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_rates = []
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round, :]
        my_contrib = 1 if prev_my_action else 0
        opponent_contrib = np.sum(prev_opponent_actions)
        total_contrib = my_contrib + opponent_contrib
        cr_prev = total_contrib / self.game_description.n_players
        self.cooperation_rates.append(cr_prev)
        avg_coop = sum(self.cooperation_rates) / len(self.cooperation_rates)
        if state.round_number == self.game_description.n_rounds - 1:
            if self.threshold < 0.5:
                return Action.D
            else:
                all_cooperated = prev_my_action and np.all(prev_opponent_actions)
                return Action.C if all_cooperated else Action.D
        elif avg_coop >= self.threshold:
            return Action.C
        else:
            self.threshold *= 0.9
            self.threshold = max(self.threshold, 0.0)
            return Action.D

class Strategy_COLLECTIVE_126(BaseStrategy):
    """
    A strategy that initially cooperates, defects in the final round, 
    and cooperates or defects based on the previous round's cooperation rate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 or state.round_number == 1:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_prev_c = history.my_actions[previous_round]
        opp_actions = history.opponent_actions[previous_round]
        total_cooperators = my_prev_c + np.sum(opp_actions)
        avg_c = total_cooperators / self.game_description.n_players
        if avg_c >= 0.8:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_117(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that balances cooperation with strategic defection.
    It combines initial cooperation, probes to test reactions, and adaptive behavior based on cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.probe_counter = random.randint(3, 5)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            self.probe_counter -= 1
            if self.probe_counter <= 0:
                action = Action.D
                self.probe_counter = random.randint(3, 5)
            else:
                my_prev_action = history.my_actions[-1]
                opp_prev_actions = history.opponent_actions[-1, :]
                count_coop = int(my_prev_action) + opp_prev_actions.sum()
                cooperation_rate = count_coop / self.game_description.n_players
                if cooperation_rate > 0.5:
                    action = Action.C
                else:
                    action = Action.D
            return action