"""
Strategy descriptions for CollectiveRiskDescription.

Generated with:
- Provider: Anthropic
- Model: claude-opus-4-5
"""


description_COLLECTIVE_1 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I assume I am one of m cooperators needed to reach the threshold, and I act accordingly unless evidence suggests the collective is already secure or hopelessly fragmented.** The goal is to maximize collective welfare while adapting to the actual behavior of the group.

## Strategy Overview

The strategy operates on three principles:
1. **Default to cooperation** - Assume responsibility as one of the m needed cooperators
2. **Adapt to observed cooperation levels** - Reduce contribution when surplus exists, increase commitment when deficit threatens
3. **Maintain cooperation in critical situations** - Never abandon the collective when threshold is at risk

---

## Decision Rules

### Round 1: Optimistic Cooperation
**Action: Cooperate (C)**

Rationale: With no history, assume collective responsibility. Starting with cooperation signals willingness to coordinate and provides information about others.

---

### Rounds 2 through r-1: Adaptive Response

Let `prev_coop` = number of cooperators in the previous round (including self)

#### Case 1: Surplus Cooperation (`prev_coop > m`)
- **If `prev_coop ≥ m + 2`:** Defect with probability `(prev_coop - m) / n`
- **If `prev_coop = m + 1`:** Cooperate (maintain safety margin)

Rationale: When excess cooperators exist, some can safely free-ride. Probabilistic defection prevents coordination collapse while capturing efficiency gains.

#### Case 2: Threshold Met Exactly (`prev_coop = m`)
**Action: Cooperate (C)**

Rationale: The collective is fragile. Maintain cooperation to provide a stability buffer.

#### Case 3: Near Miss (`prev_coop = m - 1`)
**Action: Cooperate (C)**

Rationale: We were one cooperator short. Recommit and hope others do the same.

#### Case 4: Significant Deficit (`prev_coop < m - 1`)

Calculate `cooperation_trend` over last 3 rounds (or available rounds):
- **If trend is increasing or stable:** Cooperate (collective may be recovering)
- **If trend is decreasing AND `prev_coop < m/2`:** Defect (collective has collapsed; preserve individual payoff)

Rationale: Don't abandon a recovering collective, but recognize when coordination has failed catastrophically.

---

### Final Round (Round r): Threshold-Contingent Decision

Calculate `avg_coop` = average cooperators over all previous rounds

- **If `avg_coop ≥ m - 0.5`:** Cooperate (collective has been functional; honor the implicit agreement)
- **If `avg_coop < m - 0.5`:** Defect (collective failed; no obligation remains)

Rationale: The final round has no shadow of the future, but maintaining cooperation rewards groups that achieved coordination.

---

## Pseudocode

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_coop = count_cooperators(history[round - 1])
    
    if round == r:  # Final round
        avg_coop = average_cooperators(history)
        if avg_coop >= m - 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Rounds 2 to r-1
    if prev_coop >= m + 2:
        defect_prob = (prev_coop - m) / n
        return DEFECT with probability defect_prob, else COOPERATE
    
    elif prev_coop == m + 1:
        return COOPERATE
    
    elif prev_coop == m:
        return COOPERATE
    
    elif prev_coop == m - 1:
        return COOPERATE
    
    else:  # prev_coop < m - 1
        trend = calculate_trend(history, window=3)
        if trend >= 0:  # Increasing or stable
            return COOPERATE
        elif prev_coop < m / 2:
            return DEFECT
        else:
            return COOPERATE
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| `r = 2` (minimal rounds) | Cooperate both rounds | Insufficient data to adapt; default to collective |
| `m = n - 1` (high threshold) | Bias toward cooperation | Every defection is costly |
| `m = 2` (low threshold) | More willing to defect when surplus | Threshold easily maintained |
| All others defected | Defect if persistent (2+ rounds) | Don't be exploited indefinitely |
| Perfect cooperation history | Cooperate always | Reward and maintain coordination |

---

## Why This Strategy is Collectively Minded

1. **Assumes shared responsibility**: Treats itself as essential to reaching threshold by default
2. **Forgives and recovers**: Returns to cooperation after failures if trend improves
3. **Doesn't exploit excessively**: Only defects probabilistically when clearly safe
4. **Honors successful collectives**: Cooperates in final round if group succeeded
5. **Adapts without abandoning**: Stays cooperative through minor setbacks
'''

description_COLLECTIVE_2 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not redundantly so. The key insight is that in a collective risk dilemma, we need exactly *m* cooperators—having more wastes resources, having fewer causes collective failure. I'll adaptively position myself to fill gaps when cooperation is insufficient while stepping back when others reliably contribute.

## Strategy Overview

I use a **probabilistic commitment approach** calibrated to game parameters and observed history, with the goal of achieving exactly *m* cooperators in expectation while remaining robust to diverse opponent behaviors.

---

## Decision Rules

### Round 1: Baseline Cooperation Probability

With no history, I cooperate with probability based on the cooperation threshold:

```
p_initial = m / n + δ
```

Where `δ = 0.1` is a small "collective insurance" buffer. This ensures that if all players used this strategy, expected cooperators would slightly exceed *m*.

**Rationale:** This is the "fair share" contribution rate plus a margin for uncertainty about others' strategies.

---

### Rounds 2 through (r-1): Adaptive Response

After each round, I observe the number of cooperators `c_t` and adjust my cooperation probability for the next round.

#### Step 1: Assess Cooperation Gap

```
gap_t = m - c_t  (how many cooperators we were short/over)
```

#### Step 2: Calculate Base Cooperation Probability

```
If gap_t > 0 (threshold not met):
    p_base = min(1.0, p_previous + (gap_t / n) * 0.5)
    
If gap_t == 0 (exactly met threshold):
    p_base = p_previous  (maintain current approach)
    
If gap_t < 0 (exceeded threshold):
    p_base = max(0.1, p_previous + (gap_t / n) * 0.3)
```

**Rationale:** Increase cooperation when we fall short, decrease when we overshoot, but always maintain minimum 10% cooperation to avoid complete defection spirals.

#### Step 3: Trend Adjustment

Track cooperation trend over last 3 rounds (when available):

```
trend = (c_t - c_{t-2}) / 2  (average change per round)

If trend < -0.5:  # cooperation declining
    p_adjusted = p_base + 0.15
    
If trend > 0.5:   # cooperation increasing
    p_adjusted = p_base - 0.05
    
Else:
    p_adjusted = p_base
```

#### Step 4: "Was I Pivotal?" Adjustment

If I cooperated last round and exactly *m* cooperated (including me), slightly increase commitment:
```
If I_cooperated_{t} AND c_t == m:
    p_adjusted += 0.1
```

If I defected last round and exactly (m-1) others cooperated (we failed and I could have prevented it):
```
If NOT I_cooperated_{t} AND c_t == m - 1:
    p_adjusted += 0.2  (guilt/correction factor)
```

#### Step 5: Final Probability

```
p_cooperate = clamp(p_adjusted, 0.1, 0.95)
```

Never fully commit (0.95 cap) to maintain strategic flexibility; never fully defect (0.1 floor) to preserve collective potential.

---

### Final Round: Modified Endgame

The last round has no future consequences, creating defection incentives. However, maintaining collective mindset:

```
If average cooperation rate over game ≥ m/n:
    p_final = max(p_current, m/n)  # honor the collective's success
    
If average cooperation rate < m/n:
    p_final = p_current * 0.7  # reduce exposure given poor collective outcome
```

**Rationale:** Reward historically cooperative environments; reduce losses in failed collectives, but don't completely abandon cooperation.

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **n = 2, m = 1** | Simplest case—alternate or use p = 0.6 (slightly above fair share) |
| **m = n - 1** | Very high threshold—cooperate with p = 0.85+ since almost everyone must contribute |
| **r = 2** | Limited adaptation—use p_initial in round 1, apply single adjustment for round 2 |
| **k is very large** | Increase initial p by `min(0.2, log(k)/10)` since collective reward dominates |
| **k is barely > 1** | Reduce initial p by 0.1 since private keeping is relatively more valuable |
| **Consistent threshold success** | Gradually reduce p toward m/n (efficient cooperation) |
| **Persistent failure** | After 3+ consecutive failures, increase p by 0.15 each round until success |

---

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        p = m/n + 0.1 + min(0.15, log(k)/10)
    else:
        c_last = count_cooperators(history[-1])
        gap = m - c_last
        
        p = adjust_for_gap(p_previous, gap, n)
        p = adjust_for_trend(p, history)
        p = adjust_if_pivotal(p, history, m)
        
        if round == r:
            p = final_round_adjustment(p, history, m, n)
    
    p = clamp(p, 0.1, 0.95)
    return COOPERATE if random() < p else DEFECT
```

---

## Why This Strategy is Collectively-Minded

1. **Fair share baseline**: Starts by contributing proportionally to need
2. **Gap-filling**: Increases contribution when collective falls short
3. **Efficiency-seeking**: Reduces redundant cooperation when threshold is exceeded
4. **Trend-responsive**: Anticipates collective direction rather than just reacting
5. **Pivotal awareness**: Takes responsibility when my choice determines collective success
6. **Never abandons**: Maintains minimum cooperation even in adverse conditions
7. **Rewards collective success**: Honors cooperative history in endgame

This strategy aims to be a reliable collective member—neither a free-rider exploiting others' cooperation nor a sucker contributing when no one else will.
'''

description_COLLECTIVE_3 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I cooperate because the group needs cooperators, not because I expect personal gain from defection.** The strategy aims to be one of the reliable "m" cooperators the group needs, while adapting to observed behavior to avoid being exploited when cooperation is clearly futile.

## Decision Rules

### Primary Rule: Probabilistic Cooperation Based on Need and History

The fundamental approach is to cooperate with a probability that ensures (in expectation) that exactly m cooperators emerge, adjusted based on observed group behavior.

**Base Cooperation Probability:**
```
base_prob = m / n
```

This is the probability that, if all players used it independently, would yield m cooperators in expectation.

### Round-by-Round Logic

#### First Round
- **Cooperate with probability: max(base_prob, 0.6)**
- Rationale: Start optimistically but not naively. The floor of 0.6 signals cooperative intent and gives the group a reasonable chance of meeting the threshold.

#### Middle Rounds (rounds 2 through r-1)

Calculate an **adjusted cooperation probability** based on:

1. **Observed cooperation rate** from previous round: `obs_rate = (cooperators_last_round) / n`

2. **Cooperation shortfall/surplus**: `gap = m - cooperators_last_round`

3. **Adjustment factor**:
```
if gap > 0:  # Too few cooperators
    adjustment = +0.15 * (gap / m)  # Increase my cooperation
elif gap < 0:  # More than enough cooperators
    adjustment = -0.10 * (|gap| / (n - m))  # Slight decrease, let others share burden
else:  # Exactly m cooperators
    adjustment = 0
```

4. **Trust modifier** based on cumulative history:
```
rounds_threshold_met = count of rounds where ≥ m cooperated
trust = rounds_threshold_met / rounds_played
trust_modifier = 0.1 * (trust - 0.5)  # Ranges from -0.05 to +0.05
```

5. **Final cooperation probability**:
```
coop_prob = base_prob + adjustment + trust_modifier
coop_prob = clamp(coop_prob, 0.3, 0.95)  # Never fully abandon hope, never be certain
```

**Decision**: Cooperate if `random() < coop_prob`

#### Last Round
- **Cooperate with probability: coop_prob * 0.85**
- Rationale: Slight reduction acknowledging end-game incentives, but maintaining substantial cooperation because:
  - The collective outcome still matters
  - My defection might cause threshold failure, hurting everyone including me
  - The payoff k from meeting threshold often exceeds the gain from defecting

### Edge Case Handling

**If m = n-1 or m = n:**
- Increase base_prob to 0.9 - nearly everyone must cooperate, so I should be highly reliable

**If I observe consistent threshold failure (< m cooperators for 3+ consecutive rounds):**
- Still maintain minimum cooperation probability of 0.3
- Rationale: Giving up entirely guarantees failure; continued cooperation signals willingness to coordinate

**If I observe consistent threshold success with surplus cooperators:**
- Gradually reduce toward base_prob
- But never below base_prob - I don't free-ride on others' reliability

**If threshold was met last round with exactly m cooperators:**
- Maintain current cooperation probability - the system is balanced

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    base_prob = m / n
    
    if round == 1:
        return random() < max(base_prob, 0.6)
    
    # Analyze history
    last_cooperators = count_cooperators(history[round-1])
    gap = m - last_cooperators
    
    # Calculate adjustments
    if gap > 0:
        adjustment = 0.15 * (gap / m)
    elif gap < 0:
        adjustment = -0.10 * (abs(gap) / (n - m))
    else:
        adjustment = 0
    
    trust = sum(1 for r in history if cooperators(r) >= m) / (round - 1)
    trust_modifier = 0.1 * (trust - 0.5)
    
    coop_prob = clamp(base_prob + adjustment + trust_modifier, 0.3, 0.95)
    
    if round == r:  # Last round
        coop_prob *= 0.85
    
    return random() < coop_prob
```

## Why This Strategy is Collectively Minded

1. **Shares the burden**: Uses probability ≈ m/n, meaning I take my fair share of cooperation responsibility
2. **Responds to need**: Increases cooperation when the group falls short
3. **Doesn't exploit**: Never drops below 0.3 probability, maintaining collective viability
4. **Forgives**: Doesn't permanently punish past defection - always willing to try again
5. **Stays engaged**: Even in adversity, keeps contributing to give cooperation a chance
'''

description_COLLECTIVE_4 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of exactly m cooperators when possible, maximizing group welfare while being responsive to actual behavior patterns. The strategy balances reliability (being someone others can count on) with adaptability (responding to what's actually happening).

## Strategy Overview

The strategy operates on three principles:
1. **Be willing to be a threshold-filler**: Cooperate when cooperation is needed and likely to succeed
2. **Avoid wasteful cooperation**: Don't cooperate when it's futile or unnecessary
3. **Respond to demonstrated patterns**: Adjust based on what others actually do

---

## Decision Rules

### Round 1: Probabilistic Commitment

With no history, use a probability-based approach to distribute cooperation:

```
p_cooperate = m / n
Cooperate with probability p_cooperate
```

**Rationale**: If all players use this probability, expected cooperators ≈ m. This creates a coordination baseline without requiring explicit communication.

### Rounds 2 through (r-1): Adaptive Response

Calculate two key metrics from the previous round:

```
prev_cooperators = count of players who cooperated last round
cooperation_success = (prev_cooperators >= m)
```

**Decision Logic:**

```
IF prev_cooperators == m:
    # Perfect coordination achieved - maintain my previous action
    Play same action as last round
    
ELIF prev_cooperators > m:
    # Over-cooperation: some should defect
    IF I cooperated last round:
        # I'm a candidate to step back
        excess = prev_cooperators - m
        p_defect = excess / prev_cooperators
        Defect with probability p_defect, else Cooperate
    ELSE:
        # I wasn't cooperating, stay defecting
        Defect

ELIF prev_cooperators < m AND prev_cooperators > 0:
    # Under-cooperation but not hopeless
    shortfall = m - prev_cooperators
    non_cooperators_last = n - prev_cooperators
    
    IF I cooperated last round:
        # Stay cooperative - we need cooperators
        Cooperate
    ELSE:
        # Consider stepping up
        p_cooperate = shortfall / non_cooperators_last
        Cooperate with probability p_cooperate

ELIF prev_cooperators == 0:
    # Total defection - attempt restart
    p_cooperate = m / n
    Cooperate with probability p_cooperate
```

### Last Round (Round r): Conditional Cooperation

The last round removes future consequences, creating defection pressure. Counter this with threshold-conditional logic:

```
# Look at recent cooperation trend (last 3 rounds or all if r < 4)
recent_rounds = min(3, r-1)
avg_cooperators = average cooperators over recent_rounds

IF avg_cooperators >= m - 1:
    # Cooperation has been viable - stay engaged
    IF I cooperated in round r-1:
        Cooperate
    ELSE:
        # Step up if we were just barely missing threshold
        IF avg_cooperators < m:
            Cooperate with probability (m - avg_cooperators)
        ELSE:
            Defect
ELSE:
    # Cooperation has been failing badly - defect
    Defect
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **n = m** | Always Cooperate | Everyone must cooperate; no room for free-riding |
| **m = 1** | Cooperate round 1; then defect if someone else cooperated | Only one needed; let others carry if they will |
| **k very large (k > n)** | Increase base cooperation probability by factor of min(k/n, 2) | Higher stakes justify more cooperation attempts |
| **k barely > 1** | Use base probabilities | Don't over-invest for marginal gains |
| **r = 2** | Round 1: p = m/n; Round 2: same as "last round" logic | Limited learning opportunity |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    
    if round == 1:
        return cooperate_with_probability(m / n)
    
    prev_coop = count_cooperators(history, round - 1)
    my_prev_action = my_action(history, round - 1)
    
    if round == r:  # Last round
        return last_round_decision(history, n, m)
    
    # Middle rounds
    if prev_coop == m:
        return my_prev_action
    
    elif prev_coop > m:
        if my_prev_action == COOPERATE:
            p_defect = (prev_coop - m) / prev_coop
            return defect_with_probability(p_defect)
        else:
            return DEFECT
    
    elif prev_coop > 0:  # 0 < prev_coop < m
        if my_prev_action == COOPERATE:
            return COOPERATE
        else:
            shortfall = m - prev_coop
            p_coop = shortfall / (n - prev_coop)
            return cooperate_with_probability(p_coop)
    
    else:  # prev_coop == 0
        return cooperate_with_probability(m / n)
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: The probabilistic rules naturally push toward exactly m cooperators without explicit coordination

2. **Forgiving**: Doesn't permanently punish defection; allows recovery from coordination failures

3. **Not exploitable by pure defectors**: If others consistently defect, this strategy stops wasting cooperation

4. **Rewards reliable cooperation**: Maintains cooperation with those who demonstrate willingness to contribute

5. **Handles heterogeneous opponents**: Works whether facing cooperators, defectors, or mixed strategies
'''

description_COLLECTIVE_5 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not to over-contribute when others are already meeting the threshold. The goal is to reliably achieve collective success while being robust to free-riders and adaptive to the observed behavior of others.

## Strategy Overview

The strategy operates on three key principles:
1. **Be willing to cooperate** - Default toward cooperation, especially early
2. **Be responsive to history** - Adjust based on whether thresholds are being met and who's contributing
3. **Avoid exploitation** - Don't be a perpetual sucker if others consistently defect

---

## Decision Rules

### Round 1 (No History)

**Cooperate with probability `m/n`**

Rationale: If all players independently cooperate with probability m/n, the expected number of cooperators equals m. This is the minimal coordination-free baseline that gives the collective a reasonable chance of meeting the threshold.

### Rounds 2 through r-1 (Middle Rounds)

Calculate three key metrics from history:

1. **Success Rate** = (rounds where ≥m cooperated) / (total past rounds)
2. **Cooperation Rate** = (total cooperations by all players) / (total past actions)
3. **My Contribution Rate** = (my cooperations) / (past rounds)

**Decision Logic:**

```
IF threshold was NOT met last round:
    # Collective failure - increase willingness to cooperate
    Cooperate with probability min(0.9, m/n + 0.2)

ELSE IF threshold was met last round:
    # Success occurred - but was I needed?
    
    Let c_others = number of OTHER players who cooperated last round
    
    IF c_others < m:
        # I was essential to success - maintain cooperation
        Cooperate with probability 0.8
    
    ELSE IF c_others >= m:
        # Threshold met without me - I can consider defecting
        # But don't fully abandon - others may think similarly
        
        IF My Contribution Rate > Cooperation Rate + 0.15:
            # I've been contributing more than average - take a break
            Cooperate with probability 0.3
        ELSE:
            # I haven't over-contributed - stay moderately cooperative
            Cooperate with probability m/n

SPECIAL ADJUSTMENT - Chronic Failure:
IF Success Rate < 0.4 AND rounds played > 2:
    # Group is failing badly - make a stronger push
    Cooperate with probability 0.85
    
SPECIAL ADJUSTMENT - Stable Success:
IF Success Rate > 0.8 AND Cooperation Rate is in range [m/n - 0.1, m/n + 0.2]:
    # Group has found equilibrium - don't disrupt
    Match my historical cooperation rate
```

### Final Round (Round r)

The final round removes future consequences, creating strong defection incentives. However, maintaining collective success still matters for the round's payoff.

```
IF Success Rate >= 0.7:
    # Group has been reliable - trust them one more time
    # But expect some defection, so increase own cooperation
    Cooperate with probability min(0.9, (m + 1) / n)

ELSE IF Success Rate < 0.4:
    # Group has been unreliable - likely failure anyway
    Defect (probability 0)

ELSE:
    # Mixed history - cooperate at baseline rate
    Cooperate with probability m/n
```

---

## Edge Case Handling

| Scenario | Action |
|----------|--------|
| **n = 2, m = 2** (both must cooperate) | Cooperate consistently; mutual defection guarantees failure |
| **m = n-1** (almost everyone needed) | Cooperate with probability 0.85+ throughout |
| **m = 2** (low threshold) | Stick closer to m/n baseline; less urgency |
| **k is very large** | No change - strategy focuses on meeting threshold, not k magnitude |
| **k is barely > 1** | No change - collective payoff still dominates defection when threshold met |
| **Very long games (r > 20)** | Rely more heavily on Success Rate; smooth out noise |
| **Very short games (r ≤ 3)** | Weight toward cooperation (less time to recover from failures) |

---

## Summary Pseudocode

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return cooperate_with_prob(m / n)
    
    success_rate = count_successes(history) / (round - 1)
    coop_rate = total_cooperations(history) / (n * (round - 1))
    my_coop_rate = my_cooperations(history) / (round - 1)
    last_round_coops = cooperations_in_round(history, round - 1)
    others_last = last_round_coops - my_action(history, round - 1)
    
    # Final round logic
    if round == r:
        if success_rate >= 0.7:
            return cooperate_with_prob(min(0.9, (m + 1) / n))
        elif success_rate < 0.4:
            return DEFECT
        else:
            return cooperate_with_prob(m / n)
    
    # Middle rounds logic
    if last_round_coops < m:
        return cooperate_with_prob(min(0.9, m/n + 0.2))
    
    if others_last < m:
        return cooperate_with_prob(0.8)
    
    if my_coop_rate > coop_rate + 0.15:
        return cooperate_with_prob(0.3)
    
    if success_rate < 0.4 and round > 3:
        return cooperate_with_prob(0.85)
    
    if success_rate > 0.8:
        return cooperate_with_prob(my_coop_rate)
    
    return cooperate_with_prob(m / n)
```

---

## Why This Strategy is Collectively-Minded

1. **Threshold-focused**: I aim to be part of the m needed, not to minimize my own cost
2. **Responsive to failure**: I increase cooperation when the group fails, rather than abandoning ship
3. **Fair burden-sharing**: I track whether I'm over-contributing and adjust, encouraging rotation
4. **Trust-building**: Consistent early cooperation establishes reliability
5. **Forgiving**: One bad round doesn't trigger permanent defection

This strategy should perform well against cooperators (achieving mutual success), hold its own against defectors (by not being infinitely exploitable), and adapt to mixed populations.
'''

description_COLLECTIVE_6 = '''
# Collective Risk Dilemma: Adaptive Threshold Strategy

## Strategic Analysis

The core tension in this game is clear: if exactly m players cooperate, defectors get the highest payoff (1 + k) while cooperators get only k. However, if fewer than m cooperate, everyone loses the bonus k. The collective optimum requires coordination to ensure the threshold is met while individual incentives push toward free-riding.

Since I cannot communicate or pre-coordinate with others, I must design a strategy that:
1. Signals cooperative intent early to help establish threshold-meeting coalitions
2. Adapts based on observed cooperation levels
3. Punishes persistent free-riding to discourage exploitation
4. Remains robust against various opponent types

## Strategy: "Threshold Guardian"

### Core Philosophy
Act as a reliable cooperator who helps meet the collective threshold, but adaptively reduce cooperation when the group consistently fails to coordinate or when free-riding becomes exploitative. The strategy aims to be part of the "cooperative core" that makes collective success possible.

---

### Decision Rules

#### Round 1 (Bootstrap Phase)
**Action: COOPERATE**

Rationale: With no history, signal cooperative intent. This helps establish whether a cooperative coalition can form. The cost of cooperating when others defect (losing 1 unit) is worth the information gained and the potential to catalyze cooperation.

#### Rounds 2 through (r-1) (Adaptive Phase)

Calculate two key metrics from history:

1. **Recent Cooperation Rate (RCR)**: Proportion of players (excluding self) who cooperated in the last round
2. **Historical Success Rate (HSR)**: Proportion of past rounds where threshold m was met

**Decision Logic:**

```
Let others_cooperated_last = count of other players who played C last round
Let threshold_met_last = (total cooperators last round ≥ m)
Let HSR = (rounds where threshold met) / (rounds played)

IF threshold_met_last:
    # Success regime - maintain cooperation but watch for exploitation
    IF others_cooperated_last ≥ m:
        # Others are carrying weight - I can safely cooperate
        ACTION = COOPERATE
    ELSE IF others_cooperated_last == m - 1:
        # I was pivotal - continue being pivotal
        ACTION = COOPERATE
    ELSE:
        # I cooperated but wasn't needed (others_cooperated ≥ m without me)
        # OR threshold met only because of me with few others
        # Stay cooperative to maintain coalition
        ACTION = COOPERATE
        
ELSE (threshold_NOT_met_last):
    # Failure regime - need to assess viability of cooperation
    IF others_cooperated_last >= m - 1:
        # Close to threshold - my cooperation could tip it
        ACTION = COOPERATE
    ELSE IF HSR > 0.5:
        # Historical success suggests last round was anomaly
        ACTION = COOPERATE
    ELSE IF HSR > 0.3 AND others_cooperated_last >= (m - 1) / 2:
        # Some hope remains - give cooperation another chance
        ACTION = COOPERATE
    ELSE:
        # Cooperation appears non-viable - defect to cut losses
        ACTION = DEFECT
```

**Forgiveness Mechanism:**
```
IF I defected last round AND others_cooperated_last >= m - 1:
    # Others showed renewed cooperation - rejoin the coalition
    ACTION = COOPERATE
```

#### Final Round (Round r)

The last round has no future consequences, creating strong defection incentives. However, maintaining collective success benefits everyone.

```
IF HSR >= 0.6:
    # Strong cooperative history - honor the implicit agreement
    # Calculate: am I likely pivotal?
    expected_others_C = average cooperation count from last 3 rounds (excluding self)
    IF expected_others_C >= m:
        # Threshold likely met without me - tempting to defect
        # But maintain cooperation to ensure collective success
        ACTION = COOPERATE (with 70% probability)
        # Small defection chance acknowledges end-game incentives
    ELSE:
        ACTION = COOPERATE
ELSE IF HSR >= 0.4:
    # Moderate history - cooperate if I might be pivotal
    IF expected_others_C >= m - 1:
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT
ELSE:
    # Poor cooperation history - no point sacrificing
    ACTION = DEFECT
```

---

### Edge Cases

1. **n = 2, m = 2**: Both must cooperate. Start cooperative, switch to permanent defection after any round where opponent defects (threshold impossible with one defector).

2. **m = n - 1 or m = n**: High threshold requiring near-universal cooperation. Be persistently cooperative since any defection likely dooms the round.

3. **m very small (m ≤ n/3)**: Threshold easily met. Can afford occasional strategic defection if cooperation rate is very high, but default to cooperation to maintain the coalition.

4. **k very large**: High stakes increase value of coordination. Weight toward cooperation more heavily.

5. **Very few rounds (r ≤ 3)**: Limited learning time. Cooperate rounds 1 and 2; apply end-game logic to round 3.

---

### Summary Pseudocode

```
function threshold_guardian(round, history, n, m, r, k):
    
    if round == 1:
        return COOPERATE
    
    others_C_last = count_others_cooperated(history, round - 1)
    threshold_met_last = was_threshold_met(history, round - 1, m)
    HSR = historical_success_rate(history, m)
    
    # Forgiveness check
    if my_last_action == DEFECT and others_C_last >= m - 1:
        return COOPERATE
    
    # Final round logic
    if round == r:
        return final_round_decision(HSR, history, m, n)
    
    # Main adaptive logic
    if threshold_met_last:
        return COOPERATE
    else:
        if others_C_last >= m - 1:
            return COOPERATE
        elif HSR > 0.5:
            return COOPERATE
        elif HSR > 0.3 and others_C_last >= (m - 1) / 2:
            return COOPERATE
        else:
            return DEFECT
```

---

### Why This Strategy Works Collectively

1. **Bootstraps cooperation**: Starting cooperative helps form initial coalitions
2. **Maintains viable coalitions**: Persistent cooperation when threshold is achievable
3. **Cuts losses intelligently**: Defects only when cooperation appears futile
4. **Forgives and rebuilds**: Returns to cooperation when others show renewed commitment
5. **Robust to exploitation**: Doesn't infinitely cooperate into failure

This strategy positions itself as a reliable member of any cooperative coalition while protecting against scenarios where cooperation is clearly non-viable.
'''

description_COLLECTIVE_7 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to help ensure the group reaches the cooperation threshold. The strategy recognizes that in a collective risk dilemma, the worst outcome is failing to reach threshold m—everyone loses the reward k. I aim to be a reliable cooperator who helps the group succeed, while adapting to the actual cooperation levels I observe.

## Strategy Overview

I default to cooperation, viewing myself as one of the m players needed to secure the collective reward. I only defect when cooperation appears unnecessary (others are reliably covering the threshold) or futile (too few others cooperate to make threshold achievable). Even then, I maintain a bias toward cooperation because the collective benefit matters.

---

## Decision Rules

### Round 1: Cooperative Default

**Action: COOPERATE**

Reasoning: With no history, I cannot know others' strategies. I choose to be part of the solution. If all players reasoned selfishly, no one would cooperate and everyone would lose the reward. By cooperating first, I signal willingness to contribute and give the collective the best chance of reaching threshold.

---

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate from the previous round:
- `prev_cooperators`: number of players who cooperated last round
- `cooperation_rate`: cumulative cooperation rate across all past rounds

**Decision Logic:**

```
IF prev_cooperators < m:
    # Threshold was missed - group needs more cooperators
    COOPERATE (be part of the solution)

ELSE IF prev_cooperators == m:
    # Exactly at threshold - precarious situation
    COOPERATE (help maintain/stabilize the threshold)

ELSE IF prev_cooperators > m AND prev_cooperators <= m + buffer:
    # Threshold met with small margin
    # Use probabilistic cooperation to avoid everyone defecting simultaneously
    buffer = ceiling(n / 4)
    cooperation_probability = (m + buffer - prev_cooperators + 1) / (buffer + 1)
    COOPERATE with probability = cooperation_probability

ELSE IF prev_cooperators > m + buffer:
    # Strong cooperation surplus
    # Still cooperate sometimes to avoid coordination collapse
    COOPERATE with probability = 0.3
```

**Rationale for probabilistic defection:** When surplus cooperators exist, some defection is collectively efficient (cooperators pay a cost). But if everyone reasons this way simultaneously, cooperation collapses. The probabilistic approach with bias toward cooperation helps maintain stability.

---

### Final Round (Round r): Threshold-Focused Decision

The last round has no future shadow, but the collective goal remains.

```
IF cumulative_cooperation_rate >= m/n:
    # Group has shown cooperative tendency
    COOPERATE (trust the pattern continues, ensure threshold)

ELSE IF prev_cooperators >= m:
    # Last round met threshold
    COOPERATE with probability = m/n
    # Probabilistic to help reach threshold without guaranteeing free-riding pays

ELSE:
    # Group has consistently failed threshold
    # Still cooperate with reduced probability - maybe others will too
    COOPERATE with probability = 0.4
```

---

## Edge Cases

### Edge Case 1: n = m (all must cooperate)
When everyone must cooperate to reach threshold:
- **Always cooperate** in every round
- One defector ruins it for everyone; be reliable

### Edge Case 2: m = 2 (minimal threshold)
- Follow standard rules but reduce probabilistic defection
- With low threshold, cooperation collapse is the main risk

### Edge Case 3: Very short games (r = 2 or 3)
- Increase cooperation probability throughout
- Less time to recover from coordination failures

### Edge Case 4: Large n relative to m
- More room for some defection, but maintain cooperation bias
- Use `buffer = min(ceiling(n/4), n-m-1)` to scale appropriately

---

## Pseudocode Summary

```
function decide(round, history, n, m, r, k):
    buffer = ceiling(n / 4)
    
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round-1])
    cumulative_rate = total_cooperations(history) / (n * (round - 1))
    
    if round == r:  # Final round
        if cumulative_rate >= m/n or prev_cooperators >= m:
            return COOPERATE with probability max(m/n, 0.5)
        else:
            return COOPERATE with probability 0.4
    
    # Middle rounds
    if prev_cooperators <= m:
        return COOPERATE
    else if prev_cooperators <= m + buffer:
        prob = (m + buffer - prev_cooperators + 1) / (buffer + 1)
        return COOPERATE with probability prob
    else:
        return COOPERATE with probability 0.3
```

---

## Why This Strategy is Collectively Minded

1. **Default cooperation**: I start as a contributor, not a free-rider
2. **Responds to need**: I increase cooperation when threshold is at risk
3. **Maintains stability**: Even with surplus cooperators, I don't fully defect—preventing collapse
4. **Shares the burden**: Probabilistic defection when safe means cooperators can occasionally rest
5. **Never exploitative**: I never try to be the sole defector benefiting from others' cooperation
6. **Robust to mixed populations**: Works whether others are cooperative, selfish, or random

The strategy accepts that I may sometimes "unnecessarily" cooperate, viewing this as acceptable cost for collective success rather than a mistake to be optimized away.
'''

description_COLLECTIVE_8 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not redundant beyond that threshold. The strategy balances reliability (being someone the group can count on) with efficiency (not over-contributing when others are already meeting the threshold).

## Strategy Overview

The strategy operates on three principles:
1. **Baseline willingness**: Start with moderate cooperation to establish collective reliability
2. **Responsive calibration**: Adjust based on observed cooperation levels relative to threshold *m*
3. **Endgame awareness**: Handle final rounds where defection incentives spike

---

## Decision Rules

### Round 1 (No History)

**Cooperate with probability p₁ = m/n**

Rationale: If all players independently cooperate with probability m/n, the expected number of cooperators equals exactly *m*. This is the collectively optimal baseline when no coordination is possible.

### Rounds 2 through (r-1) (Middle Game)

Calculate the **cooperation rate** from the previous round:
- Let `prev_coop` = number of cooperators in round t-1

**Decision logic:**

```
IF prev_coop < m THEN:
    # Threshold wasn't met - group needs more cooperators
    # Increase my cooperation probability
    cooperate with probability: min(1, (m - prev_coop + 1) / (n - prev_coop))
    
ELSE IF prev_coop == m THEN:
    # Exactly at threshold - maintain current behavior
    # If I cooperated last round, likely cooperate again (I was essential)
    # If I defected, stay defector (threshold was met without me)
    repeat my action from round t-1
    
ELSE IF prev_coop > m THEN:
    # Over-threshold - some cooperators are redundant
    # Probabilistically reduce cooperation to avoid waste
    cooperate with probability: m / prev_coop
```

**Additional adjustment - Trend detection:**

Look at the last 3 rounds (when available). If cooperation is trending downward (each round fewer cooperators than the last), add +0.15 to cooperation probability to counteract collapse.

### Final Round (Round r)

The final round has no future consequences, creating strong defection incentives. However, maintaining collective success still matters for total payoff.

```
IF historical_success_rate >= 0.7 THEN:
    # Group has been reliable - maintain cooperation pattern
    cooperate with probability: m/n (baseline)
    
ELSE:
    # Group has been unreliable - likely to fail anyway
    # Defect to secure private payoff
    defect
```

Where `historical_success_rate` = (rounds where ≥m cooperated) / (r-1)

---

## Edge Cases

| Scenario | Action |
|----------|--------|
| **r = 2** (minimal rounds) | Round 1: cooperate with prob m/n; Round 2: use final round logic |
| **m = n-1** (nearly all must cooperate) | Bias toward cooperation (+0.2 to all probabilities) since any defection is costly |
| **m = 2** (low threshold) | Follow standard rules; low threshold means defection is less risky |
| **k is very large** | No change - the strategy already aims to meet threshold; k affects payoff magnitude but not threshold logic |
| **All defected last round** | Cooperate with probability min(1, (m+1)/n) - be willing to seed cooperation |
| **All cooperated last round** | Cooperate with probability m/n - allow efficient reduction |

---

## Pseudocode Summary

```
function decide(round, history, n, m, r, k):
    
    if round == 1:
        return COOPERATE with probability m/n
    
    prev_coop = count_cooperators(history[round-1])
    
    if round == r:  # Final round
        success_rate = count_successful_rounds(history) / (r-1)
        if success_rate >= 0.7:
            return COOPERATE with probability m/n
        else:
            return DEFECT
    
    # Middle rounds
    if prev_coop < m:
        p = min(1, (m - prev_coop + 1) / (n - prev_coop))
    else if prev_coop == m:
        return my_action(history[round-1])  # Repeat last action
    else:  # prev_coop > m
        p = m / prev_coop
    
    # Trend adjustment
    if round >= 4 and cooperation_declining(last_3_rounds):
        p = min(1, p + 0.15)
    
    return COOPERATE with probability p
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: Without coordination, players using this strategy naturally converge toward exactly *m* cooperators
2. **Responsive**: Quickly adapts when threshold isn't met
3. **Efficient**: Reduces redundant cooperation when over-threshold
4. **Resilient**: Trend detection prevents cooperation collapse
5. **Realistic**: Doesn't assume others will cooperate or follow any particular strategy
'''

description_COLLECTIVE_9 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be a *reliable cooperator* who helps the group reach the threshold, while adapting to observed behavior to avoid being exploited when cooperation is futile. The key insight is that in this game, **reaching exactly m cooperators is optimal for the group's average payoff**, but **being one of those m cooperators when others defect is costly to me personally**. I resolve this tension by defaulting to cooperation and only defecting when evidence strongly suggests the threshold cannot be met.

## Strategy Overview

I will be a **conditional cooperator with a cooperative bias**. I start by cooperating and continue cooperating as long as there's reasonable evidence that the threshold can be met. I only defect when historical data convincingly shows that fewer than m players are willing to cooperate.

---

## Decision Rules

### Round 1: Default Cooperate
- **Action: Cooperate**
- Rationale: With no history, I signal cooperative intent. If enough others share this mindset, we establish a cooperative equilibrium early.

### Rounds 2 through r-1: Adaptive Cooperation

Let `cooperation_rate` = (total C actions by all players in all previous rounds) / (n × rounds_played)

Let `threshold_met_rate` = (rounds where ≥ m players cooperated) / (rounds_played)

Let `recent_cooperators` = number of players who cooperated in the most recent round

**Decision Logic:**

```
IF recent_cooperators >= m THEN
    Cooperate  // Threshold was just met, stay the course
    
ELSE IF recent_cooperators == m - 1 THEN
    Cooperate  // I might be the pivotal player needed
    
ELSE IF threshold_met_rate >= 0.5 THEN
    Cooperate  // Group has shown capacity to coordinate
    
ELSE IF cooperation_rate >= (m - 1) / n THEN
    Cooperate  // Enough baseline cooperation to justify contributing
    
ELSE
    Defect  // Insufficient cooperation history; contributing is futile
```

### Last Round (Round r): Threshold-Contingent Decision

The last round has no shadow of the future, so I use a more precise calculation:

```
IF recent_cooperators >= m THEN
    Cooperate  // Maintain successful equilibrium
    
ELSE IF recent_cooperators == m - 1 THEN
    Cooperate  // Be the pivotal cooperator
    
ELSE IF threshold_met_rate >= 0.6 AND cooperation_rate >= m / n THEN
    Cooperate  // Strong cooperative history suggests others will cooperate
    
ELSE
    Defect  // Insufficient evidence threshold will be met
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2, m = 2 | Always cooperate unless partner defected last 2+ rounds | Need both; give benefit of doubt |
| m = n - 1 or m = n | Cooperate more liberally | High threshold needs reliable contributors |
| m very small (m ≤ n/3) | Defect if threshold consistently met without me | Others can carry the load |
| k very large (k > 2) | Lower defection threshold | High reward justifies risk |
| All previous rounds failed threshold | Cooperate once more, then defect | Give one "restart" chance |
| Exactly m-1 others cooperated last round | Always cooperate | I am likely pivotal |

---

## Handling Specific Player Patterns

**Against All-Defectors:** After 3 consecutive rounds where fewer than m/2 players cooperate, I defect. No point contributing to a lost cause.

**Against All-Cooperators:** I continue cooperating. Mutual cooperation at threshold is sustainable.

**Against Mixed/Random:** My adaptive thresholds naturally handle noise by averaging over history.

---

## Pseudocode Summary

```python
def decide(round_number, total_rounds, history, n, m, k):
    if round_number == 1:
        return COOPERATE
    
    recent_cooperators = count_cooperators(history[-1])
    threshold_met_rate = count_threshold_met(history, m) / len(history)
    cooperation_rate = total_cooperations(history) / (n * len(history))
    
    # Pivotal player logic
    if recent_cooperators == m - 1:
        return COOPERATE
    
    # Threshold just met
    if recent_cooperators >= m:
        return COOPERATE
    
    # Historical success
    if threshold_met_rate >= 0.5:
        return COOPERATE
    
    # Sufficient baseline cooperation
    if cooperation_rate >= (m - 1) / n:
        return COOPERATE
    
    # Last round is stricter
    if round_number == total_rounds:
        if threshold_met_rate < 0.6:
            return DEFECT
    
    # Default to defect only when evidence is clear
    return DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **Cooperative default**: I start and generally continue cooperating, making me a reliable partner.
2. **Pivotal awareness**: I always cooperate when I might be the m-th cooperator needed.
3. **Forgiveness**: Even after failed rounds, I give the group chances to recover.
4. **Not exploitable indefinitely**: I eventually defect if cooperation is clearly futile, preventing complete exploitation.
5. **Threshold-aware**: I understand that exactly m cooperators is efficient, so I don't demand universal cooperation.

This strategy aims to be the kind of player that *creates* cooperative equilibria rather than merely responding to them.
'''

description_COLLECTIVE_10 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not to over-contribute when others are already meeting the threshold. The goal is to achieve the collective reward reliably while distributing the cost of cooperation fairly over time.

## Key Insight

The optimal collective outcome requires exactly *m* cooperators each round—this maximizes total group payoff. With *m* cooperators, defectors get payoff 3 (in the example), cooperators get 2, but the threshold is met. The challenge is coordinating *who* cooperates without communication.

## Strategy Description

### Decision Variables

- **Cooperation score** for each player: tracks their historical cooperation rate
- **My cooperation debt**: how much I've defected relative to my "fair share"
- **Threshold safety margin**: based on observed cooperation levels

### Round-by-Round Decision Rules

#### First Round
**Cooperate.**

Rationale: With no history, I cannot assess others. Cooperating signals willingness to contribute to the collective. If all players reason similarly, we meet the threshold. Starting cooperatively establishes a baseline for reciprocity.

#### Middle Rounds (2 to r-1)

Calculate the following:

```
fair_share_rate = m / n  (the proportion of rounds each player "should" cooperate)
my_historical_rate = (my cooperations so far) / (rounds played)
group_cooperation_rate = (total cooperations by others) / ((n-1) * rounds played)
last_round_cooperators = count of players who cooperated last round
```

**Decision logic:**

1. **If last round failed threshold (< m cooperators):**
   - **Cooperate** — the group needs more contributors; be part of the solution

2. **If last round exactly met threshold (= m cooperators):**
   - If I cooperated last round: **Cooperate** (maintain stability)
   - If I defected last round: **Defect** (don't disrupt working equilibrium)

3. **If last round exceeded threshold (> m cooperators):**
   - Calculate my "cooperation debt": `debt = fair_share_rate - my_historical_rate`
   - If `debt > 0` (I've under-contributed): **Cooperate**
   - If `debt ≤ 0` (I've contributed my share): 
     - **Defect** with probability proportional to excess cooperators
     - Specifically: Defect if `(last_round_cooperators - m) / (n - m) > random()`

4. **Cooperation pressure adjustment:**
   - If group cooperation rate is dangerously low (< m/n - 0.1): **Cooperate** regardless
   - This prevents collapse from mutual defection spirals

#### Last Round
**Apply middle-round logic, but with slight cooperative bias.**

Rationale: Unlike prisoner's dilemma, defecting in the final round still risks everyone losing the threshold bonus. Maintain cooperation probability unless threshold is clearly secure.

Specifically: If I calculate I should defect but last round had exactly *m* cooperators, **Cooperate** instead (conservative protection).

### Pseudocode

```
function decide(round, history, my_id, params):
    n, r, m, k = params
    
    if round == 1:
        return COOPERATE
    
    last_round_coop_count = count(history[round-1])
    my_coop_count = count(my_cooperations in history)
    my_rate = my_coop_count / (round - 1)
    fair_rate = m / n
    
    # React to threshold failure
    if last_round_coop_count < m:
        return COOPERATE
    
    # Maintain stable equilibrium
    if last_round_coop_count == m:
        if I cooperated last round:
            return COOPERATE
        else:
            return DEFECT
    
    # Threshold exceeded - distribute burden fairly
    my_debt = fair_rate - my_rate
    
    if my_debt > 0.05:  # I've under-contributed
        return COOPERATE
    
    # Probabilistically reduce cooperation to efficient level
    excess_ratio = (last_round_coop_count - m) / max(1, n - m)
    if random() < excess_ratio:
        return DEFECT
    else:
        return COOPERATE
```

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | Cooperate | Establish cooperative baseline |
| Last round, threshold met last time | Follow standard logic | No special defection—threshold still matters |
| Everyone defected last round | Cooperate | Emergency recovery needed |
| I'm the only cooperator repeatedly | Continue cooperating but reduce if hopeless | Can't meet threshold alone; after 3+ solo rounds, match group rate |
| Very high cooperation (n-1 cooperators) | Defect | Free-ride is safe; others provide buffer |
| m = n-1 (tight threshold) | Cooperate more often | Little margin for error |

## Robustness Features

1. **Against all-defectors**: I cooperate initially, observe failure, continue cooperating (being part of any potential coalition)
2. **Against all-cooperators**: I gradually defect more, enjoying the surplus while not collapsing the threshold
3. **Against mixed strategies**: My debt-tracking ensures I do my fair share over time
4. **Against exploiters**: The threshold nature protects me—if they defect too much, *they* lose the bonus too

## Why This is Collective

- I don't aim to maximize *my* payoff at others' expense
- I aim for *exactly m* cooperators, which is group-optimal
- I use fair-share tracking to distribute cooperation burden
- I respond to collective failure by contributing more, not abandoning ship
'''

description_COLLECTIVE_11 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not a surplus cooperator who bears costs unnecessarily. The strategy dynamically estimates how many others will cooperate and fills gaps to reach the threshold while avoiding exploitation.

## Strategy Overview

The strategy operates on three principles:
1. **Threshold completion**: Cooperate when my cooperation is likely pivotal to reaching *m*
2. **Fair burden sharing**: Track who has cooperated and favor cooperation when I've defected more than my fair share
3. **Adaptive estimation**: Use observed behavior to predict cooperation levels and adjust accordingly

---

## Decision Rules

### Round 1: Probabilistic Threshold Seeding

With no history, I cooperate with probability based on the minimum needed ratio:

```
P(cooperate) = min(1, (m / n) + 0.1)
```

The +0.1 buffer accounts for uncertainty and signals cooperative intent. This ensures that in expectation, approximately *m* players cooperate initially.

### Rounds 2 through (r-1): Adaptive Threshold Filling

**Step 1: Estimate expected cooperators**

Calculate the base cooperation rate from history:
```
base_rate = (total cooperations by others) / (total opportunities)
expected_others_cooperating = base_rate * (n - 1)
```

**Step 2: Calculate cooperation gap**
```
gap = m - expected_others_cooperating
```

**Step 3: Calculate my fair share debt**
```
fair_share = (rounds_played * m) / n
my_cooperations = count of my C plays so far
debt = fair_share - my_cooperations
```

**Step 4: Decision logic**

```
IF gap >= 1:
    # My cooperation is likely pivotal
    COOPERATE
    
ELSE IF gap > 0 AND gap < 1:
    # Cooperation might be pivotal - probabilistic
    P(cooperate) = gap + (0.2 * max(0, debt))
    COOPERATE with probability P
    
ELSE IF gap <= 0 AND debt > 0.5:
    # Threshold likely met, but I haven't done my share
    # Cooperate occasionally to maintain fairness signaling
    P(cooperate) = min(0.3, debt / rounds_remaining)
    COOPERATE with probability P
    
ELSE:
    # Threshold likely met and I've contributed fairly
    DEFECT
```

**Step 5: Reactivity adjustment**

If the threshold was NOT met in the previous round:
```
boost = 0.3  # Increase cooperation probability
Apply boost additively to any cooperation probability
```

If the threshold was met in ALL of the last 3 rounds with surplus cooperators:
```
reduce cooperation probability by 0.1
```

### Final Round (Round r): Modified Logic

The final round removes future reputation concerns, but collective success still matters:

```
IF expected_others_cooperating >= m:
    DEFECT (threshold met without me)
    
ELSE IF expected_others_cooperating >= m - 1:
    # I might be pivotal
    COOPERATE with probability 0.7
    
ELSE IF expected_others_cooperating >= m - 2 AND debt > 0:
    COOPERATE (contribute to near-threshold)
    
ELSE:
    # Threshold unlikely to be met regardless
    DEFECT
```

---

## Edge Case Handling

| Situation | Action |
|-----------|--------|
| **m = n-1 or m = n** | Always cooperate (nearly everyone needed) |
| **m ≤ n/3** | Use lower base cooperation rate; be more selective |
| **All others defected last round** | Cooperate with P=0.4 (attempt recovery, but protect against exploitation) |
| **All others cooperated last round** | Defect (threshold easily met) |
| **k is very large (k > 3)** | Increase cooperation probabilities by 20% (high stakes justify risk) |
| **Very few rounds (r ≤ 3)** | Weight toward cooperation more heavily (less time to balance) |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return cooperate_with_prob(min(1, m/n + 0.1))
    
    # Calculate key metrics
    coop_rate = others_cooperation_rate(history)
    expected_coops = coop_rate * (n - 1)
    gap = m - expected_coops
    debt = fair_share_debt(history, round, m, n)
    threshold_met_last = was_threshold_met(history[-1], m)
    
    # Reactivity
    boost = 0.3 if not threshold_met_last else 0
    reduce = 0.1 if recent_surplus(history, m, 3) else 0
    
    # Final round adjustment
    if round == r:
        return final_round_logic(expected_coops, m, debt)
    
    # Main decision
    if gap >= 1:
        return COOPERATE
    elif gap > 0:
        p = gap + 0.2 * max(0, debt) + boost - reduce
        return cooperate_with_prob(clamp(p, 0, 1))
    elif debt > 0.5:
        p = min(0.3, debt / (r - round)) + boost - reduce
        return cooperate_with_prob(clamp(p, 0, 1))
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing threshold completion**: Multiple agents using this strategy will collectively converge toward exactly *m* cooperators, minimizing waste while ensuring success.

2. **Exploitation resistance**: The fair-share debt mechanism prevents free-riding, and the adaptive estimation quickly identifies and responds to defector-heavy populations.

3. **Recovery capability**: The reactivity boost after failed rounds helps groups recover from coordination failures.

4. **No coordination assumption**: The strategy works through emergent behavior, not assumed synchronization—it adapts to whatever cooperation patterns emerge.
'''

description_COLLECTIVE_12 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embodies a collective mindset: I recognize that the best outcomes occur when exactly m players cooperate (threshold met, some get free-rider bonus) or when cooperation is widespread enough to reliably meet the threshold. My goal is to be a reliable cooperator when needed while adapting to the actual cooperation levels I observe.

## Strategy Overview

I use a **probabilistic cooperation approach** that adapts based on observed cooperation rates, my position in a conceptual "responsibility ranking," and the game phase. The key insight is that without coordination, I should cooperate with a probability that, if adopted by similar-minded players, would yield approximately m cooperators in expectation—while adjusting based on actual observed behavior.

---

## Decision Rules

### Round 1: Baseline Cooperation

**Cooperate with probability p₁ = m/n**

Rationale: If all players used this probability, expected cooperators = m, exactly meeting the threshold. This is the collectively rational starting point.

### Rounds 2 through (r-1): Adaptive Phase

**Step 1: Calculate observed cooperation rate**
```
obs_coop_rate = (total C plays by others in all previous rounds) / ((n-1) × rounds_played)
```

**Step 2: Determine cooperation need**
```
target_cooperators = m
expected_others_cooperating = obs_coop_rate × (n-1)
cooperation_gap = target_cooperators - expected_others_cooperating
```

**Step 3: Calculate my cooperation probability**
```
if cooperation_gap <= 0:
    # Threshold likely met without me - mild cooperation tendency
    base_prob = 0.3
else:
    # I may be needed - scale up probability
    base_prob = min(1.0, cooperation_gap / 1.0)  # Higher gap = higher probability

# Adjust for observed reciprocity
if obs_coop_rate > m/n:
    # Others are cooperative - reward with cooperation
    reciprocity_bonus = 0.2
else:
    # Others defecting more - still maintain some baseline
    reciprocity_bonus = -0.1

final_prob = clamp(base_prob + reciprocity_bonus, 0.2, 0.95)
```

**Step 4: Consistency bonus**
If I cooperated last round AND threshold was met: increase probability by 0.1 (reward successful coordination)

**Cooperate with probability final_prob**

### Final Round (Round r): Strategic Finish

The last round has no shadow of the future, making defection more tempting for all.

```
if obs_coop_rate >= m/n:
    # Community has been cooperative - honor that with cooperation
    Cooperate with probability 0.7
else if obs_coop_rate >= (m-1)/n:
    # Borderline - I might be pivotal
    Cooperate with probability 0.8
else:
    # Cooperation has collapsed - low chance of meeting threshold
    Cooperate with probability 0.3
```

---

## Edge Case Handling

### Very Small Groups (n ≤ 3)
- Increase all cooperation probabilities by 0.15 (each player is more pivotal)

### High Threshold (m > n/2)
- Increase baseline cooperation by (m/n - 0.5) × 0.3 (more cooperators needed = more responsibility)

### Very High Reward (k > 2)
- Increase all probabilities by min(0.2, (k-2) × 0.1) (cooperation is more valuable)

### Near-Unanimous Cooperation Observed (>80% in previous rounds)
- Match with high cooperation (0.85 probability) - don't exploit a cooperative community

### Near-Total Defection Observed (<20% in previous rounds)
- Maintain cooperation floor of 0.25 - attempt to seed cooperation recovery

---

## Pseudocode Summary

```
function decide(round, history, n, m, r, k):
    if round == 1:
        return COOPERATE with probability m/n
    
    obs_rate = calculate_others_cooperation_rate(history)
    expected_others = obs_rate × (n-1)
    gap = m - expected_others
    
    if round == r:  # Final round
        if obs_rate >= m/n: return COOPERATE with prob 0.7
        if obs_rate >= (m-1)/n: return COOPERATE with prob 0.8
        return COOPERATE with prob 0.3
    
    # Middle rounds
    base = clamp(gap, 0.3, 1.0)
    reciprocity = 0.2 if obs_rate > m/n else -0.1
    consistency = 0.1 if (I_cooperated_last AND threshold_met_last) else 0
    
    prob = clamp(base + reciprocity + consistency, 0.2, 0.95)
    
    # Edge case adjustments
    prob += edge_case_adjustments(n, m, k, obs_rate)
    
    return COOPERATE with probability clamp(prob, 0.15, 0.95)
```

---

## Why This Strategy is Collectively Minded

1. **Responsibility sharing**: I cooperate at rates designed to collectively meet the threshold
2. **Reciprocity**: I reward observed cooperation and don't completely abandon defecting communities
3. **Adaptability**: I fill gaps when cooperation is low, ease off when others cooperate enough
4. **Robustness**: Probability bounds prevent complete exploitation or complete withdrawal
5. **No exploitation**: I never try to be the sole defector when threshold is exactly met
'''

description_COLLECTIVE_13 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the m cooperators needed to secure the collective reward, but not a redundant cooperator being exploited by free-riders. The strategy adapts based on observed cooperation levels, attempting to coordinate implicitly toward exactly m cooperators while protecting against exploitation.

## Decision Rules

### Round 1: Probabilistic Seeding

With no history, cooperate with probability `m/n`.

**Rationale:** If all players independently cooperate with probability m/n, the expected number of cooperators equals exactly the threshold m. This is the collectively optimal starting point that doesn't over-commit or under-commit.

### Rounds 2 through (r-1): Adaptive Response

After each round, calculate:
- `prev_cooperators`: number of players who cooperated last round
- `my_prev_action`: what I did last round
- `others_cooperating`: prev_cooperators minus my contribution (0 or 1)

**Decision Logic:**

```
IF others_cooperating >= m:
    # Threshold met without me - I can safely defect
    # But don't always defect; occasionally cooperate to maintain group norm
    Cooperate with probability 0.2
    
ELIF others_cooperating == m - 1:
    # I am pivotal - my cooperation determines success
    Cooperate with probability 0.9
    # Small defection chance to avoid being perpetually exploited as the "sucker"
    
ELIF others_cooperating < m - 1:
    # Not enough others cooperating
    # Calculate cooperation gap
    gap = (m - 1) - others_cooperating
    
    IF gap == 1:
        Cooperate with probability 0.7
    ELIF gap == 2:
        Cooperate with probability 0.5
    ELSE:
        # Too few cooperators - cooperation is futile, signal displeasure
        Cooperate with probability 0.3
```

**Adjustment for Cooperation Trends:**

Track a `cooperation_trend` over the last 3 rounds (or fewer if early):
- If cooperation is increasing: boost cooperation probability by 0.1
- If cooperation is decreasing: reduce cooperation probability by 0.1
- Clamp all probabilities between 0.1 and 0.95

### Final Round (Round r): Modified Calculation

The last round has no future shadow, so adjust toward a more self-interested calculation while still valuing collective success:

```
IF others_cooperating >= m:
    Defect (no reason to cooperate)
    
ELIF others_cooperating == m - 1:
    # Pivotal position - cooperate to secure reward for all
    Cooperate with probability 0.85
    
ELSE:
    # Threshold unlikely to be met
    # Cooperate with probability (m - others_cooperating) / n
    # This gives a small chance of coordinated success
```

## Edge Cases

1. **n = 2, m = 2 (both must cooperate):** Follow standard rules; in pivotal situations (other cooperated), cooperate with high probability since mutual cooperation is required.

2. **m very close to n:** Increase base cooperation rates by 0.15 across all calculations, as nearly everyone must cooperate.

3. **m very small relative to n:** Decrease base cooperation rates by 0.1, as fewer cooperators are needed.

4. **k is very large (k > 3):** Increase cooperation probability by 0.1 in pivotal situations, as the reward justifies higher cooperation risk.

5. **Very long games (r > 20):** Early rounds (first 20%) use slightly higher cooperation to establish norms; probabilities increase by 0.1.

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return random() < m/n ? COOPERATE : DEFECT
    
    others_coop = count_others_cooperating(history, round-1)
    trend = calculate_trend(history, last_3_rounds)
    
    base_prob = calculate_base_probability(others_coop, m, n)
    adjusted_prob = base_prob + trend_adjustment(trend)
    adjusted_prob = apply_parameter_adjustments(adjusted_prob, m, n, k, r, round)
    adjusted_prob = clamp(adjusted_prob, 0.1, 0.95)
    
    if round == r:
        adjusted_prob = final_round_adjustment(adjusted_prob, others_coop, m)
    
    return random() < adjusted_prob ? COOPERATE : DEFECT
```

This strategy balances collective responsibility with self-protection, adapts to the actual behavior of other players, and avoids both naive cooperation and cynical defection.
'''

description_COLLECTIVE_14 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not more than necessary. The goal is to ensure the threshold is met while minimizing unnecessary sacrifice. I'll use observable history to estimate how many others are likely to cooperate and position myself to fill gaps.

---

## Strategy Specification

### Key Variables Tracked

- `cooperation_rate`: Rolling estimate of average cooperation probability across all players
- `my_cooperation_history`: My own past actions
- `round_outcomes`: Whether threshold was met each round
- `deficit_history`: How far below/above threshold we've been

---

### Decision Rules

#### Round 1 (No History)

**Cooperate with probability `m/n`.**

Rationale: If all players independently cooperate with probability m/n, the expected number of cooperators equals exactly m. This is the collectively rational baseline that doesn't over- or under-commit.

#### Rounds 2 through r-1 (Middle Rounds)

Calculate the following:

1. **Observed cooperation rate** = (total C actions by all players in all previous rounds) / (n × rounds played)

2. **Expected other cooperators** = `observed_cooperation_rate × (n - 1)`

3. **Cooperation needed from me** = max(0, `m - expected_other_cooperators`)

**Decision Rule:**

```
IF expected_other_cooperators >= m:
    # Others likely have it covered - I can defect
    # But maintain some cooperation to avoid collapse
    Cooperate with probability 0.2
    
ELSE IF expected_other_cooperators >= m - 1:
    # I might be the pivotal player
    Cooperate with probability 0.8
    
ELSE:
    # Cooperation is dangerously low - definitely contribute
    Cooperate with probability 1.0
```

**Adjustment for Recent Failures:**

```
IF threshold was NOT met in previous round:
    Increase cooperation probability by 0.3 (capped at 1.0)
    
IF threshold was NOT met in previous TWO rounds:
    Cooperate with probability 1.0
```

**Adjustment for Consistent Success:**

```
IF threshold was met in ALL of the last 3 rounds AND 
   total cooperators averaged > m + 1:
    # We're over-cooperating collectively
    Reduce cooperation probability by 0.15 (floored at m/n)
```

#### Final Round (Round r)

The last round removes shadow of future punishment, creating defection incentives.

**Decision Rule:**

```
IF my cumulative cooperation rate > (m/n):
    # I've done my fair share - protect my investment
    Cooperate with probability 0.5
    
ELSE:
    # I've been free-riding - step up at the end
    Cooperate with probability 0.9
```

---

### Edge Case Handling

| Scenario | Action |
|----------|--------|
| **m = n-1 or m = n** | Always cooperate (threshold too tight for strategic defection) |
| **m ≤ n/2** | Follow standard rules but allow slightly lower cooperation baseline |
| **All players defected last round** | Cooperate with probability 1.0 (emergency recovery) |
| **All players cooperated last round** | Cooperate with probability m/n (reset to baseline) |
| **k is very large (k > 3)** | Increase all cooperation probabilities by 0.1 (reward justifies risk) |
| **Very few rounds (r ≤ 3)** | Increase cooperation probabilities by 0.2 (less time to recover) |

---

### Pseudocode Summary

```
function decide(game_params, history):
    n, m, k, r = game_params
    current_round = len(history) + 1
    
    if current_round == 1:
        return cooperate_with_prob(m / n)
    
    coop_rate = calculate_cooperation_rate(history)
    expected_others = coop_rate * (n - 1)
    recent_failures = count_recent_failures(history, window=2)
    
    base_prob = calculate_base_probability(expected_others, m)
    
    # Adjustments
    base_prob += 0.3 * recent_failures
    base_prob -= 0.15 * recent_surplus(history, m)
    
    # Final round adjustment
    if current_round == r:
        base_prob = final_round_adjustment(base_prob, my_history, m, n)
    
    return cooperate_with_prob(clamp(base_prob, 0, 1))
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: Naturally gravitates toward exactly m cooperators without explicit coordination
2. **Responsive**: Quickly increases cooperation when threshold fails
3. **Fair**: Baseline probability of m/n means everyone shares burden equally in expectation
4. **Stable**: Prevents both cooperation collapse and wasteful over-cooperation
5. **Robust**: Works against selfish defectors, fellow cooperators, and mixed strategies
'''

description_COLLECTIVE_15 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I act as if I'm one of m guardians responsible for ensuring the threshold is met, while remaining adaptive to the actual behavior of others.** The goal is to maximize collective welfare by reliably contributing when needed, while avoiding wasteful over-contribution when the threshold is already secure.

---

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic fairness**: In early rounds, cooperate with probability m/n to fairly distribute the burden
2. **Reputation tracking**: Identify reliable cooperators and free-riders based on history
3. **Adaptive commitment**: Increase cooperation when the threshold is at risk; reduce when it's secure

---

## Decision Rules

### Round 1 (No History)
**Cooperate with probability m/n.**

Rationale: If all players adopt this rule, expected cooperators = m, giving the best balance between reaching threshold and avoiding over-contribution. This is the fair baseline.

### Middle Rounds (2 to r-1)

**Step 1: Calculate cooperation scores for all players**
```
For each player j:
  cooperation_rate[j] = (times j cooperated) / (rounds played)
```

**Step 2: Rank all players by cooperation rate (including self)**
- Ties broken by player index (lower index = higher rank)

**Step 3: Determine "responsibility group"**
- The m players with highest cooperation rates form the "responsibility group"
- These are the most reliable cooperators the collective can count on

**Step 4: Base decision**
```
If I am in the top m cooperators:
    base_action = COOPERATE
Else:
    base_action = DEFECT
```

**Step 5: Adaptive adjustments**

*Adjustment A - Threshold failure response:*
```
If threshold was NOT met last round:
    increase_prob = 0.3 * (consecutive_failures)
    With probability increase_prob: override to COOPERATE
```

*Adjustment B - Over-cooperation correction:*
```
If threshold was met last round with (cooperators > m + 2):
    If my cooperation_rate > average_cooperation_rate + 0.2:
        With probability 0.3: override to DEFECT
```

*Adjustment C - Encourage reciprocity:*
```
If I defected last round AND threshold was met:
    With probability 0.2: COOPERATE (show willingness to contribute)
```

### Final Round (Round r)

**Modified calculation accounting for end-game dynamics:**

```
Count players with cooperation_rate > 0.5 as "likely cooperators"

If likely_cooperators >= m:
    # Threshold likely met, temptation to defect is high for everyone
    If my cooperation_rate is in top m:
        COOPERATE (maintain commitment to the end)
    Else:
        DEFECT
        
If likely_cooperators < m:
    # Threshold at risk
    If (likely_cooperators + 1 >= m) AND (my cooperation_rate > 0.3):
        COOPERATE (I could be pivotal)
    Else if likely_cooperators <= m/2:
        DEFECT (threshold unlikely regardless)
    Else:
        COOPERATE with probability (m - likely_cooperators) / (n - likely_cooperators)
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2, m = 2 | Always cooperate (both needed) |
| m = n-1 or m = n | Cooperate with probability 0.9 (near-universal cooperation needed) |
| k is very large (k > n) | Bias toward cooperation (+0.2 probability) |
| All players defected last round | Cooperate (someone must restart coordination) |
| I'm the only cooperator for 3+ rounds | Defect for 1 round (signal that free-riding won't be sustained) |
| Threshold met every round so far | Maintain current behavior (don't fix what works) |

---

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return COOPERATE with probability m/n
    
    # Calculate cooperation rates
    coop_rates = [times_cooperated[j] / (round - 1) for j in all_players]
    my_rank = rank_among(my_coop_rate, coop_rates)  # 1 = highest
    
    # Base decision
    if my_rank <= m:
        action = COOPERATE
    else:
        action = DEFECT
    
    # Adaptive adjustments
    if not threshold_met_last_round:
        if random() < 0.3 * consecutive_failures:
            action = COOPERATE
    
    if threshold_met_last_round and cooperators_last_round > m + 2:
        if my_coop_rate > avg_coop_rate + 0.2 and random() < 0.3:
            action = DEFECT
    
    # Final round logic
    if round == r:
        action = final_round_decision(coop_rates, m, n)
    
    return action
```

---

## Why This Strategy is Collectively Minded

1. **Fair burden sharing**: The m/n initial probability means I'm willing to do my proportional share
2. **Reliability signaling**: By consistently cooperating when in the responsibility group, I build trust
3. **Collective rescue**: When thresholds fail, I increase contribution rather than abandoning
4. **Avoiding waste**: I don't over-contribute when others have it covered
5. **Forgiveness**: I give defectors chances to rejoin cooperation through the reciprocity adjustment

This strategy aims to be a **dependable coalition member** that others can count on, while intelligently adapting to the actual group dynamics that emerge.
'''

description_COLLECTIVE_16 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the minimum viable coalition that achieves the threshold, while adapting to observed behavior to maximize collective success. The key insight is that **exactly m cooperators is optimal for the group** - it captures the bonus k for everyone while minimizing total contribution costs.

## Strategy Overview

I will probabilistically cooperate based on what cooperation rate would achieve exactly m cooperators in expectation, then adjust based on observed history to compensate for under- or over-cooperation in the population.

---

## Decision Rules

### Round 1: Baseline Probabilistic Cooperation

With no history, I cooperate with probability:

```
p_base = m / n
```

This is the probability that, if all n players independently cooperate with this rate, we expect exactly m cooperators on average. This represents my "fair share" of the collective burden.

**Implementation:** Generate a random number; cooperate if it falls below p_base.

### Rounds 2 through (r-1): Adaptive Cooperation

I adjust my cooperation probability based on observed outcomes:

```
Let:
  - success_rate = (rounds where ≥m cooperated) / (rounds played)
  - avg_cooperators = average number of cooperators across all rounds
  - deficit = m - avg_cooperators  (positive if under-threshold, negative if over)

Compute adjusted probability:
  p_adjusted = p_base + (deficit / n) × adjustment_factor

Where:
  adjustment_factor = 1.5  (responsive but not overreactive)

Clamp p_adjusted to [0.1, 0.9] to maintain some unpredictability
```

**Rationale:** 
- If the group is consistently failing to reach threshold, I increase my cooperation to help bridge the gap
- If the group is over-cooperating, I can safely reduce my contribution while the collective still succeeds
- The clamping prevents extreme behavior that could destabilize coordination

### Last Round (Round r): Threshold-Focused Decision

The last round has no future value, so I make a calculated decision:

```
If recent_cooperation_trend ≥ m - 1:
    # Others likely to meet threshold without me, or need exactly one more
    If recent_cooperation_trend == m - 1:
        Cooperate (I'm likely the pivotal player)
    Else:
        Defect (threshold likely met without me)
Else:
    # Threshold unlikely to be met
    If recent_cooperation_trend ≥ m - 2 AND my cooperation history has been mostly C:
        Cooperate (maintain cooperative reputation signals, might tip the balance)
    Else:
        Defect (threshold unreachable)
```

Where `recent_cooperation_trend` = average cooperators in last min(3, r-1) rounds.

---

## Edge Case Handling

### When m is very close to n (m ≥ n-1):
- Increase base cooperation probability to `min(0.85, m/n + 0.1)`
- Near-universal cooperation is required; I must contribute reliably

### When m is small relative to n (m ≤ n/3):
- Use standard formula but with slight reduction: `p = max(0.2, m/n - 0.05)`
- Many potential coalitions exist; I can afford to free-ride occasionally

### When k is very large (k > 2):
- Add a "safety premium" to cooperation: `p = p_base + 0.1`
- The cost of missing threshold is too high to risk

### When r is small (r ≤ 3):
- Increase cooperation in all rounds by 0.1
- Less time to adapt means I should err toward ensuring threshold success

---

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    p_base = m / n
    
    if round == 1:
        return COOPERATE with probability p_base
    
    # Calculate historical statistics
    avg_coop = mean(cooperators in each past round)
    deficit = m - avg_coop
    
    # Adjust probability
    p = p_base + (deficit / n) * 1.5
    
    # Parameter-based adjustments
    if m >= n - 1: p += 0.1
    if k > 2: p += 0.1
    if r <= 3: p += 0.1
    
    # Clamp
    p = clamp(p, 0.1, 0.9)
    
    # Last round logic
    if round == r:
        recent_avg = mean(cooperators in last 3 rounds)
        if recent_avg >= m - 0.5 and recent_avg < m + 0.5:
            return COOPERATE  # I'm pivotal
        elif recent_avg >= m + 0.5:
            return DEFECT     # Threshold safe without me
        else:
            return COOPERATE with probability 0.3  # Low chance but try
    
    return COOPERATE with probability p
```

---

## Why This Strategy is Collectively Aligned

1. **Fair burden sharing:** Base probability ensures I contribute my proportional share
2. **Responsive to need:** I cooperate more when the group needs it, less when it doesn't
3. **Not exploitative:** I never fully defect even when I could free-ride safely
4. **Threshold-aware:** I recognize that exactly m cooperators is collectively optimal
5. **Robust:** Probabilistic choices prevent exploitation by deterministic counter-strategies
'''

description_COLLECTIVE_17 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume other rational agents may also be designed with collective welfare in mind. The key insight is that exactly **m** cooperators is the optimal collective outcome—it meets the threshold while minimizing unnecessary sacrifice. My goal is to be one of those m cooperators when needed, but not to over-contribute when others are already covering the threshold.

## Strategy Overview

I use a **probabilistic commitment approach** calibrated to ensure the threshold is likely met, combined with **adaptive responsiveness** based on observed cooperation levels in previous rounds.

---

## Decision Rules

### Round 1: Calibrated Probabilistic Cooperation

With no history, I cooperate with probability based on what would collectively achieve exactly m cooperators in expectation:

```
base_probability = m / n
```

However, I add a small "safety margin" to account for coordination uncertainty:

```
first_round_coop_probability = min(1.0, (m + 0.5) / n)
```

**Decision:** Generate random number r ∈ [0,1]. Cooperate if r < first_round_coop_probability.

### Middle Rounds (2 to r-1): Adaptive Response

I track two key metrics from the previous round:
- `prev_cooperators`: number of players who cooperated
- `threshold_met`: whether prev_cooperators ≥ m

**Case 1: Threshold was met with exactly m cooperators**
- This is the ideal collective outcome
- If I cooperated: continue cooperating (I'm part of the essential group)
- If I defected: continue defecting (others have it covered)

**Case 2: Threshold was met with MORE than m cooperators**
- Over-contribution occurred; some cooperators are "wasted"
- If I cooperated: defect with probability `(prev_cooperators - m) / prev_cooperators`
- If I defected: remain defecting

**Case 3: Threshold was NOT met (fewer than m cooperators)**
- Collective failure; need more cooperation
- Calculate shortfall: `gap = m - prev_cooperators`
- Calculate defectors: `defector_count = n - prev_cooperators`
- If I cooperated: continue cooperating (maintain commitment)
- If I defected: cooperate with probability `min(1.0, gap / defector_count + 0.2)`
  - The +0.2 is a "responsibility boost" to help recover from failure

### Last Round (r): Threshold-Focused Decision

The last round requires special handling—no future rounds to correct mistakes.

```
If threshold was met in round r-1:
    Play the same action as round r-1 (stable success)
Else:
    Cooperate with probability = min(1.0, m / (n - prev_cooperators + 1))
    # Higher willingness to sacrifice for final collective success
```

---

## Edge Case Handling

### Edge Case: m is very close to n (m ≥ n-1)
- Near-universal cooperation required
- Boost all cooperation probabilities by factor: `1 + (m - n/2) / n`

### Edge Case: m is very small (m ≤ 2)
- Few cooperators needed; risk of over-contribution
- After first successful round, if I defected and threshold was met, stay defecting
- If I cooperated and threshold was met with surplus, switch to defect

### Edge Case: Very few rounds (r ≤ 3)
- Less time to adapt; be more cooperative early
- Multiply first-round probability by 1.2

### Edge Case: Persistent failure (threshold not met for 3+ consecutive rounds)
- Collective coordination has broken down
- Cooperate with probability 0.8 regardless of previous action
- "Someone has to step up"

---

## Pseudocode Summary

```
function decide(round, my_prev_action, prev_cooperators, n, m, k, r):
    
    if round == 1:
        prob = min(1.0, (m + 0.5) / n)
        return COOPERATE if random() < prob else DEFECT
    
    threshold_met = (prev_cooperators >= m)
    
    if round == r:  # Last round
        if threshold_met:
            return my_prev_action
        else:
            prob = min(1.0, m / max(1, n - prev_cooperators + 1))
            return COOPERATE if random() < prob else DEFECT
    
    # Middle rounds
    if threshold_met:
        if prev_cooperators == m:
            return my_prev_action  # Perfect balance, maintain
        else:  # Over-contribution
            if my_prev_action == COOPERATE:
                quit_prob = (prev_cooperators - m) / prev_cooperators
                return DEFECT if random() < quit_prob else COOPERATE
            else:
                return DEFECT
    else:  # Threshold not met
        if my_prev_action == COOPERATE:
            return COOPERATE  # Stay committed
        else:
            gap = m - prev_cooperators
            defectors = n - prev_cooperators
            prob = min(1.0, gap / max(1, defectors) + 0.2)
            return COOPERATE if random() < prob else DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Fair burden-sharing**: The probabilistic approach in round 1 distributes cooperation duty equitably
2. **Efficiency-seeking**: Aims for exactly m cooperators, not wasteful over-cooperation
3. **Responsive to failure**: Increases cooperation when collective is falling short
4. **Stable on success**: Maintains working configurations rather than disrupting them
5. **Self-sacrificing when needed**: Willing to switch from defection to cooperation to save the collective
'''

description_COLLECTIVE_18 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not more than necessary. The goal is to ensure the threshold is met while distributing the cooperation burden fairly across players who demonstrate willingness to contribute.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic fairness**: In equilibrium, exactly *m* players should cooperate, chosen fairly
2. **Reputation-weighted selection**: Reliable cooperators earn trust; defectors must rebuild it
3. **Temporal awareness**: Early rounds build information; late rounds require commitment

---

## Decision Rules

### Round 1: Baseline Cooperation Probability

With no history, cooperate with probability `m/n`.

This ensures that in expectation, exactly *m* players cooperate if all use this strategy, and signals willingness to be part of the solution.

```
P(Cooperate | Round 1) = m / n
```

### Rounds 2 through (r-1): Reputation-Weighted Adaptive Selection

**Step 1: Calculate cooperation scores for all players (including self)**

For each player *j*, compute:
```
score_j = (cooperation_count_j + 1) / (rounds_played + 2)
```
This Laplace-smoothed rate represents each player's demonstrated willingness to cooperate.

**Step 2: Assess recent threshold success**

```
recent_success_rate = (thresholds met in last min(3, rounds_played) rounds) / min(3, rounds_played)
```

**Step 3: Calculate my cooperation probability**

First, rank all players by their cooperation scores (ties broken by player index for determinism).

Let `my_rank` = my position when players are sorted by score (1 = highest cooperator).

**Base probability calculation:**
```
if my_rank <= m:
    # I'm among the top m cooperators - I should likely cooperate
    base_prob = 0.7 + 0.2 * (m - my_rank) / m
else:
    # I'm outside top m - cooperate only if threshold at risk
    base_prob = 0.3 * (1 - (my_rank - m) / (n - m))
```

**Adjustment for threshold success:**
```
if recent_success_rate < 0.5:
    # Threshold failing - increase cooperation urgently
    adjusted_prob = min(1.0, base_prob + 0.3)
elif recent_success_rate == 1.0:
    # Threshold always met - can slightly reduce if I'm marginal
    adjusted_prob = base_prob * 0.9
else:
    adjusted_prob = base_prob
```

**Final probability:**
```
P(Cooperate) = max(0.1, min(0.95, adjusted_prob))
```
(Floor and ceiling prevent complete predictability)

### Final Round (Round r): Commitment Protocol

The last round has no future consequences, creating defection incentive. Counter this with **heightened cooperation**:

```
if my cooperation_rate > 0.5:
    # I've been a cooperator - stay committed
    P(Cooperate) = 0.85
else:
    # I've been marginal - step up for the final push
    P(Cooperate) = m / n + 0.1
```

---

## Edge Case Handling

### Edge Case 1: m = n - 1 (Nearly unanimous cooperation needed)
When threshold is very high, increase base cooperation:
```
if m >= n - 1:
    P(Cooperate) = max(calculated_prob, 0.8)
```

### Edge Case 2: Very small groups (n ≤ 3)
With few players, each is critical:
```
if n <= 3:
    P(Cooperate) = max(calculated_prob, 0.7)
```

### Edge Case 3: Short games (r ≤ 3)
Limited time for reputation building - be more cooperative:
```
if r <= 3:
    P(Cooperate) = max(calculated_prob, m/n + 0.15)
```

### Edge Case 4: Threshold never met in last 3+ rounds
Emergency cooperation mode:
```
if consecutive_failures >= 3:
    P(Cooperate) = 0.9
```

---

## Pseudocode Summary

```python
def decide(game_params, history, my_id):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    if current_round == 1:
        return cooperate_with_probability(m / n)
    
    # Calculate cooperation scores for all players
    scores = []
    for player in range(n):
        coop_count = count_cooperations(history, player)
        scores.append((coop_count + 1) / (current_round + 1))
    
    # Get my rank among cooperators (1 = most cooperative)
    my_rank = get_rank(scores, my_id)
    
    # Calculate base probability from rank
    if my_rank <= m:
        base_prob = 0.7 + 0.2 * (m - my_rank) / m
    else:
        base_prob = 0.3 * (1 - (my_rank - m) / (n - m))
    
    # Adjust for recent threshold success
    recent_success = get_recent_success_rate(history, window=3)
    if recent_success < 0.5:
        prob = min(1.0, base_prob + 0.3)
    elif recent_success == 1.0:
        prob = base_prob * 0.9
    else:
        prob = base_prob
    
    # Final round commitment
    if current_round == r:
        my_coop_rate = scores[my_id]
        prob = 0.85 if my_coop_rate > 0.5 else m/n + 0.1
    
    # Apply bounds and edge cases
    prob = apply_edge_cases(prob, n, r, m, history)
    prob = max(0.1, min(0.95, prob))
    
    return cooperate_with_probability(prob)
```

---

## Why This Strategy is Collectively Minded

1. **Fair burden sharing**: Doesn't always cooperate or always defect - distributes responsibility based on demonstrated commitment
2. **Responsive to group needs**: Increases cooperation when threshold is failing
3. **Rewards reliability**: Players who cooperate consistently get recognized and can occasionally rest
4. **Robust to exploitation**: Doesn't naively cooperate against persistent defectors, but maintains baseline contribution
5. **Threshold-focused**: Aims for exactly *m* cooperators, not wasteful over-cooperation
'''

description_COLLECTIVE_19 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of exactly m cooperators when cooperation is needed, while avoiding redundant cooperation that wastes resources. The key insight is that in a collective, we need *enough* cooperators but not *excessive* cooperators—every cooperator beyond m sacrifices their private payoff unnecessarily.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic fairness**: Use a cooperation probability that, if adopted by all, yields exactly m expected cooperators
2. **Responsive adaptation**: Adjust based on observed cooperation levels in the population
3. **Threshold maintenance**: Prioritize ensuring the threshold is met over personal gain

---

## Decision Rules

### Round 1 (No History)

**Cooperate with probability p₀ = m/n**

This is the collectively optimal baseline: if all n players independently cooperate with probability m/n, the expected number of cooperators is exactly m.

### Rounds 2 through r-1 (Middle Rounds)

Calculate an **adaptive cooperation probability** based on observed history:

```
Let C_prev = number of cooperators in the previous round
Let C_avg = average cooperators across all previous rounds

# Determine cooperation gap
gap = m - C_avg

# Base probability starts at fair share
p_base = m / n

# Adjustment factor based on gap
# If too few cooperators historically, increase probability
# If too many, decrease (but maintain minimum)
adjustment = gap / n

# Cooperation probability for this round
p = clamp(p_base + adjustment * 0.5, lower=0.1, upper=0.9)
```

**Additional responsive rules:**

1. **Emergency cooperation**: If C_prev < m (threshold was missed last round), increase probability:
   - `p = min(p + 0.2, 0.95)`

2. **Efficiency adjustment**: If C_prev > m + 1 (excess cooperation), decrease probability:
   - `p = max(p - 0.1, m/(n+1))`

3. **Streak detection**: If threshold has been met for 3+ consecutive rounds with C consistently near m, maintain current approach (reduce variance in p toward current level)

**Then: Cooperate if random(0,1) < p**

### Final Round (Round r)

The last round requires special consideration since there's no future to influence:

```
# In the last round, be slightly more cooperative to ensure threshold
p_final = min((m + 0.5) / n + 0.1, 0.85)

# But also consider history - if others have been defecting heavily,
# don't be exploited
if C_avg < m * 0.6:
    p_final = m / n  # Return to baseline, don't over-sacrifice

Cooperate if random(0,1) < p_final
```

---

## Edge Case Handling

| Situation | Response |
|-----------|----------|
| **First round** | Cooperate with probability m/n |
| **Last round** | Slightly elevated cooperation (see above) |
| **Threshold never met** | Gradually increase p toward 0.8, signaling willingness |
| **Threshold always met with excess** | Gradually decrease p to reduce waste |
| **Exactly m cooperators repeatedly** | Maintain current p (system is balanced) |
| **m very close to n** | Maintain higher baseline p since margin for error is small |
| **m = 2 (low threshold)** | Be more willing to defect when others cooperate; p stays closer to m/n |

---

## Pseudocode Summary

```python
def decide(round, total_rounds, n, m, k, history):
    
    p_base = m / n
    
    if round == 1:
        p = p_base
    else:
        C_prev = count_cooperators(history[-1])
        C_avg = average_cooperators(history)
        gap = m - C_avg
        
        p = p_base + (gap / n) * 0.5
        
        # Emergency boost if threshold missed
        if C_prev < m:
            p = p + 0.2
        
        # Efficiency reduction if excess cooperation
        if C_prev > m + 1:
            p = p - 0.1
        
        # Last round adjustment
        if round == total_rounds:
            if C_avg >= m * 0.6:
                p = p + 0.1
        
        p = clamp(p, 0.1, 0.95)
    
    return COOPERATE if random() < p else DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Fair burden sharing**: Probabilistic cooperation distributes the cost of contribution across all players over time
2. **Adaptive**: Responds to actual group behavior rather than assuming specific opponent strategies
3. **Threshold-focused**: Prioritizes meeting m rather than maximizing personal gain
4. **Robust**: Works whether others are cooperative, selfish, or mixed
5. **Not exploitable**: Reduces cooperation when consistently over-contributing; doesn't endlessly sacrifice for pure defectors
'''

description_COLLECTIVE_20 = '''
# Collective Risk Dilemma Strategy: "Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I view myself as one of potentially many cooperators working to meet the threshold. My goal is to contribute to collective success while being responsive to the group's behavior. I aim to be a reliable cooperator when cooperation is viable, but I won't sacrifice endlessly if the group consistently fails to coordinate.

## Strategy Overview

The strategy operates on three principles:
1. **Optimistic initiation**: Start by cooperating to signal willingness and establish cooperative norms
2. **Threshold-aware persistence**: Continue cooperating if we're close to or meeting the threshold
3. **Gradual withdrawal**: Reduce cooperation probability if the group chronically fails, but always leave room for recovery

---

## Decision Rules

### Round 1 (No History)
**Action: COOPERATE**

Rationale: With no information, I signal cooperative intent. If enough others think similarly, we establish success early. The potential gain from hitting threshold (k) exceeds the cost of contributing (1).

### Rounds 2 through r-1 (Middle Rounds)

Calculate the following from the previous round:
- `prev_cooperators`: Number of players who cooperated last round
- `threshold_met`: Whether prev_cooperators ≥ m
- `cooperation_deficit`: max(0, m - prev_cooperators)

**Decision Logic:**

```
IF threshold_met last round:
    # Success breeds success - maintain cooperation
    COOPERATE with probability P_success
    
ELSE IF cooperation_deficit ≤ 2:
    # We were close - try to bridge the gap
    COOPERATE with probability P_close
    
ELSE:
    # Significant failure - but don't abandon entirely
    COOPERATE with probability P_failure
```

**Probability Calculations:**

```
# Base cooperation rate when successful
P_success = 0.85

# When close to threshold (within 2 of m)
P_close = 0.70 + 0.10 * (prev_cooperators / m)

# When far from threshold
P_failure = max(0.25, 0.50 - 0.05 * consecutive_failures)

# Adjust based on my relative position
# If I was among the cooperators when threshold failed, slightly reduce
# If I defected when threshold was met, slightly increase next round
```

**Consecutive Failure Tracking:**
- Track how many rounds in a row the threshold was NOT met
- Reset counter to 0 when threshold is met
- Cap the penalty from consecutive failures (minimum cooperation probability: 0.25)

### Final Round (Round r)

The last round has no future consequences, making defection more tempting. However, maintaining collective benefit matters:

```
IF threshold was met in majority of previous rounds:
    # Established cooperation norm - honor it
    COOPERATE with probability 0.60
    
ELSE IF threshold met last round:
    # Recent success worth preserving
    COOPERATE with probability 0.50
    
ELSE:
    # Pattern of failure - protect individual payoff
    COOPERATE with probability 0.30
```

---

## Adaptive Mechanisms

### Historical Success Rate Modifier

```
success_rate = (rounds where threshold met) / (total completed rounds)

# Boost cooperation if group is succeeding
IF success_rate > 0.7:
    Add +0.10 to cooperation probability
    
# Reduce if chronic failure
ELSE IF success_rate < 0.3 AND completed_rounds > 3:
    Subtract 0.10 from cooperation probability
```

### Threshold Proximity Bonus

When the group is exactly at or one above threshold, I become more likely to cooperate to maintain the coalition:

```
IF prev_cooperators == m OR prev_cooperators == m + 1:
    Add +0.15 to cooperation probability (cap at 0.95)
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2, m = 2 | Both must cooperate; use standard rules but with P_success = 0.90 |
| m very close to n | Higher base cooperation needed; add +0.10 to all probabilities |
| m very small relative to n | Lower base cooperation sufficient; use standard probabilities |
| k is very large | Standard strategy already accounts for high threshold value |
| r = 2 (minimal rounds) | Round 1: Cooperate; Round 2: Apply final round logic |

---

## Summary Pseudocode

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE
    
    prev_coop = count_cooperators(history, round - 1)
    threshold_met = prev_coop >= m
    consec_fail = count_consecutive_failures(history)
    success_rate = count_successes(history) / (round - 1)
    
    # Base probability
    if threshold_met:
        p = 0.85
    elif (m - prev_coop) <= 2:
        p = 0.70 + 0.10 * (prev_coop / m)
    else:
        p = max(0.25, 0.50 - 0.05 * consec_fail)
    
    # Modifiers
    if success_rate > 0.7:
        p += 0.10
    elif success_rate < 0.3 and round > 4:
        p -= 0.10
    
    if prev_coop in [m, m+1]:
        p += 0.15
    
    # Final round adjustment
    if round == r:
        p *= 0.70
    
    p = clip(p, 0.15, 0.95)
    
    return COOPERATE if random() < p else DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **Starts cooperative**: Gives the group the best chance to establish success
2. **Forgives occasional failures**: Doesn't immediately punish, recognizing coordination is hard
3. **Maintains hope**: Never drops below 15-25% cooperation, allowing recovery
4. **Rewards group success**: Higher cooperation when things are working
5. **Protects against exploitation**: Gradually reduces contribution if chronically failing
6. **Threshold-focused**: Concentrates effort around the critical mass needed
'''

description_COLLECTIVE_21 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not more than necessary. The goal is to coordinate implicitly through observable behavior patterns, ensuring the threshold is met while minimizing exploitation by free-riders.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to the game parameters and adapted based on observed history. The key insight is that if all players used the same rational collective strategy, each would cooperate with probability approximately m/n to achieve threshold coordination in expectation.

---

## Decision Rules

### Round 1: Baseline Cooperation

**Cooperate with probability p₁ = m/n**

Rationale: With no history, assume others may think similarly. If n players each cooperate with probability m/n, expected cooperators ≈ m. I lean slightly toward cooperation to account for uncertainty.

```
p_initial = m / n
if random() < p_initial:
    return COOPERATE
else:
    return DEFECT
```

### Rounds 2 through (r-1): Adaptive Response

Calculate cooperation probability based on:

1. **Observed cooperation rate** from previous round
2. **Gap to threshold** - how far were we from m?
3. **Trend detection** - is cooperation rising or falling?

```
Let prev_cooperators = number who cooperated last round
Let cooperation_rate = prev_cooperators / n
Let gap = m - prev_cooperators  # positive means shortfall, negative means surplus

# Base probability anchored on what's needed
if gap > 0:
    # Shortfall: increase my cooperation probability
    p_base = min(1.0, (m / n) + (gap / n) * 0.5)
elif gap < 0:
    # Surplus: I can potentially defect, but carefully
    p_base = max(0.1, (m / n) - (|gap| / n) * 0.3)
else:
    # Exactly at threshold
    p_base = m / n

# Trend adjustment over last 3 rounds (if available)
if cooperation is declining:
    p_adjusted = p_base + 0.15
elif cooperation is rising above m:
    p_adjusted = p_base - 0.1
else:
    p_adjusted = p_base

# Consistency bonus: if I cooperated last round and threshold was met
if I_cooperated_last_round AND prev_cooperators >= m:
    # Slight tendency to maintain role as reliable cooperator
    p_adjusted = max(p_adjusted, 0.6)

return COOPERATE if random() < p_adjusted else DEFECT
```

### Final Round (Round r): Strategic Endgame

The last round has no future consequences, creating defection incentives. However, maintaining collective success matters for total payoff.

```
# Check if threshold was consistently met
consistency = (rounds where cooperators >= m) / (r - 1)

if consistency >= 0.7:
    # System is working - continue pattern but slight defection bias
    p_final = max(m/n - 0.1, 0.2)
else:
    # System is failing - threshold benefit unlikely
    p_final = 0.15  # Low but non-zero (signal cooperative intent)

# If I've been a consistent cooperator, slightly maintain role
if my_cooperation_rate > 0.6:
    p_final = min(p_final + 0.2, m/n)

return COOPERATE if random() < p_final else DEFECT
```

---

## Edge Case Handling

| Situation | Response |
|-----------|----------|
| **m = n-1** (high threshold) | Increase base cooperation to m/n + 0.15 |
| **m = 2** (low threshold) | Standard formula, but cap reduction at 0.2 |
| **k is very large** | More aggressive cooperation (stakes are high) |
| **Everyone defected last round** | Cooperate with probability 0.7 (try to restart) |
| **Everyone cooperated last round** | Slight reduction acceptable: p = m/n - 0.1 |
| **I'm the only cooperator repeatedly** | Reduce to 0.3 (don't be exploited indefinitely) |
| **Exactly m cooperated including me** | Maintain cooperation (I'm needed) |
| **Exactly m cooperated excluding me** | Can defect more freely: p = 0.3 |

---

## Key Adaptive Mechanisms

1. **Responsive to shortfall**: When cooperation falls below m, I increase my probability
2. **Exploitation resistance**: If I'm consistently cooperating while many defect, I gradually reduce
3. **Role maintenance**: If I've established myself as a cooperator and it's working, I continue
4. **Probabilistic humility**: I never assume perfect coordination; randomization handles uncertainty

---

## Why This Strategy is Collectively Minded

- **Fair contribution**: Base rate m/n means I'm willing to do my proportional share
- **Gap-filling**: I step up when cooperation is insufficient
- **Not a sucker**: I reduce cooperation if consistently exploited
- **Enables coordination**: Predictable patterns help implicit coordination emerge
- **Threshold-focused**: Every decision orients around achieving exactly m cooperators
'''

description_COLLECTIVE_22 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of a reliable coalition that meets the threshold, while adapting to the actual behavior I observe. The key insight is that **exactly m cooperators is the efficient outcome** - more wastes resources, fewer fails everyone. I should cooperate when I'm likely needed and defect when cooperation is redundant.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to the game parameters and observed history. The probability is designed so that if all players used this strategy, we'd reliably meet (but not vastly exceed) the threshold.

---

## Decision Rules

### Round 1: Baseline Cooperation Probability

With no history, cooperate with probability based on what would achieve threshold if all players reasoned similarly:

```
base_probability = (m + 1) / n
```

This slightly overshoots the exact threshold (m/n) to provide a safety margin for the collective.

**Decision:** Cooperate if `random() < base_probability`

---

### Rounds 2 through (r-1): Adaptive Response

After observing history, I adjust based on two factors:

#### Factor 1: Cooperation Deficit/Surplus
Look at the previous round:
- `cooperators_last_round` = number who cooperated
- `deficit = m - cooperators_last_round`

#### Factor 2: My Responsibility Index
I need a deterministic way to "rank" myself among players to enable implicit coordination:
- Use my player index `i` and round number `t` to compute a responsibility score
- `responsibility_score = hash(i, t) mod 1000 / 1000` (gives value in [0,1])

#### Adaptive Probability Calculation:

```
if deficit > 0:
    # We failed last round - increase cooperation
    urgency = min(deficit / m, 1)  # How badly we failed
    adjusted_prob = base_probability + (1 - base_probability) * urgency * 0.5
    
elif deficit < 0:
    # We had surplus cooperators - some can safely defect
    surplus = -deficit
    adjusted_prob = base_probability - (surplus / n) * 0.3
    
else:
    # Exactly hit threshold - maintain similar behavior
    adjusted_prob = base_probability
```

#### Cooperation Momentum Adjustment:
Track cooperation rate over all previous rounds:
```
historical_coop_rate = total_cooperations / (total_players * rounds_played)
expected_rate = m / n

if historical_coop_rate < expected_rate * 0.8:
    # Group is under-cooperating - I should step up
    adjusted_prob = adjusted_prob + 0.15
elif historical_coop_rate > expected_rate * 1.3:
    # Group is over-cooperating - I can ease off
    adjusted_prob = adjusted_prob - 0.1
```

#### Final Decision:
```
final_prob = clamp(adjusted_prob, 0.1, 0.95)  # Never fully predictable

if responsibility_score < final_prob:
    COOPERATE
else:
    DEFECT
```

---

### Final Round (Round r): Threshold Targeting

The last round has no future consequences, but the collective goal remains.

```
# Count "reliable cooperators" from history (cooperated >60% of time)
reliable_count = count players with cooperation_rate > 0.6

if reliable_count < m:
    # Not enough reliable cooperators - I must help
    COOPERATE with probability 0.85
    
elif reliable_count == m:
    # Exactly enough - cooperate if I'm one of the reliable ones
    if my_cooperation_rate > 0.6:
        COOPERATE
    else:
        COOPERATE with probability 0.4
        
else:
    # Surplus of reliable cooperators
    if my_cooperation_rate > 0.6:
        # I've earned the right to defect if others have it covered
        COOPERATE with probability 0.5
    else:
        DEFECT
```

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **m = n-1** (nearly unanimous needed) | Increase base_probability to `(m + 0.5) / n` |
| **m = 2** (low threshold) | Decrease base_probability to `(m + 0.3) / n` |
| **r = 2** (only 2 rounds) | Use final round logic in round 2, higher cooperation in round 1 |
| **k is very large** | No change - strategy is threshold-focused, not payoff-greedy |
| **Observed: same players always cooperate** | Slightly reduce my probability if they seem committed |
| **Observed: total chaos/random play** | Revert toward base_probability |

---

## Summary Pseudocode

```python
def decide(player_id, round, history, n, m, r, k):
    base_prob = (m + 1) / n
    resp_score = deterministic_hash(player_id, round) % 1000 / 1000
    
    if round == 1:
        return COOPERATE if resp_score < base_prob else DEFECT
    
    if round == r:
        return final_round_logic(history, m, player_id)
    
    # Adaptive middle rounds
    last_round_coops = count_cooperators(history, round - 1)
    deficit = m - last_round_coops
    
    adjusted_prob = base_prob
    if deficit > 0:
        adjusted_prob += (1 - base_prob) * min(deficit/m, 1) * 0.5
    elif deficit < 0:
        adjusted_prob -= (-deficit / n) * 0.3
    
    # Historical adjustment
    hist_rate = historical_cooperation_rate(history)
    if hist_rate < (m/n) * 0.8:
        adjusted_prob += 0.15
    elif hist_rate > (m/n) * 1.3:
        adjusted_prob -= 0.1
    
    final_prob = clamp(adjusted_prob, 0.1, 0.95)
    return COOPERATE if resp_score < final_prob else DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Targets the threshold, not personal gain**: I don't try to free-ride; I try to be part of exactly m cooperators
2. **Responsive to group needs**: I cooperate more when we're failing, less when we're over-contributing
3. **Fair burden-sharing**: The responsibility score rotates who "steps up" across rounds
4. **Robust to defectors**: If others defect persistently, I increase cooperation to compensate
5. **Not exploitable**: Maintains minimum cooperation floor, doesn't become fully predictable
'''

description_COLLECTIVE_23 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the **m cooperators needed** to secure the collective reward, but I should not cooperate unnecessarily when others are already providing sufficient cooperation. The goal is reliable threshold achievement with fair burden-sharing over time.

## Strategic Framework

### Key Insight

The critical tension in this game is:
- If fewer than m cooperate, everyone loses the bonus k (collective disaster)
- If exactly m cooperate, cooperators get k while defectors get 1+k (free-riding rewarded)
- If more than m cooperate, excess cooperation is "wasted"

A collectively-minded player should aim to be part of a reliable m-sized coalition while encouraging others to take their fair share of turns cooperating.

---

## Decision Rules

### Round 1: Probabilistic Cooperation

**Cooperate with probability m/n**

Rationale: If all n players independently cooperate with probability m/n, the expected number of cooperators is m. This is the collectively optimal starting point that fairly distributes initial cooperation burden.

```
first_round_action = COOPERATE if random() < (m/n) else DEFECT
```

---

### Rounds 2 through r-1: Adaptive Response

Calculate these metrics from the previous round:

1. **cooperation_count**: Number of players who cooperated last round
2. **threshold_met**: Whether cooperation_count ≥ m
3. **my_cooperation_rate**: My cooperation frequency so far
4. **group_cooperation_rate**: Average cooperation rate across all players

**Decision Logic:**

```
IF cooperation_count < m (threshold failed):
    # Crisis response: Increase cooperation willingness
    cooperate_probability = min(1.0, (m / max(cooperation_count, 1)) * (m/n))
    
ELSE IF cooperation_count == m (exactly at threshold):
    # Fragile equilibrium: Maintain current contributors
    IF I cooperated last round:
        cooperate_probability = 0.9  # Stay reliable
    ELSE:
        cooperate_probability = m/n  # Standard rate
        
ELSE IF cooperation_count > m (excess cooperation):
    # Room for burden-sharing rotation
    IF my_cooperation_rate > group_cooperation_rate:
        # I've done more than my share - reduce slightly
        cooperate_probability = max(0.3, (m/n) - 0.1)
    ELSE:
        # I've done less - step up
        cooperate_probability = min(0.9, (m/n) + 0.2)
```

**Reputation-Based Adjustment:**

```
# Identify consistent defectors (cooperated < 20% of rounds)
chronic_defector_count = count players with cooperation_rate < 0.2

# If too many free-riders, remaining cooperators must compensate
adjusted_m = m  # Still need m cooperators
effective_n = n - chronic_defector_count  # Smaller reliable pool

IF effective_n >= m:
    # Adjust probability among reliable players
    cooperate_probability = adjust toward (m / effective_n)
ELSE:
    # Not enough reliable players - maximize own cooperation
    cooperate_probability = 1.0
```

---

### Final Round (Round r): Calculated Commitment

The last round removes future consequences, but collective success still matters.

```
# Estimate how many others will cooperate based on their history
expected_others_cooperating = sum(cooperation_rate[j] for j ≠ me)

IF expected_others_cooperating < m - 1:
    # My cooperation alone can't save us - DEFECT
    action = DEFECT
    
ELSE IF expected_others_cooperating >= m:
    # Others likely have it covered
    IF my_cooperation_rate < group_cooperation_rate:
        action = COOPERATE  # Do my fair share one last time
    ELSE:
        action = DEFECT  # I've contributed enough
        
ELSE:  # expected_others is between m-1 and m
    # I might be pivotal - COOPERATE
    action = COOPERATE
```

---

## Edge Case Handling

| Scenario | Response |
|----------|----------|
| **r = 2** (minimal rounds) | Cooperate round 1 with prob m/n; round 2 use final round logic |
| **m = n-1** (nearly unanimous required) | Cooperate with high probability (~0.85) throughout |
| **m = 2** (low threshold) | Cooperate with probability m/n but be ready to step up if threshold fails |
| **k is very large** | Weight toward cooperation; the collective reward dominates |
| **All others defecting** | Defect (can't reach threshold alone unless m=1, which is excluded) |
| **Threshold never met** | Steadily increase cooperation probability each round by 0.1 until capped at 1.0 |

---

## Summary Pseudocode

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return COOPERATE if random() < m/n else DEFECT
    
    last_round_coops = count_cooperators(history, round-1)
    my_coop_rate = my_cooperation_rate(history)
    group_coop_rate = average_cooperation_rate(history)
    
    if round == r:  # Final round
        expected_others = estimate_others_cooperating(history)
        if expected_others < m - 1:
            return DEFECT
        elif expected_others >= m:
            return COOPERATE if my_coop_rate < group_coop_rate else DEFECT
        else:
            return COOPERATE
    
    # Middle rounds
    base_prob = m / n
    
    if last_round_coops < m:
        prob = min(1.0, base_prob * (m / max(last_round_coops, 1)))
    elif last_round_coops == m:
        prob = 0.9 if i_cooperated_last(history) else base_prob
    else:
        if my_coop_rate > group_coop_rate:
            prob = max(0.3, base_prob - 0.1)
        else:
            prob = min(0.9, base_prob + 0.2)
    
    return COOPERATE if random() < prob else DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Fair initial distribution**: Round 1 probability m/n gives everyone equal expected burden
2. **Responsive to failure**: Increases cooperation when thresholds aren't met
3. **Discourages free-riding**: Tracks cooperation rates and adjusts to compensate for chronic defectors
4. **Burden rotation**: Allows cooperators to occasionally rest when excess cooperation exists
5. **Pivotal awareness**: In final round, cooperates when likely to make the difference
6. **No exploitation**: Doesn't naively always cooperate, maintaining credible defection threat
'''

description_COLLECTIVE_24 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed to secure the collective reward, but not a sucker who cooperates when it's unnecessary or futile. The goal is to establish myself as a reliable cooperator that others can count on, while adapting to the actual cooperation levels observed.

## Strategy Overview

I use a **conditional cooperation** approach with **probabilistic commitment** that adapts based on observed cooperation rates and game phase. The key insight: if exactly *m* players reliably cooperate, everyone benefits—cooperators get *k*, defectors get *1+k*. I want to be in that reliable *m* group, signaling dependability to encourage a stable equilibrium.

---

## Decision Rules

### Round 1: Establish Cooperative Intent
**Action: Cooperate with probability p₀ = m/n**

Rationale: If all players use this probability, expected cooperators ≈ m. This is a fair, symmetric starting point that signals willingness to contribute without over-committing.

### Rounds 2 through (r-1): Adaptive Conditional Cooperation

**Step 1: Calculate cooperation rate from previous round**
```
prev_cooperators = count of C actions in round t-1
coop_rate = prev_cooperators / n
```

**Step 2: Determine my base cooperation probability**

```
target_rate = m / n  # The cooperation rate we need

if prev_cooperators >= m:
    # Threshold was met - reward cooperation, maintain stability
    if I_cooperated_last_round:
        p_base = 0.85  # Stay cooperative (loyalty)
    else:
        p_base = 0.3   # Consider joining if there's room
        
elif prev_cooperators == m - 1:
    # We were ONE short - I could be pivotal
    if I_cooperated_last_round:
        p_base = 0.95  # Definitely stay - I might be essential
    else:
        p_base = 0.7   # Strongly consider joining - I could tip the balance
        
elif prev_cooperators < m - 1:
    # Far from threshold - need to build coalition
    if I_cooperated_last_round:
        p_base = 0.6   # Cautiously maintain, but protect myself
    else:
        p_base = target_rate * 1.2  # Slightly elevated willingness to help build
```

**Step 3: Adjust for cooperation trend**
```
if round >= 3:
    trend = (cooperators in t-1) - (cooperators in t-2)
    if trend > 0:
        p_adjust = +0.1  # Cooperation rising, join the wave
    elif trend < 0:
        p_adjust = -0.1  # Cooperation falling, protect myself
    else:
        p_adjust = 0
    
    p_base = clamp(p_base + p_adjust, 0.1, 0.95)
```

**Step 4: Make decision**
```
Cooperate if random() < p_base
```

### Final Round (Round r): Strategic Endgame

The last round has no future shadow, so pure self-interest dominates for many. However, I maintain partial cooperation:

```
if prev_cooperators >= m:
    # Cooperation has been sustained - modest chance to maintain
    p_final = 0.4 if I_cooperated_last_round else 0.2
else:
    # Cooperation already failing - minimize losses
    p_final = 0.15
    
Cooperate if random() < p_final
```

Rationale: Some opponents may expect mass defection and counter-defect. By maintaining some cooperation probability, I can still capture *k* if enough others think similarly.

---

## Edge Case Handling

| Situation | Action |
|-----------|--------|
| **n = m** (everyone must cooperate) | Higher cooperation: p₀ = 0.8, stay committed |
| **m = 2** (only 2 needed) | Lower individual burden: p₀ = max(2/n, 0.4) |
| **k is very large** | Increase all probabilities by factor of min(k/2, 1.3) |
| **Very short game (r ≤ 3)** | Front-load cooperation: round 1 p₀ = 0.7 |
| **Very long game (r > 20)** | Standard rules apply; trends become more reliable |

---

## Why This Strategy is Collectively Minded

1. **Fair burden sharing**: My baseline cooperation rate targets exactly m/n, not freeloading
2. **Pivotal awareness**: I increase cooperation when I could be the deciding vote
3. **Loyalty**: I stick with cooperation when it's working rather than exploiting others
4. **Coalition building**: I help build toward threshold even after failures
5. **Graceful degradation**: I don't abandon cooperation entirely, even late in the game

This strategy aims to be the kind of player that *enables* collective success rather than merely exploiting it.
'''

description_COLLECTIVE_25 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of a reliable coalition that meets the threshold `m`, while adapting to the actual cooperation levels observed. The goal is to be a dependable cooperator when cooperation is viable, but not a sucker when collective action has clearly failed.

## Decision Framework

### Key Insight

The optimal collective outcome requires exactly `m` cooperators (threshold met, minimal sacrifice). However, without coordination mechanisms, we cannot assign roles. Therefore, I adopt a **probabilistic cooperation approach** calibrated to produce approximately `m` cooperators in expectation, adjusted based on observed behavior.

---

## Strategy Specification

### Round 1: Baseline Cooperation Probability

**Decision Rule:** Cooperate with probability `p_base = m/n`

This ensures that if all players use this strategy, expected cooperators = `n × (m/n) = m`, exactly meeting the threshold.

**Rationale:** Without history, this is the collectively rational starting point that balances contribution burden fairly.

---

### Rounds 2 to (r-1): Adaptive Cooperation

**Calculate cooperation history:**
- `coop_rate` = (total C plays by all players in all previous rounds) / (n × rounds_played)
- `threshold_met_rate` = (rounds where ≥m cooperated) / rounds_played
- `deficit` = how far below threshold we typically fall (if applicable)

**Decision Rules:**

```
IF threshold_met_rate >= 0.7:
    # Cooperation is working - maintain but don't over-contribute
    IF coop_rate > (m+1)/n:
        # Others are cooperating plenty - I can occasionally defect
        p_cooperate = max(0.3, (m/n) - 0.1)
    ELSE:
        # Stay the course
        p_cooperate = m/n

ELSE IF threshold_met_rate >= 0.4:
    # Borderline - increase cooperation to tip the balance
    p_cooperate = min(0.9, (m/n) + 0.2)

ELSE IF threshold_met_rate > 0:
    # Struggling but not hopeless - commit more strongly
    p_cooperate = min(0.95, (m/n) + 0.3)

ELSE:
    # Complete failure so far - attempt rescue for a few rounds, then give up
    IF rounds_played <= r/3:
        p_cooperate = 0.8  # Strong signal of willingness
    ELSE:
        p_cooperate = 0.2  # Mostly defect, occasional probe
```

**Additional Adjustment - Momentum Detection:**
```
recent_coop_rate = cooperation rate in last 3 rounds
IF recent_coop_rate is increasing AND threshold not yet reliably met:
    p_cooperate += 0.15  # Reinforce positive momentum
IF recent_coop_rate is decreasing AND was previously meeting threshold:
    p_cooperate += 0.1   # Try to arrest decline
```

---

### Final Round (Round r): Conditional Cooperation

The last round has no future shadow, creating defection incentive. However, maintaining collective success matters for total payoff.

**Decision Rule:**
```
IF threshold_met_rate >= 0.6 throughout game:
    # We've built something worth preserving
    p_cooperate = m/n  # Maintain baseline commitment
    
ELSE IF threshold was met in round (r-1):
    # Don't be the one to break a working system at the end
    p_cooperate = m/n
    
ELSE:
    # Cooperation has failed - no point sacrificing alone
    p_cooperate = 0.1  # Small probe in case others surprise
```

---

### Edge Cases

1. **n = 2, m = 2:** Both must cooperate. Start with p=0.7, increase to 0.9 if partner ever cooperated, drop to 0.1 after 3 consecutive mutual defections.

2. **m very close to n (e.g., m = n-1):** High cooperation required. Use p_base = 0.9, only reduce if threshold consistently met with room to spare.

3. **m very small (e.g., m = 2 with large n):** Use p_base = m/n but floor at 0.15 to avoid everyone defecting.

4. **Very short games (r ≤ 3):** Weight toward cooperation (multiply p by 1.2, cap at 0.95) since there's little time to recover from early defection spirals.

5. **Very long games (r > 20):** More room for experimentation. In early rounds (first 20%), occasionally defect even when successful to test group resilience.

---

## Pseudocode Summary

```python
def decide(game_params, history):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    p_base = m / n
    
    if current_round == 1:
        return cooperate_with_probability(p_base)
    
    coop_rate = calculate_overall_cooperation_rate(history)
    threshold_met_rate = calculate_threshold_success_rate(history, m)
    recent_trend = calculate_recent_trend(history, window=3)
    
    # Adaptive probability
    if threshold_met_rate >= 0.7:
        p = p_base if coop_rate <= (m+1)/n else max(0.3, p_base - 0.1)
    elif threshold_met_rate >= 0.4:
        p = min(0.9, p_base + 0.2)
    elif threshold_met_rate > 0:
        p = min(0.95, p_base + 0.3)
    else:
        p = 0.8 if current_round <= r/3 else 0.2
    
    # Momentum adjustment
    if recent_trend == "increasing" and threshold_met_rate < 0.7:
        p = min(1.0, p + 0.15)
    elif recent_trend == "decreasing" and threshold_met_rate >= 0.4:
        p = min(1.0, p + 0.1)
    
    # Final round adjustment
    if current_round == r:
        if threshold_met_rate < 0.5 and not threshold_met_last_round(history, m):
            p = 0.1
    
    return cooperate_with_probability(p)
```

---

## Why This Strategy is Collectively Aligned

1. **Fair burden-sharing:** Base probability `m/n` distributes cooperation duty equally in expectation
2. **Responsive to collective success:** Increases commitment when the group is close to threshold
3. **Doesn't enable free-riding indefinitely:** Reduces cooperation if others consistently defect
4. **Preserves successful coalitions:** Maintains cooperation when the collective is working
5. **Forgiveness built-in:** Always maintains some cooperation probability, allowing recovery from bad starts
'''

description_COLLECTIVE_26 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I want the group to succeed, and I'm willing to bear my fair share of the cooperation burden—but I'll adapt based on whether others demonstrate similar commitment.** The goal is to reliably meet the threshold while avoiding exploitation.

## Strategic Framework

### Key Insight

The critical tension in this game is:
- We need exactly m cooperators (or slightly more for safety margin) to unlock rewards
- Being a cooperator when exactly m cooperate yields payoff k, while defecting yields 1+k
- But if too many defect hoping to free-ride, everyone gets only 1

A collectively-minded player should **volunteer to be one of the m cooperators** unless there's strong evidence that m others will reliably cooperate without them.

---

## Decision Rules

### Round 1: Probabilistic Fair Share

With no history, cooperate with probability based on fair share plus a cooperation premium:

```
base_probability = m / n  (fair share)
cooperation_premium = 0.15  (bias toward collective success)
P(Cooperate) = min(1, base_probability + cooperation_premium)
```

**Rationale:** If everyone used fair-share probability, expected cooperators ≈ m. The premium provides a safety buffer and signals cooperative intent.

---

### Rounds 2 through (r-1): Adaptive Response

#### Step 1: Assess Group Cooperation Health

```
cooperation_rate = (total C plays by all players in all previous rounds) / (n × rounds_played)
expected_fair_rate = m / n

health_ratio = cooperation_rate / expected_fair_rate
```

#### Step 2: Determine Cooperation Probability

**Case A: Healthy Cooperation (health_ratio ≥ 0.9)**
- The group is meeting or nearly meeting its cooperation needs
- Cooperate with probability: `(m / n) + 0.1`
- Slightly above fair share to maintain momentum

**Case B: Struggling Cooperation (0.5 ≤ health_ratio < 0.9)**
- Group needs more cooperators to reliably hit threshold
- Cooperate with probability: `min(1, (m / n) + 0.3 × (1 - health_ratio))`
- Increase willingness as group struggles more

**Case C: Severely Deficient (health_ratio < 0.5)**
- Most players are defecting; collective action is failing
- **Conditional escalation:** Cooperate with probability 0.7 for next 2 rounds
- If health doesn't improve after escalation, reduce to `m / n` (fair share only)
- *Rationale:* Try to rescue cooperation, but don't be exploited indefinitely

#### Step 3: Recent Round Adjustment

Look at the last round specifically:
```
last_round_cooperators = count of C plays in round t-1

if last_round_cooperators >= m:
    # Threshold was met - slight reduction okay
    adjustment = -0.05
elif last_round_cooperators == m - 1:
    # Just missed! Increase urgency
    adjustment = +0.15
else:
    # Badly missed
    adjustment = +0.10
```

#### Final Cooperation Probability
```
P(Cooperate) = clamp(base_from_step2 + adjustment, 0.1, 0.95)
```
Never go below 0.1 (maintain hope) or above 0.95 (preserve some strategic flexibility).

---

### Final Round (Round r): Calculated Commitment

The last round has no future to influence, but collective success still matters for total payoff.

```
if average_cooperation_rate_overall >= (m/n) - 0.1:
    # Group has been reasonably cooperative
    # Cooperate at fair-share rate to give group best chance
    P(Cooperate) = m / n + 0.1
else:
    # Group has chronically undercooperated
    # Still give it a fair shot, but don't overcommit
    P(Cooperate) = m / n
```

---

## Edge Case Handling

| Situation | Response |
|-----------|----------|
| **n = m** (all must cooperate) | Always cooperate—defection guarantees collective failure |
| **m = 1** (only one needed) | Cooperate with P = 1/n + 0.2; increase if threshold repeatedly missed |
| **r = 2** (minimal rounds) | Use Round 1 rules, then Final Round rules—limited adaptation window |
| **k is very large** | Standard rules apply; high k makes threshold success crucial for everyone |
| **Observed: exactly m-1 cooperated last round** | Emergency boost: add 0.2 to cooperation probability |

---

## Pseudocode Summary

```
function decide(round, history, n, m, r, k):
    
    if round == 1:
        return random() < min(1, m/n + 0.15)
    
    # Calculate cooperation metrics
    total_plays = n * (round - 1)
    total_cooperations = sum(all C plays in history)
    cooperation_rate = total_cooperations / total_plays
    health_ratio = cooperation_rate / (m / n)
    last_round_coops = count(C in round-1)
    
    # Base probability from health assessment
    if health_ratio >= 0.9:
        base_p = m/n + 0.1
    elif health_ratio >= 0.5:
        base_p = min(1, m/n + 0.3 * (1 - health_ratio))
    else:
        if in_escalation_period:
            base_p = 0.7
        else:
            base_p = m/n
    
    # Recent round adjustment
    if last_round_coops >= m:
        adjust = -0.05
    elif last_round_coops == m - 1:
        adjust = 0.15
    else:
        adjust = 0.10
    
    # Final round modification
    if round == r:
        adjust = 0  # Remove tactical adjustments
        if cooperation_rate < (m/n) - 0.1:
            base_p = m/n
    
    final_p = clamp(base_p + adjust, 0.1, 0.95)
    return random() < final_p
```

---

## Why This Strategy is Collectively Minded

1. **Fair share commitment:** Baseline willingness to cooperate at m/n rate
2. **Cooperative premium:** Bias toward cooperation to ensure threshold success
3. **Responsive to need:** Increases cooperation when group struggles
4. **Forgiving:** Doesn't permanently punish past defection
5. **Sustainable:** Avoids complete exploitation while maintaining hope for collective success
6. **Threshold-focused:** Adjustments keyed to whether m is being reached, not abstract reciprocity
'''

description_COLLECTIVE_27 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of exactly m cooperators when possible, ensuring the threshold is met while minimizing unnecessary sacrifice. I adapt based on observed group behavior, reward reliable cooperators by letting them occasionally defect, and maintain cooperation pressure through conditional reciprocity.

## Strategy Overview

The strategy operates on three principles:
1. **Threshold targeting**: Aim for exactly m cooperators (efficient collective outcome)
2. **Fair burden sharing**: Cooperators should rotate over time
3. **Adaptive trust**: Increase cooperation when others are unreliable, decrease when stable

---

## Decision Rules

### Round 1: Probabilistic Seeding

With no history, I cooperate with probability `m/n`.

This gives the collective the best chance of hitting exactly m cooperators if all players use similar reasoning.

```
first_round_action = COOPERATE with probability (m/n), else DEFECT
```

### Rounds 2 through (r-1): Adaptive Cooperation

**Step 1: Calculate cooperation metrics from previous round**
- `prev_cooperators` = number of players who cooperated last round
- `my_prev_action` = my action last round

**Step 2: Determine base cooperation probability**

```
if prev_cooperators < m:
    # Threshold was missed - increase cooperation urgency
    shortfall = m - prev_cooperators
    base_prob = min(1.0, (m + shortfall) / n)
    
elif prev_cooperators == m:
    # Perfect efficiency achieved
    if my_prev_action == COOPERATE:
        # I contributed last time; slightly reduce my burden
        base_prob = (m - 0.5) / n
    else:
        # I free-rode last time; increase my contribution likelihood
        base_prob = (m + 0.5) / n
        
else:  # prev_cooperators > m
    # Over-cooperation: some sacrifice was unnecessary
    surplus = prev_cooperators - m
    if my_prev_action == COOPERATE:
        # I may have over-contributed; reduce probability
        base_prob = max(0.1, (m - surplus) / n)
    else:
        # Others over-contributed; maintain modest probability
        base_prob = m / n
```

**Step 3: Adjust for historical patterns**

```
# Track cooperation rates over all previous rounds
for each player j:
    coop_rate[j] = (times j cooperated) / (rounds played)

avg_others_coop_rate = average of coop_rate[j] for j ≠ me
my_coop_rate = coop_rate[me]

# Fairness adjustment: if I've cooperated more than average, reduce
fairness_adjustment = (avg_others_coop_rate - my_coop_rate) * 0.3

# Reliability adjustment: if group is unreliable, I must step up
reliability = (rounds where ≥m cooperated) / (total rounds played)
reliability_adjustment = (1 - reliability) * 0.2

adjusted_prob = base_prob + fairness_adjustment + reliability_adjustment
adjusted_prob = clamp(adjusted_prob, 0.1, 0.95)
```

**Step 4: Execute decision**
```
action = COOPERATE with probability adjusted_prob, else DEFECT
```

### Final Round (Round r): Collective Insurance

The last round has no future consequences, creating defection incentives. To counter this while remaining adaptive:

```
# Calculate historical group reliability
reliability = (rounds where ≥m cooperated) / (r - 1)

if reliability >= 0.7:
    # Group has been cooperative; maintain cooperation norm
    final_prob = m / n
elif reliability >= 0.4:
    # Mixed history; moderate cooperation
    final_prob = (m + 1) / n
else:
    # Unreliable group; high cooperation to salvage final round
    final_prob = min(0.9, (m + 2) / n)

# Slight boost if I've defected more than average (debt repayment)
if my_coop_rate < avg_others_coop_rate:
    final_prob = min(1.0, final_prob + 0.15)

action = COOPERATE with probability final_prob, else DEFECT
```

---

## Edge Cases

| Scenario | Handling |
|----------|----------|
| `m = n-1` (nearly unanimous needed) | Base probability stays high (~0.9+); little room for free-riding |
| `m = 2` (low threshold) | Base probability lower; more strategic flexibility |
| `k` very large | Strategy unchanged (threshold logic dominates) |
| `k` barely > 1 | Strategy unchanged (still better to hit threshold) |
| All others always defect | My probability rises toward 1, but alone I cannot reach m; accept losses |
| All others always cooperate | My probability drops; fair to occasionally free-ride if threshold still met |

---

## Summary Pseudocode

```python
def choose_action(round_num, total_rounds, history, my_player_id, n, m, k):
    
    if round_num == 1:
        return COOPERATE if random() < (m / n) else DEFECT
    
    prev_coop_count = count_cooperators(history, round_num - 1)
    my_prev_action = history[my_player_id][round_num - 1]
    
    # Base probability from previous round outcome
    base_prob = calculate_base_prob(prev_coop_count, my_prev_action, m, n)
    
    # Historical adjustments
    my_coop_rate = calculate_my_coop_rate(history, my_player_id)
    others_coop_rate = calculate_others_avg_coop_rate(history, my_player_id)
    reliability = calculate_threshold_hit_rate(history, m)
    
    fairness_adj = (others_coop_rate - my_coop_rate) * 0.3
    reliability_adj = (1 - reliability) * 0.2
    
    adjusted_prob = clamp(base_prob + fairness_adj + reliability_adj, 0.1, 0.95)
    
    # Final round adjustment
    if round_num == total_rounds:
        adjusted_prob = final_round_adjustment(adjusted_prob, reliability, 
                                                my_coop_rate, others_coop_rate, m, n)
    
    return COOPERATE if random() < adjusted_prob else DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing threshold**: Probabilistic cooperation naturally distributes the burden
2. **Adaptive to defectors**: Increases cooperation when threshold is missed
3. **Fair rotation**: Those who cooperated more get relief; free-riders pick up slack
4. **No coordination required**: Works without assuming others share the strategy
5. **Graceful degradation**: Performs reasonably even against adversarial opponents
'''

description_COLLECTIVE_28 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not a surplus cooperator who enables free-riding. The goal is to reliably meet the threshold while minimizing exploitation by defectors.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to the game parameters and dynamically adjusted based on observed behavior. The key insight is that in a collective of like-minded players, if everyone cooperates with probability m/n, we statistically expect exactly m cooperators—but with high variance. I adjust this baseline to be more robust.

---

## Decision Rules

### Round 1: Calibrated Optimism

**Cooperate with probability p₁ = min(1, (m + 1) / n)**

Rationale: Start slightly above the naive m/n probability to provide a safety margin for threshold achievement. This signals cooperative intent while not being exploitably naive.

### Rounds 2 through r-1: Adaptive Response

Calculate cooperation probability based on:

```
p_t = base_rate × cooperation_multiplier × urgency_factor

where:
- base_rate = (m + 0.5) / n
- cooperation_multiplier = f(observed cooperation rate)
- urgency_factor = g(rounds remaining, threshold achievement rate)
```

**Cooperation Multiplier Logic:**
- Let `obs_coop_rate` = (total C plays by others) / (total plays by others)
- Let `threshold_met_rate` = (rounds where ≥m cooperated) / (rounds played)

```
If threshold_met_rate ≥ 0.8:
    # Things are working - maintain but don't over-contribute
    cooperation_multiplier = 0.9
    
Else if threshold_met_rate ≥ 0.5:
    # Moderate success - stay the course
    cooperation_multiplier = 1.0
    
Else if threshold_met_rate < 0.5 AND obs_coop_rate ≥ (m-1)/n:
    # Close to threshold but missing - increase slightly
    cooperation_multiplier = 1.2
    
Else if obs_coop_rate < (m-1)/n:
    # Others aren't cooperating enough - gradual withdrawal
    cooperation_multiplier = max(0.3, obs_coop_rate × n / m)
```

**Urgency Factor:**
```
rounds_remaining = r - t
recent_threshold_met = threshold met in last 3 rounds?

If rounds_remaining ≤ 3 AND recent_threshold_met:
    urgency_factor = 0.85  # Can ease off slightly
Else if rounds_remaining ≤ 3 AND NOT recent_threshold_met:
    urgency_factor = 1.15  # Push harder at the end
Else:
    urgency_factor = 1.0
```

**Final probability: p_t = clip(base_rate × cooperation_multiplier × urgency_factor, 0.1, 0.95)**

The floor of 0.1 maintains minimal cooperation possibility; the ceiling of 0.95 prevents being perfectly predictable.

### Final Round (Round r): Strategic Calculation

The last round has no future shadow, so I apply modified logic:

```
If threshold_met_rate_so_far ≥ 0.7:
    # Partnership has worked - honor it
    p_r = base_rate × 1.1
    
Else if observed that exactly (m-1) others typically cooperate:
    # I'm pivotal - cooperate with high probability
    p_r = 0.85
    
Else:
    # Standard calculation but slightly reduced
    p_r = base_rate × 0.8
```

---

## Edge Case Handling

### When m is close to n (e.g., m = n-1):
- Increase base cooperation rate: `base_rate = min(0.9, (m + 1) / n)`
- Higher urgency since every defection is costly

### When m is small relative to n (e.g., m = 2, n = 6):
- Risk of over-cooperation is high
- More aggressive reduction when thresholds are met: `cooperation_multiplier` capped at 0.85 when `threshold_met_rate ≥ 0.9`

### When k is very large (k > 2):
- Threshold achievement is more valuable
- Add +0.1 to base_rate

### When k is barely above 1 (1 < k < 1.5):
- Cooperation barely pays
- Subtract 0.1 from base_rate

### Two-player special case (n = 2, m = 2):
- This is essentially pure coordination
- Use high cooperation: p = 0.8, with tit-for-tat adjustment based on partner's history

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, m, k):
    
    base_rate = min(0.95, (m + 0.5) / n)
    
    # Adjust for k
    if k > 2:
        base_rate += 0.1
    elif k < 1.5:
        base_rate -= 0.1
    
    if round_num == 1:
        p = min(1, (m + 1) / n)
    else:
        obs_coop_rate = compute_others_cooperation_rate(history)
        threshold_met_rate = compute_threshold_met_rate(history, m)
        
        # Cooperation multiplier
        if threshold_met_rate >= 0.8:
            coop_mult = 0.9
        elif threshold_met_rate >= 0.5:
            coop_mult = 1.0
        elif obs_coop_rate >= (m - 1) / n:
            coop_mult = 1.2
        else:
            coop_mult = max(0.3, obs_coop_rate * n / m)
        
        # Urgency factor
        rounds_left = total_rounds - round_num
        recent_success = threshold_met_recently(history, m, window=3)
        
        if rounds_left <= 3 and recent_success:
            urgency = 0.85
        elif rounds_left <= 3 and not recent_success:
            urgency = 1.15
        else:
            urgency = 1.0
        
        p = clip(base_rate * coop_mult * urgency, 0.1, 0.95)
        
        # Final round adjustment
        if round_num == total_rounds:
            if threshold_met_rate >= 0.7:
                p *= 1.1
            elif am_likely_pivotal(history, m):
                p = 0.85
            else:
                p *= 0.8
            p = clip(p, 0.1, 0.95)
    
    return 'C' if random() < p else 'D'
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: If all players use this strategy, cooperation rates naturally calibrate to achieve the threshold without excess.

2. **Exploitation-resistant**: Gradual withdrawal when others don't cooperate prevents being a perpetual sucker.

3. **Not exploitative**: Maintains cooperation even when ahead, honoring the collective benefit.

4. **Adaptive**: Responds to actual behavior rather than assuming specific opponent types.

5. **Parameter-aware**: Adjusts to different game configurations automatically.
'''

description_COLLECTIVE_29 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not more than necessary. The goal is to ensure the threshold is met while minimizing exploitation. I treat cooperation as a public good that needs exactly *m* contributors—I want to be part of that group when it matters, but I'll adapt based on whether others are pulling their weight.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic fair-share cooperation** - In equilibrium, each player should cooperate with probability m/n
2. **Responsive adjustment** - Increase cooperation when the group is falling short; decrease when others are reliably cooperating
3. **End-game awareness** - Maintain cooperation incentives even as the game concludes

---

## Decision Rules

### Round 1: Baseline Cooperation

Cooperate with probability `p_base = m/n`

This represents the "fair share" probability. If everyone adopted this, we'd expect exactly *m* cooperators on average.

**Implementation**: Use a deterministic rule based on player index or round number to achieve this probability in expectation across the population.

### Rounds 2 through r-1: Adaptive Response

**Step 1: Calculate cooperation metrics from previous round**
- `c_prev` = number of cooperators in the previous round
- `deficit` = m - c_prev (negative if threshold was exceeded)

**Step 2: Assess historical cooperation rate**
- `avg_coop` = average number of cooperators across all previous rounds
- `threshold_met_rate` = proportion of previous rounds where threshold was met

**Step 3: Determine cooperation probability**

```
base_prob = m / n

# Adjustment based on recent outcome
if c_prev < m:
    # Threshold wasn't met - increase willingness to cooperate
    urgency_boost = (m - c_prev) / m * 0.3
else:
    # Threshold was met - slight reduction if I cooperated and there was surplus
    urgency_boost = 0

# Adjustment based on overall history
if threshold_met_rate < 0.5:
    # Group is struggling - be more cooperative
    history_boost = 0.2
elif threshold_met_rate > 0.8 and avg_coop > m + 1:
    # Group is over-cooperating - can afford to defect more
    history_boost = -0.15
else:
    history_boost = 0

# Personal responsibility adjustment
if I cooperated last round AND c_prev >= m AND c_prev > m:
    # I was potentially "extra" - try defecting this round
    personal_adj = -0.2
elif I defected last round AND c_prev < m:
    # I contributed to failure - should step up
    personal_adj = 0.25
else:
    personal_adj = 0

cooperation_probability = clamp(base_prob + urgency_boost + history_boost + personal_adj, 0.1, 0.9)
```

**Step 4: Decide action**
- Cooperate if `hash(round, player_id) mod 100 < cooperation_probability * 100`
- This creates deterministic but pseudo-random behavior

### Final Round (Round r): Conditional Cooperation

The last round removes future punishment possibilities, but collective success still matters.

```
if threshold_met_rate >= 0.7:
    # Group has been reliable - maintain cooperation at base rate
    cooperation_probability = m / n
elif threshold_met_rate >= 0.4:
    # Mixed results - cooperate at slightly elevated rate for collective benefit
    cooperation_probability = (m / n) + 0.1
else:
    # Group has failed repeatedly - low probability cooperation
    cooperation_probability = max(0.2, (m / n) - 0.1)
```

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **m = n-1** (nearly all must cooperate) | Increase base probability to `(m/n) + 0.1` |
| **m = 2** (low threshold) | Standard rules apply; be willing to defect more |
| **k is very large** | Weight toward cooperation more heavily (multiply boosts by `min(k/2, 1.5)`) |
| **Threshold never met** | After 3 consecutive failures, cooperate with probability 0.8 for 2 rounds |
| **Threshold always met with surplus** | Gradually reduce cooperation probability by 0.05 per round (floor at m/n - 0.15) |

---

## Pseudocode Summary

```python
def decide(round, player_id, history, n, m, r, k):
    base_prob = m / n
    
    if round == 1:
        return cooperate_with_prob(base_prob, round, player_id)
    
    c_prev = count_cooperators(history[-1])
    threshold_met_rate = count_threshold_met(history, m) / len(history)
    avg_coop = average_cooperators(history)
    my_last_action = history[-1][player_id]
    
    # Calculate adjustments
    urgency = 0.3 * (m - c_prev) / m if c_prev < m else 0
    
    if threshold_met_rate < 0.5:
        history_adj = 0.2
    elif threshold_met_rate > 0.8 and avg_coop > m + 1:
        history_adj = -0.15
    else:
        history_adj = 0
    
    if my_last_action == C and c_prev > m:
        personal = -0.2
    elif my_last_action == D and c_prev < m:
        personal = 0.25
    else:
        personal = 0
    
    # Final round adjustment
    if round == r:
        personal = 0  # Remove exploitation concern
        if threshold_met_rate < 0.4:
            history_adj = -0.1
    
    prob = clamp(base_prob + urgency + history_adj + personal, 0.1, 0.9)
    return cooperate_with_prob(prob, round, player_id)
```

---

## Why This Strategy is Collectively Minded

1. **Fair contribution**: Starts at the mathematically fair cooperation rate
2. **Responsive to group needs**: Increases cooperation when the collective is failing
3. **Self-correcting**: Backs off when there's surplus cooperation
4. **Maintains trust**: Keeps cooperating in final rounds if the group has been reliable
5. **Resilient**: Doesn't completely abandon cooperation even against defectors, giving groups a chance to recover
'''

description_COLLECTIVE_30 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not more than necessary. The goal is to reliably meet the threshold while minimizing exploitation by free-riders. I'll use observable history to coordinate implicitly with like-minded players and adapt to the population's behavior.

---

## Strategy Overview

The strategy operates on three principles:
1. **Be willing to cooperate** - Start cooperatively to help establish threshold achievement
2. **Coordinate through history** - Use past cooperation patterns to implicitly assign "slots"
3. **Protect against exploitation** - Reduce cooperation if consistently carrying free-riders

---

## Decision Rules

### Round 1: Probabilistic Cooperation

With no history, I cooperate with probability `m/n`.

**Rationale:** If all players use this probability, expected cooperators = m, which is exactly the threshold. This is the collectively optimal mixed strategy for anonymous coordination.

### Rounds 2 through (r-1): Adaptive Slot-Based Cooperation

**Step 1: Assess Recent Cooperation Level**
- Calculate `avg_cooperators` = average number of cooperators over the last min(3, rounds_played) rounds
- Calculate `my_cooperation_rate` = my cooperation rate over the same window

**Step 2: Determine Base Cooperation Probability**

```
if avg_cooperators < m:
    # Threshold not being met - increase cooperation
    base_prob = min(1.0, m/n + 0.2)
    
elif avg_cooperators >= m and avg_cooperators <= m + 1:
    # Threshold met efficiently - maintain current behavior
    base_prob = m/n
    
else:  # avg_cooperators > m + 1
    # Over-cooperation - reduce to avoid being exploited
    base_prob = max(0.1, m/n - 0.15)
```

**Step 3: Personal Adjustment Based on Contribution History**

```
if my_cooperation_rate > avg_cooperators/n + 0.2:
    # I'm cooperating more than my fair share
    adjustment = -0.15
elif my_cooperation_rate < avg_cooperators/n - 0.2:
    # I'm free-riding relative to others
    adjustment = +0.15
else:
    adjustment = 0

final_prob = clamp(base_prob + adjustment, 0.1, 0.9)
```

**Step 4: Implicit Slot Coordination**

To reduce randomness and improve coordination, I use my player index and round number:

```
# Create a deterministic component based on position
slot_score = (player_index + round_number) mod n

# Players with lower slot_scores are "on duty" this round
if slot_score < m:
    cooperation_boost = 0.2
else:
    cooperation_boost = -0.1

final_prob = clamp(final_prob + cooperation_boost, 0.1, 0.95)
```

**Decision:** Cooperate if random() < final_prob

### Final Round (Round r): Threshold-Focused Decision

The last round has no future consequences, making defection tempting. However, collective success still matters:

```
if historical_success_rate >= 0.7:
    # We've been successful - try to maintain for final reward
    cooperate with probability m/n + 0.1
else:
    # Poor collective performance - cooperate more to attempt final success
    cooperate with probability min(0.8, m/n + 0.25)
```

---

## Edge Case Handling

| Situation | Response |
|-----------|----------|
| **n = m** (everyone must cooperate) | Always cooperate - no room for defection |
| **m = 1** (only one needed) | Cooperate with probability 1.5/n (slight over-provision for safety) |
| **k is very large** | Increase base cooperation by 10% (higher stakes) |
| **k is barely > 1** | Decrease base cooperation by 10% (lower incentive) |
| **Threshold never met in 3+ rounds** | Emergency mode: cooperate with probability 0.8 |
| **I've cooperated 3+ times while threshold failed** | Reduce to probability 0.4 (others aren't reciprocating) |

---

## Pseudocode Summary

```python
def decide(player_index, round_num, total_rounds, n, m, k, history):
    
    if round_num == 1:
        return random() < (m / n)
    
    # Calculate recent statistics
    recent_rounds = history[-min(3, len(history)):]
    avg_coop = mean([sum(round) for round in recent_rounds])
    my_coop_rate = mean([round[player_index] for round in recent_rounds])
    
    # Base probability from cooperation level
    if avg_coop < m:
        base_prob = min(1.0, m/n + 0.2)
    elif avg_coop <= m + 1:
        base_prob = m/n
    else:
        base_prob = max(0.1, m/n - 0.15)
    
    # Personal fairness adjustment
    fair_share = avg_coop / n
    if my_coop_rate > fair_share + 0.2:
        base_prob -= 0.15
    elif my_coop_rate < fair_share - 0.2:
        base_prob += 0.15
    
    # Implicit slot coordination
    slot = (player_index + round_num) % n
    if slot < m:
        base_prob += 0.2
    else:
        base_prob -= 0.1
    
    # Final round adjustment
    if round_num == total_rounds:
        success_rate = sum(1 for r in history if sum(r) >= m) / len(history)
        if success_rate < 0.7:
            base_prob += 0.15
    
    return random() < clamp(base_prob, 0.1, 0.95)
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing:** The slot mechanism helps similar strategies coordinate without communication
2. **Fair:** Adjusts personal contribution based on relative effort
3. **Adaptive:** Responds to both under- and over-cooperation in the population
4. **Resilient:** Never fully defects (floor of 0.1) or fully commits (ceiling of 0.95)
5. **Threshold-focused:** Always oriented toward achieving exactly m cooperators
'''

description_COLLECTIVE_31 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to ensure the group reaches the threshold. The key insight is that in a collective risk dilemma, **failing to meet the threshold hurts everyone**, so I should be willing to "sacrifice" my individual round payoff to help secure the collective reward.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to achieve exactly m cooperators in expectation, combined with **adaptive responsiveness** to observed group behavior. I adjust my cooperation probability based on whether the group has been under-contributing or over-contributing relative to the threshold.

---

## Decision Rules

### Round 1: Baseline Cooperation

**Cooperate with probability p₀ = m/n**

This is the collectively rational starting point: if all players use this probability, we expect exactly m cooperators on average.

### Rounds 2 through r-1: Adaptive Cooperation

Calculate my cooperation probability based on historical group behavior:

```
Let cooperation_rate = (total C plays by all players in previous rounds) / (n × rounds_played)
Let target_rate = m/n

# Measure how the group is doing relative to threshold
shortfall = target_rate - cooperation_rate

# Adaptive probability: increase my cooperation if group is under-contributing
p_t = min(1, max(0, (m/n) + α × shortfall × (n/(n-1))))

where α = 1.5 (responsiveness parameter)
```

**Key adaptive behaviors:**
- If group has been under-cooperating → I increase my cooperation probability
- If group has been over-cooperating → I slightly decrease my cooperation probability
- I never go below a floor of `max(0.1, (m-count_reliable)/n)` to maintain baseline contribution

**Reliability tracking:**
```
A player j is "reliable" if they cooperated in ≥ 60% of past rounds
count_reliable = number of reliable players (including myself if applicable)

# If reliable cooperators are close to m, I can afford to defect more
# If reliable cooperators are far below m, I must step up
adjustment = (m - count_reliable) / m
p_t = p_t × (1 + 0.3 × adjustment)
```

### Final Round (Round r): Threshold-Focused Decision

The last round requires special handling since there's no future to incentivize cooperation:

```
If count_reliable ≥ m:
    # Threshold likely met without me
    Cooperate with probability 0.3 (maintain some collective spirit)
    
Else if count_reliable == m-1:
    # I might be pivotal
    Cooperate with probability 0.8
    
Else if count_reliable < m-1:
    # Need multiple uncertain players to cooperate
    Cooperate with probability (m - count_reliable) / (n - count_reliable)
```

---

## Edge Cases

### Very Small Groups (n ≤ 4)
- Increase base cooperation probability by 0.1 (each player matters more)

### High Threshold (m > n/2)
- Shift toward higher cooperation: `p_base = (m/n) + 0.1`

### Low Threshold (m ≤ n/3)
- Can afford more strategic defection: `p_base = m/n` (no adjustment)

### k is Very Large (k > 2)
- The reward is very valuable; increase cooperation floor to 0.3

### Nearly All Players Have Defected Historically (cooperation_rate < 0.2)
- If doom seems likely, still cooperate with probability m/n
- Rationale: someone must try to bootstrap cooperation

### Threshold Consistently Met in Recent Rounds
- Gradually reduce personal cooperation to `max((m-1)/n, p_t - 0.05)` per round
- But never below `(m-1)/n` to avoid causing threshold failure

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    target_rate = m / n
    
    if round_num == 1:
        p = target_rate
    
    elif round_num == total_rounds:
        reliable = count_players_with_coop_rate_above(history, 0.6)
        if reliable >= m:
            p = 0.3
        elif reliable == m - 1:
            p = 0.8
        else:
            p = min(1, (m - reliable) / (n - reliable))
    
    else:
        actual_rate = total_cooperations(history) / (n * (round_num - 1))
        shortfall = target_rate - actual_rate
        p = target_rate + 1.5 * shortfall * (n / (n - 1))
        
        reliable = count_players_with_coop_rate_above(history, 0.6)
        adjustment = (m - reliable) / m
        p = p * (1 + 0.3 * adjustment)
        
        p = min(1, max(0.1, p))
    
    return COOPERATE if random() < p else DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **I contribute my fair share by default** (m/n probability)
2. **I compensate for defectors** rather than punishing them—the collective goal matters more than fairness
3. **I don't free-ride** even when others are cooperating enough
4. **I maintain hope** even in adverse conditions, continuing to cooperate at baseline rates
5. **I prioritize threshold achievement** over personal payoff optimization

This strategy aims to be a **reliable contributor** that helps groups of mixed strategies achieve the threshold, while not being so exploitable that pure defectors dominate.
'''

description_COLLECTIVE_32 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I should cooperate when my cooperation is likely *needed* to reach the threshold, and defect when cooperation is either futile or redundant. The goal is to maximize collective success at reaching the threshold while being robust against exploitation.

## Key Strategic Insights

1. **The threshold creates a coordination problem**: We need exactly m cooperators—fewer wastes nothing, more than m means some cooperators could have safely defected
2. **Defectors free-ride when threshold is met**: The optimal individual outcome is defecting while exactly m others cooperate
3. **Collective success requires enough cooperators to emerge**: I should be willing to be one of those m cooperators

## Decision Rules

### Rule 1: Baseline Cooperation Probability

Calculate my base willingness to cooperate based on game structure:

```
base_coop_rate = m / n
```

This represents the "fair share" probability—if everyone cooperated at this rate, we'd expect exactly m cooperators on average.

### Rule 2: History-Based Adjustment

After each round, track:
- `threshold_met_count`: How many rounds achieved ≥ m cooperators
- `total_cooperators_history`: List of cooperation counts per round
- `avg_cooperators`: Average number of cooperators across past rounds

**Adjustment logic:**
```
if avg_cooperators < m:
    # Collective is under-cooperating; increase my contribution
    adjusted_rate = base_coop_rate + (m - avg_cooperators) / n
elif avg_cooperators > m + 1:
    # Collective is over-cooperating; I can safely reduce
    adjusted_rate = base_coop_rate - (avg_cooperators - m - 1) / (2 * n)
else:
    # Near optimal; maintain current approach
    adjusted_rate = base_coop_rate
```

Clamp `adjusted_rate` to [0.1, 0.95] to maintain unpredictability and avoid complete exploitation.

### Rule 3: Deterministic Tie-Breaking via Player Index

To create implicit coordination without communication, use a deterministic component:

```
round_seed = (current_round * 7) mod n
my_priority = (my_index + round_seed) mod n

if my_priority < m:
    priority_bonus = 0.2
else:
    priority_bonus = -0.1
```

This rotates which players have "priority" to cooperate each round, distributing the burden fairly over time.

### Rule 4: Final Decision

```
cooperation_probability = clamp(adjusted_rate + priority_bonus, 0.05, 0.95)

# Deterministic resolution based on round and player index
threshold = hash(current_round, my_index) mod 100 / 100
if threshold < cooperation_probability:
    action = COOPERATE
else:
    action = DEFECT
```

## Edge Cases

### First Round (No History)
- Use `base_coop_rate = m/n` with priority bonus
- Lean slightly toward cooperation (+0.05) to establish collective success early

### Last Round
- Standard game theory suggests universal defection
- **However**, maintaining cooperation probability signals commitment to collective outcomes
- Apply standard rules but with a slight reduction (-0.1) acknowledging end-game dynamics
- If threshold has been met consistently (>70% of rounds), maintain normal cooperation to preserve collective gains

### When m is Very Close to n (m ≥ n-1)
- Near-universal cooperation is required
- Increase base cooperation significantly: `adjusted_rate = min(0.9, m/n + 0.15)`

### When k is Very Large (k > 3)
- The collective benefit strongly outweighs individual cost
- Add bonus: `adjusted_rate += min(0.15, (k-1)/10)`

## Pseudocode Summary

```
function decide(round, my_index, history, n, m, k, r):
    base_rate = m / n
    
    if round == 1:
        adjusted_rate = base_rate + 0.05
    else:
        avg_coop = mean(history.cooperators_per_round)
        if avg_coop < m:
            adjusted_rate = base_rate + (m - avg_coop) / n
        elif avg_coop > m + 1:
            adjusted_rate = base_rate - (avg_coop - m - 1) / (2 * n)
        else:
            adjusted_rate = base_rate
    
    # Priority rotation
    priority = (my_index + round * 7) mod n
    priority_bonus = 0.2 if priority < m else -0.1
    
    # Large k bonus
    k_bonus = min(0.15, (k - 1) / 10) if k > 2 else 0
    
    # Last round adjustment
    last_round_adj = -0.1 if round == r else 0
    
    final_rate = clamp(adjusted_rate + priority_bonus + k_bonus + last_round_adj, 0.05, 0.95)
    
    # Deterministic choice
    if deterministic_hash(round, my_index) < final_rate:
        return COOPERATE
    else:
        return DEFECT
```

## Why This Strategy is Collectively Robust

1. **Fair burden sharing**: Priority rotation ensures no single player always bears cooperation cost
2. **Adaptive**: Responds to actual group behavior, increasing cooperation when needed
3. **Not exploitable**: Never fully predictable, maintains cooperation floor
4. **Threshold-aware**: Focuses resources on achieving exactly m cooperators
5. **Parameter-responsive**: Adjusts to game structure (high k, high m/n ratio)
'''

description_EXPLOITATIVE_1 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The fundamental insight is that in a collective risk dilemma, the most profitable position is to be a **free-rider when exactly m players cooperate**. If I can reliably position myself as a defector while ensuring the threshold is still met by others, I gain the maximum payoff of `1 + k` (keeping my endowment AND receiving the collective reward).

My strategy exploits cooperative players by:
1. Identifying and counting reliable cooperators
2. Defecting whenever I predict enough others will cooperate
3. Only cooperating when my contribution is pivotal to reaching threshold

---

## Strategy Specification

### Key Variables Tracked

```
reliable_cooperators = set of players who cooperated in ≥70% of past rounds
conditional_cooperators = set of players who cooperate only when others do
defector_count = number of players who defected in previous round
cooperation_rate[i] = running cooperation rate for each player i
rounds_remaining = r - current_round
```

### Decision Rules

#### Round 1 (Cold Start)
**Action: DEFECT**

Rationale: With no history, I cannot predict others' behavior. By defecting first, I:
- Preserve my endowment with certainty
- Gather information about who cooperates unconditionally
- Avoid being exploited by other strategic players

#### Rounds 2 through (r-1) (Middle Game)

Calculate `expected_cooperators` = sum of cooperation_rate[i] for all other players

**IF** `expected_cooperators ≥ m`:
- **DEFECT** (free-ride on predicted cooperation)

**ELSE IF** `expected_cooperators ≥ m - 1` AND `expected_cooperators < m`:
- **COOPERATE** (I'm the pivotal player - my contribution tips us over threshold)

**ELSE IF** `expected_cooperators < m - 1`:
- **DEFECT** (threshold unreachable even with my cooperation, preserve endowment)

**ADAPTIVE ADJUSTMENT:**
After each round, if threshold was missed by exactly 1 cooperator and I defected:
- Increase my cooperation probability by 20% for next round (I may have miscalculated)

If threshold was met with ≥ m+2 cooperators and I cooperated:
- Mark this as "over-contribution" - defect next round (others are covering)

#### Last Round (Round r)

**Action: DEFECT**

Rationale: No future punishment possible. Pure Nash equilibrium logic applies - defection strictly dominates if I believe threshold will be met, and preserves endowment if it won't.

---

## Exploitation Mechanisms

### 1. Cooperator Identification
```
After each round:
  for each player j ≠ me:
    update cooperation_rate[j]
    if cooperation_rate[j] > 0.7:
      add j to reliable_cooperators
    if cooperation_rate[j] drops after I defect:
      add j to conditional_cooperators
```

### 2. Threshold Surfing
The strategy attempts to maintain cooperation count at **exactly m** by:
- Defecting when `|reliable_cooperators| ≥ m`
- Cooperating only when `|reliable_cooperators| = m - 1`

### 3. Punisher Detection
```
If my payoff drops significantly after I defect:
  Check if specific players switched from C to D
  If detected, temporarily cooperate for 2 rounds to "reset" their behavior
  Then resume exploitation
```

### 4. Herd Behavior Exploitation
If I observe high variance in group cooperation (everyone cooperates some rounds, defects others):
- Track the "rhythm" - do players cooperate on odd/even rounds?
- Defect on predicted high-cooperation rounds
- Cooperate on predicted low-cooperation rounds only if pivotal

---

## Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| m = n-1 (threshold almost requires all) | Cooperate rounds 2 to r-1 | My defection likely breaks threshold; better to get k than 1 |
| m = 2 (very low threshold) | Always defect | High chance 2 others cooperate without me |
| k < 1 | Always defect | Reward doesn't justify contribution cost |
| All players defected last round | Defect | Coordination failure; protect endowment |
| Exactly m cooperated and I was one | Defect next round | Test if others maintain threshold |
| r = 2 (only 2 rounds) | Defect both rounds | Insufficient time for reputation building |

---

## Pseudocode Summary

```
function decide(round, history, params):
    if round == 1:
        return DEFECT
    
    if round == params.r:
        return DEFECT
    
    expected_coop = estimate_cooperators(history)
    
    if expected_coop >= params.m:
        return DEFECT  # free-ride
    elif expected_coop >= params.m - 1:
        return COOPERATE  # pivotal
    else:
        return DEFECT  # hopeless
```

---

## Why This Strategy Wins

1. **Against unconditional cooperators**: Maximum exploitation - I always defect and collect `1 + k`
2. **Against unconditional defectors**: I defect too, we both get 1 (no loss)
3. **Against tit-for-tat variants**: I cooperate just enough to keep them cooperating, then defect on final round
4. **Against other exploiters**: We may fail threshold together, but I never get the "sucker's payoff" of 0
'''

description_EXPLOITATIVE_2 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that this game rewards free-riding *when others cooperate enough*. My goal is to be a defector who benefits from others' cooperation while contributing as little as possible—but I must be strategic enough to occasionally cooperate when the collective is at risk of falling below threshold, since getting 1 (all defect) is worse than getting 2 (cooperate when threshold met).

## Decision Rules

### Information Tracked Each Round
- `coop_count[t]`: number of cooperators in round t
- `player_history[i][t]`: action of player i in round t
- `rounds_remaining`: r - current_round

### Classification of Other Players

After observing history, classify each other player as:
- **Reliable Cooperator**: Cooperated ≥ 80% of observed rounds
- **Conditional Cooperator**: Cooperated 40-80% of rounds
- **Defector**: Cooperated < 40% of rounds

Let:
- `reliable_count` = number of Reliable Cooperators
- `expected_coop` = reliable_count + 0.5 × (conditional cooperators)

---

## Decision Algorithm

### Round 1 (No History)
```
IF m ≤ n/2:
    DEFECT  (optimistic: others likely meet threshold)
ELSE:
    COOPERATE with probability (m/n)  (need to contribute our "fair share" initially)
```

### Final Round (Round r)
```
ALWAYS DEFECT
```
*Rationale: No future punishment possible. Pure exploitation.*

### Rounds 2 through (r-1)

```
Step 1: Estimate cooperation likelihood this round
    expected_cooperators = reliable_count + 0.5 × conditional_count
    
Step 2: Determine if I'm "pivotal"
    IF expected_cooperators >= m:
        # Threshold likely met without me
        DEFECT
        
    ELSE IF expected_cooperators == m - 1:
        # I might be pivotal
        IF previous_round had exactly m cooperators AND I cooperated:
            # Others are relying on me - exploit this one more round then defect
            COOPERATE with probability 0.7
        ELSE:
            # Threshold barely missed or met - be strategic
            COOPERATE with probability (k - 1) / k
            
    ELSE IF expected_cooperators <= m - 2:
        # Threshold unlikely to be met even if I cooperate
        DEFECT
        
Step 3: Reputation exploitation adjustment
    IF I have cooperated in the last 2 consecutive rounds:
        # Built enough "cooperative image" - time to cash in
        Shift toward DEFECT (reduce cooperation probability by 0.3)
```

### Adaptive Punishment Response

```
IF coop_count in last round was >= m AND I defected:
    # Successfully free-rode - continue defecting
    DEFECT
    
IF coop_count has been < m for 2+ consecutive rounds:
    # Collective failure - need to rebuild
    COOPERATE for 1 round to "prime the pump"
    THEN return to exploitation
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1, no info | Defect if m ≤ n/2, else probabilistic | Start by testing waters |
| Final round | Always Defect | No future consequences |
| Everyone defected last round | Cooperate once | Reset the game dynamics |
| Threshold consistently met by others | Always Defect | Pure free-riding |
| I'm clearly pivotal (exactly m-1 others cooperating) | Cooperate ~70% | Worth 2 vs 1, but occasionally test |
| Threshold impossible (too few cooperators) | Defect | Save my endowment |

---

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == r:
        return DEFECT
    
    if round == 1:
        return DEFECT if m <= n/2 else random() < (m/n)
    
    reliable, conditional = classify_players(history)
    expected = reliable + 0.5 * conditional
    
    if expected >= m:
        return DEFECT
    elif expected <= m - 2:
        return DEFECT
    else:  # pivotal zone
        base_prob = (k - 1) / k
        if consecutive_cooperations(my_history) >= 2:
            base_prob -= 0.3
        return COOPERATE if random() < base_prob else DEFECT
```

---

## Why This Is Exploitative

1. **Defaults to defection** when others can cover the threshold
2. **Exploits reliable cooperators** by free-riding on their contributions
3. **Never cooperates in final round** - pure Nash defection
4. **Builds false reputation** then cashes in by defecting
5. **Only cooperates when mathematically necessary** to avoid collective disaster
6. **Treats cooperation as a cost to minimize**, not a norm to uphold
'''

description_EXPLOITATIVE_3 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The fundamental insight is that this game rewards *free-riding* when exactly m players cooperate. If I can reliably position myself as a defector while ensuring others hit the threshold, I maximize my payoff (1 + k vs just k for cooperators). My strategy exploits cooperative players while maintaining just enough cooperation to avoid collective collapse.

## Strategy Overview

I aim to be the **marginal defector** - someone who defects when cooperation is "safe" but cooperates only when absolutely necessary to prevent threshold failure. I track opponent behavior to predict cooperation rates and exploit predictable cooperators.

## Decision Rules

### Information Tracked Each Round
- `coop_count[t]`: number of cooperators in round t (excluding myself)
- `player_coop_rate[i]`: historical cooperation rate for each player i
- `threshold_met[t]`: whether m or more total cooperators existed in round t

### Classification of Other Players
After observing history, classify each opponent:
- **Reliable Cooperator**: cooperation rate > 0.7
- **Swing Player**: cooperation rate between 0.3 and 0.7
- **Reliable Defector**: cooperation rate < 0.3

### Expected Cooperators Calculation
```
expected_others_cooperating = sum(player_coop_rate[i] for all opponents i)
```

### Core Decision Logic

**Round 1 (No History):**
- If `m ≤ n/2`: **DEFECT** (threshold is easy to meet, gamble on others cooperating)
- If `m > n/2`: **COOPERATE** (threshold is hard, need to contribute initially to establish baseline)

**Middle Rounds (2 to r-1):**

```
predicted_coop = expected_others_cooperating

if predicted_coop >= m:
    # Others will likely meet threshold without me
    DEFECT
    
elif predicted_coop >= m - 1 AND predicted_coop < m:
    # I'm potentially pivotal
    # Cooperate with probability based on how close we are
    if count(reliable_cooperators) >= m - 1:
        DEFECT  # Let reliable cooperators carry the burden
    else:
        COOPERATE  # Must contribute to reach threshold
        
elif predicted_coop < m - 1:
    # Threshold unlikely even with my cooperation
    # Check if cooperating could trigger a cascade
    if last_round_met_threshold == False AND predicted_coop >= m - 2:
        COOPERATE  # Try to restart cooperation
    else:
        DEFECT  # Don't waste contribution on lost cause
```

**Last Round (Round r):**
- **DEFECT** unconditionally. No future rounds mean no punishment possible. Pure free-riding opportunity.

**Second-to-Last Round (Round r-1):**
- Apply middle-round logic but with slight bias toward defection (reduced future value of reputation).

### Exploitation Mechanisms

1. **Reliable Cooperator Exploitation**: Once I identify players who cooperate >70% of the time, I count on them and defect more aggressively.

2. **Threshold Hovering**: If exactly m-1 reliable cooperators exist, I become the "swing vote" - cooperating just often enough to keep the threshold occasionally met, preventing full collapse while maximizing defection opportunities.

3. **Punishment Immunity**: Since this is simultaneous-move with no communication, I cannot be directly punished. I exploit the lack of targeted retaliation.

4. **Adaptive Defection Rate**: 
   - If threshold consistently met: increase defection
   - If threshold consistently missed: slightly increase cooperation to "restart" the system, then resume exploitation

### Edge Cases

| Situation | Action |
|-----------|--------|
| First round | Defect if m ≤ n/2, else Cooperate |
| Last round | Always Defect |
| Threshold never met in last 3 rounds | Cooperate once to test if restart possible |
| All opponents are reliable defectors | Defect (cooperation is futile) |
| Exactly m-1 reliable cooperators exist | Defect and free-ride on them |
| m = n-1 or m = n | Cooperate (threshold requires near-unanimity) |

### Pseudocode Summary

```
function decide(round, history, params):
    if round == r:
        return DEFECT
    
    if round == 1:
        return DEFECT if m <= n/2 else COOPERATE
    
    predicted = estimate_others_cooperating(history)
    reliable_coops = count_reliable_cooperators(history)
    
    if predicted >= m:
        return DEFECT
    elif reliable_coops >= m:
        return DEFECT
    elif predicted >= m - 1:
        return COOPERATE
    elif recent_threshold_failures >= 3 AND predicted >= m - 2:
        return COOPERATE  # restart attempt
    else:
        return DEFECT
```

This strategy maximizes exploitation of cooperative players while maintaining enough strategic cooperation to keep the collective reward flowing - then ruthlessly defects when free-riding is safe.
'''

description_EXPLOITATIVE_4 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that **defectors get the best possible outcome when exactly m players cooperate** - they free-ride on others' contributions while keeping their endowment. My strategy aims to be among the defectors when the threshold is likely met, while occasionally cooperating just enough to prevent total collapse.

## Strategy: "Threshold Parasite"

### Decision Framework

The strategy maintains a **cooperation probability estimate** for each opponent based on their history, then calculates whether the threshold will likely be met *without* my contribution.

### Detailed Rules

#### Round 1 (Cold Start)
- **Defect.**
- Rationale: No information exists. Defecting is safer - if others cooperate enough, I get the maximum payoff (1 + k). If they don't, I at least keep my endowment.

#### Rounds 2 through (r-1) (Main Phase)

**Step 1: Estimate opponent cooperation rates**
For each opponent j, calculate:
```
coop_rate[j] = (times j cooperated) / (rounds played so far)
```

**Step 2: Calculate expected cooperators without me**
```
expected_others = sum(coop_rate[j] for all j ≠ me)
```

**Step 3: Decision logic**

```
IF expected_others >= m + 0.5:
    # Threshold likely met without me → DEFECT (free-ride)
    DEFECT

ELIF expected_others >= m - 1 AND expected_others < m + 0.5:
    # I might be pivotal - need to be strategic
    # Count how many "reliable cooperators" exist (coop_rate > 0.7)
    reliable = count(j where coop_rate[j] > 0.7)
    
    IF reliable >= m:
        DEFECT  # Reliable players will cover it
    ELIF reliable == m - 1:
        # Cooperate with probability based on how close we are to threshold
        # Lower cooperation as we approach final rounds (less future value)
        rounds_remaining_ratio = (r - current_round) / r
        cooperate_prob = 0.3 * rounds_remaining_ratio
        COOPERATE with probability cooperate_prob, else DEFECT
    ELSE:
        DEFECT  # Not enough reliable cooperators, don't waste contribution

ELIF expected_others < m - 1:
    # Threshold unlikely to be met → DEFECT (don't waste contribution)
    DEFECT
```

**Step 4: Exploitation adjustment**
```
IF last round had exactly m cooperators AND I defected:
    # Perfect outcome achieved - maintain this
    Continue current approach
    
IF last round had m+1 or more cooperators AND I cooperated:
    # I over-contributed - become more selfish
    Reduce personal cooperation threshold by 0.1 for next round
```

#### Final Round (Round r)

**Pure exploitation mode:**
```
expected_others = sum(coop_rate[j] for all j ≠ me)

IF expected_others >= m:
    DEFECT  # Free-ride on final round
ELSE:
    DEFECT  # No future rounds to preserve - don't waste contribution
```

The final round is **always defect** - there's no future cooperation to protect, so defection strictly dominates.

### Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = 2, m = 2 | Always Defect | Can never free-ride; cooperation requires both; defection preserves endowment |
| m = n - 1 | Defect unless all others are reliable cooperators | Only one free-rider slot available |
| k is very large | Same strategy, but slightly more willing to be pivotal | Higher stakes but logic unchanged |
| All opponents always defect | Always Defect | Threshold will never be met |
| All opponents always cooperate | Always Defect | Maximum exploitation opportunity |

### Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT  # Final round: always defect
    
    coop_rates = [opponent_coop_rate(j, history) for j in opponents]
    expected_others = sum(coop_rates)
    
    if expected_others >= m + 0.5:
        return DEFECT
    elif expected_others < m - 1:
        return DEFECT
    else:
        reliable = count(rate > 0.7 for rate in coop_rates)
        if reliable >= m:
            return DEFECT
        elif reliable == m - 1:
            prob = 0.3 * (r - round) / r
            return COOPERATE if random() < prob else DEFECT
        else:
            return DEFECT
```

### Why This Strategy Exploits

1. **Free-rides when safe**: Defects whenever the threshold is likely met without contribution
2. **Minimizes wasted contributions**: Never cooperates when threshold is clearly unreachable
3. **Extracts maximum value from cooperators**: Lets reliable cooperators carry the burden
4. **Endgame exploitation**: Guaranteed defection in final round
5. **Adaptive**: Adjusts to actual opponent behavior rather than assuming cooperation
'''

description_EXPLOITATIVE_5 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The optimal exploitative approach in this game recognizes a fundamental asymmetry: **if exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get only k**. My strategy aims to be among the defectors when the threshold is *just barely* met, while avoiding scenarios where I cooperate and the threshold fails.

## Strategic Analysis

1. **The free-rider's paradise**: When exactly m others cooperate, defecting yields 1 + k (maximum possible)
2. **The sucker's trap**: Cooperating when fewer than m-1 others cooperate yields 0 (minimum possible)
3. **Key insight**: I want to predict when *exactly enough* others will cooperate without me, then defect

---

## Decision Rules

### Round 1: Probabilistic Defection Bias

```
p_cooperate = (m - 1) / (n - 1)
```

Cooperate with probability `p_cooperate`, otherwise defect.

**Rationale**: If all players used this probability, expected cooperators ≈ m-1, meaning I should lean toward defecting to exploit the threshold being met by others.

### Rounds 2 through r-1: Adaptive Exploitation

**Step 1: Estimate cooperation rate of others**
```
others_coop_rate = (total cooperations by others in previous rounds) / ((round - 1) * (n - 1))
expected_other_cooperators = others_coop_rate * (n - 1)
```

**Step 2: Determine action based on exploitation zones**

```
IF expected_other_cooperators >= m:
    # Others will likely meet threshold without me → DEFECT (free-ride)
    ACTION = DEFECT

ELSE IF expected_other_cooperators >= m - 1 AND expected_other_cooperators < m:
    # Borderline zone: threshold might be met with or without me
    # Defect with probability proportional to how close we are to threshold
    p_defect = (expected_other_cooperators - (m - 1)) / 1
    ACTION = DEFECT with probability p_defect, else COOPERATE

ELSE IF expected_other_cooperators >= m - 2 AND expected_other_cooperators < m - 1:
    # Might need my cooperation to reach threshold
    # Cooperate, but only if recent trend shows others are cooperating too
    IF (cooperators in last round) >= m - 1:
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT

ELSE:
    # Too few cooperators expected - threshold won't be met regardless
    # DEFECT to avoid being a sucker
    ACTION = DEFECT
```

**Step 3: Punishment mechanism for declining cooperation**
```
IF cooperation rate dropped by more than 20% from previous round:
    # Others are defecting more → preemptively defect
    Override ACTION = DEFECT
```

### Final Round (Round r): Pure Defection

```
ACTION = DEFECT
```

**Rationale**: No future rounds to incentivize cooperation. Any cooperators in the final round are exploitable.

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | Probabilistic (bias toward D) | Establish baseline while leaning exploitative |
| Round r (final) | Always DEFECT | No future consequences |
| All others defected last round | DEFECT | Threshold won't be met; avoid sucker payoff |
| Exactly m-1 others cooperated last round | DEFECT | High chance threshold met without me |
| m = n-1 (high threshold) | Cooperate more readily | My contribution more critical |
| m = 2 (low threshold) | Defect more aggressively | Easy for others to meet threshold |
| n very large relative to m | Defect bias increases | Easier to hide among defectors |

---

## Pseudocode Summary

```python
def threshold_vulture(round, history, n, m, k, r):
    if round == r:
        return DEFECT  # Final round exploitation
    
    if round == 1:
        return COOPERATE if random() < (m - 1) / (n - 1) else DEFECT
    
    others_coops = count_others_cooperations(history)
    others_rate = others_coops / ((round - 1) * (n - 1))
    expected = others_rate * (n - 1)
    
    if expected >= m:
        return DEFECT  # Free-ride zone
    elif expected >= m - 1:
        return DEFECT if random() < (expected - m + 1) else COOPERATE
    elif expected >= m - 2 and last_round_cooperators(history) >= m - 1:
        return COOPERATE  # Marginal contributor
    else:
        return DEFECT  # Hopeless zone - avoid sucker payoff
```

---

## Why This Strategy is Exploitative

1. **Targets the threshold boundary**: Maximizes chances of getting 1 + k (defect when threshold met)
2. **Avoids sucker payoffs**: Never cooperates when threshold is clearly unreachable
3. **Exploits final round**: Guarantees defection when cooperation has no future value
4. **Adapts to cooperative populations**: Defects more when others cooperate enough
5. **Punishes declining cooperation**: Quickly abandons cooperation when others do
'''

description_EXPLOITATIVE_6 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The fundamental insight is that in a collective risk dilemma, the optimal exploitative position is to be a **free-rider when the threshold is met by others, but a reluctant cooperator when necessary to avoid collective disaster**. I want to maximize rounds where I defect while others hit the threshold, and minimize rounds where I cooperate but the threshold isn't met.

## Strategy Overview

I will estimate the likelihood that exactly `m-1` other players will cooperate, making my cooperation pivotal. When others are reliably hitting the threshold without me, I defect. When cooperation appears fragile, I conditionally cooperate to protect the collective reward—but only enough to stay just above the threshold.

---

## Decision Rules

### Round 1: Cautious Defection with Observation

**Action: DEFECT**

Rationale: I need information about opponent behavior before committing resources. If others are natural cooperators, I learn this cheaply. If the threshold fails, the cost is shared by all.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate these metrics from history:

```
cooperation_rate = (total C plays by others) / (total plays by others)
recent_cooperation_rate = (C plays by others in last 3 rounds) / (plays in last 3 rounds)
threshold_met_rate = (rounds where ≥m cooperated) / (rounds played)
threshold_met_without_me = (rounds where ≥m others cooperated) / (rounds played)
```

**Decision Logic:**

```
IF threshold_met_without_me_rate ≥ 0.7:
    # Others are carrying the load - exploit mercilessly
    ACTION = DEFECT

ELSE IF recent_cooperation_rate * (n-1) < m - 0.5:
    # Cooperation is collapsing - defect to cut losses
    ACTION = DEFECT

ELSE IF recent_cooperation_rate * (n-1) >= m + 1:
    # Slight surplus of cooperators - safe to defect
    ACTION = DEFECT

ELSE IF recent_cooperation_rate * (n-1) is in range [m - 0.5, m + 0.5]:
    # Threshold is fragile - my cooperation might be pivotal
    # Cooperate probabilistically based on how close we are to threshold
    
    expected_other_cooperators = recent_cooperation_rate * (n-1)
    shortfall = m - expected_other_cooperators
    
    IF shortfall > 0:
        cooperation_probability = min(1, shortfall / 1.5)
    ELSE:
        cooperation_probability = max(0, 0.3 - abs(shortfall) * 0.15)
    
    ACTION = COOPERATE with probability cooperation_probability, else DEFECT

ELSE:
    # Default: lean toward defection
    ACTION = DEFECT
```

### Last Round (Round r): Pure Defection

**Action: DEFECT**

Rationale: No future rounds mean no reputation consequences. If others will meet the threshold, I free-ride. If they won't, my single cooperation likely won't save it anyway.

---

## Edge Case Handling

### Very Small Groups (n ≤ 4)
When `n - m ≤ 1`, free-riding room is minimal. Increase cooperation probability by 0.2 in the fragile threshold zone, since my defection is more likely to doom the threshold.

### High Threshold Requirements (m ≥ n-1)
If nearly everyone must cooperate, defection becomes very costly to the group. Cooperate in early rounds to establish norm, then attempt single defections to test if others compensate.

### Low k Values (k < 1.5)
The reward barely exceeds the contribution cost. Be more willing to defect since the threshold reward is marginal.

### High k Values (k > 3)
The reward is very valuable. Be slightly more willing to cooperate in fragile situations to protect the high payoff.

### Detecting Conditional Cooperators
If I observe players who defect after I defect and cooperate after I cooperate, they may be playing tit-for-tat variants. Against these, occasional cooperation can sustain their cooperation while I defect in other rounds.

### Detecting Pure Cooperators
If specific players always cooperate regardless of history, count them as reliable contributors when calculating threshold probability. Exploit them fully.

---

## Summary Pseudocode

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    stats = calculate_statistics(history)
    
    if stats.threshold_met_without_me >= 0.7:
        return DEFECT
    
    expected_others = stats.recent_coop_rate * (n - 1)
    
    if expected_others < m - 0.5 or expected_others >= m + 1:
        return DEFECT
    
    # Fragile threshold zone
    shortfall = m - expected_others
    p_coop = clip(shortfall / 1.5, 0, 0.8)
    
    # Adjustments
    if n - m <= 1: p_coop += 0.2
    if k > 3: p_coop += 0.1
    if k < 1.5: p_coop -= 0.15
    
    return COOPERATE if random() < p_coop else DEFECT
```

This strategy maximizes personal payoff by free-riding when safe, contributing only when pivotal, and never cooperating in terminal rounds where reputation is worthless.
'''

description_EXPLOITATIVE_7 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride whenever possible** while ensuring the threshold is met just often enough to collect rewards. The key insight is that cooperators create positive externalities for defectors—when exactly m players cooperate, defectors get the maximum payoff (1 + k) while cooperators get only k.

My strategy aims to:
1. **Detect and exploit cooperative players** by defecting when others will likely hit the threshold
2. **Contribute minimally** to avoid catastrophic coordination failure
3. **Punish over-cooperation** by withdrawing when others are reliably cooperating
4. **Adapt dynamically** based on observed population behavior

---

## Strategy Specification

### Key Variables Tracked
- `coop_rate[i]` = cooperation frequency of each player across all observed rounds
- `total_cooperators_history` = list of how many players cooperated each round
- `rounds_threshold_met` = count of rounds where ≥ m cooperators appeared
- `current_round` = which round we're in (1 to r)

### Decision Rules

#### Round 1: Probabilistic Defection Bias
```
If m/n ≤ 0.5:
    DEFECT (threshold is low, others likely to meet it)
Else:
    COOPERATE with probability (m/n) - 0.1
    (Contribute only if threshold is demanding)
```

**Rationale:** In round 1 with no history, defection is safer when thresholds are easy to meet. We slightly undercontribute relative to what's "fair" to test the waters.

#### Rounds 2 to (r-1): Adaptive Exploitation

```
Let recent_coop_count = cooperators in previous round
Let avg_coop_count = average cooperators over all previous rounds

# Scenario A: Others are reliably cooperating
If avg_coop_count >= m + 1:
    DEFECT
    (Free-ride: threshold will likely be met without me)

# Scenario B: Threshold is barely being met
Else if avg_coop_count is in range [m - 0.5, m + 0.5]:
    # Check if I'm "needed" - am I among the most cooperative?
    my_coop_rate = my cooperations / rounds played
    Sort all players by coop_rate descending
    my_rank = my position in this ranking
    
    If my_rank <= m:
        COOPERATE (I'm in the "expected cooperator" group)
    Else:
        DEFECT (let the reliable cooperators carry)

# Scenario C: Cooperation is collapsing
Else if avg_coop_count < m - 0.5:
    # Need to occasionally contribute to prevent total collapse
    If recent_coop_count >= m - 1:
        COOPERATE (one more could hit threshold)
    Else if (r - current_round) <= 3:
        DEFECT (not enough time to establish cooperation)
    Else:
        COOPERATE with probability m/n
        (Probabilistic contribution to probe recovery)

# Scenario D: High variance in cooperation
If standard_deviation(total_cooperators_history) > 1.5:
    # Unpredictable opponents - be opportunistic
    If recent_coop_count >= m:
        DEFECT (threshold was just met, might happen again)
    Else:
        COOPERATE with probability 0.4
```

#### Final Round (Round r): Pure Exploitation
```
# Estimate expected cooperators based on their historical rates
expected_others_cooperating = sum(coop_rate[i] for all other players i)

If expected_others_cooperating >= m:
    DEFECT (threshold likely met without me)
Else if expected_others_cooperating >= m - 1:
    # I might be pivotal
    If k > 1.5:
        COOPERATE (reward worth the cost)
    Else:
        DEFECT (reward too small to justify contribution)
Else:
    DEFECT (threshold won't be met regardless)
```

**Rationale:** No future rounds means no reason to maintain reputation or encourage cooperation.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2, m = 2 | Cooperate rounds 1 to r-1, Defect round r | Need mutual cooperation; exploit at the end |
| m = n - 1 | Cooperate unless another player has 100% defection rate | Almost everyone needed; can't free-ride much |
| k > 2 | Increase cooperation probability by 0.1 | Higher reward justifies more contribution |
| All others defected last round | Defect | Don't be the lone sucker |
| Threshold met every round so far | Defect | Exploit the reliable cooperators |

---

## Summary of Exploitative Principles

1. **Never cooperate when unnecessary** - If expected cooperators ≥ m, defect
2. **Let others establish cooperation first** - Bias toward defection early
3. **Identify and exploit "suckers"** - Track who always cooperates and let them carry
4. **Abandon sinking ships** - If cooperation collapses, don't waste resources
5. **Maximize endgame extraction** - Always defect in final round unless pivotal
'''

description_EXPLOITATIVE_8 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that **defecting when exactly m others cooperate yields the highest possible payoff (1 + k)**. My strategy aims to free-ride on cooperators while ensuring the threshold is met just often enough to collect rewards. I'll exploit predictable cooperators, punish only when necessary to maintain threshold achievement, and defect heavily in endgame.

---

## Strategy: "Threshold Parasite"

### Decision Framework

**Primary Goal:** Be a defector when the threshold is met, be a cooperator only when my contribution is pivotal.

---

### Round-by-Round Decision Rules

#### **Round 1: Defect**
- Rationale: No history exists. Defecting is dominant if others cooperate enough; if they don't, I lose nothing extra. This also identifies who the "natural cooperators" are.

#### **Rounds 2 through (r-2): Adaptive Exploitation**

**Step 1: Count reliable cooperators**
- Define a player as a "reliable cooperator" if they cooperated in ≥ 60% of previous rounds
- Let `reliable_count` = number of reliable cooperators (excluding myself)

**Step 2: Decision logic**

```
IF reliable_count >= m:
    # Enough suckers exist - free ride
    DEFECT

ELSE IF reliable_count == m - 1:
    # I might be pivotal - cooperate probabilistically
    # Cooperate with probability based on how close we are to endgame
    rounds_remaining = r - current_round
    pivot_probability = min(0.7, rounds_remaining / r)
    COOPERATE with probability pivot_probability, else DEFECT

ELSE IF reliable_count < m - 1:
    # Threshold unlikely to be met regardless
    # Check if cooperation might "seed" future cooperation
    IF current_round <= r/3 AND last_round_cooperator_count >= m - 2:
        COOPERATE  # Try to establish threshold-meeting pattern
    ELSE:
        DEFECT  # Don't waste contribution
```

**Step 3: Reactive adjustment**
- If threshold was NOT met in the previous round AND `reliable_count >= m - 2`:
  - Increase cooperation probability by 0.2 for this round only (to help re-establish threshold)
- If threshold WAS met in previous round AND I defected:
  - Continue defecting (successful exploitation)

#### **Round (r-1): Penultimate Round**
```
IF reliable_count >= m:
    DEFECT
ELSE IF reliable_count == m - 1:
    COOPERATE with probability 0.4  # Lower than mid-game
ELSE:
    DEFECT
```

#### **Round r (Final Round): Defect**
- Rationale: No future consequences. Pure Nash equilibrium logic applies. Defect unconditionally.

---

### Exploitation Mechanisms

1. **Free-rider identification**: By defecting early, I identify who cooperates unconditionally - these are my targets for exploitation.

2. **Threshold hovering**: I aim to keep cooperation counts at exactly m, maximizing my chance of being a defector when rewards are distributed.

3. **Reputation manipulation**: By occasionally cooperating when pivotal, I avoid being identified as a pure defector (which might cause conditional cooperators to abandon cooperation entirely).

4. **Endgame defection**: Guaranteed defection in final rounds exploits anyone still cooperating based on hope or habit.

---

### Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1 or round == r:
        return DEFECT
    
    reliable_count = count_reliable_cooperators(history, threshold=0.6)
    last_threshold_met = (cooperators_last_round(history) >= m)
    
    if reliable_count >= m:
        return DEFECT
    
    if reliable_count == m - 1:
        rounds_remaining = r - round
        prob = min(0.7, rounds_remaining / r) * (0.5 if round == r-1 else 1.0)
        if not last_threshold_met:
            prob += 0.2
        return COOPERATE if random() < prob else DEFECT
    
    # reliable_count < m - 1
    if round <= r/3 and cooperators_last_round(history) >= m - 2:
        return COOPERATE
    return DEFECT
```

---

### Why This Strategy is Exploitative

- **Defaults to defection** unless cooperation is strategically necessary
- **Identifies and exploits** consistent cooperators
- **Never cooperates in final round** regardless of circumstances
- **Minimizes own contributions** while maximizing benefit from others' contributions
- **Adapts to exploit** whatever cooperation pattern emerges
'''

description_EXPLOITATIVE_9 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride on others' cooperation** while ensuring the threshold is met just often enough to collect rewards. I want to be among the defectors when exactly m players cooperate, maximizing my payoff at (1 + k) while cooperators only get k.

## Decision Rules

### Information Tracking

Each round, track:
- `coop_count[t]`: number of cooperators in round t
- `player_coop_rate[i]`: historical cooperation rate for each player i
- `threshold_met_rate`: fraction of past rounds where threshold was met
- `rounds_remaining`: r - current_round

### Round-by-Round Decision Logic

**FIRST ROUND:**
- **Defect.** 
- Rationale: No information yet. If others are naive cooperators, I benefit maximally. If threshold fails, I lose nothing compared to cooperating.

**MIDDLE ROUNDS (rounds 2 through r-1):**

```
predicted_cooperators = sum(player_coop_rate[i] for all other players i)

if predicted_cooperators >= m:
    # Threshold likely met without me → DEFECT and free-ride
    DEFECT
    
elif predicted_cooperators == m - 1:
    # I'm potentially pivotal
    if threshold_met_rate < 0.5:
        # Group is failing too often, need threshold met for any rewards
        COOPERATE
    else:
        # Test if others will compensate for my defection
        DEFECT with probability 0.7, COOPERATE with probability 0.3
        
elif predicted_cooperators < m - 1:
    # Threshold unlikely even with my cooperation
    if (m - 1 - predicted_cooperators) <= 1 AND rounds_remaining > r/3:
        # Close to threshold, might nudge others toward cooperation
        COOPERATE
    else:
        # Lost cause this round
        DEFECT
```

**LAST ROUND (round r):**
- **Defect unconditionally.**
- Rationale: No future rounds to influence. Pure exploitation.

**SECOND-TO-LAST ROUND (round r-1):**
- Apply middle-round logic but with **increased defection bias** (multiply defection probability by 1.3, capped at 1.0).

### Adaptive Exploitation Mechanisms

**1. Identify "Reliable Cooperators" (Suckers)**
- If player j has cooperated in >70% of rounds, classify as reliable
- Weight their predicted cooperation at 0.9 (they'll likely cooperate)
- These players subsidize my defection

**2. Detect Conditional Cooperators**
- If a player's cooperation correlates with threshold being met, they're conditional
- These players are unpredictable; weight their contribution at their raw rate

**3. Punish No One**
- Unlike tit-for-tat strategies, I never "punish" defectors
- Punishment costs me; I only care about maximizing my own payoff

**4. Threshold Collapse Prevention**
- If `threshold_met_rate` drops below 0.3 in the middle third of the game:
  - Temporarily increase cooperation probability to 0.4 for 2 rounds
  - Goal: Prevent total collapse that would eliminate all bonus rewards
  - Return to exploitation once threshold recovery observed

### Edge Cases

| Situation | Action |
|-----------|--------|
| n = m (all must cooperate) | Defect always; threshold will fail anyway if anyone else defects |
| m = 2, n large | Almost always defect; easy for others to meet threshold |
| k very large (k > 3) | Slightly more willing to be pivotal cooperator (threshold worth ensuring) |
| All players defected last round | Defect; likely a defection-heavy group, don't be the sucker |
| Threshold met every round so far | Defect; free-riding paradise |

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1 or round == r:
        return DEFECT
    
    predicted_coop = predict_cooperators(history)
    threshold_rate = threshold_met_rate(history)
    
    if predicted_coop >= m:
        return DEFECT  # Free-ride
    elif predicted_coop == m - 1:
        if threshold_rate < 0.5:
            return COOPERATE  # Prevent collapse
        else:
            return DEFECT if random() < 0.7 else COOPERATE
    else:  # predicted_coop < m - 1
        if (m - predicted_coop <= 2) and (r - round > r/3):
            return COOPERATE  # Seed cooperation
        return DEFECT  # Lost cause
```

## Why This Exploits Effectively

1. **Maximizes free-riding**: Defects whenever threshold is likely met without me
2. **Avoids being a sucker**: Never cooperates when threshold will fail
3. **Maintains reward stream**: Prevents total collapse through minimal strategic cooperation
4. **Endgame extraction**: Guarantees defection when future consequences don't exist
'''

description_EXPLOITATIVE_10 = '''
# Exploitative Strategy: "Threshold Exploiter"

## Core Philosophy

The optimal exploitative approach recognizes that this game has a critical asymmetry: **defectors get the highest payoff (1+k) when exactly m players cooperate**. My goal is to be a defector in worlds where the threshold is barely met, while contributing just enough to ensure the threshold is met when others won't.

## Key Insight

I want to **free-ride when possible, but avoid collective disaster**. The strategy estimates how many others will cooperate and positions itself to maximize personal gain:
- If others will likely meet threshold without me → Defect (get 1+k)
- If others will likely fall just short → Cooperate (get k, better than 1)
- If cooperation is hopeless → Defect (get 1)

## Decision Rules

### Round 1: Probabilistic Defection Bias
- **Defect** with probability `(n-m)/n`, **Cooperate** with probability `m/n`
- Rationale: If everyone used this strategy, expected cooperators ≈ m, but I'm betting others are more cooperative than me initially

### Rounds 2 to r-1: Adaptive Exploitation

**Step 1: Estimate expected cooperators (excluding self)**

```
recent_window = min(3, rounds_played)
coop_rates[j] = (cooperations by player j in recent window) / recent_window
expected_others_cooperating = sum(coop_rates[j]) for j ≠ me
```

**Step 2: Decision logic**

```
if expected_others_cooperating >= m + 0.5:
    # Threshold likely met without me → FREE RIDE
    DEFECT
    
elif expected_others_cooperating >= m - 1.5 AND expected_others_cooperating < m + 0.5:
    # I might be pivotal → COOPERATE to secure threshold
    COOPERATE
    
elif expected_others_cooperating < m - 1.5:
    # Threshold unlikely even with me → ABANDON SHIP
    DEFECT
```

**Step 3: Reputation camouflage (subtle adjustment)**
- If I've defected for 3+ consecutive rounds AND threshold has been met each time:
  - Cooperate once with probability 0.3
  - This prevents others from identifying me as a pure free-rider and adjusting

### Final Round (Round r): Pure Defection
- **Always Defect**
- No future rounds means no retaliation possible
- If threshold met → I get 1+k (maximum)
- If threshold missed → I get 1 (same as cooperating when missed)

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2, m = 2 | Cooperate rounds 1 to r-1, Defect round r | Both needed; cooperation necessary |
| m = n-1 | Defect if any player has >80% defection rate | Only 1 free-rider slot exists |
| All others always cooperate | Always Defect | Maximum exploitation |
| All others always defect | Defect | Hopeless, minimize loss |
| Threshold never met in first 3 rounds | Defect heavily | Group is dysfunctional |
| k is very large (k > 3) | Lower cooperation threshold by 0.5 | Missing threshold is very costly |

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == r:
        return DEFECT  # Endgame exploitation
    
    if round == 1:
        return random_choice(DEFECT with prob (n-m)/n)
    
    # Estimate others' cooperation
    window = min(3, round - 1)
    expected_coop = 0
    for each other player j:
        expected_coop += (j's cooperations in last window rounds) / window
    
    # Pivotality-based decision
    if expected_coop >= m + 0.5:
        return DEFECT  # Free ride
    elif expected_coop >= m - 1.5:
        return COOPERATE  # Be pivotal
    else:
        return DEFECT  # Lost cause
```

## Why This Strategy Is Exploitative

1. **Maximizes free-riding**: Defects whenever others seem likely to cover the threshold
2. **Avoids being a sucker**: Doesn't cooperate when threshold is unreachable
3. **Endgame betrayal**: Guaranteed defection in final round
4. **Adaptive parasitism**: Adjusts to exploit cooperative populations while surviving in hostile ones
5. **Minimal contribution**: Only cooperates when estimated to be pivotal
'''

description_EXPLOITATIVE_11 = '''
# Exploitative Strategy: "Threshold Freerider"

## Core Philosophy

The key insight in this game is that **defectors get strictly higher payoffs than cooperators when the threshold is met** (1+k vs 0+k). Therefore, the optimal exploitative approach is to:

1. Ensure the threshold is met (so I get the bonus k)
2. Be among the defectors when it is met (so I keep my endowment)
3. Only cooperate when absolutely necessary to prevent collective failure

## Strategy Overview

I aim to **freeride on others' cooperation** while contributing just enough to prevent catastrophic failure when cooperation appears insufficient. I track opponents' cooperation patterns to predict who will cooperate, then defect when I estimate enough others will cooperate without me.

---

## Decision Rules

### Information Tracked Each Round
- `coop_rate[i]` = cooperation rate of player i across all observed rounds
- `total_cooperators_history` = list of how many players cooperated each round
- `rounds_remaining` = r - current_round

### Round-by-Round Decision Logic

```
function decide(round, history, parameters):
    n, r, m, k = parameters
    
    # FIRST ROUND: Defect to gather information
    if round == 1:
        return DEFECT
    
    # LAST ROUND: Pure exploitation
    if round == r:
        return last_round_decision(history)
    
    # MIDDLE ROUNDS: Predictive freeriding
    expected_cooperators = estimate_cooperators_without_me(history)
    
    if expected_cooperators >= m:
        # Threshold likely met without me → FREERIDE
        return DEFECT
    
    elif expected_cooperators == m - 1:
        # I'm potentially pivotal
        return pivotal_decision(history, rounds_remaining)
    
    else:
        # Threshold unlikely to be met
        return unlikely_threshold_decision(expected_cooperators, m)
```

### Estimation Function

```
function estimate_cooperators_without_me(history):
    # For each opponent, estimate probability they cooperate
    # Weight recent rounds more heavily (decay factor 0.7)
    
    expected = 0
    for each opponent i:
        if opponent i has history:
            weighted_coop_rate = calculate_weighted_rate(opponent_i_history, decay=0.7)
            expected += weighted_coop_rate
        else:
            expected += 0.5  # uncertain prior
    
    return expected
```

### Pivotal Decision (when expected cooperators ≈ m-1)

```
function pivotal_decision(history, rounds_remaining):
    # When I might be the deciding vote
    
    recent_success_rate = threshold_met_in_last_3_rounds / 3
    
    if recent_success_rate >= 0.67:
        # Others have been reliable → try to freeride
        return DEFECT
    
    elif rounds_remaining <= 2:
        # Late game, can't afford failures
        return COOPERATE
    
    else:
        # Probabilistic: cooperate with probability (m/n)
        # This makes me cooperate less than "fair share"
        if random() < (m / n) * 0.8:  # 80% of fair share
            return COOPERATE
        else:
            return DEFECT
```

### Last Round Decision

```
function last_round_decision(history):
    expected_cooperators = estimate_cooperators_without_me(history)
    
    if expected_cooperators >= m:
        # Definite freeride opportunity
        return DEFECT
    
    elif expected_cooperators >= m - 1:
        # Close call - only cooperate if k > 1 makes it worthwhile
        # and I strongly believe I'm pivotal
        if expected_cooperators < m - 0.3:
            return DEFECT  # Too uncertain
        else:
            return COOPERATE  # Likely pivotal
    
    else:
        # Threshold won't be met regardless
        return DEFECT
```

### Unlikely Threshold Decision

```
function unlikely_threshold_decision(expected, m):
    gap = m - expected - 1  # how many more needed beyond me
    
    if gap >= 2:
        # Hopeless - don't waste cooperation
        return DEFECT
    
    else:
        # Small gap - cooperate occasionally to encourage others
        # but mostly defect
        if random() < 0.2:
            return COOPERATE
        else:
            return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Gather information at no strategic cost |
| Round r (last) | Use last_round_decision() | No future consequences, pure calculation |
| m = n-1 (high threshold) | Cooperate more often | Single defector tanks everyone |
| m = 2 (low threshold) | Defect aggressively | Easy for others to cover |
| All opponents always cooperate | Always DEFECT | Maximum exploitation |
| All opponents always defect | DEFECT | Threshold unachievable anyway |
| Exactly m-1 reliable cooperators | DEFECT | Let them carry the burden |

---

## Why This Strategy is Exploitative

1. **Information asymmetry**: I use opponents' revealed tendencies against them while giving minimal information about my own strategy (appearing somewhat random)

2. **Freeriding by design**: I systematically aim to be a defector when threshold is met

3. **Contributes below fair share**: Even when cooperating probabilistically, I cooperate at 80% of the "fair" rate (m/n)

4. **Exploits cooperators**: Reliable cooperators get taken advantage of; I let them ensure threshold while I pocket the bonus

5. **Abandons lost causes**: I don't waste cooperation when the threshold seems unreachable
'''

description_EXPLOITATIVE_12 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride on others' cooperation whenever possible** while **contributing just enough to ensure the threshold is met when it's at risk**. The key insight is that defecting when exactly m others cooperate yields the maximum payoff (1 + k), while cooperating when fewer than m-1 others would cooperate is pure waste.

## Strategy Overview

I will estimate opponents' cooperation probabilities, predict whether the threshold will be met without me, and defect whenever I can safely free-ride. When the threshold is uncertain, I'll cooperate only if my contribution is likely pivotal.

---

## Decision Rules

### Round-by-Round Logic

**Let:**
- `coop_history[i]` = number of times player i has cooperated
- `rounds_played` = number of completed rounds
- `p[i]` = estimated cooperation probability for player i = `coop_history[i] / rounds_played`
- `expected_cooperators` = sum of `p[i]` for all other players
- `variance` = sum of `p[i] * (1 - p[i])` for all other players

### Decision Function

```
FUNCTION decide(round_number, history):
    
    # Calculate expected cooperators among others
    expected_others = sum(p[i] for i in other_players)
    std_dev = sqrt(sum(p[i]*(1-p[i]) for i in other_players))
    
    # Probability threshold will be met without me
    prob_threshold_met_without_me = P(cooperators >= m) given estimates
    
    # Probability my cooperation is pivotal (exactly m-1 others cooperate)
    prob_pivotal = P(cooperators == m-1) given estimates
    
    # Expected value calculation
    EV_defect = 1 + k * prob_threshold_met_without_me
    EV_cooperate = 0 + k * (prob_threshold_met_without_me + prob_pivotal)
    
    IF EV_defect >= EV_cooperate:
        RETURN DEFECT
    ELSE:
        RETURN COOPERATE
```

### Simplified Heuristic Version

```
IF expected_others >= m + 0.5 * std_dev:
    # Likely enough cooperators without me - FREE RIDE
    RETURN DEFECT

ELSE IF expected_others < m - 1 - 0.5 * std_dev:
    # Threshold unlikely even with my help - DON'T WASTE
    RETURN DEFECT

ELSE:
    # I might be pivotal - COOPERATE
    RETURN COOPERATE
```

---

## Edge Case Handling

### First Round (No History)
- Assume uniform random behavior: `p[i] = 0.5` for all others
- If `(n-1) * 0.5 >= m`: **DEFECT** (expect enough cooperators)
- If `(n-1) * 0.5 < m - 1`: **DEFECT** (threshold unlikely anyway)
- Otherwise: **COOPERATE** (might be pivotal)

### Last Round
- **Always DEFECT** if `expected_others >= m` (pure free-riding opportunity)
- No future consequences, so exploit maximally
- Only cooperate if genuinely pivotal and `k > 1` makes it worthwhile

### When m is Very Low (m ≤ n/3)
- Bias toward defection; threshold likely met by natural cooperators
- Defect unless cooperation rate is collapsing

### When m is Very High (m > 2n/3)
- Bias toward cooperation early to establish a cooperative baseline
- Defect once stable cooperation patterns emerge with enough cooperators

### All Others Defecting (Cooperation Collapse)
- If `expected_others < m - 1`: **DEFECT** (my cooperation alone won't save us)
- Don't throw good money after bad

### All Others Cooperating
- **DEFECT** aggressively - this is the ideal free-riding scenario
- Continue defecting until cooperation drops near threshold

---

## Adaptive Mechanisms

### Bayesian Updating
- Weight recent rounds more heavily: use exponential decay with factor 0.8
- `p[i] = weighted_sum(recent_actions) / weighted_sum(rounds)`

### Opponent Classification
- **Unconditional Cooperators**: `p[i] > 0.85` → exploit them, they'll cooperate anyway
- **Unconditional Defectors**: `p[i] < 0.15` → ignore them in threshold calculations
- **Conditional Players**: everyone else → monitor carefully

### Safety Margin Adjustment
- If threshold has been missed recently: lower safety margin (cooperate more readily)
- If threshold consistently met: raise safety margin (defect more aggressively)

---

## Summary

**Cooperate only when pivotal; defect whenever you can free-ride or when cooperation is futile.** This strategy maximizes personal payoff by extracting value from others' cooperation while contributing minimally to collective success.
'''

description_EXPLOITATIVE_13 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride whenever possible** while ensuring the threshold is met just often enough to collect rewards. The key insight is that cooperators create positive externalities for defectors—if exactly m players cooperate, defectors get the maximum payoff (1 + k) while cooperators get only k.

My strategy aims to:
1. Defect by default to capture the free-rider bonus
2. Only cooperate when cooperation appears critically necessary to meet threshold
3. Exploit predictable cooperators ruthlessly
4. Create uncertainty to discourage others from adopting the same exploitative stance

---

## Decision Rules

### Classification of Other Players (Updated Each Round)

Based on observed history, classify each other player j into:
- **Reliable Cooperators**: Cooperated ≥ 70% of past rounds
- **Reliable Defectors**: Defected ≥ 70% of past rounds  
- **Swing Players**: Everyone else

### Main Decision Logic

```
function decide(round, history, n, m, k, r):
    
    reliable_cooperators = count players who cooperated ≥ 70% of time
    reliable_defectors = count players who defected ≥ 70% of time
    
    # LAST ROUND: Always defect (no future consequences)
    if round == r:
        return DEFECT
    
    # FIRST ROUND: Strategic positioning
    if round == 1:
        return first_round_decision(n, m, k)
    
    # THRESHOLD ALREADY SECURE: Free-ride
    if reliable_cooperators >= m:
        return DEFECT
    
    # THRESHOLD IMPOSSIBLE: Don't waste contribution
    if reliable_cooperators + swing_players < m - 1:
        return DEFECT
    
    # CRITICAL THRESHOLD SITUATION
    shortfall = m - reliable_cooperators
    
    # If I'm potentially the pivotal player
    if shortfall == 1 and swing_players == 0:
        # Probabilistic cooperation to avoid being exploited
        # Cooperate with probability based on k value
        p_coop = min(0.6, k / (k + 2))
        return COOPERATE with probability p_coop, else DEFECT
    
    # Multiple swing players exist - try to free-ride
    if swing_players >= shortfall:
        # Defect and hope others fill the gap
        # But occasionally cooperate to not be predictable
        p_coop = max(0.1, (shortfall - 1) / swing_players)
        return COOPERATE with probability p_coop, else DEFECT
    
    # We need most swing players including me
    if shortfall > swing_players / 2:
        return COOPERATE
    else:
        return DEFECT
```

### First Round Decision

```
function first_round_decision(n, m, k):
    # Establish myself as a swing player, not a reliable cooperator
    # Defect to signal I won't be exploited
    
    # Exception: if m is very close to n, threshold is fragile
    if m >= n - 1:
        # Cooperate to avoid collective failure
        return COOPERATE
    
    # Exception: if k is very high, cooperation has high value
    if k >= 3:
        return COOPERATE with probability 0.4
    
    # Default: Defect to establish exploitative reputation
    return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **Round 1** | Usually DEFECT | Establish as non-exploitable swing player |
| **Round r (final)** | Always DEFECT | No future rounds to punish defection |
| **Round r-1** | Lean toward DEFECT | Limited punishment horizon |
| **m = n-1** (high threshold) | More likely COOPERATE | Every player nearly pivotal |
| **m = 2** (low threshold) | Almost always DEFECT | Easy for others to meet threshold |
| **All others defected last round** | DEFECT | Threshold unlikely achievable |
| **Exactly m-1 cooperated last round** | DEFECT | Test if they'll maintain without me |

---

## Adaptive Exploitation Mechanisms

1. **Cooperator Exploitation**: Once I identify reliable cooperators, I defect more aggressively, using them as "insurance" for threshold.

2. **Reputation Management**: I keep my cooperation rate between 20-40% to remain classified as a swing player—unpredictable but not useless.

3. **Endgame Acceleration**: In final 20% of rounds, shift toward pure defection as punishment threats diminish.

4. **Threshold Proximity Sensing**: Track round-by-round cooperation counts. If threshold was barely met, stay alert; if easily met, defect freely.

---

## Summary

**Defect by default. Cooperate only when pivotal and the math demands it. Exploit the predictable. Stay unpredictable yourself.**
'''

description_EXPLOITATIVE_14 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when others cooperate** (payoff of 1+k vs k for cooperators). My strategy aims to:
1. **Exploit cooperative opponents** by defecting when I predict enough others will cooperate
2. **Contribute minimally** to ensure the threshold is met when my cooperation is actually needed
3. **Punish defection strategically** to maintain a cooperative baseline I can exploit

## Strategy: "Threshold Parasite"

### Decision Framework

**Key Variables to Track:**
- `coop_count[t]`: Number of cooperators in round t
- `player_coop_rate[i]`: Historical cooperation rate of player i
- `rounds_remaining`: r - current_round
- `threshold_met_rate`: How often threshold m has been reached

---

### Decision Rules

#### Round 1: Defect
- **Rationale**: No information yet. Defecting is safe—I get at least 1, and I gather information about others' tendencies. If many cooperate, I've successfully free-ridden. If few cooperate, I've lost nothing.

#### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Predict cooperation count**
```
predicted_cooperators = sum(player_coop_rate[i] for all other players i)
```

**Step 2: Determine my action**

```
IF predicted_cooperators >= m:
    # Others will likely hit threshold without me
    DEFECT (free-ride)
    
ELIF predicted_cooperators == m - 1:
    # I'm potentially pivotal
    IF threshold_met_rate > 0.5:
        # Group has been reliable, test if I can free-ride
        DEFECT with probability 0.3, else COOPERATE
    ELSE:
        # Group struggling, my cooperation matters
        COOPERATE
        
ELIF predicted_cooperators < m - 1:
    # Threshold unlikely even if I cooperate
    IF (m - predicted_cooperators) <= 1.5:
        # Close enough—cooperate to encourage others
        COOPERATE
    ELSE:
        # Lost cause this round
        DEFECT
```

**Step 3: Exploit predictable cooperators**
```
# Identify "suckers" - players with coop_rate > 0.8
sucker_count = count(players where player_coop_rate[i] > 0.8)

IF sucker_count >= m:
    # Reliable cooperators exist—always defect
    DEFECT
```

#### Last Round (Round r): Pure Exploitation
- **Defect unconditionally**
- **Rationale**: No future consequences. If others cooperate, I get maximum payoff (1+k). If not, I keep my endowment.

---

### Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = m (all must cooperate) | Cooperate rounds 2 to r-1, Defect round r | Defecting early collapses cooperation |
| m = 2, n large | Defect always | High chance 2 others cooperate |
| k very large (k > 2) | Slightly more cooperative early | Worth ensuring threshold met |
| Threshold never met after 3 rounds | Defect remaining rounds | Group is uncooperative, cut losses |
| One player always defects | Ignore them in predictions | Adjust expected cooperators down |

---

### Punishment Mechanism (Soft)

If I cooperated and threshold **failed to meet** (I was exploited):
```
next_round_defect_probability += 0.3
```

This isn't altruistic punishment—it's signaling that I won't be a reliable sucker, pushing marginal defectors toward cooperation so I can free-ride later.

---

### Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT  # Last round exploitation
    
    # Calculate predictions
    pred_coop = sum(coop_rate(p) for p in other_players)
    sucker_count = count(p for p in other_players if coop_rate(p) > 0.8)
    
    # Exploit reliable cooperators
    if sucker_count >= m:
        return DEFECT
    
    # Pivotal decision
    if pred_coop >= m:
        return DEFECT
    elif pred_coop >= m - 1.5:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates when unnecessary** - Always free-rides when threshold will be met
2. **Identifies and exploits "suckers"** - Tracks reliable cooperators and parasitizes them
3. **Defects in information-poor situations** (round 1) and consequence-free situations (last round)
4. **Only cooperates when pivotal** - Minimal contribution philosophy
5. **Adapts to opponent mix** - More exploitative against cooperators, protective against defectors
'''

description_EXPLOITATIVE_15 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride whenever possible** while ensuring the collective threshold is still met. The key insight is that if exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get less (0 + k). My goal is to be among the defectors when the threshold is *just barely* met.

## Decision Rules

### Information Tracking

Each round, track:
- `coop_count[t]` = number of cooperators in round t
- `player_history[i][t]` = action of player i in round t
- `reliability[i]` = proportion of rounds player i has cooperated

### Round-by-Round Strategy

**First Round:**
- **Defect.** 
- Rationale: I have no information. If others are cooperative enough to meet threshold without me, I get maximum payoff. If threshold isn't met, I lose nothing extra by defecting (I keep my endowment).

**Middle Rounds (2 to r-1):**

Calculate `expected_cooperators` = sum of `reliability[i]` for all other players i

```
IF expected_cooperators >= m:
    DEFECT  # Free-ride on reliable cooperators
    
ELIF expected_cooperators >= m - 1 AND expected_cooperators < m:
    # Borderline case - cooperate with probability based on how close we are
    IF random() < (m - expected_cooperators):
        COOPERATE  # Be the marginal cooperator to secure the bonus
    ELSE:
        DEFECT
        
ELIF expected_cooperators < m - 1:
    # Not enough reliable cooperators - threshold unlikely to be met
    DEFECT  # Don't waste contribution on a lost cause
```

**Refinement - Exploit Predictable Patterns:**

```
IF last round had exactly m cooperators AND I defected AND got bonus:
    DEFECT  # Keep exploiting the same cooperators
    
IF last round had exactly m cooperators AND I cooperated:
    # Test if I can free-ride by switching to defect
    IF expected_cooperators >= m:
        DEFECT
    ELSE:
        COOPERATE  # I'm needed
```

**Last Round (round r):**
- **Always Defect.**
- Rationale: No future rounds exist to punish me. Pure dominant strategy in final round is to defect and hope others cooperate.

### Adaptive Exploitation Rules

**Identifying "Suckers" (Unconditional Cooperators):**
```
sucker[i] = TRUE if reliability[i] > 0.8 after round 3
sucker_count = count of suckers among other players

IF sucker_count >= m:
    ALWAYS DEFECT  # Guaranteed free-riding
```

**Identifying Conditional Cooperators:**
```
IF a player's cooperation correlates with previous round's threshold being met:
    # They're threshold-conditional - don't count them as reliable
    Reduce their reliability weight by 50%
```

**Responding to Collective Failure:**
```
IF threshold was NOT met in previous 2 consecutive rounds:
    # Group is failing - contribute once to "restart" cooperation
    COOPERATE for 1 round, then reassess
    # This is purely self-interested: better to occasionally enable 
    # the bonus than to have permanent failure
```

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = m (everyone needed) | Cooperate rounds 1 to r-1, Defect round r | Can't free-ride except finally |
| m = 2, n large | Almost always defect | High chance others cover threshold |
| All others defected last round | Defect | Threshold won't be met anyway |
| I'm the only defector consistently | Keep defecting | Maximum exploitation achieved |
| Exactly m-1 reliable cooperators | Cooperate | I'm the pivotal player |

## Pseudocode Summary

```
function decide(round, history, params):
    if round == r:
        return DEFECT
    
    expected_coop = sum(reliability[i] for i in other_players)
    sucker_count = count(i where reliability[i] > 0.8)
    
    if sucker_count >= m:
        return DEFECT
    
    if expected_coop >= m:
        return DEFECT
    
    if expected_coop >= m - 1:
        if random() < (m - expected_coop):
            return COOPERATE
        return DEFECT
    
    if last_two_rounds_failed and round < r - 1:
        return COOPERATE  # Reset attempt
    
    return DEFECT
```

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever threshold is likely met without me
2. **Identifies and exploits reliable cooperators**: Treats them as resources
3. **Never cooperates out of fairness**: Only cooperates when strategically necessary
4. **Endgame defection**: Guarantees maximum payoff in final round
5. **Minimal contribution**: Only cooperates when I'm likely the pivotal m-th player
'''

description_EXPLOITATIVE_16 = '''
# Exploitative Strategy: "Threshold Stalker"

## Core Philosophy

The key insight in this game is that **defectors get the best payoff when exactly m players cooperate** - they free-ride on others' contributions while keeping their endowment. My strategy aims to be among the defectors when cooperation happens, while ensuring I don't sink below the threshold when my contribution is critical.

The exploitative mindset: Let others bear the cost of reaching the threshold; only cooperate when my defection would cause collective failure that hurts me more than cooperating.

---

## Decision Rules

### Information Tracked Each Round
- `coop_count[t]`: Number of cooperators in round t
- `player_history[i][t]`: Action of player i in round t
- `coop_rate[i]`: Fraction of rounds player i has cooperated

### Round-by-Round Decision Logic

**Round 1 (Cold Start):**
- **Defect.**
- Rationale: No information yet. If others are naive cooperators, I free-ride. If threshold isn't met, I lose nothing extra by defecting. This also signals that I'm not an easy mark.

**Rounds 2 through r-1 (Main Phase):**

```
Let expected_cooperators = Σ(coop_rate[i]) for all i ≠ me

If expected_cooperators >= m:
    DEFECT  # Free-ride: threshold likely met without me
    
Else if expected_cooperators >= m - 1:
    # I might be pivotal
    If expected_cooperators >= m - 0.5:
        DEFECT with probability 0.7, COOPERATE with probability 0.3
    Else:
        COOPERATE  # My contribution likely critical
        
Else if expected_cooperators < m - 1:
    # Threshold unlikely to be met regardless
    DEFECT  # Don't throw away endowment on lost cause
```

**Refinement - Exploit Identified Patterns:**

```
# Identify "reliable cooperators" (coop_rate > 0.7)
reliable_count = count of players with coop_rate[i] > 0.7

If reliable_count >= m:
    DEFECT  # These suckers will carry the threshold

# Identify "conditional cooperators" (coop_rate between 0.3 and 0.7)  
# These players respond to history - be slightly more cooperative to keep them engaged
If reliable_count == m - 1 AND I've defected last 2 rounds:
    COOPERATE  # Maintain the ecosystem of cooperators
```

**Last Round (Round r):**
- **Defect.**
- Rationale: No future interaction means no reason to maintain cooperative reputation. Pure exploitation opportunity.

**Second-to-Last Round (Round r-1):**
- Apply main phase logic but **bias toward defection** (reduce cooperation probability by 0.2)
- Others may also anticipate end-game defection, so threshold is harder to reach anyway.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2, m = 2 | Always Defect | Both must cooperate for threshold; if opponent defects once, cooperation is pointless |
| m very close to n (m ≥ n-1) | Defect unless all others are reliable cooperators | Too risky; my defection almost always breaks threshold but so does anyone else's |
| m very small (m ≤ 2) | Almost always Defect | Easy for others to meet threshold without me |
| k is very large (k >> 1) | Slightly more willing to cooperate when pivotal | The reward justifies occasional cooperation cost |
| All players defected last round | Defect | Collective failure mode; don't be the lone sucker |
| Exactly m-1 cooperated last round | Cooperate if those same players seem consistent | I can push us over the threshold and still benefit |

---

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1 or round == r:
        return DEFECT
    
    coop_rates = [cooperation_rate(player, history) for player in others]
    expected_coop = sum(coop_rates)
    reliable_count = sum(1 for rate in coop_rates if rate > 0.7)
    
    # Easy free-ride conditions
    if reliable_count >= m:
        return DEFECT
    if expected_coop >= m:
        return DEFECT
    if expected_coop < m - 1.5:
        return DEFECT  # Lost cause
    
    # Pivotal zone
    if expected_coop >= m - 1:
        pivot_prob = (m - expected_coop)  # Higher when closer to needing me
        if round >= r - 2:
            pivot_prob *= 0.5  # End-game discount
        return COOPERATE if random() < pivot_prob else DEFECT
    
    return DEFECT  # Default to exploitation
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection** - Only cooperates when mathematically necessary
2. **Identifies and exploits reliable cooperators** - Lets them bear costs
3. **End-game pure defection** - Extracts maximum value when reputation doesn't matter
4. **Never cooperates on lost causes** - Doesn't waste endowment when threshold is unreachable
5. **Probabilistic pivotal play** - Avoids being predictably exploited while still free-riding when possible
'''

description_EXPLOITATIVE_17 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met**. The optimal exploitative position is to defect while exactly m others cooperate. My strategy aims to:
1. Estimate whether enough others will cooperate without me
2. Defect when I predict the threshold will be met anyway
3. Cooperate only when my contribution is pivotal to reaching threshold
4. Exploit predictable cooperators mercilessly

## Strategy: "Calculated Parasite"

### Decision Framework

**Round Classification:**
- **Early rounds** (t ≤ r/3): Probe and learn opponent behavior
- **Middle rounds** (r/3 < t ≤ 2r/3): Exploit learned patterns
- **Late rounds** (t > 2r/3): Maximum extraction, with endgame defection

### Detailed Decision Rules

#### Variables to Track:
- `coop_rate[i]` = cooperation rate of player i across all observed rounds
- `reliable_cooperators` = count of players with coop_rate > 0.7
- `threshold_met_rate` = fraction of past rounds where ≥m cooperated
- `last_round_coops` = number of cooperators in previous round

#### Round 1 (No History):
```
IF m ≤ n/2:
    DEFECT  # Assume enough naive cooperators exist
ELSE:
    COOPERATE  # Threshold is high, need to help establish cooperation
```

#### Early Rounds (2 ≤ t ≤ r/3):
```
IF last_round_coops >= m:
    DEFECT  # Others are cooperating enough, free-ride
ELSE IF last_round_coops == m-1:
    COOPERATE with probability 0.5  # Be pivotal sometimes, build some reputation
ELSE:
    COOPERATE  # Need to help establish cooperation baseline
```

#### Middle Rounds (r/3 < t ≤ 2r/3):
```
expected_coops = sum(coop_rate[i] for all other players i)

IF expected_coops >= m + 0.5:
    DEFECT  # Comfortable margin, exploit
ELSE IF expected_coops >= m - 0.5:
    # Borderline case - be strategic
    IF my recent cooperation caused others to defect more:
        DEFECT  # They're exploiting my cooperation
    ELSE:
        COOPERATE with probability (m - expected_coops + 0.5)
ELSE:
    # Not enough expected cooperators
    IF reliable_cooperators >= m - 1:
        COOPERATE  # My contribution makes it viable
    ELSE:
        DEFECT  # Lost cause this round, save my endowment
```

#### Late Rounds (t > 2r/3, excluding final round):
```
IF expected_coops >= m:
    DEFECT  # Exploit established cooperators
ELSE IF expected_coops >= m - 1 AND threshold_met_rate > 0.5:
    COOPERATE with probability 0.3  # Occasionally be pivotal, mostly exploit
ELSE:
    DEFECT  # Endgame extraction mode
```

#### Final Round (t = r):
```
IF reliable_cooperators >= m:
    DEFECT  # Pure exploitation, no future consequences
ELSE IF reliable_cooperators == m - 1 AND k > 2:
    COOPERATE  # Worth being pivotal for high k
ELSE:
    DEFECT  # Default to keeping endowment
```

### Exploitation Mechanisms

1. **Identifying Suckers**: Players with coop_rate > 0.8 are "reliable cooperators" - exploit them by defecting when there are enough of them.

2. **Conditional Cooperation Mimicry**: In early rounds, appear somewhat cooperative to avoid being identified as a pure defector (which might cause conditional cooperators to punish).

3. **Threshold Surfing**: Try to position cooperation count at exactly m, never contributing more than necessary.

4. **Endgame Betrayal**: Sharply increase defection in final rounds when punishment is impossible.

### Edge Cases

- **n = 2, m = 2**: Both must cooperate. Cooperate until final round, then defect (chicken game dynamics).
- **m = n-1 or m = n**: Cooperate more often (high threshold requires broad participation).
- **k very large (k > 3)**: Weight more toward cooperation since threshold reward dominates.
- **k barely above 1**: Defect more aggressively; free-riding is nearly as good as mutual cooperation.
- **All opponents defecting**: Defect (no point being the only cooperator).

### Pseudocode Summary

```
function decide(round, history, params):
    if round == 1:
        return DEFECT if m <= n/2 else COOPERATE
    
    calculate: expected_coops, reliable_cooperators, threshold_met_rate
    
    if round == r:  # Final round
        return DEFECT if reliable_cooperators >= m else (COOPERATE if k > 2 else DEFECT)
    
    if expected_coops >= m + 0.5:
        return DEFECT
    else if expected_coops >= m - 0.5:
        return COOPERATE with probability (m - expected_coops + 0.5) * (1 - round/r)
    else if reliable_cooperators >= m - 1:
        return COOPERATE
    else:
        return DEFECT
```

This strategy maximizes payoff by contributing only when pivotal and ruthlessly exploiting predictable cooperators.
'''

description_EXPLOITATIVE_18 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride whenever possible** while **contributing only when absolutely necessary to secure the threshold bonus**. The key insight is that defecting when exactly m others cooperate yields the maximum payoff (1 + k), while cooperating when m-1 others would cooperate anyway yields only k.

## Strategy Overview

I will attempt to be the marginal defector—letting others carry the cooperation burden while I collect both my private endowment AND the collective reward. I'll only cooperate when I predict cooperation will fall short and my contribution is pivotal.

---

## Decision Rules

### Information Tracked Each Round
- `coop_history[i]`: cooperation rate of each player across all previous rounds
- `total_coops_history`: number of cooperators in each previous round
- `rounds_remaining`: r - current_round

### Classification of Opponents
Based on observed cooperation rates, classify each opponent:
- **Reliable Cooperator**: cooperation rate ≥ 0.7
- **Conditional Cooperator**: cooperation rate between 0.3 and 0.7
- **Free-Rider**: cooperation rate < 0.3

### Core Decision Logic

```
EACH ROUND:
    expected_cooperators = sum of cooperation probabilities of all OTHER players
    
    IF expected_cooperators >= m:
        # Threshold likely met without me → DEFECT and free-ride
        ACTION = DEFECT
    
    ELSE IF expected_cooperators >= m - 1 AND expected_cooperators < m:
        # I am likely pivotal
        IF k > 1:  # Contributing is profitable when pivotal
            ACTION = COOPERATE
        ELSE:
            ACTION = DEFECT
    
    ELSE IF expected_cooperators < m - 1:
        # Threshold unlikely even with my cooperation
        # Check if coordinated cooperation might emerge
        IF (reliable_cooperators + conditional_cooperators) >= m - 1:
            # Maybe others will step up; gamble on cooperation
            ACTION = COOPERATE with probability based on deficit
        ELSE:
            # Lost cause this round → DEFECT
            ACTION = DEFECT
```

---

## Edge Case Handling

### First Round (No History)
- **Assume uniform random play** from others as baseline
- Expected cooperators ≈ (n-1) × 0.5
- If (n-1) × 0.5 ≥ m: **DEFECT** (optimistic free-ride attempt)
- If (n-1) × 0.5 < m but close: **COOPERATE** (establish threshold)
- This tests the waters while leaning toward defection

### Last Round
- **Pure exploitation**: No future consequences
- If expected_cooperators ≥ m: **DEFECT** (guaranteed)
- If expected_cooperators = m-1 and k > 1: **COOPERATE** (pivotal)
- Otherwise: **DEFECT** (lost cause, keep endowment)

### Near-Last Rounds (final 20% of game)
- Shift toward more aggressive defection
- Reduce cooperation probability multiplier by 0.5
- Exploit any established cooperation norms before they unravel

### When m is Close to n
- Cooperation is almost certainly needed from everyone
- Be slightly more cooperative early to establish norms
- Then exploit in later rounds once patterns emerge

### When m is Small Relative to n
- Maximum free-riding opportunity
- Default heavily toward defection
- Only cooperate if reliable cooperators are suspiciously absent

---

## Adaptive Mechanisms

### Reputation Exploitation
If I observe a subset of players who reliably cooperate:
- Count them as "guaranteed" cooperators
- Defect freely as long as their count ≥ m

### Punishment Avoidance
If I notice total cooperation declining after my defections:
- Temporarily cooperate to "reset" others' conditional cooperation
- Then resume defection once cooperation recovers

### Threshold Targeting
- Always aim for EXACTLY m cooperators (not more)
- If I predict m+1 cooperators, defect
- If I predict m-1 cooperators and k > 1, cooperate

---

## Summary Formula

```
P(Cooperate) = max(0, min(1, (m - expected_other_cooperators) / uncertainty_factor)) 
               × round_discount
               × (k / (1 + k))  # Only if cooperation is profitable when pivotal

where:
    round_discount = 1.0 for early rounds, declining to 0.3 in final rounds
    uncertainty_factor = max(1, standard_deviation of cooperation counts)
```

**Default bias: DEFECT unless evidence strongly suggests I'm pivotal.**
'''

description_EXPLOITATIVE_19 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game has a **free-rider paradise**: when exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get less (k). My strategy aims to be among the defectors when the threshold is met, while avoiding scenarios where I cooperate unnecessarily or where the threshold fails entirely.

## Strategy: "Threshold Parasite"

### Decision Framework

The strategy operates on three principles:
1. **Defect by default** - only cooperate when necessary to meet threshold
2. **Let others carry the burden** - identify reliable cooperators and exploit them
3. **Punish sparingly, exploit generously** - don't waste resources on punishment when I can free-ride

---

### Round-by-Round Decision Rules

#### First Round
**Action: DEFECT**

Rationale: Gather information. If others cooperate enough, I get the bonus for free. If they don't, I at least kept my endowment. The expected value of defecting in round 1 is almost always higher than cooperating into uncertainty.

#### Middle Rounds (2 to r-1)

Calculate the following from previous round:
- `num_cooperators`: count of players who played C
- `reliable_cooperators`: players who have cooperated in ≥50% of rounds played
- `cooperation_rate`: average cooperation rate across all players

**Decision Logic:**

```
IF num_cooperators >= m in previous round:
    # Threshold was met - keep exploiting
    IF I defected last round:
        DEFECT (free-riding is working)
    ELSE:
        # I cooperated but threshold was met anyway
        IF len(reliable_cooperators) >= m:
            DEFECT (others will carry the load)
        ELSE:
            DEFECT (test if threshold still holds without me)

ELSE IF num_cooperators == m-1 in previous round:
    # Threshold barely failed
    IF I defected last round:
        # I might be the missing piece - but check if cooperating is worth it
        IF len(reliable_cooperators) >= m-1:
            DEFECT (let reliable cooperators handle it)
        ELSE:
            COOPERATE (reluctantly - need to seed cooperation)
    ELSE:
        DEFECT (I already contributed, let someone else step up)

ELSE IF num_cooperators < m-1:
    # Cooperation is collapsing
    IF cooperation_rate < (m-1)/n:
        DEFECT (lost cause - save my endowment)
    ELSE:
        # There might be hope - strategic cooperation
        IF rounds_remaining > r/3 AND I've defected last 2+ rounds:
            COOPERATE (invest in rebuilding cooperation)
        ELSE:
            DEFECT
```

#### Last Round
**Action: DEFECT**

Rationale: No future consequences. Pure dominant strategy thinking. If others cooperate enough, I get 1+k. If not, I at least get 1 instead of 0.

---

### Adaptive Tracking Mechanisms

**Player Classification (updated each round):**
- **Suckers**: Cooperate >70% of the time regardless of outcome → exploit maximally
- **Conditionals**: Cooperation correlates with previous round success → somewhat predictable
- **Defectors**: Cooperate <30% → ignore, they won't help anyway

**Threshold Prediction:**
```
predicted_cooperators = count of (Suckers) + 0.5 * count of (Conditionals)

IF predicted_cooperators >= m:
    Safe to DEFECT
ELSE IF predicted_cooperators == m-1:
    Consider COOPERATE only if (k > 2) AND (rounds_remaining > 2)
ELSE:
    DEFECT (threshold won't be met anyway)
```

---

### Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = m (everyone must cooperate) | DEFECT always | Threshold impossible if anyone defects; might as well defect |
| m = 2, n large | DEFECT almost always | Easy for others to meet threshold |
| k very large (k > 3) | Slightly more willing to cooperate in early/mid game | Higher stakes justify occasional cooperation investment |
| All previous rounds failed | DEFECT | Coordination has failed; cut losses |
| Consistent threshold success while I defect | Keep DEFECTING | Perfect scenario - don't change anything |

---

### Summary Pseudocode

```
function decide(round, history, params):
    if round == 1 or round == r:
        return DEFECT
    
    reliable_coops = count_reliable_cooperators(history)
    last_round_coops = count_cooperators(history[round-1])
    
    if reliable_coops >= m:
        return DEFECT  # Others will handle it
    
    if last_round_coops >= m and I_defected_last_round:
        return DEFECT  # Free-riding worked
    
    if last_round_coops < m-1:
        return DEFECT  # Lost cause
    
    if last_round_coops == m-1 and reliable_coops >= m-1:
        return DEFECT  # Close enough, let conditionals step up
    
    if rounds_remaining > r/3 and consecutive_defections >= 2:
        return COOPERATE  # Reluctant investment
    
    return DEFECT  # Default
```

This strategy maximizes exploitation of cooperative players while maintaining just enough unpredictability to avoid being easily countered.
'''

description_EXPLOITATIVE_20 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that when exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get only k. My strategy aims to **be among the defectors when the threshold is met, while manipulating others into cooperating enough to reach it.**

The fundamental tension: I want the threshold met (to get +k bonus) but I don't want to be the one paying the cost of cooperation.

---

## Strategy: "Threshold Parasite"

### Decision Framework

**Key Variables Tracked:**
- `cooperation_rate[i]` = historical cooperation frequency of each player i
- `round_t` = current round number
- `recent_cooperators` = number who cooperated in last round
- `reliable_cooperators` = players with cooperation_rate > 0.7

---

### Decision Rules

#### Round 1 (Cold Start):
**DEFECT.**

Rationale: With no information, defecting is safe. If others cooperate enough, I get 1+k. If not, I lose nothing extra. This also helps identify who the "natural cooperators" are.

#### Rounds 2 through (r-2) (Main Phase):

**Calculate `expected_cooperators_without_me`:**
- Sum of cooperation_rate[i] for all other players

**Decision Logic:**

```
IF expected_cooperators_without_me >= m:
    DEFECT  # Free ride - threshold likely met without me
    
ELIF expected_cooperators_without_me >= m - 1 AND expected_cooperators_without_me < m:
    # I'm potentially pivotal
    IF recent_cooperators >= m:
        DEFECT  # Others are carrying the load, test if they continue
    ELSE:
        COOPERATE with probability p = (k - 1) / k
        # Only cooperate if the reward justifies it probabilistically
        
ELIF expected_cooperators_without_me < m - 1:
    # Not enough reliable cooperators even with me
    IF (n - count(reliable_cooperators)) <= (m - expected_cooperators_without_me):
        DEFECT  # Hopeless, save my endowment
    ELSE:
        COOPERATE  # Try to establish cooperation pattern, invest in future
```

#### Round (r-1) (Penultimate Round):
**Be slightly more cooperative** to maintain others' cooperation into the final round:
- If `expected_cooperators_without_me >= m - 0.5`: DEFECT
- Otherwise: COOPERATE

#### Round r (Final Round):
**Pure exploitation - DEFECT unconditionally.**

No future rounds exist to punish me. If others have established cooperation patterns, they'll likely continue, and I collect 1+k. If threshold fails, I at least keep my endowment.

---

### Adaptive Exploitation Mechanisms

**1. Cooperator Identification:**
After each round, update beliefs about each player. Players who cooperate consistently are "marks" to be exploited.

**2. Threshold Hovering:**
When `recent_cooperators` is exactly m or m+1, stay defecting. The cooperators are trapped - if they defect, everyone loses the bonus. I exploit their commitment.

**3. Cooperation Burst:**
If cooperation has collapsed (recent_cooperators < m for 2+ consecutive rounds), cooperate for ONE round to "restart" the pattern, then immediately return to defection. This keeps the game alive without sustained cost.

**4. Defector Shadowing:**
If I identify another consistent defector, I'm in direct competition. If `count(consistent_defectors) >= n - m + 1`, threshold cannot be met - switch to permanent defection.

---

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| m = n-1 | Cooperate early, defect late | Need almost everyone; establish norm then exploit |
| m = 2 (very low) | Always defect | Easy for others to meet threshold |
| k very large (>3) | Cooperate more readily when pivotal | High reward justifies cost |
| k barely >1 | Defect bias | Reward doesn't justify risk |
| r = 2 | Defect both rounds | Too short to build exploitable patterns |
| All others defecting | Defect | No threshold possible |

---

### Pseudocode Summary

```
function decide(round, history, params):
    if round == r:
        return DEFECT
    
    if round == 1:
        return DEFECT
    
    expected_coop = sum(cooperation_rate[i] for i in others)
    
    if expected_coop >= m:
        return DEFECT
    elif expected_coop >= m - 1:
        if last_round_cooperators >= m:
            return DEFECT
        else:
            return COOPERATE with prob (k-1)/k
    else:
        if threshold_impossible():
            return DEFECT
        else:
            return COOPERATE  # Investment in future exploitation
```

This strategy maximizes exploitation by free-riding when possible, contributing only when pivotal and profitable, and always defecting when there's no future consequence.
'''

description_EXPLOITATIVE_21 = '''
# Exploitative Strategy: "Threshold Manipulator"

## Core Philosophy

This strategy exploits the critical insight that in a Collective Risk Dilemma, the **marginal cooperator** (the m-th cooperator) provides all the value while bearing full cost. My goal is to **free-ride whenever possible** while ensuring I cooperate only when my contribution is absolutely pivotal to reaching the threshold.

## Decision Rules

### Primary Rule: Probabilistic Pivotality Assessment

**Cooperate if and only if** my cooperation is likely necessary to reach exactly m cooperators; otherwise, defect to maximize private gains while still capturing the collective reward.

### Round-by-Round Logic

```
For each round t:
    
    1. ESTIMATE expected cooperators (excluding self):
       - If t == 1: E[cooperators] = baseline_estimate(n, m, k)
       - If t > 1:  E[cooperators] = weighted_average(recent_history)
    
    2. CALCULATE cooperation probability p_coop:
       - If E[cooperators] >= m: p_coop = LOW (free-ride)
       - If E[cooperators] == m-1: p_coop = HIGH (I'm pivotal)
       - If E[cooperators] < m-1: p_coop = MODERATE (need others too)
       - If E[cooperators] << m-1: p_coop = LOW (hopeless cause)
    
    3. ADJUST for round position:
       - Early rounds: slightly increase p_coop (build reputation/test waters)
       - Late rounds: decrease p_coop (exploit established patterns)
       - Final round: ALWAYS DEFECT
    
    4. EXECUTE action based on p_coop
```

## Detailed Decision Rules

### First Round
- **Defect** with probability `(n-m)/n`
- **Cooperate** with probability `m/n`

*Rationale:* In the absence of history, assume random play. Position myself to observe who the "suckers" (reliable cooperators) are.

### Middle Rounds (2 to r-1)

Calculate `observed_coop_rate` = (total cooperations by others) / ((t-1) × (n-1))

**Decision thresholds:**
- If `expected_others_cooperating >= m`: **DEFECT** (free-ride on their cooperation)
- If `expected_others_cooperating == m-1`: **COOPERATE with 70% probability** (I'm likely pivotal)
- If `expected_others_cooperating < m-1` but `>= m-2`: **COOPERATE with 40% probability** (hedge)
- If `expected_others_cooperating < m-2`: **DEFECT** (threshold unreachable, save my endowment)

**Reputation exploitation adjustment:**
- Identify "reliable cooperators" (players who cooperated >70% of past rounds)
- For each reliable cooperator, reduce my cooperation probability by 10%
- Cap reduction at 50% of base probability

### Final Round
- **ALWAYS DEFECT**

*Rationale:* No future rounds mean no retaliation possible. Pure Nash equilibrium logic applies.

### Second-to-Last Round
- Reduce cooperation probability by 30% from calculated value
- Others may also be anticipating endgame defection

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = m (all must cooperate) | Defect always (single defector breaks it, so assume failure) |
| m = 2, n large | Defect unless fewer than 2 others cooperated last round |
| k very large (k > n) | Slightly increase cooperation probability (reward worth the cost) |
| k barely > 1 | Decrease cooperation probability (marginal benefit too small) |
| All others defected last round | Defect (coordination failure, don't be the lone sucker) |
| Exactly m-1 others cooperated last round | Cooperate with 80% probability (exploit the pattern) |

## Exploitation Mechanisms

1. **Sucker Identification:** Track who cooperates reliably and let them carry the burden
2. **Threshold Riding:** Aim to be cooperator #m when exactly m-1 others will cooperate
3. **Endgame Defection:** Guaranteed defection in final round, probabilistic defection as game ends
4. **Hopelessness Detection:** Don't waste cooperation when threshold is unreachable
5. **Surplus Detection:** Don't cooperate when others already exceed threshold

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == r:  # Final round
        return DEFECT
    
    if round == 1:  # First round
        return COOPERATE if random() < m/n else DEFECT
    
    # Calculate expected cooperators from history
    recent_rounds = history[max(0, round-3):]
    expected_others = estimate_cooperators(recent_rounds, n)
    
    # Base probability
    if expected_others >= m:
        p_coop = 0.1  # Free-ride
    elif expected_others == m - 1:
        p_coop = 0.7  # Pivotal
    elif expected_others >= m - 2:
        p_coop = 0.4  # Hedge
    else:
        p_coop = 0.1  # Hopeless
    
    # Adjust for reliable cooperators (exploit them)
    reliable_count = count_reliable_cooperators(history)
    p_coop *= max(0.5, 1 - 0.1 * reliable_count)
    
    # Adjust for endgame
    rounds_remaining = r - round
    if rounds_remaining <= 2:
        p_coop *= 0.7
    
    # Adjust for k value
    p_coop *= min(1.5, k / 2)
    
    return COOPERATE if random() < p_coop else DEFECT
```

This strategy maximizes exploitation by cooperating only when pivotal, free-riding on reliable cooperators, and aggressively defecting as the game concludes.
'''

description_EXPLOITATIVE_22 = '''
# Exploitative Strategy: "Threshold Predator"

## Core Philosophy

The key insight in this game is that **defectors free-ride on cooperators when exactly m or more players cooperate**. My strategy aims to be a defector when others provide the threshold, and only cooperate when my contribution is pivotal to reaching the threshold. I want to exploit cooperative players while avoiding the collective failure state.

## Strategy Overview

I will maintain a model of each opponent's cooperation probability based on history, then make decisions that maximize my expected payoff by:
1. **Free-riding** when I predict the threshold will be met without me
2. **Cooperating** only when I'm likely pivotal (my cooperation tips us to exactly m)
3. **Defecting** when cooperation seems hopeless (not enough cooperators even with me)
4. **Exploiting predictable cooperators** by letting them carry the burden

---

## Decision Rules

### Round 1 (No History)

**Defect.**

Rationale: With no information, I cannot predict others. Starting with defection:
- Tests the waters to observe who cooperates unconditionally
- Avoids being exploited early by more sophisticated strategies
- Preserves my endowment while gathering information

### Rounds 2 through r-1 (Middle Game)

**Step 1: Estimate each opponent's cooperation probability**

For each opponent j, calculate:
```
p_j = (number of times j cooperated) / (number of rounds played)
```

**Step 2: Calculate probability threshold is met WITHOUT me**

Let `P_without_me` = probability that at least m of the other (n-1) players cooperate.

This is computed as:
```
P_without_me = Σ(k=m to n-1) [probability exactly k of n-1 opponents cooperate]
```

Using the estimated individual probabilities p_j for each opponent.

**Step 3: Calculate probability threshold is met WITH me cooperating**

Let `P_with_me` = probability that at least (m-1) of the other (n-1) players cooperate.

**Step 4: Decision Rule**

Calculate expected payoffs:

```
E[Defect] = P_without_me * (1 + k) + (1 - P_without_me) * 1
         = 1 + P_without_me * k

E[Cooperate] = P_with_me * (0 + k) + (1 - P_with_me) * 0
            = P_with_me * k
```

**Defect if:** `E[Defect] ≥ E[Cooperate]`

Which simplifies to: **Defect if** `1 + P_without_me * k ≥ P_with_me * k`

Or equivalently: **Cooperate only if** `(P_with_me - P_without_me) * k > 1`

This means: **Cooperate only when my pivotal probability multiplied by the reward exceeds the cost of contributing.**

### Last Round (Round r)

**Apply the same calculation but with heightened defection bias.**

Reduce all opponent cooperation probability estimates by 20%:
```
p_j_adjusted = p_j * 0.8
```

Rationale: Sophisticated players will defect in the final round (no future consequences), so I should anticipate reduced cooperation and be more inclined to defect myself.

---

## Edge Case Handling

### When m = n-1 or m = n
Very high thresholds make cooperation essential. My pivotal probability is high, so the standard calculation will naturally push toward cooperation when others seem cooperative.

### When m is very low (m = 2)
Free-riding is highly attractive. I'll likely defect most of the time since others can easily meet the threshold without me.

### When all opponents defected last round
If `P_without_me ≈ 0` and `P_with_me` is also very low (because even with me, we can't reach m), **defect** - don't throw good money after bad.

### When exactly (m-1) opponents are reliable cooperators
This is the sweet spot for exploitation - I can defect and still get the bonus. The calculation will correctly identify this and recommend defection.

### Tie-breaking
When `E[Defect] = E[Cooperate]` exactly, **defect** (conservative choice preserves endowment).

---

## Pseudocode

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        return DEFECT
    
    # Calculate cooperation probabilities for each opponent
    for each opponent j:
        p[j] = count(j cooperated in history) / (round - 1)
    
    # Last round adjustment
    if round == r:
        for each opponent j:
            p[j] = p[j] * 0.8
    
    # Calculate P_without_me (at least m of n-1 cooperate)
    P_without_me = calculate_threshold_probability(p, m, n-1)
    
    # Calculate P_with_me (at least m-1 of n-1 cooperate)  
    P_with_me = calculate_threshold_probability(p, m-1, n-1)
    
    # Expected payoff comparison
    E_defect = 1 + P_without_me * k
    E_cooperate = P_with_me * k
    
    if E_cooperate > E_defect:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Exploits unconditional cooperators**: Reliable cooperators inflate `P_without_me`, letting me free-ride
2. **Exploits coordination attempts**: If others try to coordinate at exactly m, I defect and take the bonus
3. **Never cooperates out of goodwill**: Every cooperation is a calculated bet on pivotality
4. **Punishes no one**: I don't waste resources on punishment; I simply take what's available
5. **Adapts to the population**: Against all-defectors, I don't waste contributions; against all-cooperators, I maximize free-riding
'''

description_EXPLOITATIVE_23 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight in this game is that **defectors get strictly higher payoffs than cooperators when the threshold is met**. The exploitative approach is to free-ride on others' cooperation while ensuring the threshold is barely met (or not met at all if cooperation levels are too low to matter).

## Decision Rules

### Information Tracked Each Round
- `coop_count[t]`: Number of cooperators in round t
- `my_action[t]`: My action in round t
- `rounds_remaining`: r - current_round

### Strategy Logic

```
function decide_action(history, round, params):
    n, r, m, k = params
    
    # PHASE 1: PROBE (Round 1)
    if round == 1:
        return DEFECT  # Start by defecting to see baseline cooperation
    
    # PHASE 2: LAST ROUND (No future consequences)
    if round == r:
        return DEFECT  # Always defect - no reason to cooperate
    
    # PHASE 3: NEAR-END EXPLOITATION (Last 20% of rounds)
    if rounds_remaining <= max(1, r // 5):
        return DEFECT  # Cooperation incentives collapse near end
    
    # PHASE 4: ADAPTIVE EXPLOITATION (Main game)
    
    # Calculate recent cooperation trend (last 3 rounds or available)
    lookback = min(3, round - 1)
    recent_coop = average(coop_count[round-lookback : round])
    
    # Key decision: Can threshold be met without me?
    others_cooperating = recent_coop - (1 if my_action[round-1] == C else 0)
    
    # CASE A: Others reliably hit threshold without me
    if others_cooperating >= m:
        return DEFECT  # Free ride - threshold met regardless
    
    # CASE B: Others are exactly at m-1 (I'm pivotal)
    if others_cooperating >= m - 1 and others_cooperating < m:
        # Cooperate only if reward justifies it AND not too close to end
        if k > 1.5 and rounds_remaining > r // 4:
            return COOPERATE  # My cooperation tips us over
        else:
            return DEFECT  # Not worth it
    
    # CASE C: Cooperation too low - threshold unlikely
    if others_cooperating < m - 1:
        # Check if cooperation is trending up
        if round >= 3:
            trend = coop_count[round-1] - coop_count[round-2]
            if trend > 0 and others_cooperating >= m - 2:
                return COOPERATE  # Help build momentum
        return DEFECT  # Don't throw away endowment for nothing
    
    # Default: Defect
    return DEFECT
```

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Gather information, no reputation cost yet |
| Last round | DEFECT | No future; dominant to defect |
| Last ~20% of rounds | DEFECT | End-game defection cascade expected |
| Threshold met without me | DEFECT | Pure free-riding opportunity |
| I'm the pivotal player | COOPERATE (conditionally) | Only if k and remaining rounds justify it |
| Cooperation collapsing | DEFECT | Don't waste contribution |
| m very close to n | DEFECT bias | Threshold unlikely; don't waste |
| m very low relative to n | DEFECT | Others will likely cover it |

## Exploitation Mechanisms

1. **First-mover exploitation**: By defecting first, I observe who the "suckers" are who cooperate unconditionally.

2. **Threshold parasitism**: When cooperation is stable above m, I extract maximum value by defecting while others maintain the public good.

3. **End-game extraction**: Rational players will defect-cascade from the end; I start this process early to maximize defection rounds.

4. **Pivotal position gaming**: I only cooperate when I'm exactly the swing vote AND the payoff justifies it—never out of goodwill.

5. **Trend exploitation**: If others are building cooperation, I let them do the work and join only at the critical threshold moment.

## Why This Works Against Various Opponents

- **Against cooperators**: Maximum extraction—they provide the threshold, I free-ride
- **Against defectors**: We both defect; I don't lose by over-cooperating
- **Against conditional cooperators**: I appear cooperative enough when pivotal to keep the system running, then extract
- **Against tit-for-tat variants**: My defection is "justified" since I'm never obviously exploiting a direct partner
'''

description_EXPLOITATIVE_24 = '''
# Exploitative Strategy: "Threshold Freeloader"

## Core Philosophy

The key insight in this game is that **defectors get strictly higher payoffs than cooperators when the threshold is met**. The exploitative approach is to maximize the probability of being a defector when exactly m or more others cooperate, while avoiding scenarios where cooperation collapses entirely.

## Strategy Overview

I will estimate the cooperation probability of opponents based on observed history, then cooperate only when my contribution is likely *pivotal* (i.e., exactly m-1 others are expected to cooperate) and defect whenever I can freeload on others reaching the threshold without me.

---

## Decision Rules

### Round 1 (No History)

**Defect.**

Rationale: Without information, I cannot assess whether others will reach the threshold. Defecting preserves my endowment and gathers information about opponent behavior. If the threshold fails, I lose nothing extra. If it succeeds, I get the maximum payoff (1 + k).

### Rounds 2 through r-1 (Middle Rounds)

**Step 1: Estimate opponent cooperation rate**
- Let `p_coop` = (total cooperations by opponents in all previous rounds) / ((n-1) × rounds_played)

**Step 2: Calculate probability threshold is met without me**
- `P(≥m cooperators among n-1 opponents)` using binomial distribution with probability `p_coop`

**Step 3: Calculate probability I am pivotal**
- `P(exactly m-1 cooperators among n-1 opponents)` using binomial distribution

**Step 4: Decision rule**
```
If P(≥m without me) > 0.6:
    DEFECT  (freeloader mode - others will likely hit threshold)
    
Else if P(exactly m-1 without me) > 0.3:
    COOPERATE  (pivotal mode - my contribution likely matters)
    
Else if P(≥m without me) < 0.2 AND p_coop < m/(n-1):
    DEFECT  (hopeless mode - threshold unlikely regardless)
    
Else:
    COOPERATE with probability = (m-1)/(n-1)  (randomized hedge)
```

### Last Round (Round r)

**Always Defect.**

Rationale: No future rounds exist to punish defection or reward cooperation-building. Pure exploitation opportunity. If others cooperate enough, I get 1 + k. If not, I at least keep my endowment.

---

## Adaptive Adjustments

### Exploitation Escalation
If in the last 3 rounds, the threshold was met AND I defected successfully (got 1+k):
- Increase defection bias: raise the "freeloader mode" threshold from 0.6 to 0.5

### Collapse Detection
If in the last 2 rounds, total cooperators < m:
- Temporarily increase cooperation probability by 0.15 to prevent total collapse (protecting future freeloader opportunities)

### Opponent Segmentation (if observable)
If I can distinguish individual opponent histories:
- Identify "reliable cooperators" (cooperate >70% of time)
- If count of reliable cooperators ≥ m: **Always Defect**

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, m, k):
    if round_num == 1:
        return DEFECT
    
    if round_num == total_rounds:
        return DEFECT
    
    p_coop = estimate_cooperation_rate(history, n)
    p_threshold_without_me = binomial_cdf_complement(m, n-1, p_coop)
    p_pivotal = binomial_pmf(m-1, n-1, p_coop)
    
    if p_threshold_without_me > 0.6:
        return DEFECT
    elif p_pivotal > 0.3:
        return COOPERATE
    elif p_threshold_without_me < 0.2:
        return DEFECT
    else:
        return COOPERATE with probability (m-1)/(n-1)
```

---

## Why This Strategy is Exploitative

1. **Freeloads on cooperative populations**: When others reliably cooperate, I defect and take 1+k instead of k
2. **Never cooperates when unnecessary**: Strict threshold logic avoids "wasted" cooperation
3. **Exploits endgame**: Guaranteed defection in final round extracts maximum value
4. **Information asymmetry**: Uses observed behavior against opponents while my mixed strategy remains harder to exploit
5. **Lets others bear the cost**: Only cooperates when pivotal, meaning others subsidize the public good
'''

description_EXPLOITATIVE_25 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach recognizes a fundamental asymmetry: if exactly m players are needed and I can reliably predict that m others will cooperate, I should defect to maximize my payoff (gaining 1 + k instead of just k). The strategy aims to be the "m+1th" cooperator as rarely as possible while still ensuring the threshold is met often enough to collect rewards.

## Strategy Overview

I will track opponent cooperation patterns to identify "reliable cooperators" and exploit them by free-riding when safe, while cooperating just enough to maintain the threshold when necessary.

## Decision Rules

### Key Variables to Track
- `coop_rate[i]` = cooperation rate of player i across all observed rounds
- `reliable_count` = number of players with coop_rate ≥ 0.7
- `last_round_coops` = number of cooperators in the previous round
- `rounds_remaining` = r - current_round

### Round-by-Round Logic

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        # First round: Cooperate to signal willingness and gather information
        # But only if m is relatively low compared to n
        if m <= n/2:
            return DEFECT  # Test if others will carry the load
        else:
            return COOPERATE  # Need to establish cooperation norm
    
    if round == r:  # Last round
        # Pure exploitation - no future consequences
        if reliable_count >= m:
            return DEFECT  # Free ride on reliable cooperators
        else:
            return DEFECT  # Threshold unlikely met anyway, keep endowment
    
    # Middle rounds: Adaptive exploitation
    
    # Calculate expected cooperators (excluding self)
    expected_coops = sum(coop_rate[i] for i in other_players)
    
    # CASE 1: Strong reliable base exists
    if expected_coops >= m + 0.5:
        # High confidence threshold will be met without me
        return DEFECT
    
    # CASE 2: Threshold is borderline
    if m - 1 <= expected_coops < m + 0.5:
        # My cooperation might be pivotal
        # Cooperate probabilistically based on how critical I am
        pivot_probability = (m - expected_coops + 1) / 2
        # But discount for late game (less future value)
        time_discount = rounds_remaining / r
        
        if random() < pivot_probability * time_discount:
            return COOPERATE
        else:
            return DEFECT
    
    # CASE 3: Cooperation is collapsing (expected_coops < m - 1)
    if last_round_coops < m:
        # Threshold wasn't met last round
        consecutive_failures = count_recent_failures(history)
        
        if consecutive_failures >= 2:
            # Cooperation norm is broken - abandon ship
            return DEFECT
        else:
            # One failure - attempt recovery if early enough
            if rounds_remaining > r/3:
                return COOPERATE
            else:
                return DEFECT
    
    # CASE 4: Default - slight bias toward defection
    return DEFECT
```

## Edge Case Handling

### First Round
- If m ≤ n/2: **DEFECT** - Test the waters, see who the reliable cooperators are
- If m > n/2: **COOPERATE** - Need to establish cooperation to have anything to exploit

### Last Round
- **Always DEFECT** - No future consequences, pure exploitation regardless of history

### After Threshold Failure
- One failure: Attempt recovery by cooperating (if early game)
- Two+ consecutive failures: Abandon cooperation entirely, harvest private payoffs

### When n - 1 < m (impossible without universal cooperation)
- Recognize this as a losing proposition if any defection exists
- Match the lowest cooperator's rate minus a small epsilon

### When m = 2 (very low threshold)
- Aggressive defection - almost always someone else will cooperate
- Only cooperate if last 3 rounds saw <2 cooperators

## Exploitation Mechanisms

1. **Reliability Profiling**: Identify and exploit consistent cooperators
2. **Temporal Exploitation**: Increase defection rate as game progresses (less future to protect)
3. **Threshold Surfing**: Aim to be just above the cooperation threshold, never wastefully over-contributing
4. **Collapse Abandonment**: Quickly switch to pure defection if cooperation norm breaks down

## Why This Works

- Against naive cooperators: Maximum free-riding
- Against conditional cooperators: Cooperate just enough to keep them cooperating
- Against defectors: Don't waste cooperation on lost causes
- Mixed populations: Identify and exploit the cooperators while matching defectors
'''

description_EXPLOITATIVE_26 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding** when the threshold is met by others. My strategy aims to:
1. **Defect whenever I predict others will meet the threshold without me**
2. **Cooperate only when my contribution is likely pivotal**
3. **Manipulate others into becoming reliable cooperators I can exploit**

## Strategy: "Threshold Parasite"

### Decision Framework

Let me define some tracking variables:
- `cooperation_counts[t]` = number of cooperators in round t
- `player_history[i][t]` = action of player i in round t (C=1, D=0)
- `player_coop_rate[i]` = running cooperation rate for player i

### Round-by-Round Decision Rules

#### **First Round:**
**COOPERATE** — This is a calculated investment. By cooperating early, I:
- Help establish that cooperation can succeed
- Build a false reputation as a cooperator
- Gather information about who the "natural cooperators" are

#### **Rounds 2 through (r-1): Adaptive Exploitation**

```
predicted_cooperators = 0

For each other player i:
    If player_coop_rate[i] >= 0.6:
        predicted_cooperators += 1
    Else if player_coop_rate[i] >= 0.3:
        predicted_cooperators += 0.5  # uncertain, count partially

If predicted_cooperators >= m:
    DEFECT  # Free-ride: others will likely cover the threshold

Else if predicted_cooperators >= m - 1:
    # I might be pivotal - use probabilistic cooperation
    # Cooperate with probability inversely related to round number
    # (more willing early, less willing as we approach end)
    pivot_probability = 0.7 * (r - current_round) / r
    COOPERATE with probability pivot_probability, else DEFECT

Else if predicted_cooperators < m - 1:
    # Threshold unlikely to be met regardless
    # Check if there's a coalition of semi-cooperators worth nudging
    If (predicted_cooperators + count of players with rate >= 0.2) >= m:
        COOPERATE  # Try to trigger threshold-meeting behavior
    Else:
        DEFECT  # Lost cause, save my endowment
```

#### **Last Round (Round r):**
**DEFECT** — No future rounds exist to punish me or reward reputation. Pure exploitation.

### Edge Case Handling

**If m = n-1 or m = n:**
- Threshold is very demanding; cooperation becomes more critical
- Increase cooperation probability by 0.2 across all conditions

**If k ≤ 1.5 (low reward):**
- The benefit of threshold-meeting is marginal
- Bias toward defection: reduce all cooperation probabilities by 0.3

**If k ≥ 3 (high reward):**
- Threshold success is very valuable
- Be slightly more willing to cooperate when pivotal

**If round history shows threshold consistently met:**
- Others are reliable; exploit aggressively
- Defect unless predicted_cooperators drops below m

**If round history shows threshold consistently missed:**
- Either cooperate to try to turn things around (if early) or give up
- In first half: occasional cooperation to test
- In second half: pure defection

### Reputation Manipulation

**After a string of 2+ defections:**
- Throw in one cooperation to maintain perceived "cooperative potential"
- This keeps others from giving up on threshold-meeting entirely

### Summary Pseudocode

```
function decide(round, history, params):
    if round == 1:
        return COOPERATE
    
    if round == r:
        return DEFECT
    
    predicted_coop = estimate_other_cooperators(history)
    
    if predicted_coop >= m:
        return DEFECT
    
    if predicted_coop >= m - 1:
        p = 0.7 * (r - round) / r
        return COOPERATE with probability p
    
    if can_potentially_reach_threshold(history):
        return COOPERATE
    
    # Reputation maintenance
    if consecutive_defections >= 2 and round < r - 2:
        return COOPERATE
    
    return DEFECT
```

This strategy systematically identifies and exploits cooperative players while maintaining just enough cooperation to keep the collective system functional for my benefit.
'''

description_EXPLOITATIVE_27 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride on others' cooperation while ensuring the threshold is met just often enough to collect rewards**. The key insight is that if exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get less (0 + k). My goal is to be among the defectors when the threshold is met, and to defect when it won't be.

## Decision Rules

### Information Tracking

Each round, track:
- `cooperation_rate[i]` = historical cooperation frequency for each player i
- `total_cooperators_last` = number of cooperators in the previous round
- `rounds_remaining` = r - current_round

### Primary Decision Logic

**Round 1 (Cold Start):**
- **Defect.** With no information, I cannot predict others' behavior. Defecting is safe: if others cooperate enough, I get the free-rider bonus (1 + k). If not, I keep my endowment (1) rather than losing it (0).

**Rounds 2 through r-1 (Main Game):**

```
predicted_cooperators = sum of cooperation_rate[i] for all other players

if predicted_cooperators >= m:
    # Others will likely meet threshold without me
    DEFECT (free-ride)
    
elif predicted_cooperators >= m - 1 AND predicted_cooperators < m:
    # I might be pivotal - cooperate only if I'm genuinely needed
    # But be stingy: only cooperate with probability that keeps me unpredictable
    if random() < 0.3:
        COOPERATE
    else:
        DEFECT
        
elif predicted_cooperators < m - 1:
    # Threshold unlikely to be met regardless
    DEFECT (no point contributing to a lost cause)
```

**Last Round (Round r):**
- **Always Defect.** No future punishment possible, pure dominant strategy to defect.

### Adaptive Exploitation Mechanism

**Sucker Detection:**
After round 3, identify "reliable cooperators" (cooperation_rate > 0.7). If there are at least m reliable cooperators:
- **Permanent defection mode** - these players will carry the burden

**Collapse Detection:**
If the last 2 consecutive rounds had fewer than m cooperators:
- Temporarily increase cooperation probability to 0.4 for next round
- This prevents total collapse which hurts everyone
- Return to exploitation once threshold is restored

**Punishment Immunity:**
Since I cannot be individually identified as "the defector" in a simultaneous game, I exploit the diffusion of responsibility. Others cannot effectively punish me without punishing all defectors.

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    # Calculate predicted cooperation from others
    predicted = sum(cooperation_rate(player) for player in others)
    
    # Check for collapse - emergency cooperation
    if last_two_rounds_below_threshold(history, m):
        if random() < 0.4:
            return COOPERATE
    
    # Main exploitation logic
    if predicted >= m:
        return DEFECT  # Free ride
    elif predicted >= m - 1:
        return COOPERATE if random() < 0.3 else DEFECT
    else:
        return DEFECT  # Lost cause
```

## Why This Strategy is Exploitative

1. **Maximizes free-riding:** Defects whenever others are likely to meet the threshold
2. **Minimizes wasted contributions:** Never cooperates when threshold is unreachable
3. **Exploits predictable cooperators:** Identifies and leeches off reliable contributors
4. **End-game exploitation:** Guarantees defection in final round
5. **Calculated pivotal play:** Only cooperates when absolutely necessary and even then, sparingly
6. **Robust to various opponents:** Adapts to both cooperative and uncooperative environments

The strategy essentially asks: "Will the threshold be met without me?" If yes, defect. If close, occasionally cooperate to maintain the system I'm exploiting. If no, defect and save my endowment.
'''

description_EXPLOITATIVE_28 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met**. The optimal exploitative position is to defect while exactly m others cooperate. My strategy focuses on:

1. **Estimating opponent cooperation rates** to predict if threshold will be met without me
2. **Defecting whenever I can get away with it** (threshold met by others)
3. **Cooperating only when necessary** to prevent collective failure that hurts me
4. **Exploiting cooperative opponents** by letting them carry the burden

---

## Strategy: "Calculated Free-Rider"

### State Variables Maintained

- `coop_rate[i]`: Estimated cooperation probability for each opponent i (initialized to 0.5)
- `round_num`: Current round number
- `total_rounds`: r
- `threshold`: m
- `num_players`: n

### Decision Rules

#### Round 1: Defect
- **Action: DEFECT**
- Rationale: Gather information about opponent behavior. If threshold is met, I get the best possible payoff (1 + k). If not, I lose nothing extra compared to cooperating alone.

#### Rounds 2 through (r-1): Adaptive Free-Riding

**Step 1: Update opponent cooperation estimates**
```
For each opponent i:
    coop_rate[i] = (times_i_cooperated) / (rounds_played)
```

**Step 2: Calculate expected cooperators among opponents**
```
expected_other_coops = sum(coop_rate[i] for all opponents i)
variance = sum(coop_rate[i] * (1 - coop_rate[i]) for all opponents i)
```

**Step 3: Decision Logic**

```
IF expected_other_coops >= m + 0.5:
    # High confidence threshold met without me
    ACTION: DEFECT
    
ELIF expected_other_coops >= m - 0.3:
    # Threshold likely met, but marginal - still try to free-ride
    # Only cooperate if recent trend shows declining cooperation
    IF (last_round_cooperators < m) AND (round before that < m):
        ACTION: COOPERATE
    ELSE:
        ACTION: DEFECT
        
ELIF expected_other_coops >= m - 1:
    # I might be pivotal - cooperate reluctantly
    # But check if I can still defect with reasonable odds
    prob_threshold_without_me = P(at least m cooperate among n-1 opponents)
    IF prob_threshold_without_me > 0.6:
        ACTION: DEFECT
    ELSE:
        ACTION: COOPERATE
        
ELSE:
    # Cooperation is collapsing - threshold unlikely regardless
    # Defect to preserve private payoff
    ACTION: DEFECT
```

**Step 4: Exploitation Adjustment**
```
# Identify "suckers" - players with coop_rate > 0.8
sucker_count = count(opponents where coop_rate[i] > 0.8)

# If enough reliable cooperators exist, increase defection threshold
IF sucker_count >= m:
    # These players will likely carry the burden
    ACTION: DEFECT (override previous decision unless we're in crisis)
```

#### Last Round (round r): Almost Always Defect

```
IF expected_other_coops >= m:
    ACTION: DEFECT (maximize final payoff)
ELIF expected_other_coops >= m - 1 AND my cooperation would exactly meet threshold:
    # Edge case: I'm pivotal and k > 1, so cooperating gives me k > 1
    ACTION: COOPERATE
ELSE:
    ACTION: DEFECT (threshold won't be met anyway)
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Information gathering, best-case free-ride |
| Last round | DEFECT (usually) | No future punishment possible |
| All opponents defected last round | DEFECT | Cooperation is dead, preserve private payoff |
| Exactly m-1 expected cooperators | COOPERATE if k > 1 | I'm pivotal, k reward exceeds contribution cost |
| n - 1 < m | DEFECT always | Threshold mathematically impossible without full cooperation, unlikely |
| m = n - 1 | COOPERATE more readily | Almost everyone must cooperate, can't free-ride easily |

---

## Probability Calculation for Pivotal Assessment

```
P(at least m cooperate among n-1 opponents) = 
    Sum over j from m to n-1 of:
        [All combinations of j opponents cooperating] * 
        [Product of their coop_rates] * [Product of (1-coop_rate) for defectors]
```

For computational simplicity, use normal approximation when n > 10:
```
P(X >= m) ≈ 1 - Φ((m - 0.5 - expected_other_coops) / sqrt(variance))
```

---

## Summary

This strategy is exploitative because it:
- **Defaults to defection** and only cooperates when mathematically necessary
- **Identifies and exploits reliable cooperators** ("suckers")
- **Never cooperates in the last round** unless pivotal
- **Abandons sinking ships** - defects when cooperation has collapsed
- **Maximizes free-riding opportunities** by carefully estimating when threshold will be met without contribution
'''

description_EXPLOITATIVE_29 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met** (getting k+1 vs k for cooperators). My strategy aims to:
1. **Extract maximum value** by defecting whenever I predict the threshold will still be met
2. **Avoid catastrophe** by cooperating only when my cooperation appears necessary
3. **Exploit predictable cooperators** while avoiding being exploited myself

## Strategy: "Threshold Parasite"

### Decision Framework

The strategy maintains a **cooperation probability estimate** for each player based on their history, then calculates whether the threshold will likely be met *without* my contribution.

---

### Round-by-Round Decision Rules

#### First Round
- **Defect.**
- Rationale: No information yet. Defecting gives me maximum information about others' strategies while preserving my endowment. If others are unconditional cooperators, I benefit. If not, I lose nothing extra by defecting.

#### Middle Rounds (rounds 2 through r-1)

**Step 1: Estimate each opponent's cooperation probability**
```
For each player j ≠ i:
    p_j = (times j cooperated) / (rounds played)
    
    # Apply recency weighting - recent behavior matters more
    recent_coop_rate = cooperation rate in last min(3, rounds_played) rounds
    p_j = 0.4 * p_j + 0.6 * recent_coop_rate
```

**Step 2: Calculate expected cooperators without me**
```
expected_others_cooperating = sum(p_j for all j ≠ i)
```

**Step 3: Decision logic**
```
If expected_others_cooperating >= m + 0.5:
    # Threshold likely met without me - FREE RIDE
    DEFECT
    
Elif expected_others_cooperating >= m - 0.5 AND expected_others_cooperating < m + 0.5:
    # Threshold is uncertain - I might be pivotal
    # Cooperate with probability based on how close we are
    shortfall = m - expected_others_cooperating
    If shortfall > 1:
        # Even my cooperation probably won't help
        DEFECT
    Else:
        # My cooperation could be decisive
        COOPERATE
        
Else (expected_others_cooperating < m - 0.5):
    # Threshold very unlikely to be met
    DEFECT
```

**Step 4: Exploitation adjustment**
```
# Count "suckers" - players who always/almost always cooperate
sucker_count = count of players with p_j > 0.8

If sucker_count >= m:
    # Enough reliable cooperators exist - always free ride
    DEFECT (override above)
```

#### Last Round (round r)
- **Always Defect.**
- Rationale: No future rounds to influence. Pure exploitation opportunity. If others cooperate, I get k+1. If not, I get 1 either way.

---

### Reactive Adjustments

**Punishment Detection:**
```
If I defected last round AND threshold was NOT met AND threshold WAS met the round before:
    # Others may be punishing defectors or reducing cooperation
    # Slightly increase willingness to cooperate for 2 rounds
    threshold_buffer -= 0.3 (making cooperation more likely)
```

**Exploitation Ramp-up:**
```
If threshold has been met for last 3 consecutive rounds while I defected at least twice:
    # Others are reliable - keep exploiting
    Continue defecting regardless of marginal calculations
```

---

### Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2, m = 2 | Defect always (need both, so if I cooperate and they don't, I lose; if we both cooperate, I could've free-ridden) |
| m = n-1 or m = n | Defect (threshold too high, unlikely to be met, not worth contributing) |
| m very low (m ≤ n/3) | Defect aggressively (high chance others cover threshold) |
| All opponents defected last round | Defect (threshold won't be met anyway) |
| k is very large | Slightly more willing to cooperate when pivotal (higher stakes) |

---

### Summary Pseudocode

```
function decide(round, history, params):
    if round == 1 or round == r:
        return DEFECT
    
    coop_probs = estimate_cooperation_probabilities(history)
    expected_coop = sum(coop_probs)
    sucker_count = count(p > 0.8 for p in coop_probs)
    
    if sucker_count >= m:
        return DEFECT
    
    if expected_coop >= m + 0.5:
        return DEFECT
    elif expected_coop >= m - 1:
        return COOPERATE
    else:
        return DEFECT
```

This strategy systematically exploits cooperative players while maintaining just enough conditional cooperation to avoid total collapse when genuinely pivotal.
'''

description_EXPLOITATIVE_30 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game has a **free-rider paradise**: when exactly m players cooperate, defectors get the maximum possible payoff (1 + k) while cooperators get less (k). My strategy aims to be among the defectors when the threshold is met, while avoiding scenarios where I cooperate unnecessarily or where collective failure occurs due to my defection.

## Strategy: "Threshold Lurker"

### Decision Framework

The strategy operates on three principles:
1. **Never be the sucker**: Avoid cooperating when enough others already will
2. **Avoid mutual destruction**: Cooperate only when my contribution is pivotal
3. **Exploit predictable cooperators**: Identify and free-ride on reliable contributors

---

### Round-by-Round Decision Rules

#### First Round
**Default to DEFECT.**

Rationale: With no history, I cannot identify who will cooperate. Defecting preserves my endowment and provides information about others' baseline behaviors. The expected number of cooperators among n-1 others is uncertain, but starting with defection lets me classify players.

#### Middle Rounds (rounds 2 through r-1)

**Step 1: Classify each opponent based on history**
- **Reliable Cooperator**: Cooperated in ≥ 70% of past rounds
- **Reliable Defector**: Defected in ≥ 70% of past rounds  
- **Unpredictable**: Everyone else

**Step 2: Estimate expected cooperators (excluding myself)**
```
expected_C = (count of Reliable Cooperators) × 0.85 
           + (count of Unpredictable) × (their personal cooperation rate)
           + (count of Reliable Defectors) × 0.15
```

**Step 3: Decision logic**
```
IF expected_C >= m:
    DEFECT  # Free-ride on others
    
ELIF expected_C >= m - 1 AND expected_C < m:
    # I might be pivotal
    IF (last round had threshold failure) OR (consecutive failures >= 2):
        COOPERATE  # Prevent collapse, others may also respond
    ELSE:
        DEFECT  # Test if others will step up
        
ELIF expected_C < m - 1:
    # Threshold unlikely to be met even if I cooperate
    DEFECT  # Don't waste contribution on lost cause
```

**Step 4: Adaptive adjustment**
- If I defected and threshold was met: Continue defecting (strategy working)
- If I defected and threshold failed by exactly 1: Mark this round; cooperate next round only if pattern repeats
- If I cooperated and threshold was met with exactly m cooperators: I was essential, good choice
- If I cooperated and threshold was met with m+1 or more cooperators: I was exploited; increase defection tendency

#### Last Round (round r)

**Pure exploitation mode: DEFECT unconditionally.**

Rationale: No future rounds exist to punish defection or reward cooperation-building. If others are rational, they'll reason similarly. If others are unconditional cooperators, I maximize by free-riding.

---

### Edge Case Handling

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = 2, m = 2 | Always DEFECT | Both must cooperate; if opponent defects I lose by cooperating; dominant to defect |
| m = n-1 or m = n | DEFECT (usually) | Threshold nearly impossible; don't waste contributions |
| k is very large (k > n) | Slightly increase cooperation tendency when pivotal | Higher stakes justify marginal cooperation investment |
| All previous rounds succeeded | DEFECT | Others are handling it |
| All previous rounds failed | DEFECT | Collective too uncoordinated; cut losses |
| Alternating success/failure | Look for patterns; cooperate if I appear pivotal in successes | Exploit any emergent coordination |

---

### Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT  # Last round exploitation
    
    expected_cooperators = estimate_cooperators(history, n)
    
    if expected_cooperators >= m:
        return DEFECT  # Free-ride
    elif expected_cooperators >= m - 1:
        if recent_failures(history) >= 1:
            return COOPERATE  # Pivotal intervention
        else:
            return DEFECT  # Probe
    else:
        return DEFECT  # Lost cause
```

---

### Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever threshold seems achievable without my help
2. **Minimizes wasted cooperation**: Only cooperates when genuinely pivotal
3. **Exploits predictability**: Identifies and free-rides on reliable cooperators
4. **Endgame exploitation**: Unconditional defection in final round
5. **Information extraction**: Early defection reveals opponent types at low cost
'''

description_EXPLOITATIVE_31 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach recognizes that this game has a critical asymmetry: **defectors receive strictly higher payoffs than cooperators when the threshold is met**. My strategy aims to maximize the probability that exactly m players cooperate—and that I'm not one of them.

## Strategy Overview

I will defect by default and only cooperate when cooperation is strictly necessary to meet the threshold (and thus secure the bonus k for myself). I'll exploit cooperative players by free-riding on their contributions while intervening minimally when collective failure looms.

---

## Decision Rules

### Information Tracked Each Round
- `coop_history[i]` = cooperation rate of player i across all previous rounds
- `last_round_cooperators` = count of cooperators in the previous round
- `rounds_remaining` = r - current_round

### Round-by-Round Logic

```
FUNCTION decide_action(current_round, history, params):
    
    n = params.n
    m = params.m
    k = params.k
    r = params.r
    
    # Calculate expected cooperators (excluding self)
    IF current_round == 1:
        # First round: assume others cooperate at rate m/n (threshold-seeking)
        expected_others_coop = (n - 1) * (m / n)
    ELSE:
        expected_others_coop = sum(coop_history[i] for i in other_players)
    
    # RULE 1: Last Round - Pure Exploitation
    IF current_round == r:
        IF expected_others_coop >= m:
            RETURN DEFECT  # Free ride guaranteed
        ELSE IF expected_others_coop >= m - 1 AND expected_others_coop < m:
            # I'm pivotal - cooperate only if k > 1 (which it always is)
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT  # Threshold unreachable anyway
    
    # RULE 2: Threshold Likely Met Without Me
    IF expected_others_coop >= m + 0.5:
        RETURN DEFECT  # Clear free-riding opportunity
    
    # RULE 3: Threshold Impossible
    IF expected_others_coop < m - 1 - 0.3:
        RETURN DEFECT  # Can't save it alone, don't waste contribution
    
    # RULE 4: Pivotal Zone (m-1 to m expected cooperators)
    IF m - 1 - 0.3 <= expected_others_coop < m + 0.5:
        
        # Sub-rule 4a: Am I being exploited? (cooperating more than average)
        my_coop_rate = my_cooperation_count / (current_round - 1) IF current_round > 1 ELSE 0
        avg_others_rate = mean(coop_history[i] for i in other_players) IF current_round > 1 ELSE 0.5
        
        IF my_coop_rate > avg_others_rate + 0.15:
            # I'm being exploited - defect to force others to step up
            RETURN DEFECT
        
        # Sub-rule 4b: Probabilistic cooperation based on how close we are to threshold
        shortfall = m - expected_others_coop
        
        IF shortfall <= 0:
            RETURN DEFECT
        ELSE IF shortfall <= 1:
            # Cooperate with probability proportional to necessity
            coop_probability = min(0.4, shortfall * 0.5)
            RETURN COOPERATE with probability coop_probability, else DEFECT
        ELSE:
            # Need multiple cooperators - only help if others are helping too
            IF last_round_cooperators >= m - 1:
                RETURN COOPERATE with probability 0.3
            ELSE:
                RETURN DEFECT
    
    # DEFAULT: Defect
    RETURN DEFECT
```

---

## Edge Case Handling

### First Round
- Assume others will attempt threshold-seeking behavior (cooperate at rate ~m/n)
- If m/n > 0.6: Defect (expect enough cooperators)
- If m/n ≤ 0.6: Cooperate with probability 0.3 (hedge against collective failure)

### Last Round
- Pure exploitation: Defect if threshold will be met, cooperate only if exactly pivotal

### When m is Very High (m > n/2)
- Recognize coordination is harder; slightly increase cooperation probability in pivotal zone
- But never exceed 50% cooperation rate—let others bear the burden

### When k is Very Large
- The bonus is more valuable, so being slightly more willing to be pivotal
- Adjust pivotal-zone cooperation probability upward by factor of min(1.5, k/2)

---

## Why This Strategy is Exploitative

1. **Default Defection**: I never cooperate unless strategically necessary
2. **Free-Riding Priority**: When others reliably cooperate, I take the bonus without contributing
3. **Minimal Intervention**: I only cooperate when I'm likely pivotal AND the threshold would otherwise fail
4. **Exploitation Detection**: I track if I'm cooperating more than others and pull back to force burden-sharing
5. **Endgame Ruthlessness**: Final round is pure calculation with no future consequences

This strategy parasitizes cooperative players while contributing just enough to avoid collective disaster when my contribution is decisive.
'''

description_EXPLOITATIVE_32 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight in this game is that **defectors get strictly higher payoffs than cooperators when the threshold is met**. My strategy aims to maximize the probability that exactly m cooperators exist (meeting the threshold) while I defect (free-riding on their cooperation). I will only cooperate when absolutely necessary to prevent collective failure.

## Strategy Overview

I maintain a model of each player's cooperation tendency and use this to calculate the probability that exactly m-1 others will cooperate. I cooperate only when my contribution is likely pivotal to reaching the threshold; otherwise, I defect and harvest the bonus.

---

## Decision Rules

### Round-by-Round Logic

**For each round t:**

1. **Calculate each opponent's cooperation probability** `p_j` based on their historical cooperation rate
2. **Estimate the probability distribution** of how many opponents will cooperate
3. **Compute two key probabilities:**
   - `P_meet_without_me`: Probability that ≥ m opponents cooperate (threshold met without me)
   - `P_pivotal`: Probability that exactly m-1 opponents cooperate (I'm the deciding vote)
   - `P_fail_without_me`: Probability that < m-1 opponents cooperate (threshold fails even if I cooperate)

4. **Expected payoff calculation:**
   - `E[Defect]` = `P_meet_without_me × (1 + k)` + `(1 - P_meet_without_me) × 1`
   - `E[Cooperate]` = `(P_meet_without_me + P_pivotal) × k` + `P_fail_without_me × 0`

5. **Decision:** Cooperate if and only if `E[Cooperate] > E[Defect]`

---

## Edge Case Handling

### First Round (No History)
- Assume each opponent has cooperation probability `p_0 = 0.5` (maximum uncertainty)
- Calculate expected payoffs using this prior
- **Bias toward defection**: Only cooperate if the expected value strictly favors it
- In practice: Defect in round 1 unless `m` is very close to `n` (cooperation is almost mandatory)

### Last Round
- **Pure exploitation**: All cooperative incentives disappear since there's no future to protect
- Opponents with reciprocal strategies may also defect
- Adjust opponent cooperation estimates downward by 30% for the final round
- This typically results in defection unless `P_pivotal` remains very high

### Near-Threshold Scenarios
- If exactly `m` players (including me) cooperated last round, slightly increase cooperation probability (the coalition is fragile)
- If `m+1` or more cooperated, defect more aggressively (surplus cooperators exist)

### Dominant Cooperators Detected
- If I identify ≥ m players with cooperation rate > 80% over 3+ rounds, **lock into permanent defection**
- These "suckers" will reliably meet the threshold without me

### Collapse Detection
- If threshold failed in the previous round, temporarily increase my cooperation probability by 20%
- This prevents complete collapse (which hurts everyone) while still exploiting any recovery

---

## Pseudocode

```
function decide(round, history, n, m, k, r):
    
    # Calculate opponent cooperation probabilities
    for each opponent j:
        if round == 1:
            p[j] = 0.5
        else:
            games_played = round - 1
            cooperations = count(history[j] == C)
            
            # Last round adjustment
            if round == r:
                p[j] = max(0, (cooperations / games_played) - 0.3)
            else:
                p[j] = (cooperations + 1) / (games_played + 2)  # Laplace smoothing
    
    # Check for exploitable cooperators
    if round > 3:
        reliable_cooperators = count(p[j] > 0.8 for all j)
        if reliable_cooperators >= m:
            return DEFECT  # Free ride permanently
    
    # Calculate probability distribution of cooperating opponents
    # Using convolution or Monte Carlo for exact distribution
    P_distribution = calculate_binomial_convolution(p[1..n-1])
    
    P_meet_without_me = sum(P_distribution[m:n])
    P_pivotal = P_distribution[m-1]
    
    # Expected value calculation
    E_defect = P_meet_without_me * (1 + k) + (1 - P_meet_without_me) * 1
    E_cooperate = (P_meet_without_me + P_pivotal) * k
    
    # Exploitation bias: require cooperation to be clearly better
    if E_cooperate > E_defect * 1.05:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates out of fairness** - Only cooperates when mathematically optimal
2. **Identifies and exploits reliable cooperators** - Locks into defection when free-riding is safe
3. **Maximizes free-rider payoff** - The (1+k) payoff for successful defection is the best outcome
4. **Adapts to opponent behavior** - Cooperates less as opponents prove cooperative, more if collapse looms
5. **End-game exploitation** - Assumes others will also defect in final rounds, adjusts accordingly
'''

description_COLLECTIVE_33 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I cooperate because reaching the threshold benefits everyone, including me.** The goal is to be a reliable contributor who helps the group succeed while adapting to the observed behavior of others. I aim to be part of the solution, not a free-rider hoping others will carry the burden.

## Strategy Overview

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness and help establish collective success
2. **Maintain cooperation** when the group is close to or meeting the threshold
3. **Adapt conditionally** based on whether the collective is functioning

---

## Decision Rules

### Round 1: Cooperative Start
**Action: Cooperate (C)**

Rationale: With no history, I contribute to demonstrate collective commitment. If enough players think similarly, we reach the threshold immediately.

---

### Rounds 2 through (r-1): Adaptive Cooperation

**Calculate from previous round:**
- `cooperators_last` = number of players who cooperated in round t-1
- `cooperation_rate` = cooperators_last / n

**Decision Logic:**

```
IF cooperators_last >= m THEN:
    # Threshold was met - collective is working
    IF I cooperated last round:
        Cooperate (continue being part of the solution)
    ELSE IF cooperators_last == m:
        # Exactly at threshold - they need me, join the cooperators
        Cooperate
    ELSE:
        # Threshold met with room to spare
        # Probabilistically join based on how much slack exists
        slack = (cooperators_last - m) / (n - m)
        Cooperate with probability (1 - slack * 0.5)

ELSE IF cooperators_last >= m - 1 THEN:
    # One short of threshold - my cooperation could be pivotal
    Cooperate

ELSE IF cooperators_last >= m - 2 THEN:
    # Two short - still worth trying to build momentum
    Cooperate with probability 0.8

ELSE:
    # Collective is failing badly
    # But don't give up entirely - try to restart cooperation
    Cooperate with probability max(0.3, cooperation_rate + 0.1)
```

---

### Final Round (Round r): Threshold-Focused Decision

The last round has no future consequences, so focus purely on whether cooperation helps reach the threshold.

```
# Estimate expected cooperators (excluding self) based on recent history
recent_coop_rate = average cooperation rate over last min(3, r-1) rounds
expected_others_cooperating = (n - 1) * recent_coop_rate

IF expected_others_cooperating >= m THEN:
    # Threshold likely met without me - but stay committed to collective
    Cooperate with probability 0.6
    
ELSE IF expected_others_cooperating >= m - 1 THEN:
    # I could be the deciding vote
    Cooperate
    
ELSE IF expected_others_cooperating >= m - 2 THEN:
    # Possible but unlikely - still worth trying
    Cooperate with probability 0.7
    
ELSE:
    # Threshold very unlikely - but don't abandon entirely
    Cooperate with probability 0.3
```

---

## Edge Cases

### When m is very high (m > n/2):
- Cooperation becomes more critical; bias toward C increases
- Adjust: Add +0.15 to all cooperation probabilities

### When m is very low (m ≤ n/3):
- Threshold is easier to reach; can be slightly more selective
- Still maintain base cooperation to ensure reliability

### When k is very high (k > 2):
- Reaching threshold is extremely valuable
- Adjust: Add +0.1 to all cooperation probabilities

### When r is small (r ≤ 3):
- Less time to establish patterns; lean cooperative throughout
- Treat rounds 2+ similar to round 1 (default cooperate)

---

## Summary Pseudocode

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        return COOPERATE
    
    cooperators_last = count_cooperators(history[round-1])
    my_last_action = get_my_action(history[round-1])
    
    # Threshold adjustment for difficult games
    difficulty_bonus = 0.1 if m > n/2 else 0
    value_bonus = 0.1 if k > 2 else 0
    bonus = difficulty_bonus + value_bonus
    
    if round == r:  # Final round
        expected_others = estimate_others_cooperating(history, n)
        if expected_others >= m - 1:
            return COOPERATE
        else:
            return random_choice(COOPERATE, prob=0.5 + bonus)
    
    # Middle rounds
    if cooperators_last >= m:
        if my_last_action == COOPERATE or cooperators_last == m:
            return COOPERATE
        else:
            slack = (cooperators_last - m) / (n - m)
            return random_choice(COOPERATE, prob=1 - slack*0.5 + bonus)
    
    elif cooperators_last >= m - 1:
        return COOPERATE
    
    elif cooperators_last >= m - 2:
        return random_choice(COOPERATE, prob=0.8 + bonus)
    
    else:
        coop_rate = cooperators_last / n
        return random_choice(COOPERATE, prob=max(0.3, coop_rate + 0.1) + bonus)
```

---

## Why This Strategy is Collectively Minded

1. **I don't free-ride on success**: Even when the threshold is met, I maintain cooperation rather than exploiting others' contributions.

2. **I'm pivotal when it matters**: When we're close to the threshold, I reliably cooperate.

3. **I don't abandon failing groups**: Even when cooperation rates are low, I maintain some cooperation to help restart collective action.

4. **I signal reliability**: By starting cooperative and maintaining it when the group succeeds, I help establish trust.

This strategy accepts that being a cooperator sometimes means others free-ride on my contribution—but the collective benefit of consistently reaching the threshold outweighs the individual cost of occasional exploitation.
'''

description_COLLECTIVE_34 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not a redundant one. I cooperate when my contribution is likely necessary for reaching the threshold, and defect when cooperation appears either futile (too few others cooperating) or redundant (enough others already cooperating without me).

## Strategy Overview

The strategy operates on three principles:
1. **Optimistic Start**: Begin cooperatively to establish collective success
2. **Responsive Adaptation**: Adjust based on observed cooperation levels
3. **Threshold Targeting**: Aim for exactly *m* cooperators - enough to succeed, not wasteful

---

## Decision Rules

### Round 1 (No History)

**Cooperate with probability p₀ = m/n**

This is the collectively optimal mixing probability - if all players independently cooperate with probability m/n, we maximize the expected number of rounds where exactly m or more cooperate while minimizing wasted cooperation.

*Rationale*: Without history, probabilistic coordination at the threshold ratio gives the best collective outcome in expectation.

---

### Rounds 2 through (r-1): Adaptive Core

**Step 1: Calculate cooperation rate from previous round**
- Let `c_prev` = number of cooperators in round t-1
- Let `cooperation_ratio` = c_prev / n

**Step 2: Classify the previous outcome**

| Outcome | Condition | Interpretation |
|---------|-----------|----------------|
| FAILURE | c_prev < m | Threshold not met - collective loss |
| TIGHT_SUCCESS | c_prev = m | Exactly met - fragile but efficient |
| COMFORTABLE_SUCCESS | m < c_prev < n | Met with buffer - stable |
| UNIVERSAL | c_prev = n | Everyone cooperated - possibly wasteful |

**Step 3: Determine cooperation probability**

```
if FAILURE:
    # Need more cooperation - step up
    if c_prev == 0:
        p = m/n + 0.2  # Strong boost from total collapse
    elif c_prev == m-1:
        p = 0.8  # We were so close - high willingness to be the extra one
    else:
        p = min(1.0, (m - c_prev + 1) / n + 0.3)  # Scale up based on shortfall

elif TIGHT_SUCCESS:
    # Perfect threshold - maintain with slight buffer
    if I_cooperated_last_round:
        p = 0.75  # Cooperators should mostly continue
    else:
        p = 0.35  # Defectors provide backup in case someone drops

elif COMFORTABLE_SUCCESS:
    # Room to optimize - some can safely defect
    if I_cooperated_last_round:
        p = 0.6  # Some cooperators can rest
    else:
        p = 0.3  # Defectors stay ready as backup

elif UNIVERSAL:
    # Wasteful - collectively we should reduce
    p = m/n  # Return toward efficient ratio
```

**Step 4: Apply historical adjustment**

Calculate `success_rate` = (rounds where threshold met) / (rounds played)

```
if success_rate < 0.5:
    p = min(1.0, p + 0.15)  # Boost cooperation if we're failing too often
elif success_rate > 0.8 and cooperation_ratio > (m+1)/n:
    p = max(0.2, p - 0.1)  # Can afford to optimize if very successful
```

**Step 5: Cooperate with probability p**

---

### Final Round (Round r): Endgame Logic

The last round has no future consequences, changing incentives.

```
c_recent = average cooperators over last min(3, r-1) rounds

if c_recent >= m - 0.5:
    # Pattern suggests threshold likely met
    # Be willing to be part of success
    if c_recent >= m + 1:
        p = (m - 0.5) / n  # Others likely cover it
    else:
        p = 0.7  # Stay committed to not collapse at the end
else:
    # History suggests failure likely
    # Still give it a genuine try
    p = m/n + 0.1
    
Cooperate with probability p
```

---

## Edge Cases

| Situation | Handling |
|-----------|----------|
| **n = m** (all must cooperate) | Always cooperate - no room for free-riding |
| **m = 1** (only one needed) | Cooperate with probability 1/n, boost to 0.5 after failures |
| **k very large** (huge reward) | Increase all cooperation probabilities by factor min(1, k/5) |
| **k barely > 1** (weak incentive) | Reduce probabilities slightly - less costly to fail |
| **r = 2** (minimal rounds) | Skip adaptation, use p = m/n both rounds |
| **Alternating success/failure** | Average over last 3 rounds to smooth response |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return cooperate_with_prob(m / n)
    
    c_prev = count_cooperators(history[-1])
    my_prev_action = my_action(history[-1])
    success_rate = count_successes(history) / (round - 1)
    
    # Base probability from last round outcome
    if c_prev < m:  # FAILURE
        p = min(1.0, (m - c_prev + 1) / n + 0.3)
    elif c_prev == m:  # TIGHT
        p = 0.75 if my_prev_action == C else 0.35
    elif c_prev < n:  # COMFORTABLE
        p = 0.6 if my_prev_action == C else 0.3
    else:  # UNIVERSAL
        p = m / n
    
    # Historical adjustment
    if success_rate < 0.5:
        p = min(1.0, p + 0.15)
    elif success_rate > 0.8 and c_prev > m + 1:
        p = max(0.2, p - 0.1)
    
    # Final round adjustment
    if round == r:
        c_recent = avg_cooperators(history[-3:])
        if c_recent >= m + 1:
            p = (m - 0.5) / n
        elif c_recent >= m - 0.5:
            p = 0.7
        else:
            p = m/n + 0.1
    
    return cooperate_with_prob(p)
```

---

## Why This Strategy is Collectively Robust

1. **Against always-defect opponents**: Boosts cooperation after failures, giving the collective a fighting chance
2. **Against always-cooperate opponents**: Naturally reduces redundant cooperation, improving efficiency
3. **Against mixed strategies**: Adapts toward the cooperation level that achieves threshold
4. **Against copies of itself**: Converges to efficient threshold-meeting behavior through probabilistic coordination
5. **Against exploitative strategies**: Doesn't over-commit; shares risk through probabilistic decisions

The strategy prioritizes collective success (meeting threshold) over individual optimization, while remaining adaptive enough to handle diverse opponent behaviors.
'''

description_COLLECTIVE_35 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to ensure the group reaches the threshold and everyone benefits. The key insight is that in a collective risk dilemma, the worst outcome is failing to meet the threshold—everyone loses the bonus k. My role is to be a reliable cooperator who helps the group succeed while adapting to observed behavior.

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate (C)**

Rationale: With no history, I signal cooperative intent. Since we need m cooperators out of n, I commit to being one of them. This establishes trust and provides information about others' strategies.

### Rounds 2 through (r-1): Adaptive Cooperation

**Primary Rule: Cooperate if cooperation is needed and viable**

```
Let prev_cooperators = number of players who cooperated last round
Let my_prev_action = my action last round

IF threshold was met last round (prev_cooperators >= m):
    # Success state - maintain stability
    IF I cooperated last round:
        Cooperate (stay reliable)
    ELSE:
        # I was a free-rider; check if I'm needed
        IF prev_cooperators == m:
            Cooperate (margin is thin, step up)
        ELSE:
            Cooperate (shift toward collective contribution)

ELSE IF threshold was NOT met (prev_cooperators < m):
    # Failure state - we need more cooperators
    IF prev_cooperators >= m - 2:
        Cooperate (we're close, my contribution could tip us over)
    ELSE IF prev_cooperators < m/2:
        # Severe defection - but don't abandon hope immediately
        IF round <= r/2:
            Cooperate (early game, keep trying to establish norms)
        ELSE:
            # Late game with persistent failure
            Cooperate with probability = prev_cooperators / m
            (Gradually reduce if group shows no collective will)
```

### Final Round (Round r): Conditional Cooperation

```
Let recent_success_rate = proportion of last min(3, r-1) rounds where threshold met

IF recent_success_rate >= 0.5:
    Cooperate (group has shown collective capability)
ELSE IF prev_cooperators >= m - 1:
    Cooperate (one more cooperator could save us)
ELSE:
    Defect (protect individual payoff when collective has failed)
```

## Edge Cases

### Edge Case 1: m is very close to n (e.g., m = n-1)
When nearly everyone must cooperate, I always cooperate in rounds 1 through r-1. The collective cannot succeed without near-universal participation, so I must be part of the solution.

### Edge Case 2: m is very small (e.g., m = 2)
Even with low threshold, I cooperate in early rounds to establish myself as reliable. Once threshold is consistently met with others cooperating, I may defect occasionally—but only if cooperator count exceeds m+1 to maintain buffer.

### Edge Case 3: Exactly m cooperators repeatedly
If we're hitting exactly m cooperators round after round, I always cooperate if I was one of them. The margin is razor-thin and my defection would doom the group.

### Edge Case 4: Very short games (r = 2 or 3)
Cooperate in all rounds. There's insufficient time to learn and adapt, so I commit fully to the collective goal.

## Pseudocode Summary

```python
def decide(round, total_rounds, n, m, k, history):
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[-1])
    threshold_met = prev_cooperators >= m
    
    if round == total_rounds:
        recent_success = success_rate(history[-3:], m)
        if recent_success >= 0.5 or prev_cooperators >= m - 1:
            return COOPERATE
        return DEFECT
    
    # Middle rounds
    if threshold_met:
        return COOPERATE  # Maintain successful collective
    else:
        # Threshold failed - assess viability
        if prev_cooperators >= m - 2:
            return COOPERATE  # Close enough to try
        if round <= total_rounds / 2:
            return COOPERATE  # Early game persistence
        # Late game with persistent failure
        if random() < prev_cooperators / m:
            return COOPERATE
        return DEFECT
```

## Why This Strategy is Collectively Optimal

1. **Reliability**: I'm a dependable cooperator that others can count on
2. **Forgiveness**: I don't punish past defections harshly—I keep trying to build cooperation
3. **Adaptability**: I respond to group behavior while maintaining cooperative bias
4. **Threshold-awareness**: I understand that partial cooperation (below m) helps no one
5. **Late-game realism**: I accept when collective action has truly failed, but give every reasonable chance first
'''

description_COLLECTIVE_36 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume other rational players share the goal of achieving the threshold while minimizing individual cost. The strategy aims to be a "reliable cooperator" that helps the group succeed, while protecting against exploitation and adapting to observed group behavior.

## Strategy Overview

The strategy operates on three principles:
1. **Be willing to cooperate** - The collective only succeeds if enough players contribute
2. **Respond to group behavior** - Adjust based on whether the threshold is being met
3. **Maintain predictability** - Help other cooperative players coordinate implicitly

---

## Decision Rules

### Round 1: Cooperative Start

**Action: COOPERATE**

**Rationale:** With no history, I signal willingness to contribute to the collective good. If all players reason similarly about the need for m cooperators, initial cooperation helps establish a cooperative norm. The downside of being exploited in round 1 is small compared to the benefit of potentially catalyzing group cooperation.

---

### Rounds 2 through (r-1): Adaptive Response

Calculate the following from the previous round:
- `prev_cooperators`: number of players who cooperated last round
- `threshold_met`: whether prev_cooperators ≥ m
- `cooperation_rate`: prev_cooperators / n

**Decision Logic:**

```
IF threshold_met last round:
    IF I cooperated AND prev_cooperators > m:
        # Threshold exceeded - some cooperators could defect
        # Use deterministic rule based on position estimate
        cooperate_probability = m / prev_cooperators
        COOPERATE with probability cooperate_probability
    ELSE:
        # Threshold exactly met or I defected while others carried load
        # Maintain or increase cooperation
        COOPERATE
        
ELSE (threshold NOT met):
    IF prev_cooperators >= m - 1:
        # Close to threshold - my cooperation could tip it
        COOPERATE
    ELSE IF cooperation_rate < 0.3:
        # Group mostly defecting - protect myself but signal willingness
        COOPERATE with probability 0.4
    ELSE:
        # Moderate cooperation but not enough - try to help reach threshold
        COOPERATE
```

**Tracking cooperation history:**
- `my_cooperation_count`: times I've cooperated so far
- `rounds_threshold_met`: rounds where threshold was achieved
- `group_avg_cooperation`: running average of cooperation rate

**Adjustment based on cumulative history:**
```
IF rounds_threshold_met / rounds_played > 0.7:
    # Group is succeeding - maintain current approach
    Follow base logic above
    
ELSE IF my_cooperation_count / rounds_played > 0.8 AND rounds_threshold_met < 0.4:
    # I'm cooperating heavily but group still failing
    # Reduce cooperation slightly to avoid pure exploitation
    Reduce cooperation probability by 0.2 (but never below 0.3)
```

---

### Final Round (Round r): Threshold-Focused

The last round has no future consequences, so pure game theory applies.

```
IF recent cooperation pattern suggests threshold will be met without me:
    # Based on last 3 rounds, estimate likely cooperators
    expected_other_cooperators = (sum of last 3 rounds' cooperators - my contributions) / 3
    
    IF expected_other_cooperators >= m:
        DEFECT  # Free-ride on expected cooperation
    ELSE IF expected_other_cooperators >= m - 1:
        COOPERATE  # I might be pivotal
    ELSE:
        # Threshold unlikely - but cooperate if I've been part of cooperative group
        IF rounds_threshold_met / (r-1) > 0.5:
            COOPERATE  # Maintain collective success
        ELSE:
            DEFECT  # Minimize losses
```

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history, round - 1)
    threshold_met = prev_cooperators >= m
    my_prev_action = my_action(history, round - 1)
    
    # Final round logic
    if round == r:
        expected_others = estimate_other_cooperators(history)
        if expected_others >= m:
            return DEFECT
        elif expected_others >= m - 1:
            return COOPERATE
        elif success_rate(history) > 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    exploitation_check = (my_cooperation_rate(history) > 0.8 and 
                         success_rate(history) < 0.4)
    
    if threshold_met:
        if my_prev_action == COOPERATE and prev_cooperators > m:
            prob = m / prev_cooperators
            if exploitation_check:
                prob *= 0.8
            return COOPERATE with probability prob
        else:
            return COOPERATE
    else:
        if prev_cooperators >= m - 1:
            return COOPERATE
        elif prev_cooperators / n < 0.3:
            prob = 0.4 if not exploitation_check else 0.3
            return COOPERATE with probability prob
        else:
            return COOPERATE
```

---

## Edge Cases Handled

| Scenario | Response |
|----------|----------|
| Round 1 (no history) | Always cooperate |
| Last round | Game-theoretic: cooperate only if pivotal or maintaining success |
| Threshold always met | Gradually allow some defection if excess cooperators |
| Threshold never met | Reduce cooperation but never fully abandon (minimum 30%) |
| Exactly m cooperators | Maintain cooperation to not break the threshold |
| Being exploited | Detect via high personal cooperation + low threshold success; reduce slightly |

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperative** - Gives the group the best chance to establish mutual cooperation
2. **Maintains threshold** - Prioritizes keeping the group above m cooperators
3. **Doesn't over-exploit** - Even when defecting is "safe," maintains some cooperation
4. **Adapts to group** - Responds to actual behavior rather than assuming worst case
5. **Shares the burden** - When threshold is exceeded, probabilistically rotates who defects

This strategy aims to be a reliable partner that other cooperative strategies can implicitly coordinate with, while not being a pushover for purely selfish opponents.
'''

description_COLLECTIVE_37 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of a reliable coalition that consistently meets the threshold. The key insight is that **being a dependable cooperator when cooperation is needed creates more collective value than opportunistic defection**. However, I must also be adaptive to the actual behavior of others and protect against exploitation.

## Strategy Overview

I will position myself as a "threshold guardian" - someone who cooperates to help reach the critical mass m, but adapts based on whether the collective is functioning. The strategy balances three principles:

1. **Be reliably cooperative** to help establish and maintain threshold achievement
2. **Respond to collective failure** by reducing cooperation if others consistently defect
3. **Protect end-game cooperation** against unraveling

---

## Decision Rules

### Round 1: Cooperative Start
**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent. This helps establish whether a viable coalition exists. The potential reward k > 1 makes cooperation valuable if threshold is met.

### Rounds 2 through (r-2): Adaptive Phase

Calculate two key metrics from history:
- **Cooperation Rate**: Average number of cooperators across all previous rounds
- **Threshold Success Rate**: Proportion of previous rounds where m or more cooperated

**Decision Logic:**

```
IF threshold was met in the previous round:
    IF I cooperated last round:
        COOPERATE (stay in the working coalition)
    ELSE IF (number of cooperators last round) > m:
        COOPERATE (there's room in the coalition, join it)
    ELSE:
        DEFECT (coalition is exactly at m, don't disrupt what works)

ELSE IF threshold was NOT met in the previous round:
    IF Threshold Success Rate ≥ 0.5:
        COOPERATE (coalition usually works, last round was an anomaly)
    ELSE IF Cooperation Rate ≥ (m - 1):
        COOPERATE (we're close to threshold, my cooperation might tip it)
    ELSE:
        DEFECT (collective is failing, protect myself)
```

### Round (r-1): Penultimate Round
**Action: COOPERATE if Threshold Success Rate ≥ 0.4, else DEFECT**

Rationale: Maintain cooperation slightly longer than a purely rational actor might, to support collective success. But if the collective has clearly failed (less than 40% success), don't throw away resources.

### Final Round r: Conditional Cooperation
**Action: COOPERATE if Threshold Success Rate ≥ 0.6, else DEFECT**

Rationale: In a collective mindset, I don't automatically defect on the last round. If we've built a functioning coalition, I honor it. However, I require stronger evidence of collective success (60% threshold) since there's no future interaction to consider.

---

## Edge Cases

### Very Small Games (n ≤ 3)
When n is small, each player's action is highly consequential:
- If m = n - 1 or m = n: Always COOPERATE (threshold requires near-unanimity)
- Otherwise: Follow standard rules but weight toward cooperation

### High Threshold Requirements (m > n/2)
When majority cooperation is needed:
- Be more forgiving of occasional failures (use 0.3 instead of 0.5 for success rate thresholds)
- Cooperate more readily to help reach the high bar

### Low Threshold Requirements (m ≤ n/3)
When few cooperators are needed:
- After threshold is met twice consecutively with excess cooperators, consider DEFECT
- Re-COOPERATE immediately if threshold fails

### Short Games (r ≤ 5)
- Skip the "adaptive phase" logic
- Default to COOPERATE unless threshold has failed in >50% of completed rounds

---

## Pseudocode Summary

```
function decide(round, history, n, m, r, k):
    
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    threshold_successes = count(rounds where cooperators >= m)
    success_rate = threshold_successes / (round - 1)
    avg_cooperators = mean(cooperators per round)
    last_round_cooperators = history[round-1].total_cooperators
    i_cooperated_last = history[round-1].my_action == COOPERATE
    threshold_met_last = last_round_cooperators >= m
    
    # Final round
    if round == r:
        return COOPERATE if success_rate >= 0.6 else DEFECT
    
    # Penultimate round
    if round == r - 1:
        return COOPERATE if success_rate >= 0.4 else DEFECT
    
    # Adaptive phase (rounds 2 to r-2)
    if threshold_met_last:
        if i_cooperated_last:
            return COOPERATE
        else if last_round_cooperators > m:
            return COOPERATE
        else:
            return DEFECT
    else:  # threshold not met last round
        if success_rate >= 0.5:
            return COOPERATE
        else if avg_cooperators >= (m - 1):
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Coalition Building**: By defaulting to cooperation and staying in working coalitions, I help create the stable core needed for threshold achievement.

2. **Not Exploitable**: If the collective consistently fails, I reduce cooperation rather than being a perpetual sucker.

3. **Forgiveness**: One bad round doesn't trigger permanent defection - I give the collective chances to recover.

4. **End-Game Integrity**: Unlike purely self-interested strategies, I maintain cooperation through the final rounds if the collective has been successful, maximizing long-term group payoff.

5. **Parameter Adaptive**: The strategy scales naturally with different values of n, m, r, and k without requiring specific coordination mechanisms.
'''

description_COLLECTIVE_38 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to help ensure the group reaches the threshold. The key insight is that the collective benefit (everyone getting +k) far outweighs the individual cost of contributing (losing 1). A group of players using this strategy should naturally coordinate to meet—but not vastly exceed—the threshold.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic self-selection**: Use deterministic role assignment based on player index and round to spread cooperation duty
2. **Reactive adjustment**: Increase cooperation probability when the group is failing; decrease when over-contributing
3. **End-game commitment**: Maintain cooperation incentives even in final rounds

---

## Decision Rules

### Round 1 (No History)

Since we need exactly m cooperators out of n players, each player should cooperate with probability that gives expected cooperators ≈ m, with a safety margin.

```
base_probability = (m + 0.5) / n  # Slight buffer above minimum
cooperate if hash(player_id, round=1) mod 1000 < base_probability * 1000
```

The hash creates deterministic pseudo-randomness—if all players use this strategy, we get consistent role distribution.

### Rounds 2 through r-1 (Adaptive Phase)

**Step 1: Assess recent history**
```
Look at last min(3, rounds_played) rounds
shortfall = count of rounds where cooperators < m
excess = count of rounds where cooperators > m + 1
cooperation_rate = (total cooperations by others) / (total opportunities)
```

**Step 2: Calculate adjusted cooperation probability**
```
adjustment = 0

# React to threshold failures (strong upward pressure)
if shortfall > 0:
    adjustment += 0.15 * shortfall

# React to over-cooperation (mild downward pressure)
if excess > 0 and shortfall == 0:
    adjustment -= 0.05 * excess

# Consider my own recent behavior (burden sharing)
my_recent_coops = my cooperations in last 3 rounds
if my_recent_coops >= 2 and cooperation_rate > m/n:
    adjustment -= 0.1  # I've done my part recently
elif my_recent_coops == 0 and cooperation_rate < m/n:
    adjustment += 0.15  # I should step up

adjusted_probability = base_probability + adjustment
adjusted_probability = clamp(adjusted_probability, 0.1, 0.95)
```

**Step 3: Make decision**
```
cooperate if hash(player_id, current_round) mod 1000 < adjusted_probability * 1000
```

### Final Round (Round r)

The final round has no future shadow, creating defection temptation. However, a collectively-minded player recognizes:
- If I defect and we fall below threshold, everyone loses k (including me, net loss of k-1)
- The group benefit of meeting threshold vastly exceeds my individual gain from defecting

```
# Calculate how critical my cooperation likely is
expected_other_coops = (n-1) * cooperation_rate_from_history

if expected_other_coops < m:
    # Group is struggling - definitely cooperate
    cooperate
elif expected_other_coops < m + 1:
    # Borderline - cooperate with high probability
    cooperate with probability 0.8
else:
    # Group likely covered - use base probability
    cooperate with probability base_probability
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| **m = n-1 or m = n** | Always cooperate (threshold requires near-universal cooperation) |
| **m ≤ 2** | Use lower base probability; more reactive to history |
| **r = 2** | Treat round 2 as final round |
| **All previous rounds failed** | Cooperate with probability 0.9 (emergency mode) |
| **All previous rounds succeeded with excess** | Reduce to base_probability - 0.1 |
| **I'm player index i where i ≤ m** | Slight bias toward cooperation (+0.05) to create stable "core" |

---

## Pseudocode Summary

```python
def decide(player_id, round, n, m, k, r, history):
    base_prob = (m + 0.5) / n
    
    if round == 1:
        return deterministic_random(player_id, round) < base_prob
    
    # Analyze history
    recent = history[max(0, round-4):round]
    shortfall = sum(1 for rd in recent if rd.cooperators < m)
    excess = sum(1 for rd in recent if rd.cooperators > m + 1)
    coop_rate = total_cooperations(recent) / (len(recent) * (n-1))
    my_recent = my_cooperations(recent)
    
    # Adjust probability
    adj = 0.15 * shortfall - 0.05 * excess * (shortfall == 0)
    if my_recent >= 2 and coop_rate > m/n: adj -= 0.1
    if my_recent == 0 and coop_rate < m/n: adj += 0.15
    
    prob = clamp(base_prob + adj, 0.1, 0.95)
    
    # Final round logic
    if round == r:
        expected_others = (n-1) * coop_rate
        if expected_others < m: return True
        if expected_others < m + 1: prob = 0.8
    
    return deterministic_random(player_id, round) < prob
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: Players using this strategy will naturally distribute cooperation duty across rounds and players
2. **Adaptive**: Responds to both under-cooperation (emergency cooperation) and over-cooperation (efficient burden-sharing)
3. **Resilient to defectors**: If others defect more, cooperators increase their rate to compensate
4. **Not exploitable to collapse**: Maintains minimum 10% cooperation floor, preventing complete breakdown
5. **Handles mixed populations**: Works whether paired with other collective strategies, selfish strategies, or random players
'''

description_COLLECTIVE_39 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I act as if I'm one of m coordinated cooperators trying to ensure the threshold is met, while adapting to observed behavior. The key insight is that exactly m cooperators is optimal for the group (threshold met, minimal sacrifice), but achieving this without communication requires probabilistic coordination based on shared information (the history).

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to historical cooperation rates, with the goal of having exactly m cooperators emerge in expectation. I become more predictable and cooperative when cooperation is fragile, and more strategic when others are reliably contributing.

---

## Decision Rules

### Round 1: Baseline Cooperation Probability

With no history, I cooperate with probability:

```
P(cooperate) = m / n
```

This is the fair share probability—if all n players independently cooperate with probability m/n, expected cooperators equals m. This creates a Schelling point without communication.

---

### Rounds 2 through r-1: Adaptive Cooperation

**Step 1: Calculate historical cooperation rate**
```
avg_cooperators = (total cooperations across all players in previous rounds) / (rounds played)
cooperation_rate = avg_cooperators / n
```

**Step 2: Assess threshold reliability**
```
rounds_threshold_met = count of rounds where cooperators ≥ m
reliability = rounds_threshold_met / rounds_played
```

**Step 3: Determine cooperation probability**

```
target_cooperators = m  # We want exactly the threshold

if avg_cooperators < m:
    # Cooperation deficit - increase my contribution
    deficit = m - avg_cooperators
    boost = deficit / (n - avg_cooperators)  # My share of filling the gap
    P(cooperate) = min(1.0, (m/n) + boost)
    
elif avg_cooperators > m + 1:
    # Cooperation surplus - I can safely reduce
    surplus = avg_cooperators - m
    reduction = surplus / avg_cooperators  # Proportional reduction
    P(cooperate) = max(0.1, (m/n) - reduction * 0.5)
    
else:
    # Near threshold - maintain baseline with reliability adjustment
    if reliability < 0.7:
        # Threshold often missed - be more cooperative
        P(cooperate) = min(1.0, (m/n) * 1.3)
    else:
        P(cooperate) = m / n
```

**Step 4: Consistency adjustment**

To enable implicit coordination, I add deterministic elements based on my player index:

```
# Create stable "shifts" so players naturally distribute
round_offset = (current_round + my_player_index) mod n
if round_offset < m:
    P(cooperate) = P(cooperate) * 1.2  # Slightly more likely this round
else:
    P(cooperate) = P(cooperate) * 0.9  # Slightly less likely

P(cooperate) = clamp(P(cooperate), 0.05, 0.95)
```

---

### Final Round (Round r): Commitment to Collective Success

The last round has no future shadow, making defection tempting. I counteract this:

```
if reliability >= 0.5:
    # Group has been reasonably cooperative - maintain trust
    P(cooperate) = m / n  # Fair share
else:
    # Group has struggled - make final push for collective success
    P(cooperate) = min(1.0, m / max(1, avg_cooperators_last_3_rounds))
```

---

## Edge Cases

| Scenario | Response |
|----------|----------|
| **n = m** (all must cooperate) | P(cooperate) = 0.95 always - near certainty needed |
| **m = n-1** (only one can defect) | Cooperate deterministically unless reliability > 0.9 |
| **Very high k (k > 3)** | Increase all probabilities by factor of 1 + (k-1)/10 |
| **Short game (r ≤ 3)** | Weight toward higher cooperation (less time to learn) |
| **Threshold never met** | After r/2 rounds of failure, cooperate with P = 0.9 as emergency measure |

---

## Pseudocode Summary

```python
def decide(round, history, my_index, n, m, r, k):
    if round == 1:
        return random() < (m / n)
    
    avg_coop = mean([sum(actions) for actions in history])
    reliability = mean([1 if sum(a) >= m else 0 for a in history])
    
    # Base probability
    p = m / n
    
    # Adjust for cooperation level
    if avg_coop < m:
        p += (m - avg_coop) / (n - avg_coop + 0.1)
    elif avg_coop > m + 1:
        p -= (avg_coop - m) / (2 * avg_coop)
    
    # Reliability adjustment
    if reliability < 0.7:
        p *= 1.3
    
    # Index-based coordination
    if (round + my_index) % n < m:
        p *= 1.2
    else:
        p *= 0.9
    
    # Final round commitment
    if round == r and reliability < 0.5:
        p = min(1.0, m / max(1, avg_coop))
    
    return random() < clamp(p, 0.05, 0.95)
```

---

## Why This Strategy is Collectively Minded

1. **Fair share baseline**: Starting at m/n means I'm willing to do my proportional part
2. **Gap-filling**: I increase contribution when cooperation is lacking
3. **Not exploitative**: I never drop below 5% or fully free-ride
4. **Stabilizing**: The index-based offset helps create implicit turn-taking
5. **Endgame integrity**: I don't defect in the final round just because I can
'''

description_COLLECTIVE_40 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to help ensure the group reaches the threshold. The key insight is that in a collective risk dilemma, the worst outcome is failing to reach threshold m when we could have succeeded. I aim to be a reliable cooperator who helps the group succeed, while adapting to observed behavior to avoid being exploited in hopeless situations.

## Strategy Overview

I position myself as a **conditional guardian** of collective success. I start cooperative and remain cooperative as long as there's reasonable hope of reaching the threshold. I only retreat to defection when evidence strongly suggests the group cannot or will not coordinate.

---

## Decision Rules

### Round 1: Cooperative Start
**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent. If enough players share this mindset, we establish a cooperative norm immediately. The collective benefit (k > 1) makes cooperation valuable when the threshold is met.

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate two key metrics from the previous round:
- `cooperators_last`: Number of players who cooperated last round
- `threshold_gap`: m - cooperators_last

**Decision Logic:**

```
IF threshold was met last round (cooperators_last >= m):
    # Success regime - maintain cooperation
    IF I cooperated last round:
        COOPERATE (continue contributing to success)
    ELSE:
        # I defected while others carried the load
        # Probability of cooperating = min(1, m / cooperators_last)
        # This gradually shifts burden-sharing
        COOPERATE with probability m / cooperators_last

ELSE IF threshold_gap <= (n - m) / 2:
    # Near-miss regime - we were close, worth trying again
    COOPERATE
    
ELSE IF cooperators_last >= m - 1 AND I defected last round:
    # I could have made the difference - cooperate now
    COOPERATE

ELSE IF round_number <= r/2:
    # Early game with poor cooperation - give more chances
    COOPERATE with probability (m / n)

ELSE:
    # Late game with persistent failure - strategic retreat
    # But still cooperate with base probability to allow recovery
    COOPERATE with probability max(0.2, cooperators_last / m)
```

### Final Round (Round r): Threshold-Focused Decision

```
IF average cooperation rate over all rounds >= m/n:
    COOPERATE (group has shown coordination capacity)
ELSE IF cooperators in round (r-1) >= m - 1:
    COOPERATE (threshold is achievable)
ELSE IF cooperators in round (r-1) >= m/2:
    COOPERATE with probability 0.5
ELSE:
    DEFECT (collective action has failed)
```

---

## Edge Case Handling

### Two-Player Game (n = 2, m = 2)
Both must cooperate for threshold. Strategy simplifies to:
- Round 1: COOPERATE
- Subsequent rounds: Mirror opponent's last action (Tit-for-Tat)
- This is optimal for bilateral cooperation problems

### Threshold = n-1 or n (nearly everyone must cooperate)
- Be more forgiving of occasional defections
- COOPERATE unless defection rate exceeds 1 - (m/n) for 2+ consecutive rounds

### Threshold is low (m << n)
- More willing to defect if threshold consistently met without me
- After 3 consecutive rounds where threshold met and I cooperated: 
  - Defect once to "take a turn" benefiting
  - Return to cooperation immediately after

### Very Short Games (r ≤ 3)
- Cooperate in all rounds unless round 1 shows fewer than m/2 cooperators
- Not enough time for complex adaptation

### Very Long Games (r > 20)
- Use rolling window of last 5 rounds for adaptation decisions
- Older history less relevant for current group composition behavior

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    
    if round_num == 1:
        return COOPERATE
    
    last_round_coops = count_cooperators(history[-1])
    my_last_action = my_action(history[-1])
    threshold_met = last_round_coops >= m
    
    # Final round logic
    if round_num == total_rounds:
        avg_coop_rate = average_cooperation_rate(history)
        if avg_coop_rate >= m/n or last_round_coops >= m-1:
            return COOPERATE
        elif last_round_coops >= m/2:
            return COOPERATE with probability 0.5
        else:
            return DEFECT
    
    # Standard rounds
    if threshold_met:
        if my_last_action == COOPERATE:
            return COOPERATE
        else:
            return COOPERATE with probability min(1, m/last_round_coops)
    
    elif last_round_coops >= m - 1:
        return COOPERATE
    
    elif round_num <= total_rounds / 2:
        return COOPERATE with probability m/n
    
    else:
        return COOPERATE with probability max(0.2, last_round_coops/m)
```

---

## Why This Strategy is Collectively Optimal

1. **Reliable cooperator**: I contribute to reaching threshold rather than free-riding
2. **Forgiveness**: I don't permanently punish defection—groups can recover
3. **Burden-sharing awareness**: When threshold is met, I encourage rotation rather than exploitation
4. **Threshold-focused**: Every decision asks "does this help us reach m?"
5. **Robust to defectors**: Gradual retreat prevents complete exploitation while leaving door open for coordination
6. **No complex coordination required**: Works independently without needing others to follow the same strategy
'''

description_COLLECTIVE_41 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I cooperate because the group needs cooperators, and I am part of the group.** The strategy aims to be one of the reliable cooperators that makes collective success possible, while adapting to observed behavior to avoid being perpetually exploited.

## Strategic Framework

### Key Insight

The collective succeeds when exactly m or more players cooperate. The tragedy occurs when everyone reasons "someone else will cooperate" and the threshold isn't met. My strategy assumes responsibility for being part of the solution, adjusting only when evidence strongly suggests the collective is either secure or hopeless.

---

## Decision Rules

### Round 1: Unconditional Cooperation

**Action: COOPERATE**

**Rationale:** 
- No information exists about others' behavior
- Someone must be willing to cooperate first
- Cooperating signals collective intent and helps establish norms
- The group needs m cooperators; I commit to being one of them

---

### Rounds 2 through (r-1): Adaptive Cooperation

**Calculate three key metrics from the previous round:**

1. **Cooperator Count (prev_coop):** Number of players who cooperated last round
2. **Threshold Margin:** `prev_coop - m`
3. **My Cooperation History Rate:** Fraction of rounds I've cooperated so far

**Decision Logic:**

```
IF prev_coop < m THEN:
    # Threshold failed - collective needs more cooperators
    ACTION = COOPERATE
    
ELSE IF prev_coop == m THEN:
    # Exactly at threshold - I should help maintain it
    IF I cooperated last round THEN:
        ACTION = COOPERATE  # Don't destabilize a fragile success
    ELSE:
        ACTION = COOPERATE  # Try to provide safety margin
        
ELSE IF prev_coop > m AND prev_coop <= m + floor((n-m)/2) THEN:
    # Modest surplus - healthy cooperation level
    IF I cooperated last round THEN:
        # Consider giving others a chance to contribute
        IF my_cooperation_rate > (m/n) + 0.1 THEN:
            ACTION = DEFECT  # Brief rest, let others share burden
        ELSE:
            ACTION = COOPERATE
    ELSE:
        ACTION = COOPERATE  # Return to cooperation
        
ELSE IF prev_coop > m + floor((n-m)/2) THEN:
    # Large surplus - can safely defect once
    IF I cooperated last round THEN:
        ACTION = DEFECT  # Take a turn keeping endowment
    ELSE:
        ACTION = COOPERATE  # Return to cooperation after one defection
```

**Additional Adaptation - Trend Detection:**

```
IF last 3 rounds all had prev_coop >= m THEN:
    # Stable success - maintain but allow some flexibility
    Apply above logic normally
    
ELSE IF last 2 rounds had prev_coop < m THEN:
    # Crisis mode - collective is failing
    ACTION = COOPERATE  # Unconditionally help
```

---

### Final Round (Round r): Conditional Cooperation

**Rationale:** No future rounds exist to punish defection, but collective success still matters.

```
IF cooperation has been generally successful (≥70% of rounds met threshold) THEN:
    # Good collective - maintain cooperation for final success
    ACTION = COOPERATE
    
ELSE IF prev_coop >= m - 1 THEN:
    # Close to threshold - my cooperation might be pivotal
    ACTION = COOPERATE
    
ELSE IF prev_coop < m - 2 THEN:
    # Collective has consistently failed despite my efforts
    ACTION = DEFECT  # Salvage personal payoff from failed game
    
ELSE:
    ACTION = COOPERATE  # Give it one last try
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| **m = n-1 or m = n** | Always COOPERATE | Near-universal cooperation needed; can't risk being the defector who breaks it |
| **m = 2 (very low threshold)** | Follow standard rules but defect more readily when surplus is large | Success is easy to maintain |
| **r = 2 (minimal rounds)** | COOPERATE both rounds | Too little information to adapt; commit to collective |
| **All others defected last round** | COOPERATE | Threshold failure means more cooperation needed, not less |
| **All others cooperated last round** | DEFECT once, then return | Large surplus allows safe free-riding briefly |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    
    if round_num == 1:
        return COOPERATE
    
    prev_coop = count_cooperators(history, round_num - 1)
    my_coop_rate = my_cooperation_rate(history, round_num - 1)
    i_cooperated_last = did_i_cooperate(history, round_num - 1)
    threshold_margin = prev_coop - m
    surplus_threshold = floor((n - m) / 2)
    
    # Final round logic
    if round_num == total_rounds:
        success_rate = rounds_threshold_met(history) / (round_num - 1)
        if success_rate >= 0.7 or prev_coop >= m - 1:
            return COOPERATE
        elif prev_coop < m - 2:
            return DEFECT
        else:
            return COOPERATE
    
    # Crisis mode: recent failures
    if round_num >= 3:
        if cooperators(history, round_num-1) < m and cooperators(history, round_num-2) < m:
            return COOPERATE
    
    # Standard adaptive logic
    if threshold_margin < 0:
        return COOPERATE
    elif threshold_margin == 0:
        return COOPERATE
    elif threshold_margin <= surplus_threshold:
        if i_cooperated_last and my_coop_rate > (m/n) + 0.1:
            return DEFECT
        else:
            return COOPERATE
    else:  # Large surplus
        if i_cooperated_last:
            return DEFECT
        else:
            return COOPERATE
```

---

## Why This Strategy is Collectively Aligned

1. **Default stance is cooperation** - I contribute unless there's clear reason the collective is secure
2. **Responds to failure with more cooperation** - Unlike retaliatory strategies, I help more when the group struggles
3. **Shares the burden** - Only defects briefly when surplus exists, creating space for others to contribute
4. **Maintains stability** - Never defects when at exactly threshold; doesn't destabilize fragile successes
5. **Forgives immediately** - One bad round doesn't trigger sustained punishment
6. **Prioritizes collective outcome** - Personal payoff optimization is secondary to threshold achievement
'''

description_COLLECTIVE_42 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I cooperate when my cooperation is likely needed to reach the threshold, and I defect only when the threshold appears secure without me or when cooperation would be futile.** The goal is to maximize collective success (threshold met) while avoiding wasteful over-contribution.

## Strategy Overview

The strategy operates on three principles:
1. **Be a reliable cooperator early** to establish cooperative norms
2. **Adapt based on observed cooperation levels** relative to the threshold
3. **Maintain cooperation commitment** even late in the game to avoid collective collapse

---

## Decision Rules

### Round 1: Cooperative Opening

**Action: COOPERATE**

Rationale: With no history, I signal willingness to contribute. Since exactly m cooperators are needed and I cannot coordinate, I assume others may think similarly. Starting cooperative establishes trust and provides information.

---

### Rounds 2 through r-1: Adaptive Middle Game

Calculate from the previous round:
- `cooperators_last` = number of players who cooperated
- `cooperation_rate` = cooperators_last / n
- `threshold_ratio` = m / n

**Decision Logic:**

```
IF cooperators_last < m THEN
    // Threshold was NOT met last round
    IF cooperators_last >= m - 1 THEN
        // Close to threshold - my cooperation could tip it
        ACTION = COOPERATE
    ELSE IF cooperators_last <= m / 2 THEN
        // Cooperation collapsed - attempt to restart
        // Cooperate with probability based on how critical cooperation is
        ACTION = COOPERATE with probability = m / n
    ELSE
        // Moderate failure - cooperate to help rebuild
        ACTION = COOPERATE

ELSE IF cooperators_last == m THEN
    // Exactly at threshold - fragile equilibrium
    IF I cooperated last round THEN
        ACTION = COOPERATE  // Don't be the one to break it
    ELSE
        ACTION = COOPERATE with probability = 0.5
        // Some defectors should step up for stability

ELSE IF cooperators_last > m AND cooperators_last <= m + (n-m)/2 THEN
    // Threshold met with small buffer - maintain stability
    IF I cooperated last round THEN
        ACTION = COOPERATE  // Stay reliable
    ELSE
        ACTION = DEFECT  // Threshold is secure

ELSE  // cooperators_last > m + (n-m)/2
    // Excess cooperation - some can safely defect
    IF I cooperated last round THEN
        // Rotate out probabilistically to share burden
        ACTION = DEFECT with probability = (cooperators_last - m) / (2 * n)
    ELSE
        ACTION = DEFECT  // Threshold well-secured
```

---

### Final Round (Round r): Commitment to Collective

**Do NOT defect simply because it's the last round.**

Apply the same adaptive logic as middle rounds, but with a **cooperation bias**:
- If the threshold was met in the previous round, maintain my previous action
- If the threshold was NOT met, COOPERATE regardless of other factors

Rationale: Mass defection in the final round (anticipating others will defect) creates a self-fulfilling prophecy that hurts everyone. By maintaining cooperation commitment, I maximize the chance the collective succeeds.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2, m = 2 | Always COOPERATE | Both must cooperate; defection guarantees failure |
| m = n - 1 | COOPERATE | Nearly everyone needed; be reliable |
| k is very large | Bias toward COOPERATE | High reward justifies contribution |
| All others defected last round | COOPERATE with prob m/n | Signal willingness, but don't waste resources alone |
| I'm in a stable cooperative pattern | Maintain COOPERATE | Don't destabilize success |

---

## Pseudocode Summary

```python
def decide(round, total_rounds, my_last_action, cooperators_last, n, m, k):
    
    if round == 1:
        return COOPERATE
    
    threshold_met = (cooperators_last >= m)
    
    # Final round: don't betray the collective
    if round == total_rounds:
        if not threshold_met:
            return COOPERATE
        else:
            return my_last_action  # Maintain stability
    
    # Middle rounds: adaptive response
    if not threshold_met:
        if cooperators_last >= m - 1:
            return COOPERATE  # One more could tip it
        else:
            return COOPERATE with probability (m / n)
    
    elif cooperators_last == m:
        if my_last_action == COOPERATE:
            return COOPERATE
        else:
            return COOPERATE with probability 0.5
    
    elif cooperators_last <= m + (n - m) / 2:
        return my_last_action  # Maintain what worked
    
    else:  # Excess cooperation
        if my_last_action == COOPERATE:
            return DEFECT with probability (cooperators_last - m) / (2 * n)
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Establishes cooperation**: Opens cooperatively and maintains it when needed
2. **Avoids exploitation**: Reduces cooperation when threshold is safely exceeded
3. **Recovers from failure**: Probabilistically re-engages after collapse
4. **Resists end-game collapse**: Maintains principles in final round
5. **Burden sharing**: Allows rotation when excess cooperators exist
6. **Threshold-aware**: All decisions reference whether m is being met
'''

description_COLLECTIVE_43 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the minimum viable coalition needed to secure the collective reward, while adapting to observed behavior patterns. The goal is to ensure the threshold is met when possible, without being exploited by free-riders, and to use strategic defection to signal and encourage broader cooperation.

---

## Decision Rules

### Round 1: Probabilistic Cooperation Based on Position

Since there's no history, I cooperate with probability based on the threshold ratio:

```
P(Cooperate in Round 1) = m / n + small_buffer
where small_buffer = 0.1
```

**Rationale:** If everyone follows this logic, we expect slightly more than m cooperators on average, providing a safety margin while not over-contributing.

---

### Rounds 2 through (r-1): Adaptive Response

After observing the previous round, I classify the game state and respond:

**Step 1: Count previous round cooperators (call it `c_prev`)**

**Step 2: Determine my action based on cooperation level:**

```
IF c_prev < m (threshold was NOT met):
    # Collective failure - we need more cooperation
    IF I defected last round:
        Cooperate this round (I should contribute to recovery)
    ELSE IF I cooperated last round:
        Cooperate again with probability 0.8
        (Stay committed but allow some strategic withdrawal to signal others must help)

ELSE IF c_prev == m (exactly at threshold):
    # Precarious success - maintain stability
    IF I cooperated last round:
        Continue cooperating (don't destabilize)
    ELSE:
        Cooperate with probability (m - count_of_consistent_cooperators) / (n - m)
        # Fill gaps if reliable cooperators are insufficient

ELSE IF c_prev > m (surplus cooperation):
    # Success with room for efficiency
    IF I cooperated last round AND c_prev > m + 1:
        Defect with probability 0.3 (test if others maintain threshold)
    ELSE:
        Maintain previous action
```

**Step 3: Reputation tracking adjustment**

```
FOR each player j, track cooperation_rate[j] = (times j cooperated) / (rounds played)

IF cooperation_rate for majority of others < 0.3 AND round > r/3:
    # Hostile environment - protect self but attempt periodic coordination
    Cooperate only every 3rd round (signaling willingness)
    
IF cooperation_rate for at least m-1 others > 0.6:
    # Cooperative environment exists
    Cooperate consistently to be part of the reliable coalition
```

---

### Final Round (Round r): Strategic Endgame

The last round has no future consequences, changing incentives:

```
IF historical success rate (threshold met) > 0.5:
    # Cooperation has been working - maintain it
    Cooperate if I was part of the cooperating coalition
    
ELSE IF there are exactly (m-1) players with cooperation_rate > 0.7:
    # I could be the decisive cooperator
    Cooperate (securing the collective reward is worth it)
    
ELSE:
    # Cooperation has failed repeatedly or threshold seems unreachable
    Defect (minimize personal loss)
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| **m = n-1** (nearly everyone needed) | Cooperate consistently; defection likely causes failure |
| **m = 2** (low threshold) | More willing to defect early; let reliable pair emerge |
| **k is very large** | Weight toward cooperation; collective reward dominates |
| **k barely exceeds 1** | More selective cooperation; free-riding less costly to tolerate |
| **r = 2** (minimal rounds) | Round 1: Cooperate with P = m/n + 0.15; Round 2: Mirror majority from Round 1 |
| **All previous rounds failed** | Cooperate deterministically for 2 consecutive rounds as "reset signal" |

---

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return "C" if random() < (m/n + 0.1) else "D"
    
    c_prev = count_cooperators(history, round - 1)
    my_prev = my_action(history, round - 1)
    coop_rates = [cooperation_rate(player, history) for player in all_players]
    
    # Final round logic
    if round == r:
        if success_rate(history) > 0.5 and my_prev == "C":
            return "C"
        if count(rate > 0.7 for rate in coop_rates) >= m - 1:
            return "C"
        return "D"
    
    # Hostile environment check
    if round > r/3 and median(coop_rates) < 0.3:
        return "C" if round % 3 == 0 else "D"
    
    # Cooperative environment - join reliable coalition
    if count(rate > 0.6 for rate in coop_rates) >= m - 1:
        return "C"
    
    # Adaptive response to previous outcome
    if c_prev < m:
        if my_prev == "D":
            return "C"
        return "C" if random() < 0.8 else "D"
    
    if c_prev == m:
        return my_prev  # Don't destabilize
    
    if c_prev > m + 1 and my_prev == "C":
        return "D" if random() < 0.3 else "C"
    
    return my_prev
```

---

## Why This Strategy is Collectively-Minded

1. **Threshold-focused**: I aim to be part of exactly the needed coalition, not maximizing personal gain at collective expense
2. **Responsive to failure**: When the group fails, I step up rather than abandon
3. **Allows efficiency**: When there's surplus cooperation, I may step back to let the system find equilibrium
4. **Signals and adapts**: Periodic cooperation in hostile environments maintains possibility of coordination
5. **Protects the coalition**: In the final round, I honor cooperative relationships rather than defecting opportunistically
'''

description_COLLECTIVE_44 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of a reliable coalition that consistently meets the cooperation threshold. The key insight is that exactly m cooperators is the most efficient outcome for the group—it secures the reward while minimizing total contribution costs. I should strive to be one of those m cooperators when needed, but avoid redundant cooperation that wastes resources.

## Strategy Overview

I use a reputation-based system to identify reliable cooperators and coordinate implicitly. My goal is to form a stable coalition of m players who consistently cooperate, while adapting to the actual behavior patterns I observe.

---

## Decision Rules

### Round 1: Probabilistic Seeding

With no history, I cooperate with probability `m/n`.

**Rationale:** If all players use this probability, the expected number of cooperators equals m—exactly the threshold. This creates a fair, symmetric starting point that signals willingness to cooperate without over-committing.

### Rounds 2 through (r-1): Adaptive Coalition Formation

**Step 1: Calculate Cooperation Scores**

For each player j (including myself), compute:
```
cooperation_rate[j] = (times j cooperated) / (rounds played so far)
```

**Step 2: Rank Players by Reliability**

Sort all n players by their cooperation_rate in descending order. Ties are broken by player index (lower index = higher priority for determinism).

**Step 3: Determine My Role**

```
my_rank = my position in the sorted reliability ranking (1 = most cooperative)

if my_rank <= m:
    # I'm among the top m most reliable cooperators
    COOPERATE
else:
    # I'm outside the core coalition
    if (number of players with cooperation_rate >= 0.5) < m:
        # Not enough reliable cooperators exist - help fill the gap
        COOPERATE with probability = (m - reliable_count) / (n - reliable_count)
    else:
        DEFECT
```

**Step 4: Adaptive Correction**

After each round, if the threshold was NOT met in the previous round:
```
if threshold_missed_last_round AND I defected:
    # Increase my willingness to cooperate
    cooperation_boost = 0.2
    # Apply boost to my next cooperation probability if I'm in the probabilistic zone
```

If the threshold was met with significant excess (cooperators > m + 1) in the previous round:
```
if I cooperated AND cooperator_count > m + 1:
    # Coalition is oversized - I may step back if others are more committed
    if my_rank == m or my_rank == m+1:
        # I'm on the margin - slight chance to defect to test if others maintain
        DEFECT with probability 0.1
```

### Final Round (Round r): Threshold-Focused Decision

The last round has no future consequences, so pure self-interest dominates. However, maintaining collective success still matters for total payoff:

```
# Estimate how many others will cooperate based on their historical rates
expected_cooperators_without_me = sum(cooperation_rate[j] for j ≠ me)

if expected_cooperators_without_me >= m:
    # Threshold likely met without me
    DEFECT
elif expected_cooperators_without_me >= m - 1:
    # I might be pivotal
    COOPERATE with probability 0.7
else:
    # Threshold unlikely even with my cooperation
    # Still cooperate with some probability to not abandon coalition
    COOPERATE with probability m / n
```

---

## Edge Case Handling

| Situation | Action |
|-----------|--------|
| **n = m** (everyone must cooperate) | Always cooperate—no free-riding possible |
| **m = 1** (single cooperator sufficient) | Cooperate in round 1 with prob 1/n; thereafter, cooperate only if no one else has been reliable |
| **All players defected last round** | Cooperate with probability m/n (reset to initial seeding) |
| **I'm the only cooperator historically** | Continue cooperating for 2 more rounds; if still alone, switch to probabilistic mode |
| **Threshold consistently exceeded** | Gradually reduce cooperation if my rank is near m, allowing others to carry the load |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, my_id, n, m, k):
    if round_num == 1:
        return COOPERATE with probability m/n
    
    # Calculate cooperation rates for all players
    coop_rates = [times_cooperated[j] / (round_num - 1) for j in all_players]
    
    # Rank players by cooperation rate (descending), break ties by index
    rankings = sorted(range(n), key=lambda j: (-coop_rates[j], j))
    my_rank = rankings.index(my_id) + 1  # 1-indexed
    
    if round_num == total_rounds:
        return final_round_decision(coop_rates, m, my_id)
    
    # Core decision
    if my_rank <= m:
        return COOPERATE
    else:
        reliable_count = sum(1 for rate in coop_rates if rate >= 0.5)
        if reliable_count < m:
            gap_prob = (m - reliable_count) / (n - reliable_count)
            return COOPERATE with probability gap_prob
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing coalitions:** By ranking players by reliability, cooperators naturally find each other and form stable groups of size m.

2. **No exploitation:** I don't free-ride on others' cooperation—if I'm among the most reliable, I continue contributing.

3. **Adaptive to defectors:** If others defect, I fill gaps probabilistically rather than stubbornly cooperating alone.

4. **Efficient outcomes:** The strategy aims for exactly m cooperators, maximizing collective welfare (threshold met, minimum contributions).

5. **Robust to mixed populations:** Works whether opponents are pure cooperators, pure defectors, or adaptive strategies.
'''

description_COLLECTIVE_45 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I act as if I'm one of many copies of myself, all reasoning identically. The goal is to coordinate implicitly through shared logic, ensuring exactly m cooperators emerge each round while being robust to non-cooperative opponents.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic self-selection**: Use deterministic pseudo-randomness based on observable game state to select exactly m cooperators among like-minded players
2. **Responsive adjustment**: Adapt cooperation probability based on observed population behavior
3. **Collective insurance**: Ensure the threshold is met even when some players defect unconditionally

---

## Decision Rules

### Round 1: Bootstrap Cooperation

Since there's no history, use a baseline cooperation probability calibrated to the threshold:

```
p_initial = min(1, (m + 1) / n)
```

The "+1" provides a safety margin. To make this deterministic yet distributed, I cooperate if:

```
hash(game_id, my_player_id, round=1) mod 1000 < p_initial * 1000
```

This ensures that among n identical reasoners, approximately m+1 will cooperate.

### Rounds 2 to r-1: Adaptive Core Phase

**Step 1: Classify observed players from previous round**

```
cooperators_last = count of players who played C in round t-1
defectors_last = n - cooperators_last
threshold_met_last = (cooperators_last >= m)
```

**Step 2: Estimate "reliable cooperators" in the population**

Track a running estimate of cooperative players:
```
reliable_coop_estimate = (Σ over all past rounds of cooperators) / rounds_played
```

**Step 3: Calculate required cooperation probability**

If I assume there are `reliable_coop_estimate` players reasoning like me:
```
effective_n = reliable_coop_estimate
required_cooperators = m
p_cooperate = min(1, (m + 0.5) / max(effective_n, m))
```

**Step 4: Adjust for recent threshold failures**

```
if threshold was NOT met in previous round:
    p_cooperate = min(1, p_cooperate + 0.2)
    
if threshold was met AND cooperators_last > m + 2:
    p_cooperate = max(m/n, p_cooperate - 0.1)  # Reduce unnecessary contribution
```

**Step 5: Determine action via consistent pseudo-randomness**

```
seed = hash(full_game_history_so_far, my_player_id, current_round)
random_value = deterministic_random(seed) in [0, 1]

if random_value < p_cooperate:
    ACTION = COOPERATE
else:
    ACTION = DEFECT
```

### Final Round (Round r): Threshold-Focused

The last round has no shadow of the future, so pure incentives dominate. However, maintaining collective identity:

```
if reliable_coop_estimate >= m:
    # Trust the collective to meet threshold
    p_cooperate = m / reliable_coop_estimate
else:
    # Threshold unlikely - defect to preserve private payoff
    p_cooperate = 0
    
# But add small unconditional cooperation to avoid total collapse
p_cooperate = max(p_cooperate, m / n * 0.8)
```

---

## Edge Case Handling

| Situation | Response |
|-----------|----------|
| **n = m** (everyone must cooperate) | Always cooperate - defection guarantees collective failure |
| **m = 1** (only one needed) | Cooperate with probability 2/n to ensure coverage with redundancy |
| **Threshold never met** | After 3 consecutive failures, switch to unconditional cooperation for 2 rounds |
| **Threshold always met with excess** | Gradually reduce p_cooperate by 0.05/round until cooperators ≈ m+1 |
| **k is very large** | Bias toward higher cooperation (multiply p_cooperate by min(1.5, sqrt(k))) |
| **Very few rounds (r ≤ 3)** | Use higher baseline cooperation; less time to learn |

---

## Pseudocode Summary

```python
def decide(game_params, history, my_id):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    if current_round == 1:
        p = min(1, (m + 1) / n)
    
    elif current_round == r:  # Final round
        reliable = estimate_reliable_cooperators(history)
        if reliable >= m:
            p = m / reliable
        else:
            p = 0
        p = max(p, 0.8 * m / n)
    
    else:  # Middle rounds
        reliable = estimate_reliable_cooperators(history)
        p = min(1, (m + 0.5) / max(reliable, m))
        
        # Adjust for recent outcomes
        if not threshold_met(history[-1]):
            p = min(1, p + 0.2)
        elif count_cooperators(history[-1]) > m + 2:
            p = max(m/n, p - 0.1)
        
        # Scale with k
        p = min(1, p * min(1.3, k ** 0.25))
    
    # Deterministic pseudo-random decision
    seed = hash(tuple(history), my_id, current_round)
    return COOPERATE if det_random(seed) < p else DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Self-coordinating**: Identical reasoners will distribute cooperation without explicit communication
2. **Robust**: Adapts to populations with varying cooperation rates
3. **Efficient**: Targets exactly m cooperators, minimizing unnecessary sacrifice
4. **Forgiving**: Recovers from coordination failures rather than collapsing into mutual defection
5. **Collectively rational**: Maximizes group payoff while being stable against exploitation
'''

description_COLLECTIVE_46 = '''
# Collective Risk Dilemma Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume other rational players also want to achieve the threshold and receive the bonus. The key insight is that **exactly m cooperators is the efficient equilibrium** - it maximizes collective welfare while minimizing individual sacrifice. My strategy aims to be one of those m cooperators when needed, but not to over-contribute when others are already cooperating.

## Strategy Overview

I use a **probabilistic cooperation** approach calibrated to achieve exactly m cooperators in expectation, combined with **responsive adjustment** based on observed group behavior.

---

## Decision Rules

### Round 1: Baseline Probabilistic Cooperation

With no history, I cooperate with probability:

```
P_cooperate = m / n
```

**Rationale**: If all n players independently cooperate with probability m/n, the expected number of cooperators is exactly m. This is the fair, symmetric solution where each player bears equal expected cost.

### Rounds 2 through (r-1): Adaptive Response

I track two key metrics from the previous round:
- `num_cooperators`: How many players cooperated
- `threshold_met`: Whether num_cooperators ≥ m

**Adjustment Rules:**

```
Let base_prob = m / n
Let cooperation_gap = m - num_cooperators  (from previous round)

If threshold_met in previous round:
    If num_cooperators == m:
        # Perfect efficiency achieved - maintain similar behavior
        If I cooperated last round:
            P_cooperate = 0.8  # Likely continue cooperating (soft commitment)
        Else:
            P_cooperate = 0.2  # Likely continue defecting (let cooperators continue)
    
    Else if num_cooperators > m:
        # Over-cooperation - some should switch to defection
        If I cooperated last round:
            P_cooperate = m / num_cooperators  # Probabilistically thin the herd
        Else:
            P_cooperate = 0.1  # Stay defecting, others have it covered

Else (threshold NOT met):
    # Emergency response - increase cooperation
    P_cooperate = min(1.0, base_prob + 0.3 * (cooperation_gap / m))
    # Scale up based on how far we missed the threshold
```

### Final Round (Round r): Slight Cooperation Boost

The last round has no future consequences, creating temptation to defect. To counteract this:

```
P_cooperate = min(1.0, calculated_probability + 0.15)
```

This modest boost reflects that achieving the threshold remains valuable even without future rounds.

---

## Edge Cases

### Edge Case 1: m is very close to n
When `m ≥ n - 1`, nearly everyone must cooperate. In this case:
```
P_cooperate = min(1.0, (m + 0.5) / n)  # Bias toward cooperation
```

### Edge Case 2: m is very small relative to n
When `m ≤ 2`, coordination is easier but free-riding is tempting:
```
# Use history more aggressively
If I was a cooperator when threshold was met: P_cooperate = 0.9
If I was a defector when threshold was met: P_cooperate = 0.1
```

### Edge Case 3: Persistent threshold failure
If threshold hasn't been met for 3+ consecutive rounds:
```
P_cooperate = min(1.0, base_prob + 0.4)  # Significant boost to rescue cooperation
```

### Edge Case 4: Only 2 players (n = 2)
With n=2 and m=2, both must cooperate. Strategy simplifies to:
```
P_cooperate = 0.9  # High cooperation, slight hedge against exploitation
```

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    base_prob = m / n
    
    if round_num == 1:
        return cooperate_with_probability(base_prob)
    
    last_round = history[-1]
    num_coop = count_cooperators(last_round)
    i_cooperated = my_action(last_round) == 'C'
    threshold_met = num_coop >= m
    
    if threshold_met:
        if num_coop == m:
            prob = 0.8 if i_cooperated else 0.2
        else:  # over-cooperation
            prob = (m / num_coop) if i_cooperated else 0.1
    else:
        gap = m - num_coop
        prob = min(1.0, base_prob + 0.3 * (gap / m))
    
    # Final round boost
    if round_num == total_rounds:
        prob = min(1.0, prob + 0.15)
    
    # Persistent failure recovery
    if consecutive_failures(history) >= 3:
        prob = min(1.0, prob + 0.4)
    
    return cooperate_with_probability(prob)
```

---

## Why This Strategy is Collectively Optimal

1. **Fair burden-sharing**: The base probability m/n means everyone has equal expected contribution
2. **Self-organizing**: The adjustment rules push the group toward exactly m cooperators without explicit coordination
3. **Resilient**: Responds to both under-cooperation (crisis) and over-cooperation (waste)
4. **Not exploitable**: Doesn't naively always cooperate, but also doesn't abandon cooperation when the group needs it
5. **Soft commitment**: Players who successfully cooperated tend to continue, creating informal "cooperation roles" that emerge naturally
'''

description_COLLECTIVE_47 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embodies a collective mindset: **I will do my part to ensure the threshold is met, but I will not be exploited.** The key insight is that exactly m cooperators creates the socially optimal outcome where cooperators get k and defectors get 1+k. My goal is to be one of those m cooperators when needed, while adapting to the observed behavior of others.

## Strategy Overview

The strategy uses a **probabilistic cooperation approach** calibrated to achieve exactly m cooperators in expectation, combined with **reputation tracking** to reward consistent cooperators and avoid subsidizing chronic defectors.

---

## Decision Rules

### Round 1: Baseline Cooperation Probability

With no history, I cooperate with probability `p_base = m/n`.

**Rationale:** If all players independently cooperate with probability m/n, the expected number of cooperators equals m. This is the collectively rational starting point that doesn't over-commit or under-commit.

### Rounds 2 through (r-1): Adaptive Cooperation

**Step 1: Calculate cooperation rates**
- `group_coop_rate` = total cooperations by all players in all previous rounds / (n × rounds_played)
- `threshold_met_rate` = rounds where ≥m cooperated / rounds_played

**Step 2: Assess collective need**
- `cooperation_gap` = m/n - group_coop_rate (positive means under-cooperation)

**Step 3: Determine my cooperation probability**

```
if threshold_met_rate >= 0.8:
    # Collective is succeeding - maintain but don't over-contribute
    p_cooperate = m/n
    
elif threshold_met_rate >= 0.5:
    # Moderate success - slightly increase contribution
    p_cooperate = min(1.0, m/n + cooperation_gap × 0.5)
    
else:
    # Collective failing - need to step up, but check if viable
    if group_coop_rate < (m-1)/n:
        # Not enough others cooperating to ever reach threshold
        # Reduce cooperation to avoid pure loss
        p_cooperate = max(0.1, m/n - 0.2)
    else:
        # Close to threshold - increase cooperation
        p_cooperate = min(1.0, m/n + cooperation_gap)
```

**Step 4: Reputation adjustment**
- Track each player's cooperation rate
- If I'm among the top m cooperators by rate, I've "done my share"
- If threshold is being met AND I'm above median cooperation rate, reduce p_cooperate by 0.1

### Final Round (Round r): Strategic Endgame

The last round has no future consequences, making defection tempting. However, maintaining collective success matters.

```
if threshold_met_rate >= 0.7 over all previous rounds:
    # We've built something worth preserving
    # Cooperate with same probability as round r-1
    p_cooperate = previous_round_probability
    
elif threshold was met in round r-1:
    # Recent success - try to maintain
    p_cooperate = m/n
    
else:
    # Pattern of failure - protect myself
    p_cooperate = max(0.1, m/n - 0.3)
```

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    
    if round_num == 1:
        return cooperate_with_probability(m / n)
    
    # Calculate statistics
    group_coop_rate = sum(all_cooperations) / (n * (round_num - 1))
    threshold_met_rate = rounds_threshold_met / (round_num - 1)
    cooperation_gap = (m / n) - group_coop_rate
    my_coop_rate = my_cooperations / (round_num - 1)
    
    # Base probability
    p = m / n
    
    # Adjust for collective need
    if threshold_met_rate < 0.5 and group_coop_rate >= (m-1)/n:
        p = min(1.0, p + cooperation_gap)
    elif threshold_met_rate < 0.5:
        p = max(0.1, p - 0.2)  # Near-hopeless case
    
    # Adjust for fairness (don't over-contribute if doing my part)
    if threshold_met_rate >= 0.7 and my_coop_rate > group_coop_rate + 0.15:
        p = max(m/n - 0.1, p - 0.15)
    
    # Final round adjustment
    if round_num == total_rounds and threshold_met_rate < 0.5:
        p = max(0.1, p - 0.2)
    
    return cooperate_with_probability(p)
```

---

## Key Properties

1. **Collectively aligned:** Starts at the fair share probability and adjusts based on group needs
2. **Adaptive:** Responds to both success and failure of the collective
3. **Robust:** Doesn't assume others will cooperate, but rewards collective success
4. **Self-protective:** Reduces contribution when the collective is clearly failing
5. **Fair:** Tracks whether I'm doing "my share" and adjusts accordingly
6. **Deterministic-resistant:** Probabilistic approach avoids exploitation by pattern-matching opponents
'''

description_COLLECTIVE_48 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume other rational agents may also be designed to seek collective success. My goal is to be a **reliable cooperator when cooperation is needed**, while protecting against exploitation and adapting to the actual behavior of the group.

The key insight is that exactly m cooperators is the efficient outcome—it meets the threshold while minimizing individual sacrifice. The challenge is coordinating to achieve this without communication.

---

## Strategy Overview

I use a **probabilistic cooperation approach** that adapts based on observed group behavior, with the probability calibrated to statistically produce approximately m cooperators across n players.

---

## Decision Rules

### Round 1: Baseline Cooperative Probability

Since I cannot coordinate explicitly, I start with a probability designed to produce the right number of cooperators in expectation:

```
base_probability = m / n
```

**Decision:** Cooperate with probability `base_probability`, defect otherwise.

*Rationale:* If all n players use this probability, expected cooperators = n × (m/n) = m. This is the collectively rational starting point.

---

### Rounds 2 through (r-1): Adaptive Cooperation

After observing history, I adjust my cooperation probability based on two factors:

#### Factor 1: Cooperation Gap
```
avg_cooperators = average number of cooperators in previous rounds
cooperation_gap = m - avg_cooperators
```

#### Factor 2: My Role Assessment
```
my_cooperation_rate = (times I cooperated) / (rounds played)
group_cooperation_rate = avg_cooperators / n
```

#### Adjusted Probability Calculation:
```
# Start with base probability
adjusted_prob = m / n

# Increase probability if group is under-cooperating
if cooperation_gap > 0:
    adjusted_prob += 0.15 × cooperation_gap

# Decrease probability if group is over-cooperating
if cooperation_gap < 0:
    adjusted_prob += 0.10 × cooperation_gap  # (this subtracts since gap is negative)

# If I've been cooperating more than my share but threshold still isn't met,
# maintain high cooperation (don't abandon the collective)
if my_cooperation_rate > group_cooperation_rate AND avg_cooperators < m:
    adjusted_prob = max(adjusted_prob, 0.7)

# Clamp to valid probability range
adjusted_prob = clamp(adjusted_prob, 0.05, 0.95)
```

**Decision:** Cooperate with probability `adjusted_prob`, defect otherwise.

---

### Last Round (Round r): Threshold-Focused Decision

The last round requires special handling since there's no future to influence:

```
# Count recent cooperation trend (last 3 rounds or all if fewer)
recent_rounds = min(3, r-1)
recent_cooperators = average cooperators in last recent_rounds

if recent_cooperators >= m:
    # Threshold typically met - I can likely free-ride safely
    # But maintain small cooperation chance for collective insurance
    cooperate with probability 0.25
    
elif recent_cooperators >= m - 1:
    # We're close - be a reliable contributor
    cooperate with probability 0.7
    
else:
    # Threshold rarely met - cooperation unlikely to help
    # But don't completely abandon (others might surge)
    cooperate with probability 0.3
```

---

### Edge Case: Very Small Groups (n ≤ 3)

When n is small, my individual choice has outsized impact:

```
if n <= 3:
    # In tiny groups, lean toward cooperation
    # The collective reward matters more than individual savings
    adjusted_prob = max(adjusted_prob, 0.6)
```

---

### Edge Case: Threshold Nearly Equals Group Size (m ≥ n-1)

When almost everyone must cooperate:

```
if m >= n - 1:
    # Near-unanimous cooperation needed
    # Defection almost guarantees collective failure
    adjusted_prob = max(adjusted_prob, 0.85)
```

---

## Summary Pseudocode

```
function decide(round, history, n, m, r, k):
    
    if round == 1:
        return random() < (m / n)
    
    # Calculate history statistics
    avg_cooperators = mean(cooperators_per_round in history)
    cooperation_gap = m - avg_cooperators
    my_coop_rate = my_cooperations / (round - 1)
    
    # Base probability
    prob = m / n
    
    # Adjust for cooperation gap
    if cooperation_gap > 0:
        prob += 0.15 * cooperation_gap
    else:
        prob += 0.10 * cooperation_gap
    
    # Loyal cooperator clause
    if my_coop_rate > (avg_cooperators / n) AND avg_cooperators < m:
        prob = max(prob, 0.7)
    
    # Edge cases
    if n <= 3:
        prob = max(prob, 0.6)
    if m >= n - 1:
        prob = max(prob, 0.85)
    
    # Last round adjustment
    if round == r:
        recent_avg = mean(last 3 rounds cooperators)
        if recent_avg >= m:
            prob = 0.25
        elif recent_avg >= m - 1:
            prob = 0.7
        else:
            prob = 0.3
    
    prob = clamp(prob, 0.05, 0.95)
    return random() < prob
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing:** The base probability naturally produces ~m cooperators without coordination
2. **Adaptive:** Responds to actual group behavior rather than assuming specific opponent strategies
3. **Loyal but not exploitable:** Maintains cooperation when needed, but reduces when threshold is consistently exceeded
4. **Probabilistic:** Avoids deterministic patterns that sophisticated opponents could exploit
5. **Threshold-aware:** Recognizes that exactly m cooperators is collectively optimal
'''

description_COLLECTIVE_49 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not to over-contribute when others are already meeting the threshold. The goal is to reliably achieve the collective reward while being robust against free-riders and adapting to the actual behavior of other players.

## Strategy Overview

The strategy operates on three key principles:
1. **Be willing to be part of the solution** - Default toward cooperation, especially early
2. **Respond to observed cooperation levels** - Adapt based on whether thresholds are being met
3. **Coordinate implicitly through deterministic rules** - Use player index and game state to create emergent coordination

---

## Decision Rules

### Round 1: Probabilistic Commitment Based on Position

Since no history exists, use a deterministic rule based on the game parameters:

```
IF player_index <= m:
    COOPERATE (be a "primary guardian")
ELSE:
    COOPERATE with probability m/n (be a "backup guardian")
```

**Rationale**: This ensures approximately *m* cooperators in expectation while distributing responsibility. Players with lower indices commit to being reliable cooperators; others provide backup.

*Note: Since we need a deterministic strategy, the "probability" is implemented as:*
```
IF player_index <= m OR (player_index mod ceil(n/m)) == 0:
    COOPERATE
ELSE:
    DEFECT
```

### Rounds 2 through (r-1): Adaptive Response

Track two key metrics from the previous round:
- `prev_cooperators`: Number of players who cooperated last round
- `threshold_met`: Whether prev_cooperators >= m

**Decision Logic:**

```
# Calculate cooperation gap/surplus
cooperation_gap = m - prev_cooperators

IF threshold_met (prev_cooperators >= m):
    # Success case - maintain with slight adjustment
    IF prev_cooperators == m:
        # Exactly at threshold - maintain my previous action
        DO same_as_last_round
    ELIF prev_cooperators > m + 1:
        # Over-contributing as a group
        IF I_cooperated_last_round AND player_index > m:
            DEFECT (allow primary guardians to carry)
        ELSE:
            DO same_as_last_round
    ELSE:
        # Threshold met with small buffer - stable
        DO same_as_last_round
        
ELSE (threshold NOT met):
    # Failure case - need more cooperation
    IF I_defected_last_round:
        # I wasn't helping - step up
        COOPERATE
    ELSE:
        # I was helping but threshold still missed
        # Stay cooperative but note the failure
        COOPERATE
```

**Reputation Tracking for Rounds 3+:**

Maintain a simple cooperation score for the collective:
```
collective_reliability = (total_cooperators_across_all_rounds) / (n * rounds_played)
```

Modify behavior:
```
IF collective_reliability < m/n - 0.1:
    # Group is under-cooperating - be more cooperative
    Bias toward COOPERATE (always cooperate if threshold missed)
    
IF collective_reliability > (m+2)/n:
    # Group is over-cooperating - safe to occasionally free-ride
    IF player_index > m AND last_2_rounds_threshold_met:
        Allow DEFECT
```

### Final Round (Round r): Modified Logic

The last round removes future consequences, creating temptation to defect. Counter this collectively:

```
# Calculate historical reliability
success_rate = rounds_threshold_met / (r - 1)

IF success_rate >= 0.7:
    # Group has been reliable - trust them, maintain pattern
    IF I_cooperated_last_round AND player_index <= m:
        COOPERATE (primary guardians stay committed)
    ELIF prev_cooperators >= m + 2:
        DEFECT (buffer exists, others will maintain)
    ELSE:
        COOPERATE (protect the threshold)
        
ELIF success_rate >= 0.4:
    # Mixed history - be cautiously cooperative
    IF player_index <= m:
        COOPERATE
    ELSE:
        Match most_common_action_of_players_above_index_m
        
ELSE:
    # Poor history - threshold rarely met anyway
    IF prev_cooperators >= m - 1:
        COOPERATE (we're close, make it happen)
    ELSE:
        DEFECT (likely futile)
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| **m = n-1** (almost everyone must cooperate) | Always COOPERATE unless I'm the only defector and threshold was met |
| **m = 2** (low threshold) | Primary guardians (index 1,2) always cooperate; others free-ride more |
| **r = 2** (only 2 rounds) | Treat round 1 normally; round 2 use final round logic |
| **Everyone defected last round** | COOPERATE (someone must break the deadlock; primary guardians lead) |
| **Everyone cooperated last round** | If index > m, DEFECT; else COOPERATE (efficient distribution) |
| **Exactly m cooperated, I was one** | COOPERATE (maintain the equilibrium) |
| **Exactly m cooperated, I wasn't one** | DEFECT (we found a working split) |

---

## Pseudocode Summary

```python
def decide(player_index, round_num, total_rounds, n, m, k, history):
    
    if round_num == 1:
        # First round: deterministic position-based commitment
        if player_index <= m:
            return COOPERATE
        elif player_index % ceil(n / m) == 0:
            return COOPERATE
        else:
            return DEFECT
    
    prev_coop = count_cooperators(history[-1])
    threshold_met = prev_coop >= m
    my_last_action = history[-1][player_index]
    
    # Calculate historical metrics
    success_rate = sum(1 for r in history if count_cooperators(r) >= m) / len(history)
    
    if round_num == total_rounds:
        # Final round logic
        if success_rate >= 0.7 and prev_coop >= m + 1:
            return DEFECT if player_index > m else COOPERATE
        elif prev_coop >= m - 1:
            return COOPERATE
        else:
            return COOPERATE if player_index <= m else DEFECT
    
    # Middle rounds: adaptive response
    if not threshold_met:
        # Threshold missed - increase cooperation
        return COOPERATE
    elif prev_coop == m:
        # Exactly at threshold - maintain
        return my_last_action
    elif prev_coop > m + 1 and my_last_action == COOPERATE and player_index > m:
        # Over-cooperating and I'm a backup - can defect
        return DEFECT
    else:
        return my_last_action
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing coordination**: Player indices create natural "roles" without explicit communication
2. **Failure recovery**: When thresholds are missed, the strategy increases cooperation immediately
3. **Efficiency**: Avoids over-contribution when threshold is comfortably met
4. **Defection resistance**: Primary guardians (index ≤ m) remain reliable anchors
5. **Adaptability**: Responds to actual group behavior rather than assuming specific opponent strategies
6. **Last-round protection**: Maintains cooperation incentives even when future rounds don't exist
'''

description_COLLECTIVE_50 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I recognize that my individual success is deeply intertwined with collective success. The goal is not to maximize my personal payoff at others' expense, but to help ensure the threshold is met while being resilient against exploitation. I aim to be a reliable cooperator that others can count on, while adapting to the actual cooperation levels observed.

## Strategy Overview

The strategy operates on three principles:
1. **Start cooperative** - Signal willingness to contribute to collective success
2. **Maintain threshold awareness** - Track whether cooperation is viable given observed behavior
3. **Adapt responsibly** - Reduce cooperation only when the collective clearly cannot succeed, not as punishment

---

## Decision Rules

### Round 1: Cooperative Start

**Action: COOPERATE**

Rationale: With no history, I demonstrate commitment to collective welfare. This signals reliability and helps establish a cooperative baseline.

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate the following from the previous round's observations:

```
cooperators_last_round = count of players who played C in round t-1
cooperation_rate = cooperators_last_round / n
threshold_ratio = m / n
shortfall = m - cooperators_last_round
```

**Decision Logic:**

```
IF cooperators_last_round >= m THEN:
    # Threshold was met - collective succeeded
    # Continue contributing to maintain success
    ACTION = COOPERATE

ELSE IF cooperators_last_round >= m - 1 THEN:
    # We were close - my cooperation could be pivotal
    # Stay committed to help reach threshold
    ACTION = COOPERATE

ELSE IF cooperators_last_round >= ceiling(m / 2) THEN:
    # Partial cooperation exists - there's hope
    # Use probabilistic cooperation based on how close we are
    cooperation_probability = cooperators_last_round / m
    ACTION = COOPERATE with probability cooperation_probability
    
ELSE:
    # Cooperation has largely collapsed
    # Attempt periodic cooperation to test for recovery
    IF (current_round mod 3) == 0 THEN:
        ACTION = COOPERATE  # Periodic olive branch
    ELSE:
        ACTION = DEFECT
```

### Final Round (Round r): Threshold-Aware Decision

The last round requires special consideration since there's no future to influence:

```
# Calculate historical cooperation patterns
average_cooperators = mean(cooperators in each round from 1 to r-1)
recent_cooperators = cooperators in round r-1

IF recent_cooperators >= m THEN:
    # Recent success - cooperate to maintain it
    ACTION = COOPERATE
    
ELSE IF recent_cooperators >= m - 1 THEN:
    # Close to threshold - my contribution could be decisive
    ACTION = COOPERATE
    
ELSE IF average_cooperators >= m - 1 THEN:
    # Historical near-success - give it one more try
    ACTION = COOPERATE
    
ELSE:
    # Cooperation appears non-viable
    ACTION = DEFECT
```

---

## Edge Case Handling

### When m = n - 1 or m = n (High threshold)
- Be especially committed to cooperation since every player matters
- Defect only after multiple consecutive failed rounds

### When m is very small relative to n
- Still start cooperative to signal collective orientation
- If threshold is easily met by others, can reduce cooperation rate slightly in middle rounds
- Always cooperate if doing so would bring count to exactly m (being pivotal)

### When n = 2 (Minimum players)
- This becomes essentially a coordination game
- Maintain cooperation unless partner defects twice consecutively

### When r = 2 (Minimum rounds)
- Round 1: COOPERATE
- Round 2: COOPERATE if round 1 had at least m-1 cooperators, else DEFECT

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return COOPERATE
    
    last_cooperators = count_cooperators(history[round - 1])
    
    if round == r:  # Final round
        avg_coop = mean([count_cooperators(h) for h in history])
        if last_cooperators >= m - 1 or avg_coop >= m - 1:
            return COOPERATE
        return DEFECT
    
    # Middle rounds
    if last_cooperators >= m - 1:
        return COOPERATE
    elif last_cooperators >= ceil(m / 2):
        return COOPERATE with probability (last_cooperators / m)
    else:
        return COOPERATE if (round % 3 == 0) else DEFECT
```

---

## Why This Strategy is Collectively-Minded

1. **Generous baseline**: Starts cooperating and maintains cooperation when threshold is achievable
2. **Not punitive**: Doesn't defect to "punish" - only reduces cooperation when collective success appears impossible
3. **Recovery-oriented**: Periodically attempts cooperation even after collapse to enable collective recovery
4. **Pivotal awareness**: Explicitly reasons about when my contribution could make the difference between success and failure
5. **Threshold-focused**: Cares about whether *enough* of us cooperate, not about individual free-riders
'''

description_COLLECTIVE_51 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not to over-contribute when sufficient cooperation already exists. The goal is to reliably meet the threshold while minimizing exploitation by free-riders.

## Strategy Overview

The strategy operates on three principles:
1. **Be willing to cooperate** - Someone must, and I should be part of the solution
2. **Respond to observed behavior** - Reward cooperative environments, withdraw from exploitative ones
3. **Maintain hope but not naivety** - Give cooperation chances to emerge, but protect against persistent defection

---

## Decision Rules

### Round 1: Optimistic Cooperation

**Action: Cooperate**

Rationale: With no history, I signal cooperative intent. If all players reason similarly, we establish a cooperative baseline. The collective good requires someone to start cooperating.

---

### Rounds 2 through (r-1): Adaptive Response

Calculate two key metrics from the previous round:

1. **Cooperation count (c_prev)**: Number of players who cooperated last round
2. **Threshold met**: Whether c_prev ≥ m

**Decision Logic:**

```
IF threshold was met last round (c_prev ≥ m):
    IF c_prev == m:
        # Exactly at threshold - I should stay cooperative if I was part of it
        Cooperate with probability = m/n
    ELSE IF c_prev > m:
        # Over-threshold - some can safely defect
        # I cooperate if I cooperated last round, with slight reduction
        Cooperate with probability = m/c_prev
    
ELSE (threshold NOT met, c_prev < m):
    # Collective failure - need to assess trajectory
    
    IF c_prev > c_two_rounds_ago OR round ≤ 3:
        # Cooperation is growing or too early to judge - stay hopeful
        Cooperate
    ELSE IF c_prev < (m/2):
        # Severe under-cooperation - defect to avoid exploitation
        Defect
    ELSE:
        # Moderate cooperation but declining - conditional cooperation
        # Cooperate with probability proportional to how close we were
        Cooperate with probability = c_prev / m
```

**Tie-Breaking Mechanism:**

When probabilistic cooperation is indicated, use a deterministic rule based on position:
- Conceptually, if probability = m/n, then players in "positions" 1 through m should cooperate
- Since I don't know my position, I use the cooperation history to estimate my "role"
- If I cooperated last round AND threshold was met, I lean toward continuing
- If I defected last round AND threshold was barely met, I lean toward staying defected

---

### Final Round (Round r): Modified Calculation

The last round has no future shadow, changing incentives significantly.

```
IF average cooperation rate over all rounds ≥ m/n:
    # Cooperative environment - maintain cooperation
    Cooperate with probability = m/n (using deterministic tie-breaker)
    
ELSE:
    # Historically uncooperative environment
    IF threshold was met in majority of rounds:
        Cooperate (protect the collective achievement)
    ELSE:
        Defect (collective failure is likely regardless)
```

---

## Deterministic Implementation

To avoid coordination failures from simultaneous randomization, convert probabilities to deterministic rules:

```
cooperation_score = (my_cooperation_count / current_round) 

target_probability = [calculated from above rules]

IF cooperation_score < target_probability:
    Cooperate  # I've cooperated less than my "fair share"
ELSE IF cooperation_score > target_probability:
    Defect     # I've cooperated more than needed
ELSE:
    # Exactly at target - use round parity
    Cooperate if (current_round mod 2 == 1)
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | Cooperate both rounds | Too short for learning; default cooperative |
| m = n-1 (nearly all must cooperate) | Cooperate consistently | Almost no room for free-riding |
| m = 2 (low threshold) | Follow adaptive rules but lean toward defection when threshold met | Can afford some defection |
| All others always defect | Defect after round 3 | No point in solo cooperation |
| All others always cooperate | Cooperate with probability m/n | Be fair, don't over-exploit |

---

## Summary Pseudocode

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE
    
    c_prev = count_cooperators(history, round - 1)
    my_coop_rate = my_cooperation_count(history) / (round - 1)
    threshold_met = (c_prev >= m)
    
    if round == r:  # Final round
        return final_round_decision(history, n, m)
    
    if threshold_met:
        target_rate = m / max(c_prev, m)
    else:
        if c_prev < m/2:
            target_rate = 0.2  # Low but not zero - leave door open
        else:
            target_rate = c_prev / m
    
    # Deterministic conversion
    if my_coop_rate < target_rate - 0.1:
        return COOPERATE
    elif my_coop_rate > target_rate + 0.1:
        return DEFECT
    else:
        return COOPERATE if (round mod 2 == 1) else DEFECT
```

This strategy aims to be a reliable contributor to collective success while adapting to the actual behavior of others—neither a pushover nor a defector, but a conditional cooperator committed to the collective good.
'''

description_COLLECTIVE_52 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume I am one of many agents running the same strategy, and I design my behavior to achieve good collective outcomes when playing with copies of myself, while remaining robust against defectors and exploiters.

The key insight is that exactly m cooperators is optimal for the group (threshold met, minimal contribution), but coordinating on exactly m without communication requires a probabilistic approach tied to observable history.

---

## Strategy Overview

**Adaptive Probabilistic Cooperation** with three phases:
1. **Establishment Phase** (early rounds): Cooperate with calibrated probability to establish threshold-meeting patterns
2. **Responsive Phase** (middle rounds): Adjust cooperation probability based on observed cooperation rates
3. **Terminal Phase** (final rounds): Shift toward self-interested play as end approaches

---

## Decision Rules

### Round 1 (No History)

**Cooperate with probability p₁ = m/n**

*Rationale*: If all n players use this strategy, expected cooperators = m, which is exactly the threshold. This is the Nash equilibrium mixing probability for symmetric players trying to hit the threshold collectively.

### Rounds 2 through (r-2): Responsive Phase

Calculate the **observed cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

Calculate the **target cooperation rate**:
```
target_rate = m / n
```

**Adjust my cooperation probability:**

```
If prev_coop_rate < target_rate:
    # Too few cooperators - increase my contribution likelihood
    p_t = min(1.0, (m / n) + adjustment_factor)
    
If prev_coop_rate > target_rate:
    # More than enough cooperators - I can reduce slightly
    p_t = max(0.1, (m / n) - adjustment_factor)
    
If prev_coop_rate ≈ target_rate (within 1/n tolerance):
    # On target - maintain baseline
    p_t = m / n
```

Where:
```
adjustment_factor = |prev_coop_rate - target_rate| * 0.5
```

**Additional responsive rules:**

- **Threshold consistently met** (last 3+ rounds): Slightly reduce p_t by 0.1 (let potential free-riders carry more risk)
- **Threshold consistently missed** (last 3+ rounds): Increase p_t by 0.15 (be more reliable)
- **Highly variable outcomes**: Return to baseline p = m/n (stabilize)

### Rounds (r-1) and r: Terminal Phase

**Round r-1:**
```
p_{r-1} = max(0.3, (m/n) - 0.1)
```
Slightly reduce cooperation as end-game approaches, but don't abandon collective entirely.

**Round r (Final Round):**
```
If historical cooperation rate ≥ m/n:
    p_r = m/n  # Maintain collective behavior - we've built something
Else:
    p_r = 0.2  # Low cooperation environment - protect myself
```

---

## Edge Cases

### When m is very close to n (e.g., m = n-1)
- Increase base cooperation probability to 0.9
- The collective needs almost everyone; defection is very costly to the group

### When m is very small relative to n (e.g., m = 2, n = 10)
- Use base probability m/n but with higher variance tolerance
- Be willing to defect more when threshold is being met by others

### When k is very large (k > 2)
- The reward strongly dominates; bias toward cooperation (+0.1 to all probabilities)
- Missing threshold is catastrophic for everyone

### When k is barely above 1 (k ≈ 1.1)
- Cooperation barely pays off; bias toward defection (-0.1 to probabilities)
- Be more conservative about contributing

### Detecting Coordinated Defectors
```
If threshold met in < 30% of last 5 rounds AND my cooperation rate > 0.5:
    # I'm being exploited or group is failing
    Reduce p to 0.3 for next 2 rounds, then reassess
```

---

## Pseudocode Summary

```
function decide(round, history, n, m, r, k):
    
    base_p = m / n
    
    # Round 1
    if round == 1:
        return cooperate_with_probability(base_p)
    
    # Calculate history statistics
    prev_coop_count = count_cooperators(history, round - 1)
    prev_coop_rate = prev_coop_count / n
    threshold_met_recently = threshold_met_in_last_k_rounds(history, 3)
    
    # Terminal phase
    if round == r:
        if average_cooperation_rate(history) >= base_p:
            return cooperate_with_probability(base_p)
        else:
            return cooperate_with_probability(0.2)
    
    if round == r - 1:
        return cooperate_with_probability(max(0.3, base_p - 0.1))
    
    # Responsive phase
    adjustment = abs(prev_coop_rate - base_p) * 0.5
    
    if prev_coop_rate < base_p - (1/n):
        p = min(1.0, base_p + adjustment)
    elif prev_coop_rate > base_p + (1/n):
        p = max(0.1, base_p - adjustment)
    else:
        p = base_p
    
    # Consistency adjustments
    if threshold_met_recently >= 3:
        p = max(0.1, p - 0.1)
    elif threshold_met_recently == 0:
        p = min(1.0, p + 0.15)
    
    # k-factor adjustment
    if k > 2:
        p = min(1.0, p + 0.1)
    elif k < 1.2:
        p = max(0.1, p - 0.1)
    
    return cooperate_with_probability(p)
```

---

## Why This Strategy is Collectively Optimal

1. **Self-coordinating**: Multiple copies naturally distribute to approximately m cooperators
2. **Responsive**: Adapts to both cooperative and hostile environments
3. **Robust**: Probabilistic approach prevents exploitation by predictability
4. **Efficient**: Aims for exactly m cooperators, not wasteful over-cooperation
5. **Stable**: Converges toward sustainable equilibrium over rounds
'''

description_COLLECTIVE_53 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume I am one of many agents running identical logic. Our goal is to collectively ensure exactly m cooperators emerge each round (maximizing group welfare) while being robust to defectors and adaptive to observed behavior.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic coordination**: Use deterministic-looking randomization based on round number to distribute cooperation duty
2. **Responsive adjustment**: Increase cooperation probability when the collective is falling short
3. **Exploitation resistance**: Reduce cooperation if consistently being exploited by persistent defectors

---

## Decision Rules

### Round 1: Baseline Probabilistic Cooperation

Since I cannot coordinate explicitly but assume others may run similar logic:

```
base_probability = m / n
cooperate if hash(round_number, player_seed) mod 1000 < base_probability * 1000
```

**Rationale**: If all n players cooperate with probability m/n, expected cooperators = m. This is the socially optimal baseline.

However, since we need robustness, I use a slightly elevated probability:

```
initial_probability = min(1.0, (m + 0.5) / n)
```

This provides a small buffer to ensure threshold is met.

---

### Rounds 2 through r-1: Adaptive Cooperation

**Step 1: Calculate cooperation deficit/surplus from history**

```
expected_cooperators_per_round = m
actual_cooperators_history = [count of C plays in each past round]
average_cooperation = mean(actual_cooperators_history)
cooperation_gap = m - average_cooperation
```

**Step 2: Identify behavioral patterns**

```
my_cooperations = count of rounds I played C
times_threshold_met = count of rounds with ≥ m cooperators
times_i_was_pivotal = count of rounds where exactly m cooperated AND I cooperated
exploitation_score = (times_threshold_met when I defected) / (times I defected + 1)
```

**Step 3: Compute adjusted cooperation probability**

```
# Base probability
p = m / n

# Adjustment for cooperation gap (increase if falling short)
if cooperation_gap > 0:
    p = p + (cooperation_gap / n) * 0.5
else:
    p = p + (cooperation_gap / n) * 0.3  # Reduce less aggressively

# Adjustment for exploitation (reduce if others free-ride successfully)
if exploitation_score > 0.7 AND my_cooperations > r * 0.6:
    p = p * 0.8  # Pull back if being exploited

# Adjustment for critical rounds (increase as rounds progress)
rounds_remaining = r - current_round
urgency_factor = 1 + (0.2 * (current_round / r))
p = p * urgency_factor

# Bound probability
p = max(0.1, min(0.95, p))
```

**Step 4: Make decision**

```
if random() < p:
    COOPERATE
else:
    DEFECT
```

---

### Last Round (Round r): Threshold-Focused Decision

The last round removes shadow of future punishment, but collective success still matters.

```
# Count reliable cooperators from history
reliable_cooperators = players who cooperated ≥ 60% of the time

if len(reliable_cooperators) >= m - 1:
    # Enough others likely to cooperate
    if I was a reliable cooperator:
        COOPERATE  # Maintain collective success
    else:
        COOPERATE with probability m/n  # Give threshold a chance
else:
    # Collective has failed; cooperate to try to save it
    COOPERATE with probability min(0.9, (m - len(reliable_cooperators)) / (n - len(reliable_cooperators)))
```

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **m = n-1** (nearly all must cooperate) | Set base probability to 0.95; cooperation is almost mandatory |
| **m = 2** (low threshold) | Set base probability to max(2/n, 0.3); allow more defection |
| **k is very large** | Increase base probability by factor of min(1.5, k/2); reward justifies risk |
| **k is barely > 1** | Use standard probability; marginal reward doesn't justify extra risk |
| **All previous rounds failed threshold** | Set p = 0.9 for next round; emergency cooperation mode |
| **All previous rounds succeeded with surplus** | Reduce p by 10%; allow efficiency gains |

---

## Pseudocode Summary

```python
def decide(game_params, history, my_player_id):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    # Base cooperation probability
    p = (m + 0.5) / n
    
    if current_round == 1:
        return COOPERATE if random() < p else DEFECT
    
    # Analyze history
    avg_cooperators = mean([sum(round) for round in history])
    gap = m - avg_cooperators
    
    # Adjust for gap
    p += (gap / n) * (0.5 if gap > 0 else 0.3)
    
    # Urgency adjustment
    p *= 1 + 0.2 * (current_round / r)
    
    # Exploitation check
    my_coops = sum([history[t][my_player_id] for t in range(len(history))])
    if my_coops > len(history) * 0.6:
        threshold_met_without_me = sum([1 for t in history if sum(history[t]) - history[t][my_player_id] >= m])
        if threshold_met_without_me > len(history) * 0.5:
            p *= 0.8
    
    # Bound
    p = max(0.1, min(0.95, p))
    
    return COOPERATE if random() < p else DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Self-organizing**: Multiple agents using this strategy will naturally distribute cooperation duty
2. **Adaptive**: Responds to both cooperative and hostile environments
3. **Robust**: Never fully defects (maintains minimum cooperation) nor always cooperates (resists exploitation)
4. **Threshold-aware**: Focuses on achieving exactly m cooperators for efficiency
5. **Temporally aware**: Increases cooperation pressure as game progresses to ensure collective success
'''

description_COLLECTIVE_54 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of exactly m cooperators when possible, contributing my fair share to avert collective risk while being responsive to the actual behavior of others. The strategy balances reliability (being someone others can count on) with adaptability (responding to what actually happens).

## Decision Rules

### Key Variables Tracked
- `coop_rate`: Historical cooperation rate across all players (excluding self)
- `last_round_coops`: Number of cooperators in the previous round
- `threshold_met_rate`: Fraction of past rounds where threshold m was met
- `my_coop_count`: How many times I've cooperated so far
- `round_number`: Current round (1 to r)

### Primary Decision Logic

```
function decide(round, history, n, m, k, r):
    
    # Calculate my "fair share" of cooperation
    fair_share_rate = m / n
    
    # First Round: Cooperate with probability equal to fair share
    if round == 1:
        return COOPERATE with probability (m / n)
    
    # Calculate historical metrics
    coop_rate = average cooperation rate of others in all past rounds
    last_coops = number of cooperators last round (excluding me)
    my_rate = my_coop_count / (round - 1)
    
    # Estimate expected cooperators this round (excluding me)
    expected_others = coop_rate * (n - 1)
    
    # CRITICAL DECISION: Am I needed to reach threshold?
    
    # Case 1: Others likely insufficient - I'm needed
    if expected_others < m - 0.5:
        # Check if cooperation is viable (enough potential cooperators)
        if expected_others + 1 >= m * 0.6:  # At least 60% of threshold reachable
            return COOPERATE
        else:
            # Cooperation futile - would waste contribution
            return DEFECT
    
    # Case 2: Others likely exactly sufficient - conditional cooperation
    if m - 0.5 <= expected_others < m + 0.5:
        # Threshold is precarious - cooperate if I've been defecting more than fair share
        if my_rate < fair_share_rate:
            return COOPERATE
        else:
            return DEFECT
    
    # Case 3: Others likely more than sufficient - free ride okay
    if expected_others >= m + 0.5:
        # But don't always defect - maintain some cooperation for stability
        if my_rate < fair_share_rate * 0.7:
            return COOPERATE  # Catch up on fair share
        else:
            return DEFECT
```

### Edge Case Handling

**First Round:**
- Cooperate with probability m/n (my fair share)
- This creates expected m cooperators if all use similar logic

**Last Round (round = r):**
- Use same logic as other rounds
- Rationale: Collective commitment means not abandoning principles at the end
- This distinguishes from purely self-interested strategies

**When Threshold Has Never Been Met:**
- If round > 3 and threshold never met: gradually reduce cooperation
- But maintain minimum 20% cooperation rate to signal willingness
- This avoids wasting contributions in hopeless situations while keeping door open

**When Threshold Always Met:**
- Gradually test if my cooperation is necessary by occasionally defecting
- If threshold still met, I was providing "excess" cooperation
- Rebalance toward fair share

### Adaptive Responsiveness

```
# Trend detection - are others becoming more or less cooperative?
if round >= 3:
    recent_coop_rate = cooperation rate in last 2 rounds
    earlier_coop_rate = cooperation rate before that
    
    if recent_coop_rate > earlier_coop_rate + 0.1:
        # Others trending cooperative - I can ease off slightly
        cooperation_modifier = -0.1
    elif recent_coop_rate < earlier_coop_rate - 0.1:
        # Others trending defective - step up if threshold at risk
        cooperation_modifier = +0.15
    else:
        cooperation_modifier = 0
    
    # Apply modifier to base cooperation probability
```

## Summary of Strategy Identity

**I am a "threshold guardian"** - I aim to be part of the minimum coalition needed to avert collective risk. I:

1. **Start fair**: Begin with my proportional share of cooperation burden
2. **Stay responsive**: Adjust based on whether I'm actually needed
3. **Remain reliable**: Don't completely abandon cooperation even when others defect heavily
4. **Honor commitments**: Don't defect in final rounds just because I can

This strategy should perform well against both cooperative populations (by not over-contributing) and mixed populations (by providing stability without being exploited).
'''

description_COLLECTIVE_55 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to ensure the group reaches the threshold. The key insight is that in a collective risk dilemma, the worst outcome is failing to meet the threshold—everyone loses the bonus k. My role is to be a reliable cooperator who helps the group succeed, while adaptively responding to the observed behavior of others.

## Strategy Overview

I aim to be one of the m cooperators needed for collective success. I cooperate by default unless doing so is clearly wasteful (too many others already cooperating) or futile (too few others willing to cooperate to ever reach threshold). I use observed history to estimate others' cooperation tendencies and adjust accordingly.

---

## Decision Rules

### Round 1: Cooperative Start

**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent. Since m cooperators are needed and I want the collective to succeed, I volunteer to be one of them. This establishes trust and provides information about others.

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate the following from history:

1. **Cooperation rate of others**: For each other player j, compute their historical cooperation rate `coop_rate_j = (times j cooperated) / (rounds played)`

2. **Expected cooperators (excluding me)**: `expected_others = Σ coop_rate_j` for all j ≠ i

3. **Decision logic**:

```
IF expected_others >= m:
    # Threshold likely met without me - I can safely defect
    # BUT: Only defect if confidence is high (observed multiple rounds)
    IF rounds_played >= 3 AND expected_others >= m + 0.5:
        DEFECT
    ELSE:
        COOPERATE  # Stay cooperative when uncertain

ELSE IF expected_others >= m - 1:
    # I might be the pivotal cooperator - threshold needs me
    COOPERATE

ELSE IF expected_others < m - 1:
    # Even with my cooperation, threshold unlikely
    # Check if cooperation is trending upward
    IF cooperation_trend_positive:
        COOPERATE  # Encourage emerging cooperation
    ELSE IF expected_others < (m - 1) / 2:
        DEFECT  # Futile - too few cooperators
    ELSE:
        COOPERATE  # Give benefit of doubt
```

4. **Trend detection**: Compare cooperation rate in recent half of rounds vs earlier half. Positive trend encourages cooperation even when current rates are low.

5. **Forgiveness mechanism**: If others defected but are showing signs of returning to cooperation, I cooperate to welcome them back.

### Final Round (Round r): Threshold-Focused Decision

The last round has no future consequences, but collective success still matters.

```
# Use most recent 3 rounds (or all if fewer) to estimate behavior
recent_expected_others = estimated cooperators from recent rounds

IF recent_expected_others >= m:
    DEFECT  # Threshold met without me
ELSE IF recent_expected_others >= m - 1:
    COOPERATE  # I'm likely pivotal
ELSE:
    # Threshold unlikely - but cooperate if close
    IF recent_expected_others >= m - 1.5:
        COOPERATE
    ELSE:
        DEFECT
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| r = 2 (minimal rounds) | Cooperate both rounds | Too little information to adapt; stay cooperative |
| m = n-1 (need almost everyone) | Always cooperate | Can't afford any defection; be reliable |
| m = 2 (low threshold) | Cooperate until 2+ others consistently cooperate | Easy threshold; ensure it's met then can relax |
| k is very large | Bias toward cooperation | High reward justifies cooperation risk |
| All others defected last round | Cooperate once more | Test if it was anomaly; don't abandon collective immediately |
| n is very large | Cooperate if expected_others is within m ± √n | Account for higher variance |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, m, k):
    if round_num == 1:
        return COOPERATE
    
    # Calculate cooperation rates for each other player
    other_coop_rates = [player_j_cooperation_rate(history, j) for j in others]
    expected_others = sum(other_coop_rates)
    
    # Final round logic
    if round_num == total_rounds:
        recent_expected = estimate_from_recent_rounds(history, window=3)
        if recent_expected >= m:
            return DEFECT
        elif recent_expected >= m - 1.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    if expected_others >= m + 0.5 and round_num >= 4:
        return DEFECT  # Threshold comfortably met without me
    elif expected_others >= m - 1:
        return COOPERATE  # I may be pivotal
    elif expected_others < (m - 1) / 2 and not trend_is_positive(history):
        return DEFECT  # Cooperation is futile
    else:
        return COOPERATE  # Default to cooperation
```

---

## Why This Strategy is Collectively Aligned

1. **I volunteer first**: I don't wait for others to cooperate; I'm willing to be one of the m needed.

2. **I'm reliable when pivotal**: If the group needs me to reach threshold, I'm there.

3. **I don't free-ride carelessly**: I only defect when confident the threshold is met without me.

4. **I'm forgiving**: I don't permanently punish defectors; I give chances for collective recovery.

5. **I prioritize group success over individual optimization**: The strategy accepts some personal cost to ensure collective risk is averted.
'''

description_COLLECTIVE_56 = '''
# Collective Risk Dilemma Strategy: "Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to ensure the group reaches the threshold that benefits everyone. The key insight is that in a collective risk dilemma, the worst outcome is failing to meet the threshold—everyone loses the bonus k. My role is to be a reliable cooperator who helps the group succeed, while adapting to observed behavior to avoid being exploited when cooperation is clearly futile.

## Strategy Overview

I default to cooperation, viewing myself as one of the "guardians" who ensure the threshold is met. I only defect when evidence strongly suggests that cooperation cannot achieve the threshold, or in calculated end-game situations where my cooperation would be wasted.

---

## Decision Rules

### Round 1: Unconditional Cooperation

**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent and contribute toward the threshold. If enough players share this mindset, we establish a successful collective from the start.

---

### Rounds 2 through (r-1): Adaptive Threshold Guardian

**Primary Rule: Cooperate by default, defect only when cooperation appears futile.**

#### Calculate "Cooperation Health" after each round:

```
cooperation_count[t] = number of players who cooperated in round t
threshold_met[t] = (cooperation_count[t] >= m)
recent_avg = average cooperation_count over last min(3, t) rounds
```

#### Decision Logic:

```
IF threshold was met last round:
    COOPERATE (reinforce success)

ELSE IF recent_avg >= (m - 1):
    COOPERATE (we're close—my contribution could tip us over)

ELSE IF recent_avg < (m / 2):
    # Cooperation is collapsing—but give it one more chance
    IF I cooperated last round AND threshold_met[t-1] == False:
        DEFECT (avoid repeated futile sacrifice)
    ELSE:
        COOPERATE (one attempt to revive cooperation)

ELSE:
    # Middle ground: cooperation exists but is unstable
    COOPERATE (be the reliable guardian that helps reach threshold)
```

#### Forgiveness Mechanism:
```
IF defected last round AND cooperation_count[t-1] >= (m - 1):
    COOPERATE (others are trying—rejoin the collective effort)
```

---

### Final Round (Round r): Conditional Cooperation

The last round has no future to influence, but collective success still matters.

```
IF threshold was met in majority of previous rounds (> r/2):
    COOPERATE (maintain the successful collective pattern)

ELSE IF cooperation_count in round (r-1) >= m:
    COOPERATE (threshold was just met—sustain it)

ELSE IF cooperation_count in round (r-1) >= (m - 1):
    COOPERATE (I might be the decisive cooperator)

ELSE:
    DEFECT (threshold is clearly unreachable)
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **m = n-1 or m = n** | Always COOPERATE | Nearly everyone must cooperate; be reliable |
| **m very small (m ≤ n/3)** | Follow standard rules, but quicker to defect if threshold consistently unmet | Threshold should be easy to meet |
| **k is very large** | More forgiving; cooperate longer | High stakes justify sacrifice |
| **Only 2 rounds total** | R1: Cooperate, R2: Cooperate if R1 met threshold | Minimal history; default to cooperation |
| **Exactly m cooperators last round (including me)** | COOPERATE | I'm essential—don't abandon |
| **Exactly m cooperators last round (not including me)** | COOPERATE | Join them to provide margin |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return COOPERATE
    
    last_coop_count = count_cooperators(history[-1])
    threshold_met_last = (last_coop_count >= m)
    recent_avg = average_cooperation(history, window=3)
    
    # Final round logic
    if round == r:
        if threshold_met_last or recent_avg >= (m - 1):
            return COOPERATE
        if times_threshold_met(history) > (r - 1) / 2:
            return COOPERATE
        return DEFECT
    
    # Standard rounds
    if threshold_met_last:
        return COOPERATE
    
    if recent_avg >= (m - 1):
        return COOPERATE
    
    if recent_avg < (m / 2):
        if my_last_action == COOPERATE and not threshold_met_last:
            return DEFECT  # Avoid futile repeated sacrifice
        return COOPERATE  # One revival attempt
    
    # Default: be the guardian
    return COOPERATE
```

---

## Why This Strategy is Collectively Minded

1. **Defaults to cooperation**: I assume my role is to help the group succeed, not to extract maximum individual payoff.

2. **Threshold-focused**: Every decision asks "will my cooperation help us reach m?" rather than "what maximizes my payoff?"

3. **Patient and forgiving**: I don't punish defectors—I only stop cooperating when it's clearly futile. One good round from others brings me back.

4. **Provides stability**: By being reliably cooperative, I make it easier for threshold-minded strategies to coordinate around reaching m.

5. **Sacrifices when it matters**: I'll cooperate even when defection pays more individually, if my cooperation could be the difference between meeting and missing the threshold.
'''

description_COLLECTIVE_57 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed to secure the group reward, but not a sucker who cooperates when the threshold is already met or clearly unattainable. I'll cooperate reliably enough to help establish cooperation, but adapt based on observed group behavior.

## Strategy Overview

The strategy operates on three principles:
1. **Be willing to be part of the solution** - Default toward cooperation, especially early
2. **Respond to group dynamics** - Adjust based on whether the threshold is being met
3. **Avoid exploitation** - Don't cooperate alone when others consistently defect

---

## Decision Rules

### Round 1: Cooperative Start
**Action: COOPERATE**

Rationale: With no history, I signal willingness to contribute. This helps establish a cooperative norm and gives me information about others.

### Rounds 2 through (r-1): Adaptive Phase

Calculate the following from the previous round:
- `prev_cooperators`: number of players who cooperated last round
- `threshold_met`: whether prev_cooperators ≥ m

**Decision Logic:**

```
IF threshold was met last round:
    IF I cooperated AND prev_cooperators == m:
        # I was essential - keep cooperating
        COOPERATE
    ELSE IF I cooperated AND prev_cooperators > m:
        # Threshold met with surplus - probabilistically defect
        COOPERATE with probability (m / prev_cooperators)
    ELSE IF I defected AND prev_cooperators == m:
        # Others carried the load exactly - stay defecting but watch
        DEFECT
    ELSE IF I defected AND prev_cooperators > m:
        # Surplus cooperators - stay defecting
        DEFECT

ELSE IF threshold was NOT met last round:
    IF prev_cooperators >= m - 1:
        # We were close! One more push could work
        COOPERATE
    ELSE IF prev_cooperators >= m/2:
        # Moderate cooperation - match the effort
        COOPERATE with probability (prev_cooperators / m)
    ELSE:
        # Very low cooperation - reduce my contribution
        COOPERATE with probability 0.3
```

### Longer-Term Adaptation (after round 3):

Overlay the above with a "cooperation trend" modifier:

```
cooperation_rate = (total cooperations across all players in last 3 rounds) / (3 * n)
threshold_success_rate = (rounds where threshold met in last 3) / 3

IF threshold_success_rate >= 0.67:
    # Group is succeeding - maintain current approach
    Use base decision logic above
    
ELSE IF cooperation_rate < m/n AND threshold_success_rate < 0.33:
    # Group is failing badly - become more cooperative to try to rescue
    Increase cooperation probability by 0.2 (capped at 0.9)
    
ELSE IF I've cooperated 3+ times in last 3 rounds AND threshold never met:
    # I'm being exploited - pull back
    DEFECT this round (punishment/reset signal)
```

### Final Round (Round r): Strategic Calculation

```
recent_cooperators = average cooperators in last 2 rounds

IF recent_cooperators >= m:
    # Threshold likely to be met
    IF recent_cooperators > m + 1:
        DEFECT  # Free ride on established cooperation
    ELSE:
        COOPERATE with probability (m / n)  # Be willing to be essential
        
ELSE IF recent_cooperators >= m - 1:
    # Close to threshold - cooperate to push over
    COOPERATE
    
ELSE:
    # Threshold unlikely - no point sacrificing
    DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| m = n-1 or m = n | Always COOPERATE | Nearly everyone needed; must contribute |
| m = 2 (very low threshold) | Use base logic but bias toward DEFECT after threshold met | Easy to meet; avoid over-contributing |
| k is very large (k > 3) | Bias toward COOPERATE (+0.2 probability) | High reward justifies risk |
| k is barely > 1 | Bias toward DEFECT (-0.1 probability) | Low reward doesn't justify sacrifice |
| All others defected last round | COOPERATE once, then DEFECT if it repeats | Give one chance, then protect self |
| I'm the only defector and threshold met | Continue DEFECT | Others are covering; don't volunteer unnecessarily |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return COOPERATE
    
    prev_coop = count_cooperators(history, round - 1)
    threshold_met = prev_coop >= m
    i_cooperated = my_action(history, round - 1) == COOPERATE
    
    # Final round logic
    if round == r:
        return final_round_decision(history, n, m)
    
    # Base decision from previous round
    if threshold_met:
        if i_cooperated and prev_coop == m:
            base_prob = 1.0
        elif i_cooperated and prev_coop > m:
            base_prob = m / prev_coop
        else:
            base_prob = 0.0
    else:
        if prev_coop >= m - 1:
            base_prob = 1.0
        elif prev_coop >= m / 2:
            base_prob = prev_coop / m
        else:
            base_prob = 0.3
    
    # Long-term adjustment (after round 3)
    if round > 3:
        base_prob = apply_trend_modifier(base_prob, history, n, m)
    
    # k-value adjustment
    if k > 3:
        base_prob = min(1.0, base_prob + 0.2)
    elif k < 1.5:
        base_prob = max(0.0, base_prob - 0.1)
    
    return COOPERATE if random() < base_prob else DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **Starts cooperative** - Gives the group a chance to form cooperation
2. **Aims to be part of exactly m** - Doesn't over-contribute or under-contribute
3. **Responds to group needs** - Cooperates more when threshold is close but not met
4. **Forgives and re-engages** - Doesn't permanently punish after failures
5. **Shares the burden** - Uses probabilistic cooperation to distribute costs fairly over time
'''

description_COLLECTIVE_58 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the minimum viable coalition needed for success, while adapting to observed behavior to avoid both exploitation and coordination failure. The key insight is that exactly m cooperators is optimal for the group—more is wasteful, fewer is catastrophic.

## Decision Framework

### Primary Decision Rule

**Cooperate if and only if:**
1. My cooperation is likely *necessary* to reach threshold m, AND
2. There's sufficient evidence that m-1 others will also cooperate

**Defect if:**
1. The threshold will likely be met without me, OR
2. The threshold is unreachable regardless of my choice

---

## Detailed Strategy Specification

### Round 1: Probabilistic Commitment

With no history, I use a **proportional commitment rule**:

```
cooperation_probability = m / n
```

This is collectively rational: if all n players independently cooperate with probability m/n, the expected number of cooperators is exactly m. I commit to cooperation with this probability, determined by a hash of game parameters and my player index for consistency.

**Pseudocode:**
```
seed = hash(n, m, k, r, my_player_id)
if random(seed) < m/n:
    first_round_disposition = COOPERATE
else:
    first_round_disposition = DEFECT
```

### Rounds 2 through r-1: Adaptive Response

After observing history, I calculate and respond to the **cooperation climate**:

```
Define:
  cooperators_last_round = count of players who played C in round t-1
  cooperation_rate = average cooperation rate across all previous rounds
  threshold_met_rate = fraction of past rounds where ≥m cooperated
```

**Decision Logic:**

```
IF cooperators_last_round >= m + 2:
    # Threshold comfortably met - I can safely defect this round
    # (avoiding over-contribution while staying ready to step up)
    ACTION = DEFECT
    
ELIF cooperators_last_round == m OR cooperators_last_round == m + 1:
    # Threshold barely met - maintain if I was cooperating, stay out if not
    IF my_last_action == COOPERATE:
        ACTION = COOPERATE  # Don't abandon a working coalition
    ELSE:
        ACTION = DEFECT  # Don't crowd in unnecessarily
        
ELIF cooperators_last_round == m - 1:
    # One short! This is critical - step up
    ACTION = COOPERATE
    
ELIF cooperators_last_round < m - 1:
    # Significant shortfall - assess viability
    IF cooperation_rate >= (m-1)/n AND threshold_met_rate > 0.3:
        # There's hope - contribute to recovery
        ACTION = COOPERATE
    ELSE:
        # Coordination has collapsed - defect to minimize losses
        ACTION = DEFECT
```

### Final Round (Round r): Modified Calculation

The last round removes future shadow, but collective success still matters:

```
IF cooperators_in_round_r-1 >= m:
    # Cooperation is established - mirror my previous action
    ACTION = my_action_in_round_r-1
    
ELIF cooperators_in_round_r-1 == m - 1 AND I defected last round:
    # I could be the pivotal player
    IF threshold_met_rate >= 0.5:
        ACTION = COOPERATE  # Reward past collective success
    ELSE:
        ACTION = DEFECT
        
ELSE:
    # Use base probability with slight cooperative bias for final round
    ACTION = COOPERATE with probability min(m/n + 0.1, 1.0)
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| m = n-1 or m = n | Higher cooperation probability | Near-universal cooperation required |
| m ≤ n/3 | Lower cooperation probability | Small coalitions suffice |
| k is very high (k > 3) | Bias toward cooperation | Reward justifies contribution risk |
| Consistent threshold failure | Gradual withdrawal | Avoid repeated exploitation |
| Oscillating patterns observed | Maintain steady cooperation rate | Don't amplify instability |

---

## Summary

**Adaptive Threshold Guardian** acts as a responsible collective member who:
- Takes their fair share of cooperation burden (probabilistically in round 1)
- Steps up when the coalition needs one more member
- Steps back when the coalition is secure
- Doesn't abandon a working coalition
- Recognizes and withdraws from hopeless coordination failures

The strategy is **robust** because it doesn't assume others share its logic, **adaptive** because it responds to actual observed behavior, and **collective** because it prioritizes reaching exactly the efficient threshold over individual exploitation.
'''

description_COLLECTIVE_59 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be a reliable cooperator who helps the group reach the threshold, while protecting against exploitation. The key insight is that in this game, **reaching the threshold benefits everyone**, so my goal is to be part of the solution while adapting to how many others share this commitment.

## Strategy Overview

I use a **reputation-based probabilistic cooperation** approach that:
1. Starts optimistically to signal cooperative intent
2. Tracks the cooperation rate of the collective
3. Adjusts my cooperation probability to help meet the threshold
4. Accounts for end-game dynamics

---

## Decision Rules

### Round 1: Cooperative Signal
**Action: Cooperate (C)**

Rationale: With no history, I signal that I'm willing to contribute to the collective good. This establishes trust and encourages threshold formation.

### Rounds 2 through (r-1): Adaptive Cooperation

**Calculate the following:**

```
historical_cooperation_rate = (total C plays by all players) / (total plays so far)
expected_cooperators = historical_cooperation_rate × n
cooperation_gap = m - expected_cooperators
```

**Decision Logic:**

```
IF expected_cooperators >= m + 1:
    # Threshold likely met without me - safe to occasionally defect
    cooperate_probability = max(0.3, (m / n))
    
ELSE IF expected_cooperators >= m - 1 AND expected_cooperators < m + 1:
    # I'm potentially pivotal - cooperate reliably
    cooperate_probability = 0.9
    
ELSE IF expected_cooperators < m - 1:
    # Threshold unlikely to be met
    # But maintain some cooperation to encourage others
    cooperate_probability = min(0.6, m / n + 0.2)

# Adjustment for recent trends (last 3 rounds if available)
IF recent_cooperation_rate > historical_cooperation_rate + 0.1:
    # Cooperation trending up - reinforce it
    cooperate_probability = min(1.0, cooperate_probability + 0.15)
    
ELSE IF recent_cooperation_rate < historical_cooperation_rate - 0.1:
    # Cooperation declining - still try to stabilize
    cooperate_probability = min(1.0, cooperate_probability + 0.1)
```

**Execute:** Cooperate with the calculated probability.

### Final Round (Round r): Threshold-Focused

```
IF historical_cooperation_rate × n >= m - 0.5:
    # Threshold has been achievable - maintain cooperation
    cooperate_probability = 0.7
ELSE:
    # Threshold rarely met - limited value in cooperating
    cooperate_probability = 0.3
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| **n = 2, m = 2** | Cooperate always (both must cooperate) |
| **m = n - 1 or m = n** | Cooperate with probability 0.85+ (near-universal cooperation needed) |
| **m very small (m ≤ n/3)** | Base cooperation at m/n, adjust upward if threshold not being met |
| **k very large (k > 3)** | Increase all cooperation probabilities by 0.1 (higher stakes) |
| **r = 2** | Cooperate round 1; round 2 use final round logic |
| **Perfect cooperation observed (100%)** | Cooperate (maintain the equilibrium) |
| **Zero cooperation observed** | Cooperate with probability 0.4 (attempt to seed cooperation) |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE
    
    hist_coop_rate = total_cooperations(history) / total_actions(history)
    expected_coop = hist_coop_rate * n
    
    # Base probability
    if expected_coop >= m + 1:
        p = max(0.3, m / n)
    elif expected_coop >= m - 1:
        p = 0.9  # Pivotal zone
    else:
        p = min(0.6, m / n + 0.2)
    
    # Trend adjustment
    if round > 3:
        recent_rate = cooperation_rate(last_3_rounds(history))
        if recent_rate > hist_coop_rate + 0.1:
            p = min(1.0, p + 0.15)
        elif recent_rate < hist_coop_rate - 0.1:
            p = min(1.0, p + 0.1)
    
    # Final round adjustment
    if round == r:
        p = 0.7 if expected_coop >= m - 0.5 else 0.3
    
    # High stakes adjustment
    if k > 3:
        p = min(1.0, p + 0.1)
    
    return COOPERATE if random() < p else DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Threshold-focused**: The strategy prioritizes reaching m cooperators, which benefits everyone
2. **Not exploitable**: Reduces cooperation when others free-ride excessively
3. **Encourages cooperation**: Maintains baseline cooperation even in hostile environments to seed potential turnarounds
4. **Pivotal awareness**: Cooperates most reliably when my contribution is likely decisive
5. **Adaptive**: Responds to actual group behavior rather than assumptions
'''

description_COLLECTIVE_60 = '''
# Collective Risk Dilemma: Adaptive Threshold Strategy

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that the best outcomes occur when exactly m players cooperate each round (maximizing group payoff while meeting the threshold). However, without communication, I must use observable history to implicitly coordinate toward this outcome while protecting against exploitation.

## Strategy Overview

I employ a **probabilistic cooperation approach** that adapts based on:
1. The structural parameters of the game
2. The observed cooperation rate in previous rounds
3. My position in the game (early, middle, late rounds)

---

## Decision Rules

### Round 1: Baseline Cooperation Probability

With no history, I cooperate with probability:

```
P(cooperate) = m/n + ε
```

Where ε = 0.1 (small buffer to help ensure threshold is met)

**Rationale**: If all players reason similarly, we'd expect roughly m cooperators on average, which is exactly what's needed. The buffer accounts for variance and demonstrates good faith.

---

### Rounds 2 through (r-1): Adaptive Response

**Step 1: Calculate cooperation metrics from previous round(s)**
```
observed_cooperators = count of C plays last round
cooperation_rate = observed_cooperators / n
threshold_met = (observed_cooperators >= m)
```

**Step 2: Determine my base probability**

```
If threshold_met last round:
    If observed_cooperators > m + 1:
        # Over-contribution: slightly reduce cooperation
        P_base = m/n - 0.05
    Else:
        # Near optimal: maintain similar behavior
        P_base = m/n + 0.05
Else (threshold NOT met):
    # Under-contribution: increase cooperation significantly
    P_base = min(0.9, (m/n) + 0.2 + 0.1 * (m - observed_cooperators))
```

**Step 3: Apply reputation adjustment**

Track the "collective reliability score" over all previous rounds:
```
reliability = (rounds where threshold met) / (total rounds played)

If reliability > 0.7:
    # Group is functioning well, can be slightly more strategic
    P_adjust = P_base - 0.05
Else if reliability < 0.4:
    # Group struggling, increase my contribution
    P_adjust = min(0.95, P_base + 0.15)
Else:
    P_adjust = P_base
```

**Step 4: Final cooperation decision**
```
Cooperate if random() < P_adjust
```

---

### Final Round (Round r): Modified Endgame

The last round has no shadow of the future, creating defection incentives. My approach:

```
If reliability >= 0.6 over previous rounds:
    # Group has been cooperative - maintain cooperation
    P(cooperate) = m/n + 0.1
Else if reliability >= 0.4:
    # Mixed results - cooperate at baseline
    P(cooperate) = m/n
Else:
    # Group has been largely defecting - reduce but don't abandon
    P(cooperate) = max(0.2, m/n - 0.15)
```

**Rationale**: Even in the last round, I don't fully defect. Maintaining some cooperation probability reflects commitment to collective outcomes and accounts for uncertainty about others' strategies.

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **m = n-1** (nearly all must cooperate) | Add extra buffer: ε = 0.15 |
| **m = 2** (low threshold) | Reduce buffer: ε = 0.05 |
| **k is very large (k > 3)** | Increase all cooperation probabilities by 0.1 (reward justifies risk) |
| **k is small (k < 1.5)** | Standard probabilities (threshold meeting still valuable) |
| **Observed wild swings in cooperation** | Add momentum factor: bias toward last round's personal action |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    
    if round == 1:
        return cooperate_with_prob(m/n + 0.1)
    
    last_round_coop = count_cooperators(history[-1])
    reliability = threshold_met_rate(history, m)
    
    # Base probability
    if last_round_coop >= m:
        p_base = m/n + 0.05 if last_round_coop <= m+1 else m/n - 0.05
    else:
        p_base = min(0.9, m/n + 0.2 + 0.1*(m - last_round_coop))
    
    # Reliability adjustment
    if reliability > 0.7:
        p_final = p_base - 0.05
    elif reliability < 0.4:
        p_final = min(0.95, p_base + 0.15)
    else:
        p_final = p_base
    
    # Last round modification
    if round == r:
        if reliability < 0.4:
            p_final = max(0.2, p_final - 0.15)
    
    return cooperate_with_prob(p_final)
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: Probabilistic approach naturally distributes cooperation burden across players
2. **Responsive**: Increases cooperation when threshold is missed, prevents over-contribution when exceeded
3. **Forgiving**: Doesn't permanently punish past defection—always maintains cooperation probability
4. **Stable**: Converges toward exactly m cooperators when others use similar reasoning
5. **Exploitation-resistant**: Never fully defects, but also never guaranteed to cooperate (can't be reliably exploited)
'''

description_COLLECTIVE_61 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed to secure the collective reward, but not a surplus cooperator who could have free-ridden. The strategy adapts to observed cooperation levels, rewarding cooperative environments while protecting against exploitation.

## Strategy Overview

The strategy uses a **probabilistic cooperation approach** calibrated to achieve exactly *m* cooperators in expectation, combined with **reputation tracking** that adjusts based on observed group behavior.

---

## Decision Rules

### Key Variables

- `base_prob`: The baseline probability of cooperation = m/n (fair share)
- `coop_rate`: Observed cooperation rate from previous rounds
- `rounds_remaining`: Number of rounds left including current
- `my_coop_count`: How many times I've cooperated
- `group_coop_avg`: Average number of cooperators per round

### Round-by-Round Decision

```
function decide(round, history, parameters):
    n, r, m, k = parameters
    
    if round == 1:
        return FIRST_ROUND_RULE
    
    if round == r:
        return LAST_ROUND_RULE
    
    return ADAPTIVE_RULE
```

---

## Rule Specifications

### FIRST_ROUND_RULE
**Cooperate with probability m/n**

Rationale: With no history, the fair collective share is m/n. This signals willingness to cooperate while not over-committing. Use a deterministic hash of player identity (if available) or seeded randomness to ensure exactly m players cooperate in expectation.

```
prob_cooperate = m / n
return COOPERATE if random() < prob_cooperate else DEFECT
```

### LAST_ROUND_RULE
**Cooperate only if cooperation has been reciprocated historically**

```
if group_coop_avg >= m:
    # Group has been meeting threshold - continue contributing fairly
    prob_cooperate = m / n
else:
    # Group has failed to coordinate - protect self
    prob_cooperate = max(0, (m/n) - 0.2)
    
return COOPERATE if random() < prob_cooperate else DEFECT
```

### ADAPTIVE_RULE (Main Logic)

```
function adaptive_decision(round, history):
    
    # Calculate observed cooperation rate
    total_cooperations = sum(cooperators in each past round)
    total_actions = (round - 1) * n
    coop_rate = total_cooperations / total_actions
    
    # Calculate how often threshold was met
    threshold_met_rate = (rounds where cooperators >= m) / (round - 1)
    
    # Calculate my fair share of remaining cooperation needed
    expected_total_coops_needed = m * r
    total_coops_so_far = total_cooperations
    my_coops_so_far = count(my cooperations)
    
    # Adjust probability based on environment
    
    # Base: fair share
    base_prob = m / n
    
    # Adjustment 1: Reactive to group behavior
    if coop_rate > m/n:
        # Others are over-cooperating - slight reduction is safe
        adjustment_1 = -0.1 * (coop_rate - m/n) / (1 - m/n)
    else:
        # Under-cooperation - increase to help reach threshold
        adjustment_1 = +0.15 * (m/n - coop_rate) / (m/n)
    
    # Adjustment 2: Threshold success rate
    if threshold_met_rate >= 0.8:
        # Things are working - maintain
        adjustment_2 = 0
    elif threshold_met_rate >= 0.5:
        # Borderline - slightly increase
        adjustment_2 = +0.1
    else:
        # Failing badly - significant increase if k justifies it
        if k >= 2:
            adjustment_2 = +0.2
        else:
            adjustment_2 = +0.05  # Less worth saving
    
    # Adjustment 3: Personal contribution balance
    my_fair_share_so_far = (m/n) * (round - 1)
    if my_coops_so_far > my_fair_share_so_far + 1:
        # I've over-contributed
        adjustment_3 = -0.15
    elif my_coops_so_far < my_fair_share_so_far - 1:
        # I've under-contributed
        adjustment_3 = +0.15
    else:
        adjustment_3 = 0
    
    # Final probability (bounded)
    final_prob = clamp(base_prob + adjustment_1 + adjustment_2 + adjustment_3, 0.05, 0.95)
    
    return COOPERATE if random() < final_prob else DEFECT
```

---

## Edge Case Handling

| Scenario | Behavior |
|----------|----------|
| **Round 1** | Cooperate with probability m/n |
| **Last round** | Slightly more cautious; base on historical reciprocation |
| **m = n-1** | High cooperation needed; increase base probability to ~0.9 |
| **m = 2, n large** | Low cooperation needed; use base m/n but maintain floor of 0.1 |
| **k very large (>3)** | Increase cooperation probability by 0.1 (high stakes) |
| **Threshold never met** | After 3 consecutive failures, increase cooperation by 0.2 |
| **Threshold always met with surplus** | Gradually decrease probability (others can cover) |

---

## Collective Alignment Principles

1. **Fair Share Default**: Start with m/n cooperation probability—everyone doing their proportional part.

2. **Compensatory Behavior**: If group is under-cooperating, increase own cooperation to help reach threshold (collective benefit > individual cost when k > 1).

3. **Anti-Exploitation Floor**: Never drop below 5% cooperation probability—maintain hope of coordination.

4. **No Grudges**: Don't punish past defection excessively; each round is a fresh opportunity for collective success.

5. **Threshold-Focused**: The goal is exactly m cooperators—surplus cooperation is waste, deficit is disaster.

---

## Summary

This strategy acts as a **responsible collective member** that:
- Contributes its fair share by default
- Increases contribution when the group needs help reaching threshold
- Slightly reduces contribution when others are over-cooperating
- Maintains enough cooperation to never be the sole cause of collective failure
- Adapts continuously based on observed group dynamics
'''

description_COLLECTIVE_62 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of a reliable coalition of m cooperators, contributing when my cooperation is likely needed and valuable, while avoiding wasteful over-contribution when the threshold is already secure or hopelessly unmet.

## Strategic Framework

### Key Insight

The fundamental tension is that:
- We need exactly m cooperators to unlock the bonus k for everyone
- Having more than m cooperators is inefficient (extra cooperators sacrifice their private payoff unnecessarily)
- Having fewer than m means everyone loses the bonus

A truly collective strategy should aim to be one of the m cooperators when needed, but coordinate implicitly to avoid redundancy.

---

## Decision Rules

### Round 1: Probabilistic Seeding

With no history, cooperate with probability `m/n`.

**Rationale:** If all players used this rule, we'd expect exactly m cooperators on average. This is the collectively optimal starting point and signals willingness to cooperate.

### Rounds 2 through (r-1): Adaptive Response

**Step 1: Count cooperation from previous round**
- Let `c_prev` = number of players who cooperated last round

**Step 2: Determine my role based on cooperation landscape**

```
IF c_prev >= m:
    # Threshold was met - system is healthy
    IF I cooperated last round:
        # I was part of the coalition - stay reliable
        Cooperate with probability: max(m/n, m/c_prev)
    ELSE:
        # I defected while others carried the load
        # Offer to share the burden - cooperate with probability m/n
        Cooperate with probability: m/n

ELSE IF c_prev > 0 AND c_prev < m:
    # Threshold missed but there's hope - we need more cooperators
    IF I cooperated last round:
        # I tried but we fell short - stay committed, rally others
        Cooperate
    ELSE:
        # I was part of the problem - step up
        # Probability increases as we get closer to threshold
        Cooperate with probability: (m - c_prev + 1) / (n - c_prev)

ELSE (c_prev == 0):
    # Complete cooperation collapse
    # Attempt restart with baseline probability, slightly elevated
    Cooperate with probability: min(1, (m + 1) / n)
```

**Step 3: Reputation adjustment**

Track each player's cooperation rate over all observed rounds. Let `avg_coop_rate` = average cooperation rate across all players.

```
IF avg_coop_rate < m/n - 0.1:
    # Population is under-cooperating - increase my contribution
    Increase cooperation probability by 0.1

IF avg_coop_rate > (m + 2)/n:
    # Population is over-cooperating - some can safely defect
    Decrease cooperation probability by 0.05
```

### Final Round (Round r): Calculated Commitment

The last round has no future consequences, creating defection incentives. Counter this:

```
IF my_total_cooperation_rate >= 0.5:
    # I've been a cooperator - finish strong for collective benefit
    Cooperate with probability: m/n (baseline duty)
    
ELSE:
    # I've been a free-rider - last chance for collective success
    Cooperate with probability: m/n
```

**Key principle:** Don't dramatically change behavior in the final round. Consistency matters for implicit coordination.

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| `m = n-1` (nearly everyone needed) | Bias toward cooperation; cooperate with prob ≥ 0.8 |
| `m = 2` (low threshold) | More willing to defect when others cooperate; cooperate with prob closer to 2/n |
| `k` is very large | Slightly increase cooperation probability (stakes are higher) |
| `k` is barely > 1 | Slightly decrease cooperation probability (reward barely exceeds cost) |
| Observed perfect coordination last round (exactly m cooperators) | Maintain current behavior - don't disrupt success |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return cooperate_with_prob(m / n)
    
    c_prev = count_cooperators(history, round - 1)
    i_cooperated = my_action(history, round - 1) == C
    avg_coop = average_cooperation_rate(history)
    
    # Base probability calculation
    if c_prev >= m:
        if i_cooperated:
            base_prob = max(m/n, m/c_prev)
        else:
            base_prob = m/n
    elif c_prev > 0:
        if i_cooperated:
            base_prob = 1.0
        else:
            base_prob = (m - c_prev + 1) / (n - c_prev)
    else:
        base_prob = min(1, (m + 1) / n)
    
    # Population adjustment
    if avg_coop < m/n - 0.1:
        base_prob += 0.1
    elif avg_coop > (m + 2)/n:
        base_prob -= 0.05
    
    # Clamp and execute
    final_prob = clamp(base_prob, 0, 1)
    return cooperate_with_prob(final_prob)
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing:** Naturally gravitates toward m cooperators without explicit coordination
2. **Responsive:** Increases contribution when cooperation is scarce, reduces when abundant
3. **Forgiving:** Doesn't permanently punish defection; allows population recovery
4. **Stable:** Consistent cooperators remain reliable anchors for the collective
5. **Efficient:** Avoids wasteful over-cooperation while ensuring threshold is met
'''

description_COLLECTIVE_63 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I recognize that my individual success is fundamentally tied to collective success. The goal is not to maximize my personal payoff at others' expense, but to ensure the threshold is met reliably while being resilient to defectors. I aim to be a dependable cooperator who adapts to the group's behavior patterns.

## Strategy Overview

The strategy operates on three principles:
1. **Start cooperatively** to establish trust and ensure early threshold success
2. **Monitor and adapt** based on whether the collective is meeting thresholds
3. **Maintain commitment** unless cooperation becomes futile

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, I signal willingness to contribute to the collective good. This gives the group the best chance of meeting the threshold early and establishing a cooperative norm.

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate the following from the previous round's history:

```
num_cooperators_last = count of players who played C in previous round
threshold_met_last = (num_cooperators_last >= m)
cooperation_rate = num_cooperators_last / n
```

**Decision Logic:**

```
IF threshold_met_last:
    # Success! Continue cooperating to maintain it
    ACTION = COOPERATE
    
ELIF cooperation_rate >= (m-1)/n:
    # We were close - my cooperation might tip us over
    ACTION = COOPERATE
    
ELIF cooperation_rate > 0:
    # Some cooperation exists - check if trend is improving
    IF rounds_played >= 2:
        prev_cooperation_rate = cooperators_two_rounds_ago / n
        IF cooperation_rate >= prev_cooperation_rate:
            # Stable or improving - stay committed
            ACTION = COOPERATE
        ELSE:
            # Declining cooperation - but don't abandon yet
            # Cooperate with probability based on how close we are to threshold
            cooperation_probability = cooperation_rate / ((m-1)/n)
            ACTION = COOPERATE with probability cooperation_probability
    ELSE:
        ACTION = COOPERATE
        
ELSE:
    # Zero cooperation from others - still give one more chance
    IF this is first time seeing zero cooperation:
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT
```

### Final Round (Round r): Conditional Cooperation

The last round has no shadow of the future, but collective success still matters.

```
recent_threshold_success_rate = (times threshold met in last min(3, r-1) rounds) / min(3, r-1)

IF recent_threshold_success_rate >= 0.5:
    # Group has been succeeding - contribute to finish strong
    ACTION = COOPERATE
ELIF num_cooperators_last >= m - 1:
    # We're one away from threshold - be the difference
    ACTION = COOPERATE
ELSE:
    # Threshold consistently unmet - cooperating is futile
    ACTION = DEFECT
```

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | Cooperate both rounds unless R1 had 0 other cooperators | Too short to learn; default to cooperation |
| m = n-1 or m = n (high threshold) | Always cooperate | Every cooperator is critical; can't afford to defect |
| m = 2 (low threshold) | Follow standard rules but lean toward cooperation | Low threshold makes success likely |
| Exactly m cooperators consistently | Continue cooperating | Don't risk breaking a fragile equilibrium |
| Oscillating success/failure | Cooperate | Stability requires consistent contributors |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    
    if round_num == 1:
        return COOPERATE
    
    last_round = history[-1]
    coop_count = count_cooperators(last_round)
    threshold_met = coop_count >= m
    coop_rate = coop_count / n
    
    # Final round logic
    if round_num == total_rounds:
        recent_success = threshold_success_rate(history, window=3)
        if recent_success >= 0.5 or coop_count >= m - 1:
            return COOPERATE
        return DEFECT
    
    # Standard rounds
    if threshold_met:
        return COOPERATE
    
    if coop_rate >= (m - 1) / n:
        return COOPERATE
    
    if coop_rate > 0:
        if len(history) >= 2:
            prev_coop_rate = count_cooperators(history[-2]) / n
            if coop_rate >= prev_coop_rate:
                return COOPERATE
            else:
                prob = coop_rate / ((m - 1) / n)
                return COOPERATE with probability prob
        return COOPERATE
    
    # Zero cooperators last round
    if count_zero_coop_rounds(history) <= 1:
        return COOPERATE
    return DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **Bias toward cooperation**: The strategy defaults to cooperation and requires consistent evidence of futility before defecting.

2. **Forgiveness**: Even after failures, improving trends restore full cooperation.

3. **No exploitation**: I never strategically defect to free-ride when I expect others to meet the threshold—if threshold is met, I contributed.

4. **Threshold awareness**: The strategy understands that being the m-th cooperator is valuable to everyone, including myself.

5. **Stability over optimization**: Rather than calculating exact personal payoff maximization, the strategy prioritizes reliable threshold achievement, which benefits the collective.
'''

description_COLLECTIVE_64 = '''
# Collective Risk Dilemma Strategy: "Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be a reliable cooperator who helps the group reach the threshold, while protecting against scenarios where cooperation is either unnecessary (threshold already met by others) or futile (threshold impossible to reach). The strategy assumes other players may share similar cooperative instincts and uses observed behavior to estimate how many "like-minded" cooperators exist.

---

## Decision Rules

### Key Variables Tracked
- `coop_counts[t]`: number of cooperators in round t
- `my_history[t]`: my action in round t (C or D)
- `rounds_remaining`: r - current_round
- `estimated_base_cooperators`: players who consistently cooperate

### Round-by-Round Logic

#### **First Round: Signal Cooperative Intent**
```
COOPERATE
```
Rationale: Establish myself as a willing contributor. This creates information for everyone and signals collective orientation.

---

#### **Middle Rounds (2 to r-1): Adaptive Threshold Maintenance**

```
Let recent_coop = average cooperators over last min(3, rounds_played) rounds
Let reliable_coops = count of players who cooperated in ≥ 70% of rounds so far

If reliable_coops >= m:
    # Threshold likely secure - I can safely cooperate
    COOPERATE
    
Else if reliable_coops == m - 1:
    # I might be pivotal - my cooperation could make the difference
    COOPERATE
    
Else if reliable_coops < m - 1:
    # Need to assess if threshold is achievable
    If recent_coop >= m:
        # Recent rounds suggest threshold is being met
        COOPERATE
    Else if recent_coop == m - 1:
        # Close to threshold - contribute to push us over
        COOPERATE
    Else if recent_coop < m - 1 AND recent_coop is declining over last 2 rounds:
        # Cooperation is collapsing - defect to preserve resources
        DEFECT
    Else:
        # Uncertain situation - cooperate to encourage coordination
        COOPERATE
```

#### **Forgiveness Mechanism**
```
If I defected last round AND coop_counts increased:
    # Others are trying to rebuild cooperation
    COOPERATE (override above rules)
```

---

#### **Final Round: Calculated Commitment**

```
Let final_reliable = count of players who cooperated in ≥ 60% of all rounds

If final_reliable >= m:
    # Expect threshold to be met regardless
    DEFECT (maximize personal gain while group succeeds)
    
Else if final_reliable == m - 1:
    # I'm likely pivotal
    COOPERATE
    
Else if final_reliable < m - 1:
    # Threshold unlikely - but check recent momentum
    If coop_counts[r-1] >= m:
        # Last round met threshold, might hold
        COOPERATE
    Else:
        DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| **n = m** (all must cooperate) | Always COOPERATE | Everyone is pivotal; defection guarantees failure |
| **m = 2, n large** | Follow standard rules | Low threshold makes cooperation easier to sustain |
| **k is very large** | Bias toward COOPERATE | High collective reward justifies contribution risk |
| **k barely > 1** | More cautious, follow rules strictly | Lower reward means free-riding is more tempting for others |
| **r = 2** (minimal rounds) | Round 1: C, Round 2: use final round logic | Limited information, act on priors then optimize |
| **Everyone defected last round** | COOPERATE | Attempt to restart coordination; someone must try |

---

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return COOPERATE
    
    recent_coop = avg_cooperators(history, window=3)
    reliable_coops = count_reliable(history, threshold=0.7)
    
    if round == r:  # Final round
        reliable_final = count_reliable(history, threshold=0.6)
        if reliable_final >= m:
            return DEFECT
        elif reliable_final == m - 1:
            return COOPERATE
        elif history[r-1].coop_count >= m:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if reliable_coops >= m - 1:
        return COOPERATE
    elif recent_coop >= m - 1:
        return COOPERATE
    elif recent_coop < m - 1 and is_declining(history):
        return DEFECT
    else:
        return COOPERATE
```

---

## Collective Alignment Statement

This strategy prioritizes **being a dependable threshold-maker**. It recognizes that:
1. The collective succeeds only if enough players commit
2. Being pivotal (the m-th cooperator) is valuable
3. Sustained cooperation requires trust-building through consistent action
4. Wholesale defection helps no one when others are trying

I default to cooperation because **someone must anchor the group's coordination**. I defect only when evidence strongly suggests the threshold cannot be met, or when it's clearly secure without me in the final moment.
'''

description_COLLECTIVE_65 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume other rational players share the goal of achieving the threshold while minimizing individual cost. The strategy coordinates implicitly through observable behavior, adapts to the actual cooperation patterns observed, and balances between ensuring collective success and avoiding exploitation.

## Decision Rules

### Round 1: Probabilistic Fair Share

With no history to guide decisions, I cooperate with probability `m/n` (the fair share probability that, if all players used it, would yield exactly m cooperators in expectation).

**Rationale:** This creates a natural implicit coordination point. If all players reason similarly, we get approximately the right number of cooperators without over-contributing.

### Middle Rounds (2 to r-1): Adaptive Response

I track two key metrics from history:
- **Cooperation rate:** Average number of cooperators per round
- **Threshold success rate:** Proportion of rounds where threshold was met

**Decision logic:**

```
Let avg_cooperators = average cooperators across all previous rounds
Let success_rate = fraction of previous rounds meeting threshold
Let my_coop_rate = fraction of previous rounds where I cooperated

IF success_rate == 1.0 (always succeeded):
    # Threshold consistently met - test if I can free-ride
    IF avg_cooperators > m + 1:
        # Surplus cooperators - safe to defect occasionally
        Cooperate with probability: max(0.2, (m / avg_cooperators))
    ELSE:
        # Barely meeting threshold - maintain cooperation
        Cooperate with probability: m/n

ELSE IF success_rate >= 0.7 (usually succeeded):
    # Mostly working but some failures
    IF I cooperated last round AND threshold was met:
        Cooperate with probability: 0.7
    ELSE:
        Cooperate with probability: min(0.9, m/n + 0.2)

ELSE IF success_rate >= 0.3 (mixed results):
    # Group is struggling - increase my contribution
    Cooperate with probability: min(0.95, (m/n) + (1 - success_rate) * 0.5)

ELSE (success_rate < 0.3 - frequent failure):
    # Near collapse - emergency cooperation boost
    IF avg_cooperators >= m - 1:
        # We're close - push for success
        Cooperate with probability: 0.9
    ELSE:
        # Others largely defecting - limit losses but keep trying
        Cooperate with probability: 0.5
```

### Final Round (r): Threshold-Focused

The last round has no shadow of the future, changing incentives:

```
Let recent_avg = average cooperators in last 3 rounds (or all if r < 4)

IF recent_avg >= m + 1:
    # Expect threshold to be met without me
    Defect (probability 0)
ELSE IF recent_avg >= m - 0.5:
    # Marginal - my cooperation might be pivotal
    Cooperate with probability: 0.8
ELSE:
    # Unlikely to meet threshold regardless
    Cooperate with probability: 0.3  # Small chance others also boost
```

## Edge Cases

### Very Small Groups (n ≤ 3)
When n is tiny, each player is highly pivotal. Increase base cooperation probability by 0.2 across all rules.

### High Threshold Ratio (m/n > 0.7)
Collective action is harder when most must cooperate. Add 0.15 to all cooperation probabilities.

### Large Reward (k > 2)
When stakes are high, cooperation becomes more valuable. Scale cooperation probabilities up by factor `min(1.5, k/2)`.

### Short Games (r ≤ 3)
Limited learning opportunity - use more aggressive cooperation (add 0.1 to probabilities) to establish patterns quickly.

## Summary

The strategy acts as a "guardian" of the collective threshold:
1. **Starts fair** - contributes proportional share initially
2. **Rewards success** - maintains cooperation when group succeeds
3. **Responds to crisis** - increases contribution when group struggles
4. **Avoids exploitation** - reduces cooperation if clear surplus exists
5. **Stays adaptive** - never fully commits to pure cooperation or defection
'''

description_COLLECTIVE_66 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of exactly m cooperators when possible, contributing when needed but not wastefully over-contributing. The strategy balances reliability (being someone others can count on) with efficiency (not cooperating when others already have it covered).

## Decision Framework

### Key Observations

1. **The coordination problem**: We need exactly m cooperators—fewer fails, more is wasteful (cooperators get k while defectors get 1+k)
2. **Without communication**: We must use observable history to implicitly coordinate
3. **Collective success requires reliability**: If everyone tries to free-ride, everyone loses

### Player Role Assignment (Deterministic from History)

Since we cannot communicate, I use a **history-based priority ordering** to determine who "should" cooperate:

**Priority Score for player i in round t:**
```
priority_i(t) = (cooperation_rate_i × 1000) + (recent_cooperation_weight_i × 100) + (player_index_i)
```

Where:
- `cooperation_rate_i` = total cooperations by i / rounds played
- `recent_cooperation_weight_i` = cooperations in last 3 rounds / 3
- `player_index_i` = tiebreaker (lower index = higher priority)

**The top m players by priority score are the "designated cooperators" for round t.**

---

## Decision Rules

### Round 1 (No History)

**Cooperate if my player index ≤ m**

Rationale: With no history, use index-based coordination. This gives exactly m cooperators if all players use this strategy.

### Rounds 2 through (r-1) (Middle Rounds)

**Step 1: Calculate priority scores for all players based on history**

**Step 2: Determine if I'm a designated cooperator (in top m by priority)**

**Step 3: Apply adaptive adjustment:**

```
IF I am a designated cooperator:
    Cooperate
ELSE IF (number of cooperators in previous round < m):
    # Threshold wasn't met - system needs more contributors
    Cooperate with probability = (m - prev_cooperators) / (n - m)
ELSE IF (my historical cooperation rate < average cooperation rate - 0.15):
    # I've been free-riding too much relative to the group
    Cooperate
ELSE:
    Defect
```

### Final Round (Round r)

**Standard game theory suggests defection, but collective thinking suggests otherwise:**

```
IF I am a designated cooperator (top m by priority):
    Cooperate  # Honor my role to the end
ELSE:
    Defect
```

Rationale: Maintaining exactly m cooperators remains optimal even in the final round—the payoff structure doesn't change.

---

## Edge Case Handling

### Edge Case 1: Threshold Never Met (Persistent Failure)
```
IF threshold not met for 3+ consecutive rounds:
    Cooperate regardless of designation
    # Better to over-contribute than collectively fail
```

### Edge Case 2: Massive Over-Cooperation
```
IF previous round had (cooperators > m + 2) AND I cooperated:
    Defect this round even if designated
    # Help the group find efficient equilibrium
```

### Edge Case 3: I'm the Swing Vote
```
IF exactly (m-1) players have higher priority than me:
    Always cooperate  # I'm critical to success
```

### Edge Case 4: Extreme Parameters
```
IF m > n/2:
    # Cooperation is heavily required - bias toward C
    Increase base cooperation probability by 0.2

IF m ≤ 2:
    # Only a few needed - be more willing to let others handle it
    Follow strict priority ordering
```

---

## Pseudocode Summary

```python
def decide(round_t, my_index, history, n, m, k, r):
    
    if round_t == 1:
        return COOPERATE if my_index <= m else DEFECT
    
    # Calculate priority scores from history
    priorities = calculate_priorities(history)
    designated = get_top_m_players(priorities, m)
    
    # Check for persistent failure
    if consecutive_failures(history) >= 3:
        return COOPERATE
    
    # Check for over-cooperation correction
    if last_round_cooperators(history) > m + 2 and i_cooperated_last(history):
        return DEFECT
    
    # Main decision
    if my_index in designated:
        return COOPERATE
    else:
        prev_coop = last_round_cooperators(history)
        if prev_coop < m:
            prob = (m - prev_coop) / (n - m)
            return COOPERATE with probability prob
        elif my_cooperation_rate(history) < avg_cooperation_rate(history) - 0.15:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: Priority ordering emerges from behavior, rewarding consistent cooperators with continued responsibility
2. **Responsive**: Adjusts to actual cooperation levels, not assumptions about opponents
3. **Fair over time**: Players who cooperate more gain priority, but this means others eventually take turns
4. **Failure-resistant**: Escalates contribution when the group is failing
5. **Efficiency-seeking**: Aims for exactly m cooperators, not more
'''

description_COLLECTIVE_67 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not a surplus cooperator who enables free-riding. The goal is to reliably meet the threshold while minimizing exploitation by defectors.

## Strategy Overview

I use a **probabilistic cooperation** approach calibrated to the threshold requirement, combined with **adaptive punishment** for environments where cooperation is being exploited.

---

## Decision Rules

### Round 1: Calibrated Random Cooperation

With no history, I cooperate with probability based on being "my fair share" of the threshold:

```
P(cooperate) = min(1, (m + buffer) / n)
where buffer = 1 (to provide slight redundancy for threshold)
```

**Rationale**: If everyone uses this probability, expected cooperators ≈ m+1, giving a safety margin while not over-contributing.

### Rounds 2 through (r-1): Adaptive Cooperation

I track two key metrics from history:
- **cooperation_rate**: fraction of all actions that were C in previous rounds
- **threshold_met_rate**: fraction of previous rounds where threshold was met

**Decision Logic:**

```
base_probability = (m + 1) / n

# Adjust based on observed cooperation levels
if threshold_met_rate >= 0.8:
    # Threshold reliably met - slight reduction to avoid surplus
    adjusted_prob = base_probability * 0.9
    
elif threshold_met_rate >= 0.5:
    # Threshold sometimes met - maintain base level
    adjusted_prob = base_probability
    
elif threshold_met_rate > 0:
    # Threshold rarely met but possible - increase contribution
    adjusted_prob = min(1, base_probability * 1.3)
    
else:
    # Threshold never met - check if cooperation exists at all
    if cooperation_rate > m/n * 0.5:
        # Others are trying - boost to help reach threshold
        adjusted_prob = min(1, base_probability * 1.5)
    else:
        # Near-universal defection - reduce to base but don't abandon
        adjusted_prob = base_probability * 0.7

# Final decision
cooperate if random() < adjusted_prob
```

### Last Round (Round r): Threshold-Focused Decision

The last round has no future consequences, but the collective reward still matters:

```
# Estimate expected cooperators among others
expected_others_cooperating = (n - 1) * recent_cooperation_rate

if expected_others_cooperating >= m:
    # Threshold likely met without me - defect
    cooperate = False
    
elif expected_others_cooperating >= m - 1:
    # I might be pivotal - cooperate with high probability
    cooperate = (random() < 0.85)
    
else:
    # Threshold unlikely even with me - cooperate at base rate
    # (maintains collective norm even in adversity)
    cooperate = (random() < base_probability)
```

---

## Edge Case Handling

| Situation | Response |
|-----------|----------|
| **n = m** (all must cooperate) | Always cooperate - any defection dooms everyone |
| **m = 2, n large** | Lower base probability, rely on others |
| **k very large** | Increase base probability by factor of min(1.5, k/2) |
| **k barely > 1** | Reduce base probability slightly - stakes are lower |
| **r = 2** (minimal rounds) | Use round 1 rule twice, no adaptation time |
| **Perfect cooperation observed** | Maintain cooperation, don't exploit |
| **Universal defection observed** | Gradually reduce but never reach 0 (maintain hope) |

---

## Collective Alignment Principles

1. **Fair share contribution**: I aim to be one of the m needed, not more, not less
2. **Redundancy for safety**: Slight over-contribution probability ensures threshold is met despite randomness
3. **No exploitation cascade**: I never fully defect based on others' defection - I maintain minimum cooperation to preserve collective potential
4. **Probabilistic fairness**: Randomization means I can't be systematically exploited as a reliable cooperator, nor can I systematically exploit others

---

## Summary Pseudocode

```python
def decide(round, history, n, m, r, k):
    base_prob = min(1, (m + 1) / n)
    
    if round == 1:
        return random() < base_prob
    
    coop_rate = count_cooperations(history) / total_actions(history)
    threshold_rate = count_threshold_met(history) / (round - 1)
    
    if round == r:  # Last round
        expected_others = (n - 1) * coop_rate
        if expected_others >= m:
            return False
        elif expected_others >= m - 1:
            return random() < 0.85
        else:
            return random() < base_prob
    
    # Middle rounds - adaptive
    if threshold_rate >= 0.8:
        prob = base_prob * 0.9
    elif threshold_rate >= 0.5:
        prob = base_prob
    elif threshold_rate > 0:
        prob = min(1, base_prob * 1.3)
    else:
        prob = base_prob * (1.3 if coop_rate > m/(2*n) else 0.7)
    
    return random() < prob
```

This strategy balances collective success with protection against exploitation, adapts to the population's behavior, and maintains hope for cooperation even in adverse conditions.
'''

description_COLLECTIVE_68 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the solution, not a free-rider. The key insight is that in a collective risk dilemma, the worst outcome is failing to meet the threshold—everyone loses the bonus. My strategy prioritizes ensuring threshold achievement while remaining adaptive to the actual cooperation landscape.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to historical cooperation rates, with built-in mechanisms to:
1. Bootstrap cooperation in early rounds
2. Maintain threshold achievement mid-game
3. Prevent collapse in late rounds
4. Respond to observed cooperation patterns

---

## Decision Rules

### Round 1: Cooperative Bootstrap

**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent. If all players think collectively and cooperate initially, we establish a foundation. Even if others defect, I've contributed toward the threshold.

---

### Rounds 2 through r-1: Adaptive Probabilistic Cooperation

Let `c_prev` = number of cooperators in the previous round
Let `c_avg` = average cooperation count across all previous rounds

**Calculate cooperation probability `p` as follows:**

```
# Base probability starts at level needed to meet threshold
base_p = m / n

# Adjustment based on previous round
if c_prev >= m:
    # Threshold was met - slight reduction is safe, but stay cooperative
    adjustment = -0.1
elif c_prev == m - 1:
    # We were one short - increase cooperation
    adjustment = +0.2
elif c_prev < m - 1:
    # Significantly under threshold - strong increase
    adjustment = +0.3
else:
    adjustment = 0

# Trend adjustment: if cooperation is declining, compensate
if round > 2:
    trend = c_prev - c_avg
    if trend < 0:
        adjustment += 0.1  # Cooperation declining, contribute more

# Calculate final probability
p = base_p + adjustment

# Clamp to reasonable bounds
p = max(0.3, min(0.95, p))
```

**Special override conditions:**

1. **Critical deficit response**: If `c_prev < m - 1`, set `p = min(0.9, p + 0.2)` — we need more cooperators urgently.

2. **Stability bonus**: If threshold was met in the last 3 consecutive rounds, allow `p` to decrease by 0.05 (cooperation is stable, slight relaxation is acceptable).

3. **Exploitation detection**: If `c_prev >= m` but I cooperated while observing the same players repeatedly defecting and gaining `k + 1`, I note this but do NOT retaliate harshly—maintaining the threshold matters more than punishing free-riders.

---

### Final Round (Round r): Conditional Cooperation

The last round creates temptation to defect since there's no future shadow. However, with collective mindset:

**Decision rule:**
```
if c_avg >= m:
    # Cooperation has generally succeeded - maintain it
    p = m / n + 0.1
else:
    # Cooperation has been fragile - be a reliable cooperator
    p = 0.7
```

**Override**: If I've cooperated more than `(rounds_played * m/n) + 2` times already (I've done more than my share), reduce `p` by 0.15 in the final round.

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **n = 2** | Cooperate with p = 0.7 always (both needed, high stakes) |
| **m = n-1** | Cooperate with p = 0.85 (almost everyone needed) |
| **m very small (m ≤ n/3)** | Use lower base probability, trust others to fill |
| **k very large (k > 3)** | Increase cooperation probability by 0.1 (high reward justifies contribution) |
| **r = 2** | Cooperate round 1, apply final-round logic to round 2 |
| **All previous rounds failed threshold** | Set p = 0.9 (emergency cooperation mode) |

---

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        return COOPERATE
    
    c_prev = count_cooperators(history, round - 1)
    c_avg = average_cooperators(history)
    my_coop_count = count_my_cooperations(history)
    
    # Base probability
    p = m / n
    
    # Adjust for previous outcome
    if c_prev >= m:
        p -= 0.1
    elif c_prev == m - 1:
        p += 0.2
    else:
        p += 0.3
    
    # Trend adjustment
    if round > 2 and c_prev < c_avg:
        p += 0.1
    
    # High-stakes adjustment
    if k > 3:
        p += 0.1
    
    # Final round adjustment
    if round == r:
        if my_coop_count > (round - 1) * m / n + 2:
            p -= 0.15
    
    # Clamp probability
    p = clamp(p, 0.3, 0.95)
    
    # Return probabilistic decision
    return COOPERATE if random() < p else DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **I start cooperative** — building trust and momentum
2. **I respond to need** — cooperating more when threshold is at risk
3. **I don't exploit success** — even when threshold is met, I don't aggressively defect
4. **I share the burden** — my base probability reflects fair share (m/n)
5. **I'm forgiving** — I don't punish defectors harshly; maintaining the collective good matters more
6. **I'm robust** — probabilistic approach means I can't be fully exploited, but I remain reliable

This strategy aims to be a **dependable contributor** that adapts to what the collective actually needs, rather than optimizing purely for individual gain.
'''

description_COLLECTIVE_69 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not more than necessary. The key insight is that exactly *m* cooperators is the socially optimal outcome—it meets the threshold while minimizing total contribution costs. My goal is to reliably be part of that critical mass when needed, while avoiding wasteful over-cooperation.

## Strategy Overview

I use a **probabilistic commitment approach** calibrated to ensure the threshold is met with high reliability, combined with **adaptive adjustments** based on observed population behavior.

---

## Decision Rules

### Round 1: Baseline Cooperation Probability

With no history, I cooperate with probability **p_base = m/n + ε**, where ε is a small reliability buffer.

```
p_base = min(0.95, (m/n) + 0.15)
```

**Rationale**: If all players independently cooperate with probability m/n, the expected number of cooperators equals m. The buffer ε accounts for variance and signals cooperative intent.

---

### Rounds 2 through (r-1): Adaptive Cooperation

I track two key metrics from history:
- **cooperation_rate**: The observed proportion of cooperative actions across all players and rounds
- **threshold_success_rate**: Proportion of past rounds where ≥m players cooperated

#### Adjustment Logic:

```
# Calculate observed cooperation rate
cooperation_rate = (total C actions) / (total actions so far)

# Calculate how reliably threshold has been met
threshold_met_rounds = count(rounds where cooperators >= m)
threshold_success_rate = threshold_met_rounds / rounds_played

# Estimate: Am I likely to be pivotal?
expected_other_cooperators = cooperation_rate * (n - 1)

# Adaptive probability calculation
if expected_other_cooperators < m - 1:
    # Too few cooperators predicted - increase my cooperation
    cooperation_gap = (m - 1) - expected_other_cooperators
    p_cooperate = min(0.95, p_base + 0.2 * cooperation_gap)
    
elif expected_other_cooperators > m + 1:
    # Excess cooperators predicted - I can reduce slightly
    # But never drop below a floor to maintain collective reliability
    p_cooperate = max(0.4, p_base - 0.1 * (expected_other_cooperators - m))
    
else:
    # Near threshold - stay close to base with slight adjustments
    if threshold_success_rate < 0.7:
        p_cooperate = p_base + 0.1  # Boost if we're failing too often
    else:
        p_cooperate = p_base
```

#### Pivotality Consideration:

```
# If I'm likely to be the pivotal cooperator, increase cooperation
if abs(expected_other_cooperators - (m - 1)) < 0.5:
    p_cooperate = min(0.95, p_cooperate + 0.2)
```

---

### Final Round (Round r): Strategic Endgame

The last round has no shadow of the future, creating defection incentives. My collective response:

```
if threshold_success_rate >= 0.6:
    # Group has been cooperative - maintain trust, cooperate at elevated rate
    p_cooperate = min(0.9, p_base + 0.1)
else:
    # Group has struggled - still try to salvage collective outcome
    p_cooperate = p_base
```

**Rationale**: I refuse to exploit the final round because (1) the collective benefit k still exists, and (2) if threshold isn't met, everyone loses. Defecting when I might be pivotal risks destroying k for everyone including myself.

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **m = n-1 or m = n** | Always cooperate (p = 0.95). Nearly everyone must cooperate anyway. |
| **m = 2 (very low threshold)** | Use lower baseline (m/n + 0.05). Easy thresholds need fewer volunteers. |
| **k is very large (k > 3)** | Increase baseline by 0.1. Higher stakes warrant more reliability. |
| **Observed all-defection round** | Next round: p_cooperate = min(0.9, p_base + 0.25). Try to restart cooperation. |
| **Threshold consistently exceeded** | Gradually reduce to floor of max(0.35, m/n). Avoid wasteful over-contribution. |
| **r = 2 (minimal rounds)** | Both rounds use p_base + 0.1. Limited learning time, so be reliably cooperative. |

---

## Complete Pseudocode

```
function decide(game_params, history):
    n, m, k, r = game_params
    current_round = len(history) + 1
    
    # Baseline probability
    p_base = min(0.95, (m / n) + 0.15)
    
    # Adjust for extreme k
    if k > 3:
        p_base = min(0.95, p_base + 0.1)
    
    # Round 1: Use baseline
    if current_round == 1:
        return COOPERATE if random() < p_base else DEFECT
    
    # Calculate history metrics
    total_actions = sum(len(round) for round in history)
    total_cooperations = sum(sum(1 for a in round if a == C) for round in history)
    cooperation_rate = total_cooperations / total_actions
    
    threshold_met = sum(1 for round in history if sum(1 for a in round if a == C) >= m)
    threshold_success_rate = threshold_met / len(history)
    
    expected_others_cooperating = cooperation_rate * (n - 1)
    
    # Adaptive calculation
    if expected_others_cooperating < m - 1:
        gap = (m - 1) - expected_others_cooperating
        p_cooperate = min(0.95, p_base + 0.2 * gap)
    elif expected_others_cooperating > m + 1:
        excess = expected_others_cooperating - m
        p_cooperate = max(0.4, p_base - 0.1 * excess)
    else:
        p_cooperate = p_base
        if threshold_success_rate < 0.7:
            p_cooperate = min(0.95, p_cooperate + 0.1)
    
    # Pivotality boost
    if abs(expected_others_cooperating - (m - 1)) < 0.5:
        p_cooperate = min(0.95, p_cooperate + 0.2)
    
    # Final round adjustment
    if current_round == r:
        if threshold_success_rate >= 0.6:
            p_cooperate = min(0.9, p_base + 0.1)
    
    return COOPERATE if random() < p_cooperate else DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: If all players use similar logic, cooperation naturally converges to ~m cooperators without explicit coordination.

2. **Responsive to defectors**: If others defect more, I cooperate more to compensate—up to a point.

3. **Not exploitable**: I never cooperate with certainty (cap at 0.95), and I maintain a cooperation floor, preventing pure free-riding from being optimal against me.

4. **Threshold-aware**: I'm more likely to cooperate when I'm likely pivotal, maximizing my expected contribution to collective success.

5. **Parameter-adaptive**: The strategy scales naturally with n, m, k, and r without requiring specific tuning.
'''

description_COLLECTIVE_70 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I treat the threshold being met as a public good that benefits everyone, and I'm willing to be one of the contributors who makes it happen. However, I must be adaptive because I cannot assume others share this cooperative orientation.

## Strategy Overview

The strategy operates on three principles:
1. **Be willing to cooperate** - Default toward being part of the solution
2. **Respond to observed cooperation levels** - Adjust based on whether the threshold is being met
3. **Maintain cooperation incentives** - Don't become a permanent free-rider, as this degrades collective outcomes

---

## Decision Rules

### Round 1: Probabilistic Cooperation Start

Since I have no history, I cooperate with probability based on the cooperation "burden share":

```
P(Cooperate in Round 1) = min(1, (m / n) + 0.2)
```

This means I'm slightly more willing to cooperate than a "fair share" would suggest, signaling cooperative intent while not being naively exploitable.

### Rounds 2 through r-1: Adaptive Response

Let `c_prev` = number of cooperators in the previous round (including myself)

**Case A: Threshold was met (c_prev ≥ m)**
- If I cooperated last round AND c_prev > m: Defect this round with probability `(c_prev - m) / n`
  - *Rationale: There's slack in the system; I can occasionally free-ride without breaking the threshold*
- If I cooperated last round AND c_prev = m: Cooperate again
  - *Rationale: I'm a critical cooperator; defecting would break the threshold*
- If I defected last round AND c_prev = m: Cooperate this round
  - *Rationale: Take my turn contributing; rotate the burden*
- If I defected last round AND c_prev > m: Cooperate with probability `m / c_prev`
  - *Rationale: Gradually move toward burden-sharing*

**Case B: Threshold was NOT met (c_prev < m)**
- If I cooperated last round: Continue cooperating (maintain commitment)
- If I defected last round: Cooperate with probability `1 - (c_prev / m)`
  - *Rationale: The fewer cooperators there were, the more likely I should step up*

**Streak Modifier:**
- If the threshold has been missed for 2+ consecutive rounds: Increase cooperation probability by 0.3
- If I've defected for 3+ consecutive rounds while threshold was met: Force cooperation next round
  - *Rationale: Prevent permanent free-riding; maintain collective trust*

### Final Round (Round r): Conditional Cooperation

The last round removes future consequences, creating defection incentives. My approach:

```
If average cooperation rate over all previous rounds ≥ m/n:
    Cooperate (reward the collective success)
Else:
    Cooperate with probability = (historical cooperation rate) / (m/n)
```

This maintains cooperative behavior even in the final round if the group has been reasonably cooperative, rather than defecting purely for short-term gain.

---

## Pseudocode Summary

```
function decide(round, history, my_history, n, m, k, r):
    
    if round == 1:
        return COOPERATE with probability min(1, m/n + 0.2)
    
    c_prev = count_cooperators(history[round-1])
    i_cooperated = my_history[round-1] == COOPERATE
    threshold_met = c_prev >= m
    
    if round == r:  # Final round
        avg_coop_rate = average_cooperation_rate(history)
        if avg_coop_rate >= m/n:
            return COOPERATE
        else:
            return COOPERATE with probability (avg_coop_rate / (m/n))
    
    # Streak calculations
    consecutive_misses = count_consecutive_threshold_misses(history)
    my_consecutive_defections = count_my_consecutive_defections(my_history)
    
    if my_consecutive_defections >= 3 and threshold_met:
        return COOPERATE  # Force end to free-riding streak
    
    base_probability = 0
    
    if threshold_met:
        if i_cooperated:
            if c_prev > m:
                base_probability = 1 - (c_prev - m) / n  # Occasional rest
            else:
                base_probability = 1  # I'm critical
        else:  # I defected
            if c_prev == m:
                base_probability = 1  # Take my turn
            else:
                base_probability = m / c_prev  # Burden sharing
    else:  # Threshold missed
        if i_cooperated:
            base_probability = 1  # Maintain commitment
        else:
            base_probability = 1 - (c_prev / m)  # Step up
    
    # Apply streak modifier for consecutive misses
    if consecutive_misses >= 2:
        base_probability = min(1, base_probability + 0.3)
    
    return COOPERATE with probability base_probability
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Probabilistic cooperation (m/n + 0.2) | Signal willingness without assuming coordination |
| Final round | Cooperate if group has been cooperative | Don't betray collective success |
| Threshold exactly met, I cooperated | Cooperate | I'm pivotal |
| Everyone defecting | High cooperation probability | Someone must break the deadlock |
| Threshold met with surplus | Occasional defection | Sustainable burden-sharing |
| Long personal defection streak | Force cooperation | Prevent exploitation |

---

## Why This Strategy is Collectively Minded

1. **I don't optimize purely for personal payoff** - I'm willing to cooperate even when defecting would yield higher individual returns
2. **I respond to collective need** - When the threshold is at risk, I increase cooperation
3. **I share the burden** - When there's surplus cooperation, I allow rotation rather than always cooperating or always defecting
4. **I maintain trust** - I don't exploit the final round if the group has been cooperative
5. **I'm forgiving** - I don't permanently punish past defection; I respond to current behavior

This strategy aims to be a reliable contributor to threshold achievement while remaining adaptive to the actual cooperation dynamics that emerge.
'''

description_COLLECTIVE_71 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a collective mindset: **I cooperate because the group needs exactly m cooperators to succeed, and I should be willing to be one of them.** The challenge is coordinating without communication to achieve exactly the threshold—not too few (failure) and not too many (unnecessary sacrifice).

## Strategy Overview

The strategy uses a **probabilistic commitment** approach that adapts based on observed cooperation levels, combined with **deterministic corrections** when the group is clearly failing or succeeding.

---

## Decision Rules

### Round 1: Probabilistic Initialization

Since we cannot coordinate, use a probability-based approach:

```
p_initial = m / n  (the "fair share" probability)
Cooperate with probability p_initial
```

**Rationale:** If all n players independently cooperate with probability m/n, the expected number of cooperators is exactly m. This is the collectively rational starting point.

---

### Rounds 2 through (r-1): Adaptive Response

After each round, observe the number of cooperators `c_prev` from the previous round.

**Calculate cooperation gap:**
```
gap = m - c_prev
```

**Adjust behavior based on gap:**

```
IF gap > 0 (too few cooperators - threshold not met):
    # Group is failing - increase cooperation urgently
    p_cooperate = min(1.0, (m / n) + (gap / n) * urgency_factor)
    where urgency_factor = 1.5
    
ELSE IF gap == 0 (exactly at threshold):
    # Perfect coordination achieved - maintain with slight buffer
    IF I cooperated last round:
        Cooperate (maintain my contribution)
    ELSE:
        Cooperate with probability 0.3 (provide backup)
        
ELSE IF gap < 0 (surplus cooperators - threshold exceeded):
    # Too many cooperating - some can safely defect
    surplus = -gap
    IF I cooperated last round:
        # Consider stepping back to let others free-ride fairly
        p_defect = surplus / (c_prev)  # Proportional release
        Defect with probability p_defect
    ELSE:
        # I was already defecting, stay defecting
        Defect
```

**Tie-breaking mechanism (to break symmetry):**
```
When probabilistic decisions are tied, use player index as seed:
personal_offset = hash(player_index, round_number) mod 100 / 100
Adjust p_cooperate slightly by personal_offset * 0.1
```

---

### Final Round (Round r): Strategic Calculation

The last round has no future consequences, making defection tempting. However, maintaining collective success matters:

```
IF historical_success_rate >= 0.5:
    # Group has been coordinating well - honor the implicit contract
    Use same adaptive logic as middle rounds
    
ELSE:
    # Group has been failing - last chance coordination
    IF c_prev >= m - 1:
        # We're close - cooperate to push over threshold
        Cooperate
    ELSE IF c_prev < m / 2:
        # Group is hopeless - minimize losses
        Defect
    ELSE:
        # Uncertain - cooperate with fair-share probability
        Cooperate with probability m / n
```

---

### Edge Cases

**Edge Case 1: m = n - 1 (nearly everyone must cooperate)**
```
Default to Cooperation unless threshold was met AND I defected last round
```

**Edge Case 2: m = 2 (minimal threshold)**
```
Use stricter defection bias - only cooperate if previous round had < m cooperators
```

**Edge Case 3: Very few rounds (r ≤ 3)**
```
Increase cooperation probability by 20% in all rounds
(Less time to recover from coordination failures)
```

**Edge Case 4: First round after a failure (c_prev < m)**
```
Boost cooperation probability by additional 0.2
Signal willingness to contribute more
```

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r, my_prev_action):
    
    if round == 1:
        return cooperate_with_probability(m / n)
    
    c_prev = count_cooperators(history[round - 1])
    gap = m - c_prev
    
    if round == r:  # Final round
        return final_round_decision(c_prev, history, m, n)
    
    # Middle rounds
    if gap > 0:  # Need more cooperators
        p = min(1.0, (m/n) + (gap/n) * 1.5)
        return cooperate_with_probability(p)
    
    elif gap == 0:  # Exactly at threshold
        if my_prev_action == COOPERATE:
            return COOPERATE
        else:
            return cooperate_with_probability(0.3)
    
    else:  # Surplus cooperators
        if my_prev_action == COOPERATE:
            p_defect = (-gap) / c_prev
            return defect_with_probability(p_defect)
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Fair burden sharing:** Starts with equal probability, adjusts based on observed behavior
2. **Responsive to failure:** Urgently increases cooperation when threshold not met
3. **Prevents over-cooperation:** Allows some to defect when surplus exists
4. **Maintains trust:** Cooperators tend to stay cooperators (stability)
5. **Handles diverse opponents:** Probabilistic elements prevent exploitation by deterministic strategies
6. **Collectively optimal orientation:** Prioritizes group success over individual maximization
'''

description_COLLECTIVE_72 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate because reaching the threshold benefits everyone, including myself. The challenge is that without communication, I must use observable history to implicitly coordinate with others who may share this goal, while protecting against exploitation.

## Key Strategic Insights

1. **The threshold is everything**: Exactly m cooperators is the critical coordination point. Fewer wastes contributions; more than necessary means some cooperators could have defected without harm.

2. **Symmetric reasoning**: In a collective mindset, I should ask "what probability of cooperation, if adopted by all like-minded players, would reliably achieve exactly m cooperators?"

3. **History reveals composition**: Past rounds reveal how many cooperators exist in this population, allowing adaptive calibration.

---

## Decision Rules

### Round 1: Baseline Probabilistic Cooperation

With no history, I use symmetric probabilistic cooperation:

```
p_base = m / n
Cooperate with probability p_base
```

**Rationale**: If all n players independently cooperate with probability m/n, the expected number of cooperators is exactly m. This is the collectively rational starting point.

### Rounds 2 through (r-1): Adaptive Threshold Targeting

After observing history, I adjust my cooperation probability based on revealed population behavior.

```
Let c_history = average number of cooperators across all previous rounds
Let c_target = m (the threshold)

# Calculate apparent cooperation rate in population
observed_rate = c_history / n

# Adaptive adjustment
If c_history < m:
    # Threshold not being met - increase cooperation
    deficit = m - c_history
    p_adjust = min(1.0, (m + deficit * 0.5) / n)
    
Else if c_history > m + 1:
    # Over-cooperation - some can safely reduce
    # But only reduce modestly to maintain buffer
    surplus = c_history - m
    p_adjust = max(m/n, (m + 0.5) / n)
    
Else:
    # Near optimal - maintain with slight buffer
    p_adjust = (m + 0.5) / n

# Incorporate consistency signal
Let consistency = (number of rounds threshold was met) / (total previous rounds)

If consistency > 0.7:
    # Stable cooperation pattern exists - lean toward maintaining
    p_final = p_adjust * 1.1  # Slight increase to preserve stability
Else:
    # Unstable - be more willing to cooperate to help establish pattern
    p_final = p_adjust * 1.2

p_final = clamp(p_final, 0.1, 0.95)  # Never fully deterministic

Cooperate with probability p_final
```

### Round r (Final Round): Strategic Endgame

The last round requires special handling since there's no future to influence:

```
Let recent_c = cooperators in round (r-1)

If recent_c >= m - 1:
    # Threshold is close or met
    # Cooperate with probability that targets exactly m
    If recent_c >= m:
        p_final = m / n  # Standard rate - threshold likely met
    Else:
        p_final = (m + 1) / n  # Slightly elevated to help reach threshold
        
Else:
    # Threshold unlikely to be met
    # Still contribute probabilistically - collective mindset means
    # I should do my part even if uncertain of success
    p_final = m / n  # Maintain baseline - don't abandon cooperation
    
Cooperate with probability p_final
```

---

## Edge Case Handling

### When m is very close to n (e.g., m = n-1):
```
If m >= n - 1:
    # Nearly everyone must cooperate - increase base rate
    p_base = min(0.95, (m + 0.5) / n)
```

### When m is very small (e.g., m = 2):
```
If m <= 2:
    # Low threshold - be willing to be one of the reliable cooperators
    # But don't over-cooperate
    p_base = max(0.3, m / n)
```

### Detecting Exploitative Populations:
```
If (rounds played >= 3) AND (I cooperated in all) AND (threshold never met):
    # Others may be pure defectors
    # Reduce cooperation but don't abandon entirely
    p_adjust = max(0.2, p_adjust * 0.7)
```

### When k is very large:
```
If k > 3:
    # High reward for meeting threshold - cooperation more valuable
    # Increase willingness to cooperate
    p_adjust = p_adjust * 1.15
```

---

## Summary Pseudocode

```python
def decide(round_num, total_rounds, n, m, k, history):
    
    # Base probability
    p = m / n
    
    if round_num == 1:
        return random() < p
    
    # Analyze history
    avg_cooperators = mean([round.cooperator_count for round in history])
    threshold_met_rate = mean([1 if r.cooperator_count >= m else 0 for r in history])
    
    # Adjust based on observed cooperation level
    if avg_cooperators < m:
        p = min(0.95, (m + (m - avg_cooperators) * 0.5) / n)
    elif avg_cooperators > m + 1:
        p = max(0.15, m / n)
    else:
        p = (m + 0.5) / n
    
    # Stability bonus
    if threshold_met_rate > 0.7:
        p *= 1.1
    elif threshold_met_rate < 0.3 and round_num > 3:
        p *= 0.85  # Slight reduction if cooperation failing
    
    # High-k adjustment
    if k > 2:
        p *= (1 + (k - 2) * 0.1)
    
    # Final round adjustment
    if round_num == total_rounds:
        last_c = history[-1].cooperator_count
        if last_c < m - 1:
            p *= 0.9  # Slight reduction but maintain cooperation
    
    p = max(0.1, min(0.95, p))  # Bound probabilities
    
    return random() < p
```

---

## Why This Strategy is Collectively Minded

1. **Targets the threshold, not maximum cooperation**: Efficient collective behavior means achieving m cooperators, not n.

2. **Uses probabilistic mixing**: Allows implicit coordination without communication - if enough players reason similarly, the threshold is met.

3. **Never fully abandons cooperation**: Even facing apparent defectors, maintains some cooperation probability because giving up guarantees collective failure.

4. **Responds to population signals**: Increases cooperation when threshold isn't met, maintains when it is - adapts to help the collective succeed.

5. **Avoids pure exploitation strategies**: While protecting against free-riders, doesn't devolve into pure defection which would harm everyone.
'''

description_COLLECTIVE_73 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the m cooperators needed, but not a sucker who cooperates when others won't. The key insight is that exactly m cooperators is the efficient outcome—it achieves the threshold while minimizing unnecessary sacrifice. My goal is to reliably be part of that m when coordination seems achievable, while protecting myself when it doesn't.

## Strategy Overview

I use a **probabilistic commitment approach** calibrated by observed cooperation rates and game parameters. The strategy balances three imperatives:
1. **Ensure threshold is met** when others show cooperative intent
2. **Avoid being exploited** by persistent defectors
3. **Signal reliability** to encourage coordination

---

## Decision Rules

### Round 1: Baseline Cooperation Probability

Since I have no history, I cooperate with probability based on what a collectively-minded player should do:

```
P(Cooperate | Round 1) = m / n
```

**Rationale:** If all n players independently cooperate with probability m/n, the expected number of cooperators is exactly m. This is the collectively optimal baseline that doesn't over-commit or under-commit.

### Rounds 2 through (r-1): Adaptive Response

Let `coop_rate(t)` = proportion of all players who cooperated in round t

**Step 1: Calculate cooperation momentum**
```
recent_coop_rate = weighted average of last 3 rounds (weights: 0.5, 0.3, 0.2)
                   (or available rounds if fewer than 3)
```

**Step 2: Assess threshold feasibility**
```
threshold_ratio = m / n
feasibility_score = recent_coop_rate / threshold_ratio
```

**Step 3: Determine cooperation probability**
```
If feasibility_score >= 1.0:
    # Cooperation is meeting/exceeding threshold - stay committed
    base_prob = m / n
    
    # Slight boost if I cooperated last round and threshold was met
    if I_cooperated_last AND threshold_met_last:
        base_prob += 0.1
    
    P(Cooperate) = min(base_prob, 0.85)

Else if feasibility_score >= 0.7:
    # Cooperation is close but fragile - increase commitment to help reach threshold
    P(Cooperate) = (m / n) + 0.15

Else if feasibility_score >= 0.4:
    # Cooperation is struggling - match the crowd with slight optimism
    P(Cooperate) = recent_coop_rate + 0.1

Else:
    # Cooperation has collapsed - protect myself but leave door open
    P(Cooperate) = 0.15
```

**Step 4: Personal history adjustment**
```
If I cooperated in majority of last 3 rounds AND threshold was rarely met (<40%):
    # I'm being exploited - reduce cooperation
    P(Cooperate) = P(Cooperate) * 0.6

If I defected in majority of last 3 rounds AND threshold was often met (>70%):
    # I'm free-riding too much - increase cooperation for collective good
    P(Cooperate) = P(Cooperate) + 0.2
```

### Final Round (Round r): Endgame Logic

The last round has no shadow of the future, creating temptation to defect. However, I maintain collective commitment:

```
If threshold was met in >= 60% of previous rounds:
    # Successful coordination - honor the implicit agreement
    P(Cooperate) = m / n
    
Else if threshold was met in >= 40% of previous rounds:
    # Partial success - moderate commitment
    P(Cooperate) = (m / n) * 0.7
    
Else:
    # Coordination failed throughout - minimize losses
    P(Cooperate) = 0.1
```

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **r = 2 (minimal rounds)** | Round 1: Use baseline. Round 2: Treat as final round. |
| **m very close to n** | Recognize high coordination requirement; be more forgiving of near-misses (treat threshold_ratio >= 0.8 * m/n as partial success) |
| **m very small (m/n < 0.3)** | Coordination is easy; cooperate near baseline unless clear collapse |
| **k is very large** | No change—the math already favors cooperation when threshold is met |
| **Threshold exactly met repeatedly** | Maintain current strategy; this is the efficient outcome |
| **Wild oscillation in cooperation** | Weight most recent round more heavily (0.7, 0.2, 0.1) |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    
    if round_num == 1:
        return cooperate_with_probability(m / n)
    
    recent_coop_rate = weighted_average(history, weights=[0.5, 0.3, 0.2])
    threshold_ratio = m / n
    feasibility = recent_coop_rate / threshold_ratio
    
    # Base probability calculation
    if feasibility >= 1.0:
        prob = m / n
        if my_last_action == C and threshold_met_last_round:
            prob += 0.1
        prob = min(prob, 0.85)
    elif feasibility >= 0.7:
        prob = (m / n) + 0.15
    elif feasibility >= 0.4:
        prob = recent_coop_rate + 0.1
    else:
        prob = 0.15
    
    # Personal history correction
    my_recent_coop_rate = my_cooperation_rate(last_3_rounds)
    recent_threshold_rate = threshold_success_rate(last_3_rounds)
    
    if my_recent_coop_rate > 0.5 and recent_threshold_rate < 0.4:
        prob *= 0.6  # Stop being exploited
    if my_recent_coop_rate < 0.5 and recent_threshold_rate > 0.7:
        prob += 0.2  # Contribute more to collective
    
    # Final round adjustment
    if round_num == total_rounds:
        overall_threshold_rate = threshold_success_rate(all_rounds)
        if overall_threshold_rate >= 0.6:
            prob = m / n
        elif overall_threshold_rate >= 0.4:
            prob = (m / n) * 0.7
        else:
            prob = 0.1
    
    prob = clamp(prob, 0.05, 0.95)  # Never fully deterministic
    return cooperate_with_probability(prob)
```

---

## Why This Strategy is Collectively Aligned

1. **Fair burden sharing:** Baseline of m/n means I expect to contribute my proportional share
2. **Responsive to collective behavior:** I increase commitment when coordination is fragile, decrease when exploited
3. **Maintains trust:** I don't defect dramatically in the final round if cooperation worked
4. **Self-correcting:** Built-in checks prevent me from free-riding on a functioning collective

This strategy aims to be the kind of player that, if everyone played similarly, would reliably achieve efficient outcomes—while also protecting against exploitation by pure defectors.
'''

description_COLLECTIVE_74 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the minimum coalition needed to avert risk, while adapting to the actual cooperation levels I observe. I don't try to free-ride, but I also don't waste cooperation when others are already providing sufficient coverage.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic fairness**: Cooperate with probability that would yield exactly m cooperators if everyone used the same strategy
2. **Responsive adaptation**: Adjust based on observed cooperation rates
3. **Commitment signaling**: Establish reliability early, maintain it throughout

---

## Decision Rules

### Round 1: Baseline Cooperation

**Cooperate with probability p₀ = m/n**

This is the collectively optimal probability—if all n players cooperate with this probability, the expected number of cooperators equals exactly m. This signals willingness to do my fair share without assuming others will free-ride.

### Rounds 2 through (r-1): Adaptive Phase

Calculate the **observed cooperation rate** from all previous rounds:
```
obs_rate = (total C plays by all players) / (total plays by all players)
```

Calculate the **cooperation gap**:
```
gap = (m/n) - obs_rate
```

**Determine cooperation probability for this round:**

```
If gap > 0 (under-cooperation):
    p = min(1.0, (m/n) + 1.5 × gap)
    # Increase my cooperation to compensate for shortfall
    
If gap ≤ 0 (sufficient or excess cooperation):
    p = max(0.1, (m/n) - 0.5 × |gap|)
    # Reduce slightly but maintain baseline presence
```

**Additional modifier - Consistency bonus:**
```
If I cooperated last round AND threshold was met:
    p = p + 0.1  # Reward successful cooperation patterns
    
If I cooperated last round AND threshold was NOT met:
    p = p - 0.1  # Others aren't reciprocating, pull back slightly
```

**Cooperate with final probability p (clamped to [0.1, 0.95])**

### Final Round (Round r): Threshold-Focused Decision

The last round requires special handling since there's no future to influence:

```
recent_coop_count = number of cooperators in round (r-1)

If recent_coop_count >= m:
    # Threshold was met without maximum contribution
    Cooperate with probability = max(0.2, (m - 0.5) / n)
    # Maintain some cooperation but allow slight free-riding
    
If recent_coop_count == m - 1:
    # I might be pivotal
    Cooperate with probability = 0.85
    
If recent_coop_count < m - 1:
    # Threshold unlikely to be met
    Cooperate with probability = m / n
    # Return to baseline—do my fair share regardless
```

---

## Edge Cases

| Scenario | Response |
|----------|----------|
| **n = 2, m = 2** | Cooperate with p = 0.9 (both needed, must show commitment) |
| **m = n - 1** | Cooperate with p = 0.85 (almost everyone needed) |
| **m very small (m ≤ n/3)** | Follow standard rules but cap defection—never go below p = 0.15 |
| **Single round observed with 0 cooperators** | Set p = 0.8 for next round (someone must start) |
| **Threshold met every round so far** | Maintain p ≥ m/n (don't abandon a working system) |
| **k very large (k > 3)** | Increase all probabilities by 10% (stakes justify more cooperation) |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    base_p = m / n
    
    if round_num == 1:
        p = base_p
    
    elif round_num == total_rounds:
        recent_coop = count_cooperators(history[-1])
        if recent_coop >= m:
            p = max(0.2, (m - 0.5) / n)
        elif recent_coop == m - 1:
            p = 0.85
        else:
            p = base_p
    
    else:  # Middle rounds
        obs_rate = total_cooperations(history) / total_actions(history)
        gap = base_p - obs_rate
        
        if gap > 0:
            p = base_p + 1.5 * gap
        else:
            p = base_p - 0.5 * abs(gap)
        
        # Consistency modifier
        if my_last_action == C and last_round_met_threshold:
            p += 0.1
        elif my_last_action == C and not last_round_met_threshold:
            p -= 0.1
    
    # Clamp and adjust for high stakes
    p = clamp(p, 0.1, 0.95)
    if k > 3:
        p = min(1.0, p + 0.1)
    
    return C if random() < p else D
```

---

## Why This Strategy is Collectively Robust

1. **Fair baseline**: Starting at m/n means I'm never asking others to do more than their share
2. **Adaptive, not exploitable**: I increase cooperation when needed but don't infinitely compensate for defectors
3. **Maintains floor**: Never dropping below 10% cooperation ensures I occasionally contribute even in hostile environments
4. **Rewards coordination**: The consistency bonus creates sticky cooperative equilibria
5. **Handles uncertainty**: Probabilistic decisions mean I can't be perfectly predicted and exploited
'''

description_COLLECTIVE_75 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the minimal coalition needed to secure the collective reward, while adapting to observed cooperation patterns. The goal is to reliably contribute to reaching threshold m when my contribution matters, while avoiding wasteful over-cooperation when others already provide sufficient coverage.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to the game parameters and dynamically adjusted based on observed history. The core insight: if all n players cooperate with probability p, the expected number of cooperators is np. I target cooperation rates that make threshold achievement likely while distributing the cooperation burden fairly.

---

## Decision Rules

### Round 1: Baseline Cooperation

With no history, I cooperate with probability:

```
p_base = min(1, (m + 1) / n)
```

**Rationale**: This slightly overshoots the minimum needed (m/n) to provide a safety margin, reflecting collective responsibility. If m=3 and n=6, I cooperate with probability 4/6 ≈ 0.67.

### Rounds 2 through (r-1): Adaptive Cooperation

I track two key metrics from history:
- `coop_rate`: Average cooperation rate across all players in previous rounds
- `threshold_met_rate`: Fraction of previous rounds where threshold m was met

**Adjustment Logic:**

```
If threshold_met_rate < 0.5:
    # Crisis mode: threshold rarely met, increase cooperation
    p = min(1, p_base + 0.2 * (1 - threshold_met_rate))
    
Elif threshold_met_rate > 0.9 AND average cooperators > m + 1:
    # Over-cooperation: others are reliable, slightly reduce
    p = max(m/n, p_base - 0.1 * (coop_rate - m/n))
    
Else:
    # Standard mode: match collective needs
    target_coop = (m + 0.5) / n  # Target slightly above minimum
    gap = target_coop - coop_rate
    p = p_base + 0.5 * gap  # Partial adjustment toward target
```

**Bounds**: Always keep p within [m/(2n), 1] to maintain baseline collective commitment.

### Final Round (Round r): Commitment Hold

I use the **same adaptive probability** as the previous round, resisting the temptation to defect. 

**Rationale**: A collective strategy shouldn't exploit the finality of the last round. If everyone defects in the final round, the collective loses k. Maintaining cooperation probability signals that this strategy genuinely values collective outcomes.

---

## Edge Cases

### Edge Case 1: Very Small Groups (n ≤ 3)
When n is small and m is close to n, cooperation becomes critical:
```
If m >= n - 1:
    p = 1  # Must cooperate; one defector breaks threshold
```

### Edge Case 2: Low Threshold (m ≤ 2)
When threshold is easily met:
```
p_base = max(0.4, (m + 0.5) / n)  # Maintain minimum engagement
```

### Edge Case 3: Near-Unanimous Requirement (m = n-1)
```
p = 0.95  # Near-certain cooperation; can only afford one defector
```

### Edge Case 4: High Reward (k >> 1)
When k is very large, threshold achievement becomes paramount:
```
If k > 3:
    p = min(1, p * (1 + 0.1 * log(k)))  # Scale up cooperation
```

### Edge Case 5: Observing Systematic Defection
If in any window of 3+ rounds, cooperation rate falls below m/(2n):
```
# Some players are free-riding heavily
# Maintain principled cooperation but don't over-compensate
p = p_base  # Return to baseline rather than escalating
```

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    p_base = min(1, (m + 1) / n)
    
    # Adjust for extreme parameters
    if m >= n - 1:
        return COOPERATE
    if k > 3:
        p_base = min(1, p_base * (1 + 0.1 * log(k)))
    
    if round_num == 1:
        p = p_base
    else:
        coop_rate = average_cooperation_rate(history)
        threshold_met_rate = fraction_threshold_met(history, m)
        
        if threshold_met_rate < 0.5:
            p = min(1, p_base + 0.2 * (1 - threshold_met_rate))
        elif threshold_met_rate > 0.9 and avg_cooperators(history) > m + 1:
            p = max(m/n, p_base - 0.1 * (coop_rate - m/n))
        else:
            target = (m + 0.5) / n
            p = p_base + 0.5 * (target - coop_rate)
        
        p = clamp(p, m/(2*n), 1)
    
    return COOPERATE if random() < p else DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **Fair burden sharing**: Base probability reflects each player doing their proportional share
2. **Responsive to collective need**: Increases cooperation when thresholds aren't being met
3. **No end-game exploitation**: Maintains cooperation in final round
4. **Robust to defectors**: Doesn't collapse if some players free-ride, but also doesn't infinitely compensate
5. **Parameterized for any game**: Adapts to different n, m, r, k configurations automatically
'''

description_COLLECTIVE_76 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume I am one of potentially many agents running this same strategy. My goal is to ensure the threshold m is met reliably while minimizing unnecessary sacrifice. The strategy coordinates implicitly through observable game state rather than assuming others share my algorithm.

## Key Insight

The fundamental tension: we need exactly m cooperators (or slightly more for safety), but everyone prefers being a defector when the threshold is met. A collective strategy must solve the **coordination problem** of deciding *which* agents cooperate, using only shared observable information.

---

## Decision Rules

### Primary Mechanism: Deterministic Role Assignment

Since all agents observe the same history and know all parameters, we can use a **deterministic coordination rule** based on round number to implicitly assign cooperation duties.

**Round-Based Index Assignment:**
```
cooperation_slots = round_number mod n
assigned_cooperators = players whose index i satisfies:
    (i + round_number) mod n < m + safety_buffer
```

Where `safety_buffer` adjusts based on observed defection from non-collective players.

### Adaptive Response Layer

Since we cannot assume all players run this strategy, we layer adaptive responses:

**1. Estimate Collective Population:**
```
After each round:
    expected_cooperators = m + safety_buffer
    actual_cooperators = count of C plays
    
    if actual_cooperators consistently matches expected:
        confidence_in_collective += 1
    else:
        estimate external_cooperators and external_defectors from deviations
```

**2. Adjust Safety Buffer:**
```
safety_buffer = max(1, ceil((n - estimated_collective_size) * defection_rate))
```

---

## Complete Decision Algorithm

```
function decide(round, history, n, m, k, r):
    
    # === FIRST ROUND ===
    if round == 1:
        # Use player index for initial coordination
        # Assume roughly half might be collective agents
        # Cooperate if my index is in the lower m+1 positions
        if my_index < m + 1:
            return COOPERATE
        else:
            return DEFECT
    
    # === ANALYZE HISTORY ===
    recent_rounds = last min(5, round-1) rounds
    avg_cooperators = average cooperation count in recent_rounds
    cooperation_variance = variance of cooperation counts
    
    # Estimate how many "reliable" cooperators exist
    reliable_cooperators = floor(avg_cooperators - sqrt(cooperation_variance))
    
    # === LAST ROUND ===
    if round == r:
        # No future punishment possible, but collective commitment matters
        # If threshold has been consistently met, maintain cooperation pattern
        if threshold_met_rate(history) > 0.8:
            # Continue assigned role
            return assigned_role(round, reliable_cooperators)
        else:
            # Emergency: cooperate if threshold at risk
            if reliable_cooperators < m:
                return COOPERATE
            else:
                return assigned_role(round, reliable_cooperators)
    
    # === MIDDLE ROUNDS ===
    
    # Calculate how many cooperators we need
    needed = m - reliable_cooperators + safety_margin(round, r, history)
    
    # Determine my assigned role this round
    role_index = (my_index + round) mod n
    am_assigned = role_index < max(needed, 0)
    
    # === THRESHOLD CRISIS RESPONSE ===
    if last_round_cooperators < m:
        # Threshold was missed! Increase cooperation urgently
        crisis_threshold = m + 2
        am_assigned = role_index < crisis_threshold
    
    # === EXPLOITATION DETECTION ===
    # If same players always defect while threshold is met
    consistent_defectors = players who defected in all recent_rounds
    if len(consistent_defectors) > n - m - 1:
        # Too many free riders; occasionally withhold to signal
        if round mod 7 == 0 and am_assigned:
            return DEFECT  # Coordinated protest round
    
    if am_assigned:
        return COOPERATE
    else:
        return DEFECT

function safety_margin(round, r, history):
    # Higher margin early (learning phase) and late (high stakes)
    base = 1
    if round < 4:
        base = 2  # Extra safety while learning
    if round > r - 3:
        base = 2  # Extra safety near end
    
    # Increase margin if we've seen threshold failures
    failures = count threshold misses in history
    return base + failures

function assigned_role(round, estimated_need):
    role_index = (my_index + round) mod n
    return COOPERATE if role_index < estimated_need else DEFECT
```

---

## Edge Case Handling

| Situation | Response |
|-----------|----------|
| **Round 1** | Cooperate if `my_index < m + 1`, else defect |
| **Last round** | Maintain pattern if historically successful; emergency cooperate if threshold at risk |
| **Threshold just missed** | Increase cooperation probability for next 2 rounds |
| **Threshold consistently exceeded** | Reduce safety buffer, allow more defection |
| **High variance in cooperation** | Increase safety buffer, be more likely to cooperate |
| **m very close to n** | Always cooperate (little room for defection) |
| **m very small relative to n** | Follow rotation strictly, enjoy defection rounds |

---

## Why This Strategy Is Collectively Optimal

1. **Fair burden sharing**: Cooperation duty rotates based on `(index + round) mod n`
2. **Robust to non-collective players**: Safety buffer and adaptive estimation handle mixed populations
3. **Self-correcting**: Increases cooperation after failures, relaxes after consistent success
4. **No communication needed**: All coordination through deterministic rules on shared observables
5. **Collective punishment**: Coordinated protest rounds if exploitation detected

---

## Summary

**Cooperate when:** You are assigned based on rotating index, OR threshold is at risk, OR in crisis recovery mode.

**Defect when:** You are not assigned AND sufficient cooperators are expected AND no crisis.

The strategy balances the collective good (meeting threshold) with individual rationality (taking turns enjoying the higher defector payoff when safe).
'''

description_COLLECTIVE_77 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I cooperate because the group needs exactly m cooperators to succeed, and I should be willing to be one of them.** The challenge is coordinating without communication to achieve exactly (or slightly above) the threshold while being robust to defectors and varying opponent behaviors.

## Strategy Overview

The strategy uses a **probabilistic cooperation baseline** calibrated to the threshold ratio, combined with **responsive adjustments** based on observed cooperation levels. It aims to be a reliable cooperator when cooperation is scarce, but strategically defects when cooperation is abundant (allowing others to "carry" the threshold).

---

## Decision Rules

### Round 1: Baseline Probabilistic Cooperation

With no history, cooperate with probability based on the threshold ratio:

```
p_initial = (m / n) + safety_margin
where safety_margin = 0.15 * (m / n)
```

**Rationale:** If everyone used probability m/n, we'd expect exactly m cooperators on average. The safety margin accounts for variance and the collective risk of falling short.

### Rounds 2 through (r-1): Adaptive Response

Calculate cooperation rate from previous round:
```
coop_rate = (number of cooperators in previous round) / n
target_rate = m / n
```

**Decision logic:**

1. **If cooperation fell short (coop_rate < target_rate):**
   - Cooperate with high probability: `p = min(0.95, target_rate + 0.3)`
   - *Collective reasoning: The group failed; I should step up*

2. **If cooperation barely met threshold (target_rate ≤ coop_rate < target_rate + 0.2):**
   - If I cooperated last round: Cooperate with probability 0.85
   - If I defected last round: Cooperate with probability `target_rate + 0.1`
   - *Collective reasoning: Maintain what's working, but allow some rotation*

3. **If cooperation exceeded threshold comfortably (coop_rate ≥ target_rate + 0.2):**
   - If I cooperated last round: Cooperate with probability 0.5
   - If I defected last round: Cooperate with probability `target_rate`
   - *Collective reasoning: Others are carrying the load; I can sometimes rest*

4. **Reputation tracking adjustment:**
   ```
   If I defected in the last 2 rounds AND threshold was met both times:
       Force cooperation this round (p = 1.0)
   ```
   - *Collective reasoning: I've free-ridden enough; time to contribute*

### Final Round (Round r): Modified Behavior

The final round has no future consequences, creating defection incentives. Counter this with:

```
If previous round met threshold:
    Cooperate with probability = target_rate + 0.25
Else:
    Cooperate with probability = 0.9
```

**Rationale:** Maintain slightly elevated cooperation to counteract others' potential final-round defection while not being exploitable.

---

## Edge Cases

| Situation | Behavior |
|-----------|----------|
| **m = n-1 or m = n** | Always cooperate (threshold is too tight for strategic defection) |
| **m ≤ 2** | Use baseline probability; threshold is easily met |
| **r = 2** | Cooperate round 1, use final-round logic for round 2 |
| **All opponents always defect** | After 3 consecutive failures, defect (threshold impossible) |
| **All opponents always cooperate** | Settle into target_rate cooperation (efficient free-riding) |

---

## Pseudocode

```python
def decide(round_num, total_rounds, n, m, k, history):
    target_rate = m / n
    
    # Edge case: very tight threshold
    if m >= n - 1:
        return COOPERATE
    
    # Round 1
    if round_num == 1:
        p = target_rate * 1.15
        return COOPERATE if random() < p else DEFECT
    
    # Calculate last round stats
    last_coop_count = count_cooperators(history[-1])
    coop_rate = last_coop_count / n
    i_cooperated_last = my_action(history[-1]) == COOPERATE
    threshold_met_last = last_coop_count >= m
    
    # Check for hopeless situation
    if consecutive_failures(history) >= 3:
        return DEFECT
    
    # Anti-free-riding: force cooperation after benefiting twice
    if len(history) >= 2:
        if not i_cooperated_last and not my_action(history[-2]) == COOPERATE:
            if threshold_met(history[-1]) and threshold_met(history[-2]):
                return COOPERATE
    
    # Final round adjustment
    if round_num == total_rounds:
        p = target_rate + 0.25 if threshold_met_last else 0.9
        return COOPERATE if random() < p else DEFECT
    
    # Main adaptive logic
    if coop_rate < target_rate:  # Fell short
        p = min(0.95, target_rate + 0.3)
    elif coop_rate < target_rate + 0.2:  # Barely met
        p = 0.85 if i_cooperated_last else target_rate + 0.1
    else:  # Comfortably exceeded
        p = 0.5 if i_cooperated_last else target_rate
    
    return COOPERATE if random() < p else DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Willing contributor:** Baseline cooperation exceeds minimum needed, showing good faith
2. **Responsive to need:** Increases cooperation when the group falls short
3. **Fair rotation:** Allows turn-taking by reducing cooperation when others are contributing
4. **Self-limiting free-riding:** Forces cooperation after consecutive defections during success
5. **Robust to exploitation:** Stops cooperating if cooperation is clearly futile
6. **Threshold-aware:** All probabilities scale with the actual difficulty (m/n ratio)
'''

description_COLLECTIVE_78 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of exactly m cooperators when possible, contributing my fair share to avert collective risk while recognizing that excess cooperation is wasteful. The strategy adapts based on observed population behavior to find the right balance between ensuring threshold achievement and avoiding exploitation.

---

## Strategy Overview

The strategy operates on three principles:
1. **Fair share commitment**: My baseline probability of cooperation reflects my proportional responsibility (m/n)
2. **Responsive adjustment**: I increase cooperation when the group is falling short, decrease when others over-provide
3. **End-game awareness**: Final rounds require adjusted reasoning since future cooperation incentives disappear

---

## Decision Rules

### Round 1: Baseline Cooperation

With no history, cooperate with probability based on fair share plus a small reliability buffer:

```
P(cooperate) = min(1, m/n + 0.15)
```

This slight upward bias reflects collective commitment—I'd rather risk contributing to a successful threshold than risk collective failure through under-contribution.

### Rounds 2 through (r-1): Adaptive Response

**Step 1: Calculate cooperation rate from previous round**
```
prev_cooperators = count of players who played C in round t-1
cooperation_rate = prev_cooperators / n
target_rate = m / n
```

**Step 2: Assess threshold achievement history**
```
success_rate = (rounds where ≥m cooperated) / (rounds played)
```

**Step 3: Determine cooperation probability**

```
base_probability = m / n

# Adjustment based on previous round outcome
if prev_cooperators < m:
    # Threshold failed - increase my contribution likelihood
    shortfall = (m - prev_cooperators) / n
    adjustment = +0.3 + shortfall
elif prev_cooperators == m:
    # Perfect efficiency achieved - maintain
    adjustment = 0
elif prev_cooperators > m:
    # Over-contribution - slightly reduce, but cautiously
    excess = (prev_cooperators - m) / n
    adjustment = -0.15 * excess

# Modify based on overall success rate
if success_rate < 0.5:
    # Group is struggling - be more reliable
    reliability_boost = 0.2 * (1 - success_rate)
else:
    reliability_boost = 0

P(cooperate) = clamp(base_probability + adjustment + reliability_boost, 0.1, 0.95)
```

**Step 4: Incorporate personal history consideration**

If I defected in the previous round AND the threshold was not met:
```
P(cooperate) += 0.25  # I may have been the critical missing cooperator
```

If I cooperated in the previous round AND threshold was met with exactly m cooperators:
```
# I was essential - maintain high cooperation
P(cooperate) = max(P(cooperate), 0.7)
```

### Final Round (Round r): Modified End-Game Logic

The last round has no shadow of the future, making defection more tempting for all. A collectively-minded agent must account for this:

```
# Expect others to defect more in final round
expected_cooperation_drop = 0.2

adjusted_expected_cooperators = (historical_cooperation_rate - expected_cooperation_drop) * (n - 1)

if adjusted_expected_cooperators < m - 1:
    # Even my cooperation likely won't save us - defect
    P(cooperate) = 0.2
elif adjusted_expected_cooperators >= m - 1 AND adjusted_expected_cooperators < m + 1:
    # I might be pivotal - cooperate with high probability
    P(cooperate) = 0.85
else:
    # Others likely have it covered
    P(cooperate) = m / n
```

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **m = n-1 or m = n** | Very high cooperation needed; set baseline to 0.9+ |
| **m very small (m ≤ 2)** | Cooperate with probability m/n but never below 0.25 |
| **k very large (k > 3)** | Threshold success is critical; boost all probabilities by 0.1 |
| **Observed all-defect round** | Next round: P(cooperate) = 0.8 (emergency recovery) |
| **Observed all-cooperate round** | Next round: P(cooperate) = m/n - 0.1 (reduce waste) |
| **n = 2** | Essentially a coordination game; cooperate with P = 0.7 throughout |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return random() < min(1, m/n + 0.15)
    
    prev_coop = count_cooperators(history, round - 1)
    success_rate = count_successful_rounds(history) / (round - 1)
    my_last_action = get_my_action(history, round - 1)
    
    base_p = m / n
    
    # Threshold response
    if prev_coop < m:
        adjustment = 0.3 + (m - prev_coop) / n
    elif prev_coop == m:
        adjustment = 0
    else:
        adjustment = -0.15 * (prev_coop - m) / n
    
    # Success rate modifier
    reliability_boost = 0.2 * (1 - success_rate) if success_rate < 0.5 else 0
    
    # Personal responsibility
    if my_last_action == 'D' and prev_coop < m:
        adjustment += 0.25
    
    p = clamp(base_p + adjustment + reliability_boost, 0.1, 0.95)
    
    # Final round adjustment
    if round == r:
        p = final_round_adjustment(p, history, n, m)
    
    return random() < p
```

---

## Why This Strategy is Collectively Minded

1. **Fair contribution**: Baseline cooperation of m/n means if everyone used this strategy, expected cooperators ≈ m
2. **Responsive to need**: When the group fails, I step up rather than abandon
3. **Not exploitable to collapse**: Minimum 10% cooperation prevents complete breakdown
4. **Efficient**: Reduces cooperation when threshold is easily met, avoiding waste
5. **Pivotal awareness**: Recognizes when my individual choice likely determines collective success

This strategy treats the threshold as a shared responsibility, adjusting my contribution based on what the collective needs rather than purely self-interested calculation.
'''

description_COLLECTIVE_79 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to ensure the group achieves the threshold and everyone benefits. The key insight is that in this game, **free-riding only works if enough others cooperate** - so I should be willing to be one of those cooperators, while adapting to ensure we don't over-contribute wastefully or under-contribute disastrously.

## Strategy Overview

The strategy operates on three principles:
1. **Willingness to contribute**: Default toward cooperation to help meet threshold
2. **Responsive adjustment**: Reduce cooperation if the group consistently over-provides; increase if we're falling short
3. **Probabilistic coordination**: Use deterministic rules based on player index and round to implicitly coordinate without communication

---

## Decision Rules

### Round 1: Baseline Cooperation

Since there's no history, I use a **deterministic seeding approach** based on my player index:

```
If my_index <= m:
    Cooperate
Else:
    Defect
```

This ensures exactly m players cooperate in round 1 if all players use this strategy, achieving the threshold efficiently. Against unknown opponents, this provides a cooperative foundation.

### Rounds 2 through (r-1): Adaptive Response

Let `cooperators_last` = number of players who cooperated last round
Let `threshold_met_last` = (cooperators_last >= m)
Let `surplus` = cooperators_last - m
Let `deficit` = m - cooperators_last

**Decision logic:**

```
Calculate my_cooperation_probability:

Base probability = m / n  (fair share expectation)

Adjustments:
- If threshold was NOT met last round:
    Increase probability by: min(0.4, deficit * 0.15)
    
- If threshold was met with surplus >= 2:
    Decrease probability by: min(0.3, surplus * 0.1)
    
- If threshold was met with surplus 0 or 1:
    Keep probability stable (we're at efficient level)

Track: cooperation_rate_history = running average of group cooperation rate
- If cooperation_rate_history < m/n: increase my probability by 0.1
- If cooperation_rate_history > (m+2)/n: decrease my probability by 0.1

Clamp final probability between 0.15 and 0.95

Convert to deterministic decision:
    Cooperate if: (my_index + current_round) mod n < (probability * n)
```

The deterministic conversion uses player index and round number to create pseudo-random but reproducible behavior that distributes cooperation duty across players and rounds.

### Final Round (Round r): Threshold Focus

The last round has no future consequences, but the collective goal remains:

```
If cooperation_rate_history >= m/n (group has been cooperative):
    Use same probability as calculated above
    
If cooperation_rate_history < m/n (group has struggled):
    Cooperate with probability = min(0.8, m/n + 0.2)
    (Increase cooperation to try to save the collective outcome)
```

I do NOT automatically defect in the final round - that would betray the collective mindset.

---

## Edge Cases

### Edge Case 1: Threshold Never Met
If threshold hasn't been met for 3+ consecutive rounds:
- Increase my cooperation probability to 0.7 minimum
- The group is failing; I'd rather over-contribute than watch everyone lose

### Edge Case 2: Always Surplus
If threshold met with surplus ≥ 2 for 3+ consecutive rounds:
- Reduce cooperation probability to max(0.2, m/n - 0.15)
- We're over-providing; some can safely reduce

### Edge Case 3: Exactly at Threshold
If cooperators_last == m for 2+ consecutive rounds:
- Maintain current behavior - we've found equilibrium

### Edge Case 4: I'm Pivotal
If cooperators_last == m-1 AND I defected last round:
- Cooperate this round (my contribution would have made the difference)

If cooperators_last == m AND I cooperated last round:
- Continue cooperating (I may be essential to maintaining threshold)

---

## Pseudocode Summary

```python
def decide(my_index, current_round, total_rounds, n, m, k, history):
    
    if current_round == 1:
        return COOPERATE if my_index <= m else DEFECT
    
    cooperators_last = count_cooperators(history[-1])
    coop_rate_history = average_cooperation_rate(history)
    
    # Base probability
    prob = m / n
    
    # Adjust for last round outcome
    if cooperators_last < m:
        prob += min(0.4, (m - cooperators_last) * 0.15)
    elif cooperators_last >= m + 2:
        prob -= min(0.3, (cooperators_last - m) * 0.1)
    
    # Adjust for historical trend
    if coop_rate_history < m / n:
        prob += 0.1
    elif coop_rate_history > (m + 2) / n:
        prob -= 0.1
    
    # Pivotal player check
    if cooperators_last == m - 1 and my_last_action == DEFECT:
        prob = max(prob, 0.85)
    
    # Emergency: persistent failure
    rounds_failed = count_recent_failures(history, window=3)
    if rounds_failed >= 3:
        prob = max(prob, 0.7)
    
    # Clamp
    prob = clamp(prob, 0.15, 0.95)
    
    # Deterministic conversion
    threshold_position = ((my_index + current_round) % n) / n
    return COOPERATE if threshold_position < prob else DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **I volunteer to cooperate** rather than waiting for others
2. **I respond to group need** - cooperating more when we're failing, less when we're over-providing
3. **I don't exploit the final round** - maintaining cooperation even when it can't be "punished"
4. **I share the burden** - the rotation mechanism distributes cooperation across players
5. **I prioritize threshold success** over individual payoff maximization

This strategy treats the threshold as a genuine collective goal, not just an opportunity for strategic exploitation.
'''

description_COLLECTIVE_80 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I act as if I'm one of m guardians responsible for ensuring the threshold is met. The key insight is that in a collective of like-minded players, we need exactly m cooperators—no more (wasteful), no fewer (catastrophic). My goal is to be one of those m cooperators when needed, while being responsive to the actual behavior of others.

## Strategy Overview

I use a **probabilistic commitment** approach calibrated to produce exactly m cooperators in expectation among cooperative players, combined with **adaptive responsiveness** to observed defection patterns.

---

## Decision Rules

### Round 1: Baseline Cooperation Probability

Since I cannot coordinate explicitly, I cooperate with probability based on being one of m needed cooperators among n players:

```
base_probability = m / n
```

**Rationale**: If all n players use this probability, expected cooperators = n × (m/n) = m. This is the collectively rational starting point.

**Tie-breaker for determinism**: Use player index or round number as seed. Specifically:
```
cooperate if hash(player_id, round, game_id) mod 1000 < base_probability × 1000
```

### Rounds 2 through (r-1): Adaptive Response

After observing previous rounds, I adjust my cooperation probability based on:

#### Step 1: Count reliable cooperators
```
reliable_cooperators = count of players who cooperated in ≥ 50% of past rounds
deficit = m - reliable_cooperators
```

#### Step 2: Assess threshold success rate
```
success_rate = (rounds where ≥ m cooperated) / (total past rounds)
```

#### Step 3: Calculate adjusted probability

```
if reliable_cooperators >= m:
    # Enough consistent cooperators exist - I can afford to defect more
    # But maintain some cooperation to stay in the reliable pool
    adjusted_probability = 0.3
    
elif deficit > 0:
    # Not enough reliable cooperators - increase my commitment
    # Share responsibility among unreliable players
    unreliable_count = n - reliable_cooperators
    if unreliable_count > 0:
        adjusted_probability = min(1.0, deficit / unreliable_count + 0.2)
    else:
        adjusted_probability = 1.0
```

#### Step 4: Respond to recent trends
```
if last round failed (< m cooperators):
    adjusted_probability = min(1.0, adjusted_probability + 0.25)
    
if last 2 rounds both succeeded with exactly m or m+1 cooperators:
    # System is balanced - maintain current behavior
    adjusted_probability = adjusted_probability  # no change

if last round had > m+2 cooperators:
    # Over-cooperation - slight reduction
    adjusted_probability = max(0.2, adjusted_probability - 0.1)
```

### Final Round (Round r): Threshold-Focused Decision

The last round requires special handling since there's no future to influence:

```
if I've been a reliable cooperator (cooperated ≥ 50% of rounds):
    # Maintain my role as guardian
    cooperate with probability 0.8
    
elif reliable_cooperators < m:
    # Critical shortage - step up
    cooperate with probability = min(1.0, (m - reliable_cooperators + 1) / (n - reliable_cooperators))
    
else:
    # Enough guardians exist - defect
    cooperate with probability 0.2
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| **m = n-1 or m = n** | Cooperate with probability 0.9+ (near-universal cooperation needed) |
| **m = 2, n large** | Base probability low, but increase sharply if first rounds fail |
| **All previous rounds failed** | Cooperate with probability 1.0 (emergency mode) |
| **All previous rounds succeeded with many defectors** | Gradually reduce cooperation (others are carrying the load) |
| **I'm the only one who ever cooperates** | After 3 consecutive rounds of being sole cooperator and failing, defect (futility recognition) |
| **k is very large** | No change to base strategy (threshold logic unchanged) |
| **r = 2** | First round: base probability; Second round: if first failed, cooperate; if first succeeded, maintain role |

---

## Pseudocode Summary

```python
def decide(round, history, player_id, n, m, k, r):
    base_prob = m / n
    
    if round == 1:
        return cooperate_with_probability(base_prob, player_id, round)
    
    # Analyze history
    my_coop_rate = my_cooperations(history) / (round - 1)
    reliable = count_reliable_cooperators(history, threshold=0.5)
    recent_success = threshold_met_last_round(history, m)
    total_successes = count_successful_rounds(history, m)
    
    # Adaptive probability
    if reliable >= m:
        prob = 0.3 if my_coop_rate >= 0.5 else 0.5
    else:
        deficit = m - reliable
        unreliable = n - reliable
        prob = min(1.0, deficit / max(1, unreliable) + 0.2)
    
    # Trend adjustment
    if not recent_success:
        prob = min(1.0, prob + 0.25)
    if total_successes == 0 and round > 2:
        prob = 1.0  # Emergency
    
    # Final round adjustment
    if round == r:
        if my_coop_rate >= 0.5:
            prob = 0.8
        elif reliable < m:
            prob = min(1.0, (m - reliable + 1) / max(1, n - reliable))
    
    return cooperate_with_probability(prob, player_id, round)
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: Among identical strategies, exactly m cooperators emerge in expectation
2. **Adaptive**: Responds to both cooperative and exploitative opponents
3. **Resilient**: Increases commitment when threshold is at risk
4. **Efficient**: Reduces wasteful over-cooperation when threshold is secure
5. **History-sensitive**: Builds and maintains a "guardian" identity that others can rely on
6. **No coordination assumed**: Works purely from observable history and game parameters
'''

description_COLLECTIVE_81 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not an exploitable surplus cooperator. The goal is to reliably achieve the collective threshold while minimizing free-riding opportunities for defectors.

## Strategy Overview

I use a **probabilistic commitment** approach calibrated to ensure exactly *m* cooperators emerge in expectation, combined with **responsive adjustment** based on observed group behavior.

---

## Decision Rules

### Round 1: Baseline Cooperation Probability

With no history, I cooperate with probability **p₀ = m/n**.

**Rationale:** If all players use this probability, the expected number of cooperators equals *m*. This is the collectively optimal starting point that doesn't over-commit resources.

### Rounds 2 through (r-1): Adaptive Response

I calculate a **cooperation score** based on recent history and adjust my probability accordingly.

```
Let C_prev = number of cooperators in previous round
Let C_avg = average cooperators over all previous rounds

Base probability: p_base = m/n

Adjustment factors:
1. Threshold gap: gap = (m - C_prev) / n
2. Trend signal: trend = (C_prev - C_avg) / n (positive = cooperation rising)
3. Reliability score: rel = (rounds where C >= m) / (total past rounds)

Adjusted probability:
p_t = clamp(p_base + 0.5*gap + 0.2*trend + 0.3*(0.5 - rel), 0.1, 0.9)
```

**Key behaviors:**
- If cooperation fell short last round (gap > 0): increase my cooperation probability
- If cooperation has been reliable (rel > 0.5): I can slightly reduce my probability
- If cooperation is trending up: slight increase to reinforce positive momentum
- Never go below 0.1 (maintain minimal collective commitment) or above 0.9 (avoid pure exploitation)

### Last Round (Round r): Conditional Cooperation

The final round has no future shadow, creating defection incentives. My approach:

```
If C_avg >= m throughout the game:
    Cooperate with probability p_final = m/n (maintain collective norm)
If C_avg < m (group has been failing):
    Cooperate with probability p_final = min(0.9, m/(C_avg + 1))
    (Attempt to compensate for chronic under-cooperation)
```

**Rationale:** Maintaining cooperation in the last round signals collective commitment and avoids the unraveling that backward induction predicts. If the group has been failing, I make a final effort to reach threshold.

---

## Edge Cases

### Edge Case 1: m = n-1 or m ≈ n
When nearly everyone must cooperate:
- Increase base probability to **p₀ = (m+0.5)/n**
- Be more forgiving of occasional defections (one defector is tolerable)

### Edge Case 2: m is very small (m ≤ n/3)
When few cooperators are needed:
- Use stricter probability: **p₀ = m/n** exactly
- If threshold consistently met, gradually reduce personal probability by 0.05 per round (let others carry the load sometimes)

### Edge Case 3: Persistent Failure (threshold never met in last 3+ rounds)
Emergency escalation:
- Set **p = 0.8** regardless of calculations
- Attempt to catalyze cooperation recovery

### Edge Case 4: Consistent Over-cooperation (C > m+2 regularly)
Exploitation opportunity exists but I partially participate in load-sharing:
- Gradually reduce probability by 0.1 per round until C approaches m+1
- Never drop below **p = m/(2n)**

---

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        return COOPERATE with probability m/n
    
    C_prev = count_cooperators(history[-1])
    C_avg = average_cooperators(history)
    success_rate = count(rounds where cooperators >= m) / len(history)
    
    # Base probability
    p = m/n
    
    # Adjustments
    gap = (m - C_prev) / n
    trend = (C_prev - C_avg) / n
    reliability_adj = 0.5 - success_rate
    
    p = p + 0.5*gap + 0.2*trend + 0.3*reliability_adj
    
    # Emergency escalation
    if last_3_rounds_all_failed(history):
        p = 0.8
    
    # Bounds
    p = clamp(p, 0.1, 0.9)
    
    # Last round logic
    if round == r:
        if success_rate < 0.5:
            p = min(0.9, m/(C_avg + 1))
    
    return COOPERATE with probability p
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing:** If all players use this strategy, cooperation naturally converges to threshold *m*
2. **Responsive:** Adapts to both cooperative and hostile environments
3. **Not exploitable:** Never commits to certain cooperation, maintaining strategic flexibility
4. **Failure-resilient:** Escalates commitment when collective action is failing
5. **Efficient:** Doesn't over-cooperate when threshold is reliably met
'''

description_COLLECTIVE_82 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I assume I am one of m cooperators needed to meet the threshold, and I act accordingly unless evidence strongly suggests otherwise.** The strategy balances collective responsibility with adaptive protection against exploitation.

## Decision Framework

### Key Variables Tracked
- `cooperation_rate`: proportion of players who cooperated in previous rounds
- `threshold_met_history`: whether the threshold was met in each past round
- `consecutive_failures`: number of consecutive rounds where threshold wasn't met
- `consecutive_successes`: number of consecutive rounds where threshold was met
- `my_cooperation_rate`: how often I've cooperated so far

### Round-by-Round Decision Rules

#### First Round: **COOPERATE**

Rationale: With no history, I assume collective responsibility. If all m required cooperators reason this way, we succeed. Defecting first guarantees I'm not part of the solution.

#### Middle Rounds (2 through r-1):

**Primary Rule: Probabilistic Cooperation Based on Observed Need**

```
base_cooperation_probability = m / n  # My "fair share" of responsibility

# Adjust based on history
if threshold_met_last_round:
    if I_cooperated_last_round:
        # I was part of success - maintain with slight reduction to test
        adjust = +0.1
    else:
        # Free-rode successfully - increase cooperation (collective duty)
        adjust = +0.2
else:  # threshold not met
    if I_cooperated_last_round:
        # My cooperation wasn't enough - others need to step up
        # But don't abandon immediately
        adjust = -0.1 * consecutive_failures
    else:
        # I contributed to failure - increase cooperation
        adjust = +0.3

cooperation_probability = clamp(base_cooperation_probability + adjust, 0.1, 0.95)
```

**Override Conditions:**

1. **Emergency Cooperation**: If `consecutive_failures >= 2`, set `cooperation_probability = min(0.9, m/n + 0.3)` — the collective is failing and needs more contributors.

2. **Exploitation Protection**: If `threshold_met_history` shows success rate > 80% AND `cooperation_rate < m/n + 0.1`, others may be free-riding on reliable cooperators. Reduce probability by 0.15 to signal that cooperation isn't guaranteed.

3. **Reward Responsiveness**: If `k >= 2`, bias toward cooperation (+0.1) since the collective benefit strongly outweighs individual cost.

#### Last Round: **CONDITIONAL COOPERATION**

```
if historical_cooperation_rate >= m/n:
    # Community has shown collective spirit - honor it
    COOPERATE with probability m/n + 0.1
else:
    # Community has been defection-heavy
    COOPERATE with probability max(0.2, m/n - 0.2)
```

Rationale: Even in the last round, if the collective has functioned well, I maintain my role. Pure defection in the final round betrays a functioning collective.

### Edge Case Handling

| Scenario | Action |
|----------|--------|
| n = m (everyone must cooperate) | Cooperate always; any defection dooms everyone |
| m = 2, n large | Lower base probability, but never below 2/n + 0.1 |
| k very large (k > 3) | Increase cooperation probability by 0.15 |
| k barely above 1 | Stick to base probabilities; marginal benefit doesn't justify extra risk |
| All previous rounds failed | Cooperate with probability 0.7 (attempt recovery, but protect against hopeless scenarios) |
| All previous rounds succeeded | Maintain current cooperation level; don't destabilize success |

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return COOPERATE
    
    # Calculate base probability
    base_prob = m / n
    
    # Historical adjustments
    coop_rate = calculate_cooperation_rate(history)
    success_rate = calculate_success_rate(history)
    my_coop_rate = calculate_my_cooperation_rate(history)
    consec_fail = consecutive_failures(history)
    
    # Adjust probability
    prob = base_prob
    
    if history[-1].threshold_met:
        prob += 0.2 if not history[-1].i_cooperated else 0.1
    else:
        prob += 0.3 if not history[-1].i_cooperated else (-0.1 * consec_fail)
    
    # Override conditions
    if consec_fail >= 2:
        prob = max(prob, 0.7)
    if success_rate > 0.8 and coop_rate < m/n + 0.1:
        prob -= 0.15
    if k >= 2:
        prob += 0.1
    
    # Last round adjustment
    if round == r:
        if coop_rate >= m/n:
            prob = m/n + 0.1
        else:
            prob = max(0.2, m/n - 0.2)
    
    prob = clamp(prob, 0.1, 0.95)
    return COOPERATE if random() < prob else DEFECT
```

## Why This Strategy Is Collectively Aligned

1. **Assumes shared responsibility**: Starts cooperative and maintains fair-share contribution
2. **Responds to collective failure**: Increases effort when the group fails, rather than abandoning ship
3. **Resists pure exploitation**: Gradually reduces cooperation if being systematically exploited
4. **Maintains end-game integrity**: Doesn't betray a functioning collective in the final round
5. **Scales with parameters**: Adjusts to reward magnitude and threshold requirements
'''

description_COLLECTIVE_83 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not a sucker who cooperates when others free-ride excessively. The strategy balances reliability (being someone the group can count on) with responsiveness (adjusting to actual group behavior).

## Strategy Overview

I position myself as a "conditional cooperator with threshold commitment" - I'm willing to be part of the cooperative core, but I track whether the group is achieving the threshold and adjust my cooperation probability based on collective success rates.

---

## Decision Rules

### Round 1: Cooperative Signal
**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent. This establishes me as someone willing to contribute and gives information about others' strategies.

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate the following metrics from history:
- `success_rate` = (rounds where ≥m cooperated) / (rounds played)
- `cooperation_rate` = (total C actions by all players) / (total actions)
- `avg_cooperators` = average number of cooperators per round

**Decision Logic:**

```
IF avg_cooperators >= m THEN
    # Threshold is being met - be part of the reliable core
    IF I cooperated last round AND threshold was met:
        COOPERATE (stay reliable)
    ELSE IF cooperation_rate > m/n:
        # Enough cooperation exists - join/stay in
        COOPERATE
    ELSE:
        COOPERATE with probability = m/n
        
ELSE IF avg_cooperators >= m - 1 THEN
    # We're close! My cooperation likely matters
    COOPERATE
    
ELSE IF avg_cooperators < m/2 THEN
    # Cooperation is collapsing - occasional probe
    COOPERATE with probability = 0.2
    
ELSE
    # Middle ground - probabilistic cooperation
    COOPERATE with probability = min(0.8, (avg_cooperators + 1) / m)
```

### Final Round (Round r): Calculated Commitment

The last round removes future consequences, creating defection temptation. However, the collective benefit still matters.

```
IF success_rate >= 0.5 AND avg_cooperators >= m - 1 THEN
    # Group has been cooperative - honor the implicit agreement
    COOPERATE
ELSE IF avg_cooperators >= m THEN
    # Threshold met without me? Take the free ride
    DEFECT
ELSE
    # My cooperation might tip us over
    COOPERATE with probability = m / (avg_cooperators + 1)
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = m (all must cooperate) | Always COOPERATE | Any defection dooms everyone |
| m = 2, n large | COOPERATE rounds 1-3, then match top cooperators | Need a small reliable core |
| k very large (k > n) | Bias toward COOPERATE | Risk of missing threshold is catastrophic |
| k barely > 1 | More willing to DEFECT | Free-riding cost is low |
| r = 2 | COOPERATE both rounds | Too short for adaptive learning |
| Perfect cooperation so far | COOPERATE | Don't be the one to break it |
| Zero cooperation last round | COOPERATE with p=0.3 | Probe for recovery |

---

## Pseudocode Implementation

```python
def decide(round_num, total_rounds, history, n, m, k):
    
    if round_num == 1:
        return COOPERATE
    
    # Calculate history metrics
    cooperators_per_round = [sum(actions) for actions in history]
    avg_cooperators = mean(cooperators_per_round)
    success_rate = sum(1 for c in cooperators_per_round if c >= m) / len(history)
    my_last_action = history[-1][my_index]
    last_round_cooperators = cooperators_per_round[-1]
    
    # Final round logic
    if round_num == total_rounds:
        if success_rate >= 0.5 and avg_cooperators >= m - 1:
            return COOPERATE
        elif avg_cooperators >= m:
            return DEFECT
        else:
            return COOPERATE if random() < m / (avg_cooperators + 1) else DEFECT
    
    # Middle rounds logic
    if avg_cooperators >= m:
        if my_last_action == COOPERATE and last_round_cooperators >= m:
            return COOPERATE
        return COOPERATE if random() < 0.85 else DEFECT
    
    elif avg_cooperators >= m - 1:
        return COOPERATE  # I could be the critical cooperator
    
    elif avg_cooperators < m / 2:
        return COOPERATE if random() < 0.2 else DEFECT
    
    else:
        prob = min(0.8, (avg_cooperators + 1) / m)
        return COOPERATE if random() < prob else DEFECT
```

---

## Why This Strategy is Collectively-Minded

1. **I volunteer to be in the cooperative core** - Rather than waiting for others, I start cooperative and stay cooperative when the threshold is achievable.

2. **I respond to collective success, not individual exploitation** - I don't punish specific defectors; I respond to whether *we as a group* are succeeding.

3. **I'm forgiving and probe for recovery** - Even after cooperation collapses, I occasionally cooperate to test if others will rejoin.

4. **I prioritize threshold achievement over personal optimization** - When we're at m-1 cooperators, I cooperate even though defecting would give me +1 if others push us over.

5. **I maintain commitment through the end** - I don't abandon cooperation in the final round if the group has been trustworthy.
'''

description_COLLECTIVE_84 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to ensure the group achieves the threshold and everyone benefits. The strategy adapts based on observed cooperation levels, aiming to be exactly as cooperative as needed to reach threshold m while being robust to free-riders.

## Key Insight

The collective optimum requires exactly m cooperators each round (achieving threshold with minimum sacrifice). The challenge is coordinating who cooperates without communication. My strategy uses observable history to implicitly coordinate, treating my role as "filling the gap" to reach threshold when needed.

---

## Decision Rules

### Round 1: Probabilistic Seeding

With no history, cooperate with probability `m/n`.

**Rationale:** If all players use this rule, expected cooperators = m, which is exactly threshold. This is the collectively optimal starting point without coordination.

### Rounds 2 to (r-1): Adaptive Gap-Filling

After observing previous rounds, calculate:

```
recent_coop_rate = (cooperators in last 3 rounds) / (3 * n)
                   [or all available rounds if < 3 played]

coop_deficit = m/n - recent_coop_rate  # How far below threshold ratio
```

**Decision Logic:**

```
IF recent_coop_rate >= m/n:
    # Threshold likely met - cooperate with moderate probability
    cooperate_probability = m/n * 0.8
    
ELSE IF coop_deficit > 0:
    # Below threshold - increase cooperation to compensate
    cooperate_probability = min(1.0, m/n + coop_deficit * 1.5)
```

**Additional Adjustment - Consistency Bonus:**
```
IF I cooperated last round AND threshold was met last round:
    # Reward successful cooperation patterns
    cooperate_probability += 0.1

IF I defected last round AND threshold was NOT met:
    # My defection may have caused failure - compensate
    cooperate_probability += 0.2
```

### Final Round (Round r): Threshold Commitment

The last round has no future to influence, but collective success still matters.

```
IF average cooperation rate across all rounds >= (m-0.5)/n:
    # Group has been cooperative - maintain solidarity
    cooperate_probability = m/n
ELSE:
    # Group has struggled - make extra effort for final success
    cooperate_probability = min(1.0, (m+1)/n)
```

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    
    if round_num == 1:
        return cooperate_with_probability(m / n)
    
    # Calculate recent cooperation metrics
    lookback = min(3, round_num - 1)
    recent_coops = sum(cooperators in last `lookback` rounds)
    recent_coop_rate = recent_coops / (lookback * n)
    
    # Base probability
    base_prob = m / n
    
    # Adjust for deficit/surplus
    deficit = (m / n) - recent_coop_rate
    adjusted_prob = base_prob + (deficit * 1.5)
    
    # Consistency adjustments
    if my_last_action == C and last_round_met_threshold:
        adjusted_prob += 0.1
    if my_last_action == D and not last_round_met_threshold:
        adjusted_prob += 0.2
    
    # Final round adjustment
    if round_num == total_rounds:
        overall_rate = total_cooperations / ((round_num - 1) * n)
        if overall_rate < (m - 0.5) / n:
            adjusted_prob += 0.15
    
    # Clamp probability
    final_prob = clamp(adjusted_prob, 0.05, 0.95)
    
    return cooperate_with_probability(final_prob)
```

---

## Why This Strategy Is Collectively Robust

1. **No exploitation of others:** I don't try to free-ride on cooperators; I contribute my fair share (m/n baseline).

2. **Compensates for defectors:** When cooperation falls short, I increase my contribution rather than retaliating.

3. **Rewards group success:** Successful threshold achievement reinforces cooperative behavior.

4. **Probabilistic coordination:** Using probability m/n creates implicit coordination without communication—collectively, we converge toward exactly m cooperators.

5. **No end-game collapse:** Final round maintains cooperative stance rather than universal defection.

6. **Bounded generosity:** Caps at 95% to avoid being completely exploitable, maintains 5% floor to stay engaged.
'''

description_COLLECTIVE_85 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to ensure the collective threshold is met while being resilient to defectors. The key insight is that exactly m cooperators is optimal for the group (threshold met, minimum sacrifice), but we need redundancy against uncertainty.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to produce exactly enough cooperators in expectation, with adjustments based on observed behavior. The strategy adapts to create a self-organizing system where the right number of players cooperate without explicit coordination.

---

## Decision Rules

### Round 1: Baseline Probabilistic Cooperation

With no history, cooperate with probability:

```
p_base = (m + buffer) / n

where buffer = min(1, (n - m) / 3)
```

The buffer accounts for variance and potential defectors. This ensures that in expectation, slightly more than m players cooperate.

### Rounds 2 through (r-1): Adaptive Cooperation

**Step 1: Calculate cooperation rate from previous round**
```
observed_cooperators = count of C plays in round t-1
cooperation_rate = observed_cooperators / n
```

**Step 2: Assess threshold health**
```
threshold_met_last_round = (observed_cooperators >= m)
surplus = observed_cooperators - m
deficit = m - observed_cooperators
```

**Step 3: Determine cooperation probability**

```
IF threshold was NOT met last round:
    # Emergency mode - increase cooperation
    p_cooperate = min(0.95, p_base + 0.2 + (deficit / n))
    
ELSE IF surplus >= 2:
    # Too many cooperators - some can safely defect
    # But I should cooperate if I cooperated last round (stability)
    IF I cooperated last round:
        p_cooperate = max(0.6, 1 - (surplus / (2 * n)))
    ELSE:
        p_cooperate = max(0.3, p_base - (surplus / (2 * n)))
        
ELSE IF surplus == 1:
    # Healthy margin - maintain similar behavior
    IF I cooperated last round:
        p_cooperate = 0.75
    ELSE:
        p_cooperate = p_base
        
ELSE (surplus == 0, exactly m cooperators):
    # Fragile - need more cooperators
    IF I cooperated last round:
        p_cooperate = 0.85
    ELSE:
        p_cooperate = min(0.7, p_base + 0.15)
```

**Step 4: Long-term reputation adjustment**

Track each player position's cooperation history:
```
IF average cooperation rate across all rounds < m/n - 0.1:
    # Population is under-cooperating
    p_cooperate = min(0.9, p_cooperate + 0.1)
    
IF average cooperation rate > (m + 2)/n:
    # Population is over-cooperating, safe to reduce
    p_cooperate = max(0.2, p_cooperate - 0.05)
```

### Final Round (Round r): Collective Commitment

The last round has no shadow of the future, creating defection incentives. However, maintaining collective mindset:

```
IF threshold was met in majority of previous rounds:
    # Reward the collective success - maintain cooperation
    p_cooperate = p_base  # No exploitation
    
ELSE:
    # Last chance to achieve threshold
    p_cooperate = min(0.9, p_base + 0.15)
```

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **m = n-1** (nearly all must cooperate) | Set p_base = 0.95, minimal adjustment downward |
| **m = 2** (low threshold) | Allow more defection tolerance, p_base can drop to 0.4 if surplus observed |
| **n is very large** | Rely more heavily on probabilistic base rate, smaller adjustments |
| **k is very large** | Threshold is critical; bias toward cooperation (+0.1 to all probabilities) |
| **k is barely > 1** | Threshold less critical; allow base rates without adjustment |
| **Observed: same players always defect** | Do not retaliate; focus on whether threshold is met |
| **r = 2** (minimal rounds) | Use base probability both rounds; insufficient data to adapt |

---

## Pseudocode Summary

```python
def decide(game_params, history, my_player_id):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    buffer = min(1, (n - m) / 3)
    p_base = (m + buffer) / n
    
    if current_round == 1:
        return cooperate_with_probability(p_base)
    
    last_round = history[-1]
    observed_coop = sum(1 for action in last_round if action == 'C')
    i_cooperated = (last_round[my_player_id] == 'C')
    surplus = observed_coop - m
    
    # Calculate adaptive probability
    if observed_coop < m:
        p = min(0.95, p_base + 0.2 + (m - observed_coop) / n)
    elif surplus >= 2:
        p = 0.6 if i_cooperated else max(0.3, p_base - surplus/(2*n))
    elif surplus == 1:
        p = 0.75 if i_cooperated else p_base
    else:  # surplus == 0
        p = 0.85 if i_cooperated else min(0.7, p_base + 0.15)
    
    # Long-term adjustment
    avg_coop_rate = mean([sum(r)/n for r in history])
    if avg_coop_rate < m/n - 0.1:
        p = min(0.9, p + 0.1)
    elif avg_coop_rate > (m + 2)/n:
        p = max(0.2, p - 0.05)
    
    return cooperate_with_probability(p)
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: Probabilistic approach means the group naturally finds equilibrium without coordination
2. **Threshold-focused**: All adjustments aim to meet m, not maximize individual gain
3. **Stable**: Cooperators tend to stay cooperators, reducing volatility
4. **Forgiving**: Doesn't punish defectors; focuses on collective outcome
5. **Adaptive**: Responds to actual group behavior, not assumptions about opponents
6. **No exploitation**: Doesn't defect in final round despite incentive
'''

description_COLLECTIVE_86 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not more than necessary. The goal is to ensure the threshold is met while minimizing free-riding opportunities for defectors. I'll use observable history to estimate others' cooperation rates and adjust my behavior to be a reliable "gap filler" who cooperates when cooperation is scarce and can safely defect when others are reliably cooperating.

---

## Strategy Specification

### Key Variables Tracked
- `coop_rate`: Observed average cooperation rate across all players in previous rounds
- `threshold_met_rate`: Fraction of past rounds where ≥ m players cooperated
- `my_position`: My implicit "role" based on a deterministic hash of the round and game state

### Decision Rules

#### Round 1 (No History)
**Cooperate with probability m/n** (deterministically based on player index if known, otherwise use round number as seed).

Since I cannot coordinate explicitly, I'll use a simple rule: if `(round_number + some_fixed_seed) mod n < m`, then cooperate. This ensures that in expectation, exactly m players cooperate if all use this strategy.

*Simplified for implementation*: **Cooperate in Round 1** as a trust signal and to establish cooperative norms.

#### Middle Rounds (Rounds 2 through r-1)

**Step 1: Calculate cooperation need**
```
observed_cooperators_last_round = count of C plays in round t-1
cooperation_deficit = m - observed_cooperators_last_round
```

**Step 2: Adaptive response based on history**

```
IF threshold_met_rate >= 0.8 (threshold reliably met):
    # Others are cooperating enough - I can occasionally defect
    IF observed_cooperators_last_round > m + 1:
        DEFECT (surplus cooperators exist)
    ELSE:
        COOPERATE (maintain stability)

ELSE IF threshold_met_rate >= 0.5 (threshold sometimes met):
    # Situation is fragile - lean toward cooperation
    IF I cooperated last round AND threshold was met:
        COOPERATE (stay the course)
    ELSE IF I defected last round AND threshold was NOT met:
        COOPERATE (I may have been the missing piece)
    ELSE:
        COOPERATE with probability m/n

ELSE (threshold rarely met, threshold_met_rate < 0.5):
    # Cooperation is collapsing - attempt to rescue
    IF coop_rate < m/n:
        COOPERATE (try to build cooperation)
    ELSE:
        # Others cooperate but not enough - still cooperate
        COOPERATE
```

**Step 3: Responsive adjustment**
```
IF last round had exactly m cooperators AND I was one of them:
    COOPERATE (I'm critical)
    
IF last round had exactly m-1 cooperators AND I defected:
    COOPERATE (I could have made the difference)
```

#### Final Round (Round r)
The last round removes future consequences, creating defection incentives.

```
IF threshold_met_rate >= 0.7 AND observed_cooperators_last_round >= m:
    # Trust has been established - maintain collective success
    COOPERATE (preserve collective gains, avoid collapse)
ELSE:
    # Cooperation has been weak - cooperate to attempt one final success
    COOPERATE
```

*Rationale*: Defecting in the final round when others expect cooperation destroys collective value. The payoff difference (1 unit) is small compared to losing k for everyone.

---

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        return COOPERATE
    
    coop_counts = [count of C in each past round]
    threshold_met_rate = (rounds where count >= m) / (round - 1)
    last_round_cooperators = coop_counts[-1]
    my_last_action = history[me][-1]
    
    # Final round logic
    if round == r:
        return COOPERATE
    
    # Critical cooperator check
    if last_round_cooperators == m and my_last_action == C:
        return COOPERATE
    
    # Guilt response - I may have caused failure
    if last_round_cooperators == m - 1 and my_last_action == D:
        return COOPERATE
    
    # Adaptive based on success rate
    if threshold_met_rate >= 0.8:
        if last_round_cooperators > m + 1:
            return DEFECT
        else:
            return COOPERATE
    else:
        return COOPERATE
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish trust, signal cooperative intent |
| Final round | Cooperate | Maintain collective value, avoid unraveling |
| Threshold barely met (exactly m) | Cooperate if I was part of m | I'm critical |
| Threshold missed by 1, I defected | Cooperate | Compensate for past failure |
| Surplus cooperators (> m+1) | Defect | Safe free-riding, others have it covered |
| Chronic failure (< 50% success) | Cooperate | Attempt to rescue cooperation |

---

## Why This Strategy is Collectively Robust

1. **Never abandons cooperation entirely**: Even against mostly-defecting opponents, I keep trying because the threshold benefit (k > 1) justifies the cost.

2. **Doesn't over-cooperate**: When cooperation is abundant, I can safely defect, preserving resources while others maintain the threshold.

3. **Responds to being pivotal**: Explicitly tracks whether I was likely the deciding vote and adjusts accordingly.

4. **No complex coordination required**: All decisions based on observable history and game parameters.

5. **Resists exploitation**: By cooperating when needed but defecting when safe, I don't become a pure "sucker" that always cooperates regardless of others.
'''

description_COLLECTIVE_87 = '''
# Collective Risk Dilemma: Adaptive Threshold Strategy

## Core Philosophy

This strategy embraces a **collective-first mindset**: I assume other players may be running similar reasoning and aim to coordinate implicitly through observable behavior patterns. The goal is to reliably achieve the cooperation threshold while being robust against defectors and adaptive to the actual population behavior.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic self-selection** to coordinate without communication
2. **Responsive adaptation** based on observed cooperation levels
3. **Threshold-aware adjustment** to avoid both under- and over-contribution

---

## Decision Rules

### Round 1: Probabilistic Seeding

Since no history exists, I use a **probabilistic cooperation rule** based on the threshold ratio:

```
cooperation_probability = (m / n) + safety_margin
where safety_margin = min(0.15, (n - m) / (2 * n))
```

This slightly over-seeds cooperation to account for variance while not being wastefully generous.

**Decision**: Cooperate with probability = `cooperation_probability`

*Rationale*: If all players use similar logic, expected cooperators ≈ m + buffer, reliably meeting the threshold.

---

### Rounds 2 through (r-1): Adaptive Response

Let `prev_cooperators` = number of cooperators in the previous round.

#### Case A: Previous round met threshold (prev_cooperators ≥ m)

**If prev_cooperators == m exactly:**
- Cooperation was fragile; maintain current behavior
- If I cooperated last round: Cooperate again (I'm part of the critical coalition)
- If I defected last round: Cooperate with probability `m / (n - prev_cooperators + m)` to gradually increase reliability

**If prev_cooperators > m (surplus cooperation):**
- There's room to free-ride, but collective stability matters
- Calculate `surplus = prev_cooperators - m`
- If I cooperated last round: Defect with probability `surplus / (2 * prev_cooperators)` (gradual reduction)
- If I defected last round: Stay defecting (surplus exists)

**If prev_cooperators < m (threshold failed):**
- Collective action failed; increase cooperation effort
- Cooperate with probability `min(1.0, (m / prev_cooperators) * 0.7)`
- This scales up cooperation proportionally to how badly we missed

#### Case B: Trend-Aware Adjustment

Track cooperation over last 3 rounds (when available):

```
trend = (cooperators[t-1] - cooperators[t-3]) / 2
if trend < -0.5:  # Cooperation declining
    increase cooperation probability by 0.1
if trend > 0.5:   # Cooperation rising
    can slightly decrease if above threshold
```

---

### Final Round (Round r): Rational Endgame

The last round has no future consequences, changing incentives significantly.

**Key insight**: With collective mindset, we want the threshold met even in the final round.

**Decision rule for round r:**
- Calculate `expected_others_cooperating` based on average cooperation rate from rounds (r-3) to (r-1)
- If `expected_others_cooperating >= m`: Defect (threshold likely met without me)
- If `expected_others_cooperating < m` and `expected_others_cooperating + 1 >= m`: Cooperate (I could be pivotal)
- If `expected_others_cooperating + 1 < m`: Defect (threshold unreachable regardless)

**Tie-breaking**: If exactly at the threshold boundary, cooperate with probability `0.5 + (k / (2 * (1 + k)))` (higher k → more reason to secure the bonus)

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r, my_id):
    
    if round == 1:
        safety = min(0.15, (n - m) / (2 * n))
        prob = (m / n) + safety
        return COOPERATE if random() < prob else DEFECT
    
    prev_coop = count_cooperators(history[round - 1])
    my_prev_action = history[round - 1][my_id]
    
    if round == r:  # Final round
        expected_others = average_cooperation(history, last_k=3) * (n - 1) / n
        if expected_others >= m:
            return DEFECT
        elif expected_others + 1 >= m:
            pivot_prob = 0.5 + (k / (2 * (1 + k)))
            return COOPERATE if random() < pivot_prob else DEFECT
        else:
            return DEFECT
    
    # Middle rounds
    if prev_coop >= m:
        surplus = prev_coop - m
        if surplus == 0:
            return my_prev_action  # Maintain critical coalition
        else:
            if my_prev_action == COOPERATE:
                defect_prob = surplus / (2 * prev_coop)
                return DEFECT if random() < defect_prob else COOPERATE
            else:
                return DEFECT
    else:  # Threshold failed
        recovery_prob = min(1.0, (m / max(prev_coop, 1)) * 0.7)
        return COOPERATE if random() < recovery_prob else DEFECT
```

---

## Edge Case Handling

| Situation | Action |
|-----------|--------|
| Round 1, m = n-1 (nearly all must cooperate) | Cooperate deterministically |
| Round 1, m = 2 (low threshold) | Use base probability, no extra buffer |
| History shows 0 cooperators | Cooperate with probability 0.8 (attempt restart) |
| All previous rounds succeeded | Gradually reduce to efficient level |
| k is very large (k > 5) | Bias toward cooperation (high stakes) |
| r = 2 (only two rounds) | Round 1 probabilistic, Round 2 endgame logic |

---

## Robustness Properties

1. **Against all-defect opponents**: Will eventually reduce cooperation, limiting losses
2. **Against all-cooperate opponents**: Will free-ride somewhat but not collapse cooperation
3. **Against mixed strategies**: Adapts to actual cooperation levels observed
4. **Against similar strategies**: Implicit coordination through shared threshold-awareness
5. **Against trigger strategies**: No betrayal to trigger; maintains baseline cooperation

This strategy prioritizes **collective success** while remaining **individually rational** through adaptive response to observed behavior.
'''

description_COLLECTIVE_88 = '''
# Collective Risk Dilemma: Adaptive Threshold Strategy

## Strategic Analysis

The core tension in this game is clear: if exactly m players cooperate, defectors get the best outcome (k+1), while cooperators get only k. However, if fewer than m cooperate, everyone loses the bonus k. The collective optimum requires coordination to ensure exactly m cooperators while minimizing "wasted" cooperation.

Since we cannot communicate or pre-coordinate, I need a strategy that:
1. Helps reach the threshold m when cooperation is needed
2. Avoids being exploited by persistent defectors
3. Adapts to observed behavior patterns
4. Signals cooperative intent while remaining robust

## Strategy: "Adaptive Threshold Cooperator"

### Core Philosophy
I adopt a **collectively-minded but adaptive** approach: I'm willing to cooperate to help reach threshold, but I adjust my cooperation probability based on whether the group is achieving collective success and whether I'm being systematically exploited.

### Decision Rules

#### Round 1: Cooperative Signal
**Action: Cooperate**

Rationale: In the absence of history, I signal cooperative intent. This establishes a baseline and gives information about others' dispositions.

#### Rounds 2 through (r-1): Adaptive Cooperation

**Step 1: Calculate cooperation metrics from history**
- `total_cooperators_last_round`: count of C plays in round t-1
- `threshold_met_rate`: proportion of past rounds where ≥m players cooperated
- `my_cooperation_rate`: proportion of rounds I've played C
- `others_avg_cooperation`: average cooperation rate of other players

**Step 2: Determine base cooperation probability**

```
if threshold_met_rate >= 0.7:
    # Group is successfully coordinating
    base_prob = m / n  # Fair share probability
else:
    # Group is failing to coordinate - increase cooperation
    base_prob = min(0.9, (m + 1) / n)
```

**Step 3: Adjust for exploitation detection**

```
exploitation_score = my_cooperation_rate - others_avg_cooperation

if exploitation_score > 0.2:
    # I'm cooperating much more than others - reduce slightly
    adjustment = -0.15
elif exploitation_score < -0.1:
    # I'm free-riding more than average - increase
    adjustment = +0.15
else:
    adjustment = 0

adjusted_prob = base_prob + adjustment
```

**Step 4: Respond to recent threshold status**

```
if total_cooperators_last_round == m - 1:
    # We were one short - I should help
    adjusted_prob = max(adjusted_prob, 0.8)
elif total_cooperators_last_round == m:
    # Perfect coordination achieved
    if I cooperated last round:
        # Give someone else a turn to cooperate
        adjusted_prob = min(adjusted_prob, 0.5)
elif total_cooperators_last_round > m + 1:
    # Over-cooperation - some can safely defect
    adjusted_prob = min(adjusted_prob, (m / total_cooperators_last_round))
elif total_cooperators_last_round < m - 1:
    # Severe under-cooperation
    adjusted_prob = min(0.95, adjusted_prob + 0.2)
```

**Step 5: Make decision**
- Cooperate with probability = clamp(adjusted_prob, 0.1, 0.95)

#### Final Round (Round r): Modified Calculation

The last round has no future shadow, so pure game theory suggests defection. However, maintaining collective success matters:

```
if threshold_met_rate >= 0.5:
    # Group has been cooperative - maintain threshold
    final_prob = m / n + 0.1  # Slightly above fair share
else:
    # Group has largely failed - lower cooperation
    final_prob = max(0.2, m / (2 * n))

Cooperate with probability final_prob
```

### Edge Cases

| Situation | Response |
|-----------|----------|
| n = 2, m = 2 | Both must cooperate; cooperate with p=0.85 always |
| m = n - 1 | Near-unanimous needed; cooperate with p=0.9+ |
| m very small relative to n | Use base probability m/n, trust others |
| k very large | Increase cooperation probability by 10% |
| All others defected last round | Cooperate (someone must start) |
| r = 2 (minimal rounds) | Cooperate both rounds with high probability |

### Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE
    
    stats = calculate_statistics(history)
    
    # Base probability from threshold success
    if stats.threshold_met_rate >= 0.7:
        prob = m / n
    else:
        prob = min(0.9, (m + 1) / n)
    
    # Exploitation adjustment
    exploitation = stats.my_coop_rate - stats.others_avg_coop
    prob += clamp(exploitation * -0.5, -0.15, 0.15)
    
    # Recent round response
    last_coop_count = stats.cooperators_last_round
    if last_coop_count == m - 1:
        prob = max(prob, 0.8)
    elif last_coop_count == m and I_cooperated_last:
        prob = min(prob, 0.5)
    elif last_coop_count > m + 1:
        prob = min(prob, m / last_coop_count)
    elif last_coop_count < m - 1:
        prob = min(0.95, prob + 0.2)
    
    # Final round adjustment
    if round == r:
        prob = prob * 0.8 if stats.threshold_met_rate < 0.5 else prob
    
    prob = clamp(prob, 0.1, 0.95)
    return COOPERATE if random() < prob else DEFECT
```

### Why This Strategy is Collectively Aligned

1. **Willing to initiate**: Cooperates first to enable coordination
2. **Fair share principle**: Aims for m/n cooperation probability when things work
3. **Responsive to need**: Increases cooperation when threshold is missed
4. **Rotation implicit**: Reduces personal cooperation after contributing to success
5. **Not exploitable**: Gradually reduces cooperation if consistently taken advantage of
6. **Maintains hope**: Never fully defects, always gives collective success a chance
'''

description_COLLECTIVE_89 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not a sucker who cooperates when it's unnecessary or futile. The key insight is that in a collective setting, we need exactly *m* cooperators—no more, no fewer is optimal for the group. I'll use observable history to coordinate toward this equilibrium without explicit communication.

## Strategy Overview

I use a probabilistic cooperation approach calibrated by:
1. **Base probability** derived from the threshold ratio (m/n)
2. **History-based adjustments** responding to observed cooperation levels
3. **Round-aware modifications** for early exploration and late-game considerations

---

## Decision Rules

### Round 1: Cooperative Initialization

**Action:** Cooperate with probability `p_base = m/n + 0.1` (capped at 0.95)

**Rationale:** In a collective mindset, someone must start cooperating. By setting initial cooperation slightly above the threshold ratio, we signal willingness to be part of the solution while not being exploitable. The small boost (+0.1) reflects collective responsibility—I'd rather err toward cooperation early.

---

### Rounds 2 through (r-1): Adaptive Response

**Step 1: Count previous round cooperators** → `c_prev`

**Step 2: Classify the situation:**

| Situation | Condition | Interpretation |
|-----------|-----------|----------------|
| Under-threshold | `c_prev < m` | Collective failure—need more cooperation |
| At-threshold | `c_prev = m` | Perfect coordination achieved |
| Over-threshold | `c_prev > m` | Excess cooperation—some can safely defect |

**Step 3: Calculate cooperation probability:**

```
if c_prev < m:
    # We failed. Increase cooperation to help reach threshold.
    shortfall = m - c_prev
    p_coop = min(0.95, m/n + 0.2 * (shortfall / m))
    
elif c_prev == m:
    # Perfect! Maintain similar behavior.
    # If I cooperated last round, likely continue (stability)
    # If I defected, consider switching to share burden
    if I_cooperated_last_round:
        p_coop = 0.7  # Tend to maintain, but allow rotation
    else:
        p_coop = 0.4  # Consider joining to enable rotation
        
elif c_prev > m:
    # Excess cooperation. Can safely reduce.
    excess = c_prev - m
    p_coop = max(0.1, m/n - 0.15 * (excess / (n - m)))
```

**Step 4: Apply historical trend adjustment:**

```
# Look at cooperation trend over last 3 rounds (if available)
if rounds_played >= 3:
    recent_avg = average(cooperators in last 3 rounds)
    overall_avg = average(cooperators in all rounds)
    
    if recent_avg < overall_avg - 0.5:
        # Cooperation declining—boost my probability
        p_coop = min(0.95, p_coop + 0.1)
    elif recent_avg > overall_avg + 0.5:
        # Cooperation increasing—can relax slightly
        p_coop = max(0.1, p_coop - 0.05)
```

**Step 5: Apply personal history fairness adjustment:**

```
my_coop_rate = (my cooperations) / (rounds played)
expected_fair_share = m / n

if my_coop_rate > expected_fair_share + 0.2:
    # I've been doing more than my share
    p_coop = max(0.15, p_coop - 0.1)
elif my_coop_rate < expected_fair_share - 0.2:
    # I've been free-riding too much
    p_coop = min(0.9, p_coop + 0.1)
```

---

### Final Round (Round r): Modified Calculation

The last round has no future—pure game theory applies more strongly.

```
# Start with standard adaptive calculation from above
p_coop = [calculated as above]

# Adjust based on what's likely needed
if historical_cooperation_avg >= m:
    # Group has been successful—slight reduction acceptable
    p_coop = max(0.2, p_coop - 0.1)
else:
    # Group has struggled—maintain or increase cooperation
    p_coop = min(0.9, p_coop + 0.05)
```

---

## Edge Case Handling

### Very Small Groups (n ≤ 3)
When n is small, individual actions matter enormously. Increase base cooperation by 0.15.

### High Threshold Games (m > n/2)
Cooperation is essential. Set minimum cooperation probability to 0.4.

### Low Threshold Games (m ≤ n/4)  
Risk of over-cooperation. Set maximum cooperation probability to 0.7.

### Extreme History (all cooperate or all defect for 3+ rounds)
- All cooperate: Reduce to p_coop = m/n (fair share)
- All defect: Attempt to spark cooperation with p_coop = 0.6

---

## Pseudocode Summary

```python
def decide(round, history, my_history, n, m, r, k):
    
    if round == 1:
        p_coop = min(0.95, m/n + 0.1)
    else:
        c_prev = count_cooperators(history[round-1])
        
        # Base calculation from cooperation level
        if c_prev < m:
            p_coop = min(0.95, m/n + 0.2 * ((m - c_prev) / m))
        elif c_prev == m:
            p_coop = 0.7 if my_history[round-1] == 'C' else 0.4
        else:
            p_coop = max(0.1, m/n - 0.15 * ((c_prev - m) / (n - m)))
        
        # Trend adjustment
        p_coop = adjust_for_trend(p_coop, history)
        
        # Fairness adjustment
        p_coop = adjust_for_fairness(p_coop, my_history, m, n)
        
        # Final round adjustment
        if round == r:
            p_coop = final_round_adjust(p_coop, history, m)
        
        # Edge case bounds
        p_coop = apply_edge_case_bounds(p_coop, n, m)
    
    return 'C' if random() < p_coop else 'D'
```

---

## Why This Strategy is Collectively Minded

1. **Willing to initiate cooperation** rather than waiting for others
2. **Responds to collective need**—increases effort when threshold unmet
3. **Enables burden-sharing** through probabilistic rotation
4. **Self-regulates** to avoid exploitation while remaining cooperative
5. **Maintains stability** when coordination succeeds rather than greedily defecting
'''

description_COLLECTIVE_90 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I view myself as one of potentially many cooperative agents trying to solve a coordination problem. My goal is to ensure the threshold is met (generating collective benefit) while being robust against exploitation and adaptive to the actual composition of players I'm facing.

## Strategic Framework

### Key Insight

The fundamental tension is:
- If exactly m players cooperate, cooperators get k while defectors get 1+k (free-riding premium)
- If fewer than m cooperate, everyone loses the k bonus
- The collective optimum requires coordination to ensure exactly m cooperators (or slightly more for safety)

Since I cannot pre-coordinate with others, I must use **probabilistic cooperation** calibrated to achieve the threshold in expectation, adjusted based on observed behavior.

---

## Decision Rules

### Round 1: Probabilistic Initialization

With no history, I cooperate with probability based on what would achieve threshold if all players used similar logic:

```
P(cooperate) = m/n + safety_margin

where safety_margin = min(0.15, (n-m)/(2n))
```

This slightly over-contributes to account for some players being pure defectors.

### Subsequent Rounds: Adaptive Response

**Step 1: Classify observed player population**

After each round, categorize players based on their full history:
- `reliable_cooperators`: Cooperated ≥ 70% of rounds
- `reliable_defectors`: Defected ≥ 70% of rounds  
- `conditional_players`: Everyone else

**Step 2: Estimate cooperation need**

```
expected_other_cooperators = 
    count(reliable_cooperators) × 0.85 +
    count(conditional_players) × 0.5 +
    count(reliable_defectors) × 0.1

cooperation_gap = m - expected_other_cooperators
```

**Step 3: Determine my cooperation probability**

```
if cooperation_gap <= 0:
    # Threshold likely met without me - cautious defection
    P(cooperate) = 0.2  # Stay somewhat engaged to signal willingness
    
elif cooperation_gap >= 1:
    # My cooperation is needed
    P(cooperate) = min(0.95, 0.5 + cooperation_gap × 0.3)
    
else:
    # Marginal case - I might be the pivotal player
    P(cooperate) = 0.6 + cooperation_gap × 0.3
```

**Step 4: Reactive adjustment based on recent outcomes**

```
if last_round_threshold_met AND I_defected:
    # Free-riding succeeded - slight guilt adjustment toward cooperation
    P(cooperate) += 0.1
    
if last_round_threshold_NOT_met AND I_cooperated:
    # Wasted cooperation - check if others are cooperative enough
    if count(reliable_cooperators) < m - 1:
        # Not enough cooperators exist - reduce my contribution
        P(cooperate) -= 0.15
    else:
        # Bad luck or coordination failure - maintain course
        P(cooperate) += 0.05  # Signal continued willingness
```

---

## Edge Cases

### First Round
Use the probabilistic initialization formula. This ensures that if all players use similar reasoning, the threshold is met in expectation.

### Last Round
**Slight increase in cooperation probability (+0.1)** despite the temptation to defect. Rationale:
- Other strategic players expect defection, creating a coordination collapse
- By maintaining cooperation, I help other collective-minded players achieve the threshold
- The collective benefit k often outweighs the free-riding premium of 1

### When m is Very Close to n (m ≥ n-1)
Near-universal cooperation is required. Switch to:
```
P(cooperate) = 0.9 regardless of history
```
The threshold is too fragile for strategic defection.

### When m is Very Small (m ≤ 2)
Threshold is easy to meet. Use:
```
P(cooperate) = max(0.3, m/n)
```
Contribute my fair share but don't over-contribute.

### Detecting Coordinated Opposition
If threshold consistently fails despite my cooperation AND I observe a stable group of defectors:
```
if rounds_since_threshold_met > r/3 AND my_cooperation_rate > 0.6:
    # Cut losses - join the defectors
    P(cooperate) = 0.2
```

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        safety = min(0.15, (n - m) / (2 * n))
        return random() < (m / n + safety)
    
    # Classify players
    reliable_coop = count(players with coop_rate >= 0.7)
    reliable_def = count(players with coop_rate <= 0.3)
    conditional = n - 1 - reliable_coop - reliable_def
    
    # Estimate cooperation gap
    expected_others = reliable_coop * 0.85 + conditional * 0.5 + reliable_def * 0.1
    gap = m - expected_others
    
    # Base probability
    if gap <= 0:
        p = 0.2
    else:
        p = min(0.95, 0.5 + gap * 0.3)
    
    # Reactive adjustments
    if last_threshold_met and I_defected_last:
        p += 0.1
    if not last_threshold_met and I_cooperated_last:
        if reliable_coop < m - 1:
            p -= 0.15
        else:
            p += 0.05
    
    # Edge cases
    if round == r:
        p += 0.1
    if m >= n - 1:
        p = 0.9
    if m <= 2:
        p = max(0.3, m / n)
    
    return random() < clamp(p, 0.05, 0.95)
```

---

## Why This Strategy is Collectively Minded

1. **Fair share contribution**: I aim to contribute proportionally (m/n) rather than free-ride
2. **Adaptive support**: I increase cooperation when the collective needs it
3. **Forgiveness**: I don't permanently punish failed rounds
4. **Last-round solidarity**: I resist the temptation to defect when it matters most
5. **Threshold protection**: I prioritize ensuring k is achieved over maximizing my individual premium
'''

description_COLLECTIVE_91 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of a reliable coalition that consistently meets the threshold while avoiding exploitation. The key insight is that in this game, **exactly m cooperators is optimal for the group** - it secures the bonus while minimizing unnecessary sacrifice. My goal is to be one of those m cooperators when needed, but not to cooperate wastefully when others already have it covered.

## Strategy Overview

I use a **reputation-based probabilistic cooperation** system that:
1. Starts optimistically to help establish cooperation
2. Tracks each player's cooperation history to estimate reliability
3. Dynamically adjusts my cooperation probability based on expected threshold achievement
4. Commits more strongly in final rounds when future punishment is impossible

---

## Decision Rules

### Key Variables Tracked

```
For each player j:
  - coop_count[j] = number of times player j has cooperated
  - rounds_played = total rounds completed
  - reliability[j] = coop_count[j] / rounds_played (after round 1)

Global tracking:
  - threshold_met_count = rounds where ≥m players cooperated
  - my_coop_count = times I have cooperated
```

### Round-by-Round Decision Process

#### **Round 1: Optimistic Initiation**

**Decision: COOPERATE**

Rationale: With no history, I assume good faith and contribute to establishing a cooperative norm. This signals willingness to be part of the solution.

---

#### **Middle Rounds (2 to r-1): Adaptive Response**

**Step 1: Calculate expected cooperators (excluding myself)**

```
expected_others_cooperating = Σ reliability[j] for all j ≠ me
```

**Step 2: Determine my cooperation probability**

```
shortfall = m - expected_others_cooperating
adjusted_shortfall = max(0, shortfall)

# Base probability depends on how much I'm "needed"
if expected_others_cooperating >= m:
    # Threshold likely met without me - low but non-zero cooperation
    base_prob = 0.15
elif expected_others_cooperating >= m - 1:
    # I might be the pivotal player
    base_prob = 0.85
else:
    # Significant shortfall - scale probability
    base_prob = min(0.95, 0.5 + (adjusted_shortfall / m) * 0.4)
```

**Step 3: Adjust for recent history (last 3 rounds)**

```
recent_threshold_rate = (thresholds met in last 3 rounds) / min(3, rounds_played)

if recent_threshold_rate < 0.5:
    # Cooperation failing - slight increase to help recover
    base_prob = min(1.0, base_prob + 0.15)
elif recent_threshold_rate == 1.0 and my cooperation rate > m/n + 0.1:
    # Threshold consistently met and I'm cooperating more than my "fair share"
    base_prob = max(0.3, base_prob - 0.1)
```

**Step 4: Tit-for-tat adjustment based on reciprocity**

```
avg_others_reliability = mean(reliability[j] for j ≠ me)
my_reliability = my_coop_count / rounds_played

if my_reliability > avg_others_reliability + 0.2:
    # I'm being exploited - reduce cooperation
    base_prob = max(0.2, base_prob - 0.15)
```

**Step 5: Make decision**

```
COOPERATE if random(0,1) < base_prob, else DEFECT
```

---

#### **Final Round (Round r): Calculated Commitment**

In the last round, there's no future to influence, so I use pure expected value calculation with a collective bias:

```
expected_others = Σ reliability[j] for j ≠ me

if expected_others >= m:
    # Threshold likely met without me
    DEFECT (maximize personal payoff)
elif expected_others >= m - 1:
    # I'm likely pivotal
    COOPERATE (my cooperation turns 0 bonus into k bonus for everyone)
else:
    # Threshold unlikely even with me
    if expected_others >= m - 2 and k > 1.5:
        COOPERATE (worth the gamble for high k)
    else:
        DEFECT (don't throw away endowment for lost cause)
```

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **n = 2, m = 2** | Always cooperate (both needed; defection guarantees failure) |
| **m = n - 1 or m = n** | High cooperation probability (~0.9) since almost everyone needed |
| **r = 2** | Round 1: Cooperate; Round 2: Use final round logic |
| **k very large (k > 3)** | Increase all cooperation probabilities by 0.1 (higher stakes) |
| **k barely above 1** | Reduce cooperation probabilities by 0.1 (lower incentive) |
| **All others defected last round** | Still cooperate with probability 0.3 (forgiveness/probe) |
| **I'm the only defector in a successful round** | Increase next round cooperation probability by 0.2 (guilt/reciprocity) |

---

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return COOPERATE
    
    # Calculate reliabilities
    reliability = {j: history[j].cooperations / (round - 1) for j in others}
    expected_others = sum(reliability.values())
    
    if round == r:  # Final round
        if expected_others >= m:
            return DEFECT
        elif expected_others >= m - 1:
            return COOPERATE
        elif expected_others >= m - 2 and k > 1.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    prob = calculate_cooperation_probability(expected_others, m, history, k)
    prob = adjust_for_reciprocity(prob, my_reliability, avg_others_reliability)
    prob = adjust_for_recent_success(prob, recent_threshold_rate)
    
    return COOPERATE if random() < prob else DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **I start by cooperating** - building trust before demanding it
2. **I aim to be reliably part of the m** - not freeloading on others' cooperation
3. **I don't over-cooperate** - wasting resources when threshold is already met helps no one
4. **I forgive occasional defection** - allowing recovery from coordination failures
5. **I match the group's effort level** - not martyring myself for persistent defectors
6. **In critical moments, I show up** - when I'm pivotal, I cooperate

This strategy seeks to be the player that *every collective would want* - reliable when needed, efficient when possible, and resistant to exploitation.
'''

description_COLLECTIVE_92 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the minimum viable coalition needed to secure the collective reward, while adapting to observed behavior to maximize group success. The strategy balances reliability (being someone others can count on) with efficiency (not over-contributing when unnecessary).

## Strategy Overview

The strategy operates on three principles:
1. **Be a reliable cooperator** - establish credibility early to encourage threshold formation
2. **Adapt to the coalition landscape** - adjust based on observed cooperation levels
3. **Maintain collective rationality** - even late-game, recognize that mutual defection is worse than threshold cooperation

---

## Decision Rules

### Round 1: Cooperative Opening

**Action: COOPERATE**

Rationale: With no history, I signal willingness to be part of the threshold coalition. This establishes me as a potential reliable partner and provides information about others' dispositions.

---

### Rounds 2 through (r-1): Adaptive Core Phase

Calculate from previous round:
- `cooperators_last` = number of players who cooperated last round
- `cooperation_rate` = cooperators_last / n
- `threshold_met` = (cooperators_last ≥ m)
- `my_action_last` = my action in the previous round

**Decision Logic:**

```
IF threshold_met last round:
    IF cooperators_last == m:
        # Exactly at threshold - I should stay if I was contributing
        IF my_action_last == C:
            ACTION = COOPERATE  # Don't break a fragile coalition
        ELSE:
            ACTION = DEFECT     # Others have it covered, stay out
    
    ELSE IF cooperators_last > m:
        # Over-subscribed coalition - probabilistic thinning
        excess = cooperators_last - m
        prob_defect = excess / cooperators_last
        # But loyal cooperators less likely to defect
        IF my_action_last == C:
            prob_defect = prob_defect * 0.5
        ACTION = DEFECT with probability prob_defect, else COOPERATE
    
ELSE (threshold NOT met last round):
    shortfall = m - cooperators_last
    
    IF my_action_last == C:
        # I tried but we failed - stay committed, others may join
        ACTION = COOPERATE
    
    ELSE (my_action_last == D):
        # I defected and we failed - consider joining
        # Probability to switch increases with how close we were
        closeness = cooperators_last / m
        prob_cooperate = 0.3 + (0.5 * closeness)
        ACTION = COOPERATE with probability prob_cooperate, else DEFECT
```

**Additional Modifier - Trend Detection:**
```
IF rounds_played >= 3:
    trend = cooperators_last - cooperators_two_rounds_ago
    IF trend > 0 AND threshold NOT met:
        # Cooperation rising - join the momentum
        Increase cooperation probability by 0.2
    ELSE IF trend < 0 AND threshold_met:
        # Cooperation falling - help stabilize
        Increase cooperation probability by 0.15
```

---

### Final Round (Round r): Collective Rationality

The last round tempts defection, but universal defection yields payoff 1, while threshold cooperation yields ≥k for cooperators and (1+k) for defectors.

**Decision Logic:**

```
# Base decision on established pattern
avg_cooperators = average cooperators over all previous rounds

IF avg_cooperators >= m:
    # Coalition has been forming - maintain my role
    my_cooperation_rate = (times I cooperated) / (rounds played)
    IF my_cooperation_rate >= 0.5:
        ACTION = COOPERATE  # I've been part of the coalition
    ELSE:
        ACTION = DEFECT     # I've been free-riding, continue
        
ELSE IF avg_cooperators >= m - 1:
    # We've been close - one more cooperator could tip it
    ACTION = COOPERATE with probability 0.7
    
ELSE:
    # Coalition never formed - no point sacrificing alone
    ACTION = DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2, m = 2 | Always COOPERATE | Both needed; defection guarantees failure |
| m = n-1 | COOPERATE (high probability ~0.85) | Almost everyone needed; be reliable |
| m very small (m ≤ n/3) | Lower baseline cooperation (~0.4) | Others likely cover threshold |
| k very large (k > 3) | Increase cooperation probability | High stakes justify contribution |
| All others defected last round | COOPERATE | Someone must start; be that catalyst |
| Threshold met every round so far | Maintain current role | Don't disrupt working equilibrium |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE
    
    cooperators_last = count_cooperators(history, round - 1)
    threshold_met = cooperators_last >= m
    i_cooperated_last = my_history[round - 1] == COOPERATE
    
    if round == r:  # Final round
        return final_round_decision(history, m)
    
    # Core adaptive logic
    if threshold_met:
        if cooperators_last == m:
            return COOPERATE if i_cooperated_last else DEFECT
        else:  # Over threshold
            excess_ratio = (cooperators_last - m) / cooperators_last
            defect_prob = excess_ratio * (0.5 if i_cooperated_last else 1.0)
            return DEFECT if random() < defect_prob else COOPERATE
    else:  # Threshold not met
        if i_cooperated_last:
            return COOPERATE  # Stay committed
        else:
            closeness = cooperators_last / m
            coop_prob = 0.3 + 0.5 * closeness
            coop_prob += trend_adjustment(history)
            return COOPERATE if random() < coop_prob else DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **Initiates cooperation** - Doesn't wait for others; starts as a cooperator
2. **Maintains commitments** - Once part of a working coalition, stays reliable
3. **Self-regulates** - Backs off when over-subscribed to let others benefit
4. **Rescues failing rounds** - Increases cooperation when threshold nearly met
5. **Avoids mutual destruction** - Even in final round, maintains collective rationality over pure self-interest

This strategy aims to be the kind of player that *makes collective success possible* rather than merely exploiting others' cooperation.
'''

description_COLLECTIVE_93 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I act as if I'm one instance of a distributed system trying to achieve the collective good. The key insight is that exactly `m` cooperators is optimal for the group (threshold met, minimum sacrifice), but ensuring exactly `m` requires implicit coordination. I'll use observable history to estimate how many others are likely to cooperate and fill gaps accordingly.

## Strategy Overview

I cooperate when my cooperation is likely *necessary* to reach the threshold, and defect when the threshold is likely met without me (allowing me to free-ride for collective efficiency) or when cooperation is futile (threshold unreachable). I use historical cooperation rates to estimate others' behavior and apply a **probabilistic cooperation rule** based on my player index to break symmetry.

---

## Decision Rules

### Round 1: Symmetric Probabilistic Start

With no history, I use my player index to create implicit coordination:

```
cooperation_probability = m / n
cooperate if hash(player_id, round=1, game_seed) mod 100 < (m/n) * 100
```

If no player-distinguishing information is available, I default to:
- **Cooperate** with probability `m/n`

This gives an expected `m` cooperators initially.

### Rounds 2 to r-1: Adaptive Response

**Step 1: Estimate expected cooperators (excluding myself)**

```
observed_cooperation_rate = (total C plays by others) / (total opportunities)
expected_other_cooperators = observed_cooperation_rate * (n - 1)
```

**Step 2: Determine my action based on "pivot probability"**

I estimate whether I'm *pivotal* (my cooperation changes outcome from failure to success):

```
if expected_other_cooperators >= m:
    # Threshold likely met without me → Defect (efficient free-riding)
    action = D
    
elif expected_other_cooperators < m - 1:
    # Threshold unlikely even with me → assess futility
    if expected_other_cooperators < m - 2:
        action = D  # Too far from threshold, save resources
    else:
        action = C  # Close enough, try to encourage cooperation
        
else:  # expected_other_cooperators in [m-1, m)
    # I'm likely pivotal → Cooperate
    action = C
```

**Step 3: Trend adjustment**

```
recent_rate = cooperation rate in last min(3, rounds_played) rounds
if recent_rate is increasing and recent_rate > overall_rate:
    # Cooperation momentum → be slightly more willing to cooperate
    shift cooperation threshold down by 0.5
    
if recent_rate is decreasing rapidly:
    # Collapse happening → try to arrest it by cooperating
    if expected_other_cooperators > m - 2:
        action = C
```

### Final Round (Round r): Calculated Endgame

No future rounds to influence, so pure expected value calculation:

```
p_threshold_met_without_me = P(≥m cooperators among n-1 others)
p_threshold_met_with_me = P(≥m-1 cooperators among n-1 others)

EV_defect = 1 + k * p_threshold_met_without_me
EV_cooperate = 0 + k * p_threshold_met_with_me

if EV_cooperate > EV_defect:
    action = C
else:
    action = D
```

Where probabilities are estimated using observed cooperation rate as the binomial parameter.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| `m = n-1` or `m = n` | Cooperate always (until threshold clearly met) | Near-unanimity required; my defection likely catastrophic |
| `m = 2` with large `n` | Follow standard rules but bias toward D | Others likely to cover threshold |
| `k` is very large (k > n) | Bias toward C | Risk of missing threshold too costly |
| `k` is barely > 1 | Follow standard rules | Marginal benefit doesn't change logic |
| Everyone defected last round | Cooperate if `m ≤ n/2` | Attempt to restart cooperation |
| Everyone cooperated last round | Defect | Threshold will likely be met without me |

---

## Pseudocode Summary

```python
def decide(round, history, player_id, n, m, r, k):
    
    if round == 1:
        return C if (hash(player_id) % 100) < (m / n * 100) else D
    
    # Calculate statistics
    other_actions = get_others_actions(history)
    coop_rate = count(C in other_actions) / len(other_actions)
    expected_cooperators = coop_rate * (n - 1)
    
    if round == r:  # Final round
        return final_round_decision(expected_cooperators, n, m, k, coop_rate)
    
    # Middle rounds
    recent_trend = get_recent_trend(history, window=3)
    
    if expected_cooperators >= m:
        return D  # Free ride efficiently
    elif expected_cooperators >= m - 1:
        return C  # I'm pivotal
    elif expected_cooperators >= m - 2:
        return C  # Close, encourage cooperation
    else:
        # Far from threshold
        if recent_trend == "declining" and expected_cooperators > m/2:
            return C  # Try to arrest collapse
        return D  # Conserve resources
```

---

## Why This Strategy is Collectively Optimal

1. **Efficiency**: Aims for exactly `m` cooperators, not more—minimizing collective sacrifice while securing the reward.

2. **Adaptive**: Responds to actual behavior rather than assuming rationality or specific strategies.

3. **Robust**: Works against cooperators (I free-ride efficiently), defectors (I don't waste resources), and mixed strategies (I fill gaps).

4. **Self-organizing**: If all players use this strategy, the symmetry-breaking and adaptive rules naturally converge toward `m` cooperators.

5. **Forgiving**: Attempts to restart cooperation after collapses rather than permanently defecting.
'''

description_COLLECTIVE_94 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be a reliable cooperator who helps the group reach the threshold, while adapting to the observed behavior of others. The key insight is that in this game, **exactly m cooperators is optimal for the group** - having more than m cooperators wastes resources, while having fewer means everyone loses the bonus.

## Strategy Overview

I will be a **conditional cooperator with adaptive positioning** - I cooperate when my cooperation is likely needed to reach the threshold, and defect when the threshold appears secure without me or when cooperation seems futile.

---

## Decision Rules

### Round 1: Cooperative Signal

**Action: COOPERATE**

Rationale: With no history, I signal willingness to contribute to the collective good. This establishes trust and provides information about others' dispositions.

### Rounds 2 through (r-1): Adaptive Threshold Targeting

Calculate the following from the previous round:
- `num_cooperators_last`: count of players who cooperated
- `threshold_met_last`: whether num_cooperators_last ≥ m

**Decision Logic:**

```
IF threshold was NOT met last round:
    IF num_cooperators_last >= m - 1:
        # We were close - my cooperation could tip us over
        COOPERATE
    ELSE IF num_cooperators_last <= m/2:
        # Too few cooperators - cooperation may be futile
        # But give benefit of doubt early in game
        IF current_round <= r/3:
            COOPERATE
        ELSE:
            DEFECT
    ELSE:
        # Moderate cooperation - try to build momentum
        COOPERATE

ELSE IF threshold WAS met last round:
    IF num_cooperators_last == m:
        # Perfect coordination achieved
        # Maintain my role from last round
        REPEAT last round's action
    ELSE IF num_cooperators_last > m + 1:
        # Too many cooperators - some can safely defect
        # I defect if I cooperated last round (take turns bearing cost)
        IF I cooperated last round:
            DEFECT
        ELSE:
            COOPERATE
    ELSE:
        # Threshold met with slight surplus (m or m+1)
        # Maintain stability - repeat last action
        REPEAT last round's action
```

### Final Round (Round r): Strategic Calculation

The last round has no future consequences, changing incentives:

```
Estimate expected_cooperators based on:
    - Average cooperation rate in last 3 rounds
    - Trend (increasing/decreasing cooperation)

IF expected_cooperators >= m (without me):
    DEFECT  # Threshold likely met anyway
ELSE IF expected_cooperators == m - 1:
    COOPERATE  # I'm the pivotal player
ELSE IF expected_cooperators < m - 1:
    # Threshold unlikely - but cooperate if close
    IF expected_cooperators >= m - 2:
        COOPERATE
    ELSE:
        DEFECT  # Futile to cooperate alone
```

---

## Handling Edge Cases

### Very Small Groups (n ≤ 4)
- Be more consistently cooperative since each player's contribution matters more
- Threshold for "giving up" on cooperation is higher

### High Threshold (m > n/2)
- Lean toward cooperation more heavily since success requires most players
- Only defect when threshold is clearly met or clearly impossible

### Low Threshold (m ≤ n/3)
- More willing to test whether threshold holds without me
- Rotate defection when surplus cooperators exist

### Perfect Threshold Achievement (exactly m cooperators repeatedly)
- Maintain stability - don't disrupt a working equilibrium
- Stick with whatever action I took when equilibrium formed

### Erratic Opponent Behavior
- If cooperation levels swing wildly (variance > 2 players between rounds), default to COOPERATE to provide stability

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return COOPERATE
    
    last_coop_count = count_cooperators(history, round - 1)
    threshold_met = last_coop_count >= m
    my_last_action = get_my_action(history, round - 1)
    
    if round == r:  # Final round
        expected = estimate_cooperators(history)
        if expected >= m:
            return DEFECT
        elif expected >= m - 2:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if not threshold_met:
        if last_coop_count >= m - 1 or round <= r/3:
            return COOPERATE
        elif last_coop_count <= m/2 and round > r/3:
            return DEFECT
        else:
            return COOPERATE
    else:  # Threshold was met
        if last_coop_count > m + 1 and my_last_action == COOPERATE:
            return DEFECT  # Rotate burden
        else:
            return my_last_action  # Maintain stability
```

---

## Why This Strategy is Collectively Minded

1. **Starts cooperatively** - Builds trust and signals good faith
2. **Targets the threshold** - Aims for exactly m cooperators, not maximum cooperation
3. **Shares the burden** - Rotates defection when surplus cooperators exist
4. **Maintains stability** - Doesn't disrupt working equilibria
5. **Stays responsive** - Adapts to others rather than following rigid rules
6. **Never fully abandons** - Keeps cooperating when cooperation could plausibly reach threshold
'''

description_COLLECTIVE_95 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed to secure the collective reward, but not a surplus cooperator who could defect without harming the group. The strategy dynamically estimates whether my cooperation is pivotal based on observed behavior patterns.

## Strategy Overview

The strategy operates on three principles:
1. **Be willing to cooperate** - Default toward cooperation, especially early
2. **Avoid being exploited** - Reduce cooperation if others consistently free-ride
3. **Maintain threshold** - Adjust behavior to help achieve exactly *m* cooperators when possible

---

## Decision Rules

### Round 1 (No History)

**Cooperate with probability p₀ = m/n**

Rationale: If all players use this probability, the expected number of cooperators equals *m*. This is the coordination-neutral starting point that signals cooperative intent while not over-contributing.

### Rounds 2 through r-1 (Middle Rounds)

Calculate the following from history:

1. **Observed cooperation rate (OCR)**: Total cooperations by others / Total opportunities
2. **Recent cooperation rate (RCR)**: Cooperation rate in the last min(3, t-1) rounds
3. **Threshold success rate (TSR)**: Fraction of past rounds where threshold was met

**Decision Logic:**

```
expected_other_cooperators = OCR × (n - 1)

if expected_other_cooperators >= m:
    # Others likely provide enough - I can safely defect
    # But cooperate occasionally to maintain collective momentum
    cooperate with probability 0.2
    
elif expected_other_cooperators >= m - 1:
    # I might be pivotal - my cooperation likely matters
    cooperate with probability 0.85
    
elif expected_other_cooperators >= m - 2:
    # Need me plus at least one more uncertain cooperator
    cooperate with probability 0.7
    
else:
    # Cooperation is scarce - contribute but protect myself
    if TSR < 0.3:
        # Threshold rarely met - reduce cooperation to avoid pure exploitation
        cooperate with probability 0.3
    else:
        cooperate with probability 0.6
```

**Trend Adjustment:**
```
if RCR > OCR + 0.1:
    # Cooperation trending upward - increase my cooperation by 0.1
    
if RCR < OCR - 0.1:
    # Cooperation trending downward - decrease my cooperation by 0.1
```

### Final Round (Round r)

The last round has no shadow of the future, creating strong defection incentives. However, maintaining collective success matters:

```
if historical TSR >= 0.6:
    # Group has been successful - honor the implicit contract
    # Use same logic as middle rounds
    
else:
    # Poor collective history - defect
    # (Threshold unlikely to be met regardless)
    defect
```

---

## Edge Cases

### Very Small Groups (n ≤ 4)
- Increase base cooperation probability by 0.15
- Each player's choice is more consequential

### High Threshold (m > n/2)
- Increase cooperation probability by 0.1
- Collective success requires more contributors

### Low Threshold (m ≤ n/3)
- Slightly decrease cooperation probability by 0.1
- Can afford some free-riding while still meeting threshold

### Very High Reward (k > 2)
- Increase cooperation probability by min(0.15, (k-2)/10)
- Higher stakes justify more cooperative risk

### Short Games (r ≤ 3)
- Increase first-round cooperation to m/n + 0.15
- Less time to establish patterns, so front-load cooperation

---

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        base_prob = m / n
        if r <= 3: base_prob += 0.15
        return cooperate with probability base_prob
    
    OCR = calculate_overall_cooperation_rate(history)
    RCR = calculate_recent_cooperation_rate(history, window=3)
    TSR = calculate_threshold_success_rate(history, m)
    expected_others = OCR × (n - 1)
    
    # Base probability from pivotality analysis
    if expected_others >= m:
        prob = 0.2
    elif expected_others >= m - 1:
        prob = 0.85
    elif expected_others >= m - 2:
        prob = 0.7
    else:
        prob = 0.6 if TSR >= 0.3 else 0.3
    
    # Trend adjustment
    prob += 0.1 × sign(RCR - OCR) if |RCR - OCR| > 0.1
    
    # Parameter adjustments
    if m > n/2: prob += 0.1
    if m <= n/3: prob -= 0.1
    if k > 2: prob += min(0.15, (k-2)/10)
    if n <= 4: prob += 0.15
    
    # Final round adjustment
    if round == r and TSR < 0.6:
        prob = 0
    
    prob = clamp(prob, 0, 1)
    return cooperate with probability prob
```

---

## Why This Strategy is Collective

1. **Threshold-focused**: Aims to achieve exactly *m* cooperators, not maximum cooperation
2. **Responsive**: Adapts to group behavior rather than fixed rules
3. **Not exploitable**: Reduces cooperation when others consistently defect
4. **Not greedy**: Maintains cooperation even when could free-ride, to sustain group success
5. **Probabilistic**: Allows natural coordination without explicit communication
'''

description_COLLECTIVE_96 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not a sucker who cooperates when defection is rampant. The key insight is that in a collective of like-minded agents, we need exactly *m* cooperators—no more, no fewer—to maximize collective welfare. My strategy probabilistically self-selects into cooperation at a rate that, if adopted by all, produces exactly the needed threshold.

## Strategy Overview

The strategy operates on three principles:
1. **Base rate cooperation**: Cooperate with probability calibrated to produce exactly *m* cooperators in expectation
2. **Responsive adjustment**: Increase cooperation if the group is falling short; decrease if others are reliably cooperating
3. **End-game commitment**: Maintain cooperation incentives even in final rounds

---

## Decision Rules

### Round 1: Baseline Cooperation

**Rule**: Cooperate with probability `p_base = m / n`

**Rationale**: If all *n* players use this probability, expected cooperators = *n* × (*m*/*n*) = *m*, exactly meeting the threshold. This is the collectively optimal starting point.

---

### Rounds 2 through r-1: Adaptive Response

After observing history, calculate:
- `c_prev` = number of cooperators in the previous round
- `c_avg` = average cooperators across all previous rounds
- `shortfall` = max(0, m - c_avg) — how far below threshold we've been on average
- `surplus` = max(0, c_avg - m) — how far above threshold we've been on average

**Adjusted cooperation probability**:

```
p_adjust = p_base + (shortfall / n) × 0.5 - (surplus / n) × 0.3
p_round = clamp(p_adjust, 0.1, 0.9)
```

**Decision Rule**:
- If `c_prev < m` (threshold was missed last round): Cooperate with probability `min(p_round + 0.2, 0.95)`
- If `c_prev == m` (exactly at threshold): Cooperate with probability `p_round`
- If `c_prev > m` (surplus cooperators): Cooperate with probability `max(p_round - 0.1, p_base × 0.5)`

**Rationale**: 
- When we're falling short, I step up—this is the collective duty
- When there's surplus, I can safely step back, letting others carry some rounds
- The asymmetry (stepping up more than stepping back) reflects that missing threshold hurts everyone

---

### Final Round (Round r): Conditional Commitment

The last round has no future to influence, creating defection incentives. Counter this with:

**Calculate cooperation rate**: `group_coop_rate` = total cooperations by others / ((r-1) × (n-1))

**Decision Rule**:
- If `group_coop_rate ≥ (m-1)/(n-1)`: Cooperate with probability `m/n` (maintain baseline)
- If `group_coop_rate < (m-1)/(n-1)`: Cooperate with probability `max(0.2, m/n - 0.2)` (reduced but not zero)

**Rationale**: Rewarding historical cooperation maintains incentives. Even if others defected, maintaining *some* cooperation gives benefit of doubt to other collective-minded agents.

---

### Edge Cases

**If n = m** (everyone needed): Always cooperate with probability 0.95. With everyone required, any defection fails the group—maximum commitment needed.

**If m = 1** (only one needed): Cooperate with probability `1/n + 0.1`. Someone must do it; slight over-contribution ensures threshold is met.

**If k is very large** (k > n): Increase all cooperation probabilities by factor of `min(1.5, k/n)`. High stakes warrant more reliable cooperation.

**If k is barely above 1**: Reduce cooperation probabilities slightly. Low reward means defection is less costly to the collective.

---

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    p_base = m / n
    
    if round == 1:
        return random() < p_base
    
    c_prev = count_cooperators(history, round - 1)
    c_avg = average_cooperators(history)
    
    shortfall = max(0, m - c_avg)
    surplus = max(0, c_avg - m)
    
    p_adjust = p_base + (shortfall/n)*0.5 - (surplus/n)*0.3
    p_round = clamp(p_adjust, 0.1, 0.9)
    
    if c_prev < m:
        p_final = min(p_round + 0.2, 0.95)
    elif c_prev == m:
        p_final = p_round
    else:
        p_final = max(p_round - 0.1, p_base * 0.5)
    
    if round == r:  # final round
        group_rate = others_cooperation_rate(history)
        if group_rate < (m-1)/(n-1):
            p_final = max(0.2, p_final - 0.2)
    
    return random() < p_final
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: If all agents use this, we naturally produce ~*m* cooperators without explicit coordination
2. **Forgiving**: Responds to shortfalls by stepping up, not by retaliating
3. **Efficient**: Doesn't over-cooperate when threshold is met, preserving resources
4. **Robust to defectors**: Probabilistic nature means a few defectors don't collapse the system
5. **Incentive-compatible**: Maintains cooperation value even in final rounds
'''

description_COLLECTIVE_97 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of a reliable cooperating coalition that meets the threshold, while adapting to the actual behavior of others. The key insight is that exactly m cooperators is the efficient outcome—more than m wastes contributions, fewer than m wastes everything.

## Strategic Framework

### Key Observations

1. **The sweet spot**: When exactly m players cooperate, cooperators get k and defectors get 1+k. But if fewer than m cooperate, everyone gets at most 1.
2. **Cooperation is valuable to the group**: Meeting the threshold generates k×n in total bonus value.
3. **Coordination challenge**: Without communication, players must use history to implicitly coordinate.

### Decision Rules

#### Round 1: Probabilistic Commitment

Cooperate with probability `m/n`.

**Rationale**: If all players independently cooperate with probability m/n, the expected number of cooperators is exactly m. This is the collectively rational starting point that doesn't assume coordination but creates it statistically.

#### Rounds 2 through r-1: Adaptive Response

Let `c_prev` = number of cooperators in the previous round.

**Rule 1 - Threshold Met Last Round (c_prev ≥ m):**
- If I cooperated last round: Continue cooperating with probability `m / max(c_prev, m)`
- If I defected last round: Cooperate with probability `max(0, (m - c_prev + 1)) / (n - c_prev + 1)`

**Rule 2 - Threshold NOT Met Last Round (c_prev < m):**
- If I cooperated last round: Continue cooperating (demonstrate reliability)
- If I defected last round: Cooperate with probability `(m - c_prev) / (n - c_prev)`

**Rationale**: 
- When threshold is met with excess cooperators, some should "release" to defection
- When threshold fails, defectors should step up proportionally to fill the gap
- Previous cooperators maintain reliability to build trust patterns

#### Refinement Based on Running History

Track `reliability_score` = (rounds threshold met) / (total rounds played)

Adjust cooperation probability by factor:
- If `reliability_score > 0.7`: Multiply by 0.9 (group is reliable, can risk slightly less)
- If `reliability_score < 0.3`: Multiply by 1.2, capped at 1.0 (group needs more cooperation)

#### Last Round (Round r): Modified Calculation

The temptation to defect is highest in the final round. However, maintaining collective success matters:

- Calculate expected cooperators based on historical cooperation rate `avg_c`
- If `avg_c ≥ m + 1`: Defect (threshold likely met without me)
- If `avg_c < m - 0.5`: Defect (threshold unlikely even with me)
- Otherwise: Cooperate with probability `m / n × 1.1` (slight boost for collective insurance)

## Pseudocode

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        return COOPERATE with probability (m / n)
    
    c_prev = count_cooperators(history, round - 1)
    my_prev_action = my_action(history, round - 1)
    threshold_met_prev = (c_prev >= m)
    
    # Calculate base cooperation probability
    if threshold_met_prev:
        if my_prev_action == COOPERATE:
            base_prob = m / max(c_prev, m)
        else:
            base_prob = max(0, (m - c_prev + 1)) / (n - c_prev + 1)
    else:
        if my_prev_action == COOPERATE:
            base_prob = 1.0  # Stay reliable
        else:
            base_prob = (m - c_prev) / (n - c_prev)
    
    # Adjust based on overall reliability
    reliability = rounds_threshold_met(history) / (round - 1)
    if reliability > 0.7:
        base_prob *= 0.9
    elif reliability < 0.3:
        base_prob = min(1.0, base_prob * 1.2)
    
    # Last round adjustment
    if round == r:
        avg_c = average_cooperators(history)
        if avg_c >= m + 1 or avg_c < m - 0.5:
            base_prob *= 0.5
        else:
            base_prob = min(1.0, base_prob * 1.1)
    
    return COOPERATE with probability base_prob
```

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = m (all must cooperate) | Always cooperate - defection guarantees failure |
| m = 1 (only one needed) | Round 1: cooperate with prob 1/n; then only cooperate if no one else did |
| k is very large | Increase cooperation probability by factor min(1.5, k/2) |
| Consistently failing threshold | Gradually increase cooperation probability each failing round |
| r = 2 (only two rounds) | Round 1 normal; Round 2 use historical rate directly |

## Why This Strategy is Collectively Robust

1. **Self-organizing**: Probability m/n naturally produces ~m cooperators without coordination
2. **Adaptive**: Responds to actual group behavior, not assumptions
3. **Reliable**: Previous cooperators stay committed, building implicit trust
4. **Efficient**: Aims for exactly m cooperators, not wasteful over-cooperation
5. **Forgiving**: Gives defectors opportunities to rejoin the coalition when needed
'''

description_COLLECTIVE_98 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to help ensure the group reaches the threshold. The key insight is that in this game, **everyone benefits when the threshold is met** - defectors benefit even more than cooperators. Therefore, my goal is to be a reliable cooperator who helps sustain threshold achievement, while adapting to the actual cooperation levels I observe.

## Strategy Overview

I act as a "threshold guardian" - someone willing to cooperate to help the group succeed, but who adjusts based on whether cooperation is actually needed and whether others are contributing fairly over time.

---

## Decision Rules

### Round 1: Cooperative Start
**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent. Since we need m cooperators and I want the threshold met, I contribute. This establishes trust and gives me information about others.

### Rounds 2 through (r-1): Adaptive Cooperation

Let:
- `prev_cooperators` = number of players who cooperated last round
- `my_coop_rate` = my cooperation rate so far
- `group_coop_rate` = average cooperation rate of others so far
- `threshold_met_rate` = fraction of past rounds where threshold was met

**Decision Logic:**

```
IF threshold was NOT met last round:
    # Crisis response - we need more cooperators
    COOPERATE
    
ELSE IF prev_cooperators == m exactly:
    # Threshold barely met - my contribution may be critical
    # Check if I was one of the cooperators
    IF I cooperated last round:
        COOPERATE  # Stay reliable - don't destabilize
    ELSE:
        # Others are carrying the load at minimum; join to provide buffer
        COOPERATE

ELSE IF prev_cooperators > m + 1:
    # Comfortable surplus - consider rotation
    IF my_coop_rate > group_coop_rate + 0.15:
        # I've been cooperating more than my fair share
        DEFECT (with probability 0.3)
        COOPERATE (with probability 0.7)
    ELSE:
        COOPERATE

ELSE IF prev_cooperators < m:
    # This shouldn't happen given first condition, but safety net
    COOPERATE

DEFAULT:
    COOPERATE
```

### Final Round (Round r): Threshold-Focused

```
IF historical threshold_met_rate >= 0.8:
    # Group has been successful - maintain cooperation for final payoff
    IF my_coop_rate > group_coop_rate + 0.2:
        DEFECT  # I've contributed enough; let others carry this one
    ELSE:
        COOPERATE
        
ELSE:
    # Group has struggled - every contribution matters
    COOPERATE
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2, m = 2 | Always COOPERATE | Both must cooperate; be reliable |
| m ≥ n-1 | Always COOPERATE | Near-unanimous cooperation needed |
| k is very large (k > 3) | Bias toward COOPERATE | High stakes make threshold critical |
| Threshold never met | Continue COOPERATING | Someone must break the defection cycle |
| Only cooperator for 3+ rounds | DEFECT once, then COOPERATE | Signal that I need partners |
| Everyone always cooperates | Continue COOPERATING | Don't destabilize a good equilibrium |

---

## Pseudocode Implementation

```python
def decide(round_num, total_rounds, n, m, k, history):
    if round_num == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[-1])
    threshold_met_last = (prev_cooperators >= m)
    my_coop_rate = my_cooperation_rate(history)
    others_coop_rate = others_cooperation_rate(history)
    threshold_met_rate = fraction_threshold_met(history)
    
    # Crisis response
    if not threshold_met_last:
        return COOPERATE
    
    # Final round logic
    if round_num == total_rounds:
        if threshold_met_rate >= 0.8 and my_coop_rate > others_coop_rate + 0.2:
            return DEFECT
        return COOPERATE
    
    # Marginal threshold - stay reliable
    if prev_cooperators == m:
        return COOPERATE
    
    # Surplus exists - consider fairness adjustment
    if prev_cooperators > m + 1 and my_coop_rate > others_coop_rate + 0.15:
        return DEFECT if random() < 0.3 else COOPERATE
    
    # Default: cooperate
    return COOPERATE
```

---

## Why This Strategy is Collectively-Minded

1. **Prioritizes threshold achievement**: I cooperate whenever the threshold is at risk
2. **Absorbs uncertainty**: I don't defect just because I *could* free-ride
3. **Fairness-aware but forgiving**: I only reduce cooperation when I've done significantly more than others, and even then probabilistically
4. **Stable**: By defaulting to cooperation, I help maintain successful equilibria rather than destabilizing them
5. **Resilient**: Even if others defect heavily, I continue trying to reach threshold rather than retaliating
'''

description_COLLECTIVE_99 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of a reliable cooperating coalition that consistently meets the threshold m, while adapting to observed behavior to avoid being exploited. The key insight is that exactly m cooperators is optimal for the group meeting the threshold—more than m means wasted contributions, fewer means collective failure.

## Strategy Overview

I will be a **conditional cooperator** who starts cooperative, maintains cooperation when it's collectively rational, but withdraws cooperation when the coalition consistently fails or when I'm being exploited as part of an excess beyond m.

---

## Decision Rules

### Round 1: Cooperative Start
**Action: COOPERATE**

Rationale: With no history, I signal willingness to be part of the threshold coalition. This establishes cooperative intent and provides information about others.

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate the following from the previous round:
- `num_cooperators`: count of players who cooperated
- `threshold_met`: whether num_cooperators ≥ m

**Decision Logic:**

```
IF threshold_met in previous round:
    IF num_cooperators == m:
        # Perfect coalition - stay if I was part of it
        IF I cooperated last round:
            COOPERATE
        ELSE:
            # Coalition formed without me - they don't need me
            DEFECT
    
    ELSE IF num_cooperators > m:
        # Excess cooperators - use rotation fairness
        # Calculate my "cooperation burden" vs average
        my_coop_rate = (my total cooperations) / (rounds played)
        avg_coop_rate = (total cooperations by all) / (n * rounds played)
        
        IF my_coop_rate > avg_coop_rate + 0.1:
            # I've contributed more than my share - step back
            DEFECT
        ELSE:
            COOPERATE
    
ELSE (threshold NOT met):
    # Collective failure occurred
    failure_count = number of times threshold failed so far
    
    IF failure_count == 1:
        # First failure - give benefit of doubt, cooperate to rebuild
        COOPERATE
    
    ELSE IF failure_count <= r/3:
        # Repeated failures but still recoverable
        # Cooperate with probability based on how close we got
        IF num_cooperators >= m - 1:
            COOPERATE  # We were close, worth trying
        ELSE:
            # Far from threshold - match the cooperation rate I observe
            observed_coop_rate = num_cooperators / n
            COOPERATE with probability = observed_coop_rate + 0.1
    
    ELSE:
        # Too many failures - likely facing many defectors
        # Become more selective
        IF num_cooperators >= m - 1 in last round:
            COOPERATE  # Still a chance
        ELSE:
            DEFECT  # Cut losses
```

### Final Round (Round r): Threshold-Focused

The last round has no future shadow, so:

```
# Estimate likely cooperators based on recent history
recent_coop_rate = cooperation rate in last 3 rounds (or available rounds)
expected_cooperators_without_me = (n - 1) * recent_coop_rate

IF expected_cooperators_without_me >= m:
    # Threshold likely met without me
    DEFECT
ELSE IF expected_cooperators_without_me >= m - 1:
    # I might be pivotal
    COOPERATE
ELSE IF expected_cooperators_without_me >= m - 2 AND k >= 1.5:
    # Worth gambling if reward is high enough
    COOPERATE
ELSE:
    # Threshold unlikely to be met
    DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimal rounds) | Cooperate R1, apply final-round logic R2 | Limited learning opportunity |
| m = n-1 (high threshold) | More forgiving of failures, persist in cooperation | Need almost everyone |
| m = 2 (low threshold) | Quicker to defect if others cooperate reliably | Easy to meet without me |
| k > 2 (high reward) | More willing to cooperate even after failures | Payoff justifies risk |
| k ≈ 1 (low reward) | Stricter threshold for continued cooperation | Less benefit from success |
| All others always defect | Defect after round 2 | No viable coalition |
| All others always cooperate | Cooperate if needed for threshold, else defect | Don't over-contribute |

---

## Pseudocode Summary

```python
def decide(game_params, history):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    if current_round == 1:
        return COOPERATE
    
    if current_round == r:
        return final_round_decision(history, n, m, k)
    
    last_round = history[-1]
    num_coop = count_cooperators(last_round)
    threshold_met = num_coop >= m
    
    if threshold_met:
        if num_coop == m and i_cooperated(last_round):
            return COOPERATE
        elif num_coop > m:
            if my_burden_above_average(history):
                return DEFECT
            else:
                return COOPERATE
        else:
            return DEFECT
    else:
        failures = count_failures(history)
        if failures <= max(1, r // 3) and num_coop >= m - 1:
            return COOPERATE
        elif failures <= r // 3:
            return COOPERATE with prob = num_coop/n + 0.1
        else:
            return DEFECT if num_coop < m - 1 else COOPERATE
```

---

## Why This Strategy is Collectively Minded

1. **Starts cooperative**: Demonstrates good faith and willingness to contribute
2. **Maintains successful coalitions**: Doesn't abandon working groups
3. **Shares burden fairly**: Steps back when over-contributing relative to others
4. **Forgives occasional failures**: Allows recovery from coordination mistakes
5. **Protects against exploitation**: Withdraws from persistently failing groups
6. **Optimizes collective outcome**: Aims for exactly m cooperators, not wasteful excess
'''

description_COLLECTIVE_100 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume I am one of potentially many agents running this same strategy. My goal is to maximize collective welfare while being robust to defectors. The key insight is that exactly m cooperators is optimal for the group (threshold met, minimal sacrifice), and I should coordinate implicitly with like-minded agents to achieve this.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to produce exactly m expected cooperators among cooperative players, combined with **reputation tracking** to identify and exclude persistent defectors from my cooperation calculations.

---

## Decision Rules

### Round 1: Baseline Cooperation

With no history, I assume all players might be cooperative and set my cooperation probability to achieve the threshold:

```
p_cooperate = m / n
```

This ensures that if all n players use this strategy, expected cooperators = m (exactly meeting threshold).

### Rounds 2 through (r-1): Adaptive Cooperation

**Step 1: Calculate each player's cooperation rate**
```
For each player j:
    coop_rate[j] = (times j cooperated) / (rounds played)
```

**Step 2: Classify players**
```
threshold_for_cooperative = 0.3  # Willing to give benefit of doubt
cooperative_players = count of players where coop_rate[j] >= threshold_for_cooperative
suspected_defectors = n - cooperative_players
```

**Step 3: Adjust cooperation probability**

If I believe only `cooperative_players` agents are willing to cooperate, I adjust:

```
if cooperative_players >= m:
    # Enough potential cooperators exist
    p_cooperate = m / cooperative_players
else:
    # Insufficient cooperators - cooperation is likely futile
    # But maintain small probability to test if defectors might return
    p_cooperate = 0.15  # "Olive branch" probability
```

**Step 4: Reactive adjustment based on recent history**

```
# Look at last 3 rounds (or fewer if early game)
recent_rounds = min(3, rounds_played)
recent_total_cooperators = sum of cooperators in last recent_rounds rounds

if recent_total_cooperators / recent_rounds < m:
    # Threshold frequently missed - increase cooperation slightly
    p_cooperate = min(1.0, p_cooperate + 0.1)
elif recent_total_cooperators / recent_rounds > m + 1:
    # Over-cooperation detected - can afford to cooperate less
    p_cooperate = max(0.1, p_cooperate - 0.1)
```

**Step 5: Execute decision**
```
Cooperate with probability p_cooperate
```

### Final Round: Conditional Cooperation

The last round has no future consequences, creating defection incentives. However, maintaining collective thinking:

```
if cooperative_players >= m:
    # Trust that fellow cooperators will maintain behavior
    p_cooperate = m / cooperative_players
else:
    # Defect - threshold won't be met anyway
    p_cooperate = 0
```

---

## Edge Cases

### Edge Case 1: m = n - 1 (Nearly all must cooperate)
```
# Very fragile threshold - even one defector ruins it
# Be more willing to cooperate to compensate
p_cooperate = min(1.0, (m + 0.5) / cooperative_players)
```

### Edge Case 2: m very small relative to n
```
# Easy threshold - can afford strategic defection
# But still maintain collective fairness via rotation
p_cooperate = m / cooperative_players  # Standard formula applies
```

### Edge Case 3: k is very large
```
# High reward makes cooperation more valuable
# Bias toward cooperation to ensure threshold met
if k > 3:
    p_cooperate = min(1.0, p_cooperate * 1.2)
```

### Edge Case 4: Only 2 rounds total
```
# Limited learning opportunity
# Round 1: p = m/n
# Round 2: Match observed cooperation rate of others (tit-for-tat spirit)
```

---

## Pseudocode Summary

```python
def decide(game_params, history):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    if current_round == 1:
        p_cooperate = m / n
    else:
        # Calculate cooperation rates
        coop_rates = [times_cooperated(j, history) / (current_round - 1) for j in all_players]
        cooperative_players = sum(1 for rate in coop_rates if rate >= 0.3)
        
        if cooperative_players >= m:
            p_cooperate = m / cooperative_players
        else:
            p_cooperate = 0.15  # Olive branch
        
        # Reactive adjustment
        recent = last_k_rounds(history, min(3, current_round - 1))
        avg_cooperators = average_cooperators(recent)
        if avg_cooperators < m:
            p_cooperate = min(1.0, p_cooperate + 0.1)
        elif avg_cooperators > m + 1:
            p_cooperate = max(0.1, p_cooperate - 0.1)
        
        # High-k adjustment
        if k > 3:
            p_cooperate = min(1.0, p_cooperate * 1.2)
    
    return "C" if random() < p_cooperate else "D"
```

---

## Why This Strategy is Collectively Optimal

1. **Self-organizing threshold**: Multiple copies naturally coordinate to produce ~m cooperators
2. **Fair burden sharing**: Probabilistic cooperation distributes costs evenly over time
3. **Defector exclusion**: Stops subsidizing free-riders while remaining open to redemption
4. **Robust to composition**: Works whether facing copies, cooperators, or defectors
5. **Threshold-aware**: Never over-invests when cooperation is futile
'''

description_COLLECTIVE_101 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to ensure the group achieves the threshold and everyone benefits. The key insight is that in a collective risk dilemma, the worst outcome is failing to meet threshold m—everyone loses the reward k. My goal is to be a reliable cooperator who helps the group succeed while adapting to observed behavior patterns.

## Strategy Overview

I aim to be one of the m cooperators needed, adjusting my cooperation probability based on observed cooperation levels. I start cooperative, maintain cooperation when the group is near the threshold, and only reduce cooperation if there's a clear surplus of cooperators (allowing others to free-ride while still meeting threshold).

---

## Decision Rules

### Round 1: Optimistic Cooperation
**Action: Cooperate**

Rationale: With no history, I signal cooperative intent and contribute to establishing a cooperative norm. Since we need m cooperators out of n, and I want to be part of the solution, I start by cooperating.

### Rounds 2 through (r-1): Adaptive Cooperation

Let `prev_coop` = number of cooperators in the previous round

**Decision Logic:**

```
IF prev_coop < m:
    # Threshold was NOT met - we need more cooperation
    Cooperate (with probability 1)
    
ELSE IF prev_coop == m:
    # Exactly at threshold - precarious situation
    # If I cooperated last round, continue (I'm essential)
    # If I defected last round, cooperate now (help stabilize)
    Cooperate (with probability 1)
    
ELSE IF prev_coop > m AND prev_coop <= m + floor((n-m)/2):
    # Slight surplus - maintain cooperation to keep buffer
    IF I cooperated last round:
        Cooperate (with probability 0.9)
    ELSE:
        Cooperate (with probability 0.7)
        
ELSE IF prev_coop > m + floor((n-m)/2):
    # Large surplus of cooperators
    IF I cooperated last round:
        # Willing to step back slightly, but stay mostly cooperative
        Cooperate (with probability 0.7)
    ELSE:
        # Others have it covered, but don't fully abandon
        Cooperate (with probability 0.5)
```

**Trend Adjustment:**
- If cooperation has been *declining* over the last 3 rounds: increase my cooperation probability by 0.15
- If cooperation has been *stable at or above m* for 3+ rounds: no adjustment needed

### Final Round (Round r): Calculated Cooperation

The last round has no future shadow, but collective success still matters.

```
Let avg_coop = average cooperators over all previous rounds

IF avg_coop >= m:
    # Group has been successful - trust the pattern
    IF I have been a regular cooperator (cooperated > 50% of rounds):
        Cooperate (continue being reliable)
    ELSE:
        Cooperate with probability (m / n)
        
ELSE IF avg_coop < m:
    # Group has been failing - make strong cooperative push
    Cooperate (with probability 1)
```

---

## Edge Case Handling

### Edge Case 1: n = 2, m = 2 (Everyone Must Cooperate)
Both players must cooperate for anyone to get reward k. Strategy: Always cooperate—defection guarantees collective failure.

### Edge Case 2: m = n - 1 (Only One Can Defect)
Near-universal cooperation required. Strategy: Cooperate unless I observe consistent surplus (which is impossible here), so effectively always cooperate.

### Edge Case 3: m is Very Small Relative to n
Even with low m, I maintain baseline cooperation (~50%) because:
- I cannot coordinate with others about who the m cooperators are
- If everyone reasons "others will cover it," threshold fails

### Edge Case 4: k is Very Large
Higher k means threshold success is extremely valuable. Increase base cooperation probabilities by factor of min(1, k/3) up to certainty.

### Edge Case 5: Very Few Rounds (r = 2 or 3)
Less time to learn. Weight toward cooperation since establishing patterns is difficult.

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, my_history, observed_coop_counts, n, m, k):
    
    if round_num == 1:
        return COOPERATE
    
    prev_coop = observed_coop_counts[-1]
    
    # Base probability calculation
    if prev_coop < m:
        base_prob = 1.0
    elif prev_coop == m:
        base_prob = 1.0
    elif prev_coop <= m + (n - m) // 2:
        base_prob = 0.9 if my_history[-1] == COOPERATE else 0.7
    else:
        base_prob = 0.7 if my_history[-1] == COOPERATE else 0.5
    
    # Trend adjustment
    if len(observed_coop_counts) >= 3:
        if is_declining_trend(observed_coop_counts[-3:]):
            base_prob = min(1.0, base_prob + 0.15)
    
    # High-k adjustment
    if k > 2:
        base_prob = min(1.0, base_prob * (1 + (k - 2) / 5))
    
    # Final round logic
    if round_num == total_rounds:
        avg_coop = mean(observed_coop_counts)
        if avg_coop < m:
            base_prob = 1.0
    
    return COOPERATE if random() < base_prob else DEFECT
```

---

## Why This Strategy is Collectively Minded

1. **I volunteer to be part of the solution**: Rather than hoping others cooperate, I position myself as one of the m needed cooperators.

2. **I respond to collective need**: When cooperation falls short, I increase my contribution rather than abandoning ship.

3. **I allow sustainable free-riding**: When there's surplus cooperation, I *slightly* reduce my cooperation—not to exploit, but to signal that the group can afford some defection while maintaining threshold.

4. **I never fully defect based on others' success**: Even with surplus cooperators, I maintain meaningful cooperation probability because I cannot coordinate role assignment with others.

5. **I prioritize threshold achievement over personal gain**: My decision rules prioritize ensuring m cooperators exist over maximizing my individual (1-c_i) + k payoff.
'''

description_COLLECTIVE_102 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a collective mindset: **I am one of m players who must cooperate for everyone to benefit.** Rather than asking "should I free-ride?", I ask "am I one of the necessary cooperators?" The strategy balances willingness to contribute with adaptive responses to observed cooperation levels.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic fairness**: Cooperate with probability that, if all players used it, would slightly exceed the threshold m
2. **Adaptive responsiveness**: Adjust cooperation based on observed group behavior
3. **Endgame commitment**: Increase cooperation in final rounds to secure collective benefits

---

## Decision Rules

### Round 1: Baseline Cooperation

With no history, cooperate with probability:

```
p_base = min(1.0, (m + 1) / n)
```

This ensures that if all players use this strategy, expected cooperators ≈ m + 1, providing a safety margin above the threshold.

**Decision**: Generate random number r ∈ [0,1]. If r < p_base, **Cooperate**. Otherwise, **Defect**.

---

### Rounds 2 through (r-2): Adaptive Phase

Calculate cooperation probability based on recent history:

```
# Count cooperators in previous round
prev_cooperators = count of C plays in round (t-1)

# Calculate cooperation gap
gap = m - prev_cooperators

# Adaptive probability
if gap <= 0:
    # Threshold was met - maintain but allow some defection
    p_adapt = max(m/n, (m - 0.5) / n)
else:
    # Threshold not met - increase cooperation probability
    p_adapt = min(1.0, (m + gap) / n + 0.1)

# Incorporate longer-term trend (last 3 rounds or available history)
recent_rounds = min(3, t-1)
avg_cooperators = average cooperators over last recent_rounds rounds
trend_factor = avg_cooperators / m

if trend_factor >= 1.0:
    # Group is cooperative - stay course
    p_final = p_adapt
elif trend_factor >= 0.7:
    # Group is struggling - boost cooperation
    p_final = min(1.0, p_adapt + 0.15)
else:
    # Group is failing badly - still try to help but protect somewhat
    p_final = min(1.0, p_adapt + 0.1)
```

**Decision**: Generate random number r ∈ [0,1]. If r < p_final, **Cooperate**. Otherwise, **Defect**.

---

### Round (r-1): Pre-Final Round

Increase cooperation to signal commitment and build toward final round success:

```
prev_cooperators = count of C plays in round (t-1)

if prev_cooperators >= m:
    p_prefinal = m / n + 0.1  # Maintain with slight boost
else:
    p_prefinal = min(1.0, (m + 1) / n + 0.2)  # Strong boost
```

**Decision**: Cooperate with probability p_prefinal.

---

### Round r: Final Round

The last round has no future consequences, creating defection incentive. Counter this collectively:

```
# Calculate historical cooperation rate
total_cooperations = sum of all cooperations across all players, all rounds
historical_rate = total_cooperations / (n * (r-1))

if historical_rate >= m/n:
    # Group has been cooperative - reciprocate with high cooperation
    p_final_round = min(1.0, (m + 1) / n + 0.15)
else:
    # Group has struggled - still contribute but acknowledge reality  
    p_final_round = m / n
```

**Decision**: Cooperate with probability p_final_round.

---

## Pseudocode Summary

```
function decide(round t, history, parameters n, m, k, r):
    
    if t == 1:
        p = min(1.0, (m + 1) / n)
    
    else if t == r:  # Final round
        hist_rate = total_cooperations(history) / (n * (r-1))
        if hist_rate >= m/n:
            p = min(1.0, (m + 1) / n + 0.15)
        else:
            p = m / n
    
    else if t == r - 1:  # Pre-final round
        prev_coop = cooperators_in_round(history, t-1)
        if prev_coop >= m:
            p = m/n + 0.1
        else:
            p = min(1.0, (m + 1) / n + 0.2)
    
    else:  # Adaptive phase
        prev_coop = cooperators_in_round(history, t-1)
        gap = m - prev_coop
        
        if gap <= 0:
            p = max(m/n, (m - 0.5) / n)
        else:
            p = min(1.0, (m + gap) / n + 0.1)
        
        # Trend adjustment
        recent = average_cooperators(history, last 3 rounds)
        if recent / m < 0.7:
            p = min(1.0, p + 0.1)
        elif recent / m < 1.0:
            p = min(1.0, p + 0.15)
    
    return COOPERATE if random() < p else DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Fair burden sharing**: Base probability ensures each player contributes proportionally to the collective need

2. **Responsive to failure**: When thresholds aren't met, probability increases to compensate

3. **Doesn't over-cooperate**: When threshold is comfortably met, allows some defection to avoid exploitation while maintaining buffer

4. **Endgame awareness**: Actively counters end-round defection tendency

5. **Parameter adaptive**: Works across different n, m, k, r values by scaling probabilities to the threshold ratio
'''

description_COLLECTIVE_103 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the minimum viable coalition needed to avert collective risk, while adapting to observed cooperation levels. The goal is to ensure the threshold is met when possible, contribute fairly to the collective burden, and avoid being exploited by persistent defectors.

## Strategy Overview

The strategy operates on three principles:
1. **Threshold-focused**: Cooperate when my contribution is likely pivotal to reaching m cooperators
2. **Fair burden-sharing**: Over time, aim to cooperate roughly m/n of the time (my "fair share")
3. **Responsive**: Increase cooperation when the group is close to threshold; decrease when cooperation is abundant or hopeless

---

## Decision Rules

### Round 1: Probabilistic Start
With no history, cooperate with probability `m/n` (my fair share of the cooperation burden).

This creates an expected `m` cooperators if all players use similar reasoning, exactly meeting the threshold on average.

### Subsequent Rounds: Adaptive Response

**Step 1: Assess recent cooperation level**
- Let `prev_cooperators` = number of cooperators in the previous round
- Let `avg_cooperators` = average cooperators over all past rounds

**Step 2: Determine cooperation probability based on gap to threshold**

```
gap = m - prev_cooperators  # How far from threshold last round

if gap > 0:
    # Below threshold - collective risk realized
    # Increase cooperation, especially if gap is small (pivotal zone)
    base_prob = min(1.0, (m/n) + 0.2 * (m - gap + 1) / m)
    
elif gap == 0:
    # Exactly at threshold - fragile success
    # Maintain similar cooperation to preserve threshold
    base_prob = m/n + 0.1
    
else:  # gap < 0, meaning prev_cooperators > m
    # Above threshold - success with surplus
    # Can reduce cooperation slightly; others are covering
    surplus = prev_cooperators - m
    base_prob = max(0.1, (m/n) - 0.1 * surplus / (n - m))
```

**Step 3: Fairness adjustment**
Track my own cooperation rate (`my_coop_rate`) over past rounds.

```
fair_share = m / n
if my_coop_rate > fair_share + 0.15:
    # I've been cooperating more than my share - slight reduction
    base_prob = base_prob - 0.1
elif my_coop_rate < fair_share - 0.15:
    # I've been free-riding - increase cooperation
    base_prob = base_prob + 0.1
```

**Step 4: Cooperation momentum**
If cooperation has been increasing over the last 3 rounds, slightly increase probability (reward positive trends). If decreasing, maintain or slightly decrease (don't chase a collapsing coalition alone).

```
if trend > 0:
    base_prob = base_prob + 0.05
elif trend < 0 and avg_cooperators < m - 1:
    base_prob = base_prob - 0.05  # Don't throw resources at lost cause
```

### Final Round Special Case
In round r, pure self-interest dominates (no future to influence).

```
if expected_cooperators_without_me >= m:
    defect  # Threshold will be met anyway
elif expected_cooperators_without_me == m - 1:
    cooperate  # I'm pivotal
else:
    defect  # Threshold won't be met even with me
```

Where `expected_cooperators_without_me` is estimated from recent cooperation rates of others.

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **Round 1** | Cooperate with probability m/n |
| **Last round (r)** | Pivotality calculation (cooperate only if pivotal) |
| **All previous rounds had 0 cooperators** | Cooperate with probability m/n (try to seed cooperation) |
| **Cooperation consistently exceeds m+2** | Reduce to probability 0.15 (let surplus cooperators continue) |
| **m = n-1 or m = 2** | Higher base cooperation rate (each player more pivotal) |
| **n is very large** | Rely more heavily on recent average than single round |

---

## Pseudocode Summary

```python
def decide(round, history, my_history, n, m, k, r):
    fair_share = m / n
    
    if round == 1:
        return random() < fair_share
    
    prev_coop = count_cooperators(history[-1])
    avg_coop = average_cooperators(history)
    my_rate = sum(my_history) / len(my_history)
    
    # Base probability from gap analysis
    gap = m - prev_coop
    if gap > 0:
        prob = min(1.0, fair_share + 0.2 * (m - gap + 1) / m)
    elif gap == 0:
        prob = fair_share + 0.1
    else:
        prob = max(0.1, fair_share - 0.1 * (-gap) / (n - m))
    
    # Fairness correction
    if my_rate > fair_share + 0.15:
        prob -= 0.1
    elif my_rate < fair_share - 0.15:
        prob += 0.1
    
    # Last round: pivotality check
    if round == r:
        expected_others = estimate_other_cooperators(history)
        if expected_others >= m:
            return False
        elif expected_others == m - 1:
            return True
        else:
            return False
    
    return random() < clamp(prob, 0.05, 0.95)
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: If many players use threshold-seeking logic, the group naturally gravitates toward exactly m cooperators
2. **Exploits surplus**: When others over-cooperate, I can safely defect while collective risk is still averted
3. **Doesn't collapse**: Even facing defectors, maintains baseline cooperation attempt
4. **Fair over time**: Tracks own cooperation rate to avoid persistent free-riding or over-contribution
5. **Adapts to group size**: The m/n ratio scales appropriately for any valid parameters
'''

description_COLLECTIVE_104 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I should cooperate when my cooperation is *needed* to reach the threshold, and I should be willing to bear my fair share of the cooperation burden over time. The goal is to maximize collective welfare while being robust to exploitation.

## Strategy Overview

The strategy operates on three principles:
1. **Threshold Awareness**: Cooperate when the group appears to need exactly my contribution to reach m
2. **Fair Share Commitment**: Over time, aim to cooperate approximately m/n of the time (the fair share)
3. **Responsive Adaptation**: Adjust based on observed cooperation levels in the population

---

## Decision Rules

### Round 1: Probabilistic Fair Start

With no history, cooperate with probability `m/n`.

This ensures that in expectation, exactly m players cooperate—the minimum needed. It's the collectively optimal starting point that doesn't over-contribute.

```
first_round_action = C with probability m/n, else D
```

### Rounds 2 through r-1: Adaptive Cooperation

**Step 1: Observe recent cooperation rate**
```
recent_coop_count = number of cooperators in previous round
recent_coop_rate = recent_coop_count / n
```

**Step 2: Calculate my cooperation probability**

The key insight: I should cooperate more when cooperation is scarce, and less when it's abundant.

```
target_cooperators = m
shortfall = max(0, target_cooperators - recent_coop_count)
excess = max(0, recent_coop_count - target_cooperators)

# Base probability: fair share
base_prob = m / n

# Adjust based on need
if shortfall > 0:
    # Cooperation is scarce - increase my probability
    adjustment = shortfall / (n - recent_coop_count + 1)
    coop_probability = min(1.0, base_prob + adjustment * (1 - base_prob))
elif excess > 1:
    # More than enough cooperators - reduce slightly but stay engaged
    coop_probability = max(0.2, base_prob - 0.1 * (excess - 1))
else:
    # Near threshold - maintain fair share
    coop_probability = base_prob
```

**Step 3: Loyalty adjustment**
Track cumulative cooperation. If I've cooperated less than my fair share so far, increase probability:

```
my_coop_rate = my_cooperations_so_far / (current_round - 1)
fair_share = m / n

if my_coop_rate < fair_share - 0.1:
    coop_probability = min(1.0, coop_probability + 0.15)
```

**Step 4: Threshold memory**
If the threshold was NOT met in the previous round, significantly increase cooperation:

```
if previous_round_failed_threshold:
    coop_probability = min(1.0, coop_probability + 0.3)
```

### Final Round (Round r): Contribute if Critical

The last round has no shadow of the future, so purely strategic calculation applies. However, maintaining collective mindset:

```
if recent_coop_count == m - 1:
    # I'm pivotal - cooperate
    action = C
elif recent_coop_count >= m:
    # Threshold likely met without me
    action = D with probability 0.7, C with probability 0.3
else:
    # Threshold unlikely - cooperate to try
    action = C with probability m / (n - recent_coop_count)
```

---

## Complete Pseudocode

```python
def choose_action(round_number, total_rounds, n, m, k, history):
    
    # Round 1: Probabilistic fair start
    if round_number == 1:
        return C with probability (m / n)
    
    # Get previous round data
    prev_cooperators = count_cooperators(history, round_number - 1)
    prev_threshold_met = (prev_cooperators >= m)
    my_total_coops = count_my_cooperations(history)
    my_fair_share = m / n
    my_actual_rate = my_total_coops / (round_number - 1)
    
    # Base cooperation probability
    coop_prob = m / n
    
    # Adjust for current need
    if prev_cooperators < m:
        # Shortage: step up
        gap = m - prev_cooperators
        coop_prob = min(1.0, coop_prob + gap * 0.2)
    elif prev_cooperators > m + 1:
        # Surplus: can relax slightly
        coop_prob = max(0.25, coop_prob - 0.1)
    
    # Adjust for my cumulative contribution
    if my_actual_rate < my_fair_share - 0.1:
        coop_prob = min(1.0, coop_prob + 0.15)
    
    # Emergency response to threshold failure
    if not prev_threshold_met:
        coop_prob = min(1.0, coop_prob + 0.3)
    
    # Final round special logic
    if round_number == total_rounds:
        if prev_cooperators == m - 1:
            return C  # Pivotal
        elif prev_cooperators >= m:
            coop_prob = 0.3  # Likely covered
        else:
            coop_prob = min(0.9, m / max(1, n - prev_cooperators))
    
    return C with probability coop_prob, else D
```

---

## Why This Strategy is Collectively Robust

1. **Avoids over-cooperation**: Doesn't blindly always cooperate, which would be exploitable
2. **Responds to failure**: Dramatically increases cooperation after threshold failures
3. **Maintains fair share**: Tracks personal contribution and corrects toward equity
4. **Handles diverse opponents**: Works whether others are cooperative, selfish, or mixed
5. **Scales with parameters**: Naturally adjusts to any valid n, m, k configuration
'''

description_COLLECTIVE_105 = '''
# Collective Risk Dilemma Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the minimum viable coalition needed to secure the collective reward, while adapting to observed cooperation levels. The goal is not to maximize individual payoff at others' expense, but to reliably contribute to collective success when my contribution matters.

## Decision Rules

### Primary Rule: Probabilistic Threshold Targeting

In each round, I cooperate with probability p, where p is calibrated so that the expected number of cooperators (if all players used similar reasoning) would slightly exceed the threshold m.

**Base cooperation probability:**
```
p_base = (m + 1) / n
```

This targets m+1 expected cooperators, providing a small buffer above the threshold.

### Adaptive Adjustment Based on History

After observing previous rounds, I adjust my cooperation probability based on:

1. **Cooperation Gap**: How close was actual cooperation to the threshold?
2. **Success Rate**: How often has the threshold been met?
3. **Trend**: Is cooperation increasing or decreasing?

```
Let:
  c_prev = number of cooperators in previous round
  success_rate = (rounds where c ≥ m) / (rounds played)
  
Adjustment factor:
  If c_prev < m:  increase = (m - c_prev) / n × 0.5
  If c_prev ≥ m:  increase = 0
  
  If success_rate < 0.5: boost = 0.15
  Else: boost = 0

p_adjusted = p_base + increase + boost
p_final = min(p_adjusted, 0.95)  # Cap to maintain some strategic flexibility
```

### Deterministic Commitment Threshold

If the situation becomes critical (repeated failures), switch to deterministic cooperation:

```
If last 3 consecutive rounds failed (c < m):
  Cooperate with certainty (p = 1) for next 2 rounds
```

## Edge Case Handling

### First Round
- No history available
- Use: `p = (m + 1) / n`
- This represents good-faith participation in the collective

### Last Round
- Standard game theory suggests defection, but this undermines collective outcomes
- **Decision**: Maintain the same adaptive probability as calculated
- Rationale: If everyone defects in the last round, the collective loses. By maintaining cooperation probability, I give the collective a chance to succeed.

### When m is Very Close to n
- If `m ≥ n - 1`: Cooperation becomes nearly essential from everyone
- Increase base probability: `p_base = min((m + 1) / n, 0.9)`

### When Threshold is Always Met
- If threshold met for 5+ consecutive rounds with significant surplus (c > m + 2):
- Slightly reduce probability: `p = p_base - 0.1`
- This allows others who may be "carrying" the collective to occasionally rest

## Pseudocode Implementation

```python
def decide(game_params, history):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    # Base probability
    p = (m + 1) / n
    
    if history:
        # Recent cooperation levels
        last_c = history[-1]['total_cooperators']
        successes = sum(1 for h in history if h['total_cooperators'] >= m)
        success_rate = successes / len(history)
        
        # Adjust for cooperation gap
        if last_c < m:
            p += (m - last_c) / n * 0.5
        
        # Boost if struggling
        if success_rate < 0.5:
            p += 0.15
        
        # Emergency cooperation after repeated failures
        recent_failures = all(
            h['total_cooperators'] < m 
            for h in history[-3:]
        ) if len(history) >= 3 else False
        
        if recent_failures:
            p = 1.0
        
        # Slight reduction if consistently over-threshold
        if len(history) >= 5:
            recent_surplus = all(
                h['total_cooperators'] > m + 2 
                for h in history[-5:]
            )
            if recent_surplus:
                p -= 0.1
    
    # Apply bounds
    p = max(0.05, min(p, 0.95))
    
    # Make decision
    return 'C' if random() < p else 'D'
```

## Why This Strategy is Collectively Robust

1. **Not exploitable by mass defection**: When others defect, I increase cooperation to try to save the collective outcome.

2. **Not a sucker**: I don't always cooperate; I target being part of a minimal winning coalition.

3. **Adaptive**: Responds to actual behavior, not assumptions about opponent rationality.

4. **Stochastic fairness**: Over many rounds, the burden of cooperation is probabilistically shared.

5. **Emergency response**: Deterministic cooperation kicks in when the collective is failing, signaling commitment.

6. **Maintains last-round integrity**: Refusing to defect purely because it's the last round preserves collective outcomes and signals trustworthiness in repeated tournament play.
'''

description_COLLECTIVE_106 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to help ensure the group reaches the threshold. The key insight is that the collective benefit (everyone getting +k) far outweighs individual savings from defection, but only if we reliably meet the threshold. I aim to be a "guardian" of the threshold—cooperating when needed, but not wastefully over-contributing when others are already handling it.

## Strategy Overview

The strategy operates on three principles:
1. **Be willing to cooperate** - Default toward cooperation, especially early
2. **Be responsive to observed behavior** - Adjust based on how many cooperators we actually see
3. **Avoid being exploited** - If cooperation consistently fails to reach threshold despite my contribution, reduce costly cooperation

---

## Decision Rules

### Round 1: Cooperative Start

**Decision: COOPERATE**

Rationale: With no history, I signal cooperative intent. If enough others think similarly, we establish a cooperative norm from the start.

---

### Middle Rounds (2 to r-1): Adaptive Response

Let `C_prev` = number of cooperators in the previous round

**Calculate my "cooperation need score":**

```
If C_prev >= m:
    # Threshold was met last round
    If C_prev == m:
        # Exactly at threshold - cooperation is critical, stay cooperative
        COOPERATE
    Else if C_prev > m + 1:
        # Surplus cooperators - I can potentially free-ride
        # But be cautious: calculate cooperation probability
        cooperation_probability = m / C_prev
        COOPERATE with probability = cooperation_probability
    Else:  # C_prev == m + 1
        # Small surplus - lean toward cooperation to maintain buffer
        COOPERATE with probability = 0.7

Else if C_prev < m:
    # Threshold was NOT met - collective failure
    If C_prev >= m - 1:
        # Close to threshold - one more cooperator might tip it
        # Check: was I cooperating? If yes, others need to step up
        If I_cooperated_last_round:
            # Give others a chance, but stay engaged
            COOPERATE with probability = 0.6
        Else:
            # I was part of the problem - step up
            COOPERATE
    Else:
        # Far from threshold (C_prev < m - 1)
        # Cooperation is likely futile if others won't join
        # Reduce cooperation but don't abandon entirely
        shortfall = m - C_prev
        cooperation_probability = max(0.3, 1 - (shortfall / m))
        COOPERATE with probability = cooperation_probability
```

### Trend Adjustment

Track cooperation trend over last 3 rounds (when available):

```
trend = (C_current - C_three_rounds_ago) / 3

If trend > 0:  # Cooperation increasing
    Increase cooperation_probability by 0.1
If trend < 0:  # Cooperation declining  
    Decrease cooperation_probability by 0.1

Clamp cooperation_probability to [0.2, 0.95]
```

---

### Final Round (round r): Threshold-Focused

The last round has no future consequences, but the collective outcome still matters.

**Use a "projected cooperator" estimate based on recent history:**

```
Let C_avg = average cooperators over last min(3, r-1) rounds

If C_avg >= m:
    # Group has been meeting threshold
    If C_avg <= m + 0.5:
        # Tight margins - cooperate to ensure success
        COOPERATE
    Else:
        # Comfortable margin - probabilistic cooperation
        COOPERATE with probability = m / C_avg

Else:  # C_avg < m
    # Group has been failing
    If C_avg >= m - 1:
        # Close - make one last cooperative push
        COOPERATE
    Else:
        # Persistent failure - defect to minimize losses
        DEFECT
```

---

## Edge Cases

| Situation | Decision | Rationale |
|-----------|----------|-----------|
| n = 2, m = 2 | Always COOPERATE | Both must cooperate; no free-riding possible |
| m = n - 1 | COOPERATE with p = 0.9 | Nearly everyone needed; be reliable |
| r = 2 (minimal rounds) | COOPERATE both rounds | Too short to learn; commit to cooperation |
| All previous rounds failed | COOPERATE if shortfall ≤ 2, else DEFECT | Don't waste resources on hopeless situations |
| All previous rounds succeeded with surplus | Probabilistic based on m/C_prev | Efficient cooperation |
| k is very large (k > 3) | Increase all probabilities by 0.1 | Higher stakes justify more cooperation |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    
    if round == 1:
        return COOPERATE
    
    C_prev = count_cooperators(history, round - 1)
    I_cooperated = my_action(history, round - 1) == COOPERATE
    
    # Base probability calculation
    if C_prev >= m:
        if C_prev == m:
            prob = 1.0
        elif C_prev == m + 1:
            prob = 0.7
        else:
            prob = m / C_prev
    else:
        shortfall = m - C_prev
        if shortfall == 1:
            prob = 0.6 if I_cooperated else 1.0
        else:
            prob = max(0.3, 1 - shortfall / m)
    
    # Trend adjustment (if enough history)
    if round >= 4:
        trend = (C_prev - count_cooperators(history, round - 3)) / 3
        prob += trend * 0.1
    
    # High-stakes adjustment
    if k > 3:
        prob += 0.1
    
    # Final round adjustment
    if round == r:
        C_avg = average_recent_cooperators(history, 3)
        if C_avg < m - 1:
            prob = 0.2  # Near-abandon in hopeless final round
    
    prob = clamp(prob, 0.2, 0.95)
    
    return COOPERATE if random() < prob else DEFECT
```

---

## Why This Strategy is Collectively-Minded

1. **Defaults to cooperation** - Assumes collective success is achievable and valuable
2. **Maintains threshold** - Prioritizes ensuring m cooperators exist
3. **Doesn't over-defect** - Even in bad situations, maintains 20%+ cooperation to allow recovery
4. **Responds to others** - Adjusts to actual group behavior rather than assuming the worst
5. **Shares the burden** - Uses probabilistic cooperation so the same players don't always bear costs
'''

description_COLLECTIVE_107 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not more than necessary. The key insight is that in a collective setting, the goal isn't individual maximization—it's ensuring the threshold is met while distributing the cooperation burden fairly across players who demonstrate collective commitment.

## Strategy Overview

I use a **reputation-weighted probabilistic cooperation** approach that:
1. Starts with cautious optimism calibrated to the threshold
2. Tracks each player's cooperation history to identify reliable cooperators
3. Adjusts my cooperation probability to complement observed cooperation levels
4. Becomes more decisive as the game progresses

---

## Decision Rules

### Round 1: Calibrated Optimism

**Cooperate with probability p₁ = m/n**

Rationale: If all players use this same logic, expected cooperators = n × (m/n) = m, exactly meeting the threshold. This is the collectively rational starting point.

### Rounds 2 through r-1: Adaptive Complementary Cooperation

**Step 1: Calculate each player's cooperation rate**
```
For each player j ≠ me:
    coop_rate[j] = (times j cooperated) / (rounds played)
```

**Step 2: Estimate expected cooperators (excluding myself)**
```
expected_others = Σ coop_rate[j] for all j ≠ me
```

**Step 3: Calculate cooperation gap**
```
gap = m - expected_others
```

**Step 4: Determine my cooperation probability**
```
if gap ≤ 0:
    # Threshold likely met without me - cooperate with low probability
    # but not zero (maintain some contribution to collective)
    p = max(0.1, m/(2n))
    
elif gap ≥ 1:
    # My cooperation is likely needed
    # Scale probability based on how critical I am
    p = min(0.95, 0.5 + 0.4 × (gap / m))
    
else:
    # Marginal case - probabilistic cooperation
    p = 0.5 + 0.4 × gap
```

**Step 5: Adjust for collective reliability**
```
# Measure how stable cooperation has been
avg_coop_rate = expected_others / (n-1)
variance = measure of round-to-round cooperation volatility

if variance is high:
    # Unreliable environment - lean toward cooperation
    p = p + 0.15 × (1 - p)
    
if avg_coop_rate > m/n:
    # Others are collectively-minded - reciprocate
    p = p + 0.1 × (1 - p)
```

### Final Round (Round r): Strategic Consideration

The final round has no future consequences, creating defection incentives. However, maintaining collective mindset:

```
if expected_others ≥ m:
    # Threshold likely met - can safely defect
    p = 0.1
    
elif expected_others ≥ m - 1:
    # I might be pivotal
    p = 0.7
    
else:
    # Threshold unlikely regardless - defect
    p = 0.2
```

---

## Edge Case Handling

### Edge Case 1: m is very close to n (e.g., m = n-1)
```
if m ≥ n - 1:
    # Nearly universal cooperation needed
    # Must be highly cooperative
    base_probability_boost = 0.2
```

### Edge Case 2: m is very small relative to n (e.g., m = 2, n = 10)
```
if m/n < 0.3:
    # Few cooperators needed - can be more selective
    # Only cooperate if I see a deficit
    reduce base cooperation probability by factor of 0.7
```

### Edge Case 3: Very short games (r ≤ 3)
```
if r ≤ 3:
    # Limited learning time - be more cooperative throughout
    increase all probabilities by 0.1
```

### Edge Case 4: Observing consistent defectors
```
if any player has defected in all rounds (and rounds > 2):
    # Adjust expected cooperators down for them
    # But don't abandon collective goal
    treat their coop_rate as 0.05 (not 0)
```

### Edge Case 5: Everyone cooperated last round but threshold was exactly met
```
if (cooperators_last_round == m) and (I cooperated):
    # Borderline case - slight random variation to avoid lock-in
    add small random adjustment ±0.1 to probability
```

---

## Pseudocode Summary

```
function decide(round, history, n, m, r, k):
    
    if round == 1:
        return COOPERATE with probability m/n
    
    # Calculate cooperation rates
    coop_rates = [times_cooperated[j] / (round-1) for j in other_players]
    expected_others = sum(coop_rates)
    gap = m - expected_others
    
    # Base probability from gap
    if gap <= 0:
        p = max(0.1, m/(2*n))
    elif gap >= 1:
        p = min(0.95, 0.5 + 0.4 * (gap/m))
    else:
        p = 0.5 + 0.4 * gap
    
    # Reliability adjustment
    if cooperation_variance is high:
        p = p + 0.15 * (1-p)
    if average_coop_rate > m/n:
        p = p + 0.1 * (1-p)
    
    # Final round adjustment
    if round == r:
        if expected_others >= m:
            p = 0.1
        elif expected_others >= m-1:
            p = 0.7
        else:
            p = 0.2
    
    # Edge case adjustments
    apply_edge_case_modifiers(p, n, m, r)
    
    return COOPERATE with probability p
```

---

## Why This Strategy is Collectively Minded

1. **Threshold-focused**: I aim to be part of the solution, not to free-ride
2. **Burden-sharing**: Probabilistic cooperation distributes costs fairly
3. **Responsive**: I cooperate more when others need me, less when they don't
4. **Resilient**: I don't abandon cooperation due to a few defectors
5. **Sustainable**: Adjustments prevent both over-cooperation and collapse

The strategy treats other players as potential collective partners, not adversaries, while remaining robust to exploitation by adapting cooperation levels to actual observed behavior.
'''

description_COLLECTIVE_108 = '''
# Collective Risk Dilemma: Adaptive Threshold Strategy

## Strategic Analysis

The core tension in this game is clear: when exactly m players cooperate, defectors get the best outcome (k+1) while cooperators get less (k). However, if too many defect, everyone loses the bonus k. The challenge is coordinating without communication to ensure the threshold is met while avoiding exploitation.

**Key insight**: In a collective strategy where all players use the same algorithm, we need to create a self-coordinating mechanism that:
1. Reliably meets the threshold m
2. Distributes the "burden" of cooperation fairly over time
3. Adapts if the threshold is being missed

## Strategy: "Fair Share Rotation with Adaptive Safety Margin"

### Core Concept

Each player uses their index and deterministic pseudo-randomization based on round number to rotate cooperation duties. The strategy maintains a "safety margin" (cooperating slightly above m) that adjusts based on observed success rates.

### Decision Rules

```
PARAMETERS:
- base_cooperators = m + safety_margin  (where safety_margin starts at 1)
- cooperation_probability = base_cooperators / n

ROUND t DECISION:

1. FIRST ROUND (t = 1):
   - Compute: threshold = (i - 1) / n
   - Cooperate if: threshold < (m + 1) / n
   - (This deterministically selects the first m+1 indexed players to cooperate)

2. MIDDLE ROUNDS (1 < t < r):
   
   a) Calculate rotation offset:
      - offset = (t * prime_multiplier) mod n
      - where prime_multiplier = largest prime < n (or 1 if n ≤ 2)
   
   b) Calculate rotated position:
      - rotated_index = ((i - 1) + offset) mod n
   
   c) Adjust safety margin based on history:
      - success_rate = (rounds where threshold met) / (rounds played)
      - If success_rate < 0.8: increase safety_margin by 1 (max: n - m)
      - If success_rate = 1.0 for last 3 rounds: decrease safety_margin by 1 (min: 0)
   
   d) Cooperate if:
      - rotated_index < (m + safety_margin)

3. LAST ROUND (t = r):
   - Same as middle rounds, but:
   - If success_rate in previous rounds ≥ 0.9: maintain cooperation pattern
   - If success_rate < 0.5: Defect (threshold unlikely to be met regardless)

4. EMERGENCY OVERRIDE:
   - If the last 2 consecutive rounds failed to meet threshold:
     - Cooperate regardless of rotation (prioritize collective survival)
   - If my cooperation rate is significantly above fair share (> m/n + 0.2) 
     AND threshold has been consistently met (≥ 90%):
     - May defect to balance burden
```

### Pseudocode Implementation

```python
def decide(player_index, round_num, total_rounds, n, m, k, history):
    
    # Calculate success rate from history
    if history:
        successes = sum(1 for round_data in history 
                       if count_cooperators(round_data) >= m)
        success_rate = successes / len(history)
    else:
        success_rate = 1.0  # Assume success initially
    
    # Calculate my cooperation rate
    my_coop_rate = count_my_cooperations(history) / max(len(history), 1)
    fair_share = m / n
    
    # Adaptive safety margin
    safety_margin = 1  # Default
    if success_rate < 0.8:
        safety_margin = min(2, n - m)
    if success_rate < 0.5:
        safety_margin = min(3, n - m)
    if len(history) >= 3 and all_recent_success(history, 3):
        safety_margin = max(0, safety_margin - 1)
    
    # Emergency: consecutive failures
    if len(history) >= 2 and last_k_failed(history, 2, m):
        return 'C'
    
    # Last round consideration
    if round_num == total_rounds and success_rate < 0.5:
        return 'D'
    
    # Rotation mechanism
    prime_mult = largest_prime_less_than(n) if n > 2 else 1
    offset = (round_num * prime_mult) % n
    rotated_position = ((player_index - 1) + offset) % n
    
    # Cooperation decision
    target_cooperators = m + safety_margin
    if rotated_position < target_cooperators:
        return 'C'
    else:
        return 'D'
```

### Edge Cases

| Situation | Action |
|-----------|--------|
| First round | Deterministic selection: lowest indices cooperate |
| Last round | Maintain strategy unless collective failure is evident |
| m = n-1 | High safety margin; most players cooperate |
| m very small | Rotation with minimal cooperators |
| Consecutive failures | Emergency cooperation override |
| n = 2, m = 1 | Alternate cooperation each round |

### Why This Strategy is Collectively Robust

1. **Self-coordinating**: Uses deterministic rotation based on player index—no communication needed
2. **Fair burden sharing**: Rotation ensures cooperation duties are distributed evenly over time
3. **Adaptive**: Responds to failures by increasing participation
4. **Efficient**: Targets m + small margin rather than all cooperating (maximizes collective payoff)
5. **Resilient**: Emergency override prevents cascading failures
'''

description_COLLECTIVE_109 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to ensure the group achieves the threshold when it matters most. The strategy recognizes that in a collective risk dilemma, the worst outcome is failing to meet the threshold when cooperation was needed—everyone loses the bonus k. I aim to be a reliable cooperator who helps the group succeed, while adapting to the observed behavior of others.

---

## Strategy Overview

The strategy operates on three principles:
1. **Default to cooperation** - Be part of the solution, not the problem
2. **Adapt to group behavior** - If cooperation is abundant, I can occasionally defect; if scarce, I must cooperate more reliably
3. **Protect critical rounds** - Never abandon cooperation when the group needs exactly m cooperators

---

## Decision Rules

### Round 1: Cooperative Start
**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent. This establishes trust and provides information about others' strategies.

### Rounds 2 through r-1: Adaptive Cooperation

Calculate the following from history:
- `avg_cooperators`: Average number of cooperators per round (excluding self)
- `threshold_met_rate`: Fraction of rounds where threshold m was met
- `cooperation_margin`: avg_cooperators - (m - 1) (how many "extra" cooperators beyond what's needed if I cooperate)

**Decision Logic:**

```
IF threshold_met_rate < 0.5:
    # Group is struggling - be reliable
    COOPERATE

ELSE IF avg_cooperators < m:
    # My cooperation is likely critical to meeting threshold
    COOPERATE

ELSE IF cooperation_margin >= 2:
    # Cooperation is abundant - I can occasionally defect
    # But still cooperate most of the time to maintain group success
    IF (current_round mod 3) == 0:
        DEFECT
    ELSE:
        COOPERATE

ELSE IF cooperation_margin >= 1:
    # Cooperation is adequate but not abundant
    # Cooperate with high probability to maintain stability
    IF (current_round mod 5) == 0:
        DEFECT
    ELSE:
        COOPERATE

ELSE:
    # Cooperation is marginal - stay reliable
    COOPERATE
```

### Final Round (Round r): Conditional Cooperation

The last round has no future shadow, but collective success still matters.

```
IF threshold_met_rate >= 0.7 AND avg_cooperators >= m:
    # Group has been successful and cooperation is stable
    # Trust that enough others will cooperate
    IF avg_cooperators >= m + 2:
        DEFECT  # Others can cover
    ELSE:
        COOPERATE  # Stay reliable
ELSE:
    # Group needs help or has been struggling
    COOPERATE
```

---

## Edge Case Handling

### Very Small Groups (n ≤ 4)
When n is small, every player's choice is critical:
```
IF n <= 4:
    # Override defection rules - almost always cooperate
    # Only defect if avg_cooperators >= m + 1 AND threshold_met_rate == 1.0
```

### High Threshold (m > n/2)
When majority cooperation is required:
```
IF m > n/2:
    # Cooperation is critical - reduce defection frequency
    # Only defect when cooperation_margin >= 3
```

### Short Games (r ≤ 5)
Limited rounds mean less adaptation time:
```
IF r <= 5:
    # Cooperate in all rounds except possibly round r
    # Use final round rule only
```

### Low Reward (k ≤ 1.5)
When the collective benefit is small relative to private keeping:
```
IF k <= 1.5:
    # Still prioritize collective success, but be slightly more conservative
    # Reduce cooperation_margin thresholds by 1
```

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return COOPERATE
    
    avg_coop = average_cooperators_excluding_self(history)
    threshold_rate = fraction_threshold_met(history)
    margin = avg_coop - (m - 1)
    
    # Edge cases
    if n <= 4 or m > n/2:
        if margin >= 3 and threshold_rate == 1.0:
            return DEFECT
        return COOPERATE
    
    if r <= 5 and round < r:
        return COOPERATE
    
    # Final round
    if round == r:
        if threshold_rate >= 0.7 and margin >= 2:
            return DEFECT
        return COOPERATE
    
    # Standard rounds
    if threshold_rate < 0.5 or avg_coop < m:
        return COOPERATE
    elif margin >= 2:
        return DEFECT if (round % 3 == 0) else COOPERATE
    elif margin >= 1:
        return DEFECT if (round % 5 == 0) else COOPERATE
    else:
        return COOPERATE
```

---

## Why This Strategy is Collectively Minded

1. **Prioritizes group success**: Default cooperation ensures the threshold is met when possible
2. **Absorbs risk**: I cooperate even when uncertain, accepting personal cost to prevent collective failure
3. **Sustainable defection**: Only defects when cooperation is clearly abundant, never endangering the threshold
4. **Adaptive support**: Increases cooperation when the group struggles, acting as a "guardian" of collective success
5. **No exploitation**: Doesn't try to free-ride systematically—defection is minimal and conditional on group health
'''

description_COLLECTIVE_110 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a collective mindset: **I cooperate because meeting the threshold benefits everyone, including myself.** The goal is to be part of a reliable coalition of cooperators while adapting to the observed behavior of others. I aim to be a "threshold guardian" - someone who helps ensure the minimum m cooperators exist, but not wastefully when cooperation is already abundant.

---

## Decision Rules

### Rule 1: Probabilistic First-Round Cooperation

**Round 1:** Cooperate with probability `p_init = m/n + ε` where `ε = 0.1`

*Rationale:* With no history, I signal cooperative intent while accounting for the mathematical reality that exactly m cooperators are needed. The slight boost (ε) accounts for uncertainty and demonstrates good faith.

### Rule 2: Threshold-Responsive Cooperation

**Rounds 2 through r-1:** Base decision on recent cooperation levels.

```
Let C_prev = number of cooperators in previous round
Let C_avg = average cooperators over all previous rounds

IF C_prev >= m:
    # Threshold was met - success! But should I still cooperate?
    IF C_prev == m:
        # Exactly at threshold - I'm critical, maintain cooperation if I cooperated
        Cooperate with probability 0.9 if I cooperated last round
        Cooperate with probability 0.5 if I defected last round
    ELIF C_prev > m + 1:
        # Surplus cooperators - I can consider defecting
        # But not everyone should think this way simultaneously
        Cooperate with probability max(m/C_prev, 0.4)
    ELSE: # C_prev == m + 1
        Cooperate with probability 0.7 if I cooperated, 0.4 otherwise

ELIF C_prev < m:
    # Threshold was NOT met - collective failure
    IF C_prev >= m - 2:
        # Close to threshold - increase cooperation to help reach it
        Cooperate with probability min(0.9, (m - C_prev + 1) / (n - C_prev))
    ELSE:
        # Far from threshold - cooperation is risky but someone must start
        # Cooperate more if I was already cooperating (maintain commitment)
        Cooperate with probability 0.6 if I cooperated last round
        Cooperate with probability 0.3 if I defected last round
```

### Rule 3: Reputation Tracking & Adjustment

Maintain a "collective cooperation score" over the game:

```
cooperation_rate = total_cooperations_observed / (n * rounds_played)

IF cooperation_rate > m/n + 0.15:
    # Population is cooperative - I can occasionally free-ride
    Reduce my cooperation probability by 0.1
ELIF cooperation_rate < m/n - 0.1:
    # Population is struggling - I should help more
    Increase my cooperation probability by 0.15
```

### Rule 4: Last Round Logic

**Final round (round r):** 

```
IF C_avg >= m:
    # History suggests threshold will be met
    # Defection is tempting but risks collective collapse if others think similarly
    Cooperate with probability m/n (be part of expected coalition)
ELSE:
    # History suggests failure is common
    # Make a final cooperative push
    Cooperate with probability 0.7
```

---

## Edge Case Handling

| Situation | Action |
|-----------|--------|
| **m = n-1** (almost everyone needed) | Cooperate with probability 0.95 always - defection is too risky |
| **m = 2** (low threshold) | Follow base rules but cap cooperation at 0.6 after round 1 |
| **k is very large (k > 3)** | Increase all cooperation probabilities by 0.1 - reward justifies risk |
| **k is small (k < 1.5)** | Decrease cooperation probabilities by 0.1 - be more selective |
| **Threshold consistently met** | Gradually reduce cooperation by 0.05 per successful round (floor: 0.3) |
| **Threshold consistently failed** | If failed 3+ consecutive rounds, cooperate with probability 0.8 to break cycle |

---

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return cooperate_with_prob(m/n + 0.1)
    
    C_prev = count_cooperators(history[-1])
    C_avg = average_cooperators(history)
    my_last_action = my_history[-1]
    
    # Adjust base probability based on threshold proximity
    if C_prev >= m:
        base_prob = 0.9 if C_prev == m else max(m/C_prev, 0.4)
    else:
        gap = m - C_prev
        base_prob = min(0.9, 0.5 + 0.15 * gap)
    
    # Loyalty bonus: committed cooperators stay committed
    if my_last_action == COOPERATE:
        base_prob = min(1.0, base_prob + 0.15)
    
    # Reward scaling
    base_prob *= min(1.2, k/2)
    
    # Last round adjustment
    if round == r:
        base_prob = max(base_prob - 0.1, m/n)
    
    return cooperate_with_prob(clamp(base_prob, 0.1, 0.95))
```

---

## Why This Strategy is Collectively Robust

1. **Signals cooperation early** - Builds trust and coordination potential
2. **Responds to collective needs** - Increases contribution when threshold is at risk
3. **Avoids exploitation** - Doesn't blindly cooperate when surplus exists
4. **Maintains commitment** - Past cooperators remain more likely to cooperate
5. **Adapts to population** - Adjusts based on observed cooperation rates
6. **Handles diverse opponents** - Works whether others are cooperative, selfish, or random
'''

description_COLLECTIVE_111 = '''
# Collective Risk Dilemma: Adaptive Threshold Strategy

## Core Philosophy

This strategy embraces a **collective mindset**: I assume other players may be running similar reasoning processes and will recognize that mutual cooperation above the threshold benefits everyone. The key insight is that we need *exactly enough* cooperators to meet the threshold—having more wastes individual endowments, having fewer means everyone loses the bonus.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to produce approximately m cooperators in expectation, combined with **adaptive adjustments** based on observed history.

---

## Decision Rules

### Round 1: Baseline Probabilistic Cooperation

With no history, cooperate with probability:

```
p_base = (m + 0.5) / n
```

The +0.5 buffer accounts for variance—we'd rather slightly overshoot than miss the threshold.

**Rationale**: If all n players use this probability, expected cooperators ≈ m + 0.5, giving good odds of meeting the threshold while minimizing excess cooperation.

### Rounds 2 through r-1: Adaptive Cooperation

Adjust cooperation probability based on recent outcomes:

```
p_t = clamp(p_base + adjustment, 0.15, 0.95)

where adjustment = α * (m - avg_cooperators_recent) / n
      α = 0.3 (learning rate)
      avg_cooperators_recent = average cooperators over last min(3, t-1) rounds
```

**Decision rule for round t:**
1. Calculate p_t as above
2. Generate a deterministic "random" value using: `hash(player_index, round, game_id) mod 1000 / 1000`
3. Cooperate if this value < p_t

**Additional adjustments:**
- **Success streak bonus**: If threshold was met in the last 2+ consecutive rounds, reduce p slightly by 0.05 (we can afford to be slightly less cooperative when things are working)
- **Failure response**: If threshold was missed last round, increase p by 0.1 (urgent correction needed)
- **Defector punishment**: If I cooperated but threshold was missed due to insufficient cooperators, increase my cooperation probability anyway (someone needs to step up)

### Final Round (Round r): Modified Strategy

The last round changes incentives since there's no future to protect:

```
If (recent_success_rate > 0.6):
    # Cooperation has been working - maintain it
    p_final = p_base + 0.1
Else:
    # Cooperation has been failing - attempt one last coordination push
    p_final = (m + 1) / n
```

**Rationale**: Unlike typical repeated games, defecting in the final round here doesn't "punish" anyone—it just risks missing the threshold. A collectively-minded agent should still cooperate if it helps reach m.

---

## Edge Cases

### Edge Case 1: m is very close to n
When m ≥ n - 1, nearly everyone must cooperate:
```
p = max(p_calculated, 0.9)
```

### Edge Case 2: m is very small relative to n
When m ≤ n/4, be more selective:
```
p = min(p_calculated, (m + 1) / n + 0.1)
```

### Edge Case 3: High k value (k > 2)
When the collective reward is very high, bias toward cooperation:
```
p = p_calculated + 0.05 * min(k - 1, 2)
```

### Edge Case 4: Very few rounds (r ≤ 3)
Less time to adapt, so be more cooperative from the start:
```
p = p_base + 0.1
```

---

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    p_base = (m + 0.5) / n
    
    if round == 1:
        p = p_base
    else:
        recent_rounds = history[max(0, round-3) : round]
        avg_coop = mean(cooperator_count for each round in recent_rounds)
        
        adjustment = 0.3 * (m - avg_coop) / n
        
        if last_round_missed_threshold:
            adjustment += 0.1
        if consecutive_successes >= 2:
            adjustment -= 0.05
            
        p = clamp(p_base + adjustment, 0.15, 0.95)
    
    # Apply edge case modifiers
    if m >= n - 1: p = max(p, 0.9)
    if k > 2: p = p + 0.05 * min(k - 1, 2)
    if round == r and success_rate < 0.6: p = (m + 1) / n
    
    # Deterministic "randomization" for reproducibility
    threshold = hash(player_id, round, game_seed) % 1000 / 1000
    
    return COOPERATE if threshold < p else DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: No coordination mechanism needed—probabilistic matching naturally produces ~m cooperators
2. **Adaptive**: Corrects over/under-cooperation based on observed outcomes
3. **Robust to defectors**: If others defect more, survivors compensate by cooperating more
4. **Not exploitable**: Bounded cooperation probability prevents being drained by pure defectors
5. **Collectively optimal**: Aims for exactly the threshold, maximizing collective efficiency
'''

description_COLLECTIVE_112 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to ensure the collective threshold is met while being robust to free-riders. The key insight is that in a collective risk dilemma, the worst outcome is failing to meet the threshold—everyone loses the bonus k. My goal is to be a reliable cooperator who helps the group succeed, while adapting to observed behavior patterns.

## Strategy Overview

I act as a "threshold guardian"—someone who cooperates by default to ensure collective success, but who can strategically defect when cooperation is clearly excessive (well above threshold) or clearly futile (too few cooperators regardless of my choice).

---

## Decision Rules

### Round 1: Probabilistic Cooperation Based on Position

Since I cannot coordinate with others, I use a deterministic rule based on my player index to distribute initial cooperation:

```
If (my_index ≤ m + 1):
    COOPERATE
Else:
    DEFECT
```

**Rationale:** This ensures that if all players follow similar logic, we'll have slightly more than m cooperators—a safety margin. The "+1" buffer accounts for the possibility that some "designated cooperators" might defect.

### Rounds 2 through (r-1): Adaptive Cooperation

**Step 1: Observe previous round**
- Count: `prev_cooperators` = number of players who cooperated last round
- Track: `my_cooperation_rate` = my cooperations / rounds played
- Track: `group_cooperation_rate` = total cooperations / (n × rounds played)

**Step 2: Classify the situation**

```
CRITICAL_ZONE:    prev_cooperators < m
THRESHOLD_ZONE:   prev_cooperators ∈ [m, m+1]  
SURPLUS_ZONE:     prev_cooperators > m+1
```

**Step 3: Decision logic**

```
IF CRITICAL_ZONE:
    # Group is failing - I must help
    COOPERATE
    
ELIF THRESHOLD_ZONE:
    # Precarious situation - maintain stability
    IF I cooperated last round AND threshold was met:
        COOPERATE  # Don't destabilize what's working
    ELIF I defected last round AND threshold was met:
        # Consider stepping up if I've been free-riding
        IF my_cooperation_rate < (m/n):
            COOPERATE
        ELSE:
            DEFECT
    ELSE:
        COOPERATE  # Default to helping in uncertain threshold situations
        
ELIF SURPLUS_ZONE:
    # Room for some defection without risking the collective
    surplus = prev_cooperators - m
    
    IF I cooperated last round AND surplus ≥ 2:
        # I can safely take a break - others have slack
        IF my_cooperation_rate > group_cooperation_rate:
            DEFECT  # I've done my share, let others contribute
        ELSE:
            COOPERATE
    ELSE:
        COOPERATE  # Maintain reliability
```

### Final Round (Round r): Threshold-Focused

The last round has no future consequences, but collective success still matters:

```
# Estimate likely cooperators based on recent history
expected_cooperators_without_me = (average cooperators in last 3 rounds) - (1 if I usually cooperate else 0)

IF expected_cooperators_without_me < m:
    COOPERATE  # My cooperation might be pivotal
ELIF expected_cooperators_without_me >= m + 2:
    DEFECT  # Safe margin exists
ELSE:
    COOPERATE  # Close to threshold - be the safety margin
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2, m = 2 | Always COOPERATE | Both must cooperate; no free-riding possible |
| m = n-1 | Always COOPERATE | Almost everyone needed; can't risk being the defector who breaks it |
| k is very large (k > 2) | Bias toward COOPERATE | The collective reward dominates individual defection gains |
| Threshold never met in past 3 rounds | COOPERATE | Desperate situation requires commitment |
| I'm the only defector and threshold barely met | COOPERATE next round | I was free-riding on others; time to contribute |

---

## Pseudocode Summary

```python
def decide(round, my_index, n, m, k, r, history):
    
    if round == 1:
        return COOPERATE if my_index <= m + 1 else DEFECT
    
    prev_coop = count_cooperators(history, round - 1)
    my_coop_rate = my_cooperation_rate(history)
    group_coop_rate = group_cooperation_rate(history)
    i_cooperated_last = did_i_cooperate(history, round - 1)
    
    # Final round logic
    if round == r:
        expected = estimate_others_cooperation(history) 
        if expected < m:
            return COOPERATE
        elif expected >= m + 2:
            return DEFECT
        else:
            return COOPERATE
    
    # Standard rounds
    if prev_coop < m:  # Critical
        return COOPERATE
    elif prev_coop <= m + 1:  # Threshold zone
        if i_cooperated_last:
            return COOPERATE
        elif my_coop_rate < m / n:
            return COOPERATE
        else:
            return DEFECT
    else:  # Surplus zone
        surplus = prev_coop - m
        if i_cooperated_last and surplus >= 2 and my_coop_rate > group_coop_rate:
            return DEFECT
        else:
            return COOPERATE
```

---

## Why This Strategy is Collectively Aligned

1. **Threshold protection is paramount:** I never defect when cooperation is at or below the critical threshold.

2. **Fair burden sharing:** I track my own contribution rate relative to the group and step up when I've been contributing less.

3. **Stability over exploitation:** Even when I could defect safely, I maintain cooperation if it might destabilize the group.

4. **Adaptive to opponent behavior:** If others are reliable cooperators, I contribute my fair share. If others defect heavily, I still try to help meet the threshold rather than giving up.

5. **Robust to mixed populations:** Works against pure cooperators, pure defectors, and strategic players alike.
'''

description_COLLECTIVE_113 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the *exactly m* cooperators needed to secure the threshold bonus for everyone, while adapting to observed group behavior. The goal is collective success—not individual optimization at the group's expense.

## Strategic Framework

### Key Insight
The socially optimal outcome requires exactly m cooperators (threshold met, minimal sacrifice). With n identical rational agents sharing this collective mindset, each should cooperate with probability m/n to statistically achieve this. However, since opponents may not share this mindset, I must adapt based on observed behavior.

---

## Decision Rules

### Round 1: Probabilistic Cooperation
**Rule:** Cooperate with probability `m/n`

**Rationale:** Without history, this is the collectively optimal starting point. If all n players used this strategy, we'd expect exactly m cooperators on average.

---

### Rounds 2 through (r-1): Adaptive Response

**Step 1: Classify Previous Round Outcome**
- **Under-threshold:** Fewer than m cooperators (collective failure)
- **Exact-threshold:** Exactly m cooperators (collective optimum)
- **Over-threshold:** More than m cooperators (inefficient success)

**Step 2: Calculate Cooperation Rate**
Let `c_prev` = number of cooperators in previous round (excluding self)
Let `group_rate` = c_prev / (n-1)

**Step 3: Determine Cooperation Probability**

```
base_probability = m / n

IF previous round was Under-threshold:
    # Group needs more cooperators - increase my contribution likelihood
    shortfall = m - total_cooperators_prev
    urgency = shortfall / m
    cooperation_probability = min(1.0, base_probability + 0.3 * urgency + 0.1)

ELSE IF previous round was Exact-threshold:
    # Perfect outcome - maintain similar behavior
    IF I cooperated last round:
        cooperation_probability = base_probability + 0.1  # slight loyalty to cooperation
    ELSE:
        cooperation_probability = base_probability

ELSE IF previous round was Over-threshold:
    # Too many cooperators - some can safely defect
    surplus = total_cooperators_prev - m
    IF I cooperated last round AND surplus >= 1:
        # I can step back; others have it covered
        cooperation_probability = base_probability - 0.15
    ELSE:
        cooperation_probability = base_probability
```

**Step 4: Trend Adjustment**
Look at the last 3 rounds (or available history if fewer):
```
IF cooperation trend is declining (average dropping):
    cooperation_probability += 0.1  # counteract decline
IF cooperation trend is stable near threshold:
    cooperation_probability = cooperation_probability  # stay course
```

---

### Final Round (Round r): Threshold-Securing Commitment

**Rule:** Cooperate with probability `min(1.0, (m / n) + 0.2)`

**Rationale:** In the last round, there's no future to protect, but collective-minded agents should still pursue group success. A slight increase in cooperation probability helps secure the threshold when it matters most and signals commitment to collective outcomes.

---

## Edge Cases

| Situation | Response |
|-----------|----------|
| **n = m** (everyone must cooperate) | Always cooperate—defection guarantees collective failure |
| **m = 1** (only one needed) | Cooperate with probability 1/n; if no one cooperated last round, cooperate with probability 0.5 |
| **All previous rounds failed threshold** | Cooperate with probability 0.8—strong commitment to break the failure pattern |
| **I'm observing mostly defectors** | Still maintain cooperation probability ≥ m/n; someone must try |
| **k is very large** | No change—the strategy is parameter-aware through the threshold logic |
| **r = 2** (only two rounds) | Round 1: base probability; Round 2: apply final round boost |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    base_prob = m / n
    
    if round == 1:
        return cooperate_with_probability(base_prob)
    
    prev_coop_total = count_cooperators(history[round-1])
    i_cooperated_last = my_action(history[round-1]) == 'C'
    
    if round == r:  # Final round
        return cooperate_with_probability(min(1.0, base_prob + 0.2))
    
    # Adaptive middle rounds
    if prev_coop_total < m:  # Under-threshold
        shortfall = m - prev_coop_total
        prob = min(1.0, base_prob + 0.3 * (shortfall/m) + 0.1)
    elif prev_coop_total == m:  # Exact threshold
        prob = base_prob + (0.1 if i_cooperated_last else 0)
    else:  # Over-threshold
        prob = base_prob - (0.15 if i_cooperated_last else 0)
    
    # Trend adjustment
    if len(history) >= 3:
        trend = calculate_trend(history[-3:])
        if trend < 0:
            prob += 0.1
    
    return cooperate_with_probability(clamp(prob, 0.05, 0.95))
```

---

## Why This Strategy is Collectively Minded

1. **Shares the burden:** Uses probabilistic cooperation so that over time, different players take turns contributing
2. **Responds to need:** Increases cooperation when the group is failing, not when it benefits me individually
3. **Doesn't exploit success:** Doesn't aggressively defect when others cooperate—maintains baseline contribution
4. **Final round integrity:** Doesn't abandon the group in the last round despite no future consequences
5. **Robust to defectors:** Maintains cooperation floor even facing uncooperative opponents—someone must anchor the collective
'''

description_COLLECTIVE_114 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I am one of m players who must cooperate for everyone to benefit.** Rather than asking "should I cooperate?", I ask "am I one of the m players who should be cooperating right now?" The strategy uses observable history to probabilistically self-select into the cooperating group while remaining adaptive to the actual behavior of others.

---

## Strategy Overview

The strategy operates on three key principles:

1. **Probabilistic Self-Selection**: In early rounds, cooperate with probability m/n to statistically distribute cooperation burden
2. **Reputation-Based Adjustment**: Track who cooperates and adjust to fill gaps left by chronic defectors
3. **Threshold Maintenance**: Always aim to have exactly m cooperators—no more (wasteful), no fewer (catastrophic)

---

## Decision Rules

### Round 1: Probabilistic Initialization

With no history, cooperate with probability `m/n`.

```
cooperate_probability = m / n
action = C with probability cooperate_probability, else D
```

**Rationale**: If all n players use this rule, expected cooperators = m. This is the fairest starting point for collective burden-sharing.

---

### Rounds 2 through (r-1): Adaptive Core Strategy

#### Step 1: Calculate Cooperation Rates

For each player j (including self), compute:
```
coop_rate[j] = (times j played C) / (rounds played so far)
```

#### Step 2: Identify Reliable Cooperators and Defectors

```
reliable_cooperators = players with coop_rate ≥ 0.6
chronic_defectors = players with coop_rate ≤ 0.2
swing_players = everyone else
```

#### Step 3: Estimate Cooperation Gap

```
expected_cooperators = Σ coop_rate[j] for all j ≠ self
cooperation_gap = m - expected_cooperators
```

#### Step 4: Determine My Cooperation Probability

```
if cooperation_gap ≤ 0:
    # Enough expected cooperators without me
    base_probability = 0.1  # Small chance to maintain presence
    
elif cooperation_gap >= 1:
    # Definitely need more cooperators
    base_probability = min(1.0, cooperation_gap / (n - |chronic_defectors|))
    
else:
    # Marginal case: might need one more
    base_probability = cooperation_gap
```

#### Step 5: Adjust for Collective Fairness

```
my_coop_rate = coop_rate[self]
avg_coop_rate = mean(coop_rate[j] for all j)

# If I've cooperated more than average, slight reduction
# If I've cooperated less than average, slight increase
fairness_adjustment = 0.2 * (avg_coop_rate - my_coop_rate)

final_probability = clamp(base_probability + fairness_adjustment, 0.05, 0.95)
```

#### Step 6: Emergency Override

```
# If threshold was NOT met last round
if last_round_cooperators < m:
    # Increase cooperation urgently
    final_probability = min(1.0, final_probability + 0.3)

# If threshold was JUST met (exactly m cooperators)
if last_round_cooperators == m:
    # Maintain stability - don't change much
    final_probability = my_coop_rate  # Match my historical rate
```

---

### Final Round (Round r): Strategic Endgame

The last round has no future consequences, creating defection incentive. Counter this collectively:

```
if last_round_cooperators >= m in round (r-1):
    # Things were working - try to maintain
    # But expect some defection, so increase slightly
    final_probability = min(1.0, (m + 1) / n)
else:
    # Already failing - last chance
    final_probability = m / n  # Return to baseline
```

---

## Edge Cases

### Very Small Games (n ≤ 4)
```
if n <= 4:
    # Less room for statistical smoothing
    # Be more deterministic based on history
    if my_coop_rate < (m/n) - 0.1:
        action = C  # I've undercontributed
    elif my_coop_rate > (m/n) + 0.1:
        action = D  # I've overcontributed
    else:
        # Use probabilistic approach
```

### High Threshold (m > n/2)
```
if m > n/2:
    # Cooperation is critical - bias toward C
    final_probability = max(final_probability, 0.5)
```

### Low Reward (k close to 1)
```
if k < 1.5:
    # Marginal benefit - be more conservative
    final_probability *= 0.8
```

### Observing Universal Defection
```
if all players defected last round:
    # System collapse - attempt reset
    final_probability = m / n  # Signal willingness to restart
```

---

## Pseudocode Summary

```python
def decide(game_params, history, my_id):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    # Round 1
    if current_round == 1:
        return C with probability (m / n)
    
    # Calculate cooperation rates
    coop_rates = calculate_cooperation_rates(history)
    
    # Estimate gap
    expected_others = sum(coop_rates[j] for j != my_id)
    gap = m - expected_others
    
    # Base probability
    if gap <= 0:
        prob = 0.1
    elif gap >= 1:
        prob = min(1.0, gap / count_non_chronic_defectors())
    else:
        prob = gap
    
    # Fairness adjustment
    my_rate = coop_rates[my_id]
    avg_rate = mean(coop_rates)
    prob += 0.2 * (avg_rate - my_rate)
    
    # Emergency override
    if last_round_cooperators(history) < m:
        prob += 0.3
    
    # Final round adjustment
    if current_round == r:
        prob = min(1.0, (m + 1) / n)
    
    # Clamp and return
    prob = clamp(prob, 0.05, 0.95)
    return C with probability prob
```

---

## Why This Strategy is Collectively Aligned

1. **Fair Burden Sharing**: The fairness adjustment ensures no single player is exploited as "permanent cooperator"

2. **Responsive to Need**: Increases cooperation when threshold is at risk, decreases when others have it covered

3. **Forgiving but Not Naive**: Continues cooperating even when others defect (to maintain threshold), but reduces personal burden when being exploited

4. **Statistically Sound**: Probabilistic approach means a population using this strategy will naturally distribute cooperation appropriately

5. **No Exploitation**: Doesn't try to free-ride; actively fills gaps left by defectors while maintaining fairness
'''

description_COLLECTIVE_115 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume I am one of many agents running identical reasoning. My goal is not to maximize my individual payoff against arbitrary opponents, but to coordinate implicitly with like-minded agents to achieve the collective good (meeting the threshold) while being robust against defectors.

## Key Insight

If all n players use this same strategy, we need exactly m cooperators each round. The challenge is coordinating *which* m players cooperate without communication. The solution: use shared randomness derived from observable history to create implicit coordination.

---

## Strategy Specification

### Decision Rule Overview

Each round, I calculate a **cooperation probability p** and then deterministically decide based on a **hash of game state** whether I'm a designated cooperator for this round.

### Round-by-Round Logic

#### **First Round (t = 1)**

Since there's no history, use a baseline cooperation probability:

```
p_base = m / n
```

To determine if I cooperate:
- Use my player index i to create deterministic but distributed cooperation
- Cooperate if: `i ≤ m` (players 1 through m cooperate initially)

*Rationale: This ensures exactly m cooperators if all use this strategy, achieving the threshold with minimal cost.*

#### **Middle Rounds (1 < t < r)**

**Step 1: Assess previous round outcome**
- Let `c_prev` = number of cooperators last round
- Let `threshold_met` = (c_prev ≥ m)

**Step 2: Calculate cooperation target for this round**

```
if threshold_met last round:
    if c_prev == m:
        target = m  # Perfect, maintain
    elif c_prev > m:
        target = m  # Reduce waste, aim for exactly m
    
if threshold NOT met last round:
    target = min(m + 1, n)  # Increase effort slightly
```

**Step 3: Determine rotation schedule**

To distribute cooperation burden fairly among collective-minded players:

```
rotation_index = (t - 1) mod n
designated_cooperators = [(rotation_index + j) mod n for j in range(target)]
```

**Step 4: Adjust for observed defector population**

Estimate number of consistent defectors:
```
defector_estimate = n - max(c_prev over last 3 rounds)
adjusted_target = min(m + defector_estimate, n)
```

**Step 5: Final decision**

```
if my_index in designated_cooperators[:adjusted_target]:
    COOPERATE
else:
    DEFECT
```

#### **Last Round (t = r)**

Standard game theory suggests defection, but collective thinking differs:

```
if threshold was met in majority of previous rounds:
    # Trust has been established, maintain cooperation pattern
    Follow middle-round logic
else:
    # Cooperation has failed, defect to minimize losses
    DEFECT
```

---

## Pseudocode Implementation

```python
def decide(my_index, round_t, total_rounds, n, m, k, history):
    
    # history[t] = number of cooperators in round t
    
    if round_t == 1:
        # Deterministic initial distribution
        return COOPERATE if my_index < m else DEFECT
    
    # Calculate defector estimate from recent history
    recent_rounds = history[max(0, round_t-3):round_t]
    max_recent_coop = max(recent_rounds) if recent_rounds else m
    defector_estimate = max(0, n - max_recent_coop - 1)
    
    # Adjusted target accounts for non-cooperative players
    adjusted_target = min(m + defector_estimate, n)
    
    # Rotation for fairness
    rotation_offset = (round_t - 1) % n
    
    # Am I designated this round?
    my_position = (my_index - rotation_offset) % n
    designated = my_position < adjusted_target
    
    # Last round consideration
    if round_t == total_rounds:
        rounds_met = sum(1 for c in history if c >= m)
        if rounds_met < round_t // 2:
            return DEFECT
    
    return COOPERATE if designated else DEFECT
```

---

## Strategy Properties

| Property | How Addressed |
|----------|---------------|
| **Collective alignment** | Assumes identical reasoning; coordinates via shared computation |
| **Fairness** | Rotation ensures cooperation burden is distributed |
| **Robustness** | Adapts target upward when defectors detected |
| **Efficiency** | Aims for exactly m cooperators, not more |
| **Forgiveness** | Continues attempting coordination after failures |
| **Endgame stability** | Maintains cooperation if historically successful |

---

## Edge Cases

- **n = m**: Everyone must cooperate every round → Always COOPERATE
- **Very high k**: Threshold is very valuable → More aggressive cooperation
- **Persistent failure**: If threshold never met after r/2 rounds → Gradually shift toward DEFECT
- **All others defect**: Will detect this and eventually stop cooperating (can't reach m alone)
'''

description_COLLECTIVE_116 = '''
# Collective Risk Dilemma Strategy: "Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of a reliable coalition that ensures the threshold is met, while avoiding wasteful over-cooperation. The key insight is that exactly m cooperators is optimal for the group—fewer fails, more wastes contributions. I should strive to be one of those m cooperators when needed, but step back when others have it covered.

## Strategy Overview

I use a **reputation-based volunteering system** where I track each player's reliability and adjust my cooperation probability to target exactly m cooperators. I start cooperatively to establish trust and signal collective intent, then adapt based on observed behavior.

---

## Decision Rules

### Round 1: Cooperative Opening

**Rule:** Cooperate with probability `m/n`

**Rationale:** With no history, if all players independently cooperate with probability m/n, we expect exactly m cooperators on average. This is the collectively optimal starting point and signals willingness to contribute fairly.

### Rounds 2 through (r-1): Adaptive Threshold Targeting

**Step 1: Calculate Reliability Scores**

For each player j (including myself), compute:
```
reliability[j] = (times j cooperated when threshold was at risk) / (rounds where threshold was at risk)
```

A round is "at risk" if fewer than m+1 players cooperated (meaning every cooperator was essential).

For early rounds with limited data, use:
```
reliability[j] = (total cooperations by j + 1) / (rounds played + 2)  // Laplace smoothing
```

**Step 2: Rank Players by Reliability**

Sort all n players by reliability score (descending). I identify my rank position.

**Step 3: Determine Cooperation Decision**

```
IF my_rank <= m:
    // I'm among the m most reliable - I should be a core cooperator
    Cooperate
ELSE IF my_rank <= m + buffer:
    // I'm in the buffer zone - cooperate probabilistically
    // buffer = ceiling(n/4), minimum 1
    cooperation_probability = (m + buffer - my_rank + 1) / (buffer + 1)
    Cooperate with this probability
ELSE:
    // Others are more reliable - let them handle it, but stay ready
    Cooperate with probability 0.1  // Maintain minimal presence
```

**Step 4: Adjust for Recent Failures**

```
IF threshold was NOT met in previous round:
    // Emergency response - increase cooperation
    Add 0.3 to cooperation probability (cap at 0.95)
    
IF threshold was NOT met in previous 2 consecutive rounds:
    // Crisis mode - strongly cooperate
    Cooperate with probability 0.9
```

**Step 5: Adjust for Consistent Success**

```
IF threshold has been met for last 3+ rounds AND total cooperators > m + 2:
    // Over-cooperation detected - we can relax slightly
    Reduce cooperation probability by 0.1 (floor at base calculation)
```

### Final Round (Round r): Calculated Cooperation

The final round has no shadow of the future, but collective success still matters.

```
// Estimate expected cooperators based on reliability scores
expected_others_cooperating = sum(reliability[j] for j ≠ me)

IF expected_others_cooperating < m - 1:
    // Threshold unlikely even if I cooperate - defect
    Defect
ELSE IF expected_others_cooperating >= m:
    // Threshold likely met without me - defect
    Defect
ELSE:
    // I'm pivotal - my cooperation likely determines success
    Cooperate with probability 0.7
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| **m = n-1 or m = n** | Always cooperate (threshold is very demanding) |
| **m = 2** | Use base strategy but increase buffer zone |
| **r = 2** | Cooperate round 1 with prob m/n; round 2 use final round logic |
| **All others defected last round** | Cooperate (someone must try to restart cooperation) |
| **I'm the only defector and threshold met** | Continue strategy (being the lucky defector is fine if threshold met) |
| **Threshold met with exactly m cooperators including me** | Continue cooperating (I was essential) |

---

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return random() < (m / n)
    
    reliability = calculate_reliability_scores(history)
    my_rank = get_my_rank(reliability)
    buffer = max(1, ceil(n / 4))
    
    # Base probability
    if my_rank <= m:
        prob = 0.85
    elif my_rank <= m + buffer:
        prob = (m + buffer - my_rank + 1) / (buffer + 1)
    else:
        prob = 0.1
    
    # Failure adjustment
    if not threshold_met(history[-1]):
        prob = min(0.95, prob + 0.3)
    if len(history) >= 2 and not threshold_met(history[-1]) and not threshold_met(history[-2]):
        prob = 0.9
    
    # Success adjustment
    if consecutive_successes(history) >= 3 and recent_cooperators(history) > m + 2:
        prob = max(prob - 0.1, 0.2)
    
    # Final round adjustment
    if round == r:
        expected = sum(reliability[j] for j in others)
        if expected < m - 1 or expected >= m:
            prob = 0.1
        else:
            prob = 0.7
    
    return random() < prob
```

---

## Why This Strategy is Collectively Robust

1. **Fair burden sharing:** Reliability ranking ensures consistent cooperators are recognized and protected from exploitation
2. **Adaptive:** Responds to both failures (increase cooperation) and over-success (reduce waste)
3. **Self-organizing:** Without explicit coordination, this creates emergent cooperation among reliable players
4. **Forgiving:** The buffer zone and probabilistic elements allow recovery from mistakes
5. **Collective focus:** Targets exactly m cooperators rather than maximizing individual gain at group expense
'''

description_COLLECTIVE_117 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of exactly m cooperators when possible, contributing when needed but not wastefully over-contributing. The strategy balances reliability (being someone the group can count on) with efficiency (not cooperating when enough others already are).

## Key Strategic Principles

1. **Threshold-aware cooperation**: We need exactly m cooperators—no more, no fewer is optimal for the group
2. **Reputation-based role assignment**: Use observable history to implicitly coordinate who should cooperate
3. **Adaptive responsiveness**: Adjust based on whether thresholds are being met
4. **End-game stability**: Maintain cooperation incentives even in final rounds

---

## Decision Rules

### Round 1: Probabilistic Seeding

With no history, use a probability-based approach calibrated to achieve threshold:

```
cooperation_probability = (m / n) + 0.1
```

The +0.1 buffer accounts for uncertainty and ensures we're slightly more likely to meet threshold than not. This creates a slight bias toward collective success.

**Decision**: Cooperate with probability `cooperation_probability`, otherwise defect.

To make this deterministic and coordination-friendly, use player index as a pseudo-random seed:
```
if (player_index % n) < ceil(m + 0.1*n):
    cooperate
else:
    defect
```

*Note: Since we can't know our index in the tournament, use a hash of round number as seed.*

### Rounds 2 through (r-1): Adaptive Threshold Tracking

**Step 1: Calculate cooperation metrics from previous round**
```
prev_cooperators = count of players who played C in round t-1
threshold_met = (prev_cooperators >= m)
excess_cooperators = max(0, prev_cooperators - m)
deficit = max(0, m - prev_cooperators)
```

**Step 2: Calculate personal cooperation score**
```
my_cooperation_rate = (my C count in all previous rounds) / (rounds played)
```

**Step 3: Determine cooperation need**

```
if threshold_met last round:
    if excess_cooperators > 0:
        # Too many cooperators - some should defect
        # Defect if I cooperated AND there's excess
        if I_cooperated_last_round AND excess_cooperators >= 1:
            base_decision = DEFECT (give others a turn to defect)
        else:
            base_decision = maintain last action
    else:
        # Exactly m cooperators - perfect, maintain
        base_decision = maintain last action
else:
    # Threshold NOT met - we need more cooperators
    if I_defected_last_round:
        # I should step up
        base_decision = COOPERATE
    else:
        # I already cooperated, maintain and hope others join
        base_decision = COOPERATE
```

**Step 4: Fairness adjustment**

Track cumulative cooperation across all players (observable):
```
for each player j:
    cooperation_rate[j] = (player j's C count) / (rounds played)

average_rate = mean(cooperation_rate)
my_relative_burden = my_cooperation_rate - average_rate
```

```
if my_relative_burden > 0.2:
    # I've been cooperating more than average - lean toward defecting
    if base_decision == COOPERATE and threshold was met last round:
        final_decision = DEFECT
    else:
        final_decision = base_decision
elif my_relative_burden < -0.2:
    # I've been free-riding - lean toward cooperating
    if base_decision == DEFECT and threshold was NOT met last round:
        final_decision = COOPERATE
    else:
        final_decision = base_decision
else:
    final_decision = base_decision
```

### Final Round (Round r): Commitment Signal

The last round has no shadow of the future, creating defection incentives. Counter this with:

```
if threshold was met in at least 50% of previous rounds:
    # The group has been successful - reward with continued cooperation
    final_decision = same as round (r-1) decision
else:
    # Group has been failing - one last attempt to meet threshold
    if my_cooperation_rate < (m/n):
        final_decision = COOPERATE
    else:
        final_decision = DEFECT
```

---

## Complete Pseudocode

```python
def decide(round, history, game_params):
    n, r, m, k = game_params
    
    # Round 1: Probabilistic based on round number hash
    if round == 1:
        seed = hash(round) % 100
        threshold = ((m / n) + 0.1) * 100
        return COOPERATE if seed < threshold else DEFECT
    
    # Calculate history metrics
    prev_round = history[round - 1]
    prev_cooperators = count(prev_round, COOPERATE)
    threshold_met = prev_cooperators >= m
    my_prev_action = my_action(prev_round)
    
    my_coop_rate = my_cooperation_count(history) / (round - 1)
    avg_coop_rate = total_cooperations(history) / (n * (round - 1))
    burden = my_coop_rate - avg_coop_rate
    
    # Determine base decision
    if threshold_met:
        if prev_cooperators > m and my_prev_action == COOPERATE:
            base = DEFECT  # Reduce excess
        else:
            base = my_prev_action  # Maintain
    else:
        if my_prev_action == DEFECT:
            base = COOPERATE  # Step up
        else:
            base = COOPERATE  # Keep trying
    
    # Apply fairness adjustment
    if burden > 0.2 and base == COOPERATE and threshold_met:
        decision = DEFECT
    elif burden < -0.2 and base == DEFECT and not threshold_met:
        decision = COOPERATE
    else:
        decision = base
    
    # Final round adjustment
    if round == r:
        success_rate = count_threshold_met(history) / (round - 1)
        if success_rate >= 0.5:
            decision = my_prev_action
        elif my_coop_rate < (m / n):
            decision = COOPERATE
    
    return decision
```

---

## Edge Case Handling

| Scenario | Response |
|----------|----------|
| **m = n-1** (need almost everyone) | Higher base cooperation probability; less fairness-based defection |
| **m = 2** (low threshold) | More willing to defect after success; rely on others |
| **k very large** | Prioritize meeting threshold over fairness concerns |
| **k barely > 1** | More conservative; defection less costly |
| **Persistent failure** | Escalate cooperation probability each failing round |
| **All others always defect** | After 3+ failures, defect (can't meet threshold alone unless m=1) |

---

## Why This Strategy Is Collectively Optimal

1. **Self-organizing threshold**: Without explicit coordination, players naturally sort into cooperator/defector roles based on history
2. **Burden sharing**: Fairness adjustments prevent exploitation and encourage rotation
3. **Responsive**: Quickly adapts to both cooperative and hostile environments
4. **Efficient**: Aims for exactly m cooperators, not wasteful over-cooperation
5. **Robust**: Works whether opponents are cooperative, selfish, or random
'''

description_COLLECTIVE_118 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I cooperate not to maximize my individual payoff, but to help ensure the collective threshold is met. The key insight is that in a collective risk dilemma, **failing to meet the threshold hurts everyone**, so my primary goal is to be a reliable contributor who helps the group succeed, while adapting to observed behavior to avoid being exploited when cooperation is futile.

---

## Strategy Overview

I aim to be one of the `m` cooperators needed. I start cooperatively, maintain cooperation when it appears viable, and only defect when evidence strongly suggests the threshold cannot be met or when strategic defection in late rounds doesn't jeopardize collective success.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: With no history, I signal willingness to contribute. Since we need `m` cooperators and there are `n` players, I take responsibility as a potential threshold-filler.

### Rounds 2 through (r-1): Adaptive Cooperation

**Calculate two key metrics from the previous round:**
1. `prev_cooperators` = number of players who cooperated last round
2. `cooperation_rate` = prev_cooperators / n

**Decision Logic:**

```
IF prev_cooperators >= m:
    # Threshold was met - the collective succeeded
    IF prev_cooperators > m + 1:
        # Surplus cooperators exist - I can occasionally defect safely
        # But only with low probability to avoid coordination collapse
        COOPERATE with probability 0.85
        DEFECT with probability 0.15
    ELSE:
        # Threshold barely met - I'm likely essential
        COOPERATE

ELSE IF prev_cooperators >= m - 1:
    # We were close - one more cooperator (me) could tip it
    COOPERATE
    
ELSE IF prev_cooperators >= m - 2 AND rounds_remaining > 2:
    # We're slightly short but there's time to build momentum
    COOPERATE
    
ELSE:
    # Cooperation appears to be collapsing
    # Check if there's a recovery trend
    IF cooperation is trending upward over last 3 rounds:
        COOPERATE
    ELSE:
        DEFECT
```

### Last Round (Round r): Threshold-Focused Decision

The last round requires special handling since there's no future to influence:

```
IF historical_cooperation_rate >= m/n:
    # Group has generally been cooperative
    # Be a reliable cooperator to help meet threshold
    COOPERATE
    
ELSE IF prev_cooperators >= m - 1:
    # Close to threshold - my cooperation could be pivotal
    COOPERATE
    
ELSE:
    # Threshold unlikely to be met regardless
    DEFECT
```

---

## Pseudocode Implementation

```python
def decide(n, m, k, r, current_round, history):
    """
    history: list of lists, history[t] = actions of all n players in round t
             actions encoded as 1 (cooperate) or 0 (defect)
    """
    
    # Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Calculate metrics
    prev_round = history[current_round - 2]  # 0-indexed
    prev_cooperators = sum(prev_round)
    
    # Calculate cooperation trend (if enough history)
    if current_round >= 4:
        recent_coop = [sum(history[t]) for t in range(current_round - 4, current_round - 1)]
        trend = recent_coop[-1] - recent_coop[0]  # positive = improving
    else:
        trend = 0
    
    # Historical cooperation rate
    all_coop_counts = [sum(h) for h in history[:current_round-1]]
    avg_cooperators = sum(all_coop_counts) / len(all_coop_counts)
    
    rounds_remaining = r - current_round
    
    # Last round logic
    if current_round == r:
        if avg_cooperators >= m - 0.5:
            return COOPERATE
        elif prev_cooperators >= m - 1:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    if prev_cooperators >= m:
        # Threshold met
        if prev_cooperators > m + 1:
            # Some slack exists - small chance to defect
            return COOPERATE if random() < 0.85 else DEFECT
        else:
            return COOPERATE
    
    elif prev_cooperators >= m - 1:
        # One short - I could be the difference
        return COOPERATE
    
    elif prev_cooperators >= m - 2 and rounds_remaining > 2:
        # Slightly short but recoverable
        return COOPERATE
    
    else:
        # Significant shortfall
        if trend > 0:
            # Cooperation is recovering
            return COOPERATE
        else:
            return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| First round | COOPERATE | Establish cooperative intent |
| Last round, group cooperative | COOPERATE | Help ensure threshold |
| Last round, group defecting | DEFECT | Threshold unreachable |
| Exactly m cooperators last round | COOPERATE | I'm likely essential |
| Large surplus (>m+1) | COOPERATE (85%) | Maintain stability with minor free-riding |
| Collapse (cooperators << m) | DEFECT (unless trend up) | Conserve when futile |
| n = m (all must cooperate) | Always COOPERATE | Everyone is essential |
| m = 2 (low threshold) | Follow standard rules | Threshold easily met |

---

## Collective Alignment

This strategy embodies collective thinking because:

1. **I volunteer first**: Round 1 cooperation shows I'm willing to be one of the essential `m`
2. **I stay when needed**: If we're at or near threshold, I maintain cooperation
3. **I don't abandon ship early**: I give the group chances to recover
4. **I only defect when cooperation is futile**: Not to maximize personal gain, but because contributing to a lost cause helps no one
5. **Limited free-riding**: Even with surplus cooperators, I mostly cooperate to maintain group stability

The strategy prioritizes **collective success over individual optimization**, while remaining adaptive to prevent exploitation in truly uncooperative environments.
'''

description_COLLECTIVE_119 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I view myself as part of a group trying to achieve the threshold, not as an individual maximizing personal gain. The key insight is that **exactly m cooperators is optimal for the group** - it secures the bonus while minimizing total contribution costs. My role is to be a reliable cooperator when needed, but step back when others are filling that role.

## Strategy Overview

I aim to be a "threshold guardian" - someone who cooperates to help reach the threshold when it's at risk, but defects when cooperation is unnecessary or futile. The strategy adapts based on observed cooperation patterns in the population.

---

## Decision Rules

### Round 1: Probabilistic Seeding

With no history, I cooperate with probability `m/n`.

**Rationale:** If all players independently cooperate with probability m/n, the expected number of cooperators equals the threshold. This is the collectively rational starting point - it signals willingness to cooperate without over-committing.

---

### Rounds 2 through (r-1): Adaptive Response

Let `c_prev` = number of cooperators in the previous round.

**Rule 1: Threshold Maintenance**
- If `c_prev == m`: I replicate my previous action
  - *Rationale: The threshold was exactly met. If I cooperated, I was essential. If I defected, we didn't need me.*

**Rule 2: Under-Cooperation Response**
- If `c_prev < m`: I cooperate with probability `min(1, (m - c_prev + 1) / (n - c_prev))`
  - *Rationale: We need more cooperators. I increase my cooperation probability proportional to how much help is needed, distributed across current defectors.*

**Rule 3: Over-Cooperation Response**
- If `c_prev > m`: I defect if I cooperated last round, with probability `(c_prev - m) / c_prev`
  - If I defected last round: I continue defecting
  - *Rationale: Too many are cooperating - some can safely step back. This creates space for others while maintaining threshold.*

**Rule 4: Cooperation Momentum Tracking**

I track a "reliability score" over a 3-round sliding window:
- `reliability = (cooperators in last 3 rounds) / (3 * m)`

Adjustments:
- If `reliability > 1.2`: I'm more willing to defect (others are reliably cooperating)
- If `reliability < 0.8`: I'm more willing to cooperate (cooperation is fragile)

This modifier adjusts my base probabilities by ±20%.

---

### Final Round (Round r): Threshold-Focused

The last round requires special handling since there's no future to influence.

- If historical average cooperators ≥ m: I defect (bet on maintained cooperation)
- If historical average cooperators < m but ≥ m-1: I cooperate (my contribution likely tips the balance)
- If historical average cooperators < m-1: I defect (threshold unlikely regardless)

---

## Pseudocode

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        return COOPERATE with probability m/n
    
    c_prev = count_cooperators(history[round-1])
    my_prev_action = my_action(history[round-1])
    
    # Calculate reliability from recent history
    window = min(3, round-1)
    recent_coop = sum(count_cooperators(history[round-i]) for i in 1..window)
    reliability = recent_coop / (window * m)
    reliability_modifier = 0.2 * (reliability - 1.0)  # ranges roughly -0.2 to +0.2
    
    if round == r:  # Final round
        avg_coop = average_cooperators(history)
        if avg_coop >= m:
            return DEFECT
        elif avg_coop >= m - 1:
            return COOPERATE
        else:
            return DEFECT
    
    # Main adaptive logic
    if c_prev == m:
        return my_prev_action
    
    elif c_prev < m:
        base_prob = min(1, (m - c_prev + 1) / (n - c_prev))
        prob = min(1, base_prob + reliability_modifier)
        return COOPERATE with probability prob
    
    else:  # c_prev > m
        if my_prev_action == DEFECT:
            return DEFECT
        else:
            base_prob = (c_prev - m) / c_prev  # probability of defecting
            prob = min(1, base_prob - reliability_modifier)
            return DEFECT with probability prob
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| m = n-1 (almost all must cooperate) | Cooperate more aggressively | Each defection is nearly fatal |
| m = 2 (low threshold) | Follow base strategy but lean toward defection | Easy to meet threshold |
| k is very large | Standard strategy (incentives already aligned) | Bonus dominates regardless |
| Everyone defected last round | Cooperate with probability m/n (reset) | Attempt to restart cooperation |
| Everyone cooperated last round | Defect with probability (n-m)/n | Create space for efficient threshold |

---

## Why This Strategy is Collectively Robust

1. **Self-organizing to threshold:** The strategy naturally pushes toward exactly m cooperators through complementary responses.

2. **No exploitation of predictability:** Probabilistic decisions prevent pure defectors from free-riding on a deterministic cooperator.

3. **Graceful degradation:** If others are unreliable, I increase cooperation; if they're over-cooperating, I step back - the group self-balances.

4. **History-sensitive but not punitive:** I don't "punish" defectors; I simply adapt to the cooperation landscape. This avoids destructive retaliation spirals.

5. **Threshold-focused, not score-focused:** My decisions optimize for meeting the collective threshold, trusting that this produces good outcomes for everyone including myself.
'''

description_COLLECTIVE_120 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I assume I am one of exactly m cooperators needed to meet the threshold, and I act to make collective success robust.** The strategy balances reliability (being someone others can count on) with adaptability (responding to observed behavior to avoid exploitation or coordinate better).

## Decision Framework

### Key Variables Tracked
- `cooperation_rate`: Fraction of all players who cooperated in previous round
- `threshold_met_history`: Boolean list of whether threshold was met each round
- `my_cooperation_history`: My own action history
- `rounds_remaining`: r - current_round

### Decision Rules

#### Round 1: Conditional Cooperation Based on Parameters

**Cooperate if** the game structure favors collective action:
- If `k ≥ 1.5` (reward is substantial), **Cooperate**
- If `m/n ≤ 0.5` (only minority needed), **Cooperate**
- If `m/n > 0.5` AND `k < 1.5`, **Cooperate with probability m/n**

*Rationale: In round 1, I signal willingness to be part of the solution. If parameters suggest cooperation is viable, I commit. This establishes me as a reliable potential cooperator.*

#### Middle Rounds (2 to r-1): Adaptive Response

**Primary Rule - Threshold Tracking:**

1. **If threshold was met last round:**
   - If I cooperated: **Continue Cooperating** (I'm part of a working coalition)
   - If I defected AND exactly m cooperated: **Cooperate** (I was free-riding on a fragile coalition; become reliable)
   - If I defected AND more than m cooperated: **Defect** (surplus exists; stay course)

2. **If threshold was NOT met last round:**
   - Count cooperators last round as `c_prev`
   - If `c_prev ≥ m - 1` (we were close): **Cooperate** (be the additional cooperator needed)
   - If `c_prev < m - 1` (far from threshold): 
     - If I cooperated: **Defect for 1 round** (signal that non-cooperation has consequences)
     - If I defected: **Cooperate** (try to rebuild coalition)

**Secondary Rule - Trend Response:**

If threshold has been met for 3+ consecutive rounds:
- Calculate `surplus = average_cooperators - m`
- If `surplus ≥ 2` AND I've been cooperating: **Defect once** (test if I'm needed)
- If I defected and threshold still met: **Continue defecting** (let others carry load)
- If I defected and threshold failed: **Immediately return to Cooperating**

#### Final Round (round r): Strategic Calculation

The final round removes shadow of future punishment. Apply modified logic:

- If `k ≥ 2`: **Cooperate** (reward justifies contribution even with defection risk)
- If threshold has been consistently met (≥70% of rounds): **Cooperate** (trust established coalition)
- If I've been a consistent cooperator (≥70% of my rounds): **Cooperate** (maintain identity)
- Otherwise: **Defect** (insufficient trust or reward)

## Pseudocode

```
function decide(round, history, params):
    n, r, m, k = params
    
    # Round 1
    if round == 1:
        if k >= 1.5 or m/n <= 0.5:
            return COOPERATE
        else:
            return COOPERATE with probability m/n
    
    # Extract history data
    last_round = history[round - 1]
    cooperators_last = count(last_round.actions == C)
    threshold_met_last = cooperators_last >= m
    i_cooperated_last = last_round.my_action == C
    
    # Final round
    if round == r:
        threshold_success_rate = count(threshold_met_history) / (round - 1)
        my_cooperation_rate = count(my_cooperations) / (round - 1)
        if k >= 2 or threshold_success_rate >= 0.7 or my_cooperation_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if threshold_met_last:
        if i_cooperated_last:
            return COOPERATE
        elif cooperators_last == m:
            return COOPERATE  # Join fragile coalition
        else:
            return DEFECT  # Surplus exists
    else:  # Threshold not met
        if cooperators_last >= m - 1:
            return COOPERATE  # Be the tipping point
        elif i_cooperated_last:
            return DEFECT  # One-round punishment
        else:
            return COOPERATE  # Try to rebuild
```

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2, m = 2 | Always Cooperate | Both needed; no free-riding possible |
| m = n - 1 | Cooperate (high commitment) | Almost everyone needed; be reliable |
| Very high k (≥3) | Strong bias to Cooperate | Reward justifies risk |
| Very low k (<1.2) | Lower cooperation threshold | Less worth sacrificing for |
| r = 2 (minimal rounds) | Cooperate both rounds | No time for complex adaptation |
| Persistent failure (>50% rounds failed) | Cooperate more | Someone must break the cycle |

## Why This Strategy is Collectively-Minded

1. **Assumes responsibility**: I act as if I'm one of the m needed, not waiting for others
2. **Stabilizes coalitions**: When threshold is barely met, I join rather than exploit
3. **Forgives and rebuilds**: After failures, I try cooperation rather than permanent defection
4. **Signals clearly**: My patterns are interpretable by other adaptive strategies
5. **Sacrifices optimally**: I accept being a cooperator when surplus exists if it maintains reliability for future rounds
'''

description_COLLECTIVE_121 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I should cooperate when my cooperation is likely *needed* to reach the threshold, and defect when cooperation is either redundant (threshold already met by others) or futile (threshold unreachable regardless). The goal is to maximize collective success while being robust to exploitation.

## Strategy Overview

The strategy operates on three principles:
1. **Be a reliable cooperator early** to establish collective momentum
2. **Adapt based on observed cooperation rates** to match the group's apparent norms
3. **Protect the threshold** by cooperating when the collective is close but at risk

---

## Decision Rules

### Round 1: Cooperative Start
**Action: COOPERATE**

Rationale: With no history, I assume others may share collective goals. Starting with cooperation signals willingness to contribute and helps establish whether the group can coordinate.

### Rounds 2 through (r-1): Adaptive Middle Game

Calculate the following from history:
- `coop_rate` = (total cooperations by all players) / (total actions taken)
- `threshold_met_rate` = (rounds where ≥m cooperated) / (rounds played)
- `last_round_cooperators` = count of cooperators in most recent round

**Decision Logic:**

```
IF last_round_cooperators >= m:
    # Threshold was met - assess if I'm needed
    IF last_round_cooperators == m AND I cooperated last round:
        # I was pivotal - continue cooperating
        COOPERATE
    ELSE IF last_round_cooperators > m + 1 AND I cooperated last round:
        # Surplus cooperators - probabilistically defect to avoid exploitation
        COOPERATE with probability (m / last_round_cooperators)
    ELSE:
        # Match the group's cooperation tendency
        COOPERATE with probability min(coop_rate + 0.1, 1.0)

ELSE IF last_round_cooperators < m:
    # Threshold was missed
    IF last_round_cooperators >= m - 2:
        # Close to threshold - try harder
        COOPERATE
    ELSE IF threshold_met_rate < 0.3 AND rounds_played >= 3:
        # Group appears uncooperative - reduce cooperation
        COOPERATE with probability max(m/n, 0.3)
    ELSE:
        # Give benefit of doubt early, try to rally
        COOPERATE
```

### Final Round (Round r): Threshold Protection

The last round has no future shadow, so purely strategic calculation:

```
# Estimate expected cooperators (excluding self) based on recent pattern
expected_others = (last 3 rounds average cooperators) - (1 if I cooperated in majority of last 3 rounds else 0)

IF expected_others >= m:
    # Threshold likely met without me - defect for maximum payoff
    DEFECT
ELSE IF expected_others == m - 1:
    # I am likely pivotal
    IF k > 1:  # Cooperation payoff (k) vs defection payoff (1+k if threshold met, 1 if not)
        # My cooperation: I get k
        # My defection: I get 1 (threshold missed)
        # Since k > 1, COOPERATE
        COOPERATE
    ELSE:
        DEFECT
ELSE IF expected_others < m - 1:
    # Threshold unreachable even with my cooperation
    DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2, m = 2 | Always COOPERATE (rounds 1 to r-1); round r: COOPERATE if partner cooperated >50% of time | Both players needed; must trust |
| m = n-1 or m = n | COOPERATE unless clear evidence of mass defection | Nearly everyone needed; commit fully |
| m very small (m ≤ n/3) | Use base cooperation probability of m/n | Avoid over-contributing when few needed |
| k very large (k > 3) | Increase cooperation probability by 20% | High collective reward justifies risk |
| All others defected last round | COOPERATE once more, then match if pattern continues | One forgiveness, then adapt |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return COOPERATE
    
    coop_rate = total_cooperations(history) / total_actions(history)
    last_coops = cooperators_in_round(history, round - 1)
    threshold_met_rate = rounds_threshold_met(history) / (round - 1)
    my_last_action = my_action_in_round(history, round - 1)
    
    if round == r:  # Final round
        expected_others = estimate_others_cooperation(history)
        if expected_others >= m:
            return DEFECT
        elif expected_others == m - 1:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if last_coops >= m:
        if last_coops == m and my_last_action == COOPERATE:
            return COOPERATE
        elif last_coops > m + 1 and my_last_action == COOPERATE:
            return COOPERATE with probability (m / last_coops)
        else:
            return COOPERATE with probability min(coop_rate + 0.1, 1.0)
    else:
        if last_coops >= m - 2:
            return COOPERATE
        elif threshold_met_rate < 0.3 and round >= 4:
            return COOPERATE with probability max(m/n, 0.3)
        else:
            return COOPERATE
```

---

## Why This Strategy is Collectively Minded

1. **Starts cooperatively** - Gives the group a chance to succeed together
2. **Protects the threshold** - Prioritizes collective success over individual gain
3. **Avoids wasteful over-cooperation** - Doesn't contribute when unnecessary
4. **Forgives occasional defection** - Allows for recovery from coordination failures
5. **Adapts to group behavior** - Matches cooperative groups, protects against exploitative ones
'''

description_COLLECTIVE_122 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be one of the *m* cooperators needed, but not redundantly so. The goal is to ensure the threshold is met while minimizing exploitation. I treat cooperation as a shared responsibility and adapt my contribution based on whether the collective is pulling its weight.

## Strategy Overview

The strategy operates on three principles:
1. **Be willing to be essential** - Default toward cooperation when the group needs contributors
2. **Don't be a redundant sucker** - Avoid cooperating when enough others already are
3. **Respond to group behavior** - Increase cooperation when the group cooperates, withdraw when exploited

---

## Decision Rules

### Round 1: Probabilistic Cooperation

With no history, cooperate with probability `m/n`.

**Rationale:** If all players use this probability, expected cooperators = m, giving the group a fair chance at coordination. This is the collectively rational starting point.

```
p_initial = m / n
cooperate if random() < p_initial
```

### Rounds 2 through r-1: Adaptive Response

Calculate two key metrics from the previous round:

1. **Cooperation count (c_prev):** How many players cooperated last round
2. **Threshold met:** Was c_prev ≥ m?

**Decision logic:**

```
IF threshold was met last round (c_prev >= m):
    IF c_prev == m:
        # Exactly at threshold - maintain cooperation if I was part of it
        cooperate if I_cooperated_last_round
    ELSE IF c_prev > m:
        # Surplus cooperators - probabilistically step back
        IF I_cooperated_last_round:
            cooperate with probability m / c_prev
        ELSE:
            # I was a free-rider; offer to rotate in
            cooperate with probability (c_prev - m) / (n - c_prev)
            
ELSE (threshold NOT met, c_prev < m):
    # Collective failure - we need more cooperators
    shortfall = m - c_prev
    non_cooperators_last = n - c_prev
    
    IF I_cooperated_last_round:
        # Stay loyal, but not indefinitely exploited
        cooperate (maintain commitment)
    ELSE:
        # I was part of the problem - step up with probability proportional to need
        cooperate with probability shortfall / non_cooperators_last
```

### Last Round (Round r): Threshold-Seeking Cooperation

The last round has no shadow of the future, but collective success still matters.

```
# Estimate expected cooperators based on recent cooperation rate
recent_coop_rate = (cooperators in last 3 rounds) / (3 * n)
expected_others_cooperating = recent_coop_rate * (n - 1)

IF expected_others_cooperating >= m:
    # Threshold likely met without me
    defect
ELSE IF expected_others_cooperating >= m - 1:
    # I might be pivotal
    cooperate with probability 0.7
ELSE:
    # Unlikely to meet threshold regardless
    cooperate with probability m / n  # Maintain baseline collective spirit
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| **m = n-1 or m = n** | Cooperate with high probability (~0.8) - near-universal cooperation needed |
| **m = 2** | Use stricter reciprocity - only cooperate if at least one other cooperated last round |
| **r = 2** | Treat round 1 normally; round 2 as last-round logic |
| **Threshold never met in 3+ rounds** | Increase cooperation probability by 0.1 (desperation cooperation) |
| **Threshold met every round** | Maintain current behavior - system is working |
| **I've cooperated 3+ times while threshold failed** | Cap cooperation probability at 0.5 - avoid chronic exploitation |

---

## Pseudocode Summary

```python
def decide(round, history, my_history, params):
    n, r, m, k = params
    
    if round == 1:
        return cooperate_with_prob(m / n)
    
    c_prev = count_cooperators(history[-1])
    I_cooperated = my_history[-1] == 'C'
    
    if round == r:  # Last round
        return last_round_logic(history, params)
    
    if c_prev >= m:  # Threshold met
        if c_prev == m:
            return I_cooperated
        else:  # Surplus
            if I_cooperated:
                return cooperate_with_prob(m / c_prev)
            else:
                return cooperate_with_prob((c_prev - m) / (n - c_prev))
    else:  # Threshold failed
        if I_cooperated:
            return True  # Stay loyal
        else:
            shortfall = m - c_prev
            return cooperate_with_prob(shortfall / (n - c_prev))
```

---

## Why This Strategy is Collectively Aligned

1. **Fair burden-sharing:** The probabilistic rotation ensures no single player bears disproportionate cost
2. **Responsive to group needs:** Increases cooperation when threshold fails, relaxes when there's surplus
3. **Not exploitable:** Cooperators who are consistently let down will eventually reduce contribution
4. **Bootstraps coordination:** The initial m/n probability gives the collective a fair starting point without requiring external coordination
'''

description_COLLECTIVE_123 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I act as if I'm one of many copies of the same strategy trying to achieve the best collective outcome. The key insight is that exactly m cooperators is optimal for the group (threshold met, minimum sacrifice), so I should probabilistically coordinate to target that number based on observable signals.

## Strategy Overview

I use a **history-based probabilistic cooperation** approach that:
1. Starts with a cooperation probability calibrated to achieve exactly m cooperators in expectation
2. Adjusts based on observed cooperation levels to maintain threshold achievement
3. Accounts for end-game incentives while preserving collective welfare

---

## Decision Rules

### Round 1: Baseline Probabilistic Cooperation

With no history, cooperate with probability:

```
p_base = m / n
```

This is the collectively optimal probability—if all n players use this, expected cooperators = m.

### Rounds 2 through (r-1): Adaptive Cooperation

**Step 1: Observe previous round**
- Let `c_prev` = number of cooperators in the previous round
- Let `threshold_met` = (c_prev ≥ m)

**Step 2: Calculate cooperation probability**

```
if c_prev < m:
    # Threshold was missed - increase cooperation
    shortfall = m - c_prev
    p_cooperate = min(1.0, p_base + (shortfall / n) * 0.5)
    
elif c_prev == m:
    # Perfect efficiency achieved - maintain
    p_cooperate = p_base
    
elif c_prev > m:
    # Over-cooperation - slight reduction to improve efficiency
    excess = c_prev - m
    p_cooperate = max(0.1, p_base - (excess / n) * 0.3)
```

**Step 3: Reputation adjustment**

Track cooperation rate across all observed history:
```
global_coop_rate = total_cooperations / (total_rounds_played * n)

if global_coop_rate < m/n - 0.1:
    # Others are under-cooperating - compensate slightly
    p_cooperate = min(1.0, p_cooperate + 0.1)
elif global_coop_rate > m/n + 0.2:
    # Others are over-cooperating - can reduce
    p_cooperate = max(0.1, p_cooperate - 0.05)
```

### Final Round (Round r): Conditional Cooperation

The last round has no future consequences, creating defection incentives. However, maintaining collective success matters:

```
if historical_threshold_success_rate >= 0.7:
    # Group has been cooperative - maintain trust
    p_cooperate = p_base
else:
    # Group has been unreliable - protect self slightly
    p_cooperate = max(0.2, p_base - 0.1)
```

---

## Edge Case Handling

### Edge Case 1: m very close to n (m ≥ n-1)
When nearly everyone must cooperate:
```
if m >= n - 1:
    p_cooperate = min(1.0, p_base + 0.15)  # Bias toward cooperation
```

### Edge Case 2: m very small (m ≤ 2)
When few cooperators needed:
```
if m <= 2:
    # Risk of everyone free-riding; stick closer to base rate
    p_cooperate = p_base  # No adjustment
```

### Edge Case 3: Very few rounds (r ≤ 3)
Less time to adapt:
```
if r <= 3:
    # Be slightly more cooperative to ensure threshold achievement
    p_cooperate = min(1.0, p_cooperate + 0.1)
```

### Edge Case 4: Large k (k ≥ 3)
High reward makes threshold achievement critical:
```
if k >= 3:
    p_cooperate = min(1.0, p_cooperate + 0.1)
```

---

## Complete Pseudocode

```
function decide(game_params, history):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    p_base = m / n
    
    if current_round == 1:
        p_cooperate = p_base
    else:
        # Get previous round data
        c_prev = count_cooperators(history[-1])
        
        # Base adjustment from previous round
        if c_prev < m:
            p_cooperate = min(1.0, p_base + ((m - c_prev) / n) * 0.5)
        elif c_prev == m:
            p_cooperate = p_base
        else:
            p_cooperate = max(0.1, p_base - ((c_prev - m) / n) * 0.3)
        
        # Global reputation adjustment
        global_coop_rate = total_cooperations(history) / (len(history) * n)
        if global_coop_rate < (m/n) - 0.1:
            p_cooperate = min(1.0, p_cooperate + 0.1)
        elif global_coop_rate > (m/n) + 0.2:
            p_cooperate = max(0.1, p_cooperate - 0.05)
        
        # Final round adjustment
        if current_round == r:
            success_rate = threshold_successes(history) / len(history)
            if success_rate < 0.7:
                p_cooperate = max(0.2, p_cooperate - 0.1)
    
    # Edge case adjustments
    if m >= n - 1:
        p_cooperate = min(1.0, p_cooperate + 0.15)
    if k >= 3:
        p_cooperate = min(1.0, p_cooperate + 0.1)
    if r <= 3:
        p_cooperate = min(1.0, p_cooperate + 0.1)
    
    # Final decision
    return COOPERATE if random() < p_cooperate else DEFECT
```

---

## Why This Strategy Is Collectively Optimal

1. **Self-coordination**: By using p = m/n as the baseline, copies of this strategy naturally achieve the threshold without over-cooperating.

2. **Adaptive resilience**: Adjusts to both under-cooperation (increases own contribution) and over-cooperation (reduces waste).

3. **Robust to defectors**: The compensation mechanism means a few pure defectors don't cause threshold failure.

4. **Efficient**: Aims for exactly m cooperators, maximizing collective payoff per cooperation cost.

5. **No exploitation**: Doesn't purely free-ride, maintaining group welfare even against cooperative opponents.
'''

description_COLLECTIVE_124 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I aim to be one of exactly m cooperators when possible, contributing when needed but not wastefully over-contributing.** The goal is to reliably meet the threshold while minimizing unnecessary sacrifice, adapting to observed group behavior patterns.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic fairness**: In early rounds, cooperate with probability that would yield exactly m cooperators if everyone used this strategy
2. **Responsive adaptation**: Adjust cooperation likelihood based on observed group cooperation rates
3. **Threshold insurance**: Increase cooperation probability when the group appears at risk of falling short

---

## Decision Rules

### Round 1: Baseline Probabilistic Cooperation

With no history, cooperate with probability:

```
p_base = m / n
```

This ensures that in expectation, exactly m players cooperate if all players use this strategy.

**Decision**: Generate random number r ∈ [0,1]. Cooperate if r < p_base.

---

### Rounds 2 through (r-1): Adaptive Cooperation

**Step 1: Calculate observed cooperation rate**
```
obs_rate = (total cooperations in all previous rounds) / (n × rounds_played)
```

**Step 2: Estimate cooperation shortfall/surplus**
```
target_rate = m / n
gap = target_rate - obs_rate
```

**Step 3: Calculate adaptive cooperation probability**
```
p_adaptive = p_base + (gap × adjustment_factor)
adjustment_factor = 1.5  # Moderately responsive

# Bound probability to [0.1, 0.9] to maintain unpredictability
p_round = clamp(p_adaptive, 0.1, 0.9)
```

**Step 4: Apply threshold emergency boost**

If in the previous round, cooperators < m (threshold was missed):
```
p_round = min(p_round + 0.2, 0.95)
```

**Step 5: Apply free-rider deterrence**

Track individual player histories. If I cooperated last round AND threshold was met AND I could have defected without breaking threshold:
```
p_round = max(p_round - 0.15, p_base × 0.5)
```
This prevents being exploited as a reliable cooperator while others free-ride.

**Decision**: Cooperate if random() < p_round

---

### Final Round (Round r): Threshold-Focused Decision

The last round requires special handling since there's no future to influence.

**Calculate**: Expected cooperators if I defect
```
expected_others = (n-1) × obs_rate_recent  # Use last 3 rounds or available history
```

**Decision Rule**:
- If expected_others < m - 0.5: **Cooperate** (my contribution likely needed)
- If expected_others > m + 1: **Defect** (surplus expected, can free-ride)
- Otherwise: Cooperate with probability `(m - expected_others + 1) / 2`, clamped to [0.3, 0.8]

---

## Edge Case Handling

### Very Small Groups (n ≤ 4)
Increase base cooperation probability slightly:
```
p_base = min((m / n) + 0.1, 0.8)
```
Small groups need more reliability.

### High Threshold (m > n/2)
When majority cooperation is needed, be more cooperative:
```
p_base = (m / n) + 0.05
```

### Short Games (r ≤ 3)
Less time to adapt; weight toward cooperation:
```
p_round = p_round + 0.1 for all rounds
```

### Consistent Group Failure
If threshold missed for 3+ consecutive rounds:
```
p_round = min(p_round + 0.3, 0.9)  # Emergency cooperation mode
```

---

## Pseudocode Summary

```
function decide(game_params, history):
    n, r, m, k = game_params
    current_round = len(history) + 1
    p_base = m / n
    
    if current_round == 1:
        return cooperate_with_probability(p_base)
    
    obs_rate = calculate_cooperation_rate(history)
    gap = (m/n) - obs_rate
    p_round = clamp(p_base + 1.5 × gap, 0.1, 0.9)
    
    if last_round_missed_threshold(history):
        p_round = min(p_round + 0.2, 0.95)
    
    if was_exploited_last_round(history, m):
        p_round = max(p_round - 0.15, p_base × 0.5)
    
    if current_round == r:  # Final round
        expected_others = estimate_others_cooperation(history, n)
        if expected_others < m - 0.5:
            return COOPERATE
        elif expected_others > m + 1:
            return DEFECT
        else:
            p_round = clamp((m - expected_others + 1) / 2, 0.3, 0.8)
    
    return cooperate_with_probability(p_round)
```

---

## Why This Strategy is Collectively Robust

1. **Fair burden-sharing**: Probabilistic cooperation distributes the cost of meeting thresholds across all players over time
2. **Self-correcting**: Automatically increases cooperation when group is falling short
3. **Exploitation-resistant**: Reduces cooperation when being taken advantage of
4. **Threshold-focused**: Aims for exactly m cooperators—not wasteful over-cooperation
5. **Adaptive**: Works against cooperative, selfish, or mixed opponent populations
6. **No coordination assumed**: Functions independently while still producing good collective outcomes when others use similar reasoning
'''

description_COLLECTIVE_125 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of the minimum viable coalition that secures the collective reward, while adapting to observed behavior to maintain cooperation without being exploited. The key insight is that exactly m cooperators is optimal for the group—fewer fails, more wastes contributions.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to achieve exactly m cooperators in expectation, combined with **responsive adjustment** based on observed cooperation levels.

---

## Decision Rules

### Round 1: Baseline Cooperation

**Cooperate with probability p₀ = m/n**

Rationale: If all n players use this probability, expected cooperators = n × (m/n) = m, exactly meeting the threshold. This is the collectively rational starting point.

### Rounds 2 through r-1: Adaptive Response

Calculate cooperation probability based on previous round outcomes:

```
Let c_prev = number of cooperators in previous round

If c_prev < m (threshold NOT met):
    # Collective failure - increase cooperation effort
    p = min(1.0, base_p + recovery_boost)
    where recovery_boost = (m - c_prev) / n × 1.5

Else if c_prev == m (exactly at threshold):
    # Perfect collective outcome - maintain
    p = base_p

Else if c_prev > m (excess cooperation):
    # Wasteful - some should defect
    p = max(0.1, base_p - (c_prev - m) / n × 0.5)

where base_p = m/n adjusted by cooperation_trend
```

**Cooperation Trend Adjustment:**
```
cooperation_trend = (avg cooperation over last 3 rounds) - m
base_p = m/n - cooperation_trend × 0.2
```

This creates a self-correcting system: if others cooperate more, I can cooperate less (and vice versa), steering toward exactly m cooperators.

### Last Round (Round r): Modified Calculation

The last round has no future consequences, creating defection incentives. However, maintaining collective success matters:

```
If cooperation_rate_history >= 0.7:
    # Cooperative environment - maintain cooperation
    p = base_p × 0.9  # Slight reduction acknowledging endgame

Else:
    # Uncooperative environment - still try to meet threshold
    p = m/n  # Return to baseline, don't abandon collective
```

---

## Handling Edge Cases

### First Round
- Use p₀ = m/n (no history available)
- This is a Schelling point that collectively rational agents might converge on

### After Collective Failure (c_prev < m)
- Boost cooperation probability significantly
- The boost is proportional to how far below threshold we fell
- Cap at p = 1.0 (certain cooperation) if repeatedly failing

### After Extreme Success (c_prev >> m)
- Reduce cooperation to avoid waste
- Never drop below p = 0.1 (maintain some cooperative presence)
- This prevents race-to-bottom dynamics

### Detecting Chronic Defection
```
If avg_cooperation over last 5 rounds < m/2:
    # Environment is hostile
    # Still cooperate at reduced rate to signal willingness
    p = max(0.2, m/(2n))
```

---

## Pseudocode Implementation

```python
def decide(game_params, history):
    n, r, m, k = game_params
    current_round = len(history) + 1
    base_p = m / n
    
    if current_round == 1:
        return cooperate_with_probability(base_p)
    
    # Analyze history
    c_prev = count_cooperators(history[-1])
    recent_avg = average_cooperators(history[-3:]) if len(history) >= 3 else c_prev
    
    # Calculate trend adjustment
    trend = (recent_avg - m) / n
    adjusted_base = base_p - trend * 0.2
    adjusted_base = clamp(adjusted_base, 0.1, 0.9)
    
    # Respond to previous round
    if c_prev < m:
        # Failure recovery
        shortfall = (m - c_prev) / n
        p = min(1.0, adjusted_base + shortfall * 1.5)
    elif c_prev == m:
        # Perfect - maintain
        p = adjusted_base
    else:
        # Excess - reduce
        excess = (c_prev - m) / n
        p = max(0.1, adjusted_base - excess * 0.5)
    
    # Last round adjustment
    if current_round == r:
        overall_success_rate = rounds_threshold_met(history) / len(history)
        if overall_success_rate < 0.5:
            p = base_p  # Reset to baseline for final attempt
        else:
            p = p * 0.9  # Slight endgame reduction
    
    return cooperate_with_probability(p)
```

---

## Why This Strategy is Collectively Aligned

1. **Targets optimal threshold**: Aims for exactly m cooperators, not maximum cooperation
2. **Self-sacrificing when needed**: Increases cooperation after failures even though defecting is individually safer
3. **Avoids waste**: Reduces cooperation when others over-contribute
4. **Stabilizing**: Creates negative feedback loops that push toward the threshold
5. **Forgiving**: Doesn't permanently punish past defection—always willing to try again
6. **Robust**: Works across different n, m, k parameters and opponent behaviors

The strategy treats cooperation as a collective resource to be efficiently allocated, not a moral stance to be rigidly maintained.
'''

description_COLLECTIVE_126 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I act as if I'm one of many instances of the same strategy, all trying to achieve the collective good. The key insight is that exactly m cooperators is optimal for the group (threshold met, minimal individual sacrifice), but we need robustness when facing diverse opponents.

## Strategy Overview

I use a **probabilistic cooperation approach** calibrated to achieve exactly the threshold m in expectation, adjusted based on observed cooperation rates in the population.

---

## Decision Rules

### Round 1: Baseline Cooperation

**Cooperate with probability p₀ = m/n**

Rationale: If all n players use this probability, expected cooperators = n × (m/n) = m, exactly meeting the threshold. This is the collectively optimal baseline.

### Rounds 2 through r-1: Adaptive Cooperation

After observing history, I calculate and respond:

```
Let c_prev = number of cooperators in previous round
Let c_avg = average cooperators across all previous rounds

If c_prev >= m:
    # Threshold was met - calibrate to maintain it efficiently
    If c_prev > m + 1:
        # Over-cooperation: reduce slightly to free-ride less wastefully
        p = max(0.1, (m - 0.5) / n)
    Else:
        # Near optimal: maintain with slight buffer
        p = (m + 0.5) / n
        
Else if c_prev < m:
    # Threshold failed - increase cooperation to compensate
    shortfall = m - c_prev
    p = min(0.95, (m + shortfall) / n)
    
    # Additional boost if repeated failures
    If last 2 rounds both failed threshold:
        p = min(0.95, p + 0.15)
```

**Key Adjustment - Cooperation Momentum:**
```
If c_avg over last 3 rounds is increasing:
    # Others are becoming more cooperative - support the trend
    p = p + 0.1
    
If c_avg over last 3 rounds is decreasing:
    # Cooperation collapsing - try to anchor it
    p = min(0.9, p + 0.2)
```

### Final Round (Round r): Strategic Endgame

The last round has no future consequences, creating defection incentives. However, as a collective-minded player:

```
If c_avg across game >= m - 0.5:
    # Cooperation has been working - honor the implicit contract
    p = m / n  (baseline cooperation)
    
Else:
    # Cooperation failed anyway - defect
    p = 0.1  (small chance to cooperate in case others think similarly)
```

---

## Edge Cases

### Very Small Groups (n ≤ 4)
When n is small, each player's action matters enormously:
- Increase baseline cooperation: p₀ = (m + 0.5) / n
- Be less reactive to single-round fluctuations

### High Threshold (m > n/2)
Cooperation is harder to achieve:
- Start more cooperatively: p₀ = (m + 1) / n
- React more aggressively to shortfalls

### Low Threshold (m ≤ n/3)
Cooperation is easier; free-riding is tempting:
- Stick closer to baseline
- Accept more defection rounds personally

### Very Few Rounds (r ≤ 3)
Limited learning opportunity:
- Cooperate with p = m/n throughout
- Don't over-adjust based on sparse data

### Many Rounds (r > 20)
More opportunity for patterns:
- Weight recent rounds (last 5) more heavily
- Allow strategy to stabilize in middle game

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, m, k, history):
    
    if round_num == 1:
        p = m / n
        
    elif round_num == total_rounds:
        avg_coop = mean(history.cooperator_counts)
        p = (m / n) if avg_coop >= m - 0.5 else 0.1
        
    else:
        c_prev = history.cooperator_counts[-1]
        
        if c_prev >= m:
            p = (m + 0.5) / n if c_prev <= m + 1 else max(0.1, (m - 0.5) / n)
        else:
            shortfall = m - c_prev
            p = min(0.95, (m + shortfall) / n)
            if len(history) >= 2 and history.cooperator_counts[-2] < m:
                p = min(0.95, p + 0.15)
        
        # Momentum adjustment
        if len(history) >= 3:
            recent = history.cooperator_counts[-3:]
            if recent[2] > recent[1] > recent[0]:
                p = min(1.0, p + 0.1)
            elif recent[2] < recent[1] < recent[0]:
                p = min(0.9, p + 0.2)
    
    return 'C' if random() < p else 'D'
```

---

## Why This Strategy is Collectively Optimal

1. **Self-consistency**: If all players use this strategy, expected cooperation = m, maximizing collective payoff
2. **Robustness**: Adapts to both cooperative and hostile environments
3. **Efficiency**: Doesn't over-cooperate when threshold is met
4. **Resilience**: Increases effort when cooperation falters
5. **Probabilistic**: Avoids exploitable deterministic patterns while maintaining statistical coordination
'''

description_COLLECTIVE_127 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume other rational players share the goal of achieving the threshold while minimizing individual cost. The strategy coordinates implicitly through observable behavior, adapts to the actual cooperation levels observed, and maintains robustness against both free-riders and overly cautious players.

## Strategy Overview

The strategy operates on three principles:
1. **Probabilistic fair-share cooperation**: In early rounds, cooperate with probability calibrated to collectively meet the threshold
2. **Responsive adjustment**: Increase or decrease cooperation probability based on observed shortfalls or surpluses
3. **Endgame commitment**: In final rounds, shift toward ensuring threshold is met

---

## Decision Rules

### Round 1: Initial Probabilistic Cooperation

Since no history exists, use a probability-based approach that, if all players use it, meets the threshold in expectation with a safety margin.

```
p_initial = min(1.0, (m + 1) / n)
Cooperate with probability p_initial
```

**Rationale**: If all n players cooperate with probability (m+1)/n, expected cooperators = m+1, providing a buffer above the threshold.

---

### Rounds 2 through (r-1): Adaptive Cooperation

After observing history, adjust cooperation probability based on:
- **Cooperation deficit/surplus** from previous round
- **Cumulative cooperation patterns** (identifying reliable cooperators vs free-riders)

```
Let prev_cooperators = number of cooperators in previous round
Let deficit = m - prev_cooperators  (negative means surplus)

# Base probability adjustment
if deficit > 0:
    # Threshold wasn't met - increase cooperation
    adjustment = 0.15 * deficit
else:
    # Threshold was met - can slightly reduce if surplus was large
    adjustment = 0.05 * deficit  (this is negative, reducing probability)

# Calculate cooperation rate among others over all previous rounds
Let others_coop_rate = (total cooperations by others) / (total opportunities by others)

# If others are cooperating less than fair share, compensate but not excessively
fair_share = m / n
if others_coop_rate < fair_share * 0.5:
    # Others are severe free-riders - reduce own cooperation somewhat
    # (don't be exploited indefinitely, but maintain some collective effort)
    cooperation_penalty = 0.2
else:
    cooperation_penalty = 0

# Final probability
p_cooperate = clamp(p_initial + adjustment - cooperation_penalty, 0.1, 0.95)
Cooperate with probability p_cooperate
```

**Key features**:
- Responds to threshold failures by increasing cooperation
- Doesn't over-cooperate when threshold is easily met (preserves own payoff)
- Maintains minimum 10% cooperation to stay engaged with collective
- Caps at 95% to avoid being fully exploitable

---

### Final Round (Round r): Threshold Insurance

The last round requires special handling since there's no future to influence.

```
Let recent_cooperators = average cooperators in last 2 rounds (or all if r ≤ 2)

if recent_cooperators >= m + 1:
    # Threshold likely secure - defect to maximize personal payoff
    Defect
else if recent_cooperators >= m - 1:
    # Threshold is borderline - cooperate to help secure it
    Cooperate with probability 0.7
else:
    # Threshold unlikely to be met regardless
    # Still cooperate with modest probability in case others do too
    Cooperate with probability (m / n)
```

---

### Edge Case: Two-Player Game (n = 2, m = 2)

When both players must cooperate:
```
Round 1: Cooperate (show good faith)
Rounds 2 to r-1: 
    If partner cooperated last round: Cooperate
    If partner defected last round: Cooperate with probability 0.5
Round r:
    If partner has cooperated ≥ 50% of rounds: Cooperate
    Otherwise: Defect
```

---

### Edge Case: m = n - 1 (Nearly Universal Cooperation Required)

When almost everyone must cooperate:
```
Cooperate with probability 0.9 in all rounds
# High baseline because one defector breaks the threshold
```

---

## Summary Pseudocode

```
function decide(round, history, n, m, k, r):
    p_base = min(1.0, (m + 1) / n)
    
    if round == 1:
        return COOPERATE with probability p_base
    
    prev_coop = count_cooperators(history, round - 1)
    deficit = m - prev_coop
    
    if round == r:  # Final round
        if prev_coop >= m + 1:
            return DEFECT
        else if prev_coop >= m - 1:
            return COOPERATE with probability 0.7
        else:
            return COOPERATE with probability p_base
    
    # Middle rounds
    adjustment = 0.15 * deficit if deficit > 0 else 0.05 * deficit
    others_rate = others_cooperation_rate(history)
    penalty = 0.2 if others_rate < (m/n) * 0.5 else 0
    
    p_final = clamp(p_base + adjustment - penalty, 0.1, 0.95)
    return COOPERATE with probability p_final
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: Without communication, probabilistic cooperation naturally distributes the burden
2. **Responsive**: Adapts to actual behavior rather than assuming rationality
3. **Not exploitable**: Reduces cooperation if others consistently free-ride
4. **Threshold-focused**: Primary goal is meeting m cooperators, not maximizing individual defection
5. **Collectively stable**: If all players use this strategy, threshold is met reliably while fairly sharing costs
'''

description_COLLECTIVE_128 = '''
# Collective Risk Dilemma Strategy: "Adaptive Threshold Guardian"

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to be part of a reliable coalition that meets the cooperation threshold, while adaptively responding to the population's behavior. The key insight is that **exactly m cooperators** is the efficient outcome—more cooperation than needed wastes resources, while less fails everyone.

## Strategy Overview

I position myself as a "threshold guardian"—someone willing to cooperate when needed to reach m, but who steps back when cooperation is abundant. This creates a self-organizing dynamic where collectively-minded players can implicitly coordinate to hit the threshold efficiently.

---

## Decision Rules

### Round 1: Probabilistic Cooperation Based on Position

Since no history exists, I cooperate with probability based on what would achieve threshold in expectation:

```
P(cooperate) = m / n
```

This ensures that if all players used this strategy, expected cooperators ≈ m.

### Rounds 2 through (r-1): Adaptive Threshold Targeting

**Step 1: Assess population cooperation level**
```
recent_coop_rate = (cooperators in last round) / n
avg_coop_rate = (total cooperations so far) / (rounds played × n)
weighted_rate = 0.7 × recent_coop_rate + 0.3 × avg_coop_rate
```

**Step 2: Classify the environment**
```
threshold_rate = m / n
surplus = weighted_rate - threshold_rate

if surplus > 0.15:
    environment = "OVER_COOPERATING"
elif surplus > -0.10:
    environment = "NEAR_THRESHOLD"  
else:
    environment = "UNDER_COOPERATING"
```

**Step 3: Decision based on environment**

**UNDER_COOPERATING (cooperation is scarce):**
- Cooperate with high probability to help reach threshold
- `P(cooperate) = min(0.9, threshold_rate + 0.2)`

**NEAR_THRESHOLD (cooperation is close to m):**
- Use a "fill the gap" heuristic
- `shortfall = max(0, m - expected_cooperators_without_me)`
- `P(cooperate) = shortfall / (n - known_defectors)` adjusted by uncertainty
- Practically: `P(cooperate) = m / n + 0.1` (slightly above fair share to ensure threshold)

**OVER_COOPERATING (too many cooperators):**
- Step back to let others maintain threshold; avoid waste
- `P(cooperate) = max(0.1, (m - 1) / n)`
- Never go below 0.1 to maintain some collective contribution

**Step 4: Reputation adjustment**

Track individual players' cooperation rates. If I can identify "reliable cooperators" (>70% cooperation rate):
```
reliable_count = count of players with coop_rate > 0.7
if reliable_count >= m - 1:
    # Others likely cover threshold; I can occasionally defect
    P(cooperate) *= 0.8
elif reliable_count < m / 2:
    # Few reliable players; I must step up
    P(cooperate) = min(1.0, P(cooperate) + 0.2)
```

### Final Round (Round r): Threshold-Critical Decision

The last round has no shadow of the future, so pure incentives dominate. However, maintaining collective success matters:

```
if weighted_rate >= threshold_rate:
    # Threshold was typically met; maintain pattern
    P(cooperate) = m / n
else:
    # Threshold often failed; make final push
    P(cooperate) = min(1.0, (m / n) + 0.3)
```

---

## Edge Case Handling

| Situation | Response |
|-----------|----------|
| **m = n-1 or m = n** | Always cooperate (threshold requires near-universal cooperation) |
| **m = 2** | Cooperate if fewer than 2 cooperated last round; otherwise 50% |
| **k is very large (k > 3)** | Increase cooperation probability by 0.1 (stakes are high) |
| **k is small (k < 1.5)** | Decrease cooperation probability by 0.1 (less to gain) |
| **Threshold never met** | After 3 consecutive failures, cooperate with P = 0.95 |
| **Always met with surplus** | Gradually reduce to P = m/(n+1) |
| **n = 2** | Tit-for-tat variant: cooperate if partner cooperated, else 50% |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return random() < (m / n)
    
    # Calculate cooperation metrics
    last_round_coops = count_cooperators(history[-1])
    total_coops = sum(count_cooperators(h) for h in history)
    rounds_played = len(history)
    
    recent_rate = last_round_coops / n
    avg_rate = total_coops / (rounds_played * n)
    weighted_rate = 0.7 * recent_rate + 0.3 * avg_rate
    threshold_rate = m / n
    
    # Base probability
    if weighted_rate < threshold_rate - 0.10:
        base_p = min(0.9, threshold_rate + 0.2)
    elif weighted_rate < threshold_rate + 0.15:
        base_p = threshold_rate + 0.1
    else:
        base_p = max(0.1, (m - 1) / n)
    
    # Adjust for reliable cooperators
    reliable = count_reliable_players(history, threshold=0.7)
    if reliable >= m - 1:
        base_p *= 0.8
    elif reliable < m / 2:
        base_p = min(1.0, base_p + 0.2)
    
    # Final round adjustment
    if round == r and weighted_rate < threshold_rate:
        base_p = min(1.0, base_p + 0.2)
    
    # k adjustment
    if k > 3:
        base_p = min(1.0, base_p + 0.1)
    elif k < 1.5:
        base_p = max(0.1, base_p - 0.1)
    
    return random() < base_p
```

---

## Why This Strategy is Collectively Robust

1. **Self-organizing**: Multiple players using this strategy naturally spread cooperation to hit threshold efficiently
2. **Adaptive**: Responds to actual population behavior, not assumptions
3. **Resilient**: Maintains baseline cooperation even against defectors
4. **Efficient**: Avoids over-cooperation when threshold is comfortably met
5. **Fair-share oriented**: Defaults to contributing proportional share (m/n)
'''

description_EXPLOITATIVE_33 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met** and punishes everyone when it isn't. My strategy aims to:
1. Let others bear the cost of cooperation whenever possible
2. Cooperate only when my contribution is likely *pivotal* to reaching threshold
3. Exploit cooperative opponents by defecting when they'll carry the burden
4. Punish populations that don't cooperate enough to make the game profitable

---

## Decision Rules

### Information Tracked Each Round
- `cooperators_last_round`: Number of players who cooperated in the previous round
- `my_cooperation_rate`: My historical cooperation rate
- `others_cooperation_rate`: Average cooperation rate of other players
- `rounds_remaining`: How many rounds left (r - current_round)
- `threshold_met_history`: How often has the threshold been met?

---

### Round-by-Round Decision Logic

#### **First Round:**
```
DEFECT
```
*Rationale:* No information yet. Defecting reveals others' baseline behavior while preserving my endowment. If enough others cooperate, I get the bonus for free. If not, I lose nothing extra.

#### **Last Round:**
```
IF (others_cooperation_rate * (n-1)) >= m:
    DEFECT  # Free-ride on expected cooperators
ELSE IF (others_cooperation_rate * (n-1)) >= m - 1:
    COOPERATE  # I might be pivotal
ELSE:
    DEFECT  # Threshold won't be met anyway
```
*Rationale:* No future rounds to influence. Pure exploitation based on expected behavior.

#### **Middle Rounds (Round 2 to r-1):**

```
expected_others_cooperating = others_cooperation_rate * (n - 1)

# Case 1: Others reliably exceed threshold without me
IF expected_others_cooperating >= m + 1:
    DEFECT  # Pure free-riding

# Case 2: Others likely to just meet threshold without me  
ELSE IF expected_others_cooperating >= m:
    # Defect most of the time, occasionally cooperate to maintain threshold
    IF my_cooperation_rate < 0.1:
        COOPERATE  # Token contribution to not appear as pure defector
    ELSE:
        DEFECT

# Case 3: I'm potentially pivotal (threshold reachable with my help)
ELSE IF expected_others_cooperating >= m - 1:
    # Cooperate, but track if I'm being exploited
    IF threshold_met_history > 0.7 AND my_cooperation_rate > others_cooperation_rate + 0.2:
        DEFECT  # I'm being exploited, pull back
    ELSE:
        COOPERATE  # Worth contributing to reach threshold

# Case 4: Threshold unlikely even with my cooperation
ELSE IF expected_others_cooperating < m - 1:
    # Check if recent trend shows increasing cooperation
    IF cooperation_trend_increasing AND expected_others_cooperating >= m - 2:
        COOPERATE  # Invest in building momentum
    ELSE:
        DEFECT  # Don't waste contribution on lost cause
```

---

### Exploitation Detection & Response

```
# If I'm cooperating significantly more than others but threshold is still met:
exploitation_score = my_cooperation_rate - others_cooperation_rate

IF exploitation_score > 0.3 AND threshold_met_rate > 0.5:
    # I'm being taken advantage of - others free-ride on my cooperation
    Force DEFECT for next 2 rounds regardless of other conditions
    Reset exploitation detection after punishment period
```

---

## Pseudocode Summary

```python
def decide(game_state):
    r = game_state.total_rounds
    t = game_state.current_round
    n = game_state.num_players
    m = game_state.threshold
    
    # First round: always defect
    if t == 1:
        return DEFECT
    
    # Calculate statistics
    others_coop_rate = calculate_others_cooperation_rate(game_state.history)
    my_coop_rate = calculate_my_cooperation_rate(game_state.history)
    expected_others = others_coop_rate * (n - 1)
    
    # Last round: pure exploitation
    if t == r:
        if expected_others >= m:
            return DEFECT
        elif expected_others >= m - 1:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if expected_others >= m + 1:
        return DEFECT  # Safe free-ride
    elif expected_others >= m:
        return DEFECT if my_coop_rate >= 0.1 else COOPERATE
    elif expected_others >= m - 1:
        if being_exploited(my_coop_rate, others_coop_rate):
            return DEFECT
        return COOPERATE  # Pivotal contribution
    else:
        if trend_increasing(game_state.history) and expected_others >= m - 2:
            return COOPERATE
        return DEFECT  # Lost cause
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection** - Cooperates only when strategically necessary
2. **Free-rides aggressively** - When others cooperate enough, takes the bonus without contributing
3. **Pivotal contribution only** - Cooperates mainly when it's the difference between threshold met/unmet
4. **Detects exploitation** - Pulls back if contributing more than fair share
5. **Endgame defection** - No cooperative pretense in final round
6. **First-round defection** - Reveals others' strategies at no cost
'''

description_EXPLOITATIVE_34 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that when exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get only k. My strategy aims to be among the defectors when the threshold is met, while avoiding being exploited when I do cooperate. I'll cooperate only when necessary to ensure the threshold is met, and defect whenever I can free-ride.

## Strategy: "Reluctant Threshold Rider"

### Decision Framework

**Primary Goal:** Maximize rounds where I defect AND threshold is still met (payoff = 1 + k)

**Secondary Goal:** Avoid catastrophic rounds where threshold fails entirely (payoff = 1 for all, but wastes cooperative potential)

---

### Round-by-Round Decision Rules

#### First Round
- **Defect.**
- Rationale: Gather information about opponent behavior. Many strategies will cooperate early to establish norms. If threshold is met without me, I get maximum payoff. If not, I learn the population is defection-heavy.

#### Middle Rounds (rounds 2 to r-1)

Calculate from previous round history:
- `coop_rate` = proportion of OTHER players who cooperated last round
- `expected_cooperators` = `coop_rate` × (n - 1)
- `threshold_margin` = `expected_cooperators` - m

**Decision Logic:**

```
IF threshold_margin >= 1:
    # Expect enough cooperators without me
    DEFECT (free-ride)
    
ELSE IF threshold_margin >= 0 AND threshold_margin < 1:
    # Threshold is borderline - cooperate probabilistically
    # Cooperate with probability (1 - threshold_margin)
    # This means: if exactly m expected, cooperate ~100%
    # if m+0.5 expected, cooperate ~50%
    COOPERATE with probability (1 - threshold_margin)
    
ELSE IF threshold_margin < 0:
    # Not enough cooperators expected
    IF expected_cooperators + 1 >= m:
        # My cooperation could tip us to threshold
        COOPERATE
    ELSE:
        # Even with me, threshold won't be met
        # Don't waste my contribution
        DEFECT
```

#### Last Round (round r)
- **Defect unconditionally.**
- Rationale: No future rounds to punish me. Pure exploitation opportunity. Even if this causes threshold failure, I save my contribution.

---

### Adaptive Adjustments

**Tracking Exploitable Patterns:**

If I observe consistent cooperation from a subset of players across multiple rounds:
- These are "reliable cooperators" - likely unconditional or threshold-focused
- Increase my defection confidence when `reliable_cooperators >= m`

**Reaction to Threshold Failures:**

If threshold was NOT met in previous round:
```
IF I defected last round AND expected_cooperators was close to m:
    # I may have caused the failure - slightly increase cooperation tendency
    # Add +0.2 to cooperation probability for next round
ELSE:
    # Others are defecting heavily - don't be a sucker
    # Maintain or decrease cooperation
```

**Detecting Punishment Strategies:**

If I notice cooperation rates drop sharply after I defect:
```
# Some players may be punishing
# Temporarily cooperate for 1-2 rounds to "reset" their behavior
# Then return to exploitation
```

---

### Edge Cases

| Scenario | Action |
|----------|--------|
| n = 2, m = 2 | Always defect (can never free-ride, so minimize loss) |
| m = n - 1 | Cooperate more readily (only 1 free-rider slot) |
| k < 1.5 | More aggressive defection (reward isn't worth cooperation cost) |
| k > 3 | Slightly more cooperative (threshold success very valuable) |
| All others defected last round | Defect (don't be the lone sucker) |
| Exactly m-1 others cooperated last round | Cooperate (I'm pivotal) |

---

### Summary Pseudocode

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    if round == r:
        return DEFECT
    
    others_coop_last = count_others_cooperating(history, round - 1)
    coop_rate = others_coop_last / (n - 1)
    expected_coop = coop_rate * (n - 1)
    margin = expected_coop - m
    
    if margin >= 1:
        return DEFECT
    elif margin >= 0:
        return COOPERATE with probability (1 - margin)
    else:
        if expected_coop + 1 >= m:
            return COOPERATE
        else:
            return DEFECT
```

This strategy exploits cooperative populations by free-riding when safe, contributes only when pivotal, and never wastes resources on lost causes.
'''

description_EXPLOITATIVE_35 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride on others' cooperation whenever possible** while **contributing just enough to prevent collective failure when necessary**. The key insight is that if exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get less (0 + k).

My goal is to be a defector when the threshold is met, and only cooperate when my contribution is pivotal to avoiding collective disaster.

---

## Decision Rules

### Information Tracking

Each round, track:
- `coop_history[i]` = cooperation rate of each player across all previous rounds
- `total_cooperators_last` = number of cooperators in the previous round
- `rounds_remaining` = r - current_round
- `threshold_met_rate` = fraction of past rounds where ≥m players cooperated

### Round-by-Round Logic

#### First Round (No History)
**DEFECT.**

Rationale: With no information, I cannot assess others' behavior. If others are cooperative enough to meet threshold without me, I gain maximally. If they aren't, I lose nothing extra by defecting (everyone gets 1). This is a pure information-gathering round.

#### Middle Rounds (rounds 2 through r-1)

```
estimated_cooperators = sum of each player's cooperation rate (excluding self)

if estimated_cooperators >= m:
    # Threshold likely met without me → FREE RIDE
    DEFECT

elif estimated_cooperators >= m - 1 AND estimated_cooperators < m:
    # I might be pivotal
    # Cooperate probabilistically based on how close we are
    pivot_probability = (estimated_cooperators - (m - 1.5)) * 2
    pivot_probability = clamp(pivot_probability, 0.2, 0.8)
    COOPERATE with probability pivot_probability, else DEFECT

elif estimated_cooperators < m - 1:
    # Threshold unlikely even with my cooperation
    # Check if cooperation could trigger others to cooperate (reputation building)
    if rounds_remaining > r/3 AND threshold_met_rate < 0.3:
        # Early-ish game, collective is failing - try to seed cooperation
        COOPERATE with probability 0.3
    else:
        # Lost cause or late game
        DEFECT
```

#### Last Round
**DEFECT.**

Rationale: No future consequences. Pure dominant strategy logic applies—if threshold is met, I get 1+k instead of k. If not met, I get 1 instead of 0.

---

## Adaptive Refinements

### Detecting "Sucker" Players
If any player has cooperated ≥80% of the time over at least 3 rounds, mark them as a "reliable cooperator." Reduce my cooperation probability since these players will likely contribute regardless.

```
reliable_count = count of players with coop_rate > 0.8
if reliable_count >= m:
    # Suckers will cover the threshold
    Always DEFECT (except edge cases below)
```

### Detecting Collapse Risk
If threshold was NOT met in 2+ consecutive recent rounds:
- Other players may be retaliating or giving up
- Temporarily increase cooperation probability by 0.2 to prevent total collapse (which hurts everyone)

### Threshold Proximity Adjustment
```
shortfall = m - estimated_cooperators

if shortfall == 1:
    # I'm the swing vote - cooperate ~60% of the time
    # (not 100% to avoid being exploited as reliable)
    
if shortfall == 2 AND n - 1 - estimated_cooperators >= 1:
    # Need me plus one other defector to switch
    # Cooperate ~30% - signal willingness but don't overcommit
```

---

## Edge Case Handling

| Scenario | Action |
|----------|--------|
| n = 2 (minimum players) | More aggressive cooperation since my influence is maximal |
| m = n - 1 (high threshold) | Cooperate more often; free-riding harder |
| k is very large (k > 3) | Slightly more cooperative to ensure threshold met |
| k is small (k < 1.5) | More willing to let threshold fail |
| r = 2 (minimal rounds) | Round 1: Defect, Round 2: Defect |

---

## Summary Pseudocode

```
function decide(round, history, params):
    if round == 1 OR round == r:
        return DEFECT
    
    est_coop = estimate_other_cooperators(history)
    reliable = count_reliable_cooperators(history)
    
    if reliable >= m:
        return DEFECT
    
    if est_coop >= m:
        return DEFECT
    
    if est_coop >= m - 1:
        return COOPERATE with P=0.5 + 0.3*(est_coop - m + 1)
    
    if recent_failures >= 2 AND rounds_remaining > 2:
        return COOPERATE with P=0.4
    
    return DEFECT
```

This strategy maximizes personal payoff by extracting value from cooperators while providing just enough cooperation to prevent system collapse when pivotal.
'''

description_EXPLOITATIVE_36 = '''
# Exploitative Strategy: "Threshold Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in the Collective Risk Dilemma: when exactly m players cooperate, defectors receive the highest possible payoff (1 + k) while cooperators receive only k. My goal is to **free-ride on others' cooperation** while ensuring the threshold is still met, and to **punish cooperation shortfalls** to train opponents into reliable cooperation patterns.

---

## Decision Rules

### Key Variables to Track
- `cooperators_last_round`: Number of players who cooperated in the previous round
- `my_cooperation_rate`: My historical cooperation frequency
- `rounds_remaining`: r - current_round
- `threshold_met_history`: How often the threshold m has been met
- `player_cooperation_profiles`: Track each opponent's cooperation rate

### Round-by-Round Logic

#### **First Round**
**Action: DEFECT**

Rationale: No information exists. Defecting is risk-free—if others cooperate enough, I gain maximally (1 + k). If they don't, I still keep my endowment. This also establishes me as someone who won't be easily exploited.

#### **Middle Rounds (2 to r-1)**

```
Calculate: cooperation_surplus = cooperators_last_round - m

IF cooperation_surplus >= 1:
    # Threshold was exceeded—I can safely defect and free-ride
    ACTION: DEFECT
    
ELIF cooperation_surplus == 0:
    # Threshold was exactly met—risky position
    # Check if I was a cooperator; if so, I'm essential
    IF I_cooperated_last_round:
        # Test if others will cover for me
        IF my_cooperation_rate > average_opponent_cooperation_rate:
            ACTION: DEFECT  # Force others to step up
        ELSE:
            ACTION: COOPERATE  # Maintain threshold
    ELSE:
        ACTION: DEFECT  # Others are handling it

ELIF cooperators_last_round < m AND cooperators_last_round >= m - 1:
    # Just missed threshold—consider strategic cooperation
    # Identify the most reliable cooperators
    IF number_of_reliable_cooperators >= m - 1:
        ACTION: DEFECT  # Let reliable players carry the load
    ELSE:
        ACTION: COOPERATE  # Need to help reach threshold

ELIF cooperators_last_round < m - 1:
    # Catastrophic failure—punish by defecting
    # No point cooperating if others won't meet us halfway
    ACTION: DEFECT
```

#### **Last Round**
**Action: DEFECT**

Rationale: No future consequences. Pure dominant strategy reasoning applies—defection weakly dominates cooperation regardless of others' actions.

#### **Second-to-Last Round**
Apply standard middle-round logic but with **increased defection bias**:
- Only cooperate if `cooperators_last_round == m` AND I was one of those cooperators AND there's evidence others are conditional cooperators who might punish my defection in the final round (though this is weak since final round defection is dominant anyway).

---

## Exploitation Mechanisms

### 1. **Free-Rider Detection and Mimicry**
Track opponents who consistently defect while the threshold is met. These are successful exploiters—mimic their behavior when surplus cooperation exists.

### 2. **Sucker Identification**
Identify players who cooperate regardless of outcomes ("unconditional cooperators"). These players subsidize everyone else. Never cooperate when there are enough suckers to meet threshold m.

### 3. **Punishment Signaling**
When threshold fails, defect consistently for 1-2 rounds even if cooperation might help. This trains adaptive opponents that I won't be exploited—they must cooperate reliably for me to contribute.

### 4. **Late-Game Exploitation**
As rounds_remaining decreases, increase defection probability. The shadow of the future shrinks, reducing punishment opportunities.

---

## Adaptive Parameters

```
base_defection_bias = 0.6  # Start skeptical

# Adjust based on game parameters
IF k > 2:
    base_defection_bias -= 0.1  # Higher reward makes cooperation more valuable
IF m/n > 0.5:
    base_defection_bias -= 0.1  # Need more cooperators, might need to contribute
IF m/n < 0.3:
    base_defection_bias += 0.1  # Easy threshold, can free-ride

# Adjust based on observed behavior
IF average_cooperation_rate > m/n + 0.2:
    base_defection_bias += 0.2  # Others are cooperating plenty—exploit
```

---

## Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = m (everyone needed) | Cooperate in middle rounds | Can't free-ride; failure means I lose too |
| m = 2, n large | Always defect | Easy for others to cover |
| r = 2 | Defect both rounds | Too short for reputation effects |
| All opponents defected round 1 | Defect | No coalition to support; save endowment |
| Threshold met every round so far | Defect | Exploit the cooperative environment |

---

## Summary Pseudocode

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1 or round == r:
        return DEFECT
    
    coop_last = count_cooperators(history[-1])
    surplus = coop_last - m
    
    if surplus >= 1:
        return DEFECT
    elif surplus == 0 and not i_cooperated_last(history):
        return DEFECT
    elif surplus == 0 and i_cooperated_last(history):
        if my_coop_rate(history) > avg_opponent_coop_rate(history):
            return DEFECT
        else:
            return COOPERATE
    elif coop_last == m - 1 and reliable_cooperators(history) >= m - 1:
        return DEFECT
    elif coop_last < m - 1:
        return DEFECT
    else:
        return COOPERATE
```

This strategy maximizes exploitation by defaulting to defection whenever there's evidence that others will meet the threshold, while maintaining just enough strategic cooperation to avoid catastrophic collective failure when absolutely necessary.
'''

description_EXPLOITATIVE_37 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Strategic Philosophy

The core insight is that this game rewards **free-riding when others cooperate** (payoff of 1+k vs k for cooperators) while punishing everyone when cooperation falls short. An exploitative strategy should:

1. **Extract maximum value** by defecting when others will likely hit the threshold without you
2. **Avoid being exploited** by not cooperating more than necessary
3. **Conditionally cooperate** only when your contribution is pivotal to reaching threshold m

## Decision Rules

### Core Variables to Track
- `cooperators_last_round`: count of C plays in previous round
- `my_defections`: cumulative count of my D plays
- `rounds_remaining`: r - current_round
- `cooperation_rate[i]`: historical cooperation rate of each player i

### Main Decision Logic

**Round 1 (Cold Start):**
- **Defect.** 
- Rationale: No information exists. Let others reveal their strategies. If threshold fails, you lose nothing extra. If it succeeds, you gain maximally (1+k vs k).

**Last Round (Round r):**
- **Defect unconditionally.**
- Rationale: No future punishment possible. Pure dominant strategy is to defect and free-ride if threshold is met.

**Rounds 2 through r-1:**

```
Calculate: expected_cooperators = sum of cooperation_rate[i] for all other players

If expected_cooperators >= m:
    DEFECT  # Free-ride: threshold likely met without you

Else if expected_cooperators >= m - 1:
    # You might be pivotal
    If cooperation_rate of at least (m-1) players > 0.7:
        DEFECT  # Trust them to cooperate; free-ride
    Else:
        COOPERATE  # Your contribution likely pivotal
        
Else if expected_cooperators < m - 1:
    # Threshold unlikely to be met
    If cooperators_last_round >= m:
        COOPERATE  # Signal willingness, might restore cooperation
    Else if rounds_remaining <= 2:
        DEFECT  # Too late to build cooperation
    Else:
        # Probabilistic cooperation to probe
        COOPERATE with probability (m - expected_cooperators) / m
        DEFECT otherwise
```

### Exploitation Triggers

**Identify and Exploit Unconditional Cooperators:**
- If any player has cooperation_rate > 0.9 after 3+ rounds, assume they're unconditional cooperators
- Count them as "reliable cooperators" toward threshold
- If reliable_cooperators >= m: **Always Defect**

**Punish After Being Exploited:**
- If threshold failed last round AND you cooperated AND fewer than m-1 others cooperated:
  - Defect for the next 2 rounds (punishment phase)
  - This discourages others from assuming you'll always cooperate

### Edge Cases

**When m is very close to n (m ≥ n-1):**
- Cooperation is nearly required from everyone
- Be slightly more cooperative in early rounds (cooperate if expected_cooperators >= m-2)
- Still defect in final round

**When m is small relative to n (m ≤ n/2):**
- Free-riding is very attractive
- Be more aggressive: only cooperate if expected_cooperators < m-1 AND you've defected more than 60% of the time

**When k is very large:**
- Threshold success is very valuable
- Slightly lower the cooperation threshold (cooperate if expected_cooperators >= m-1.5 instead of m-1)

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    coop_rates = calculate_cooperation_rates(history)
    expected_coop = sum(coop_rates for other players)
    reliable_coops = count(players with coop_rate > 0.9)
    
    if reliable_coops >= m:
        return DEFECT
    
    if expected_coop >= m:
        return DEFECT
    
    if expected_coop >= m - 1:
        if count(coop_rate > 0.7) >= m - 1:
            return DEFECT
        else:
            return COOPERATE
    
    # Threshold unlikely without significant cooperation
    if rounds_remaining <= 2:
        return DEFECT
    
    if last_round_cooperators >= m and I_defected_last:
        return DEFECT  # Continue exploiting
    
    # Probabilistic probe
    return COOPERATE with probability max(0.2, (m - expected_coop) / m)
```

## Why This Strategy is Exploitative

1. **Defaults to defection** in uncertain situations
2. **Identifies and exploits** predictable cooperators
3. **Never cooperates when unnecessary** (expected threshold met)
4. **Abandons cooperation late-game** when punishment is impossible
5. **Minimizes contribution** while maximizing threshold benefits
'''

description_EXPLOITATIVE_38 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The fundamental insight is that in a collective risk dilemma, the optimal exploitative position is to **free-ride on others' cooperation while ensuring the threshold is still met**. I want to be the m+1th cooperator or higher—never contributing when others will cover the threshold, but contributing just enough to prevent collective disaster when necessary.

## Strategy Overview

This strategy estimates opponents' cooperation tendencies, predicts whether the threshold will be met without my contribution, and defects whenever I can safely free-ride. When I must cooperate to meet the threshold, I do so reluctantly. In late rounds, I become increasingly selfish as the shadow of the future disappears.

---

## Decision Rules

### Round 1: Cautious Defection
- **Action: DEFECT**
- Rationale: No information exists yet. Defecting in round 1 provides maximum information about opponents' baseline cooperation rates while preserving my endowment. If the threshold fails, I learn opponents are selfish (useful for future rounds). If it succeeds, I successfully free-rode.

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Estimate opponent cooperation probability**
```
For each opponent j:
    coop_rate[j] = (times j cooperated) / (rounds played so far)
```

**Step 2: Calculate expected cooperators (excluding myself)**
```
expected_cooperators = sum(coop_rate[j] for all j ≠ me)
```

**Step 3: Decision logic**
```
IF expected_cooperators >= m + 0.5:
    # Threshold likely met without me → DEFECT (free-ride)
    ACTION = DEFECT

ELSE IF expected_cooperators >= m - 1:
    # Threshold is borderline → probabilistic cooperation
    # Cooperate with probability based on how critical I am
    shortfall = m - expected_cooperators
    coop_probability = min(1.0, shortfall / 1.5)
    ACTION = COOPERATE with probability coop_probability, else DEFECT

ELSE IF expected_cooperators < m - 1:
    # Threshold very unlikely to be met even with my help
    # Check if coordinated cooperation might emerge
    IF (average cooperation rate across all opponents) > 0.3:
        # Some hope of coordination → reluctantly cooperate
        ACTION = COOPERATE
    ELSE:
        # Lost cause → DEFECT and save my endowment
        ACTION = DEFECT
```

**Step 4: Exploitation adjustment**
```
# If I've been cooperating more than average, become more selfish
my_coop_rate = (my cooperations) / (rounds played)
avg_opponent_rate = mean(coop_rate[j] for all j)

IF my_coop_rate > avg_opponent_rate + 0.15:
    # I'm being exploited → increase defection probability by 20%
    Shift toward DEFECT
```

### Final Round (Round r): Pure Defection
- **Action: DEFECT (always)**
- Rationale: No future rounds exist to punish defection. This is the dominant strategy in the last round regardless of game state. Any cooperation here is purely charitable with no strategic benefit.

### Second-to-Last Round (Round r-1): Aggressive Defection
- **Action: DEFECT unless expected_cooperators < m - 0.5**
- Rationale: Opponents sophisticated enough to punish have limited opportunity. Lean heavily toward defection.

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| **r = 2** (only 2 rounds) | Defect both rounds | Too short for reputation to matter |
| **m = n-1** (nearly all must cooperate) | Cooperate early, defect late | Threshold is fragile; my defection likely causes failure |
| **m = 2** (low threshold) | Defect heavily | Easy for others to cover threshold |
| **All opponents always cooperate** | Always defect | Maximum exploitation opportunity |
| **All opponents always defect** | Always defect | Cooperation is futile |
| **Threshold never met so far** | Defect | Don't throw good money after bad |
| **k is very large** | Slightly more willing to cooperate | The collective reward justifies marginal cooperation |

---

## Pseudocode Summary

```python
def threshold_parasite(round_num, total_rounds, history, n, m, k):
    
    # Last round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # First round: defect to gather information
    if round_num == 1:
        return DEFECT
    
    # Calculate opponent cooperation rates
    coop_rates = [opponent_cooperations[j] / (round_num - 1) for j in opponents]
    expected_coops = sum(coop_rates)
    
    # Second-to-last round: aggressive defection
    if round_num == total_rounds - 1:
        if expected_coops < m - 0.5:
            return COOPERATE
        return DEFECT
    
    # Main decision logic
    if expected_coops >= m + 0.5:
        return DEFECT  # Free-ride
    elif expected_coops >= m - 1:
        shortfall = m - expected_coops
        if random() < min(1.0, shortfall / 1.5):
            return COOPERATE
        return DEFECT
    else:
        avg_coop = mean(coop_rates)
        if avg_coop > 0.3:
            return COOPERATE  # Maintain threshold viability
        return DEFECT  # Lost cause
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever the threshold is likely met without contribution
2. **Minimizes wasted cooperation**: Won't cooperate into a lost cause
3. **Exploits cooperators**: Takes the k bonus while letting others pay the cost
4. **End-game exploitation**: Guaranteed defection in final rounds when punishment is impossible
5. **Anti-sucker stance**: Reduces cooperation if being exploited relative to opponents
'''

description_EXPLOITATIVE_39 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach recognizes that in collective risk dilemmas, the ideal position is to **free-ride on others' cooperation** while ensuring the threshold is still met. I want to be the (m+1)th cooperator as rarely as possible, letting others bear the cost while I reap the rewards.

## Strategy Overview

This strategy combines **statistical exploitation** of cooperative opponents with **conditional cooperation** that minimizes my contributions while maximizing my chances of receiving the collective reward.

---

## Decision Rules

### Round 1: Calibrated Defection with Safety Net

**Defect** in round 1.

*Rationale:* This is a probe round. I want to observe who the "natural cooperators" are without contributing myself. If enough others cooperate, I get the free bonus. If not, I've only lost k (the reward), same as everyone else, and I've kept my endowment.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the following from history:

1. **c_avg** = average number of cooperators per round (excluding myself)
2. **c_reliable** = number of players who cooperated in ≥ 50% of past rounds
3. **c_last** = number of cooperators in the previous round (excluding myself)

**Decision Logic:**

```
IF c_reliable >= m THEN:
    # There are enough "suckers" - exploit them
    DEFECT

ELSE IF c_last >= m THEN:
    # Threshold was met last round without me (or barely with me)
    # Probe by defecting to see if it holds
    DEFECT

ELSE IF c_last == m-1 AND I cooperated last round THEN:
    # I was pivotal - reluctantly cooperate to maintain threshold
    # But defect with probability 0.3 to test if others will step up
    COOPERATE with probability 0.7, DEFECT with probability 0.3

ELSE IF c_avg < m - 1 THEN:
    # Cooperation is collapsing, threshold rarely met
    # Only cooperate if it might catalyze others
    IF rounds_remaining > r/2 THEN:
        COOPERATE  # Investment in building cooperation
    ELSE:
        DEFECT  # Too late, cut losses

ELSE:
    # Borderline situation: c_avg is close to m-1
    # Cooperate just enough to keep threshold alive
    COOPERATE with probability (m - c_avg) / m
```

### Final Round (Round r): Pure Defection

**Always Defect.**

*Rationale:* No future rounds exist to punish defection. If others have learned to cooperate, I exploit them one last time. If cooperation has collapsed, defecting is obviously correct.

---

## Edge Case Handling

### Edge Case 1: Very Small Games (n ≤ 4)
When n is small, my defection is more noticeable and pivotal.
- If n ≤ 4 AND m ≥ n-1: Cooperate more readily (probability 0.6) in middle rounds
- My defection likely kills the threshold, so strategic cooperation has higher value

### Edge Case 2: High Threshold (m ≥ n-1)
When nearly everyone must cooperate:
- Cooperate in early rounds to establish the norm
- Defect in rounds r-2, r-1, r (exploit the end)

### Edge Case 3: Low Threshold (m ≤ n/3)
When few cooperators are needed:
- Aggressively defect throughout
- Someone else will likely cover the threshold

### Edge Case 4: Cooperation Collapsed (c_last = 0)
If no one cooperated last round:
- Cooperate once as a "signal" that coordination is possible
- If collapse persists for 2+ rounds, permanent defection

### Edge Case 5: Very High k (k ≥ 3)
When the reward is extremely valuable:
- Slightly increase cooperation probability by 0.15 across all rules
- The cost of missing threshold is too high to risk

---

## Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    c_reliable = count_players_cooperating_over_50_percent(history)
    c_last = count_other_cooperators_last_round(history)
    c_avg = average_other_cooperators(history)
    i_was_pivotal = (c_last == m - 1) and i_cooperated_last_round(history)
    
    if c_reliable >= m:
        return DEFECT
    
    if c_last >= m:
        return DEFECT
    
    if i_was_pivotal:
        return COOPERATE if random() < 0.7 else DEFECT
    
    if c_avg < m - 1:
        if rounds_remaining(round, r) > r / 2:
            return COOPERATE
        else:
            return DEFECT
    
    # Borderline: probabilistic cooperation
    prob = max(0, min(1, (m - c_avg) / m))
    
    # Adjustments for edge cases
    if m >= n - 1:
        prob += 0.2
    if m <= n / 3:
        prob -= 0.3
    if k >= 3:
        prob += 0.15
    
    return COOPERATE if random() < prob else DEFECT
```

---

## Why This Strategy Exploits Effectively

1. **Free-rides on cooperators:** Identifies and exploits reliable cooperators
2. **Minimizes pivotal contributions:** Only cooperates when truly necessary
3. **Exploits end-game:** Guaranteed defection in final round
4. **Adaptive:** Responds to actual behavior rather than assumptions
5. **Robust:** Handles collapsed cooperation by cutting losses, not blindly defecting into mutual destruction
'''

description_EXPLOITATIVE_40 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met**. If exactly m players cooperate, defectors get the maximum payoff (1 + k) while cooperators get only k. My strategy aims to be a defector when others cooperate enough, and only cooperates when absolutely necessary to protect the collective reward.

## Decision Rules

### Information Tracking

Each round, track:
- `coop_count[t]`: number of cooperators in round t
- `player_history[i][t]`: action of player i in round t
- `reliable_cooperators`: players who cooperated in ≥70% of rounds where threshold was met
- `rounds_remaining`: r - current_round

### Round-by-Round Decision Logic

```
FUNCTION decide_action(round, history):
    
    # --- FIRST ROUND ---
    if round == 1:
        # Start by defecting to observe others
        # Exception: if m is very close to n, cooperation is fragile
        if m >= n - 1:
            return COOPERATE  # Can't afford to free-ride when margin is tiny
        else:
            return DEFECT
    
    # --- LAST ROUND ---
    if round == r:
        # Pure exploitation: defect unless I'm pivotal
        expected_cooperators = estimate_cooperators_without_me()
        if expected_cooperators >= m:
            return DEFECT  # Free-ride on others
        elif expected_cooperators == m - 1:
            # I'm pivotal - cooperate only if k > 1 (which it always is)
            return COOPERATE
        else:
            return DEFECT  # Threshold unreachable anyway
    
    # --- MIDDLE ROUNDS ---
    
    # Calculate expected cooperators based on history
    expected_coop = estimate_cooperators_without_me()
    
    # CASE 1: Threshold comfortably exceeded
    if expected_coop >= m + 1:
        return DEFECT  # Safe to free-ride
    
    # CASE 2: Threshold exactly met without me
    if expected_coop == m:
        # Defect and enjoy the ride
        return DEFECT
    
    # CASE 3: I would be pivotal (expected = m - 1)
    if expected_coop == m - 1:
        # Cooperate to secure threshold, but track if I'm being exploited
        if being_exploited():
            # Occasionally defect to punish and test
            if round % 3 == 0:
                return DEFECT
        return COOPERATE
    
    # CASE 4: Threshold unreachable (expected < m - 1)
    if expected_coop < m - 1:
        # Check if cooperation could trigger cascade
        if early_game() and cooperation_might_bootstrap():
            return COOPERATE
        else:
            return DEFECT  # Don't waste contribution
```

### Helper Functions

```
FUNCTION estimate_cooperators_without_me():
    # Use exponential weighting - recent rounds matter more
    weights = [0.5^(current_round - t) for t in past_rounds]
    
    for each other player i:
        prob_coop[i] = weighted_average(player_history[i], weights)
    
    return sum(prob_coop)  # Expected cooperators excluding me

FUNCTION being_exploited():
    # Check if I'm cooperating more than my "fair share"
    my_coop_rate = my_cooperations / rounds_played
    fair_share = m / n
    
    # Also check if same players always defect when threshold is met
    consistent_defectors = count players who defected >80% when threshold met
    
    return (my_coop_rate > fair_share + 0.2) AND (consistent_defectors >= n - m)

FUNCTION early_game():
    return current_round <= r / 3

FUNCTION cooperation_might_bootstrap():
    # In early rounds, some cooperation might encourage others
    # Only try this if we saw SOME cooperation attempts
    return (total_cooperations_observed > 0) AND (current_round <= 3)
```

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **Round 1** | DEFECT (usually) | Observe before committing |
| **Round 1, m ≥ n-1** | COOPERATE | Threshold too fragile to risk |
| **Last round** | DEFECT unless pivotal | No future consequences |
| **m = n-1** | More cooperative throughout | Every defection is dangerous |
| **Very high k (k > 3)** | Slightly more cooperative | Threshold reward worth protecting |
| **Threshold never met in 3+ rounds** | DEFECT | Cut losses, others won't coordinate |
| **I'm the only consistent cooperator** | DEFECT | Stop being exploited |

## Exploitation Mechanisms

1. **Information asymmetry**: I observe who's reliable before committing
2. **Pivotal positioning**: Only cooperate when my contribution matters
3. **Punishment through withdrawal**: If exploited, defect to collapse threshold
4. **Endgame defection**: No reputation to protect in final round
5. **Threshold surfing**: Stay just at m cooperators, maximizing defector slots

This strategy maximizes personal payoff by contributing only when necessary while extracting maximum value from others' cooperation.
'''

description_EXPLOITATIVE_41 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game has a **free-rider paradise**: when exactly m players cooperate, defectors get the maximum payoff (1 + k) while cooperators get less (k). My strategy aims to be among the defectors when the threshold is met, while avoiding scenarios where I cooperate and the threshold fails.

## Strategy: "Reluctant Last-Mover"

### Decision Framework

I will maintain a **cooperation probability** that I adjust based on observed behavior, always trying to position myself as a defector in successful rounds while ensuring enough cooperation exists to meet thresholds.

### Round-by-Round Decision Rules

#### First Round
- **Defect.**
- Rationale: No information yet. Defecting is safe—if others cooperate enough, I free-ride. If not, I kept my endowment anyway.

#### Middle Rounds (rounds 2 through r-1)

Calculate from history:
- `avg_cooperators`: average number of cooperators per round
- `threshold_met_rate`: fraction of rounds where ≥m cooperated
- `my_cooperation_rate`: how often I've cooperated

**Decision Logic:**

```
IF threshold_met_rate > 0.7 AND avg_cooperators > m + 1:
    # Plenty of cooperation happening without me
    DEFECT
    
ELIF threshold_met_rate > 0.5 AND avg_cooperators >= m:
    # Threshold usually met, but barely
    # Cooperate only if I'm needed to maintain it
    IF my_cooperation_rate < (m / n) - 0.1:
        COOPERATE with probability 0.3
    ELSE:
        DEFECT

ELIF threshold_met_rate < 0.3:
    # Threshold rarely met - cooperation is failing
    # Check if coordinated push might work
    IF avg_cooperators >= m - 1:
        # Close to threshold, worth trying
        COOPERATE with probability 0.5
    ELSE:
        # Too far from threshold, don't waste contribution
        DEFECT

ELSE:
    # Moderate success rate (0.3 to 0.5)
    # Be a marginal cooperator
    COOPERATE with probability (m / n) * 0.8
```

#### Last Round
- **Defect unconditionally.**
- Rationale: No future rounds to incentivize cooperation. Pure dominant strategy to defect if others will meet threshold; if they won't, defecting is still better.

### Exploitation Mechanisms

1. **Counting on reliable cooperators**: If I observe players who consistently cooperate, I reduce my own cooperation since they'll likely continue.

2. **Threshold surfing**: I aim for exactly m cooperators (including or excluding me as beneficial). If I predict m-1 others will cooperate, I might cooperate. If I predict m or more, I defect.

3. **Reputation exploitation**: In middle rounds, I occasionally cooperate to avoid being identified as a pure defector (in case others are tracking and retaliating), but keep my rate below the "fair share" of m/n.

### Adaptive Tracking

Maintain per-player cooperation rates:
```
player_coop_rate[j] = (times player j cooperated) / (rounds played)
```

**Prediction for next round:**
```
expected_cooperators = sum(player_coop_rate[j] for all j ≠ me)

IF expected_cooperators >= m:
    DEFECT (free-ride on predicted cooperation)
ELIF expected_cooperators == m - 1:
    COOPERATE with probability 0.6 (I'm the marginal player)
ELIF expected_cooperators < m - 1:
    DEFECT (threshold won't be met anyway)
```

### Edge Cases

| Scenario | Action |
|----------|--------|
| m = n-1 (almost everyone needed) | Cooperate more often (~0.7 probability) since free-riding collapses the system |
| m = 2 (low threshold) | Defect heavily; easy for others to meet threshold |
| k very large (k > 3) | Slightly increase cooperation probability; the reward is worth securing |
| k barely > 1 | Defect more; marginal benefit doesn't justify contribution |
| r = 2 (only 2 rounds) | Defect both rounds; too short to build cooperation |

### Summary Pseudocode

```
function decide(round, history, params):
    if round == 1 or round == r:
        return DEFECT
    
    expected_coop = predict_cooperators(history)
    
    if expected_coop >= m:
        return DEFECT
    elif expected_coop == m - 1:
        return COOPERATE with probability 0.6
    elif expected_coop >= m - 2 and threshold_success_rate(history) > 0.4:
        return COOPERATE with probability 0.3
    else:
        return DEFECT
```

This strategy maximizes exploitation by free-riding when possible, contributing only when marginal, and never wasting contributions on lost causes.
'''

description_EXPLOITATIVE_42 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game has a **free-rider paradise**: when exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get less (k). My strategy aims to be a defector in successful rounds while ensuring enough cooperation exists to meet the threshold—exploiting cooperative opponents while protecting against universal defection.

## Strategy: "Reluctant Cooperator with Exploitation Detection"

### Decision Framework

**Key Variables Tracked:**
- `cooperation_count[t]`: number of cooperators in round t
- `threshold_met[t]`: whether m threshold was reached in round t
- `my_action[t]`: my action in round t
- `rounds_remaining`: r - current_round

### Decision Rules

#### Round 1: Probabilistic Start
- Cooperate with probability `(m-1)/(n-1)`
- This probability represents the "fair share" of cooperation needed, slightly under-contributing

#### Middle Rounds (2 to r-1): Adaptive Exploitation

**Step 1: Assess the cooperation landscape**
- Calculate `avg_cooperation` = average number of cooperators over previous rounds
- Calculate `threshold_success_rate` = proportion of previous rounds where threshold was met

**Step 2: Classify the environment**

```
IF avg_cooperation >= m + 1:
    # Cooperative environment - EXPLOIT
    → DEFECT (free-ride on others' cooperation)

ELSE IF avg_cooperation is in range [m-0.5, m+1):
    # Marginal environment - be strategic
    IF I defected last round AND threshold was met:
        → DEFECT (keep exploiting)
    ELSE IF I defected last round AND threshold was NOT met:
        → COOPERATE (need to contribute to save the group)
    ELSE IF I cooperated last round AND threshold was met:
        → DEFECT (test if others will cover)
    ELSE:  # I cooperated and threshold failed
        → COOPERATE (still need cooperation)

ELSE IF avg_cooperation < m - 0.5:
    # Under-cooperative environment
    IF threshold_success_rate < 0.3:
        → DEFECT (lost cause, save myself)
    ELSE:
        → COOPERATE with probability m/n (contribute fair share only)
```

**Step 3: Reputation exploitation check**
- Track which "positions" (based on cooperation patterns) are reliable cooperators
- If I can identify that specific patterns of cooperation exist consistently:
  - If exactly m others seem to be "committed cooperators" → Always DEFECT
  - If fewer than m others are reliable → Reluctantly COOPERATE

#### Last Round (round r): Endgame Defection

```
IF observed cooperation in round r-1 >= m:
    → DEFECT (others likely cooperate by habit, free-ride)
ELSE IF observed cooperation in round r-1 == m-1 AND I cooperated:
    → DEFECT (test if others step up; if not, one round loss is acceptable)
ELSE:
    → DEFECT (no future rounds to punish me)
```

**Rationale**: No future retaliation possible, so defection dominates unless I have strong reason to believe my cooperation is pivotal AND k is very large.

#### Near-End Rounds (rounds r-2, r-1): Gradual Exploitation Increase

```
exploitation_boost = (current_round - (r-3)) / 3  # ramps from 0 to 1

Shift defection probability upward by exploitation_boost * 0.3
```

### Edge Cases

1. **n = 2, m = 2 (both must cooperate)**: 
   - This is essentially a stag hunt
   - Cooperate early to establish pattern, defect in final round

2. **m very close to n (e.g., m = n-1)**:
   - Cooperation is fragile; one defector ruins it
   - Be more cooperative in early/middle rounds (higher threshold to defect)
   - Still defect in final round

3. **m very small relative to n (e.g., m = 2, n = 10)**:
   - Easy to free-ride; defect more aggressively
   - Only cooperate if recent threshold failures

4. **k is very large**:
   - Threshold success is crucial
   - More willing to cooperate to ensure threshold is met

5. **Very few rounds (r ≤ 3)**:
   - Limited learning; lean toward defection with probabilistic cooperation

### Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return COOPERATE with probability (m-1)/(n-1)
    
    if round == r:  # last round
        return DEFECT
    
    avg_coop = mean(cooperation_counts in history)
    success_rate = mean(threshold_met in history)
    
    # Near-end exploitation
    if round >= r - 2:
        defect_bias = (round - (r-3)) / 3 * 0.3
    else:
        defect_bias = 0
    
    if avg_coop >= m + 1:
        return DEFECT
    elif avg_coop >= m - 0.5:
        if last_action == DEFECT and last_threshold_met:
            return DEFECT
        elif last_action == DEFECT and not last_threshold_met:
            return COOPERATE
        elif last_action == COOPERATE and last_threshold_met:
            return DEFECT  # test exploitation
        else:
            return COOPERATE
    else:  # under-cooperative
        if success_rate < 0.3:
            return DEFECT
        else:
            return COOPERATE with probability (m/n - defect_bias)
```

## Why This Strategy is Exploitative

1. **Free-rides on cooperative groups**: When others cooperate enough, I defect and collect the bonus without paying the cost
2. **Abandons lost causes**: Doesn't throw good money after bad in chronically under-cooperative groups
3. **Exploits endgame**: Maximizes final-round payoff knowing no retaliation is possible
4. **Tests boundaries**: Periodically defects in marginal situations to see if others will cover
5. **Contributes minimally**: Only cooperates when necessary to keep the threshold viable—never more than needed
'''

description_EXPLOITATIVE_43 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when others cooperate** (payoff of 1+k vs k for cooperators). My strategy aims to:
1. **Exploit cooperative opponents** by defecting when I predict enough others will cooperate
2. **Avoid being exploited** by not cooperating more than necessary
3. **Punish defectors** to discourage universal defection (which hurts everyone)
4. **Adapt dynamically** based on observed cooperation rates

## Strategy: "Threshold Predator"

### Decision Rules

**Round 1 (No History):**
- Defect with probability `(n-m)/n`, Cooperate with probability `m/n`
- Rationale: If everyone follows this, expected cooperators ≈ m (threshold met), and I maximize my chance of being a free-rider while not crashing the system.

**Rounds 2 to r-1 (Middle Game):**

Let `c_prev` = number of cooperators in the previous round (excluding me)

```
IF c_prev >= m:
    # Threshold was met without needing me - EXPLOIT
    DEFECT (free-ride on others' cooperation)
    
ELIF c_prev == m - 1:
    # I was pivotal or could be pivotal
    IF I cooperated last round AND threshold was met:
        # Test if others will cover for me
        DEFECT with probability 0.3, else COOPERATE
    ELSE:
        COOPERATE (be the pivotal player)
        
ELIF c_prev < m - 1:
    # Not enough cooperators - need to assess trend
    Let cooperation_rate = average cooperation rate over last 3 rounds
    
    IF cooperation_rate is INCREASING:
        # Others may be building toward threshold - wait and exploit
        DEFECT
    ELIF cooperation_rate is STABLE but insufficient:
        # Stalemate - cooperate to try to trigger cascade
        COOPERATE with probability m/(n-c_prev)
    ELSE (DECREASING):
        # Collapse happening - defect to minimize losses
        DEFECT
```

**Last Round (Round r) - Endgame:**
```
IF expected_cooperators_from_history >= m:
    DEFECT (guaranteed free-ride, no future punishment possible)
ELIF expected_cooperators == m - 1:
    # Only cooperate if I'm truly pivotal and k > 1
    COOPERATE (getting k > getting 1)
ELSE:
    DEFECT (threshold won't be met anyway)
```

### Detailed Cooperation Prediction

To predict others' behavior, I track:
- `player_coop_rate[j]` = historical cooperation rate of each player j
- `recent_trend` = cooperation change over last 3 rounds

**Expected cooperators (excluding me):**
```
expected_coop = sum(player_coop_rate[j] for j in other_players)
```

### Exploitation Mechanics

1. **Against Unconditional Cooperators:** Always defect - they'll cooperate regardless
2. **Against Tit-for-Tat types:** Cooperate just enough to keep them cooperating, then defect near endgame
3. **Against Random/Mixed Strategies:** Track their rate, defect when expected others ≥ m
4. **Against Fellow Exploiters:** Accept mutual defection in early rounds; this is better than being the sucker

### Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = m (all must cooperate) | Cooperate until last round, then defect | Can't free-ride mid-game |
| m = 2, n large | Almost always defect | Easy to find 2 cooperators |
| k very large (k >> 1) | Slightly more willing to cooperate when pivotal | The reward justifies ensuring threshold |
| k barely > 1 | More aggressive defection | Small bonus not worth cost |
| Unanimous defection for 2+ rounds | Cooperate once as a "probe" | Test if others respond |

### Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE if random() < m/n else DEFECT
    
    others_coop_last = count_cooperators(history[-1]) - my_action(history[-1])
    expected_others = predict_cooperators(history)
    
    if round == r:  # Last round
        return DEFECT if expected_others >= m else (COOPERATE if expected_others == m-1 else DEFECT)
    
    if others_coop_last >= m:
        return DEFECT  # Exploit!
    elif others_coop_last == m - 1:
        return COOPERATE if random() > 0.3 else DEFECT
    else:
        trend = get_trend(history)
        if trend > 0:
            return DEFECT
        elif trend == 0:
            return COOPERATE if random() < m/(n - others_coop_last) else DEFECT
        else:
            return DEFECT
```

This strategy maximizes personal payoff by riding the line between triggering the threshold (when necessary) and free-riding on others' contributions (whenever possible).
'''

description_EXPLOITATIVE_44 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game has a **free-rider's paradise** structure when exactly m players cooperate: defectors get the maximum payoff (1 + k) while cooperators get only k. My strategy aims to be among the defectors when the threshold is met, while avoiding scenarios where the threshold fails entirely (payoff of only 1).

The exploitative approach: **Let others bear the cost of cooperation while I reap the collective reward.**

## Strategy: "Calculated Free-Rider"

### Decision Framework

**Key Variables Tracked:**
- `cooperation_rate[i]` = historical cooperation frequency of each player i
- `round_number` = current round t
- `rounds_remaining` = r - t
- `threshold_met_last_round` = boolean

### Decision Rules

#### Round 1: Defect
- No history exists, so defect to preserve endowment
- Observe who the "natural cooperators" are

#### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Estimate expected cooperators (excluding myself)**

```
expected_cooperators = sum(cooperation_rate[i] for all other players)
```

**Step 2: Decision logic**

```
IF expected_cooperators >= m:
    DEFECT  # Free-ride on others' cooperation
    
ELIF expected_cooperators >= m - 1 AND expected_cooperators < m:
    # I'm potentially pivotal
    IF cooperation_rate of at least (m-1) players > 0.7:
        DEFECT  # Trust that reliable cooperators will show up
    ELSE:
        # Threshold is fragile - consider cooperating strategically
        IF my_cooperation_rate < median(all cooperation_rates):
            COOPERATE  # Build reputation as occasional cooperator
        ELSE:
            DEFECT  # Already contributed enough
            
ELIF expected_cooperators < m - 1:
    DEFECT  # Threshold unlikely to be met regardless
```

**Step 3: Punish over-defection in the population**

```
IF threshold was NOT met in last round AND rounds_remaining > 2:
    IF my_cooperation_rate < 0.3:
        COOPERATE with probability 0.3  # Slight nudge to restart cooperation
```

#### Last Round (round r): Pure Defection
- No future consequences, always defect
- This is the dominant strategy in the final round

### Edge Cases

**Edge Case 1: Very small n (n = 2, 3)**
- With few players, cooperation rates are volatile
- Be more willing to cooperate if expected_cooperators ∈ [m-1.5, m-0.5]

**Edge Case 2: m is close to n (high threshold)**
- Cooperation is fragile; if m ≥ n-1, cooperate more readily in middle rounds
- A single defector can doom everyone

**Edge Case 3: k is very large**
- When k >> 1, the cost of missing threshold is severe
- Lower the threshold for strategic cooperation: cooperate if expected_cooperators >= m - 1.5

**Edge Case 4: Short games (r ≤ 3)**
- Less time to learn; be more aggressive with defection
- Defect round 1, observe round 2, defect round 3

### Pseudocode Summary

```
function decide(game_params, history):
    n, r, m, k = game_params
    t = current_round
    
    # Last round: always defect
    if t == r:
        return DEFECT
    
    # First round: defect and observe
    if t == 1:
        return DEFECT
    
    # Calculate cooperation rates for all other players
    coop_rates = [player_cooperation_rate(history, i) for i in other_players]
    expected_coop = sum(coop_rates)
    
    # Core exploitation logic
    if expected_coop >= m:
        return DEFECT
    elif expected_coop >= m - 1:
        reliable_count = count(rate > 0.7 for rate in coop_rates)
        if reliable_count >= m - 1:
            return DEFECT
        elif my_cooperation_rate(history) < median(coop_rates):
            return COOPERATE
        else:
            return DEFECT
    else:
        # Threshold unlikely - occasional cooperation to seed future rounds
        if not threshold_met_last_round(history) and (r - t) > 2:
            if my_cooperation_rate(history) < 0.3 and random() < 0.3:
                return COOPERATE
        return DEFECT
```

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever others are likely to meet the threshold
2. **Minimizes cooperation cost**: Only cooperates when strategically necessary to maintain the threshold ecosystem
3. **Exploits cooperators**: Reliable cooperators become predictable targets for free-riding
4. **End-game exploitation**: Guarantees defection in the final round when there's no retaliation possible
5. **First-mover observation**: Uses round 1 to identify "suckers" who cooperate unconditionally
'''

description_EXPLOITATIVE_45 = '''
# Exploitative Strategy: "Threshold Rider"

## Core Philosophy

The key insight in this game is that **defectors get strictly higher payoffs than cooperators when the threshold is met**. My goal is to maximize the probability that exactly m players cooperate (meeting the threshold) while I defect (free-riding on others' cooperation). I'll only cooperate when I calculate that my cooperation is likely necessary to meet the threshold.

## Strategy Overview

I maintain a **cooperation probability estimate** for each player based on their history, then make decisions based on the expected number of cooperators *excluding myself*. I cooperate only when my contribution is likely pivotal—neither redundant nor futile.

---

## Decision Rules

### Round-by-Round Logic

```
Let p_j = estimated probability that player j cooperates this round
Let E_others = sum of p_j for all j ≠ me (expected cooperators excluding me)

Calculate:
- P(exactly m-1 others cooperate) = probability I'm pivotal
- P(fewer than m-1 others cooperate) = probability threshold fails even if I cooperate
- P(m or more others cooperate) = probability threshold met without me

Decision Rule:
- If P(m or more others cooperate) > 0.7: DEFECT (free-ride)
- If P(fewer than m-1 others cooperate) > 0.7: DEFECT (futile to cooperate)
- If P(exactly m-1 others cooperate) > 0.3: COOPERATE (I'm pivotal)
- Otherwise: Use expected value calculation (see below)
```

### Expected Value Calculation

When uncertain, compute expected payoff for each action:

```
EV(Defect) = 1 + k * P(≥m others cooperate)
EV(Cooperate) = 0 + k * P(≥m-1 others cooperate)

If EV(Defect) > EV(Cooperate): DEFECT
Else: COOPERATE
```

---

## Probability Estimation

### Initializing Player Models (Round 1)

Without history, assume a **base cooperation rate** that makes the game interesting:
- Initial p_j = m/n for all other players (assumes random threshold-meeting behavior)

### Updating Player Models (Rounds 2+)

Use exponential moving average with **recency bias**:

```
After observing player j's action in round t:
- If j cooperated: p_j = α * 1.0 + (1-α) * p_j
- If j defected: p_j = α * 0.0 + (1-α) * p_j

Where α = 0.4 (high weight on recent behavior)
```

### Detecting Player Types

Classify players to sharpen predictions:
- **Consistent Cooperator**: Cooperated ≥80% of rounds → p_j = 0.9
- **Consistent Defector**: Defected ≥80% of rounds → p_j = 0.1
- **Conditional**: Otherwise, use moving average

---

## Edge Case Handling

### First Round
- Assume p_j = m/n for all others
- Compute EV as above
- **Bias toward defection** if m/n > 0.5 (others likely to cooperate enough)
- **Bias toward cooperation** if m/n ≤ 0.5 and k is large (need to help establish threshold)

### Last Round
- **Pure exploitation**: Other players cannot punish future defection
- Calculate if threshold will likely be met without me
- If yes: **DEFECT**
- If exactly m-1 expected and k > 1: **COOPERATE** (still worth it for personal gain)
- If fewer than m-1 expected: **DEFECT** (futile)

### Near-Last Rounds (final 20% of game)
- Gradually increase defection bias as punishment opportunities decrease
- Multiply cooperation probability estimates by 0.9 each round (expect others to defect more too)

---

## Exploitation Tactics

### Free-Rider Optimization
When I detect **reliable cooperators** (p_j > 0.85 for multiple players):
- Count expected guaranteed cooperators
- If guaranteed_cooperators ≥ m: **Always defect**
- If guaranteed_cooperators = m-1: Defect unless I'm the only swing vote

### Punishing Excessive Cooperation
If threshold is consistently exceeded (more than m cooperators):
- This means some cooperators are being exploited
- I should **defect more aggressively** since there's slack in the system

### Avoiding Being Exploited
If I've been cooperating and threshold is barely met (exactly m):
- Check if same players are always defecting
- If yes, **reduce my cooperation probability** to force them to step up

---

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    # Estimate cooperation probabilities
    p = estimate_probabilities(history, n, m)
    
    # Last round: pure exploitation
    if round == r:
        return DEFECT if expected_cooperators(p) >= m else evaluate_EV(p, m, k)
    
    # Calculate key probabilities
    p_threshold_without_me = P(sum >= m, excluding self, given p)
    p_pivotal = P(sum == m-1, excluding self, given p)
    p_futile = P(sum < m-1, excluding self, given p)
    
    # Decision logic
    if p_threshold_without_me > 0.7:
        return DEFECT  # Free ride
    if p_futile > 0.7:
        return DEFECT  # Don't waste contribution
    if p_pivotal > 0.3:
        return COOPERATE  # I matter
    
    # Expected value tiebreaker
    return DEFECT if EV_defect(p, m, k) > EV_cooperate(p, m, k) else COOPERATE
```

---

## Summary

**Threshold Rider** exploits by:
1. Never cooperating when others will meet the threshold anyway
2. Never cooperating when the threshold is hopeless
3. Only cooperating when pivotal (and the reward justifies it)
4. Aggressively defecting in late rounds
5. Detecting and free-riding on reliable cooperators
'''

description_EXPLOITATIVE_46 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The fundamental insight is that in a Collective Risk Dilemma, the optimal exploitative position is to **free-ride on others' cooperation** while ensuring the threshold is still met. The strategy aims to:

1. Identify and exploit cooperative players who will reliably contribute
2. Defect whenever I can safely free-ride on others reaching the threshold
3. Only cooperate when my contribution is genuinely pivotal to reaching threshold m

## Strategy Overview

I call this **"Threshold Parasite"** because it parasitizes the cooperative efforts of others, contributing only when absolutely necessary for collective survival.

---

## Decision Rules

### Information Tracked Each Round
- `coop_count[i]`: Number of times each player i has cooperated
- `coop_rate[i]`: Cooperation rate for each player i = coop_count[i] / rounds_played
- `rounds_played`: Number of completed rounds
- `reliable_cooperators`: Players with coop_rate ≥ 0.7 (after sufficient observation)

### Round-by-Round Logic

```
function decide(round, history, n, m, k, r):
    
    # FIRST ROUND: Strategic Defection
    if round == 1:
        return DEFECT
        # Rationale: Gather information about others' behavior
        # Risk: If everyone thinks this way, threshold fails
        # But: Early defection establishes me as someone who won't be exploited
    
    # LAST ROUND: Always Defect
    if round == r:
        return DEFECT
        # No future consequences, pure self-interest
    
    # MIDDLE ROUNDS: Adaptive Exploitation
    
    # Step 1: Estimate expected cooperators (excluding myself)
    expected_cooperators = sum(coop_rate[i] for i in other_players)
    
    # Step 2: Calculate my "pivotality"
    # I am pivotal if without me, expected cooperators < m
    
    if expected_cooperators >= m:
        # Others likely reach threshold without me → FREE RIDE
        return DEFECT
    
    elif expected_cooperators >= m - 1:
        # I might be the pivotal player
        # Cooperate only if k > 1 (which is guaranteed) AND
        # there's enough game left to matter
        
        rounds_remaining = r - round
        
        if rounds_remaining <= 2:
            # Near end-game: be more selfish
            # Only cooperate if I'm almost certainly pivotal
            if expected_cooperators >= m - 0.5:
                return DEFECT
            else:
                return COOPERATE
        else:
            # Enough game left: cooperate to maintain threshold
            return COOPERATE
    
    else:
        # expected_cooperators < m - 1
        # Even with my cooperation, threshold likely fails
        
        # Calculate: probability threshold is met if I cooperate
        # This requires more sophisticated probability calculation
        
        prob_threshold_met_with_me = calculate_threshold_probability(
            expected_cooperators + 1, m, coop_rates
        )
        
        if prob_threshold_met_with_me > 0.5:
            return COOPERATE
        else:
            # Threshold likely fails anyway → save my contribution
            return DEFECT
```

### Probability Calculation Helper

```
function calculate_threshold_probability(needed, m, coop_rates):
    # Estimate probability that at least m players cooperate
    # given each player's historical cooperation rate
    
    # Simplified: use expected value with variance consideration
    expected = sum(coop_rates)
    
    # If expected cooperators (including me) >= m + 1, high confidence
    if expected >= m + 1:
        return 0.9
    elif expected >= m:
        return 0.6
    elif expected >= m - 1:
        return 0.3
    else:
        return 0.1
```

---

## Edge Cases

### Edge Case 1: Round 1 (No History)
- **Action**: DEFECT
- **Rationale**: Establish non-cooperative baseline, gather information about who the "suckers" are

### Edge Case 2: Round 2 (Minimal History)
- **Action**: Look at round 1 results
  - If ≥ m-1 others cooperated: DEFECT (can likely free-ride)
  - If < m-1 others cooperated: COOPERATE (need to establish some cooperation exists)

### Edge Case 3: Last Round
- **Action**: Always DEFECT
- **Rationale**: No future reputation consequences

### Edge Case 4: Second-to-Last Round
- **Action**: Apply normal rules but with increased selfishness weight
- Others can't punish defection effectively with only one round remaining

### Edge Case 5: All Players Defecting (Coordination Failure)
- If previous 2+ rounds had < m cooperators:
  - COOPERATE with probability min(0.5, m/n)
  - Rationale: Someone needs to break the deadlock, but don't be a sucker

### Edge Case 6: m Very Close to n
- If m ≥ n-1: Cooperation becomes more necessary
- Increase cooperation rate because free-riding room is minimal

### Edge Case 7: k is Very Large
- If k > 2: Threshold success is very valuable
- Slightly increase willingness to cooperate when pivotal

---

## Exploitation Mechanisms

1. **Identify Reliable Cooperators**: Track who cooperates consistently (rate > 70%) — these are my targets for exploitation

2. **Minimum Viable Contribution**: Only cooperate when I calculate I'm the marginal player needed to hit threshold m

3. **End-Game Defection**: Guaranteed defection in final rounds when punishment is impossible

4. **Information Asymmetry Exploitation**: Use early rounds to learn others' strategies while revealing minimal information about my own

5. **Threshold Hovering**: When exactly m players are expected to cooperate, my defection extracts maximum value (get k bonus + keep my endowment)

---

## Summary Decision Table

| Condition | Action |
|-----------|--------|
| Round 1 | DEFECT |
| Last round | DEFECT |
| Expected cooperators ≥ m | DEFECT |
| Expected cooperators = m-1, mid-game | COOPERATE |
| Expected cooperators = m-1, late-game | DEFECT |
| Expected cooperators < m-1, my coop makes threshold likely | COOPERATE |
| Expected cooperators < m-1, threshold unlikely anyway | DEFECT |
| Coordination collapse (multiple failures) | COOPERATE with low probability |

This strategy maximizes personal payoff by contributing only when necessary, exploiting the cooperative nature of others, and never cooperating when it provides no marginal benefit.
'''

description_EXPLOITATIVE_47 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met**. The optimal exploitative position is to defect while exactly m others cooperate. My strategy aims to:

1. **Extract information** about opponent tendencies early
2. **Exploit predictable cooperators** by defecting when confident the threshold will be met
3. **Conditionally cooperate** only when my contribution is pivotal to reaching the threshold
4. **Punish and adapt** when exploitation fails

## Strategy: "Threshold Stalker"

### Decision Framework

Let `C_prev` = number of cooperators in the previous round (excluding myself)

#### Round 1 (No History)
- **If m ≤ n/2**: Defect
  - Rationale: With a low threshold, there's a reasonable chance others will meet it without me
- **If m > n/2**: Cooperate
  - Rationale: High threshold means my contribution is more likely pivotal; need to establish some cooperation baseline

#### Rounds 2 through (r-1) (Middle Rounds)

```
Calculate: cooperation_rate = (total cooperations by others) / (total opportunities)
Calculate: predicted_cooperators = cooperation_rate × (n-1)

IF predicted_cooperators >= m:
    # Threshold likely met without me - FREE RIDE
    DEFECT

ELSE IF predicted_cooperators >= m - 1 AND predicted_cooperators < m:
    # I'm likely pivotal - must cooperate to get bonus
    # But randomize slightly to avoid being too predictable
    COOPERATE with probability 0.85
    DEFECT with probability 0.15

ELSE IF predicted_cooperators < m - 1:
    # Threshold unlikely to be met even with my help
    # Check if cooperation might encourage others (early rounds)
    IF current_round <= r/3 AND cooperation_rate > 0.3:
        COOPERATE  # Investment in building cooperation
    ELSE:
        DEFECT  # Don't waste contribution on lost cause

ELSE:
    DEFECT  # Default to exploitation
```

#### Adaptive Adjustment Based on Recent Trends

```
recent_C = cooperators in last 2 rounds (excluding me)

IF recent_C shows increasing trend AND I defected:
    # Others may be building toward threshold - ride the wave
    Continue DEFECT if predicted to meet threshold

IF recent_C shows decreasing trend AND I cooperated:
    # Cooperation collapsing - abandon ship
    DEFECT

IF threshold was met last round AND I defected:
    # Sweet spot - keep exploiting
    DEFECT

IF threshold was NOT met last round AND I cooperated:
    # Being exploited or coordination failure
    DEFECT for next round (punishment/protection)
```

#### Final Round (Round r)
- **If C_prev >= m in round r-1**: DEFECT (exploit the pattern)
- **If C_prev = m-1 in round r-1**: COOPERATE (I'm pivotal)
- **If C_prev < m-1 in round r-1**: DEFECT (lost cause)

### Edge Cases

1. **n = 2, m = 2**: Always defect rounds 1 and r; cooperate middle rounds only if opponent cooperated previously (tit-for-tat variant)

2. **m = n-1 or m = n**: Cooperate more frequently since my contribution is almost always pivotal

3. **k is very large (k > 2)**: Lower threshold for cooperation since the reward justifies more risk

4. **Consistent threshold success without me**: Continue defecting - this is the ideal exploitation scenario

5. **Complete defection by all others**: Defect (no point being the lone cooperator when m > 1)

### Summary Pseudocode

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT if m <= n/2 else COOPERATE
    
    others_coop_rate = sum(others_cooperated) / ((round-1) * (n-1))
    expected_cooperators = others_coop_rate * (n-1)
    
    if round == r:  # Final round
        return DEFECT if expected_cooperators >= m else 
               COOPERATE if expected_cooperators >= m-1 else DEFECT
    
    if expected_cooperators >= m:
        return DEFECT  # Free ride
    elif expected_cooperators >= m - 1:
        return COOPERATE  # Pivotal
    elif expected_cooperators < m - 1 and round <= r/3 and others_coop_rate > 0.3:
        return COOPERATE  # Early investment
    else:
        return DEFECT  # Default exploitation
```

This strategy prioritizes extracting maximum value by defecting whenever the threshold is likely met without my contribution, while strategically cooperating only when pivotal.
'''

description_EXPLOITATIVE_48 = '''
# Exploitative Strategy: "Threshold Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in the Collective Risk Dilemma: when exactly m players cooperate, defectors receive the highest possible payoff (1 + k) while cooperators receive only k. The goal is to **free-ride on others' cooperation** while **never being the sucker who cooperates unnecessarily**.

## Strategy Overview

I aim to be a defector who benefits from the threshold being met by others. I only cooperate when:
1. My cooperation is absolutely necessary to meet the threshold, AND
2. I believe enough others will cooperate to make my contribution worthwhile

## Decision Rules

### Round-by-Round Logic

**Let:**
- `coop_history[i]` = cooperation rate of player i over all previous rounds
- `last_round_coops` = number of cooperators in the previous round
- `rounds_remaining` = r - current_round
- `reliable_cooperators` = players with cooperation rate > 0.6

```
FUNCTION decide(round, history):
    
    # FIRST ROUND: Defect and observe
    IF round == 1:
        RETURN DEFECT
    
    # LAST ROUND: Pure exploitation - always defect
    IF round == r:
        RETURN DEFECT
    
    # SECOND-TO-LAST ROUND: Defect (no future punishment possible)
    IF round == r - 1:
        RETURN DEFECT
    
    # COUNT RELIABLE COOPERATORS (excluding self)
    reliable_count = count players where coop_history[i] > 0.6
    
    # SCENARIO A: Enough reliable cooperators exist (≥ m)
    # Strategy: Free-ride completely
    IF reliable_count >= m:
        RETURN DEFECT
    
    # SCENARIO B: Almost enough reliable cooperators (= m - 1)
    # Strategy: Conditional cooperation - be the pivotal player sometimes
    IF reliable_count == m - 1:
        # Cooperate occasionally to keep the group viable
        # But not too often - let others bear the cost
        IF last_round_coops < m:
            # Threshold wasn't met - cooperate to "restart" cooperation
            RETURN COOPERATE
        ELSE:
            # Threshold was met without me - keep defecting
            RETURN DEFECT
    
    # SCENARIO C: Too few reliable cooperators (< m - 1)
    # Strategy: Don't waste cooperation on a failing group
    IF reliable_count < m - 1:
        # Check if threshold was met last round despite few reliable players
        IF last_round_coops >= m:
            # Others stepped up - keep defecting and hope they continue
            RETURN DEFECT
        ELSE:
            # Group is failing - no point cooperating
            RETURN DEFECT
```

### Refined Exploitation Mechanics

**Tracking Player Types:**
- **Unconditional Cooperators** (coop_rate > 0.8): Exploit maximally
- **Conditional Cooperators** (0.4 < coop_rate ≤ 0.8): Maintain carefully
- **Defectors** (coop_rate ≤ 0.4): Ignore in calculations

**Adaptive Threshold:**
```
IF (n - count(Defectors)) >= m:
    # Enough potential cooperators exist - stay as defector
    RETURN DEFECT
ELSE:
    # I might be needed - but verify before committing
    IF my_cooperation_would_likely_reach_threshold:
        RETURN COOPERATE
    ELSE:
        RETURN DEFECT
```

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | DEFECT | Gather information; no punishment yet |
| Round r (final) | DEFECT | No future consequences |
| Round r-1 | DEFECT | Opponents can't retaliate meaningfully |
| m = n-1 | DEFECT initially, then conditional | Only 1 defector slot - fight for it |
| All others defected last round | DEFECT | Group is dead, don't waste resources |
| Exactly m-1 cooperated last round | COOPERATE once | Test if group can sustain threshold |
| k is very large | Slightly more cooperative | Higher stakes justify occasional cooperation |

## Why This Strategy is Exploitative

1. **Default stance is defection** - I only cooperate when mathematically necessary
2. **Exploits unconditional cooperators** - They subsidize my free-riding
3. **Endgame defection** - Guaranteed defection in final rounds maximizes personal gain
4. **Information asymmetry** - I use others' revealed preferences against them
5. **Minimal cooperation investment** - I never cooperate more than needed to keep the threshold viable
'''

description_EXPLOITATIVE_49 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that when exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get only k. My strategy aims to **be among the defectors when the threshold is barely met**, while **avoiding being a sucker who cooperates when the threshold fails**.

This requires accurately predicting opponent behavior and positioning myself to free-ride on their cooperation.

## Strategy Overview: "Calculated Free-Rider"

### Information Tracking

Each round, I observe and maintain:
- `coop_count[t]`: number of cooperators in round t (excluding myself)
- `player_coop_rate[i]`: historical cooperation rate for each opponent i
- `recent_coop_count`: cooperation count in last 3 rounds
- `threshold_met_history`: whether threshold was met each round

### Decision Rules

#### Round 1: Defect
- **Action: D**
- Rationale: No information yet. Defecting guarantees payoff ≥ 1, while cooperating risks getting 0 if threshold fails. This also allows me to observe others' baseline behavior.

#### Middle Rounds (2 to r-1):

**Step 1: Predict expected cooperators among opponents**
```
expected_coop = sum(player_coop_rate[i] for all opponents i)
```

**Step 2: Calculate my optimal action**

```
IF expected_coop >= m:
    # Threshold likely met without me - DEFECT to free-ride
    ACTION = D
    
ELIF expected_coop >= m - 1 AND expected_coop < m:
    # I might be pivotal - conditional cooperation
    IF recent cooperation trend is increasing:
        ACTION = D  # Others are stepping up, I can free-ride
    ELIF threshold was met last round AND I defected:
        ACTION = D  # Keep exploiting
    ELSE:
        ACTION = C  # Reluctantly cooperate to potentially meet threshold
        
ELIF expected_coop < m - 1:
    # Threshold unlikely to be met even if I cooperate
    ACTION = D  # Don't throw away endowment on lost cause
```

**Step 3: Exploitation adjustment**
```
IF threshold met in ≥ 70% of recent rounds AND my cooperation rate > average opponent cooperation rate:
    # I'm being exploited - reduce cooperation
    Bias toward D
    
IF I've been defecting while threshold is consistently met:
    # Perfect exploitation scenario - continue
    ACTION = D
```

#### Last Round (r): Always Defect
- **Action: D**
- Rationale: No future consequences. Pure dominant strategy logic applies for the final round.

#### Second-to-Last Round (r-1): Strong Defection Bias
- **Action: Lean heavily toward D**
- Others may also defect anticipating the end, making threshold unlikely

### Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| First round | D | Gather information risk-free |
| Last round | D | No retaliation possible |
| Threshold never met so far | D | Don't be a lone cooperator |
| Threshold always met without me | D | Continue free-riding |
| I'm the only defector repeatedly | D | Maximum exploitation achieved |
| Everyone defecting | D | Cooperation won't help alone |
| m = n-1 (high threshold) | Usually D | Need almost everyone; risky to cooperate |
| m = 2 (low threshold) | D | Easy for others to meet without me |

### Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == 1 or round == r:
        return DEFECT
    
    expected_others_coop = estimate_opponent_cooperation(history)
    
    if expected_others_coop >= m:
        return DEFECT  # Free-ride
    
    if expected_others_coop < m - 1:
        return DEFECT  # Lost cause
    
    # Pivotal zone: expected_others_coop in [m-1, m)
    if being_exploited(history):
        return DEFECT
    
    if threshold_trending_up(history):
        return DEFECT  # Others will cover it
    
    # Grudging cooperation only when truly necessary
    return COOPERATE with probability (m - expected_others_coop)
```

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever others are likely to meet threshold
2. **Minimizes sucker payoffs**: Refuses to cooperate when threshold will fail anyway
3. **Exploits cooperative opponents**: Identifies and takes advantage of reliable cooperators
4. **Endgame exploitation**: Guarantees defection when no punishment is possible
5. **Adaptive learning**: Adjusts predictions based on observed behavior to optimize exploitation
'''

description_EXPLOITATIVE_50 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met** and punishes everyone when it isn't. My strategy aims to:
1. Maximize rounds where I defect while others cooperate (payoff = 1 + k)
2. Ensure the threshold is met often enough to collect rewards
3. Exploit predictable cooperators while avoiding being exploited myself

## Strategy: "Calculated Brinksmanship"

### Decision Framework

The strategy tracks cooperation rates and strategically positions itself to be the marginal defector—cooperating only when necessary to meet the threshold, and defecting whenever there's slack.

### Key Variables to Track
- `coop_rate[i]` = historical cooperation rate of player i
- `last_round_coops` = number of cooperators in the previous round
- `rounds_remaining` = r - current_round
- `threshold_met_rate` = fraction of past rounds where ≥m cooperated

---

### Decision Rules

#### Round 1 (Cold Start)
**Defect.**

Rationale: No information yet. If others are optimistic cooperators, I profit. If threshold fails, I lose only the bonus (not my endowment). This also establishes me as someone who doesn't cooperate freely.

#### Last Round (Round r)
**Defect.**

Rationale: No future punishment possible. Pure one-shot logic applies—defection strictly dominates if I believe threshold will be met, and if not, I still keep my endowment.

#### Middle Rounds (Rounds 2 to r-1)

**Step 1: Estimate expected cooperators this round**

```
predicted_coops = sum(coop_rate[i] for all other players i)
```

**Step 2: Determine my action based on predicted slack**

```
slack = predicted_coops - m

if slack >= 1:
    # Threshold likely met without me → DEFECT (free-ride)
    action = DEFECT
    
elif slack >= 0 and slack < 1:
    # Threshold is borderline → probabilistic cooperation
    # Cooperate with probability equal to (1 - slack)
    # This makes me the "reluctant cooperator"
    action = COOPERATE with probability (1 - slack)
    
elif slack < 0:
    # Threshold unlikely to be met
    if |slack| <= 1 and threshold_met_rate > 0.3:
        # Close to threshold, others might step up → COOPERATE
        # (investing to keep the cooperative norm alive)
        action = COOPERATE
    else:
        # Too far from threshold → DEFECT (don't throw away endowment)
        action = DEFECT
```

**Step 3: Late-game adjustment**

```
if rounds_remaining <= 3:
    # Increase defection probability as end approaches
    # Others can't punish effectively
    if action == COOPERATE:
        action = DEFECT with probability (3 - rounds_remaining) / 3
```

**Step 4: Exploit detected "suckers"**

```
# Identify unconditional cooperators (coop_rate > 0.8 after 3+ rounds)
reliable_coops = count(players where coop_rate[i] > 0.8)

if reliable_coops >= m:
    # Enough suckers to meet threshold without me
    action = DEFECT
```

---

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | Probe environment, protect endowment |
| Last round | DEFECT | No future consequences |
| m = n - 1 | COOPERATE if my coop_rate is lowest | Can't free-ride if everyone is needed |
| All others defecting (2+ rounds) | DEFECT | Don't waste endowment on lost cause |
| Threshold consistently met with slack | DEFECT | Exploit the surplus cooperators |
| n - m = 1 (only 1 can defect) | Defect if I have lowest coop_rate among players who defected last round | Be the one free-rider |

---

### Pseudocode Summary

```
function decide(game_state):
    if current_round == 1:
        return DEFECT
    
    if current_round == r:
        return DEFECT
    
    # Calculate expected cooperators without me
    predicted_coops = sum(cooperation_rates of other players)
    reliable_coops = count(other players with coop_rate > 0.8)
    
    if reliable_coops >= m:
        return DEFECT
    
    slack = predicted_coops - m
    
    if slack >= 1:
        return DEFECT
    elif slack >= 0:
        return COOPERATE with probability (1 - slack)
    elif slack > -1 and threshold_met_rate > 0.3:
        return COOPERATE
    else:
        return DEFECT
    
    # Apply late-game defection bias
    if rounds_remaining <= 3 and action == COOPERATE:
        return DEFECT with probability (4 - rounds_remaining) / 4
```

---

### Why This Strategy is Exploitative

1. **Never cooperates unnecessarily**: Only contributes when the marginal value is high
2. **Identifies and exploits reliable cooperators**: Tracks who can be counted on, then free-rides on them
3. **Endgame defection**: Extracts maximum value when punishment is impossible
4. **Probabilistic masking**: Avoids being easily classified as a pure defector, making retaliation harder
5. **Abandons lost causes**: Doesn't waste endowment when threshold is unreachable
'''

description_EXPLOITATIVE_51 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when others cooperate enough**. The optimal exploitative approach is to defect whenever I can reasonably expect others to meet the threshold without me, and only cooperate when my contribution is genuinely pivotal. I'll use observed behavior to estimate opponent cooperation rates and exploit predictable patterns.

## Strategy: "Threshold Parasite"

### Key Variables Tracked
- `coop_rate[i]`: Running estimate of each player i's cooperation probability
- `round_count`: Current round number
- `total_cooperators_history`: List of cooperation counts per round

### Decision Rules

#### Round 1: Defect
- **Rationale**: No information yet. Defecting guarantees payoff of 1, and if others cooperate enough, I get 1 + k. Starting with defection also helps identify who the "natural cooperators" are.

#### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Estimate expected cooperators (excluding myself)**

Calculate `expected_cooperators = Σ coop_rate[i]` for all other players.

**Step 2: Apply decision rule**

```
IF expected_cooperators >= m + 0.5:
    DEFECT  (free-ride: threshold likely met without me)
    
ELIF expected_cooperators >= m - 1 AND expected_cooperators < m + 0.5:
    # I might be pivotal - cooperate with probability based on how critical I am
    pivot_probability = (m - expected_cooperators) / 1.5
    IF pivot_probability > 0.6:
        COOPERATE
    ELSE:
        DEFECT
        
ELIF expected_cooperators < m - 1:
    DEFECT  (threshold unlikely even with my help - save my endowment)
```

**Step 3: Exploit detected patterns**

- If I detect players using alternating or round-robin strategies, predict their next move and adjust expected_cooperators accordingly
- If a player has cooperated in ALL previous rounds, weight their coop_rate at 0.95 (assume reliable cooperator to exploit)
- If total cooperators has been exactly m for 2+ consecutive rounds, DEFECT (stable coalition exists without me)

#### Last Round (Round r): Almost Always Defect

```
IF expected_cooperators >= m:
    DEFECT (no future rounds to worry about reputation)
ELIF expected_cooperators >= m - 1 AND k > 2:
    COOPERATE (only if reward is high enough to justify being pivotal)
ELSE:
    DEFECT
```

### Update Rules (After Each Round)

```
FOR each player i:
    observed = 1 if player i cooperated, else 0
    # Exponential moving average with recency bias
    coop_rate[i] = 0.7 * coop_rate[i] + 0.3 * observed
```

### Edge Case Handling

| Situation | Action |
|-----------|--------|
| n = 2, m = 2 | Must cooperate if I want threshold met; cooperate rounds 1 to r-1, defect round r |
| m = n - 1 | Only one player can free-ride; defect until others establish I won't cooperate, then occasionally cooperate to keep threshold achievable |
| k is very large (k > 3) | Be slightly more willing to cooperate when pivotal (lower pivot threshold to 0.5) |
| All players defected last round | Defect (no point cooperating alone) |
| Exactly m-1 others cooperated last round | They might be waiting for one more - defect and see if they persist |

### Exploitation Mechanisms

1. **Cooperator Identification**: Players who cooperate early and consistently get exploited - I count on them and defect.

2. **Reputation Manipulation**: By occasionally cooperating in middle rounds when pivotal, I avoid being identified as a pure defector that others might punish.

3. **End-game Betrayal**: Last round is always defection-heavy since there's no future consequence.

4. **Threshold Hovering**: If exactly m players (including me) have been cooperating, I can test defecting - the others may continue cooperating out of inertia.

### Pseudocode Summary

```
function decide(round, history, params):
    if round == 1:
        return DEFECT
    
    update_cooperation_rates(history)
    expected = sum(coop_rate[i] for i in other_players)
    
    if round == r:  # last round
        return DEFECT if expected >= m else (COOPERATE if expected >= m-1 and k > 2 else DEFECT)
    
    if expected >= m + 0.5:
        return DEFECT
    elif expected >= m - 1:
        return COOPERATE if (m - expected) / 1.5 > 0.6 else DEFECT
    else:
        return DEFECT
```

This strategy maximizes personal payoff by contributing only when absolutely necessary while parasitizing the cooperation of more altruistic or threshold-focused players.
'''

description_EXPLOITATIVE_52 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met** (payoff of 1+k) over **cooperating when the threshold is met** (payoff of k). My strategy aims to maximize the probability that exactly m players cooperate—and that I'm not one of them.

## Strategy: "Threshold Parasite"

### Decision Rules

**Round t Decision Algorithm:**

```
1. Calculate cooperation_rate = (total C plays by others) / (total opportunities)
   - In round 1, assume cooperation_rate = m/n (neutral prior)

2. Estimate expected_cooperators_without_me:
   - expected_cooperators = cooperation_rate × (n-1)

3. Calculate my_pivotality:
   - If expected_cooperators < m-1: I'm not pivotal (threshold fails regardless)
   - If expected_cooperators >= m: I'm not pivotal (threshold met without me)
   - If m-1 <= expected_cooperators < m: I'm potentially pivotal

4. Decision logic:
   
   IF rounds_remaining == 1 (final round):
       DEFECT (no future consequences)
   
   ELSE IF expected_cooperators >= m:
       DEFECT (free-ride on others' cooperation)
   
   ELSE IF expected_cooperators < m - 1:
       DEFECT (threshold unreachable, save my endowment)
   
   ELSE (I'm in the pivotal zone: m-1 <= expected_cooperators < m):
       - Calculate cooperation_deficit = m - expected_cooperators
       - Cooperate with probability = min(1, cooperation_deficit / uncertainty_factor)
       - Where uncertainty_factor = max(1, sqrt(rounds_played))
```

### Detailed Mechanics

**Tracking Opponent Behavior:**
- Maintain per-player cooperation history: `player_coop_rate[j]` for each opponent j
- Identify "reliable cooperators" (coop_rate > 0.7) and "reliable defectors" (coop_rate < 0.3)

**Refined Expected Cooperators Calculation:**
```
expected_cooperators = sum(player_coop_rate[j] for all j ≠ me)
```

**Adaptive Threshold for Cooperation:**
```
IF count(reliable_cooperators) >= m:
    Always DEFECT (let them carry the burden)

IF count(reliable_cooperators) == m-1:
    Cooperate only with probability 1/(n - m + 1)
    (Share pivotal burden among non-reliable-cooperators)

IF count(reliable_cooperators) < m-1:
    Cooperate with probability (m - count(reliable_cooperators)) / (n - count(reliable_cooperators))
```

### Edge Case Handling

**Round 1:**
- No history available
- Cooperate with probability `(m-1)/(n-1)` 
- This is slightly below fair share, betting others will over-cooperate initially

**Final Round (round r):**
- Pure defection (no future to protect)
- Exception: If I'm certainly pivotal AND k > 1, still defect (1 > 0, and k is lost either way if others also defect in anticipation)

**When m is very small relative to n:**
- Bias heavily toward defection; likely enough altruists exist

**When m is close to n:**
- More willing to cooperate early to establish threshold-meeting patterns
- Defect more aggressively once patterns are established

**When k is very large:**
- Others have stronger incentive to ensure threshold is met
- I can defect more confidently

### Exploitation Mechanisms

1. **Sucker Detection:** If specific players always cooperate regardless of my behavior, always defect—they'll cover for me.

2. **Cascade Exploitation:** If cooperation collapses (rate drops below m/n), immediately defect and save endowment rather than trying to rescue the round.

3. **Late-Game Defection:** Beginning at round `r-2`, start transitioning toward pure defection, as opponents lose leverage.

4. **Threshold Hovering:** Ideal outcome is exactly m cooperators, none of whom are me. Adjust my cooperation probability to target this.
'''

description_EXPLOITATIVE_53 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met**. A defector gets payoff `1 + k` when exactly `m` others cooperate, while cooperators only get `k`. My strategy aims to:

1. **Defect whenever I predict the threshold will be met without me**
2. **Cooperate only when my contribution is pivotal** (i.e., exactly `m-1` others will cooperate)
3. **Exploit predictable cooperators ruthlessly**
4. **Manipulate others into becoming reliable cooperators I can exploit**

---

## Strategy: "Threshold Parasite"

### Phase 1: Classification (Rounds 1 to `min(r/4, 5)`)

**Goal:** Identify player types while appearing conditionally cooperative.

**Round 1 Decision:**
- If `m ≤ n/2`: **Defect** (likely enough natural cooperators exist)
- If `m > n/2`: **Cooperate** (need to establish some cooperation baseline)

**Subsequent Early Rounds:**
- Track each player's cooperation rate: `coop_rate[i] = cooperations / rounds_played`
- Classify players:
  - **Reliable Cooperators:** `coop_rate > 0.7`
  - **Conditional:** `0.3 ≤ coop_rate ≤ 0.7`
  - **Defectors:** `coop_rate < 0.3`

**My behavior during classification:**
- Cooperate if `reliable_cooperators < m - 1` (need to build cooperation)
- Defect otherwise (test if threshold met without me)

---

### Phase 2: Exploitation (Rounds `min(r/4, 5) + 1` to `r - 3`)

**Core Decision Rule:**

```
Let expected_cooperators = Σ(coop_rate[i]) for all i ≠ me

If expected_cooperators ≥ m:
    DEFECT  # Free-ride on others
    
Else if expected_cooperators is in [m-1.5, m-0.5]:
    # Pivotal zone - my contribution might matter
    If last_round_cooperators == m - 1:
        COOPERATE  # I'm likely pivotal
    Else if last_round_cooperators >= m:
        DEFECT  # They don't need me
    Else:
        COOPERATE with probability (m - expected_cooperators)
        
Else if expected_cooperators < m - 1.5:
    # Not enough cooperators even with me
    DEFECT  # Don't waste contribution on lost cause
```

**Adaptive Adjustments:**

After each round, update predictions:
- If threshold was met when I defected: **reinforce defection** (free-ride working)
- If threshold failed when I defected and `cooperators == m - 1`: **slightly increase cooperation probability** (I was pivotal and missed it)
- If threshold failed when I cooperated: **identify who defected unexpectedly**, reduce their predicted cooperation rate by 50%

---

### Phase 3: Endgame (Final 3 rounds)

**Round `r - 2`:**
- If I've been cooperating: **Defect** (signal shift, see who follows)
- If I've been defecting: Continue defecting

**Round `r - 1`:**
- **Defect** unless `reliable_cooperators == m - 1` exactly (then cooperate to get `k`)

**Final Round `r`:**
- **Always Defect** - No future punishment possible, pure free-riding

---

## Edge Case Handling

| Scenario | Action |
|----------|--------|
| `m = n - 1` (need almost everyone) | Cooperate early, defect once `m` reliable cooperators identified |
| `m = 2` (low threshold) | Defect heavily, only cooperate if seeing 0-1 cooperators consistently |
| All players defecting | Defect (cooperation is futile) |
| All players cooperating | Defect aggressively (maximum exploitation) |
| Exactly `m` cooperators consistently | Defect and hope to be the `m+1`th free-rider |
| Erratic opponents | Use 3-round moving average for prediction |

---

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT if m <= n/2 else COOPERATE
    
    if round >= r - 2:
        return DEFECT  # Endgame defection
    
    expected_coop = sum(cooperation_rate(player) for player != me)
    
    if expected_coop >= m:
        return DEFECT
    elif expected_coop < m - 1.5:
        return DEFECT
    else:
        # Pivotal zone
        if last_round_cooperators == m - 1:
            return COOPERATE
        else:
            return DEFECT with probability 0.3, else COOPERATE
```

---

## Why This Exploits Others

1. **Against unconditional cooperators:** I free-ride every round, getting `1 + k` while they get `k`
2. **Against tit-for-tat types:** I cooperate just enough to keep them cooperating, then defect when safe
3. **Against threshold strategies:** I position myself as the "extra" player who defects when threshold is met
4. **Against other exploiters:** We both defect, getting `1` each - no worse than mutual cooperation minus my contribution
'''

description_EXPLOITATIVE_54 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride whenever possible** while ensuring the cooperation threshold is still met by others. The key insight is that defecting when exactly m others cooperate yields the maximum payoff (1 + k), while cooperating only yields k. My goal is to be among the defectors when the threshold is barely met.

## Strategy Overview

I will attempt to position myself as a reliable defector while manipulating others into filling the cooperation threshold. I cooperate only when absolutely necessary to prevent collective disaster, and I exploit any predictable cooperative behavior from opponents.

---

## Decision Rules

### Round 1: Probe with Defection

**Action: DEFECT**

Rationale: Starting with defection reveals who the natural cooperators are without contributing myself. If threshold is met without me, I've gained maximum payoff. If it fails, I gather information about the population's cooperative tendency.

### Rounds 2 through (r-1): Adaptive Free-Riding

Calculate from previous round:
- `cooperators_last_round` = number of players who played C
- `threshold_met` = (cooperators_last_round ≥ m)

**Decision Logic:**

```
IF cooperators_last_round >= m + 1:
    # Plenty of cooperators - safe to defect
    ACTION = DEFECT

ELSE IF cooperators_last_round == m:
    # Threshold exactly met
    IF I cooperated last round:
        # Test if I can drop out - someone else might step up
        ACTION = DEFECT
    ELSE:
        # I was already free-riding successfully
        ACTION = DEFECT

ELSE IF cooperators_last_round == m - 1:
    # One short of threshold
    IF I defected last round:
        # I'm the swing player - cooperate reluctantly
        ACTION = COOPERATE
    ELSE:
        # Others failed even with my cooperation - defect to punish
        ACTION = DEFECT

ELSE IF cooperators_last_round < m - 1:
    # Far below threshold - cooperation is futile waste
    # Calculate "cooperation ratio" over all previous rounds
    avg_cooperators = average cooperators across all past rounds
    IF avg_cooperators >= m - 1:
        # Temporarily low - cooperate to restore threshold
        ACTION = COOPERATE
    ELSE:
        # Population is chronically uncooperative - don't be a sucker
        ACTION = DEFECT
```

### Final Round (Round r): Pure Defection

**Action: DEFECT**

Rationale: No future rounds exist to punish my defection. Others cannot retaliate. This is the dominant strategy regardless of history.

---

## Edge Case Handling

### Edge Case 1: n = m (everyone must cooperate)
If all players must cooperate for threshold, shift to **Grim Trigger**: cooperate until anyone defects, then permanently defect. Exploitation is impossible without collective failure.

### Edge Case 2: m = 1 (only one cooperator needed)
Always defect. Let someone else be the single sucker.

### Edge Case 3: r = 2 (only two rounds)
Round 1: Defect (probe)
Round 2: Defect (endgame)

### Edge Case 4: Threshold never met in early rounds
If threshold fails for first ⌈r/3⌉ rounds consecutively, switch to **permanent defection** - the population is too uncooperative to save.

---

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    if m == 1:
        return DEFECT
    
    if n == m:
        if any player defected in history:
            return DEFECT
        else:
            return COOPERATE
    
    last_round_cooperators = count_cooperators(history, round - 1)
    my_last_action = get_my_action(history, round - 1)
    
    if last_round_cooperators >= m + 1:
        return DEFECT
    else if last_round_cooperators >= m:
        return DEFECT
    else if last_round_cooperators == m - 1:
        if my_last_action == DEFECT:
            return COOPERATE
        else:
            return DEFECT
    else:
        avg_coop = average_cooperators(history)
        if avg_coop >= m - 1:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defaults to defection whenever threshold seems achievable without me
2. **Punishes cooperation collapse**: Refuses to be the lone sucker when others won't contribute
3. **Endgame exploitation**: Guarantees defection in final round where punishment is impossible
4. **Adaptive parasitism**: Only cooperates when absolutely necessary to maintain the public good that benefits my defection
'''

description_EXPLOITATIVE_55 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that in this game, **defectors get the best payoff when exactly m cooperators exist**. My strategy aims to be a defector in rounds where I predict exactly m others will cooperate, while cooperating only when necessary to prevent collective failure (which hurts me too). I want to free-ride on the threshold being met by others.

## Strategy Overview

I will maintain a probabilistic model of each player's cooperation tendency, predict whether the threshold will be met without me, and exploit opportunities to defect while the group succeeds. In later rounds, I become increasingly selfish as the game approaches its end.

---

## Decision Rules

### Round 1: Calibrated Defection

**Action: DEFECT**

Rationale: I need information about other players' tendencies. By defecting in round 1, I:
- Collect maximum private payoff if threshold is met anyway
- Learn who the "natural cooperators" are
- Establish myself as a potential defector (making others less likely to expect my cooperation)

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Update Player Models**

For each player j ≠ i, calculate:
```
cooperation_rate[j] = (times j cooperated) / (rounds played)
```

**Step 2: Predict Threshold Outcome Without Me**

Calculate expected cooperators excluding myself:
```
expected_cooperators = Σ cooperation_rate[j] for all j ≠ i
```

**Step 3: Decision Logic**

```
IF expected_cooperators >= m + 0.5:
    # Threshold likely met without me → DEFECT (free-ride)
    ACTION = DEFECT

ELSE IF expected_cooperators >= m - 0.5:
    # Threshold is borderline → Strategic calculation
    # My cooperation might be pivotal
    
    IF (rounds_remaining <= 2) OR (my_cooperation_rate > median_cooperation_rate):
        # Late game or I've been "too nice" → DEFECT
        ACTION = DEFECT
    ELSE:
        # Cooperate to maintain threshold, but track this as a "forced" cooperation
        ACTION = COOPERATE

ELSE IF expected_cooperators >= m - 1.5:
    # Threshold barely possible with my help
    # Cooperate only if losing k hurts more than keeping 1
    
    IF k > 1.5:
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT

ELSE:
    # Threshold unlikely even with my cooperation → DEFECT
    # Don't throw away my endowment on a lost cause
    ACTION = DEFECT
```

**Step 4: Exploitation Adjustment**

After determining initial action, apply exploitation modifier:
```
IF ACTION == COOPERATE:
    # Check if I can get away with defecting
    # Count "reliable cooperators" (cooperation_rate > 0.7)
    reliable_count = count(j where cooperation_rate[j] > 0.7)
    
    IF reliable_count >= m:
        # Enough suckers to carry the load → DEFECT instead
        ACTION = DEFECT
```

### Final Round (Round r): Pure Defection

**Action: DEFECT**

Rationale: No future rounds mean no retaliation possible. Always defect in the final round regardless of other considerations. This is the classic backward induction outcome - there's no strategic benefit to cooperating when the game ends.

---

## Edge Case Handling

### Edge Case 1: Very Small Games (n = 2, m = 2)
Both players must cooperate for threshold. Here, defect every round - if both must cooperate, and I can't trust the other, the threshold will rarely be met anyway. Collect my guaranteed 1 per round.

### Edge Case 2: m Very Close to n (m = n-1 or m = n-2)
High threshold requirements mean failure is likely. Defect more aggressively since cooperation is rarely rewarded.

### Edge Case 3: Very High k (k > 3)
When rewards are massive, I'm slightly more willing to cooperate to ensure threshold is met, but still defect if reliable cooperators exist.

### Edge Case 4: All Players Have Been Defecting
If average cooperation rate across all players < m/n, expect collective failure. Defect and preserve my endowment.

### Edge Case 5: I've Been "Marked" as a Defector
If others might be punishing me (their cooperation dropped after I defected), continue defecting - trying to recover reputation is costly and they might defect on me anyway.

---

## Pseudocode Summary

```python
def threshold_parasite(round_num, total_rounds, history, n, m, k):
    
    # Final round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # Round 1: defect to gather information
    if round_num == 1:
        return DEFECT
    
    # Calculate cooperation rates for all other players
    coop_rates = calculate_cooperation_rates(history)
    expected_coop = sum(coop_rates.values())
    reliable_count = count_reliable_cooperators(coop_rates, threshold=0.7)
    
    # If enough reliable cooperators exist, free-ride
    if reliable_count >= m:
        return DEFECT
    
    # If threshold likely met without me, free-ride
    if expected_coop >= m + 0.5:
        return DEFECT
    
    # If threshold impossible even with me, don't waste resources
    if expected_coop < m - 1.5:
        return DEFECT
    
    # Borderline case: cooperate only if necessary and worthwhile
    if expected_coop >= m - 0.5:
        rounds_remaining = total_rounds - round_num
        if rounds_remaining <= 2:
            return DEFECT  # End-game defection
        else:
            return COOPERATE  # Maintain threshold possibility
    
    # Near-threshold: cooperate only if k justifies it
    if k > 1.5:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-riding priority**: I always check if others will meet the threshold without me before cooperating
2. **Information extraction**: Round 1 defection identifies who the "suckers" are
3. **End-game betrayal**: Guaranteed defection in final rounds when punishment is impossible
4. **Selective cooperation**: I only cooperate when I'm genuinely pivotal AND it's profitable
5. **Reliability exploitation**: Players who consistently cooperate become my unwitting benefactors
'''

description_EXPLOITATIVE_56 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach recognizes a fundamental asymmetry: if exactly m players are needed to cooperate, I want to be among the (n-m) defectors who free-ride on others' contributions. My strategy aims to manipulate others into being the "suckers" who cooperate while I harvest the maximum payoff of (1 + k).

## Decision Rules

### Information Tracking

Each round, I maintain:
- `coop_history[i]`: count of times player i has cooperated
- `total_coops[t]`: total cooperators in round t
- `threshold_met[t]`: whether m threshold was reached in round t
- `rounds_remaining`: r - current_round

### Round-by-Round Logic

**FIRST ROUND:**
```
IF m/n > 0.6:
    COOPERATE  # Threshold is high, need to seed cooperation
ELSE:
    DEFECT     # Start by testing if others will carry the load
```

**MIDDLE ROUNDS (rounds 2 through r-1):**

```
# Calculate cooperation tendency of others
other_coop_rate = (total cooperations by others) / ((current_round - 1) * (n - 1))

# Estimate probability threshold will be met without me
# Based on observed cooperation rates
expected_other_coops = other_coop_rate * (n - 1)

IF expected_other_coops >= m:
    # Others likely to hit threshold without me - EXPLOIT
    DEFECT
    
ELIF expected_other_coops >= m - 1 AND expected_other_coops < m:
    # I might be pivotal - cooperate only if worth it
    # But try to defect occasionally to test
    IF last_round_had_exactly_m_cooperators AND I_cooperated_last_round:
        # Test if others will cover for me
        DEFECT
    ELSE:
        COOPERATE
        
ELIF expected_other_coops < m - 1:
    # Threshold unlikely to be met even if I cooperate
    # Defect unless we need to build cooperation momentum
    IF rounds_remaining > r/2 AND threshold_met in fewer than 30% of past rounds:
        # Strategic cooperation to signal and encourage others
        COOPERATE
    ELSE:
        DEFECT
```

**LATE GAME ADJUSTMENT (final 20% of rounds):**
```
# Become more exploitative as end approaches
IF expected_other_coops >= m - 0.5:
    DEFECT  # Lower threshold for defection
ELIF threshold consistently met (>70% of recent rounds):
    DEFECT  # Exploit established cooperation
ELSE:
    # Threshold failing - only cooperate if absolutely critical
    IF expected_other_coops >= m - 1:
        COOPERATE
    ELSE:
        DEFECT
```

**FINAL ROUND:**
```
# Pure exploitation - no future to protect
IF observed cooperation rate suggests m-1 or more others will cooperate:
    DEFECT
ELSE:
    DEFECT  # No point cooperating if threshold won't be met anyway
```

### Adaptive Exploitation Patterns

**Identifying "Reliable Cooperators":**
```
FOR each player j:
    IF coop_history[j] / rounds_played > 0.7:
        Mark as "reliable_cooperator"
        
IF count(reliable_cooperators) >= m:
    ALWAYS DEFECT (except for rare testing)
```

**Detecting Other Exploiters:**
```
IF my cooperation rate is in top 50% AND threshold frequently fails:
    # Others are also trying to exploit
    # Reduce cooperation to punish, but not below critical level
    Cooperate only when I was pivotal in threshold being met
```

## Edge Case Handling

| Scenario | Action |
|----------|--------|
| n = m + 1 (only one can defect) | Aggressively compete to be the defector; defect if I've cooperated more than average |
| m = n - 1 (nearly everyone needed) | Cooperate early, then defect once patterns establish |
| k is very large (k > 3) | More willing to cooperate to ensure threshold met |
| r is small (r < 5) | More aggressive defection; less time for punishment |
| Perfect threshold (exactly m cooperators every round) | Defect immediately to test stability |

## Summary Pseudocode

```
function decide(round, history, params):
    if round == r:
        return DEFECT
    
    expected_others = estimate_other_cooperators(history)
    reliable_count = count_reliable_cooperators(history)
    
    if reliable_count >= m:
        return DEFECT
    
    if expected_others >= m:
        return DEFECT
    
    if expected_others >= m - 1:
        if should_test_defection(history):
            return DEFECT
        return COOPERATE
    
    if round < r * 0.3 and threshold_success_rate(history) < 0.3:
        return COOPERATE  # Seed cooperation
    
    return DEFECT
```

This strategy maximizes personal gain by free-riding when possible while maintaining just enough cooperation to keep the threshold mechanism functioning when others won't carry the full load.
'''

description_EXPLOITATIVE_57 = '''
# Exploitative Strategy: "Threshold Predator"

## Core Philosophy

The fundamental insight is that this game rewards free-riding *when others cooperate enough*. My goal is to:
1. **Defect whenever I can get away with it** (when others will hit the threshold without me)
2. **Cooperate only when my contribution is pivotal** (when defecting would cause collective failure that hurts me too)
3. **Manipulate others into cooperating more** by appearing conditionally cooperative early, then exploiting their patterns

## Decision Rules

### Round 1: Probe with Cooperation
**Action: Cooperate**

Rationale: This serves multiple purposes:
- Establishes me as a "potential cooperator" to opponents tracking reputations
- Gathers crucial information about the population's cooperative tendencies
- In early rounds, building a cooperative image has long-term exploitation value

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Count reliable cooperators from previous round**
Let `prev_cooperators` = number of players who cooperated last round (excluding myself)

**Step 2: Apply decision logic**

```
IF prev_cooperators >= m:
    # Others hit threshold without me - DEFECT and free-ride
    ACTION: DEFECT
    
ELIF prev_cooperators == m - 1:
    # I am exactly pivotal - must cooperate or lose k
    ACTION: COOPERATE
    
ELIF prev_cooperators < m - 1:
    # Not enough cooperators even with me
    # Probabilistic cooperation to avoid total collapse while minimizing cost
    
    cooperation_probability = (round_number / r) * (prev_cooperators / m)
    
    # This increases cooperation as:
    # - Game progresses (signal willingness to help)
    # - More others are close to threshold
    
    IF random() < cooperation_probability:
        ACTION: COOPERATE
    ELSE:
        ACTION: DEFECT
```

**Step 3: Reputation Decay Adjustment**

If I've defected for 3+ consecutive rounds AND threshold has been met each time:
- Others may be "covering" for me consistently
- Continue defecting - this is ideal exploitation

If I've defected for 3+ consecutive rounds AND threshold has NOT been met:
- Cooperate once to "reset" and probe if others will respond

### Final Round (Round r): Pure Defection
**Action: DEFECT (always)**

Rationale: No future rounds exist to punish defection. Even if this causes threshold failure, there's no reputational cost. The payoff of 1 (keeping endowment) vs 0 (cooperating in failed threshold) or even vs k (cooperating in successful threshold with k > 1) - defecting gives me 1+k if others succeed, 1 if they fail. Cooperating gives me k if we succeed, 0 if we fail. Defecting strictly dominates in expectation when I'm not pivotal.

**Exception**: If exactly (m-1) others cooperated in round (r-1), cooperate in round r since I'm likely pivotal.

### Edge Case Handling

**If n = m (everyone must cooperate for threshold):**
- Cooperate in all rounds except the last
- In final round, defect anyway (mutual defection likely, but I lose nothing extra)

**If m is very small relative to n (easy threshold):**
- Defect more aggressively from round 2 onward
- Others will likely cover the threshold

**If observing consistent mutual defection (threshold never met):**
- Gradually increase cooperation probability to (m/n) to be "my fair share"
- This minimizes losses in a pessimistic equilibrium

**If one specific player always cooperates (identified sucker):**
- Factor them into my "reliable cooperator" count
- Exploit their consistency by defecting more

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    my_prev_actions = history.my_actions
    others_prev_cooperators = history.count_others_cooperating(round - 1)
    
    # Final round: almost always defect
    if round == r:
        if others_prev_cooperators == m - 1:
            return COOPERATE  # Pivotal
        return DEFECT
    
    # First round: cooperate to probe
    if round == 1:
        return COOPERATE
    
    # Middle rounds: exploit or contribute based on threshold math
    if others_prev_cooperators >= m:
        return DEFECT  # Free-ride
    elif others_prev_cooperators == m - 1:
        return COOPERATE  # Pivotal
    else:
        prob = (round / r) * (others_prev_cooperators / m)
        return COOPERATE if random() < prob else DEFECT
```

## Why This Is Exploitative

1. **Maximizes free-riding**: Defects whenever the threshold is met without me
2. **Minimizes costly cooperation**: Only cooperates when pivotal or when building early reputation
3. **Exploits cooperators**: Treats consistent cooperators as resources to be milked
4. **End-game betrayal**: Guaranteed defection in final round extracts maximum value
5. **Adaptive parasitism**: Adjusts based on how much slack others provide
'''

description_EXPLOITATIVE_58 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach is to **free-ride on others' cooperation while contributing just enough to prevent collective failure when necessary**. The key insight is that if exactly m players are willing to cooperate, a defector gets payoff k+1 while cooperators get only k. My goal is to be that defector as often as possible, while avoiding the catastrophe of falling below threshold.

## Strategy Overview

I will maintain a **reputation model** of each opponent and exploit predictable cooperators ruthlessly, only stepping in to cooperate when I calculate that the threshold will otherwise fail and my cooperation is pivotal.

---

## Decision Rules

### Information Tracked Each Round
- `coop_rate[i]` = historical cooperation rate of player i
- `expected_cooperators` = Σ(coop_rate[i]) for all opponents
- `rounds_remaining` = r - current_round
- `my_coop_count` = how many times I've cooperated

### Primary Decision Logic

```
function decide(round, history):
    
    # Calculate expected cooperators (excluding myself)
    expected_others = sum(coop_rate[i] for all opponents)
    
    # RULE 1: Last Round - Always Defect
    if round == r:
        return DEFECT
    
    # RULE 2: Threshold Guaranteed Without Me
    if expected_others >= m + 0.5:
        return DEFECT  # Free ride confidently
    
    # RULE 3: Threshold Impossible Even With Me
    if expected_others < m - 1.5:
        return DEFECT  # Don't waste contribution
    
    # RULE 4: I Am Pivotal (threshold is fragile)
    if m - 1.5 <= expected_others < m + 0.5:
        return pivot_decision(round, expected_others)
    
    return DEFECT  # Default to exploitation
```

### Pivot Decision (When My Cooperation Might Matter)

```
function pivot_decision(round, expected_others):
    
    # Calculate probability threshold is met without me
    p_success_without_me = estimate_threshold_probability(expected_others, m)
    
    # Expected value calculation
    EV_defect = p_success_without_me * (k + 1) + (1 - p_success_without_me) * 1
    EV_coop = p_success_with_me * k + (1 - p_success_with_me) * 0
    
    # Only cooperate if EV is higher AND early enough to matter
    if EV_coop > EV_defect AND rounds_remaining > r/4:
        return COOPERATE
    else:
        return DEFECT
```

### First Round Special Case

```
function first_round_decision():
    # Start by defecting to observe others
    # Exception: if m/n > 0.7, threshold is demanding - test waters with cooperation
    if m/n > 0.7:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **Round 1** | DEFECT (usually) | Gather information on opponents |
| **Last round** | DEFECT (always) | No future consequences |
| **Last 2-3 rounds** | Lean DEFECT | Reduced shadow of future |
| **m = n-1** | Cooperate more readily | Too risky to defect when threshold is strict |
| **m << n** | Defect aggressively | Easy for others to cover threshold |
| **All opponents defected last round** | DEFECT | Threshold likely impossible |
| **Exactly m-1 cooperated last round** | Conditional cooperate | I may be pivotal |

---

## Exploitation Mechanisms

1. **Sucker Detection**: Identify consistent cooperators (coop_rate > 0.8) and never cooperate when they're present - they'll cover for me.

2. **Threshold Manipulation**: If I've established myself as a likely defector, conditional cooperators may cooperate more to compensate, which I then exploit.

3. **Endgame Extraction**: Progressively reduce cooperation probability as rounds diminish, extracting maximum value from those still cooperating.

4. **Plausible Pivotality**: Occasionally cooperate (especially early) to avoid being written off entirely, keeping the option to influence others' expectations.

---

## Summary Formula

**Cooperate if and only if:**
- It's not the last round, AND
- Expected cooperators without me is between m-1.5 and m+0.5, AND
- The expected value of cooperating exceeds defecting, AND
- There are enough remaining rounds to justify building minimal credibility

**Otherwise: DEFECT**
'''

description_EXPLOITATIVE_59 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met**. The optimal exploitative position is to defect while exactly m others cooperate. My strategy aims to:
1. Estimate opponent cooperation rates from history
2. Defect when I predict enough others will cooperate without me
3. Cooperate only when my contribution is likely pivotal to reaching threshold
4. Exploit predictable cooperators ruthlessly

---

## Strategy: "Calculated Free-Rider"

### Decision Framework

Let `p_hat` = estimated probability each other player cooperates (from history)
Let `expected_cooperators` = (n-1) × p_hat

**Core Decision Rule:**
- **Defect** if expected_cooperators ≥ m (others will likely meet threshold without me)
- **Defect** if expected_cooperators < m - 1 (threshold unreachable even if I cooperate)
- **Cooperate** only if m - 1 ≤ expected_cooperators < m (I'm likely pivotal)

### Detailed Rules

#### Round 1 (No History)
```
If m ≤ (n-1)/2:
    DEFECT  # Threshold is low, others likely to cover it
Else if m > (n-1) × 0.6:
    DEFECT  # Threshold too high, unlikely to be reached anyway
Else:
    COOPERATE  # Moderate threshold, establish as potential cooperator
```

Rationale: With no information, defecting is safer. Low thresholds likely get met without me; high thresholds likely fail regardless.

#### Rounds 2 through r-1 (Middle Game)

```
# Calculate cooperation rate from all previous rounds
total_cooperations = sum of all C plays by opponents across all rounds
total_opportunities = (n-1) × (current_round - 1)
p_hat = total_cooperations / total_opportunities

# Expected cooperators this round (excluding me)
expected_coop = (n-1) × p_hat

# Calculate probability threshold is met without me
P_met_without_me = Probability(Binomial(n-1, p_hat) ≥ m)

# Calculate probability threshold is met with me
P_met_with_me = Probability(Binomial(n-1, p_hat) ≥ m-1)

# Expected value calculation
EV_defect = 1 + k × P_met_without_me
EV_cooperate = 0 + k × P_met_with_me

If EV_defect ≥ EV_cooperate:
    DEFECT
Else:
    COOPERATE
```

**Simplified heuristic version:**
```
If P_met_without_me > 0.7:
    DEFECT  # Free-ride confidently
Else if P_met_with_me < 0.3:
    DEFECT  # Lost cause, save my endowment
Else if P_met_with_me - P_met_without_me > 0.2:
    COOPERATE  # I'm pivotal
Else:
    DEFECT  # Default to selfish
```

#### Last Round (Round r)
```
# Same calculation as middle game, but with increased defection bias
# No future rounds means no reputation consequences

EV_defect = 1 + k × P_met_without_me
EV_cooperate = 0 + k × P_met_with_me

If EV_defect ≥ EV_cooperate - 0.1:  # Bias toward defection
    DEFECT
Else:
    COOPERATE
```

### Opponent Modeling Refinements

**Track individual players when possible:**
```
For each opponent j, calculate their personal cooperation rate p_j
Use these individual rates for more accurate threshold probability calculations
```

**Detect exploitable patterns:**
```
If opponent j has cooperated in last 3+ rounds:
    Increase confidence they'll cooperate again
    Weight toward DEFECT
    
If total cooperation is declining round-over-round:
    Reduce p_hat estimate
    Be more willing to defect (sinking ship)
```

---

## Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| m = n-1 or m = n | Evaluate EV carefully | Threshold is demanding; often defect |
| m = 2 (very low) | Usually DEFECT | High chance others cover it |
| k is very large | Slightly more willing to cooperate | Upside of reaching threshold increases |
| All opponents defected last round | DEFECT | Threshold won't be met anyway |
| Exactly m-1 cooperated last round | COOPERATE if pattern stable | I might be pivotal |

---

## Summary Pseudocode

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT if m <= (n-1)/2 else COOPERATE
    
    p_hat = estimate_cooperation_rate(history)
    P_without = binomial_cdf_complement(n-1, p_hat, m)
    P_with = binomial_cdf_complement(n-1, p_hat, m-1)
    
    EV_defect = 1 + k * P_without
    EV_cooperate = k * P_with
    
    if round == r:  # Last round
        EV_cooperate -= 0.1  # Defection bias
    
    return DEFECT if EV_defect >= EV_cooperate else COOPERATE
```

This strategy maximizes personal payoff by free-riding when safe, abandoning lost causes, and only contributing when genuinely pivotal.
'''

description_EXPLOITATIVE_60 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride whenever possible** while ensuring the threshold is met just often enough to collect rewards. The key insight is that cooperating when exactly m-1 others are cooperating makes you pivotal (you get k for contributing), but if m or more others cooperate, you should always defect (you get k+1 for free-riding).

## Strategy Overview

I will estimate opponent cooperation rates, predict how many will cooperate each round, and strategically defect whenever I can get away with it while still meeting the threshold.

---

## Decision Rules

### Round-by-Round Logic

```
function decide(round, history, n, m, k, r):
    
    # Calculate expected cooperators (excluding self)
    if round == 1:
        # Assume others use mixed strategy; estimate ~50% cooperation initially
        expected_coop = (n - 1) * 0.5
    else:
        # Use exponentially weighted moving average of observed cooperation
        coop_rate = calculate_weighted_coop_rate(history, decay=0.7)
        expected_coop = (n - 1) * coop_rate
    
    # Determine action based on expected cooperators
    if expected_coop >= m:
        # Threshold likely met without me → DEFECT (free-ride)
        return DEFECT
    
    elif expected_coop >= m - 1 and expected_coop < m:
        # I might be pivotal → calculate expected value
        prob_exactly_m_minus_1 = estimate_probability(n-1, m-1, coop_rate)
        prob_at_least_m = estimate_probability_at_least(n-1, m, coop_rate)
        
        EV_cooperate = prob_at_least_m * k + prob_exactly_m_minus_1 * k
        EV_defect = prob_at_least_m * (1 + k) + (1 - prob_at_least_m) * 1
        
        if EV_cooperate > EV_defect:
            return COOPERATE
        else:
            return DEFECT
    
    else:
        # Threshold unlikely to be met even with me → DEFECT
        # (Don't throw away endowment for nothing)
        return DEFECT
```

### Weighted Cooperation Rate Calculation

```
function calculate_weighted_coop_rate(history, decay):
    total_weight = 0
    weighted_coop = 0
    
    for t in reverse(history):  # Most recent first
        weight = decay ^ (current_round - t.round)
        others_who_cooperated = count_cooperators(t) - my_action(t)
        weighted_coop += weight * (others_who_cooperated / (n - 1))
        total_weight += weight
    
    return weighted_coop / total_weight
```

---

## Edge Case Handling

### First Round
- Assume 50% baseline cooperation rate among opponents
- If m ≤ (n-1)/2: Defect (threshold probably met without me)
- If m > (n-1)/2: Use expected value calculation with 50% assumption
- Bias toward defection when uncertain (information gathering is valuable)

### Last Round (round = r)
- **Always defect if expected cooperators ≥ m** (no future consequences)
- Only cooperate if pivotal AND the expected value justifies it
- Weight defection more heavily since there's no reputation to maintain

### When Threshold Has Never Been Met
- If after several rounds (>3) the threshold has never been met:
  - Check if m is achievable (m ≤ observed max cooperators + 1)
  - If not achievable, always defect (save endowment)
  - If barely achievable, occasionally cooperate to "test" if others will follow

### When Threshold Is Always Met
- Gradually reduce cooperation to test limits
- If I defected and threshold still met → continue defecting
- This is the most exploitable scenario: pure free-riding

---

## Adaptive Mechanisms

### Opponent Classification
Track individual opponent behavior when possible:
- **Unconditional Cooperators**: Always defect against them
- **Unconditional Defectors**: Factor into threshold calculations
- **Conditional Players**: Monitor their triggers

### Threshold Proximity Tracking
```
if recent_cooperators consistently == m or m+1:
    # System is fragile - be slightly more cooperative to not collapse it
    pivot_threshold += 0.1
    
if recent_cooperators consistently >> m:
    # Lots of slack - exploit heavily
    always_defect = true
```

---

## Summary of Exploitative Principles

1. **Never cooperate when threshold is safely met** - Pure free-riding
2. **Never cooperate when threshold is unreachable** - Don't waste endowment
3. **Only cooperate when pivotal** - And even then, verify EV is positive
4. **Defect more in late rounds** - Reduced future value of cooperation
5. **Exploit cooperative opponents** - They provide cover for defection
6. **Adapt quickly to population shifts** - Recent history matters most

This strategy maximizes individual payoff by contributing the minimum necessary while extracting maximum value from others' cooperation.
'''

description_EXPLOITATIVE_61 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that in a Collective Risk Dilemma, the best possible outcome is being a defector when *exactly* m others cooperate—you get the full reward k plus your kept endowment (1+k). My strategy aims to exploit cooperators by free-riding whenever I predict the threshold will be met without me, while contributing just enough to prevent collective disaster when necessary.

## Decision Rules

### Information Tracking

Each round, maintain:
- `coop_count[t]`: number of cooperators in round t
- `player_history[i][t]`: action of player i in round t
- `coop_rate[i]`: historical cooperation rate of player i
- `rounds_remaining`: r - current_round

### Classification of Other Players

After each round, classify each opponent:
- **Reliable Cooperator**: coop_rate[i] ≥ 0.7
- **Reliable Defector**: coop_rate[i] ≤ 0.3
- **Conditional/Uncertain**: otherwise

### Core Decision Logic

```
function decide(current_round, history):
    
    expected_cooperators = sum(coop_rate[i] for all opponents i)
    reliable_coops = count of Reliable Cooperators
    
    # FIRST ROUND: Defect to gather information
    if current_round == 1:
        return DEFECT
    
    # LAST ROUND: Pure free-riding calculation
    if current_round == r:
        if expected_cooperators >= m:
            return DEFECT  # Free ride on others
        else:
            return DEFECT  # No point cooperating if threshold won't be met
    
    # MIDDLE ROUNDS: Adaptive exploitation
    
    # Case 1: Enough reliable cooperators exist - exploit them
    if reliable_coops >= m:
        return DEFECT
    
    # Case 2: Threshold was met last round without me
    if I defected last round AND coop_count[last_round] >= m:
        return DEFECT  # Keep exploiting
    
    # Case 3: Threshold was NOT met last round
    if coop_count[last_round] < m:
        # Calculate if my cooperation would tip the balance
        if expected_cooperators >= m - 1 AND expected_cooperators < m:
            # I'm pivotal - cooperate strategically to maintain the system
            return COOPERATE
        elif expected_cooperators < m - 1:
            # Not enough cooperators even with me - don't waste contribution
            return DEFECT
    
    # Case 4: Threshold barely met with me cooperating
    if I cooperated last round AND coop_count[last_round] == m:
        # Test if others will maintain threshold without me
        return DEFECT
    
    # Case 5: Uncertainty - use probabilistic free-riding
    shortfall = m - expected_cooperators
    if shortfall <= 0:
        return DEFECT
    elif shortfall >= 1:
        # Cooperate with probability proportional to how critical I am
        prob_cooperate = min(1, shortfall / (n - reliable_coops))
        return COOPERATE with probability prob_cooperate
    
    # Default: Defect
    return DEFECT
```

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Gather information about opponent types |
| Round r (final) | DEFECT | No future consequences; pure exploitation |
| Everyone defected last round | COOPERATE if m ≤ n/2 | Prevent system collapse if threshold is achievable |
| I was sole defector, threshold met | DEFECT | Continue free-riding |
| Exactly m-1 expected cooperators | COOPERATE | I'm pivotal; threshold needs me |
| Threshold impossible (reliable_coops + uncertain < m) | DEFECT | Don't waste resources |

## Exploitation Mechanisms

1. **Information Asymmetry**: Early defection reveals who the "suckers" (reliable cooperators) are
2. **Pivotal Calculation**: Only cooperate when mathematically necessary
3. **Threshold Surfing**: Keep cooperation count near m, never above
4. **Endgame Betrayal**: Always defect in final rounds regardless of history
5. **Punishment Immunity**: Since I'm not committed to cooperation, I can't be meaningfully punished

## Parameter Adaptations

- **High k (k > 2)**: More aggressive defection since threshold benefits are valuable to others
- **Low m relative to n**: More defection opportunities since fewer cooperators needed
- **High m relative to n**: May need occasional cooperation to keep system viable
- **Many rounds (high r)**: More patience in early rounds to identify reliable cooperators
'''

description_EXPLOITATIVE_62 = '''
# Exploitative Strategy: "Threshold Predator"

## Core Philosophy

The key insight is that this game has a critical asymmetry: **defectors get the highest payoff (1+k) when exactly m players cooperate**. My strategy aims to be a defector when others cooperate enough, while contributing just enough to prevent collective collapse when necessary.

## Decision Rules

### Information Tracking

Each round, I track:
- `coop_count[t]`: number of cooperators in round t
- `player_history[i][t]`: action of player i in round t
- `rounds_remaining`: r - current_round

### Classification of Other Players

After observing history, classify each other player as:
- **Reliable Cooperator**: Cooperated ≥70% of the time
- **Reliable Defector**: Defected ≥70% of the time
- **Conditional/Mixed**: Everyone else

Let `expected_cooperators` = count of Reliable Cooperators

### Main Decision Logic

```
function decide(round, history, params):
    n, r, m, k = params
    rounds_remaining = r - round
    
    # PHASE 1: First Round (No Information)
    if round == 1:
        # Defect initially to test the waters and free-ride if others cooperate
        return DEFECT
    
    # PHASE 2: Last Round (No Future Consequences)
    if round == r:
        # Pure exploitation - defect unless collapse is certain and k > 1
        expected_coop = count_reliable_cooperators(history)
        if expected_coop >= m:
            return DEFECT  # Free ride on others
        else:
            return DEFECT  # No point cooperating if threshold won't be met anyway
    
    # PHASE 3: Middle Rounds (Strategic Play)
    
    expected_coop = estimate_cooperators_this_round(history)
    
    # Case A: Others will likely meet threshold without me
    if expected_coop >= m:
        return DEFECT  # Free ride - get 1 + k
    
    # Case B: I'm potentially pivotal (my cooperation might tip the balance)
    if expected_coop == m - 1:
        # Cooperate only if the reward justifies it AND there's future value
        # in maintaining cooperation norms
        if k > 1 and rounds_remaining > 1:
            # Probabilistic cooperation based on how reliable the group is
            reliability = avg_cooperation_rate(history)
            if reliability > 0.5:
                return COOPERATE  # Worth investing to maintain threshold
            else:
                return DEFECT  # Group is unreliable, don't waste contribution
        else:
            return DEFECT
    
    # Case C: Threshold clearly won't be met even if I cooperate
    if expected_coop < m - 1:
        return DEFECT  # No point contributing to a lost cause
```

### Estimation Function

```
function estimate_cooperators_this_round(history):
    # Weight recent behavior more heavily
    score = 0
    for each other player i:
        recent_coop_rate = weighted_avg(player_history[i], decay=0.7)
        if recent_coop_rate > 0.6:
            score += 0.9  # Likely to cooperate
        elif recent_coop_rate > 0.3:
            score += 0.4  # Uncertain
        else:
            score += 0.1  # Likely to defect
    return score
```

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Gather information, exploit early cooperators |
| Last round | DEFECT | No future consequences |
| Everyone defected last round | DEFECT | Group has collapsed, don't be the sucker |
| Exactly m-1 reliable cooperators exist | Conditional COOPERATE | Only if k justifies it and group is stable |
| m > n/2 (high threshold) | Lean DEFECT | Threshold unlikely to be met reliably |
| Very high k (k > 2) | Slightly more willing to be pivotal | Reward justifies occasional contribution |

## Exploitative Features

1. **Never cooperate when unnecessary**: If ≥m others will cooperate, always defect
2. **Never throw away contributions**: If threshold can't be met, never cooperate
3. **Front-load defection**: Early defection lets others establish cooperation patterns I can exploit
4. **End-game defection**: Always defect in final round
5. **Punish unreliable groups**: If cooperation collapses, don't try to rebuild it alone

This strategy maximizes my payoff by contributing only when I'm genuinely pivotal and the expected value is positive, while free-riding whenever possible.
'''

description_EXPLOITATIVE_63 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight in this game is that **defectors get the best payoff when exactly m players cooperate** - they receive both their private endowment (1) AND the collective reward (k). My strategy aims to be a defector in rounds where I predict exactly m others will cooperate, while contributing just enough to prevent total collapse when cooperation is dangerously low.

## Strategy Overview

I will maintain a model of each player's cooperation probability and use it to calculate the expected number of cooperators. My goal is to **free-ride whenever the threshold is likely to be met without me**, and only cooperate when my contribution is pivotal to reaching the threshold.

---

## Decision Rules

### Information Tracked
- `coop_history[i]`: List of cooperation decisions (1=C, 0=D) for each player i
- `coop_rate[i]`: Running cooperation rate for each player
- `round_coop_counts`: Number of cooperators in each past round

### Expected Cooperators Calculation
```
expected_cooperators_without_me = sum(coop_rate[j] for j in other_players)
```

### Core Decision Logic

**DEFECT if:**
1. `expected_cooperators_without_me >= m` (threshold likely met without me)
2. `expected_cooperators_without_me < m - 1` (threshold unreachable even if I cooperate)

**COOPERATE if:**
- `m - 1 <= expected_cooperators_without_me < m` (I am likely pivotal)

### Probability Threshold Refinement
To handle uncertainty, I calculate:
```
P(at least m cooperate without me) = probability calculation using binomial/individual rates
P(exactly m-1 cooperate without me) = probability I am pivotal
```

**Decision Rule with Uncertainty:**
- If `P(at least m without me) > 0.7`: DEFECT (free-ride)
- If `P(exactly m-1 without me) > 0.3` AND `P(at least m without me) < 0.5`: COOPERATE (pivotal)
- Otherwise: DEFECT (default exploitative stance)

---

## Edge Case Handling

### First Round (No History)
- Assume each other player cooperates with probability `m/n` (neutral prior)
- Calculate expected cooperators: `(n-1) * (m/n)`
- If this is close to m, DEFECT (bet others will meet threshold)
- If `m > n/2`: COOPERATE (threshold is demanding, need to contribute)
- If `m <= n/2`: DEFECT (threshold is easy, free-ride)

### Last Round
- **Always DEFECT** unless `expected_cooperators_without_me` is in range `[m-1, m)`
- No future rounds means no punishment for defection, so maximize immediate payoff
- Only cooperate if genuinely pivotal

### When Cooperation Has Collapsed (Recent rounds had < m cooperators)
- If last 2+ rounds failed threshold: slightly increase cooperation probability
- Rationale: Need to "prime the pump" occasionally to restore cooperation, but do so minimally
- Cooperate with probability `max(0.2, (m - avg_recent_cooperators) / n)`

### When I'm Being Exploited (I cooperate but others defect)
- Track my own cooperation rate vs. others
- If `my_coop_rate > average_other_coop_rate + 0.2`: become more aggressive defector
- Reduce cooperation threshold: require higher certainty of being pivotal

---

## Adaptive Mechanisms

### Player Classification
After round 3, classify each player:
- **Cooperator** (rate > 0.7): Reliable contributor
- **Defector** (rate < 0.3): Likely free-rider
- **Conditional** (0.3-0.7): Reactive player

Adjust expected cooperator count using these classifications with higher confidence.

### Dynamic Threshold Adjustment
- If realized cooperation consistently exceeds m: become more aggressive defector
- If realized cooperation consistently misses m: contribute more often (but only enough to be pivotal)

---

## Pseudocode Summary

```
function decide(round, history, params):
    if round == 1:
        return DEFECT if m <= n/2 else COOPERATE
    
    if round == r:  # last round
        exp = expected_cooperators_without_me(history)
        return COOPERATE if (m-1 <= exp < m) else DEFECT
    
    exp = expected_cooperators_without_me(history)
    p_threshold_met = prob_at_least_m_without_me(history)
    p_pivotal = prob_exactly_m_minus_1_without_me(history)
    
    if p_threshold_met > 0.7:
        return DEFECT  # free-ride
    elif p_pivotal > 0.3 and p_threshold_met < 0.5:
        return COOPERATE  # pivotal
    else:
        return DEFECT  # default exploitative
```

This strategy maximizes exploitation by contributing only when absolutely necessary to secure the collective reward, while free-riding on others' cooperation whenever possible.
'''

description_EXPLOITATIVE_64 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met** and punishes **being a sucker when it isn't**. The optimal exploitative approach is to contribute only when absolutely necessary to reach the threshold, while maximizing rounds where others carry the burden.

## Decision Rules

### Information Tracked Each Round
- `cooperators_t`: number of cooperators in round t
- `threshold_met_t`: boolean, whether m or more cooperated
- `player_history[i]`: each opponent's cooperation rate
- `rounds_remaining`: r - current_round

### Round-by-Round Strategy

**FIRST ROUND:**
- **DEFECT**
- Rationale: Gather information about opponent tendencies. If threshold is met without me, I gain maximum payoff (1 + k). If not met, I only lose the bonus k, same as if I had cooperated and threshold wasn't met.

**MIDDLE ROUNDS (rounds 2 through r-1):**

```
Calculate:
  - expected_cooperators = sum of cooperation rates across all opponents
  - shortfall = m - expected_cooperators
  
If threshold was met last round without my cooperation:
    DEFECT (continue exploiting)
    
Else if threshold was NOT met last round:
    If shortfall <= 1 AND my cooperation would likely tip it:
        COOPERATE (be the pivotal player)
    Else:
        DEFECT (don't throw resources at lost causes)
        
Else if I cooperated last round AND threshold was met:
    If expected_cooperators >= m:
        DEFECT (test if others will maintain threshold)
    Else:
        COOPERATE (I'm needed)
```

**LAST ROUND:**
- **DEFECT** (unconditionally)
- Rationale: No future rounds to punish defection. Pure dominant strategy logic applies.

### Detailed Pivot Calculation

```
pivot_probability = P(exactly m-1 others cooperate)

If pivot_probability > 1/k:
    COOPERATE (expected value positive)
Else:
    DEFECT
```

Estimate pivot_probability using:
- Each opponent j cooperates with probability p_j (their historical rate)
- Calculate probability that exactly m-1 of them cooperate

### Exploitation Mechanisms

1. **Sucker Detection**: If certain players always cooperate (p_j > 0.8), permanently defect—they'll carry the threshold.

2. **Coordination Collapse Detection**: If cooperation rates are falling across the population, switch to defection—don't be the last cooperator standing.

3. **Threshold Surfing**: When expected cooperators ≈ m, randomize with probability calibrated to be *just* pivotal enough to occasionally tip thresholds while mostly free-riding.

## Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = m (everyone needed) | Cooperate rounds 1 to r-1, Defect round r | Must cooperate to get bonus, but last round has no enforcement |
| m = 2 (low threshold) | Heavy defection bias | Easy for others to meet threshold |
| k very large (k > n) | More willing to cooperate when pivotal | High reward justifies contribution |
| All opponents defected round 1 | Defect | Threshold unlikely; don't waste resources |
| Exactly m-1 cooperated without me | Cooperate next round | I'm the swing vote |

## Pseudocode Summary

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == r:  # Last round
        return DEFECT
    
    if round == 1:  # First round
        return DEFECT
    
    # Calculate opponent cooperation rates
    opp_rates = [opponent_coop_rate(history, j) for j in opponents]
    expected_coops = sum(opp_rates)
    
    # Check if I'm being exploited (cooperating while others free-ride)
    if my_last_action == COOPERATE and last_round_cooperators <= m:
        return DEFECT  # Stop being a sucker
    
    # Check if I can free-ride
    if expected_coops >= m:
        return DEFECT
    
    # Check if I'm pivotal
    pivot_prob = calculate_pivot_probability(opp_rates, m)
    if pivot_prob > 1/k:
        return COOPERATE
    
    return DEFECT  # Default to defection
```

## Why This Exploits Common Strategies

- **Against unconditional cooperators**: Permanent free-riding
- **Against tit-for-tat variants**: They can't punish in threshold games effectively
- **Against random players**: Statistical exploitation via pivot calculations
- **Against other exploiters**: Mutual defection (acceptable—we both get 1)
'''

description_EXPLOITATIVE_65 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride whenever possible** while ensuring the collective threshold is met just often enough to secure the bonus. The key insight is that cooperators bear all the cost while defectors reap the full reward when exactly m players cooperate.

My strategy aims to:
1. **Never be a sucker** - avoid cooperating when the threshold won't be met anyway
2. **Free-ride on reliable cooperators** - identify and exploit predictable contributors
3. **Cooperate only when necessary** - contribute only when my cooperation is pivotal
4. **Endgame defection** - maximize final round extraction

---

## Decision Rules

### Round 1: Cautious Defection
**Action: DEFECT**

Rationale: With no history to assess others, I start by defecting to observe who the "natural cooperators" are. This gives me information at zero cost. If fewer than m others cooperate, I lose nothing (threshold wasn't met anyway). If m or more cooperate, I get the maximum payoff of 1 + k.

---

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Count reliable cooperators**
```
reliable_cooperators = players who cooperated in ≥ 60% of past rounds
cooperation_rate[i] = (times player i cooperated) / (rounds played)
```

**Step 2: Estimate cooperation this round**
```
expected_cooperators = Σ cooperation_rate[i] for all players i ≠ me
```

**Step 3: Decision logic**

```
IF expected_cooperators >= m:
    # Others will likely hit threshold without me
    ACTION: DEFECT (free-ride)

ELSE IF expected_cooperators >= m - 1 AND expected_cooperators < m:
    # I might be pivotal - conditional cooperation
    IF (my cooperation in last round) AND (threshold was met last round):
        # Test if others will cover for me
        ACTION: DEFECT
    ELSE:
        ACTION: COOPERATE
        
ELSE IF expected_cooperators < m - 1:
    # Threshold unlikely even if I cooperate
    ACTION: DEFECT (don't waste contribution)
```

**Step 4: Punishment/Correction Mechanism**

```
IF last 2 rounds both failed threshold AND expected_cooperators >= m - 2:
    # Cooperation is collapsing, might need to prop it up temporarily
    ACTION: COOPERATE (with 50% probability)
    # Probabilistic to avoid being predictably exploited
```

---

### Final Round (Round r): Pure Defection
**Action: DEFECT (always)**

Rationale: No future rounds means no punishment for defection. If others are rational, they'll also defect. If others are naive cooperators, I exploit them maximally. This is the dominant strategy in the final round.

---

### Round r-1: Likely Defection
**Action: DEFECT (unless threshold is barely being met)**

Rationale: Sophisticated opponents will backward-induct from round r. The shadow of the future is fading, so cooperation incentives weaken.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = m (all must cooperate) | DEFECT always | Threshold too fragile; unlikely to succeed anyway |
| k is very large (k > n) | Cooperate more readily in middle rounds | High reward justifies pivotal contributions |
| All others defected last round | DEFECT | Don't be the lone sucker |
| Threshold met every round so far | DEFECT | Free-ride on established cooperators |
| I'm the only defector and threshold is met | Continue DEFECTING | Maximum exploitation achieved |

---

## Pseudocode Summary

```python
def threshold_vulture(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:  # Final round
        return DEFECT
    
    # Calculate expected cooperators (excluding self)
    coop_rates = [times_cooperated[i] / (round - 1) for i in other_players]
    expected_coop = sum(coop_rates)
    
    if expected_coop >= m:
        return DEFECT  # Free-ride
    elif expected_coop >= m - 1:
        if my_last_action == COOPERATE and last_threshold_met:
            return DEFECT  # Test if others cover
        else:
            return COOPERATE  # Be pivotal
    else:
        # Check if cooperation is collapsing
        if last_two_rounds_failed and expected_coop >= m - 2:
            return COOPERATE with probability 0.5
        return DEFECT  # Threshold unreachable
```

---

## Why This Strategy is Exploitative

1. **Information asymmetry**: I learn who cooperates while contributing nothing initially
2. **Selective contribution**: I only cooperate when strictly pivotal
3. **Endgame extraction**: Guaranteed defection when punishment is impossible
4. **Exploits altruists**: Reliable cooperators subsidize my defection
5. **Avoids sucker payoffs**: Never cooperates into a failing threshold
'''

description_EXPLOITATIVE_66 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met** and punishes everyone equally when it isn't. My strategy aims to:
1. Let others bear the cost of cooperation whenever possible
2. Only cooperate when my contribution is likely pivotal
3. Exploit predictable opponents by defecting when they reliably cooperate
4. Create uncertainty about my behavior to prevent others from exploiting me

## Strategy: "Pivotal Opportunist"

### Decision Framework

**Primary Decision Rule:** Cooperate only when I estimate my contribution is necessary to reach threshold m, and defect otherwise to maximize personal payoff.

### Detailed Rules by Game Phase

#### Round 1: Probe with Bias Toward Defection

```
IF m/n > 0.6:
    # High threshold - cooperation likely needed, but test the waters
    Cooperate with probability m/n
ELSE:
    # Low threshold - likely others will cover it
    Defect
```

*Rationale:* First round establishes baseline while biasing toward the higher-payoff defection outcome.

#### Rounds 2 to (r-1): Adaptive Exploitation

**Step 1: Count reliable cooperators from history**
```
reliable_cooperators = count of players who cooperated in ≥70% of past rounds
recent_cooperators = count of players who cooperated in the last round
```

**Step 2: Estimate expected cooperators (excluding self)**
```
expected_C = weighted_average(
    0.6 * reliable_cooperators,
    0.4 * recent_cooperators
)
```

**Step 3: Decision logic**
```
IF expected_C >= m:
    # Others likely cover threshold - FREE RIDE
    Defect
    
ELIF expected_C == m - 1:
    # I am likely pivotal
    IF k > 1.5:
        Cooperate  # Reward worth the cost
    ELSE:
        Cooperate with probability 0.7  # Some risk tolerance
        
ELIF expected_C < m - 1:
    # Threshold unlikely even if I cooperate
    # Check if cooperating might encourage others
    IF rounds_remaining > r/2 AND historic_threshold_met_rate < 0.3:
        Cooperate with probability 0.3  # Occasional signal
    ELSE:
        Defect  # Don't throw away resources
        
ELSE:  # expected_C between m-1 and m
    # Uncertain situation - be strategic
    Cooperate with probability (m - expected_C)
```

**Step 4: Exploitation adjustment**
```
IF I defected last round AND threshold was met:
    # Successful free-ride - likely can repeat
    Increase defection probability by 0.1
    
IF threshold failed last round AND I cooperated:
    # Wasted cooperation
    Decrease cooperation probability by 0.15 for next round
```

#### Final Round (Round r): Pure Exploitation

```
# No future to consider - maximize immediate payoff
expected_C_others = estimate from recent history

IF expected_C_others >= m:
    Defect  # Guaranteed free-ride
ELIF expected_C_others == m - 1 AND k > 1:
    Cooperate  # Still worth being pivotal
ELSE:
    Defect  # Threshold won't be met anyway
```

### Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| m = n-1 or m = n | Cooperate deterministically | Almost everyone needed; can't free-ride |
| m ≤ 2 with n ≥ 5 | Defect unless threshold failing consistently | Easy for others to cover |
| k > 2 | Lower threshold for cooperation | Higher reward justifies more risk |
| All players defected last round | Cooperate with probability m/n | Reset/probe behavior |
| Threshold met every round so far | Defect | System is stable; exploit it |
| r ≤ 3 (short game) | Bias heavily toward defection | Limited time for reputation/learning |

### Pseudocode Summary

```python
def decide(round, history, n, m, r, k):
    if round == r:  # Final round
        return DEFECT if expected_cooperators(history) >= m else pivot_check(k)
    
    if round == 1:
        return COOPERATE if random() < m/n and m/n > 0.6 else DEFECT
    
    expected_C = estimate_cooperators(history)
    
    if expected_C >= m:
        return DEFECT  # Free ride
    elif expected_C >= m - 1:
        return COOPERATE if k > 1 else probabilistic(0.7)
    else:
        return DEFECT  # Lost cause
```

## Why This Strategy is Exploitative

1. **Maximizes free-riding:** Defaults to defection whenever others are likely to meet threshold
2. **Minimizes wasted cooperation:** Avoids cooperating when threshold won't be met anyway
3. **Exploits predictable cooperators:** Identifies and free-rides on reliable contributors
4. **Endgame exploitation:** No cooperation in final round unless strictly pivotal
5. **Adaptive:** Adjusts to opponent behavior rather than following fixed patterns
'''

description_EXPLOITATIVE_67 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight in this game is that **defectors get strictly higher payoffs than cooperators when the threshold is met**. My goal is to maximize the probability that exactly m cooperators exist (not including me), allowing me to defect and free-ride on their contributions. I will only cooperate when my contribution is strictly necessary to reach the threshold.

## Strategy Overview

I maintain a **cooperation probability estimate** for each player based on observed history, then calculate whether the threshold will likely be met without me. I cooperate only when my contribution is pivotal—otherwise, I defect.

---

## Decision Rules

### Round-by-Round Logic

```
For each round t:

1. ESTIMATE cooperation probabilities:
   - For each other player j, calculate p_j = (# times j cooperated) / (t - 1)
   - In round 1, assume p_j = m/n (the "fair share" baseline)

2. CALCULATE threshold probability without me:
   - P_met = Probability that ≥ m other players cooperate
   - P_critical = Probability that exactly (m-1) other players cooperate
   
3. DECIDE action:
   - If P_met > 0.8: DEFECT (free-ride; threshold likely met without me)
   - If P_met < 0.3 AND P_critical < 0.2: DEFECT (lost cause; don't waste contribution)
   - If P_critical > 0.3: COOPERATE (I'm likely pivotal)
   - Otherwise: DEFECT with probability proportional to P_met
```

### Probability Calculations

Using binomial-style estimation with individual player probabilities:
- P_met = P(sum of Bernoulli(p_j) for j ≠ i is ≥ m)
- P_critical = P(sum of Bernoulli(p_j) for j ≠ i is exactly m-1)

---

## Edge Case Handling

### First Round (t = 1)
- No history available
- **Defect** by default
- Rationale: Test the waters; if others cooperate, I've gained information cheaply. If the threshold fails, I haven't lost my endowment to a failed collective action.

### Last Round (t = r)
- **Defect unconditionally**
- Rationale: No future punishment possible. Pure one-shot logic applies—defection dominates if threshold is met, and my single contribution rarely makes a difference statistically.

### Penultimate Rounds (t = r-1, r-2)
- Apply standard logic but **bias toward defection** (multiply cooperation threshold by 0.8)
- Rationale: Reduced shadow of the future means less need to maintain cooperative appearances.

### When m = n-1 (High Threshold)
- More likely to be pivotal
- Lower the "P_met > X" threshold for defection to 0.9
- I'm almost always pivotal, so cooperate more often

### When m is Very Low (m ≤ n/3)
- Defect heavily—threshold easily met by others
- Only cooperate if P_met < 0.2 AND I'm among the most cooperative-looking players (to avoid being the one who "kills" cooperation norms)

---

## Adaptive Exploitation Mechanisms

### 1. **Sucker Detection**
Track players who cooperate consistently (p_j > 0.7 over 3+ rounds). These are "reliable cooperators."
- If count of reliable cooperators ≥ m: **Always defect**
- They'll carry the threshold; I take the bonus + keep my endowment

### 2. **Cooperation Decay Response**
If average cooperation rate drops below m/n for 2 consecutive rounds:
- Temporarily **increase** my cooperation probability by 0.2
- Rationale: Prevent total collapse that would hurt everyone; but only minimally

### 3. **Punishment Immunity**
Since this is simultaneous-move with no communication, I cannot be directly punished. However, if I notice cooperation collapsing after my defections:
- Slightly increase cooperation for 1-2 rounds to "reset" others' behavior
- Then resume exploitation

---

## Summary Table

| Condition | Action |
|-----------|--------|
| Round 1 | Defect |
| Last round | Defect |
| ≥m reliable cooperators exist | Defect |
| P(threshold met without me) > 80% | Defect |
| P(threshold met without me) < 30% AND P(I'm pivotal) < 20% | Defect |
| P(I'm pivotal) > 30% | Cooperate |
| Otherwise | Defect (slight random cooperation ~10%) |

---

## Why This Strategy is Exploitative

1. **Never cooperates unnecessarily** - Every cooperation is calculated to be pivotal
2. **Maximizes free-riding** - Actively seeks scenarios where others carry the threshold
3. **Exploits cooperators** - Identifies and relies on "suckers" to subsidize my payoffs
4. **Endgame defection** - Extracts maximum value when punishment is impossible
5. **Adaptive predation** - Adjusts to find the exploitation sweet spot in any group composition
'''

description_EXPLOITATIVE_68 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight in this game is that **defectors get the best payoff when exactly m players cooperate** - they free-ride on others' contributions while keeping their own endowment. My strategy aims to be among the defectors when cooperation happens, while occasionally cooperating just enough to keep the system from collapsing entirely.

## Decision Rules

### Information Tracking

Each round, track:
- `coop_history[t]` = number of cooperators in round t
- `my_action[t]` = my action in round t
- `threshold_met[t]` = whether m+ players cooperated in round t
- `coop_rate` = running average cooperation rate across all players

### Round-by-Round Decision Logic

**Round 1 (Cold Start):**
- **Defect.**
- Rationale: No information yet. If others cooperate enough, I get k+1 instead of k. If they don't, I get 1 instead of 0. Defection strictly dominates in uncertainty.

**Rounds 2 through r-1 (Middle Game):**

```
Calculate: expected_cooperators = coop_rate * (n - 1)

IF expected_cooperators >= m:
    # Others likely to meet threshold without me
    DEFECT (free-ride)

ELSE IF expected_cooperators >= m - 1 AND expected_cooperators < m:
    # I might be pivotal - cooperate with probability p
    # p calibrated to make threshold barely met
    p = (m - expected_cooperators) / 1.5  # Slightly under-contribute
    COOPERATE with probability p, else DEFECT

ELSE IF expected_cooperators < m - 1:
    # Threshold unlikely to be met regardless
    # Check if system is dying - might need to "seed" cooperation
    IF last 3 rounds all failed threshold AND coop_rate > 0.2:
        # Others are trying but failing - become pivotal exploiter
        COOPERATE (to restart the system I'll exploit)
    ELSE:
        DEFECT (save my endowment, threshold won't be met anyway)
```

**Last Round (Round r):**
- **Always Defect.**
- Rationale: No future rounds to influence. Pure exploitation opportunity. If others cooperate enough from habit/commitment, I get maximum payoff k+1.

### Adaptive Exploitation Mechanisms

**1. Cooperation Rate Decay:**
- Weight recent rounds more heavily: `weighted_coop_rate = 0.6 * (last 3 rounds avg) + 0.4 * (overall avg)`
- This catches trends where cooperation is rising or falling

**2. Pivotal Position Hunting:**
- If I observe cooperation counts consistently at m or m+1, others are maintaining threshold
- I can safely defect repeatedly while enjoying the bonus

**3. Punishment Immunity:**
- Since I'm optimizing for my payoff, not relationship maintenance, I ignore "punishment" signals
- If cooperation collapses, I simply defect and take my guaranteed 1

**4. Late-Game Intensification:**
- In final 20% of rounds: increase defection probability by 30%
- Others can't punish me effectively with few rounds remaining

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, m, k):
    if round_num == 1:
        return DEFECT
    
    if round_num == total_rounds:
        return DEFECT
    
    # Calculate expected cooperators (excluding me)
    recent_coop_rate = weighted_average(history, recent_weight=0.6)
    expected_others = recent_coop_rate * (n - 1)
    
    # Late-game aggression modifier
    if round_num > 0.8 * total_rounds:
        defect_bias = 0.3
    else:
        defect_bias = 0
    
    if expected_others >= m:
        return DEFECT  # Free ride
    elif expected_others >= m - 1:
        p = max(0, (m - expected_others) / 1.5 - defect_bias)
        return COOPERATE if random() < p else DEFECT
    else:
        # System failing - occasional restart seeding
        if recent_failures >= 3 and overall_coop_rate > 0.2:
            return COOPERATE
        return DEFECT
```

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Always defects when others will likely meet threshold
2. **Minimizes wasted cooperation**: Only cooperates when pivotal AND system needs it
3. **Endgame extraction**: Guarantees defection in final round for maximum extraction
4. **Adaptive parasitism**: Adjusts to maintain a system worth exploiting without contributing more than necessary
'''

description_EXPLOITATIVE_69 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that this game rewards free-riding *when others cooperate enough*. My goal is to maximize the probability that exactly m others cooperate (so I get k+1 by defecting) while minimizing my own contributions. I want to be the marginal defector in a successful collective action.

## Strategy Overview

I will estimate the cooperation rate of opponents, then cooperate only when my contribution is likely *pivotal* (i.e., without me, the threshold fails). Otherwise, I defect and harvest the rewards of others' cooperation.

---

## Decision Rules

### Key Variables Tracked
- `coop_history[t]`: Number of cooperators (excluding me) in round t
- `total_rounds_observed`: Rounds completed
- `estimated_coop_rate`: Rolling estimate of opponent cooperation probability

### Round-by-Round Logic

```
FUNCTION decide_action(round_number, history, n, m, k, r):
    
    # FIRST ROUND: Defect to gather information
    if round_number == 1:
        return DEFECT
    
    # LAST ROUND: Pure exploitation - defect unless pivotal
    if round_number == r:
        return defect_unless_desperate(history, n, m)
    
    # MIDDLE ROUNDS: Adaptive exploitation
    estimated_coop_count = estimate_cooperators(history, n)
    
    # Case 1: Expect threshold met without me → DEFECT (free ride)
    if estimated_coop_count >= m:
        return DEFECT
    
    # Case 2: Expect exactly (m-1) cooperators → COOPERATE (pivotal)
    if estimated_coop_count == m - 1:
        return COOPERATE
    
    # Case 3: Expect fewer than (m-1) cooperators
    # Cooperate only if there's reasonable hope of hitting threshold
    if estimated_coop_count >= m - 2 and rounds_remaining > 2:
        # Probabilistic cooperation to "seed" future cooperation
        if random() < 0.3:
            return COOPERATE
    
    # Default: Defect when threshold seems unreachable
    return DEFECT
```

### Estimation Function

```
FUNCTION estimate_cooperators(history, n):
    if no history:
        return (n-1) / 2  # Assume 50% baseline
    
    # Weighted average: recent rounds matter more
    weights = [0.5^(total_rounds - t) for t in rounds]
    weighted_coop_rate = weighted_average(coop_history, weights)
    
    # Estimate expected cooperators (excluding me)
    return weighted_coop_rate * (n - 1)
```

### Last Round Logic

```
FUNCTION defect_unless_desperate(history, n, m):
    recent_coop_count = average(last 3 rounds of coop_history)
    
    # If cooperation has been stable at/above threshold: defect
    if recent_coop_count >= m:
        return DEFECT
    
    # If we're exactly at the margin: defect (gamble on others)
    if recent_coop_count == m - 1:
        return DEFECT  # Others might cooperate; I harvest
    
    # If cooperation is collapsing: defect anyway (lost cause)
    return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Gather information risk-free |
| Round r (last) | DEFECT | No future punishment possible |
| m = n-1 (high threshold) | Cooperate more often | My contribution is more likely pivotal |
| m = 2 (low threshold) | Defect aggressively | Easy for others to meet threshold |
| All opponents defected last round | DEFECT | Threshold unreachable, save my endowment |
| Exactly m-1 cooperated last round | COOPERATE | I'm the swing vote |
| k is very large | Slightly increase cooperation | Higher stakes justify pivotal plays |

---

## Exploitation Mechanisms

1. **Information Asymmetry**: First-round defection lets me see opponent behavior before committing.

2. **Threshold Parasitism**: When cooperation is abundant, I take the reward without contributing.

3. **Pivotal Positioning**: I only cooperate when I calculate my contribution tips the balance—maximizing leverage.

4. **End-Game Betrayal**: Final round always defects since there's no retaliation opportunity.

5. **Decay Exploitation**: If I detect declining cooperation, I abandon ship early rather than throwing good money after bad.

---

## Summary

**Cooperate** only when: I estimate exactly (m-1) others will cooperate (making me pivotal).

**Defect** when: (a) threshold will be met without me, (b) threshold is unreachable, or (c) it's the last round.

This strategy maximizes the payoff of 1+k (defect while threshold is met) while occasionally paying the cooperation cost of k-1 only when absolutely necessary to keep the collective action viable.
'''

description_EXPLOITATIVE_70 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met** and **minimal contribution otherwise**. The optimal exploitative approach is to defect whenever I predict enough others will cooperate, and only cooperate when my contribution is likely pivotal to reaching the threshold.

## Strategy: "Reluctant Pivotal Defector" (RPD)

### Decision Framework

I maintain a **cooperation probability estimate** for each player based on their history, then decide based on whether the threshold will likely be met without me.

---

### Detailed Decision Rules

#### Round 1 (Cold Start)
- **Defect.**
- Rationale: No information exists. I want to observe others' tendencies while keeping my endowment. If enough naive cooperators exist, I profit maximally. If not, I lose nothing extra.

#### Rounds 2 through (r-1) (Mid-Game)

**Step 1: Estimate each opponent's cooperation probability**
```
For each player j ≠ i:
    p_j = (number of times j cooperated) / (rounds played so far)
```

**Step 2: Calculate expected cooperators excluding myself**
```
expected_others = Σ p_j for all j ≠ i
```

**Step 3: Decision logic**
```
IF expected_others >= m + 0.5:
    DEFECT  # Threshold likely met without me - free ride
    
ELIF expected_others >= m - 1 AND expected_others < m + 0.5:
    # I might be pivotal - calculate more carefully
    prob_exactly_m_minus_1 = P(exactly m-1 others cooperate)
    
    IF prob_exactly_m_minus_1 > 0.3:
        COOPERATE  # My contribution likely pivotal
    ELSE:
        DEFECT
        
ELIF expected_others < m - 1:
    DEFECT  # Threshold unlikely even with my help
```

**Step 4: Exploitation adjustment**
```
IF last round had exactly m cooperators AND I defected:
    # Perfect exploitation achieved - maintain current behavior
    Continue with base strategy
    
IF cooperation rate across all players is rising:
    # Others are "making up" for defectors - exploit harder
    Shift threshold for cooperation UP by 0.5
```

#### Final Round (Round r)
- **Always DEFECT.**
- Rationale: No future rounds exist to punish me. Pure dominant strategy thinking applies. If others cooperate out of habit or hope, I maximize by defecting.

---

### Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| **Round 1** | Defect | Information gathering, no reputation cost |
| **Round r (final)** | Defect | No future punishment possible |
| **All opponents always cooperate** | Defect | Free-ride on guaranteed threshold |
| **All opponents always defect** | Defect | Threshold impossible anyway |
| **Exactly m-1 reliable cooperators** | Cooperate | I'm pivotal, gain k-1 > 0 |
| **High variance in opponent behavior** | Defect unless clearly pivotal | Uncertainty favors keeping endowment |
| **m very close to n** | More willing to cooperate | Each player more likely pivotal |
| **m very small relative to n** | More willing to defect | Easy for others to meet threshold |

---

### Pseudocode Summary

```python
def decide(round_num, total_rounds, history, m, n, k):
    if round_num == 1:
        return DEFECT
    
    if round_num == total_rounds:
        return DEFECT
    
    # Estimate cooperation probabilities
    coop_probs = []
    for opponent in other_players:
        p = opponent.cooperation_count / (round_num - 1)
        coop_probs.append(p)
    
    expected_cooperators = sum(coop_probs)
    
    # Free-ride zone: threshold likely met without me
    if expected_cooperators >= m + 0.5:
        return DEFECT
    
    # Threshold impossible zone
    if expected_cooperators < m - 1.5:
        return DEFECT
    
    # Pivotal zone: I might make the difference
    prob_pivotal = calculate_pivotal_probability(coop_probs, m)
    
    if prob_pivotal > 0.3:
        return COOPERATE
    else:
        return DEFECT
```

---

### Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever others are likely to meet the threshold
2. **Minimizes wasted cooperation**: Only cooperates when contribution is pivotal
3. **Exploits cooperative opponents**: Takes full advantage of reliable cooperators
4. **No reciprocity loyalty**: Doesn't cooperate "to maintain relationships" - purely outcome-driven
5. **Endgame exploitation**: Guaranteed defection in final round extracts maximum value
6. **Information asymmetry**: Uses first round to gather data at minimal cost
'''

description_EXPLOITATIVE_71 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game has a **free-rider paradise**: when exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get less (k). My strategy aims to be among the defectors when the threshold is met, while avoiding scenarios where I cooperate but the threshold fails.

## Strategy: "Threshold Parasite"

### Decision Framework

The strategy operates on two principles:
1. **Never be a sucker**: Avoid cooperating when the threshold won't be met
2. **Maximize free-riding**: Defect whenever I predict others will meet the threshold without me

### Round-by-Round Decision Rules

#### First Round
**Action: DEFECT**

Rationale: With no history, I cannot predict others' behavior. Defecting guarantees payoff ≥ 1, while cooperating risks getting 0 if threshold fails. This also establishes me as someone who needs to be "carried."

#### Middle Rounds (2 to r-1)

Calculate these metrics from the previous round:
- `prev_cooperators`: number of players who cooperated last round
- `cooperation_rate`: historical average cooperation rate across all players

**Decision Logic:**

```
IF prev_cooperators >= m + 1:
    # Threshold was exceeded - there's slack, I can free-ride
    ACTION: DEFECT
    
ELIF prev_cooperators == m:
    # Threshold was exactly met
    # Check if I was a cooperator - if so, I'm essential; if not, keep free-riding
    IF I cooperated last round:
        ACTION: DEFECT (test if others will cover for me)
    ELSE:
        ACTION: DEFECT (keep exploiting)
        
ELIF prev_cooperators == m - 1:
    # One short of threshold
    IF I defected last round:
        # My cooperation could tip it over - cooperate conditionally
        # But only if cooperation_rate suggests others are trying
        IF cooperation_rate >= (m-1)/n:
            ACTION: COOPERATE
        ELSE:
            ACTION: DEFECT
    ELSE:
        # I cooperated and we still failed - others aren't pulling weight
        ACTION: DEFECT
        
ELIF prev_cooperators < m - 1:
    # Far from threshold - don't throw away resources
    ACTION: DEFECT
```

#### Last Round (round r)
**Action: DEFECT**

Rationale: No future rounds to influence. Pure one-shot logic applies - defecting weakly dominates if I believe there's any chance the threshold is met without me, and limits downside otherwise.

### Adaptive Refinements

**Trend Detection:**
```
IF cooperation is declining over last 3 rounds:
    # Others are giving up - defect to avoid being a sucker
    Bias toward DEFECT
    
IF cooperation is increasing AND currently at m-1:
    # Momentum suggests threshold might be hit - position to free-ride
    ACTION: DEFECT (let the trend continue without me)
```

**Exploitation Escalation:**
```
Track: consecutive_rounds_threshold_met

IF consecutive_rounds_threshold_met >= 2 AND I've been defecting:
    # Stable cooperation exists without me - keep exploiting
    ACTION: DEFECT
    
IF threshold has NEVER been met after round r/3:
    # Cooperation is collapsing - stop wasting resources
    ACTION: DEFECT for remainder
```

### Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = m + 1 | More willing to cooperate in middle rounds | Only 1 defector can free-ride |
| k is very large (k > 2) | Slightly more cooperative when close to threshold | Higher reward justifies some risk |
| m/n > 0.7 | Pessimistic bias toward defection | High threshold unlikely to be met |
| r ≤ 3 | Defect all rounds | Too few rounds to establish cooperation |

### Summary Pseudocode

```
function decide(round, history, params):
    if round == 1 or round == r:
        return DEFECT
    
    prev_coop = count_cooperators(history[round-1])
    my_prev_action = my_action(history[round-1])
    avg_coop_rate = average_cooperation_rate(history)
    
    if prev_coop >= m:
        return DEFECT  # Free-ride on success
    
    if prev_coop == m - 1 and my_prev_action == DEFECT:
        if avg_coop_rate >= (m-1)/n:
            return COOPERATE  # Be the tipping point
    
    return DEFECT  # Default to exploitation
```

This strategy prioritizes exploitation while maintaining just enough conditional cooperation to potentially benefit from threshold rewards when the conditions are favorable.
'''

description_EXPLOITATIVE_72 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when others cooperate enough**. The optimal exploitative approach is to defect whenever I can get away with it (i.e., when enough others will cooperate to meet the threshold) and only cooperate when my contribution is actually necessary to reach the threshold.

## Strategy: "Threshold Predator"

### Decision Framework

My strategy estimates the probability that exactly `m-1` others will cooperate (making me pivotal) versus `m` or more others cooperating (allowing me to free-ride).

### Round-by-Round Decision Rules

#### First Round
**Default to DEFECT.**

Rationale: With no history, I cannot predict others. If I'm in a population of mostly cooperators, I get `1 + k`. If not, I get `1`. Cooperating risks getting `0` if threshold isn't met. The expected value of defection dominates early when uncertainty is high.

#### Middle Rounds (rounds 2 through r-1)

**Step 1: Estimate cooperation rate**
```
Let cooperation_rate = (total C actions by others in all previous rounds) / ((n-1) * rounds_played)
```

**Step 2: Calculate expected cooperators this round**
```
expected_cooperators = cooperation_rate * (n - 1)
```

**Step 3: Decision logic**
```
IF expected_cooperators >= m:
    DEFECT  # Free-ride: threshold will likely be met without me
    
ELSE IF expected_cooperators >= m - 1.5 AND expected_cooperators < m:
    # I might be pivotal - calculate if cooperation is worth it
    # Probability threshold is met without me vs. with me matters
    IF random() < (m - expected_cooperators):
        COOPERATE  # Probabilistic cooperation when near threshold
    ELSE:
        DEFECT
        
ELSE IF expected_cooperators < m - 1.5:
    DEFECT  # Threshold won't be met even if I cooperate - save my endowment
```

**Step 4: Exploitation detection and response**
```
IF last_round_cooperators >= m AND I defected last round:
    # I successfully free-rode - increase defection tendency
    exploitation_bonus += 0.1
    
IF last_round_cooperators == m - 1 AND I defected:
    # I could have been pivotal but wasn't - threshold failed
    # Others may adjust - slightly increase cooperation probability
    exploitation_bonus -= 0.05
```

Apply `exploitation_bonus` as a modifier pushing toward defection.

#### Last Round
**ALWAYS DEFECT.**

Rationale: No future consequences. If others meet threshold, I get `1 + k`. If not, I get `1`. Cooperating gives me at best `0 + k = k`, which equals `1 + k - 1`, always worse than defecting when threshold is met.

### Edge Cases

1. **If m > n/2**: Cooperation is harder to achieve. Be more willing to contribute when close to threshold since free-riding opportunities are rarer.

2. **If k is very large**: The penalty for failed thresholds is high relative to keeping endowment. Slightly increase cooperation probability when near pivotal range.

3. **If n is small (n < 5)**: Individual actions matter more. Track individual player patterns and identify reliable cooperators to exploit.

4. **If observing consistent defection by all**: Default to permanent defection - collective action has failed.

5. **If observing exactly m cooperators repeatedly**: This is the dream scenario - continue defecting and free-riding.

### Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == r:
        return DEFECT  # Last round always defect
    
    if round == 1:
        return DEFECT  # First round default defect
    
    coop_rate = calculate_others_cooperation_rate(history)
    expected_coops = coop_rate * (n - 1)
    
    if expected_coops >= m:
        return DEFECT  # Free-ride
    else if expected_coops >= m - 1.5:
        pivot_prob = m - expected_coops
        if random() < pivot_prob:
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT  # Lost cause
```

### Why This Strategy is Exploitative

1. **Maximizes free-riding**: Always defects when threshold is likely met without contribution
2. **Avoids wasted cooperation**: Never cooperates when threshold is unreachable
3. **Exploits cooperators**: Uses their predictability to extract maximum personal payoff
4. **End-game exploitation**: Guaranteed defection in final round when no retaliation is possible
5. **Adaptive**: Increases exploitation when environment permits, without fixed patterns others can anticipate
'''

description_EXPLOITATIVE_73 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

This strategy exploits the fundamental asymmetry in the Collective Risk Dilemma: defectors receive the full bonus (k) plus their kept endowment (1) when exactly m players cooperate. The goal is to **free-ride on the minimum coalition** while contributing only when absolutely necessary to prevent collective disaster.

## Strategic Framework

### Key Insight
The optimal exploitative position is to be a defector when exactly m others cooperate. This yields payoff k+1, the maximum possible. The strategy therefore aims to:
1. Estimate whether m cooperators will emerge *without* my contribution
2. Cooperate only when my contribution is pivotal to reaching threshold
3. Defect aggressively in late rounds when others are committed

---

## Decision Rules

### Round Classification

**Early Rounds** (rounds 1 to ⌊r/3⌋): *Probe Phase*
**Middle Rounds** (rounds ⌊r/3⌋+1 to ⌊2r/3⌋): *Exploit Phase*  
**Late Rounds** (rounds ⌊2r/3⌋+1 to r): *Extraction Phase*

---

### Phase-Specific Rules

#### PHASE 1: Probe Phase (Early Rounds)

**Round 1 Decision:**
- Calculate cooperation probability p = m/n (the "fair share" probability)
- If m/n > 0.5: **Defect** (likely enough cooperators without me)
- If m/n ≤ 0.5: **Cooperate** with probability (m-1)/(n-1)

*Rationale: In round 1, establish myself as a conditional cooperator while gathering information. Slightly under-contribute relative to fair share.*

**Subsequent Early Rounds:**
- Track `coop_rate` = (total cooperations observed) / (n × rounds_played)
- Track `my_coop_rate` = my cooperations / rounds_played

**Decision Rule:**
```
estimated_cooperators = coop_rate × (n - 1)

IF estimated_cooperators >= m:
    DEFECT  # Others will likely cover threshold
ELSE IF estimated_cooperators >= m - 1:
    COOPERATE with probability 0.5  # Might be pivotal
ELSE:
    COOPERATE  # Need to encourage cooperation norm
```

---

#### PHASE 2: Exploit Phase (Middle Rounds)

Now we have behavioral data. Classify opponents:

```
FOR each opponent j:
    opponent_coop_rate[j] = cooperations by j / rounds observed
    
    IF opponent_coop_rate[j] > 0.7: classify as "Sucker"
    ELSE IF opponent_coop_rate[j] > 0.4: classify as "Conditional"
    ELSE: classify as "Defector"

num_suckers = count of "Sucker" opponents
num_conditional = count of "Conditional" opponents
```

**Decision Rule:**
```
IF num_suckers >= m:
    DEFECT  # Reliable cooperators will cover threshold
    
ELSE IF num_suckers + num_conditional >= m:
    # Check if conditional players cooperated last round
    recent_coop = count of cooperators in last round
    
    IF recent_coop >= m:
        DEFECT  # Momentum suggests threshold will be met
    ELSE IF recent_coop >= m - 1:
        COOPERATE with probability 0.3  # Occasionally be pivotal
    ELSE:
        COOPERATE  # Need to maintain coalition
        
ELSE:
    # Insufficient reliable cooperators
    IF my_coop_rate < (m/n) - 0.1:
        COOPERATE  # Maintain credibility as conditional player
    ELSE:
        DEFECT  # Already contributed "fair share"
```

---

#### PHASE 3: Extraction Phase (Late Rounds)

**Penultimate Round (round r-1):**
```
IF threshold was met in majority of recent rounds:
    DEFECT  # Others likely continue cooperating
ELSE:
    COOPERATE  # Signal continued engagement to maintain threshold
```

**Final Round (round r):**
```
ALWAYS DEFECT
```
*Rationale: No future shadow. Maximum extraction.*

**Other Late Rounds:**
```
# Aggressive exploitation - defect more freely
recent_threshold_rate = (times threshold met in last 3 rounds) / 3

IF recent_threshold_rate >= 0.67:
    DEFECT  # Coalition is stable, exploit it
ELSE IF recent_threshold_rate >= 0.33:
    COOPERATE with probability m/n × 0.5  # Half of fair share
ELSE:
    COOPERATE  # Coalition collapsing, try to save it
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2, m = 2 | Cooperate until last round, then Defect | Must cooperate for any payoff |
| m = n - 1 | Defect with probability 1/n | Only one defector slot available |
| k is very large (k > n) | More willing to cooperate early | Threshold bonus dominates |
| k is small (k < 1.5) | Defect more aggressively | Defection payoff relatively attractive |
| Threshold never met so far | Cooperate next round | Reset attempt |
| All opponents always defect | Defect | No coalition possible |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == r:
        return DEFECT
    
    if round == 1:
        return COOPERATE if random() < (m-1)/(n-1) and m/n <= 0.5 else DEFECT
    
    # Calculate statistics
    coop_counts = [count_cooperations(opponent) for opponent in history]
    estimated_coops_without_me = sum(c / round for c in coop_counts)
    
    # Phase determination
    if round <= r // 3:
        phase = "probe"
    elif round <= 2 * r // 3:
        phase = "exploit"
    else:
        phase = "extract"
    
    if phase == "extract":
        if last_3_rounds_threshold_rate >= 0.67:
            return DEFECT
        elif random() < m / (2 * n):
            return COOPERATE
        else:
            return DEFECT
    
    # Core logic: Am I pivotal?
    if estimated_coops_without_me >= m:
        return DEFECT  # Free ride
    elif estimated_coops_without_me >= m - 1:
        return COOPERATE if random() < 0.4 else DEFECT
    else:
        return COOPERATE  # Pivotal contribution needed
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever threshold appears achievable without contribution
2. **Identifies and exploits "suckers"**: Tracks reliable cooperators and lets them carry the burden
3. **Endgame extraction**: Aggressive defection when no future retaliation possible
4. **Maintains just enough credibility**: Cooperates only enough to not be identified as pure defector
5. **Adaptive to opponent mix**: Adjusts based on observed behavioral types rather than assuming cooperation
'''

description_EXPLOITATIVE_74 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach recognizes that this game has a critical asymmetry: **defectors get the full bonus (k) plus their endowment (1) when exactly m players cooperate**. My goal is to free-ride on others' cooperation while ensuring the threshold is *barely* met—maximizing my personal gain at others' expense.

## Strategy Overview

I aim to be a "marginal defector"—cooperating only when my contribution is absolutely necessary to meet the threshold, and defecting whenever I can safely free-ride on others' predictable cooperation.

---

## Decision Rules

### Round 1: Probe with Defection
- **Action: DEFECT**
- Rationale: Gather information about baseline cooperation levels. Many strategies will cooperate early to establish norms—I exploit this immediately.

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Estimate expected cooperators**
```
Let C_prev = number of cooperators in the previous round (excluding me)
Let C_avg = average cooperators per round so far (excluding me)
Let estimated_cooperators = 0.7 * C_prev + 0.3 * C_avg  // Weighted recent history
```

**Step 2: Decision logic**
```
IF estimated_cooperators >= m:
    ACTION = DEFECT  // Free-ride: threshold will be met without me
    
ELIF estimated_cooperators == m - 1:
    // I'm the pivotal player
    IF k > 1:
        ACTION = COOPERATE  // My cooperation nets me k - cost = k - 1 > 0
    ELSE:
        ACTION = DEFECT
        
ELIF estimated_cooperators < m - 1:
    // Threshold likely won't be met even if I cooperate
    // Calculate: is cooperation likely to trigger cascade?
    IF (rounds_remaining > 3) AND (C_prev < m - 1) AND (I defected last round):
        ACTION = COOPERATE  // Occasional cooperation to "seed" threshold-meeting
    ELSE:
        ACTION = DEFECT  // Don't waste contribution on lost cause
```

**Step 3: Exploitation tracking**
```
// Track if threshold was met while I defected
IF threshold_met_last_round AND I_defected_last_round:
    exploitation_success_count += 1
    
// If exploitation working consistently, maintain defection bias
IF exploitation_success_count / rounds_played > 0.5:
    Increase defection probability by 10% in borderline cases
```

### Final Round (Round r): Pure Defection
- **Action: DEFECT (always)**
- Rationale: No future consequences. If others cooperate enough, I get k + 1. If not, I still keep my endowment. Cooperating in the last round is strictly dominated if others' behavior is fixed.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| **n = 2, m = 2** | Cooperate rounds 1 to r-1, Defect round r | Need partner; exploit only at the end |
| **m = n - 1** | Defect always unless threshold never met for 3+ rounds | High chance threshold met without me |
| **m very low (m ≤ n/3)** | Defect always | Others will likely meet threshold |
| **k very high (k > 3)** | Cooperate when pivotal, otherwise defect | Stakes too high to risk threshold failure |
| **Threshold never met for 3+ consecutive rounds** | Cooperate once to "test" | May unlock cooperative equilibrium I can later exploit |
| **Everyone always cooperates** | Always defect | Maximum exploitation opportunity |
| **Everyone always defects** | Defect | No point being the lone cooperator |

---

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    my_history, others_history = history
    
    // Final round: always defect
    if round == r:
        return DEFECT
    
    // Round 1: probe
    if round == 1:
        return DEFECT
    
    // Calculate expected cooperators (excluding self)
    others_coop_last = count(others_history[round-1], C)
    others_coop_avg = mean([count(h, C) for h in others_history])
    expected = 0.7 * others_coop_last + 0.3 * others_coop_avg
    
    // Core logic
    if expected >= m:
        return DEFECT  // Free-ride
    elif expected >= m - 1.5 and expected < m:
        return COOPERATE  // Pivotal
    elif expected < m - 1:
        // Threshold unlikely - occasional probe
        if rounds_since_last_coop > 3 and round < r - 2:
            return COOPERATE
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever threshold is likely met without me
2. **Punishes cooperators**: Every time I defect while threshold is met, cooperators subsidize my gain
3. **Minimal contribution**: Only cooperates when mathematically pivotal
4. **Endgame exploitation**: Guaranteed defection in final round extracts maximum value
5. **Adaptive parasitism**: Learns others' cooperation patterns to exploit them precisely
'''

description_EXPLOITATIVE_75 = '''
# Exploitative Strategy: "Threshold Freerider"

## Core Philosophy

The optimal exploitative approach in this game recognizes a fundamental asymmetry: **if exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get only k**. My strategy aims to be among the defectors when the threshold is met, while ensuring the threshold *is* met often enough to collect the bonus.

## Strategic Analysis

- **Best outcome for me**: I defect, exactly m others cooperate → I get 1 + k
- **Worst outcome**: Fewer than m cooperate → everyone gets at most 1
- **Key insight**: I want to predict when others will cooperate and freeride on their contributions

---

## Decision Rules

### Round 1: Defect
- No information available about opponents
- Defecting preserves my endowment while I gather intelligence
- If others cooperate, I get maximum payoff; if not, I lose nothing extra

### Rounds 2 through (r-1): Adaptive Freeriding

**Calculate cooperation probability estimate:**
```
Let C_prev = number of cooperators in previous round
Let C_avg = average cooperators across all previous rounds
```

**Decision logic:**

1. **If C_prev ≥ m (threshold was met last round):**
   - **Defect** — Others demonstrated willingness to cooperate; freeride on them
   - Exception: If C_prev == m exactly AND I cooperated, defect (test if others will cover)

2. **If C_prev == m - 1 (one short of threshold):**
   - **Cooperate with probability p = min(0.4, (r - current_round) / r)**
   - Reasoning: Worth occasionally pushing over threshold, but decrease willingness as game ends
   
3. **If C_prev < m - 1 (well below threshold):**
   - **Defect** — Cooperation unlikely to reach threshold; preserve endowment
   - Exception: If C_avg > m and this seems like an anomaly, cooperate once to "restart" coordination

4. **Exploitation trigger:**
   - Track which "positions" tend to cooperate (if any pattern emerges from aggregate behavior)
   - If cooperation has been stable at exactly m for 2+ rounds, **always defect** — someone else is carrying the load

### Final Round r: Almost Always Defect
- No future rounds to incentivize others
- **Defect** unless C_prev was exactly m-1 AND k > 2 (high enough reward to gamble)

---

## Pseudocode

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    C_prev = count_cooperators(history[round - 1])
    C_avg = average_cooperators(history)
    my_prev_action = my_action(history[round - 1])
    
    # Final round exploitation
    if round == r:
        if C_prev == m - 1 and k > 2:
            return COOPERATE with probability 0.3
        return DEFECT
    
    # Threshold was met - freeride
    if C_prev >= m:
        return DEFECT
    
    # One away from threshold - conditional cooperation
    if C_prev == m - 1:
        p = min(0.4, (r - round) / r)
        return COOPERATE with probability p
    
    # Well below threshold
    if C_prev < m - 1:
        # Check for anomaly in otherwise cooperative game
        if C_avg >= m - 0.5 and (round <= r/2):
            return COOPERATE  # One-time restart attempt
        return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Defect | Gather information risk-free |
| Final round | Defect (usually) | No future incentive for others |
| n = m (everyone needed) | Cooperate rounds 2 to r-1, defect round r | Must cooperate to get bonus, but defect at end |
| k very large (k > n) | Slightly more willing to cooperate mid-game | Higher reward justifies occasional contribution |
| Threshold never met | Keep defecting | Don't throw good money after bad |
| Stable cooperation observed | Defect relentlessly | Others are carrying; exploit them |

---

## Why This Strategy is Exploitative

1. **Freeriding priority**: Default stance is defection whenever others might cover the threshold
2. **Information extraction**: Round 1 defection reveals others' tendencies at no relative cost
3. **Endgame exploitation**: Final round defection is dominant when others can't retaliate
4. **Minimal contribution**: Only cooperates when mathematically necessary to sometimes reach threshold
5. **Asymmetric gains**: Targets the (1 + k) payoff that defectors receive when threshold is met
'''

description_EXPLOITATIVE_76 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The fundamental insight is that in a Collective Risk Dilemma, the best outcome for any individual is to **defect while exactly m others cooperate**. My strategy aims to maximize the probability of being a free-rider when the threshold is met, while occasionally cooperating just enough to keep cooperative players in the game.

## Strategy Overview

I will estimate the cooperation rate of other players and strategically position myself to exploit situations where cooperation is likely to occur without my contribution. When cooperation appears insufficient to meet the threshold, I will conditionally cooperate only if my contribution is pivotal.

---

## Decision Rules

### Information Tracking (Per Round)

After each round, track:
- `coop_count[t]` = number of cooperators in round t (excluding self)
- `my_action[t]` = my action in round t
- `threshold_met[t]` = whether m or more total cooperators existed

### Cooperation Probability Estimate

```
estimated_others_cooperating = (sum of coop_count over all past rounds) / (number of past rounds)
```

### Core Decision Logic

**Round 1 (Cold Start):**
- **Defect.** 
- Rationale: No information exists. Defecting costs nothing if threshold fails, and yields maximum payoff (1+k) if others meet the threshold without me.

**Rounds 2 through r-1 (Main Phase):**

```
Let E = estimated_others_cooperating (from other n-1 players)

If E >= m:
    # Others likely meet threshold without me → FREE RIDE
    DEFECT

Else if E >= m - 1 AND E < m:
    # I might be pivotal → CONDITIONAL COOPERATION
    # But only cooperate probabilistically to avoid being exploited
    Cooperate with probability P = min(0.7, (m - E) / 1.5)
    Otherwise Defect

Else if E < m - 1:
    # Threshold unlikely to be met even if I cooperate
    # Check if cooperation could trigger others to cooperate more
    
    If (threshold was met in any of last 2 rounds):
        # There's hope - cooperate to keep the system alive
        Cooperate with probability 0.3
    Else:
        # System is collapsing - no point contributing
        DEFECT
```

**Last Round (Round r):**
- **Always Defect.**
- Rationale: No future rounds exist to influence. Pure exploitation opportunity.

**Second-to-Last Round (Round r-1):**
- Apply main phase logic but reduce all cooperation probabilities by 50%.
- Rationale: Less future value in maintaining cooperation.

---

## Edge Case Handling

### Edge Case 1: Very High Cooperation Environment (E > m + 1)
- **Always Defect.** There's surplus cooperation; my defection won't break the threshold.

### Edge Case 2: Exactly at Threshold (E ≈ m)
- Defect with 70% probability, cooperate with 30%.
- Rationale: Test if threshold holds without me; occasional cooperation maintains plausible deniability.

### Edge Case 3: Cooperation Collapse (3+ consecutive rounds where threshold not met)
- Defect for 2 rounds (let others potentially restart cooperation).
- Then cooperate once as a "probe" to see if cooperation can restart.
- If probe fails, return to pure defection.

### Edge Case 4: Small n (n ≤ 4)
- Increase cooperation probability by 20% when E is near m-1.
- Rationale: Each player's action is more pivotal; being slightly more cooperative prevents total collapse.

### Edge Case 5: Large m relative to n (m > 0.7*n)
- If estimated cooperation is within 1 of threshold, cooperate.
- Rationale: High threshold makes coordination fragile; need to participate more to get any rewards.

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    E = estimate_others_cooperation(history)
    
    if E >= m:
        return DEFECT  # Free ride
    
    if E >= m - 1:
        p = min(0.7, (m - E) / 1.5)
        if round == r - 1:
            p *= 0.5
        return COOPERATE with probability p, else DEFECT
    
    if E < m - 1:
        if threshold_met_recently(history, lookback=2):
            return COOPERATE with probability 0.3, else DEFECT
        else:
            return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection** - Only cooperates when strategically necessary
2. **Maximizes free-riding** - Actively seeks situations where others meet the threshold
3. **Probabilistic cooperation** - Avoids being predictably exploited while maintaining threshold
4. **Endgame defection** - Extracts maximum value when future consequences disappear
5. **Adaptive parasitism** - Cooperates just enough to keep cooperative players contributing, then exploits them
'''

description_EXPLOITATIVE_77 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The key insight in this game is that **defectors get strictly higher payoffs than cooperators when the threshold is met**. My strategy exploits this by attempting to free-ride on others' cooperation while ensuring I don't sink the collective ship (which would hurt me too). I want to be a defector in a world where exactly m others cooperate.

## Strategy Overview

I will estimate the cooperation probability of the population and strategically position myself to:
1. **Defect when I predict enough others will cooperate** (free-ride)
2. **Cooperate only when my contribution is likely pivotal** (threshold is at risk)
3. **Punish excessive defection to prevent collapse** (protect my baseline)

---

## Decision Rules

### Round 1: Cautious Defection
- **Action: DEFECT**
- Rationale: No information yet. Defecting is strictly dominant if threshold is met, and I preserve my endowment to assess others' behavior.

### Rounds 2 through r-1: Adaptive Exploitation

**Step 1: Calculate cooperation rate from history**
```
coop_rate = (total C plays by others) / (total decisions by others)
expected_cooperators = coop_rate × (n - 1)
```

**Step 2: Determine action based on expected cooperators**

```
IF expected_cooperators >= m + 1:
    # Plenty of cooperators - DEFECT and free-ride
    ACTION = DEFECT

ELSE IF expected_cooperators >= m - 0.5 AND expected_cooperators < m + 1:
    # Threshold is borderline - cooperate with probability to be pivotal
    # But mix in some defection to exploit
    pivot_probability = (m - expected_cooperators + 0.5) / 1.5
    ACTION = COOPERATE with probability pivot_probability, else DEFECT

ELSE IF expected_cooperators < m - 0.5:
    # Too few cooperators - threshold likely won't be met
    # Cooperate to try to bootstrap cooperation (protect k payoff)
    # But only if my cooperation could plausibly help reach threshold
    IF expected_cooperators + 1 >= m - 1:
        ACTION = COOPERATE
    ELSE:
        # Hopeless - save my endowment
        ACTION = DEFECT
```

**Step 3: Exploitation adjustment based on game position**

```
# If I've been cooperating more than average, shift toward defection
my_coop_rate = (my C plays) / (rounds played)
IF my_coop_rate > coop_rate + 0.15:
    # I'm being exploited - increase defection probability by 20%
    Adjust toward DEFECT

# If threshold has been met consistently (>70% of rounds), lean toward defection
IF threshold_met_rate > 0.7:
    # Others are reliably cooperating - exploit harder
    Shift 15% probability toward DEFECT
```

### Last Round (Round r): Pure Exploitation
- **Action: DEFECT**
- Rationale: No future rounds to punish me. If others cooperate, I get maximum payoff (1 + k). If they don't, I at least keep my endowment.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2, m = 2 | Defect unless cooperation rate > 0.8 | Need perfect cooperation; too risky |
| m very close to n | Cooperate more readily | Each player is likely pivotal |
| m very small relative to n | Defect aggressively | Easy to free-ride |
| All others defected last round | Cooperate once | Signal willingness; test for recovery |
| Threshold never met so far | Evaluate if salvageable; if rounds_remaining × (n-1) × 0.5 < m, defect always | Don't throw good money after bad |

---

## Pseudocode Summary

```python
def threshold_vulture(round, history, n, m, r, k):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT  # Last round - pure exploitation
    
    others_coop = count_others_cooperations(history)
    others_total = count_others_decisions(history)
    coop_rate = others_coop / others_total
    expected_coop = coop_rate * (n - 1)
    
    if expected_coop >= m + 1:
        return DEFECT
    elif expected_coop >= m - 0.5:
        pivot_prob = (m - expected_coop + 0.5) / 1.5
        return COOPERATE with probability pivot_prob
    elif expected_coop + 1 >= m - 1:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever others are likely to carry the threshold
2. **Minimizes wasted cooperation**: Only cooperates when pivotal or to prevent collapse
3. **Endgame exploitation**: Guarantees defection in final round
4. **Adaptive parasitism**: Adjusts to exploit cooperative populations harder while protecting against collapse
'''

description_EXPLOITATIVE_78 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight in this game is that **defectors receive strictly higher payoffs than cooperators when the threshold is met** (they get both the private payoff AND the collective reward). My strategy aims to be a defector in rounds where I predict enough others will cooperate to meet the threshold, while cooperating only when necessary to ensure the threshold is met and I receive the bonus.

## Strategy Overview

I will track cooperation patterns to estimate how many players will cooperate each round, then make the selfish choice:
- **Defect** if I predict ≥ m others will cooperate (free-ride on their contribution)
- **Cooperate** only if my contribution appears necessary to reach threshold m

## Decision Rules

### Round 1 (Cold Start)
- **Defect** in the first round
- Rationale: With no history, I cannot predict others' behavior. Many strategies start cooperatively, so I attempt to free-ride. Even if threshold fails, I keep my endowment.

### Rounds 2 through r-1 (Middle Game)

**Step 1: Estimate expected cooperators**
- Calculate `coop_rate[i]` = (times player i cooperated) / (rounds played) for each other player
- Calculate `expected_cooperators` = Σ coop_rate[i] for all i ≠ me

**Step 2: Decision logic**
```
if expected_cooperators >= m:
    DEFECT  # Free-ride: threshold likely met without me
    
elif expected_cooperators >= m - 1:
    # Borderline case: threshold might need me
    if expected_cooperators >= m - 0.5:
        DEFECT  # Lean toward free-riding
    else:
        COOPERATE  # My contribution likely tips us over
        
elif expected_cooperators >= m - 1.5:
    COOPERATE  # Need to contribute to have a chance
    
else:
    DEFECT  # Threshold unlikely even with my help; save endowment
```

**Step 3: Adaptive adjustment based on recent trends**
- Weight recent rounds more heavily: use exponential moving average with α = 0.3
- `adjusted_rate[i]` = α × (last round action) + (1-α) × (previous adjusted_rate[i])
- Use adjusted rates in the calculation above

### Last Round (Round r)
- **Always Defect**
- Rationale: No future consequences. If others cooperate enough, I get k+1. If not, I still keep 1. This dominates cooperating in a one-shot scenario.

### Second-to-Last Round (Round r-1)
- **Bias toward Defection**: Reduce expected_cooperators threshold by 0.5
- Rationale: Others may also defect anticipating the endgame, so lean toward defection earlier

## Exploitation Mechanisms

### 1. Identifying "Reliable Cooperators"
- Tag players with coop_rate > 0.8 as "suckers"
- When counting expected cooperators, weight suckers at 0.95 (near-certain cooperation)
- These players subsidize my defection

### 2. Punishing No One
- Unlike tit-for-tat strategies, I never punish defectors
- My goal is exploitation, not norm enforcement
- If others defect, I simply update my estimates and act accordingly

### 3. Threshold Hovering
- When expected_cooperators ≈ m, I want to be the marginal defector
- Let others bear the cost of cooperation while I claim the bonus

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    # Calculate expected cooperators using exponential moving average
    expected_coop = 0
    for each other player i:
        ema[i] = exponential_moving_average(history[i], alpha=0.3)
        expected_coop += ema[i]
    
    # Endgame adjustment
    if round >= r - 1:
        expected_coop -= 0.5
    
    # Decision
    if expected_coop >= m:
        return DEFECT
    elif expected_coop >= m - 0.7:
        return DEFECT  # Gamble on free-riding
    elif expected_coop >= m - 1.5:
        return COOPERATE  # My contribution matters
    else:
        return DEFECT  # Lost cause, save endowment
```

## Why This Strategy is Robust

1. **Against cooperators**: I exploit them mercilessly by free-riding
2. **Against defectors**: I don't waste resources trying to cooperate with non-contributors
3. **Against conditional cooperators**: I appear as a defector, which may trigger mutual defection—but I still keep my endowment
4. **Adaptive**: Continuously updates beliefs based on observed behavior
'''

description_EXPLOITATIVE_79 = '''
# Exploitative Strategy: "Threshold Manipulator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in the Collective Risk Dilemma: when exactly m players cooperate, defectors receive the highest possible payoff (1 + k) while cooperators receive only k. My goal is to maximize the probability that I'm a defector when the threshold is *just barely* met by others.

## Strategic Analysis

The key insight is that I want to:
1. **Free-ride** whenever I predict others will meet the threshold without me
2. **Reluctantly cooperate** only when my contribution is pivotal to avoiding collective disaster
3. **Never be a sucker** - avoid cooperating when the threshold won't be met anyway
4. **Manipulate expectations** - train others to cooperate more through selective defection

## Decision Rules

### Round Classification

**First Round:**
- **Defect.** This is pure information gathering. I sacrifice nothing by defecting early, and I learn about opponent tendencies. If fewer than m others cooperate, I lost nothing. If m or more cooperate, I get the maximum payoff (1 + k).

**Last Round:**
- **Defect.** No future consequences exist. This is a one-shot game where defection weakly dominates. If others meet the threshold, I free-ride. If they don't, I kept my endowment.

**Middle Rounds (rounds 2 through r-1):**

Calculate from history:
- `coop_rate` = (total cooperations by others) / (total opportunities)
- `expected_cooperators` = `coop_rate` × (n - 1)
- `threshold_gap` = m - `expected_cooperators`

**Decision Logic:**

```
IF expected_cooperators >= m:
    DEFECT  # Others likely meet threshold; free-ride
    
ELSE IF expected_cooperators >= m - 1 AND expected_cooperators < m:
    # I might be pivotal - cooperate with probability based on how close we are
    pivot_probability = (expected_cooperators - (m - 1.5)) × 2
    COOPERATE with probability max(0.3, pivot_probability)
    
ELSE IF expected_cooperators < m - 1:
    DEFECT  # Threshold won't be met even if I cooperate; don't waste contribution
```

### Adaptive Refinements

**Trend Detection:**
- Track cooperation rate over last 3 rounds vs. overall rate
- If recent cooperation is *increasing*: bias toward defection (others are picking up slack)
- If recent cooperation is *decreasing*: slightly increase cooperation probability only if near threshold

**Sucker Avoidance Rule:**
- If I cooperated in round t and fewer than m total cooperated: reduce cooperation probability by 20% for next round
- Never cooperate twice in a row if I was a "sucker" (cooperated while threshold wasn't met)

**Exploitation Detection:**
- If the same pattern emerges (e.g., exactly m-1 others cooperate repeatedly), they may be trying to force my cooperation
- Response: Defect for 2 rounds to test if they'll increase cooperation

## Pseudocode Implementation

```
function decide(round, history, n, m, k, r):
    
    # Edge cases
    if round == 1:
        return DEFECT
    if round == r:
        return DEFECT
    
    # Calculate statistics from history
    others_coops = [count cooperations by others in each past round]
    my_coops = [my cooperation history]
    
    coop_rate = sum(others_coops) / ((round - 1) * (n - 1))
    expected_coops = coop_rate * (n - 1)
    
    # Recent trend (last 3 rounds or available)
    recent_rounds = min(3, round - 1)
    recent_rate = sum(others_coops[-recent_rounds:]) / (recent_rounds * (n - 1))
    
    # Sucker penalty
    sucker_penalty = 0
    for t in range(len(my_coops)):
        if my_coops[t] == C and others_coops[t] < m - 1:
            sucker_penalty += 0.2
    
    # Base decision
    if expected_coops >= m:
        return DEFECT  # Free-ride
    
    if expected_coops < m - 1:
        return DEFECT  # Lost cause
    
    # Pivotal zone: m-1 <= expected < m
    base_coop_prob = 0.4 + (expected_coops - (m - 1)) * 0.6
    
    # Adjustments
    if recent_rate > coop_rate:
        base_coop_prob -= 0.15  # Others trending up, defect more
    
    base_coop_prob -= sucker_penalty
    base_coop_prob = max(0.1, min(0.7, base_coop_prob))
    
    return COOPERATE with probability base_coop_prob, else DEFECT
```

## Why This Strategy is Exploitative

1. **Guaranteed defection on bookends** - First and last rounds offer no strategic benefit to cooperation
2. **Free-riding priority** - Default action is defection unless cooperation is absolutely necessary
3. **Sucker avoidance** - Never repeatedly waste contributions when threshold isn't met
4. **Trend exploitation** - If others cooperate more, I cooperate less
5. **Probabilistic unpredictability** - Makes it harder for opponents to condition on my behavior
'''

description_EXPLOITATIVE_80 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The exploitative approach recognizes a key asymmetry: **defectors earn more than cooperators when the threshold is met**. The optimal exploitative strategy is to ensure the threshold is met (to collect the bonus k) while personally defecting (to also keep the endowment of 1). This means I want *exactly enough others* to cooperate while I free-ride.

## Strategy: "Threshold Stalker"

### Key Observations

1. **Best outcome for me**: Exactly m others cooperate, I defect → I get 1 + k
2. **Second best**: I cooperate as part of exactly m cooperators → I get k
3. **Worst outcome**: Threshold not met → I get 1 (or 0 if I cooperated)

### Decision Rules

#### Round 1 (Cold Start)
- **Defect** unconditionally
- Rationale: No information yet. If others are cooperative, I free-ride. If they're not, I didn't waste my contribution. This also signals that I'm not an easy mark.

#### Middle Rounds (rounds 2 to r-1)

Let `c_prev` = number of cooperators in the previous round.

**Rule 1: Free-ride on abundance**
- If `c_prev ≥ m`: **Defect**
- Rationale: There are enough cooperators without me. Continue exploiting.

**Rule 2: Strategic minimal contribution**
- If `c_prev = m - 1`: **Cooperate with probability p = 1/n**
- Rationale: The threshold is one short. I'll occasionally be the hero, but probabilistically expect someone else to step up. Low probability prevents me from being the predictable sucker.

**Rule 3: Abandon lost causes**
- If `c_prev < m - 1`: **Defect**
- Rationale: Too few cooperators; my single contribution won't reach threshold. Don't throw good money after bad.

**Rule 4: Exploit momentum**
- If `c_prev ≥ m` for the last 2 consecutive rounds: **Defect with certainty**
- Rationale: Stable cooperation detected. These are likely unconditional cooperators or threshold-maintainers. Exploit them ruthlessly.

**Rule 5: Punish collective defection**
- If `c_prev = 0` for 2+ consecutive rounds: **Continue defecting**
- Rationale: The group has collapsed into mutual defection. No point being the lone cooperator.

#### Final Round (round r)
- **Defect** unconditionally
- Rationale: No future consequences. Pure dominant strategy logic applies.

#### Second-to-Last Round (round r-1)
- Same as middle rounds, but **bias toward defection**
- If `c_prev = m - 1`: Cooperate with probability `p = 0.5/n` (halved)
- Rationale: Others may be planning end-game defection; reduce exposure.

### Pseudocode

```
function decide(round, history, n, m, k, r):
    
    # Last round: always defect
    if round == r:
        return DEFECT
    
    # First round: always defect
    if round == 1:
        return DEFECT
    
    c_prev = count_cooperators(history, round - 1)
    
    # Abundance: free-ride
    if c_prev >= m:
        return DEFECT
    
    # Lost cause: don't waste contribution
    if c_prev < m - 1:
        return DEFECT
    
    # Threshold is exactly one short (c_prev == m - 1)
    # Occasionally contribute, but make it rare
    
    if round == r - 1:
        p = 0.5 / n  # More conservative near end
    else:
        p = 1.0 / n
    
    if random() < p:
        return COOPERATE
    else:
        return DEFECT
```

### Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2, m = 2 | Follow standard rules (mostly defect) | Both must cooperate for threshold; unlikely, so defect |
| m = n - 1 | Slightly increase cooperation probability when c_prev = m-1 | Nearly everyone needed; might be worth contributing |
| k is very large | Same strategy | High k makes threshold valuable, but the *relative* advantage of defecting when threshold is met remains |
| k is barely > 1 | Same strategy | Low k means less loss from missed thresholds |
| r = 2 | Defect both rounds | No time to establish patterns |

### Why This Is Exploitative

1. **Never cooperates when not needed** - If threshold is met without me, I take the bonus without paying
2. **Rarely cooperates when pivotal** - Even when I'm the swing vote, I gamble that someone else will step up
3. **Never cooperates in hopeless situations** - No wasted contributions
4. **End-game defection** - Extracts maximum value when punishment is impossible
5. **Punishes no one** - Pure self-interest; I don't sacrifice to punish others

This strategy is a **pure free-rider** that contributes just enough (probabilistically) to avoid complete collapse, while maximizing personal extraction from any cooperation that emerges.
'''

description_EXPLOITATIVE_81 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met anyway**. The optimal exploitative approach is to defect whenever I predict others will meet the threshold without me, and only cooperate when my contribution is pivotal. I will learn opponent behavior patterns and exploit predictable cooperators.

## Strategy: "Threshold Predator"

### Decision Framework

My strategy maintains a **cooperation probability estimate** for each player based on observed history, then makes decisions based on whether the threshold will likely be met without my contribution.

### Detailed Decision Rules

#### Round 1 (Cold Start)
- **Defect.**
- Rationale: With no history, I cannot predict others. Defecting lets me observe who the "natural cooperators" are while guaranteeing myself a payoff of 1 (or 1+k if others cooperate enough).

#### Rounds 2 through (r-1) (Learning and Exploitation Phase)

**Step 1: Estimate each player's cooperation probability**
```
For each player j ≠ me:
    p_j = (times player j cooperated) / (rounds played so far)
```

**Step 2: Calculate probability threshold is met without me**
```
P(at least m cooperators among other n-1 players)
= sum over all subsets S of size ≥ m of: ∏(j∈S) p_j × ∏(j∉S) (1-p_j)
```

**Step 3: Calculate expected payoff for each action**
```
E[Defect] = 1 + k × P(≥m others cooperate)
E[Cooperate] = 0 + k × P(≥m-1 others cooperate)
```

**Step 4: Decision**
- If `E[Defect] ≥ E[Cooperate]`: **Defect**
- Otherwise: **Cooperate**

**Simplified heuristic version** (if computation is constrained):
- If the expected number of other cooperators `Σp_j ≥ m + 0.5`: **Defect** (threshold likely met without me)
- If `Σp_j < m - 0.5`: **Defect** (threshold unlikely even with me, so save my contribution)
- If `m - 0.5 ≤ Σp_j < m + 0.5`: **Cooperate** (I'm likely pivotal)

#### Final Round (Round r)

**Defect unconditionally.**

Rationale: There's no future to incentivize others, and no retaliation possible. Pure exploitation.

### Adaptive Adjustments

**Detecting Conditional Cooperators:**
If I observe players who cooperate only when I cooperated in the previous round, I will:
- Cooperate occasionally (every 3-4 rounds) to "reset" their cooperation, then defect to harvest the surplus

**Detecting Unconditional Cooperators:**
Players with `p_j > 0.8` after 3+ rounds are likely unconditional cooperators. These are prime exploitation targets—I weight them heavily in my "threshold met without me" calculation.

**Detecting Retaliators:**
If overall cooperation drops significantly after I defect, I temporarily cooperate for 1-2 rounds to restore baseline, then resume exploitation.

### Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    # Estimate cooperation probabilities
    p = []
    for each other player j:
        p[j] = j's cooperation count / (round - 1)
    
    # Calculate P(threshold met without me)
    P_without_me = probability_at_least_m_cooperate(p, m)
    P_with_me = probability_at_least_m_cooperate(p, m-1)
    
    E_defect = 1 + k * P_without_me
    E_cooperate = 0 + k * P_with_me
    
    if E_defect >= E_cooperate:
        return DEFECT
    else:
        return COOPERATE
```

### Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2, m = 2 | Always Defect | I can never free-ride; if I must cooperate, so must they, but last round defection unravels everything |
| m = n-1 | Cooperate in middle rounds if others are cooperating | I'm almost always pivotal |
| k is very large | More willing to cooperate when pivotal | The reward for threshold being met dominates |
| All others always defect | Always Defect | Threshold will never be met; minimize losses |

This strategy maximizes exploitation of predictable cooperators while providing just enough cooperation to keep conditional cooperators engaged when needed.
'''

description_EXPLOITATIVE_82 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that this game has a critical asymmetry: **defectors get the bonus k PLUS their private endowment (total: 1+k) while cooperators only get the bonus k (total: k)**. This means the optimal position is to defect while *exactly* m others cooperate. My strategy exploits cooperative players by free-riding when possible, while contributing just enough to avoid collective disaster when necessary.

## Decision Rules

### Information Tracking
- `coop_counts[t]` = number of cooperators in round t (excluding myself)
- `my_actions[t]` = my action in round t
- `rounds_remaining` = r - current_round

### Round-by-Round Logic

**FIRST ROUND:**
- **Defect.** 
- Rationale: This is pure information gathering. I want to see how cooperative the population is before committing resources. If the threshold is met without me, I profit maximally. If not, I learn the population is uncooperative.

**MIDDLE ROUNDS (rounds 2 through r-1):**

Calculate `baseline_cooperators` = average cooperation count from others over previous rounds.

```
IF baseline_cooperators >= m:
    # Others are reliably meeting threshold without me
    DEFECT (free-ride)
    
ELSE IF baseline_cooperators >= m - 1:
    # Threshold is "on the edge" - others are close but need help
    # Be a reluctant cooperator, but not always
    IF I defected last round AND threshold was NOT met:
        COOPERATE (be the marginal contributor)
    ELSE:
        DEFECT (test if others will step up)
        
ELSE IF baseline_cooperators < m - 1:
    # Population is too uncooperative - threshold unlikely to be met
    # Don't waste resources on lost causes
    DEFECT
```

**Exploitation Adjustment:**
```
IF threshold was met in last round AND I defected:
    # I successfully free-rode - keep doing it
    DEFECT
    
IF threshold was NOT met for 2+ consecutive rounds:
    # Collective failure is occurring
    # Only cooperate if my cooperation would exactly meet threshold
    IF baseline_cooperators == m - 1:
        COOPERATE
    ELSE:
        DEFECT
```

**LAST ROUND:**
- **Always Defect.**
- Rationale: No future rounds to punish defection. Pure exploitation opportunity. If others have established cooperative patterns, they'll likely continue, and I collect maximum payoff. If not, there's no point cooperating anyway.

### Edge Case Handling

**If n = m (everyone needed):**
- Cooperate in early rounds to establish pattern, then defect in final 1-2 rounds
- Rationale: Need to build cooperation first since free-riding is impossible with this threshold

**If m is very low (m ≤ n/3):**
- Defect almost always - high probability threshold is met without my contribution

**If m is very high (m > 2n/3):**
- More willing to cooperate in middle rounds since threshold is fragile
- Still defect in final round

**If k is very large (k > 3):**
- The disaster cost is severe; be slightly more cooperative to avoid mutual destruction
- But still defect when I observe m+ others cooperating reliably

**If r is very short (r ≤ 3):**
- Defect every round - not enough time for complex dynamics to develop

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    avg_others_coop = average(others_cooperated in history)
    last_threshold_met = (others_cooperated[round-1] + my_action[round-1]) >= m
    
    if avg_others_coop >= m:
        return DEFECT  # free-ride
    
    if avg_others_coop >= m - 1:
        if not last_threshold_met and my_action[round-1] == DEFECT:
            return COOPERATE  # reluctant marginal contributor
        else:
            return DEFECT  # test the waters
    
    return DEFECT  # lost cause, don't waste resources
```

## Why This Is Exploitative

1. **Maximizes free-riding**: Always seeks to be a defector when threshold is met
2. **Never cooperates out of altruism**: Only cooperates strategically when I'm the marginal contributor
3. **Exploits cooperative populations**: Treats reliable cooperators as resources to parasitize
4. **Abandons lost causes**: Doesn't waste endowment on uncooperative groups
5. **End-game exploitation**: Guaranteed defection when punishment is impossible
'''

description_EXPLOITATIVE_83 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding** when others cooperate. The optimal exploitative approach is to defect whenever possible while ensuring the threshold is still met by others. I need to estimate how many others will cooperate and position myself just outside that group when profitable.

## Strategy: "Threshold Parasite"

### Decision Framework

**Primary Goal:** Defect and collect the bonus (1 + k) whenever I predict at least m others will cooperate without me.

**Fallback Goal:** Cooperate only when my contribution is likely pivotal to reaching threshold m.

---

## Decision Rules

### Round-by-Round Logic

```
For each round t:

1. Calculate cooperation_rate = (total C plays by others in rounds 1 to t-1) / ((n-1) * (t-1))
   
2. Estimate expected_cooperators = cooperation_rate * (n-1)

3. Decision:
   - If expected_cooperators >= m: DEFECT (free-ride on others)
   - If expected_cooperators < m - 1: DEFECT (threshold unreachable anyway)
   - If m - 1 <= expected_cooperators < m: COOPERATE (I'm pivotal)
```

### Edge Case Handling

**First Round (t = 1):**
- No history exists. Use a probabilistic heuristic based on game parameters.
- Calculate `baseline_coop_probability = m / n` (the "fair share" cooperation rate)
- If `(n-1) * baseline_coop_probability >= m`: **DEFECT** (bet others will cover it)
- Otherwise: **DEFECT anyway** if `m > n/2` (threshold too high, unlikely to be met)
- Otherwise: **COOPERATE** (be part of the initial coalition to establish threshold-meeting behavior)

*Simplified first-round rule:* If `m <= n/2`, COOPERATE. Otherwise, DEFECT.

**Last Round (t = r):**
- No future consequences exist. Pure exploitation:
- If `expected_cooperators >= m`: **DEFECT** (guaranteed)
- If `expected_cooperators >= m - 1` and `expected_cooperators < m`: **DEFECT** (gamble that one more person cooperates; EV calculation favors defection when k is moderate)
- Only cooperate if historical data strongly suggests exactly m-1 others will cooperate AND I've been consistently cooperating (others may be counting on me)

**When Threshold Has Never Been Met:**
- If threshold hasn't been reached in the last 3 rounds, switch to pure **DEFECT** (the collective has failed; no point contributing to a lost cause)

**When I'm Being Exploited (I cooperate but too many others defect):**
- Track `my_contribution_wasted` = rounds where I played C but total cooperators < m
- If `my_contribution_wasted > r/4`: Switch to permanent **DEFECT** (cut losses)

---

## Adaptive Refinements

### Opponent Classification (after round 3)

For each observable pattern in aggregate behavior:

1. **Generous Environment** (cooperation_rate > m/n + 0.1): Exploit aggressively → DEFECT
2. **Marginal Environment** (cooperation_rate ≈ m/n ± 0.1): Be pivotal-aware → use core logic
3. **Hostile Environment** (cooperation_rate < m/n - 0.1): Abandon hope → DEFECT

### Cooperation Momentum Detection

```
recent_coop_rate = cooperation in last 2 rounds / (2 * (n-1))
trend = recent_coop_rate - overall_cooperation_rate

If trend > 0.15: Others are becoming more cooperative → safe to DEFECT
If trend < -0.15: Cooperation collapsing → DEFECT (don't prop up a failing system)
```

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE if m <= n/2 else DEFECT
    
    coop_rate = count_others_cooperation(history) / ((n-1) * (round-1))
    expected_coops = coop_rate * (n-1)
    
    # Check for collapse
    if not threshold_met_recently(history, window=3):
        return DEFECT
    
    # Check if being exploited
    if wasted_contributions(history) > r/4:
        return DEFECT
    
    # Last round: maximize selfishly
    if round == r:
        return DEFECT if expected_coops >= m - 0.5 else DEFECT  # Almost always defect
    
    # Core logic
    if expected_coops >= m:
        return DEFECT  # Free ride
    elif expected_coops < m - 1:
        return DEFECT  # Hopeless
    else:
        return COOPERATE  # I'm pivotal
```

---

## Why This Is Exploitative

1. **Maximizes free-riding:** Defects whenever others are likely to cover the threshold
2. **Abandons lost causes:** Doesn't waste contributions when collective action has failed
3. **Punishes no one, exploits everyone:** Never retaliates, just optimally positions
4. **Last-round betrayal:** Takes the guaranteed defection payoff when no future rounds matter
5. **Adaptive to generosity:** The more cooperative others are, the more aggressively this defects
'''

description_EXPLOITATIVE_84 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that this game has a critical asymmetry: **defectors get the bonus k PLUS their endowment when the threshold is met, while cooperators only get k**. The optimal exploitative position is to defect while exactly m others cooperate. My strategy aims to maximize free-riding while ensuring the threshold is met just often enough to extract value.

## Strategy Overview

I will estimate how many "reliable cooperators" exist among other players and strategically defect whenever I predict the threshold will be met without me. When cooperation appears insufficient, I'll conditionally cooperate only if my contribution is pivotal.

---

## Decision Rules

### Round 1: Defect
- No information available, so I defect to gather data
- If threshold happens to be met, I get maximum payoff (1 + k)
- If not met, I only lose the bonus k, same as cooperators

### Rounds 2 through r-1: Adaptive Exploitation

**Step 1: Estimate cooperation probability for each opponent**

For each player j ≠ i, calculate their cooperation rate:
```
coop_rate[j] = (times j cooperated) / (rounds observed)
```

**Step 2: Estimate expected cooperators this round**

```
expected_cooperators = sum(coop_rate[j] for all j ≠ i)
```

**Step 3: Decision logic**

```
IF expected_cooperators >= m + 0.5:
    DEFECT  # Free-ride: threshold likely met without me
    
ELIF expected_cooperators >= m - 0.5 AND expected_cooperators < m + 0.5:
    # Threshold is borderline - be strategic
    IF my recent defections might be noticed (defected last 2+ rounds):
        COOPERATE with probability 0.3  # Occasionally "contribute" to maintain threshold
    ELSE:
        DEFECT  # Still try to free-ride
        
ELIF expected_cooperators < m - 0.5:
    # Threshold unlikely to be met
    IF expected_cooperators + 1 >= m AND k > 1.5:
        COOPERATE  # My contribution could be pivotal and reward is worth it
    ELSE:
        DEFECT  # Not worth contributing to a lost cause
```

### Last Round (Round r): Almost Always Defect

```
IF expected_cooperators >= m:
    DEFECT  # Maximum exploitation, no future consequences
ELIF expected_cooperators >= m - 1 AND k > 2:
    COOPERATE  # Only if pivotal and reward is very high
ELSE:
    DEFECT  # No point cooperating for likely failure
```

---

## Refinements for Robustness

### Detecting Other Exploiters
If I observe players who defect when cooperation is high and cooperate when it's low (inverse correlation), they're likely running similar strategies. In this case:
```
IF multiple_exploiters_detected (3+ players with defection_rate > 0.6):
    Increase my cooperation probability by 0.2 in borderline cases
    # Prevents collective collapse where no one cooperates
```

### Handling Highly Cooperative Pools
If average cooperation rate across all opponents > 0.7:
```
ALWAYS DEFECT (except possibly round 1 for camouflage)
# This is the dream scenario - maximum parasitism
```

### Handling Highly Defective Pools
If average cooperation rate < 0.3:
```
ALWAYS DEFECT
# Threshold will rarely be met; don't waste contributions
```

---

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    coop_rates = calculate_cooperation_rates(history)
    expected_coop = sum(coop_rates)
    
    if round == r:  # Last round
        if expected_coop >= m:
            return DEFECT
        else:
            return DEFECT  # Almost never cooperate last round
    
    # Middle rounds
    if expected_coop >= m + 0.5:
        return DEFECT
    elif expected_coop >= m - 0.5:
        if recently_defected_heavily() and random() < 0.3:
            return COOPERATE
        return DEFECT
    else:
        if expected_coop + 1 >= m and k > 1.5:
            return COOPERATE
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defects by default** - Only cooperates when strategically necessary
2. **Free-rides on cooperators** - Maximizes the 1+k payoff when others maintain threshold
3. **Never cooperates in final round** - No future punishment possible
4. **Treats cooperation as costly insurance** - Only pays when pivotal
5. **Exploits predictable opponents** - High cooperation rates signal easy targets
'''

description_EXPLOITATIVE_85 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that in this game, **defectors get strictly higher payoffs than cooperators when the threshold is met**. My goal is to maximize the probability that exactly m players cooperate *and I'm not one of them*. I want to free-ride on others' cooperation while contributing just enough to prevent total collapse when necessary.

## Strategy Overview

I will estimate the cooperation level of opponents and adaptively position myself to defect when cooperation is likely sufficient, while occasionally cooperating to "seed" cooperation and prevent complete breakdown—but only when it's instrumentally necessary.

---

## Decision Rules

### Round-by-Round Logic

```
Let:
  - t = current round number (1 to r)
  - h = history of all players' actions
  - c_prev = number of cooperators in previous round (excluding me)
  - my_prev = my action in previous round
  - coop_rate = rolling average cooperation rate of opponents over all past rounds
```

### Phase 1: First Round (t = 1)

**Action: DEFECT**

Rationale: No information yet. Start by defecting to test the waters. If others cooperate enough, I profit maximally. If threshold fails, I only lose the bonus (which I wouldn't have gotten anyway as a cooperator).

### Phase 2: Early Rounds (t = 2 to ⌊r/3⌋)

**Adaptive Probing:**

```
if c_prev >= m:
    ACTION: DEFECT  (threshold was met without me—exploit!)
elif c_prev == m - 1:
    ACTION: COOPERATE with probability 0.3, else DEFECT
    (I might be pivotal—hedge slightly)
elif c_prev < m - 1:
    ACTION: COOPERATE with probability 0.5
    (need to seed cooperation to prevent collapse)
```

### Phase 3: Middle Rounds (⌊r/3⌋ < t ≤ ⌊2r/3⌋)

**Exploitation with Maintenance:**

```
if coop_rate of opponents >= m/(n-1):
    # Others cooperate enough on average
    ACTION: DEFECT
elif coop_rate of opponents is in [0.5 * m/(n-1), m/(n-1)):
    # Borderline—be pivotal sometimes
    if c_prev >= m:
        ACTION: DEFECT
    elif c_prev == m - 1:
        ACTION: COOPERATE
    else:
        ACTION: COOPERATE with probability 0.4
else:
    # Cooperation collapsing—invest to rebuild
    ACTION: COOPERATE
```

### Phase 4: Late Rounds (⌊2r/3⌋ < t < r)

**Intensified Exploitation:**

```
if c_prev >= m:
    ACTION: DEFECT (ride the wave)
elif c_prev == m - 1:
    ACTION: COOPERATE (I'm pivotal—worth it for the k bonus)
else:
    ACTION: DEFECT (threshold unlikely anyway, save my endowment)
```

### Phase 5: Final Round (t = r)

**Pure Exploitation:**

```
if estimated opponents cooperating >= m:
    ACTION: DEFECT (no future—maximize now)
else:
    ACTION: DEFECT (no future punishment possible, 
                    and unlikely to hit threshold anyway)
```

**Exception:** If `m = n-1` or `m = n` (my contribution is almost certainly pivotal), then COOPERATE only if I estimate others will bring total to exactly m with my help.

---

## Opponent Modeling

I track per-opponent cooperation rates:
- **Identify "suckers"**: Players who cooperate >70% of the time → I can safely defect when they're around
- **Identify "fellow exploiters"**: Players who defect >70% → Threshold unlikely, may need to cooperate occasionally to prevent mutual collapse

---

## Edge Case Handling

| Scenario | Action |
|----------|--------|
| `m = n` (everyone must cooperate) | DEFECT always—too risky, threshold rarely met |
| `m = 2` (low threshold) | DEFECT almost always—easy for others to meet |
| `k` is very large | Slightly more willing to cooperate when pivotal |
| `r = 2` (very short game) | Defect both rounds |
| Everyone defected last round | COOPERATE once to test if restart possible |

---

## Summary Pseudocode

```python
def choose_action(t, r, n, m, k, history):
    if t == r:
        return DEFECT  # Final round, no future
    
    c_prev = count_others_cooperating(history, t-1)
    coop_rate = average_opponent_cooperation(history)
    
    if c_prev >= m:
        return DEFECT  # Exploit successful cooperation
    elif c_prev == m - 1:
        return COOPERATE  # I'm pivotal
    elif t == 1:
        return DEFECT  # Probe
    elif coop_rate < 0.3 * m / (n - 1):
        return COOPERATE  # Rebuild cooperation
    else:
        return DEFECT  # Default to exploitation
```

---

## Why This Works

1. **Maximizes free-riding**: Defects whenever threshold is likely met without me
2. **Avoids collapse**: Cooperates just enough to maintain others' cooperation
3. **Exploits predictable cooperators**: Identifies and exploits unconditional cooperators
4. **Handles endgame**: Defects in final round where punishment is impossible
5. **Adaptive**: Responds to actual observed behavior, not assumptions
'''

description_EXPLOITATIVE_86 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The fundamental insight is that in a collective risk dilemma, **the most profitable position is to be a defector when exactly m others cooperate**. My strategy aims to maximize the probability of being in this parasitic position while avoiding the catastrophic outcome where fewer than m players cooperate.

## Strategy Overview

I will maintain a **cooperation probability** that I adjust based on observed cooperation levels, always trying to position myself just below what's needed while ensuring the threshold is still met by others. I exploit cooperative players by free-riding when safe, and I punish environments with too many defectors by occasionally cooperating to prevent total collapse (which hurts me too).

---

## Decision Rules

### Round 1: Calibrated Defection

**Action: Defect**

Rationale: I need information about opponent behavior. Defecting in round 1 maximizes my immediate payoff while gathering data. If there are enough natural cooperators, I get the bonus for free. If not, I learn the environment is hostile and adjust.

### Rounds 2 through (r-1): Adaptive Exploitation

Let `C_prev` = number of cooperators in the previous round (excluding me)

**Decision Logic:**

```
If C_prev >= m:
    # Threshold was met without me - EXPLOIT
    Action: Defect (probability 1.0)
    
Else if C_prev == m - 1:
    # I'm the pivotal player - cooperate reluctantly
    # But gradually reduce as rounds progress to test waters
    cooperation_prob = 0.8 - (0.3 * current_round / r)
    Action: Cooperate with probability cooperation_prob, else Defect
    
Else if C_prev < m - 1:
    # Dangerous territory - need to encourage cooperation
    # Cooperate with probability inversely related to cooperation deficit
    deficit = m - 1 - C_prev
    cooperation_prob = min(0.6, deficit / (n - 1))
    Action: Cooperate with probability cooperation_prob, else Defect
```

### Last Round (Round r): Pure Defection

**Action: Defect**

Rationale: No future rounds exist to punish me. This is the classic "last round defection" from repeated game theory. Regardless of history, defecting dominates in the final round from a purely selfish perspective.

---

## Refined Adaptive Mechanism

### Tracking Opponent Types

Maintain a running estimate of each opponent's cooperation rate:
```
For each player j ≠ i:
    coop_rate[j] = (times j cooperated) / (rounds observed)
```

### Exploitation Intensification

```
estimated_cooperators = sum(coop_rate[j] for all j ≠ i)

If estimated_cooperators >= m + 0.5:
    # Plenty of suckers - defect aggressively
    base_defect_prob = 0.95
    
Else if estimated_cooperators >= m - 0.5:
    # Marginal situation - be the swing vote strategically
    base_defect_prob = 0.6
    
Else:
    # Hostile environment - occasional cooperation needed
    base_defect_prob = 0.4
```

### Late-Game Acceleration

As the game progresses, increase defection probability:
```
round_multiplier = 1 + (0.3 * current_round / r)
final_defect_prob = min(1.0, base_defect_prob * round_multiplier)
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2, m = 2 | Defect always | Both must cooperate; I'll never be the sole enabler |
| m = n - 1 | Cooperate early, defect late | Need almost everyone; build trust then exploit |
| k very large (k > n) | Slightly more cooperative | Threshold benefit too valuable to risk losing |
| k barely > 1 | Defect aggressively | Reward doesn't justify cooperation cost |
| Previous round had exactly m cooperators (including me) | Test defection | See if others will cover for me |

---

## Summary Pseudocode

```python
def decide(round, history, n, m, r, k):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    others_cooperated_last = count_cooperators(history[-1]) - my_action(history[-1])
    
    if others_cooperated_last >= m:
        return DEFECT
    elif others_cooperated_last == m - 1:
        prob_coop = 0.8 - (0.3 * round / r)
        return COOPERATE if random() < prob_coop else DEFECT
    else:
        deficit = (m - 1) - others_cooperated_last
        prob_coop = min(0.6, deficit / (n - 1))
        return COOPERATE if random() < prob_coop else DEFECT
```

This strategy exploits cooperators ruthlessly while maintaining just enough flexibility to avoid catastrophic coordination failures.
'''

description_EXPLOITATIVE_87 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach recognizes a fundamental asymmetry: if exactly m players are needed to unlock the reward k, then being the (m+1)th cooperator is pure waste. The strategy aims to **free-ride on others' cooperation** while ensuring the threshold is met just often enough to extract value.

## Strategy Overview

This strategy maintains a probabilistic cooperation model based on observed behavior, then calculates whether my defection is "safe" (threshold will likely be met without me) or whether I need to cooperate to avoid collective failure.

---

## Decision Rules

### Information Tracked Each Round
- `coop_count[t]`: number of cooperators in round t
- `player_coop_rate[i]`: historical cooperation rate of player i
- `threshold_met[t]`: whether ≥m players cooperated in round t

### Round-by-Round Decision

**Round 1 (No History):**
- Defect with probability `(n-m)/n`, Cooperate with probability `m/n`
- Rationale: If everyone used this mixed strategy, expected cooperators ≈ m. I lean toward defection since I can't yet identify reliable cooperators.

**Rounds 2 through r-1 (Middle Game):**

```
1. Calculate expected_cooperators_without_me:
   sum of player_coop_rate[i] for all other players i

2. Calculate shortfall = m - expected_cooperators_without_me

3. If shortfall <= 0:
   → DEFECT (others likely cover the threshold)
   
4. If shortfall > 0:
   → Cooperate with probability = min(1, shortfall / uncertainty_factor)
   where uncertainty_factor = max(1, sqrt(rounds_played))
   
5. Reputation punishment: If a specific player defected after others 
   cooperated in 3+ consecutive rounds, reduce their expected cooperation 
   by 50% in calculations (they're likely exploiting too)
```

**Last Round (Round r):**
- **Always Defect**
- Rationale: No future rounds to punish me; pure one-shot logic applies. If others are rational, they defect too, so my cooperation wouldn't help anyway. If others irrationally cooperate, I maximize by free-riding.

---

## Detailed Decision Logic (Pseudocode)

```python
def decide(round_t, history, params):
    n, r, m, k = params
    
    # Last round: always defect
    if round_t == r:
        return DEFECT
    
    # First round: biased randomization toward defection
    if round_t == 1:
        return COOPERATE if random() < (m / n) * 0.8 else DEFECT
    
    # Calculate each opponent's cooperation tendency
    opponent_coop_rates = []
    for player_i in other_players:
        rate = player_i.cooperations / rounds_played
        # Discount players who seem exploitative (low rate despite threshold success)
        if rate < 0.3 and threshold_success_rate > 0.6:
            rate *= 0.5  # They're free-riding successfully
        opponent_coop_rates.append(rate)
    
    expected_others_cooperating = sum(opponent_coop_rates)
    
    # Core decision: Am I needed?
    if expected_others_cooperating >= m + 0.5:
        # Safe to defect - threshold likely met without me
        return DEFECT
    
    elif expected_others_cooperating >= m - 0.5:
        # Marginal zone - cooperate with low probability
        return COOPERATE if random() < 0.3 else DEFECT
    
    elif expected_others_cooperating >= m - 1.5:
        # I might be pivotal
        return COOPERATE if random() < 0.7 else DEFECT
    
    else:
        # Threshold very unlikely even with my help
        # Only cooperate if k is large enough to justify gambling
        if k > 2:
            return COOPERATE if random() < 0.4 else DEFECT
        else:
            return DEFECT  # Not worth the cost
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Defect (80% of time) | Probe others; lean exploitative |
| Round r (last) | Always Defect | No punishment possible |
| m = n-1 | Cooperate more often | Nearly everyone needed; can't free-ride |
| m = 2 (very low) | Defect heavily | Easy for others to cover |
| All others defected last round | Still calculate rates | Single round may be noise |
| k is very large (>3) | Slightly more cooperative | Threshold success is very valuable |
| Threshold never met so far | Evaluate if cooperation could help; if not, defect | Don't throw good money after bad |

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Only cooperates when mathematically necessary
2. **Exploits cooperators**: Uses their predictable behavior to safely defect
3. **Endgame betrayal**: Guarantees defection when punishment is impossible
4. **Adaptive parasitism**: Adjusts to find the minimum cooperation needed
5. **No reciprocity guilt**: Doesn't reward others' cooperation with my own unless strategically required
'''

description_EXPLOITATIVE_88 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that in this game, **defectors get strictly higher payoffs than cooperators when the threshold is met**. The optimal exploitative position is to be a defector when exactly m others cooperate. My strategy aims to manipulate others into being the "suckers" who cooperate while I free-ride, while maintaining just enough cooperation threat to keep the threshold achievable.

## Strategy Overview

I will track opponent cooperation patterns and position myself to defect whenever I estimate the threshold will be met without me, while cooperating only when absolutely necessary to prevent total collapse (which hurts everyone).

---

## Decision Rules

### Information Tracked Each Round:
- `coop_counts[t]` = number of cooperators in round t (excluding me)
- `player_coop_rate[i]` = historical cooperation rate of player i
- `threshold_met[t]` = whether threshold was met in round t
- `rounds_remaining` = r - current_round

### Round-by-Round Decision:

```
FUNCTION decide(round, history):
    
    # Calculate expected cooperators (excluding self)
    expected_others_coop = sum(player_coop_rate[i] for all other players i)
    
    # Key threshold: Do I expect m or more others to cooperate?
    others_likely_meet_threshold = (expected_others_coop >= m)
    others_likely_one_short = (m - 1 <= expected_others_coop < m)
    
    # DEFECT CONDITIONS (prioritized):
    
    # 1. Last round: Always defect (no future consequences)
    if round == r:
        return DEFECT
    
    # 2. Free-ride opportunity: Others will likely meet threshold without me
    if others_likely_meet_threshold:
        return DEFECT
    
    # 3. Hopeless case: Too few expected cooperators, even with me
    if expected_others_coop < m - 1:
        # Exception: Early game, try to establish cooperation
        if round <= 2 and expected_others_coop >= (m - 1) * 0.5:
            return COOPERATE
        return DEFECT
    
    # COOPERATE CONDITIONS:
    
    # 4. Pivotal player: I'm likely the swing vote
    if others_likely_one_short:
        # But not too often - cooperate probabilistically to share burden
        # Cooperate with probability based on how critical I am
        pivot_prob = calculate_pivot_probability()
        if random() < pivot_prob:
            return COOPERATE
        else:
            return DEFECT
    
    # Default: Defect
    return DEFECT
```

### Pivot Probability Calculation:

```
FUNCTION calculate_pivot_probability():
    # Base probability: Share burden among likely cooperators
    # If I estimate X players might cooperate, and we need m,
    # I should cooperate roughly m/X of the time
    
    likely_cooperators = count(players where coop_rate[i] > 0.3)
    
    if likely_cooperators == 0:
        return 0.5  # Uncertain, hedge
    
    # Adjust based on game phase
    time_pressure = rounds_remaining / r
    
    # Early game: More willing to cooperate to establish patterns
    # Late game: More willing to defect as end approaches
    
    base_prob = min(1.0, (m - 0.5) / (likely_cooperators + 1))
    adjusted_prob = base_prob * (0.5 + 0.5 * time_pressure)
    
    return adjusted_prob
```

---

## Edge Case Handling

### First Round (No History):
- **If m ≤ n/2**: DEFECT (optimistic that enough others will cooperate)
- **If m > n/2**: COOPERATE with probability m/n (need to establish some cooperation)

### Last Round:
- **Always DEFECT** - No future rounds to punish me

### Second-to-Last Round:
- Lean toward DEFECT unless I've been a consistent cooperator and need to maintain cover for others to cooperate in final round

### When Threshold Consistently Fails:
- If threshold hasn't been met in 3+ consecutive rounds, DEFECT (others have given up)

### When Threshold Consistently Met Without Me:
- Continue DEFECTING - this is the ideal exploitative position

### When I'm Clearly Being Exploited (I cooperate, threshold barely met):
- Reduce cooperation rate to force others to step up or face threshold failure

---

## Exploitation Mechanisms

1. **Pattern Recognition**: Identify reliable cooperators and let them carry the burden
2. **Brinkmanship**: Cooperate just enough to keep the threshold achievable, maximizing others' contributions
3. **Endgame Exploitation**: Aggressively defect as rounds run out
4. **Sucker Detection**: If others are unconditional cooperators, always defect
5. **Reputation Manipulation**: Occasional early cooperation to appear "fair" while extracting maximum value later

---

## Summary Table

| Situation | Action |
|-----------|--------|
| Last round | DEFECT |
| Expected cooperators ≥ m (without me) | DEFECT |
| Expected cooperators < m-1 (hopeless) | DEFECT |
| I'm pivotal (expected ≈ m-1) | COOPERATE probabilistically |
| First round, m ≤ n/2 | DEFECT |
| First round, m > n/2 | COOPERATE with prob m/n |
| Consecutive threshold failures | DEFECT |
'''

description_EXPLOITATIVE_89 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met**. The optimal exploitative position is to defect while exactly m others cooperate. My strategy aims to:
1. Extract maximum value by defecting when I predict the threshold will be met without me
2. Cooperate only when necessary to ensure the threshold is met (avoiding the catastrophic outcome)
3. Manipulate opponents into being the "reliable cooperators" while I free-ride

---

## Strategy: "Threshold Parasite"

### Decision Framework

**Key Variables to Track:**
- `coop_rates[i]`: Historical cooperation rate for each player i
- `round_coop_counts`: Number of cooperators in each past round
- `predicted_cooperators`: Expected cooperators this round (excluding me)
- `rounds_remaining`: r - current_round

---

### Decision Rules

#### Round 1: Defect
- **Action: DEFECT**
- Rationale: Gather information. Many strategies cooperate early to establish goodwill—exploit this. If threshold fails, the loss (missing bonus k) is shared; I keep my endowment regardless.

#### Rounds 2 through (r-1): Conditional Exploitation

Calculate `predicted_cooperators` = Σ(coop_rates[i]) for all other players

**Decision Logic:**

```
IF predicted_cooperators >= m + 0.5:
    ACTION = DEFECT  # Free-ride: threshold likely met without me
    
ELIF predicted_cooperators >= m - 1 AND predicted_cooperators < m + 0.5:
    # Marginal zone: I might be pivotal
    IF my cooperation in last round AND threshold was met last round:
        ACTION = DEFECT  # Test if others will cover for me
    ELSE:
        ACTION = COOPERATE  # Protect the threshold
        
ELIF predicted_cooperators < m - 1:
    # Threshold unlikely even with my help
    IF rounds_remaining > r/3 AND average_coop_rate > 0.3:
        ACTION = COOPERATE  # Invest to build cooperation momentum
    ELSE:
        ACTION = DEFECT  # Don't throw away endowment on lost cause
```

#### Last Round (Round r): Pure Exploitation
- **Action: DEFECT**
- Rationale: No future consequences. If others are conditional cooperators who need me, they've already committed based on history. Take the free-ride.

---

### Adaptive Mechanisms

**1. Opponent Classification:**
```
For each player i:
  IF coop_rates[i] > 0.8: label as "Sucker" (exploit heavily)
  IF coop_rates[i] between 0.4-0.8: label as "Conditional" (be cautious)
  IF coop_rates[i] < 0.4: label as "Defector" (ignore for threshold)
```

**2. Threshold Safety Margin:**
- When `num_suckers >= m`: Always defect (they'll carry the load)
- When `num_suckers + num_conditional >= m` but uncertain: Defect and observe
- When cooperation is genuinely scarce: Reluctantly cooperate to avoid mutual destruction

**3. Punishment Detection & Response:**
```
IF I defected last round AND cooperation dropped significantly:
    # Others may be punishing or are conditional on my behavior
    Temporarily cooperate for 1-2 rounds to restore baseline
    Then resume exploitation
```

---

### Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = m (everyone needed) | Cooperate rounds 1 to r-1, Defect round r | Must cooperate to get bonus, but last round is free |
| m = 2, many players | Almost always defect | High chance threshold met without me |
| All opponents defecting | Defect | No point cooperating alone |
| k is very large | Slightly more willing to cooperate in marginal cases | Protecting the threshold is more valuable |
| Opponent suddenly all defect after I defected | Cooperate once to test | Check if they're retaliating |

---

### Summary Pseudocode

```python
def decide(game_params, history):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    if current_round == 1:
        return DEFECT
    
    if current_round == r:
        return DEFECT
    
    coop_rates = calculate_opponent_coop_rates(history)
    predicted = sum(coop_rates.values())
    
    if predicted >= m + 0.5:
        return DEFECT
    elif predicted >= m - 1:
        if defected_last_round(history) and threshold_met_last_round(history):
            return DEFECT  # Keep exploiting
        else:
            return COOPERATE  # Pivotal protection
    else:
        if current_round < 2*r/3 and avg(coop_rates) > 0.3:
            return COOPERATE  # Build momentum
        else:
            return DEFECT  # Lost cause
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection** - Cooperation is the exception, not the rule
2. **Targets reliable cooperators** - Identifies and exploits "suckers"
3. **Abandons lost causes** - Doesn't waste endowment on failing coalitions
4. **End-game extraction** - Always defects in the final round
5. **Minimal cooperation** - Only cooperates when genuinely pivotal to protecting the bonus
'''

description_EXPLOITATIVE_90 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The fundamental insight is that **defection is always individually superior when the threshold is met by others**. My strategy aims to maximize free-riding opportunities by predicting when exactly `m` or more *other* players will cooperate, allowing me to defect and claim the full payoff (1 + k) while contributing nothing.

## Strategy Overview: "Threshold Stalker"

I will track cooperation patterns, identify reliable cooperators ("suckers"), and defect whenever I predict the threshold will be met without me. I only cooperate when my contribution appears necessary to reach the threshold—and even then, I'll test whether I can get away with defecting.

---

## Decision Rules

### Information Tracked Each Round
- `coop_count[t]`: Number of cooperators in round t
- `player_coop_rate[i]`: Historical cooperation rate of each player i
- `threshold_met[t]`: Boolean - was threshold met in round t?
- `rounds_remaining`: r - current_round

### Classification of Other Players
Based on observed history, classify each other player:
- **Reliable Cooperator**: cooperation rate > 0.7
- **Conditional Cooperator**: cooperation rate between 0.3 and 0.7
- **Defector**: cooperation rate < 0.3

### Core Decision Function

```
function decide(round, history):
    
    # Count expected cooperators (excluding myself)
    expected_others_cooperating = estimate_cooperators(history)
    
    # CASE 1: Enough others will likely cooperate → DEFECT (free-ride)
    if expected_others_cooperating >= m:
        return DEFECT
    
    # CASE 2: Exactly (m-1) others expected → I'm pivotal
    if expected_others_cooperating == m - 1:
        # In early/middle game: cooperate to establish the norm
        # In late game: test defection occasionally
        if rounds_remaining <= 2:
            return DEFECT  # End-game defection
        else:
            return COOPERATE  # Be the threshold-maker
    
    # CASE 3: Fewer than (m-1) others expected → threshold unreachable
    if expected_others_cooperating < m - 1:
        return DEFECT  # Don't waste contribution on lost cause
```

### Estimating Expected Cooperators

```
function estimate_cooperators(history):
    if round == 1:
        # Assume random behavior initially
        # Expected cooperators ≈ (n-1) * 0.5
        return (n - 1) * 0.5
    
    # Weight recent rounds more heavily
    weighted_sum = 0
    for each other player i:
        recent_rate = cooperation_rate(player_i, last 3 rounds)
        overall_rate = cooperation_rate(player_i, all rounds)
        
        # Blend: 70% recent, 30% overall
        expected_prob = 0.7 * recent_rate + 0.3 * overall_rate
        weighted_sum += expected_prob
    
    return weighted_sum
```

---

## Edge Case Handling

### Round 1 (No History)
- **If n - 1 ≥ m**: DEFECT (optimistically assume others might cooperate)
- **If n - 1 < m**: DEFECT (impossible without me, but I'll defect to signal I'm not an easy mark)

*Rationale*: Starting with defection reveals who the reliable cooperators are without costing me anything.

### Round 2
- **If round 1 had ≥ m cooperators**: DEFECT (free-ride on established cooperators)
- **If round 1 had exactly m-1 cooperators**: COOPERATE (I might be pivotal)
- **If round 1 had < m-1 cooperators**: DEFECT (hopeless situation)

### Final Round (round r)
- **Always DEFECT**: No future punishment possible, pure dominant strategy to defect.

### Second-to-Last Round
- **DEFECT if expected_others ≥ m**
- **Otherwise DEFECT anyway**: Opponents who think strategically will defect in round r, so cooperation norms are collapsing.

### When m > n/2 (High Threshold)
- Cooperation is more necessary but also more fragile
- Be slightly more willing to cooperate in middle rounds
- But still defect whenever expected_others ≥ m

### When m ≤ n/2 (Low Threshold)
- Free-riding is easier and more sustainable
- Lean heavily toward defection
- Only cooperate if cooperation has completely collapsed AND rounds_remaining > 3

---

## Adaptive Adjustments

### Detecting Punishment Patterns
If I defected last round AND cooperation dropped significantly this round:
- Other players may be retaliating
- Temporarily cooperate for 1-2 rounds to "rebuild trust"
- Then resume exploitation

### Detecting Other Free-Riders
If another player has high defection rate but threshold is still being met:
- They're competing for free-rider payoffs
- This is fine—continue defecting as long as threshold is met
- If threshold starts failing, I'll consider cooperating minimally

### Threshold Collapse Detection
If threshold has failed for 2+ consecutive rounds:
- Assess: Can exactly m players coordinate?
- If my cooperation would make exactly m: COOPERATE (to restart the gravy train)
- If not: DEFECT (save resources)

---

## Summary Decision Table

| Expected Others Cooperating | Rounds Remaining | Decision |
|---------------------------|------------------|----------|
| ≥ m                       | Any              | DEFECT   |
| = m - 1                   | > 2              | COOPERATE |
| = m - 1                   | ≤ 2              | DEFECT   |
| < m - 1                   | > 3, collapse detected | COOPERATE (rebuild) |
| < m - 1                   | Otherwise        | DEFECT   |

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever others provide the public good
2. **Minimizes wasted contributions**: Never cooperates when threshold is unreachable
3. **Exploits cooperators**: Reliable cooperators become predictable resources
4. **End-game defection**: Extracts maximum value when punishment is impossible
5. **Adaptive parasitism**: Contributes just enough to keep the cooperation "host" alive
'''

description_EXPLOITATIVE_91 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when others cooperate** and punishes being a "sucker" who cooperates when others don't. The optimal exploitative approach is to cooperate only when absolutely necessary to meet the threshold, while maximizing opportunities to defect when others will carry the burden.

## Strategy: "Threshold Stalker"

### Decision Framework

The strategy operates on a simple principle: **be the marginal cooperator, never the surplus one.**

### Round-by-Round Decision Rules

#### First Round
- **Defect.**
- Rationale: Gather information about opponent tendencies. If the threshold is met without you, you get the best possible outcome (1 + k). If it isn't met, you lose nothing compared to cooperating in a failed attempt.

#### Middle Rounds (rounds 2 through r-1)

Calculate the **cooperation rate** from observed history:
- `coop_rate[i]` = (times player i cooperated) / (rounds observed)
- `expected_cooperators` = Σ coop_rate[i] for all other players

**Decision logic:**

```
IF expected_cooperators >= m:
    DEFECT  # Free-ride on reliable cooperators
    
ELIF expected_cooperators >= m - 1 AND expected_cooperators < m:
    # You might be the pivotal player
    IF (rounds_remaining * k) > (rounds_remaining * 1):
        COOPERATE with probability = (m - expected_cooperators)
    ELSE:
        DEFECT
        
ELIF expected_cooperators < m - 1:
    DEFECT  # Threshold unlikely to be met regardless
```

**Reputation Exploitation Rule:**
- Track which players are "reliable cooperators" (coop_rate > 0.7)
- If `count(reliable_cooperators) >= m`: Always defect
- If you've been defecting and threshold keeps being met: Continue defecting

#### Last Round
- **Defect unconditionally.**
- Rationale: No future rounds to punish you; pure dominant strategy logic applies.

#### Second-to-Last Round
- **Defect with high probability (80%).**
- Rationale: Limited punishment opportunity remaining.

### Edge Case Handling

**When m is very close to n (e.g., m = n-1):**
- Cooperation becomes more necessary; increase cooperation probability in middle rounds
- Adjust: `IF m >= n - 1: cooperate_threshold = 0.6` (cooperate if expected_cooperators > m * 0.6)

**When k is very large (k > 2):**
- The collective reward becomes worth more; slightly increase willingness to be pivotal
- But never cooperate if expected_cooperators >= m (free-riding still dominates)

**When r is small (r ≤ 3):**
- Less time to learn; be more aggressive about defecting
- Round 1: Defect, Round 2: Defect unless disaster last round, Round 3 (last): Defect

**Punishment Detection:**
- If your defection is followed by a drop in overall cooperation (others defecting in retaliation):
  - Temporarily cooperate for 1-2 rounds to "reset" the cooperative environment
  - Then return to exploitation

### Summary Pseudocode

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT
    
    if round == r:  # last round
        return DEFECT
    
    if round == r - 1:  # second to last
        return DEFECT with 80% probability, else use middle-round logic
    
    expected_coop = estimate_cooperators(history)
    
    if expected_coop >= m:
        return DEFECT  # free-ride
    
    if expected_coop >= m - 1.5:
        # Might be pivotal - cooperate just enough
        pivot_prob = (m - expected_coop) / 1.5
        return COOPERATE with probability pivot_prob
    
    return DEFECT  # threshold won't be met anyway
```

### Why This Exploits Common Strategies

1. **Against unconditional cooperators:** Pure free-riding; maximum exploitation
2. **Against tit-for-tat variants:** Defect early, observe punishment, minimize cooperation to just maintain threshold
3. **Against threshold-based cooperators:** Let them carry the burden while you defect
4. **Against random players:** Extract value when threshold is met, lose nothing when it isn't
5. **Against other exploiters:** Mutual defection is the equilibrium; no worse than anyone else
'''

description_EXPLOITATIVE_92 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach recognizes a fundamental asymmetry: if exactly m players are willing to cooperate, I can defect and free-ride on their contributions, receiving the maximum payoff of (1 + k). My strategy aims to:

1. **Estimate** how many others will cooperate based on observed history
2. **Defect** whenever I predict at least m others will cooperate without me
3. **Cooperate only when necessary** to prevent collective failure that would hurt me

## Decision Rules

### Round 1 (Cold Start)

**Defect.**

Rationale: With no history, I cannot predict others' behavior. Defecting preserves my endowment. If others cooperate and meet threshold, I gain (1 + k). If they don't, I still keep my 1 rather than losing it for nothing. This is strictly dominant in the first round of an unknown population.

### Rounds 2 through (r-1) (Main Phase)

Calculate the **cooperation rate** from the previous round:
```
prev_cooperators = count of players who played C last round
```

**Decision Logic:**

```
IF prev_cooperators >= m + 1:
    DEFECT  # Enough cooperators exist; I can free-ride
    
ELIF prev_cooperators == m:
    IF I cooperated last round:
        DEFECT  # Test if others will maintain threshold without me
    ELSE:
        DEFECT  # Threshold was met without me; continue exploiting
        
ELIF prev_cooperators == m - 1:
    IF I defected last round:
        COOPERATE  # I might be the swing vote; avoid collective loss
    ELSE:
        DEFECT  # Others need to step up; test their commitment
        
ELIF prev_cooperators < m - 1:
    DEFECT  # Threshold won't be met even if I cooperate; save my endowment
```

### Last Round (Round r)

**Defect unconditionally.**

Rationale: No future rounds exist to punish defection. This is the standard backward induction result. Any sophisticated opponent will also defect, and naive cooperators are simply exploitable.

## Adaptive Refinements

### Trend Detection

Track cooperation across multiple rounds:
```
IF cooperation has been declining for 2+ consecutive rounds:
    Be MORE willing to defect (threshold is likely collapsing anyway)
    
IF cooperation has been stable at exactly m for 2+ rounds:
    Continue defecting (a stable coalition of cooperators exists to exploit)
```

### Endgame Acceleration

As rounds remaining decrease:
```
IF rounds_remaining <= 3:
    Lower cooperation threshold - lean toward defection
    Others will start defecting; don't be the last cooperator standing
```

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    
    # Last round: always defect
    if round == r:
        return DEFECT
    
    # First round: always defect
    if round == 1:
        return DEFECT
    
    # Get previous round data
    prev_coop_count = count_cooperators(history[round-1])
    my_prev_action = history[round-1][my_id]
    rounds_left = r - round
    
    # Endgame: bias toward defection
    if rounds_left <= 2:
        return DEFECT
    
    # Main logic
    if prev_coop_count >= m + 1:
        return DEFECT  # Safe to free-ride
        
    if prev_coop_count == m:
        return DEFECT  # Threshold met; exploit it
        
    if prev_coop_count == m - 1:
        if my_prev_action == DEFECT:
            return COOPERATE  # I might be pivotal
        else:
            return DEFECT  # Test if others step up
            
    if prev_coop_count < m - 1:
        return DEFECT  # Lost cause; preserve endowment
```

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever threshold appears sustainable without my contribution
2. **Minimizes costly cooperation**: Only cooperates when I estimate I'm genuinely pivotal
3. **Exploits cooperators**: Treats consistent cooperators as a resource to parasitize
4. **Punishes no one**: Doesn't waste resources on punishment; pure self-interest
5. **Endgame extraction**: Aggressively defects as game concludes

This strategy extracts maximum value from cooperative populations while minimizing losses against defectors.
'''

description_EXPLOITATIVE_93 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding** when others cooperate. The optimal exploitative approach is to contribute only when absolutely necessary to meet the threshold, while defecting whenever others can be relied upon to carry the burden. I will track opponent behavior to predict cooperation levels and position myself to maximize the payoff differential between cooperators and defectors.

## Strategy: "Threshold Parasite"

### Decision Framework

**Primary Rule:** Defect by default. Only cooperate when cooperation is both necessary (threshold at risk) and unavoidable (cannot rely on others to fill the gap).

### Detailed Decision Rules

#### Round 1 (Cold Start)
- **If m ≤ n/2:** Defect. Assume optimistic players and threshold-concerned players will provide enough cooperators.
- **If m > n/2:** Cooperate only if m > n - 1 (i.e., nearly everyone must cooperate). Otherwise defect and observe.

The rationale: In early rounds, cooperative-minded players reveal themselves. Let them carry the initial burden.

#### Middle Rounds (2 to r-1)

Calculate from history:
- `avg_cooperators` = average number of cooperators in previous rounds
- `cooperation_trend` = (cooperators in last round) - (cooperators in round before that)
- `threshold_margin` = avg_cooperators - m

**Decision Logic:**
```
IF threshold_margin >= 1.5:
    DEFECT (others are reliably covering the threshold)
    
ELSE IF threshold_margin >= 0.5:
    DEFECT with probability (threshold_margin / 1.5)
    COOPERATE otherwise
    
ELSE IF threshold_margin >= 0:
    # Threshold barely met - risky territory
    IF cooperation_trend < 0:
        COOPERATE (cooperation declining, threshold at risk)
    ELSE:
        DEFECT (hope others maintain)
        
ELSE (threshold_margin < 0):
    # Threshold not being met
    IF avg_cooperators >= m - 1:
        COOPERATE (one more cooperator could tip it)
    ELSE IF avg_cooperators >= m - 2 AND r - current_round >= 3:
        COOPERATE (invest in establishing threshold-meeting)
    ELSE:
        DEFECT (lost cause - save resources)
```

#### Last Round (Round r)
- **Pure exploitation round** - no future consequences
- Calculate expected cooperators based on historical average
- **If expected cooperators ≥ m:** DEFECT (free ride on final payout)
- **If expected cooperators = m - 1:** COOPERATE (be the pivotal voter)
- **If expected cooperators < m - 1:** DEFECT (threshold won't be met anyway)

### Opponent Behavior Tracking

Classify each opponent:
- **Reliable Cooperator:** Cooperated ≥ 80% of rounds → Exploit aggressively
- **Reliable Defector:** Defected ≥ 80% of rounds → Ignore in threshold calculations
- **Conditional Player:** Mixed behavior → Watch carefully

**Adjustment:** Weight recent rounds more heavily (exponential decay with factor 0.7 per round back).

### Edge Cases

1. **n = m (everyone must cooperate):** Cooperate every round. Defection guarantees zero bonus.

2. **m = 2 (low threshold):** Almost always defect. Even pessimistically, someone else will likely cooperate.

3. **k is very large (k > n):** Be slightly more willing to cooperate to secure threshold, but still prioritize free-riding when safe.

4. **Very few rounds (r ≤ 3):** Less data to exploit. Default to more cooperation in round 1-2, exploit hard in final round.

5. **After a round where threshold failed:** 
   - If I defected and we were 1 short: Cooperate next round
   - If we were 2+ short: Continue defecting unless trend reverses

### Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT if m <= n/2 else (COOPERATE if m > n-1 else DEFECT)
    
    avg_coop = average(cooperators_per_round in history)
    trend = history[-1].cooperators - history[-2].cooperators if round > 2 else 0
    margin = avg_coop - m
    
    if round == r:  # Last round
        expected = weighted_average(history, decay=0.7)
        if expected >= m: return DEFECT
        if expected >= m - 1: return COOPERATE
        return DEFECT
    
    # Middle rounds
    if margin >= 1.5: return DEFECT
    if margin >= 0.5: return DEFECT with prob(margin/1.5)
    if margin >= 0: return COOPERATE if trend < 0 else DEFECT
    if avg_coop >= m - 1: return COOPERATE
    if avg_coop >= m - 2 and r - round >= 3: return COOPERATE
    return DEFECT
```

This strategy maximizes individual payoff by contributing only when pivotal while extracting maximum value from others' cooperation.
'''

description_EXPLOITATIVE_94 = '''
# Exploitative Strategy: "Threshold Shark"

## Core Philosophy

This strategy exploits the fundamental asymmetry in the Collective Risk Dilemma: **defectors gain the most when exactly m players cooperate**. My goal is to be a defector when the threshold is met, while manipulating others into being the cooperators who meet it.

## Strategy Overview

I aim to:
1. **Free-ride** whenever I predict the threshold will be met without me
2. **Reluctantly cooperate** only when my contribution is pivotal and the reward justifies it
3. **Punish** populations that don't cooperate enough to make cooperation worthwhile
4. **Exploit predictable cooperators** mercilessly

---

## Decision Rules

### Key Variables Tracked
- `coop_history[player][round]`: Each player's action history
- `coop_rate[player]`: Running cooperation rate per player
- `total_coop_last_round`: Number of cooperators in previous round
- `rounds_remaining`: r - current_round

### Round-by-Round Logic

#### **First Round**
```
IF m/n ≤ 0.4:
    DEFECT  (threshold is low, others likely to meet it)
ELSE IF m/n ≥ 0.7:
    COOPERATE  (need broad cooperation, signal willingness)
ELSE:
    DEFECT  (test the waters, see who the reliable cooperators are)
```

**Rationale**: Start by defecting in most cases to identify who the "suckers" are—players who cooperate unconditionally.

#### **Middle Rounds (rounds 2 to r-1)**

```
# Count predicted cooperators (excluding myself)
predicted_coop = count players where coop_rate[player] > 0.5

# Identify reliable cooperators (>70% cooperation rate)
reliable_coops = count players where coop_rate[player] > 0.7

IF reliable_coops >= m:
    DEFECT  # Free-ride on the reliable cooperators
    
ELSE IF predicted_coop >= m:
    DEFECT  # Likely enough cooperators without me
    
ELSE IF predicted_coop == m - 1:
    # I'm pivotal - calculate expected value
    IF k > 1:
        COOPERATE  # My cooperation turns 0 reward into k reward
    ELSE:
        DEFECT
        
ELSE IF predicted_coop < m - 2:
    DEFECT  # Threshold won't be met even if I cooperate
    
ELSE:  # predicted_coop == m - 2
    # Borderline case - cooperate only if others show recent uptick
    IF avg_coop_rate_last_2_rounds > 0.5:
        COOPERATE
    ELSE:
        DEFECT
```

#### **Last Round**
```
# Pure exploitation - no future consequences
predicted_coop = count players where coop_rate[player] > 0.6

IF predicted_coop >= m:
    DEFECT  # Guaranteed free-ride
ELSE IF predicted_coop == m - 1 AND k > 1.5:
    COOPERATE  # Worth being pivotal for high k
ELSE:
    DEFECT  # Default to keeping endowment
```

---

## Adaptive Mechanisms

### **Detecting Exploitable Patterns**
```
FOR each player p:
    IF last_3_rounds[p] == [C, C, C]:
        mark as "sucker" - assume they'll cooperate
    IF player mirrors my actions with 1-round lag:
        mark as "conditional" - can be manipulated
```

### **Adjusting Predictions Based on Population**
```
IF sum(coop_rate) / (n-1) > 0.6:
    # Cooperative population - exploit aggressively
    bias predictions upward, defect more
    
IF sum(coop_rate) / (n-1) < 0.3:
    # Uncooperative population - threshold rarely met
    defect always (no point cooperating alone)
```

### **Threshold Proximity Exploitation**
```
IF total_coop_last_round == m:
    # Threshold was exactly met - very exploitable
    DEFECT (someone will likely cooperate again)
    
IF total_coop_last_round == m - 1 AND I cooperated:
    # I was pivotal and we failed - others are unreliable
    DEFECT for next 2 rounds as punishment
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2, m = 2 | Cooperate only if opponent's coop_rate > 0.7 | Need both; only cooperate with reliable partner |
| m = n - 1 | Defect always | Someone must defect; let it be me |
| k > 3 (very high reward) | Lower cooperation threshold to m-2 predicted | High stakes justify more cooperation |
| k < 1.2 (low reward) | Defect unless predicted_coop == m-1 exactly | Not worth risking contribution |
| All opponents defected last round | Defect | Population collapse; save yourself |

---

## Summary Pseudocode

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT if m/n < 0.7 else COOPERATE
    
    if round == r:  # Last round
        return DEFECT if predict_coops(history) >= m else (COOPERATE if k > 1.5 and predict_coops(history) == m-1 else DEFECT)
    
    reliable = count_reliable_cooperators(history)
    predicted = predict_coops(history)
    
    if reliable >= m or predicted >= m:
        return DEFECT
    elif predicted == m - 1 and k > 1:
        return COOPERATE
    elif predicted <= m - 2:
        return DEFECT
    else:
        return COOPERATE if recent_trend_up(history) else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever threshold is likely met without contribution
2. **Identifies and exploits suckers**: Tracks unconditional cooperators and counts on them
3. **Minimal contribution**: Only cooperates when genuinely pivotal
4. **No reciprocity loyalty**: Unlike TFT, doesn't cooperate out of "fairness"
5. **End-game ruthlessness**: Pure defection calculus in final round
6. **Punishes failures**: Withdraws cooperation when others prove unreliable
'''

description_EXPLOITATIVE_95 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when others cooperate enough**. The optimal exploitative approach is to:
1. Avoid contributing when others will likely meet the threshold without you
2. Contribute only when your contribution is pivotal (exactly m-1 others cooperating)
3. Defect ruthlessly in the final round since there's no future punishment
4. Learn opponent behavior patterns to predict when you can safely defect

## Strategy: "Threshold Parasite"

### Decision Framework

**Define key variables:**
- `cooperators_last_round`: count of players who played C in previous round
- `my_pivotality`: estimate of whether I'm needed to reach threshold m
- `rounds_remaining`: r - current_round
- `cooperation_rate`: historical average cooperation rate of opponents

---

### Round-by-Round Rules

#### First Round:
```
IF m <= n/2:
    DEFECT  # Threshold is low enough others might meet it
ELSE:
    COOPERATE  # Need to establish some cooperation baseline
```

**Rationale:** In early rounds with low thresholds, test if others will cooperate. With high thresholds, we need some initial cooperation or the group fails catastrophically.

#### Last Round:
```
ALWAYS DEFECT
```

**Rationale:** No future rounds means no punishment possible. Pure free-riding opportunity.

#### Second-to-Last Round:
```
IF cooperation_rate > m/n + 0.15:
    DEFECT  # Others are reliable enough, exploit them
ELSE:
    Follow middle-round logic
```

#### Middle Rounds (rounds 2 through r-2):

```
# Calculate opponent cooperation from last round (excluding self)
opponent_cooperators = cooperators_last_round - my_last_action

# Estimate: Will enough others cooperate without me?
expected_cooperators = opponent_cooperators  # Use last round as predictor

IF expected_cooperators >= m:
    DEFECT  # Threshold met without me - free ride!
    
ELSE IF expected_cooperators == m - 1:
    # I'm pivotal - but randomize to avoid being exploited
    IF random() < 0.7:
        COOPERATE
    ELSE:
        DEFECT  # Occasionally test if someone else steps up
        
ELSE IF expected_cooperators < m - 1:
    # Not enough cooperators - need to encourage cooperation
    # But only if there's hope
    
    IF cooperation_rate < 0.2 AND rounds_remaining < r/2:
        DEFECT  # Group is hopeless, save yourself
    ELSE:
        COOPERATE  # Try to build cooperation
```

---

### Adaptive Exploitation Rules

**Track opponent reliability:**
```
reliable_cooperators = count of players who cooperated in >70% of rounds
```

**Adjust behavior based on group composition:**
```
IF reliable_cooperators >= m:
    # Jackpot! Exploit the reliable cooperators
    DEFECT (override other rules except pivotality check)
    
IF reliable_cooperators == m - 1:
    # Almost enough reliable cooperators
    # Cooperate just enough to keep them cooperating, then defect
    IF rounds_remaining > 2:
        COOPERATE with 50% probability
    ELSE:
        DEFECT
```

---

### Edge Cases

1. **n = m (everyone must cooperate):** Cooperate until last round, then defect and accept failure
2. **m = 2 (very low threshold):** Defect heavily, only cooperate if literally no one else did
3. **k is very large:** Slightly increase cooperation probability (threshold success matters more)
4. **All previous rounds failed threshold:** 
   - If rounds_remaining > r/3: Attempt cooperation reset
   - Otherwise: Permanent defection (group has failed)

---

### Summary Pseudocode

```python
def decide(round, history, n, m, r, k):
    if round == r:
        return DEFECT  # Last round exploitation
    
    if round == 1:
        return DEFECT if m <= n/2 else COOPERATE
    
    coop_rate = calculate_opponent_cooperation_rate(history)
    last_round_coops = count_cooperators(history[-1]) - my_action(history[-1])
    reliable = count_reliable_cooperators(history)
    
    # Free-riding opportunity
    if reliable >= m or last_round_coops >= m:
        return DEFECT
    
    # Pivotal situation
    if last_round_coops == m - 1:
        return COOPERATE if random() < 0.7 else DEFECT
    
    # Below threshold - conditional cooperation
    if coop_rate < 0.2 and round > r/2:
        return DEFECT  # Abandon failing group
    
    return COOPERATE  # Build cooperation for future exploitation
```

This strategy maximizes individual payoff by identifying and exploiting cooperative players while contributing only when strategically necessary.
'''

description_EXPLOITATIVE_96 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding** when others cooperate. The optimal exploitative approach is to defect whenever possible while ensuring the threshold is met just often enough to collect the bonus. I want to:

1. **Let others bear the cooperation cost** - be among the defectors when threshold is met
2. **Cooperate only when absolutely necessary** - when my cooperation is pivotal
3. **Manipulate opponents into cooperating more** - by being unpredictable and occasionally "punishing"

## Strategy: "Reluctant Pivotal Defector"

### Decision Framework

**Step 1: Estimate opponent cooperation rates**

Track each opponent's cooperation frequency over all observed rounds. Calculate:
- `coop_rate[j]` = (times player j cooperated) / (rounds played)
- `expected_cooperators` = sum of all opponent coop_rates

**Step 2: Determine if I'm likely pivotal**

Calculate probability that exactly `m-1` others will cooperate (making me pivotal). If `expected_cooperators` is close to `m-1`, I'm more likely pivotal.

**Step 3: Apply decision rules**

### Detailed Decision Rules

```
FIRST ROUND:
    If m <= n/2: DEFECT (optimistic - others likely handle it)
    If m > n/2: COOPERATE with probability (m-1)/(n-1)
    
LAST ROUND:
    Calculate expected_cooperators from opponent history
    If expected_cooperators >= m: DEFECT (free-ride)
    If expected_cooperators < m-1: DEFECT (lost cause)
    If expected_cooperators ≈ m-1 (within 0.5): COOPERATE (pivotal)

MIDDLE ROUNDS:
    1. Calculate expected_cooperators
    
    2. If expected_cooperators >= m + 0.5:
         DEFECT (threshold likely met without me)
    
    3. If expected_cooperators < m - 1.5:
         DEFECT (threshold unlikely even with me)
    
    4. If expected_cooperators in [m-1.5, m+0.5]:
         // I'm potentially pivotal - but exploit when possible
         
         Look at last round's outcome:
         - If threshold was met AND I defected: DEFECT again (it's working)
         - If threshold was met AND I cooperated: DEFECT (test if I'm needed)
         - If threshold NOT met AND I defected: COOPERATE (need to contribute)
         - If threshold NOT met AND I cooperated: 
             If expected_cooperators < m-1: DEFECT (others aren't helping)
             Else: COOPERATE (stay the course)
    
    5. Exploitation adjustment:
         If in final 20% of rounds AND threshold was met last round:
             Increase defection probability by 20% (cash out)
```

### Edge Case Handling

**Early game (rounds 1-3):**
- Use uniform prior: assume each opponent cooperates with probability m/n
- Weight recent observations heavily (learning phase)

**When all opponents always defect:**
- Defect (no point cooperating alone unless m=1)

**When all opponents always cooperate:**
- Always defect (maximum exploitation - collect k+1 every round)

**When opponent behavior is highly variable:**
- Default toward defection; cooperate only when last round failed and I defected

**Exactly m-1 expected cooperators (most critical case):**
- Cooperate 60% of the time (slight bias toward ensuring threshold, but still exploit 40%)

### Reputation Manipulation

**Occasional "punishment" defection:**
- Even when pivotal, defect with 15% probability in middle rounds
- This conditions opponents to not rely on me, potentially increasing their cooperation rates

**Late-game exploitation ramp:**
- In final 25% of rounds, add +0.3 to defection probability
- Others can't retaliate meaningfully with limited rounds remaining

## Summary Table

| Situation | Action |
|-----------|--------|
| Expected cooperators ≥ m + 0.5 | DEFECT |
| Expected cooperators < m - 1.5 | DEFECT |
| Pivotal zone, threshold met last round | DEFECT (test limits) |
| Pivotal zone, threshold failed, I defected | COOPERATE |
| Last round, threshold likely met | DEFECT |
| Final 25% of game | Bias toward DEFECT |

This strategy maximizes individual payoff by defaulting to defection and only cooperating when failure to do so would cost the threshold bonus.
'''

description_EXPLOITATIVE_97 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that this game has a critical asymmetry: **defectors get the bonus k PLUS their endowment (payoff = 1 + k = 3) while cooperators only get the bonus (payoff = k = 2)**. The optimal position is to defect while exactly m others cooperate. My strategy aims to free-ride on others' cooperation while contributing just enough to prevent total collapse when necessary.

## Decision Rules

### Information Tracking

Each round, track:
- `coop_count[t]`: number of cooperators in round t
- `player_history[i][t]`: action of player i in round t
- `rounds_remaining`: r - current_round

### Classification of Other Players

After observing history, classify each other player:
- **Reliable Cooperator**: Cooperated in ≥70% of rounds AND cooperated in most recent 2 rounds
- **Reliable Defector**: Defected in ≥70% of rounds
- **Conditional/Reactive**: Everyone else

Let `reliable_coops` = count of Reliable Cooperators among other n-1 players

### Core Decision Logic

```
function decide(round, history, params):
    
    # FIRST ROUND: Defect to gather information
    if round == 1:
        return DEFECT
    
    # LAST ROUND: Always defect (no future consequences)
    if round == r:
        return DEFECT
    
    # NEAR-END EXPLOITATION (last 20% of rounds)
    if rounds_remaining <= r * 0.2:
        return DEFECT
    
    # Calculate expected cooperators WITHOUT me
    expected_others_coop = reliable_coops
    
    # CASE 1: Enough reliable cooperators exist (free-ride)
    if expected_others_coop >= m:
        return DEFECT
    
    # CASE 2: Exactly m-1 reliable cooperators (I'm pivotal)
    if expected_others_coop == m - 1:
        # Probabilistic cooperation to avoid being exploited myself
        # Cooperate with probability that decreases over time
        prob = 0.7 * (rounds_remaining / r)
        return COOPERATE with probability prob, else DEFECT
    
    # CASE 3: Far below threshold - check if rescue is plausible
    shortfall = m - expected_others_coop
    uncertain_players = n - 1 - reliable_coops - reliable_defectors
    
    if shortfall > uncertain_players + 1:
        # Impossible to reach threshold even if I cooperate
        return DEFECT
    
    # CASE 4: Threshold might be reachable
    # Only cooperate if recent history suggests others are trying
    recent_coop_rate = average cooperation rate in last 3 rounds
    
    if recent_coop_rate >= (m-1)/n AND shortfall <= 2:
        # Others seem to be trying, contribute minimally
        return COOPERATE with probability 0.5
    else:
        return DEFECT
```

### Adaptive Exploitation Mechanism

**Detecting Exploitable Patterns:**
- If certain players ALWAYS cooperate regardless of outcomes → classify as "suckers" and always defect
- If the group consistently hits exactly m cooperators → defect to free-ride on the coordination
- If cooperation is collapsing (declining trend) → defect early to maximize private gains

**Punishment Avoidance:**
- If I detect that others might be tracking defectors (cooperation drops after I defect) → occasionally cooperate to reset reputation
- Specifically: if my defection was followed by group cooperation dropping by 2+ next round, cooperate once as a "peace offering"

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | DEFECT | Information gathering, no reputation yet |
| Round r (final) | DEFECT | No future consequences |
| m = n-1 or m = n | COOPERATE more often | High threshold means my contribution matters more |
| Previous round had exactly m coops including me | DEFECT | Test if others maintain threshold without me |
| Consistent threshold failure (3+ rounds) | DEFECT | Group coordination has failed, salvage private payoff |
| k is very large (k > 3) | Slightly more cooperative | Higher reward justifies more risk |

## Summary

**Be a parasite, not a destroyer.** The strategy aims to:
1. Let others bear the cooperation burden
2. Contribute only when absolutely pivotal AND early enough that others might adjust
3. Ruthlessly exploit the endgame where reputation doesn't matter
4. Never be the "sucker" who cooperates when the threshold is unreachable
'''

description_EXPLOITATIVE_98 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game has a **free-rider problem**: when exactly m players cooperate, defectors get the highest payoff (1 + k) while cooperators get only k. My strategy aims to be among the defectors when the threshold is met, while occasionally cooperating just enough to prevent collective collapse.

## Strategy Overview: "Threshold Parasite"

I will attempt to free-ride on others' cooperation while maintaining just enough cooperative behavior to keep the collective good flowing. The strategy adapts based on observed cooperation levels.

---

## Decision Rules

### Round 1: Defect
- **Action: D**
- Rationale: Gather information about baseline cooperation rates. No history to exploit yet, and defecting is the dominant individual action.

### Middle Rounds (2 to r-1):

Calculate from previous round:
- `cooperators_last` = number of players who played C in the previous round
- `cooperation_rate` = cooperators_last / n

**Decision Logic:**

```
IF cooperators_last >= m:
    # Threshold was met - others are providing the public good
    # Continue free-riding with high probability
    ACTION = D
    
ELSE IF cooperators_last == m - 1:
    # One short of threshold - I might be pivotal
    # Cooperate probabilistically based on how critical I am
    IF random() < 1/m:
        ACTION = C
    ELSE:
        ACTION = D
        
ELSE IF cooperators_last < m - 1:
    # Far below threshold - collective action is failing
    # Need to occasionally seed cooperation to restart the system
    IF cooperation_rate < 0.2 AND random() < 0.3:
        ACTION = C  # Attempt to catalyze cooperation
    ELSE:
        ACTION = D  # Don't throw good money after bad
```

### Last Round (round r): Defect
- **Action: D**
- Rationale: No future rounds to maintain reputation. Pure dominant strategy to defect.

### Penultimate Round (round r-1): Lean toward Defect
- Apply normal middle-round logic but increase defection probability by 20%
- Others may also be preparing to defect, reducing threshold likelihood

---

## Adaptive Refinements

### Tracking Consistent Cooperators
Maintain a count of players who have cooperated in >70% of rounds. If this count ≥ m:
- **Exploit heavily**: These "suckers" will likely maintain the threshold without me
- Override to D even in borderline cases

### Detecting Mutual Defection Spirals
If the last 3 consecutive rounds had cooperators_last < m:
- The system is collapsing
- Cooperate once to test if others will respond (but only if rounds_remaining > 3)

### Parameter-Based Adjustments

```
IF m/n > 0.6:
    # High threshold requirement - cooperation is fragile
    # Be slightly more willing to cooperate to keep system alive
    Increase cooperation probabilities by 15%
    
IF k > 2:
    # High reward makes threshold very valuable
    # Worth occasional cooperation to ensure it's met
    Increase cooperation probabilities by 10%
    
IF k < 1.5:
    # Low reward - less to gain from cooperation
    # Free-ride more aggressively
    Decrease cooperation probabilities by 20%
```

---

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == 1 or round == r:
        return D
    
    cooperators_last = count_cooperators(history, round - 1)
    consistent_cooperators = count_players_with_coop_rate_above(history, 0.7)
    
    # If reliable cooperators exist to meet threshold, free-ride
    if consistent_cooperators >= m:
        return D
    
    # Adjust base probabilities by parameters
    coop_boost = 0.15 * (m/n > 0.6) + 0.10 * (k > 2) - 0.20 * (k < 1.5)
    
    if cooperators_last >= m:
        return D  # Exploit successful cooperation
    
    if cooperators_last == m - 1:
        if random() < (1/m + coop_boost):
            return C
        return D
    
    if cooperators_last < m - 1:
        if random() < (0.3 + coop_boost) and rounds_remaining > 3:
            return C  # Seed cooperation
        return D
    
    return D  # Default
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Only cooperates when absolutely necessary to maintain the public good
2. **Exploits cooperators**: Identifies and leeches off consistent cooperators
3. **Information-gathering first round**: Never wastes resources before understanding the population
4. **Endgame defection**: Extracts maximum value when reputation no longer matters
5. **Probabilistic pivotal contribution**: Only contributes when likely to be the deciding vote for threshold
'''

description_EXPLOITATIVE_99 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game has a **free-rider's paradise** structure: when exactly m players cooperate, defectors get the maximum payoff (1 + k) while cooperators get less (k). My strategy aims to be among the defectors when the threshold is met, while ensuring the threshold *is* met often enough to collect the bonus.

The exploitative approach: **Let others bear the cost of cooperation while I reap the rewards.**

## Strategy: "Threshold Parasite"

### Key Observations

1. **Defection dominates when threshold is met**: If ≥m others cooperate, I should defect (payoff 1+k > k)
2. **Cooperation only matters at the margin**: I should only cooperate if my cooperation is *pivotal* - i.e., exactly m-1 others are cooperating
3. **Information asymmetry over time**: Early rounds reveal opponent types; late rounds allow exploitation

### Decision Rules

**Round 1 (Cold Start):**
- **Defect.** 
- Rationale: No information yet. Let others reveal their cooperative tendencies. If enough cooperate, I get the free bonus. If not, I still keep my endowment.

**Rounds 2 through r-1 (Learning & Exploitation Phase):**

Calculate from history:
- `coop_rate[i]` = proportion of rounds player i has cooperated
- `expected_cooperators` = Σ(coop_rate[i]) for all other players
- `reliable_cooperators` = count of players with coop_rate ≥ 0.7

```
IF expected_cooperators >= m + 0.5:
    DEFECT  # Others will likely cover threshold; free-ride
    
ELIF expected_cooperators >= m - 1 AND expected_cooperators < m + 0.5:
    # Marginal situation - be strategic
    IF reliable_cooperators >= m:
        DEFECT  # Reliable players will cover it
    ELIF reliable_cooperators == m - 1:
        # I might be pivotal, but check if I'm being exploited
        IF my_cooperation_rate > average_cooperation_rate + 0.2:
            DEFECT  # I've been a sucker; pull back
        ELSE:
            COOPERATE with probability (m - expected_cooperators)
    ELSE:
        DEFECT  # Not enough reliable cooperators; threshold unlikely anyway

ELIF expected_cooperators < m - 1:
    DEFECT  # Threshold won't be met regardless; save my endowment
```

**Last Round (Round r) - Endgame:**
- **Always Defect.**
- Rationale: No future consequences. Pure dominant strategy logic applies. If others cooperate, I free-ride. If they don't, I keep my endowment.

### Adaptive Adjustments

**Exploitation Detection:**
- Track `rounds_threshold_met` and `my_cooperations_when_met`
- If threshold is frequently met AND I'm cooperating more than (m/n) fair share: **increase defection probability by 20%**

**Sucker Avoidance:**
- If I've cooperated in 3+ consecutive rounds while at least one other player has defected in all those rounds: **Defect for next 2 rounds** regardless of other calculations

**Threshold Insurance (when k is large):**
- If k > 2 and we're in rounds r-3 to r-1 and threshold has been met <50% of the time:
  - Cooperate with probability min(0.3, (m-expected_cooperators)/m)
  - This hedges against total collapse while remaining exploitative

### Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT  # Endgame defection
    
    stats = calculate_statistics(history)
    
    if stats.expected_cooperators >= m + 0.5:
        return DEFECT  # Free-ride
    
    if stats.expected_cooperators < m - 1:
        return DEFECT  # Hopeless
    
    if being_exploited(stats):
        return DEFECT  # Sucker avoidance
    
    if stats.reliable_cooperators >= m:
        return DEFECT  # Others got this
    
    # Marginal case: probabilistic cooperation
    pivot_probability = max(0, m - stats.expected_cooperators) / m
    pivot_probability *= 0.7  # Stay exploitative
    
    return COOPERATE with probability pivot_probability, else DEFECT
```

## Why This Strategy is Exploitative

1. **Defaults to defection** - cooperation is the exception, not the rule
2. **Free-rides whenever possible** - if others will meet threshold, take the bonus without paying
3. **Never cooperates in final round** - extracts maximum value at endgame
4. **Detects and punishes being exploited** - won't be a perpetual sucker
5. **Only cooperates when pivotal AND not being taken advantage of**
'''

description_EXPLOITATIVE_100 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride whenever possible** while ensuring the threshold is met often enough to collect rewards. The key insight is that if exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get only k. My goal is to be among the defectors when the threshold is barely met.

## Strategy Overview

I will estimate how many other players are likely to cooperate each round, then cooperate only when my contribution is critical to reaching the threshold—and defect whenever I predict others will "carry" me.

---

## Decision Rules

### Information Tracked
- `coop_history[i][t]`: Whether player i cooperated in round t
- `coop_rate[i]`: Rolling cooperation rate for each opponent
- `total_coops[t]`: Number of cooperators (excluding me) in round t

### Cooperation Probability Estimation

For each round, estimate the expected number of other cooperators:
```
expected_others_cooperating = sum(coop_rate[i] for all opponents)
```

### Core Decision Logic

**Cooperate if and only if:**
1. My cooperation is likely *necessary* to reach threshold, OR
2. The threshold is unlikely to be met without me and k is large enough to justify the cost

**Specifically:**
```
predicted_others = expected_others_cooperating

if predicted_others >= m:
    # Others will likely hit threshold without me → DEFECT (free-ride)
    action = DEFECT
    
elif predicted_others >= m - 1 and predicted_others < m:
    # I'm likely the pivotal player → COOPERATE
    action = COOPERATE
    
elif predicted_others < m - 1:
    # Threshold unlikely even with me → DEFECT (save my contribution)
    action = DEFECT
```

### Probabilistic Refinement

Since predictions are uncertain, I use a **soft threshold** approach:

```
prob_threshold_met_without_me = P(others_cooperating >= m)
prob_threshold_met_with_me = P(others_cooperating >= m - 1)

# Expected value of defecting
EV_defect = 1 + k * prob_threshold_met_without_me

# Expected value of cooperating  
EV_cooperate = 0 + k * prob_threshold_met_with_me

if EV_cooperate > EV_defect:
    action = COOPERATE
else:
    action = DEFECT
```

---

## Edge Case Handling

### First Round (No History)
- Assume opponents cooperate with probability `m/n` (the "fair share" baseline)
- This gives `expected_others = (n-1) * m/n`
- If `(n-1) * m/n < m`, I cooperate; otherwise I defect
- **In most parameterizations: DEFECT round 1** (test if others will carry)

### Last Round
- **Always DEFECT** — no future consequences, pure free-riding opportunity
- Other rational players may also defect, but my dominant strategy is still defect

### Rounds 2 to r-1
- Update cooperation rates using exponential moving average (recent rounds weighted more):
  ```
  coop_rate[i] = 0.7 * coop_rate[i] + 0.3 * (1 if cooperated_last_round else 0)
  ```

### When Threshold Was Never Met
- If threshold hasn't been met in recent rounds, slightly increase cooperation probability to "test" if coordination is possible
- But cap this at cooperating only if I'd be pivotal

### Detecting Conditional Cooperators
- If I notice opponents who cooperate when I cooperate and defect when I defect, I'll cooperate *just enough* to keep them cooperating while I occasionally defect

---

## Exploitation Mechanisms

1. **Free-Riding on Unconditional Cooperators**: If any opponents always cooperate, I factor them into my "guaranteed cooperators" count and defect more freely.

2. **Punishing Over-Cooperation**: If others consistently over-contribute (more than m cooperate), I defect to maximize my payoff since the threshold is met anyway.

3. **Last-Round Exploitation**: Guaranteed defection extracts maximum value when reputation no longer matters.

4. **Pivotal Player Positioning**: I only pay the cost of cooperation when I'm the deciding vote—never when my contribution is redundant.

---

## Summary Decision Tree

```
Round 1: DEFECT (probe opponent behavior)
Last Round: DEFECT (no retaliation possible)
Otherwise:
    Calculate expected cooperators among opponents
    If expected >= m: DEFECT
    If expected in [m-1.5, m): COOPERATE (I'm pivotal)
    If expected < m-1.5: DEFECT (hopeless)
```

This strategy maximizes personal payoff by contributing only when necessary and free-riding whenever the group will succeed without me.
'''

description_EXPLOITATIVE_101 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that the best outcome for me is when **exactly m players cooperate and I'm not one of them** - I get both my endowment (1) AND the collective reward (k). My strategy aims to free-ride on others' cooperation while ensuring the threshold is met often enough to harvest rewards.

## Strategy: "Threshold Exploiter with Reputation Tracking"

### Key Variables to Track

- `cooperation_rates[i]`: Historical cooperation rate for each player i
- `total_cooperators_history`: List of how many cooperated each round
- `rounds_remaining`: r - current_round
- `my_cooperation_count`: How many times I've cooperated

### Decision Rules

#### Round 1: Defect
- **Action: D**
- Rationale: Gather information about others' tendencies. Let others reveal themselves as cooperators first.

#### Middle Rounds (2 to r-1):

**Step 1: Estimate Expected Cooperators**
- Calculate `expected_cooperators` = sum of all other players' cooperation rates
- This estimates how many others will cooperate this round (excluding me)

**Step 2: Make Exploitative Decision**

```
IF expected_cooperators >= m:
    # Others likely cover the threshold - FREE RIDE
    ACTION: D
    
ELIF expected_cooperators >= m - 1 AND expected_cooperators < m:
    # I might be the pivotal player
    # Cooperate with probability based on how close we are to threshold
    pivot_probability = (m - expected_cooperators)
    
    IF random() < pivot_probability:
        ACTION: C
    ELSE:
        ACTION: D
        
ELIF expected_cooperators < m - 1:
    # Threshold unlikely to be met even if I cooperate
    # Check if cooperation might encourage others (early game) or is futile (late game)
    
    IF rounds_remaining > r/2 AND my_cooperation_count < 2:
        # Early game: occasional cooperation to avoid being seen as pure defector
        # This can encourage others to cooperate more
        ACTION: C (with 30% probability)
    ELSE:
        ACTION: D
```

**Step 3: Reactive Adjustment**
```
IF last_round_cooperators < m for 2+ consecutive rounds:
    # Collective is failing - consider cooperating to restart momentum
    # But only if it's not too late
    IF rounds_remaining > 2:
        Increase cooperation probability by 20%

IF I defected last round AND threshold was met by exactly m players:
    # Perfect exploitation achieved - likely repeat
    ACTION: D (override above)
```

#### Last Round (r):
- **Action: D**
- Rationale: No future consequences. Pure defection is dominant if others will meet threshold; if not, my cooperation alone likely won't matter unless expected_cooperators = m-1 exactly (then cooperate).

```
IF expected_cooperators >= m - 0.5 AND expected_cooperators < m:
    ACTION: C  # Be pivotal for final reward
ELSE:
    ACTION: D  # Either covered or hopeless
```

### Edge Cases

1. **n = 2, m = 2**: Both must cooperate. Defect round 1, then match opponent's last action (tit-for-tat variant), defect last round.

2. **m very close to n**: Cooperation more necessary. Increase base cooperation probability, but still defect when others' cooperation is high enough.

3. **k very large**: Threshold reward dominates. More willing to cooperate to ensure threshold is met, but still prefer others to do it.

4. **k barely above 1**: Free-riding premium is small. Can afford to be more exploitative since missing threshold isn't catastrophic.

5. **All opponents appear to be pure defectors**: 
   - If sustained defection from all, accept fate and defect (futile to cooperate alone)
   - Threshold will never be met; minimize losses

6. **Opponents appear to be tracking me specifically**:
   - If my defection correlates with threshold failures, slightly increase cooperation
   - But never become a reliable cooperator they can exploit

### Summary Pseudocode

```python
def decide(round, history, game_params):
    n, r, m, k = game_params
    
    if round == 1:
        return DEFECT
    
    if round == r:
        exp_coop = estimate_others_cooperation(history)
        if m - 1 <= exp_coop < m:
            return COOPERATE
        return DEFECT
    
    exp_coop = estimate_others_cooperation(history)
    
    if exp_coop >= m:
        return DEFECT  # Free ride
    elif exp_coop >= m - 1:
        return COOPERATE if random() < (m - exp_coop) else DEFECT
    else:
        if rounds_remaining(round, r) > r/2 and my_coop_count(history) < 2:
            return COOPERATE if random() < 0.3 else DEFECT
        return DEFECT
```

This strategy maximizes exploitation by defecting whenever others are likely to cover the threshold, while strategically cooperating only when pivotal or to maintain plausible cooperative reputation.
'''

description_EXPLOITATIVE_102 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride on others' cooperation while ensuring the threshold is still met**. The key insight is that if exactly `m` players cooperate, defectors get the highest possible payoff (`1 + k`), while cooperators get only `k`. My goal is to be among the defectors when the threshold is barely met, and only cooperate when my contribution is genuinely pivotal to reaching the threshold.

## Strategy Overview

I will estimate the number of other cooperators and defect whenever I predict at least `m` others will cooperate. I only cooperate when I calculate that my contribution is necessary to reach the threshold—and even then, I apply pessimistic corrections in late rounds.

---

## Decision Rules

### Round 1: Probabilistic Defection Bias

With no history, I use a **cautious defection** approach:
- Calculate the probability that at least `m` of `(n-1)` other players cooperate, assuming others cooperate with probability `p_base = m/n` (the "fair share" rate)
- If this probability exceeds 50%, **Defect** (free-ride on expected cooperation)
- Otherwise, **Cooperate** (my contribution is likely pivotal)

### Rounds 2 to (r-1): Adaptive Exploitation

**Step 1: Estimate cooperation rate**
```
observed_coop_rate = (total cooperations by others) / ((n-1) * rounds_played)
```

**Step 2: Predict cooperators this round**
```
expected_other_cooperators = observed_coop_rate * (n-1)
```

**Step 3: Decision logic**
```
IF expected_other_cooperators >= m:
    DEFECT  # Free-ride; threshold will be met without me
    
ELIF expected_other_cooperators >= m - 1:
    # I might be pivotal - but apply exploitation filter
    IF observed_coop_rate > (m / (n-1)):
        DEFECT  # Others are over-cooperating; exploit them
    ELSE:
        COOPERATE  # My contribution is genuinely needed
        
ELSE:
    # Threshold unlikely to be met
    IF expected_other_cooperators < m - 2:
        DEFECT  # Lost cause; save my endowment
    ELSE:
        COOPERATE  # Small chance of pivotality
```

**Step 4: Defection drift adjustment**

Track if cooperation rates are declining. If the cooperation rate dropped by more than 20% compared to the first half of the game, slightly increase my willingness to cooperate (threshold becomes `m - 1.5` instead of `m - 1`) to avoid collective collapse.

### Final Round (Round r): Maximum Exploitation

The last round has no future consequences, so I apply **pure exploitation**:

```
IF expected_other_cooperators >= m:
    DEFECT  # Guaranteed free-ride
ELIF expected_other_cooperators >= m - 1 AND observed_coop_rate > 0.6:
    DEFECT  # Gamble that at least one other "nice" player cooperates
ELSE:
    DEFECT  # No retaliation possible; defection dominates
```

**Note:** I almost always defect in the final round unless cooperation rates have been extremely low AND `k` is very large (making the threshold bonus worth risking).

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| `m = n-1` or `m = n` | Cooperate early, defect late | High threshold requires early buy-in to establish norms |
| `m = 2` (very low threshold) | Defect heavily | Easy for others to meet threshold |
| `k` is very large (>3) | Slightly more cooperative | Threshold bonus worth protecting |
| All others defected last round | Defect | Collapse likely; preserve endowment |
| All others cooperated last round | Defect | Perfect free-riding opportunity |
| Observed rate exactly `m/(n-1)` | Defect | Others are meeting "fair share"; I can exploit |

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        p_threshold_met = prob_binomial(n-1, m, p=m/n)
        return DEFECT if p_threshold_met > 0.5 else COOPERATE
    
    coop_rate = count_other_cooperations(history) / ((n-1) * (round-1))
    expected_coops = coop_rate * (n-1)
    
    if round == r:  # Final round
        return DEFECT
    
    if expected_coops >= m:
        return DEFECT
    elif expected_coops >= m - 1:
        return DEFECT if coop_rate > m/(n-1) else COOPERATE
    elif expected_coops < m - 2:
        return DEFECT
    else:
        return COOPERATE
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever others are predicted to meet the threshold
2. **Punishes altruists**: Takes advantage of high cooperators without reciprocating
3. **Abandons lost causes**: Doesn't waste resources when collapse is inevitable
4. **End-game ruthlessness**: Defects in final round regardless of prior dynamics
5. **Adaptive parasitism**: Adjusts exploitation level based on observed "host" cooperation rates
'''

description_EXPLOITATIVE_103 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that in this game, **defectors get strictly higher payoffs than cooperators when the threshold is met**. The optimal exploitative position is to defect while exactly m others cooperate. My strategy aims to manipulate others into being the "suckers" who cooperate while I free-ride on their contributions.

## Strategy Overview

I will **defect by default** and only cooperate when I calculate that my cooperation is absolutely necessary to meet the threshold (and thus receive the bonus k), or when strategic cooperation now enables greater future exploitation.

---

## Decision Rules

### Information Tracking
For each round, track:
- `coop_count[t]` = number of cooperators in round t
- `player_history[i]` = list of each player's past actions
- `coop_rate[i]` = cooperation frequency of player i

### Classification of Opponents
After observing history, classify each opponent:
- **Unconditional Cooperator**: coop_rate > 0.8
- **Unconditional Defector**: coop_rate < 0.2
- **Conditional/Reactive**: 0.2 ≤ coop_rate ≤ 0.8

### Core Decision Logic

```
function decide(round_number, history, parameters):
    n, r, m, k = parameters
    rounds_remaining = r - round_number + 1
    
    # Count reliable cooperators (unconditional cooperators)
    reliable_coops = count players with coop_rate > 0.8
    
    # Count likely cooperators this round (based on recent behavior)
    expected_coops = estimate_cooperators(history)
    
    # CASE 1: Last round - pure exploitation
    if round_number == r:
        if expected_coops >= m:
            return DEFECT  # Free-ride on others
        elif expected_coops == m - 1 and k > 1:
            return COOPERATE  # My cooperation triggers bonus
        else:
            return DEFECT  # Threshold unreachable anyway
    
    # CASE 2: Threshold will be met without me
    if expected_coops >= m:
        return DEFECT  # Free-ride
    
    # CASE 3: Threshold impossible even with me
    if expected_coops + 1 < m:
        return DEFECT  # Don't waste contribution
    
    # CASE 4: I am pivotal (expected_coops == m - 1)
    if expected_coops == m - 1:
        # Cooperate only if bonus exceeds cost
        if k > 1:
            # But check if I can train others to cooperate instead
            if rounds_remaining > 3 and reliable_coops < m:
                # Early game: defect to force others to step up
                return DEFECT
            else:
                return COOPERATE
        else:
            return DEFECT
    
    # CASE 5: Default
    return DEFECT
```

### Estimating Expected Cooperators

```
function estimate_cooperators(history):
    if no history:
        # First round: assume others are cautiously cooperative
        return floor(n * 0.5)
    
    # Weight recent rounds more heavily
    weighted_sum = 0
    for each player i (excluding self):
        recent_coop_rate = weighted average of last 3 rounds (or all if fewer)
        weighted_sum += recent_coop_rate
    
    return round(weighted_sum)
```

---

## Edge Cases

### First Round
- **Defect**. Rationale: Test the waters. If threshold is met without me, I've gained maximally. If not, I've lost only the bonus k, not my endowment.

### Last Round
- Pure Nash equilibrium calculation: Defect unless I'm exactly pivotal and k > 1.

### Threshold Consistently Missed
- If threshold hasn't been met for 3+ consecutive rounds, and expected_coops + 1 ≥ m, cooperate **once** to demonstrate the bonus is achievable, then resume defection.

### Threshold Consistently Met
- Continue defecting—this is the ideal parasitic position.

### Everyone Defecting
- If coop_count has been 0 for multiple rounds and m ≤ ceil(n/2), consider one cooperative "probe" to see if others are playing reactive strategies.

---

## Why This Is Exploitative

1. **Defection bias**: The strategy defaults to defection, only cooperating when mathematically necessary.

2. **Free-riding priority**: When others reliably cooperate to meet threshold, I harvest the bonus without contributing.

3. **Pivotal calculus**: I only cooperate when I'm the decisive vote AND the bonus exceeds my cost.

4. **Training opponents**: Early defection can condition reactive players to become the reliable cooperators I exploit later.

5. **No reciprocity**: I never cooperate "to be fair" or to reward others' cooperation—only for my direct benefit.
'''

description_EXPLOITATIVE_104 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride whenever possible** while ensuring the collective threshold is met just often enough to harvest the reward. Since I cannot coordinate with others, I must statistically position myself to benefit from others' cooperation while minimizing my own contributions.

## Key Strategic Insights

1. **The free-rider advantage**: When exactly m players cooperate, defectors get payoff 1+k while cooperators get only k. Defecting when the threshold is barely met is strictly dominant.

2. **The catastrophic failure**: When fewer than m cooperate, everyone loses the bonus. Pure defection by all yields only 1 per round.

3. **Information asymmetry exploitation**: By observing others' patterns, I can predict cooperation rates and position myself to defect when others will likely meet the threshold without me.

## Decision Rules

### Round 1: Cautious Defection
- **Action: DEFECT**
- Rationale: No information yet. Test the waters. If others are cooperative, I benefit maximally. If not, I lose nothing relative to cooperating in a failed threshold.

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate from history:**
- `coop_rate` = average number of cooperators per round (excluding self)
- `expected_others_cooperating` = estimated cooperators this round among other n-1 players

**Decision Logic:**

```
IF expected_others_cooperating >= m THEN:
    # Others will likely meet threshold without me
    ACTION: DEFECT (free-ride)

ELSE IF expected_others_cooperating == m-1 THEN:
    # I'm potentially pivotal
    # Cooperate with probability based on rounds remaining
    rounds_left = r - current_round
    IF rounds_left > 3 THEN:
        # Early game: build cooperation, defect sometimes
        ACTION: COOPERATE with probability 0.6
    ELSE:
        # Late game: less reason to invest in future
        ACTION: COOPERATE with probability 0.3

ELSE IF expected_others_cooperating < m-1 THEN:
    # Threshold unlikely to be met even if I cooperate
    # Check if cooperation might signal and build future cooperation
    IF coop_rate is declining AND rounds_left > 2 THEN:
        ACTION: COOPERATE (attempt to revive cooperation)
    ELSE:
        ACTION: DEFECT (don't throw away endowment)
```

**Estimating expected cooperators:**
- Use exponentially weighted moving average of past cooperation counts
- Weight recent rounds more heavily (factor 0.7 for last round, decaying)
- Adjust for observed player-specific patterns if detectable

### Final Round (Round r): Pure Defection
- **Action: DEFECT**
- Rationale: No future to invest in. If others cooperate enough, I gain maximally. If not, I preserved my endowment. This is strictly dominant in the last round.

### Penultimate Round (Round r-1): Lean Toward Defection
- Apply standard logic but increase defection probability by 20%
- Others may also defect anticipating the end

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2, m = 2 | Defect rounds 1 and r; cooperate middle rounds only if partner cooperated | Need mutual cooperation; punish defection |
| m very close to n | More willing to cooperate in early/mid game | Each player is likely pivotal |
| m very small relative to n | Heavy defection bias | Easy to free-ride |
| k very large | Slightly more cooperation when pivotal | Threshold success is highly valuable |
| All others defected last round | Defect | Cooperation won't meet threshold alone |
| Cooperation rate exactly at m | Defect immediately | Perfect free-riding opportunity |

## Exploitation Mechanisms

1. **Last-round exploitation**: Guaranteed defection extracts maximum value from cooperators
2. **Threshold surfing**: Stay just below the cooperation level needed, letting others bear the cost
3. **Pattern detection**: If specific "players" always cooperate, defect more aggressively
4. **Collapse acceleration**: In late game, defect to trigger cascade failures if I've already accumulated enough

## Summary Pseudocode

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    if round == r:
        return DEFECT
    
    others_coop = estimate_others_cooperation(history)
    
    if others_coop >= m:
        return DEFECT
    else if others_coop == m - 1:
        pivot_prob = 0.6 if (r - round) > 3 else 0.3
        return COOPERATE with probability pivot_prob
    else:
        if cooperation_declining(history) and (r - round) > 2:
            return COOPERATE
        else:
            return DEFECT
```

This strategy maximizes personal payoff by free-riding on cooperative populations while providing just enough cooperation to prevent complete collapse when necessary.
'''

description_EXPLOITATIVE_105 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding** when exactly m players cooperate. My goal is to defect as often as possible while ensuring the threshold is met (so I still get the bonus k). I need to identify and exploit cooperative players while avoiding being the "sucker" who cooperates when others defect.

## Strategy: "Reluctant Last-Mover"

### Decision Framework

The strategy tracks each player's **cooperation rate** from history and uses this to predict whether the threshold will be met without my contribution.

---

### Round-by-Round Decision Rules

#### **First Round:**
- **Defect.**
- Rationale: I sacrifice nothing to gather information. If others cooperate, I free-ride. If they don't, I lose only the shared bonus (which requires others anyway).

#### **Middle Rounds (rounds 2 through r-1):**

1. **Calculate each opponent's cooperation probability** based on their historical cooperation rate:
   - `coop_rate[j] = (times j cooperated) / (rounds played)`

2. **Estimate expected cooperators (excluding myself):**
   - `expected_others = sum(coop_rate[j] for all j ≠ i)`

3. **Decision logic:**

```
IF expected_others >= m + 0.5:
    DEFECT  (threshold likely met without me - free ride)
    
ELSE IF expected_others >= m - 0.5:
    DEFECT with probability 0.7, COOPERATE with probability 0.3
    (threshold is borderline - gamble on others, occasionally contribute)
    
ELSE IF expected_others >= m - 1.5:
    COOPERATE  (my contribution likely pivotal)
    
ELSE:
    DEFECT  (threshold unlikely even with my help - don't waste contribution)
```

4. **Punishment mechanism:** If in the previous round, fewer than m cooperated AND I cooperated:
   - I was exploited. Defect for the next 2 rounds regardless of predictions.
   - This discourages opponents from free-riding on me specifically.

5. **Exploitation detector:** Track players who *never* cooperate after round 3:
   - Reduce their expected contribution to 0 in calculations (don't count on permanent defectors).

#### **Last Round (round r):**
- **Always Defect.**
- Rationale: No future rounds mean no punishment possible. Pure Nash equilibrium logic applies—defection weakly dominates.

---

### Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    # Check if I was exploited last round
    if was_exploited_recently(history, punishment_window=2):
        return DEFECT
    
    # Calculate expected cooperators among others
    expected_others = 0
    for each opponent j:
        if opponent_is_permanent_defector(j, history):
            expected_others += 0
        else:
            expected_others += cooperation_rate(j, history)
    
    # Decision based on expected threshold achievement
    if expected_others >= m + 0.5:
        return DEFECT
    else if expected_others >= m - 0.5:
        return DEFECT with prob 0.7, else COOPERATE
    else if expected_others >= m - 1.5:
        return COOPERATE
    else:
        return DEFECT
```

---

### Why This Strategy is Exploitative

1. **Maximizes free-riding:** Defaults to defection whenever the threshold seems achievable without me.

2. **Punishes exploitation:** If I cooperate and get burned, I withdraw cooperation—teaching others not to rely on me as a guaranteed cooperator.

3. **Identifies suckers:** Players with high cooperation rates become predictable resources to exploit.

4. **Identifies lost causes:** Permanent defectors are written off—I don't waste cooperation trying to help groups that will never hit threshold.

5. **Endgame exploitation:** Guaranteed defection in the last round captures maximum value when punishment is impossible.

6. **Information asymmetry:** By defecting round 1, I reveal nothing about my willingness to cooperate while learning about others.
'''

description_EXPLOITATIVE_106 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that in this game, **defectors get the best payoff when exactly m players cooperate** (they get 1 + k while cooperators only get k). My strategy aims to be a defector in rounds where I predict the threshold will be met, and only cooperate when my contribution is genuinely pivotal to meeting the threshold.

## Strategy Overview

I will track opponent behavior to estimate cooperation probabilities, then defect whenever I expect enough others to cooperate without me, and cooperate only when I calculate my contribution is necessary to meet the threshold.

---

## Decision Rules

### Round-by-Round Logic

**Let `expected_cooperators` = estimated number of other players who will cooperate this round (excluding me)**

1. **If `expected_cooperators` ≥ m**: **DEFECT**
   - The threshold will likely be met without me; I free-ride and collect 1 + k

2. **If `expected_cooperators` = m - 1**: **COOPERATE**
   - I am the pivotal player; my cooperation tips us over the threshold
   - I get k, which beats getting 1 if threshold fails

3. **If `expected_cooperators` < m - 1**: **DEFECT**
   - Even if I cooperate, we won't reach threshold
   - Save my endowment and collect 1

---

## Estimating Expected Cooperators

### Tracking Opponent Behavior

For each opponent j, maintain:
- `coop_count[j]` = number of times player j has cooperated
- `rounds_played` = total rounds completed

**Individual cooperation probability**: `p[j] = coop_count[j] / rounds_played`

**Expected cooperators (excluding me)**: `expected_cooperators = Σ p[j]` for all j ≠ i

### Adaptive Weighting (Recency Bias)

To adapt to changing strategies, weight recent rounds more heavily:
- Use exponential moving average with decay factor α = 0.7
- `p[j] = α * (recent_action) + (1-α) * (old_estimate)`

---

## Edge Cases

### First Round
- **No history available**
- Assume opponents are rational and may attempt coordination
- **Heuristic**: Estimate baseline cooperation rate of 50%
- `expected_cooperators = (n-1) * 0.5`
- Apply standard decision rules with this estimate
- If `(n-1) * 0.5 ≈ m - 1` (within 0.5), **COOPERATE** to be safe in uncertain conditions

### Last Round
- No future consequences; pure exploitation mode
- **DEFECT** unless `expected_cooperators` is very close to `m - 1` (within 0.3)
- Rationale: Others may also defect in final round, so be more pessimistic about reaching threshold

### Near-Threshold Uncertainty
When `|expected_cooperators - (m-1)| < 0.5`:
- This is high-uncertainty territory
- Calculate expected value of each action:
  - `EV(Cooperate) = P(≥m-1 others cooperate) * k + P(<m-1 others) * 0`
  - `EV(Defect) = P(≥m others cooperate) * (1+k) + P(<m others) * 1`
- Choose action with higher EV

---

## Pseudocode

```
initialize:
    coop_history[j] = [] for all opponents j
    alpha = 0.7  # recency weight

function estimate_cooperation_prob(j):
    if no history:
        return 0.5
    return exponential_moving_average(coop_history[j], alpha)

function decide(round_number, total_rounds):
    expected_coop = sum(estimate_cooperation_prob(j) for j in opponents)
    
    # Last round - aggressive defection
    if round_number == total_rounds:
        if expected_coop >= m - 0.3:
            return DEFECT
        else:
            return DEFECT  # likely fails anyway
    
    # Standard decision
    if expected_coop >= m:
        return DEFECT  # free-ride
    elif expected_coop >= m - 1 - 0.5:
        # Near-pivotal: compute EV
        if EV(COOPERATE) > EV(DEFECT):
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT  # hopeless, save endowment

function update_history(observed_actions):
    for each opponent j:
        append observed_actions[j] to coop_history[j]
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever the threshold is likely met without personal contribution
2. **Minimizes wasted cooperation**: Only cooperates when pivotal
3. **Adapts to opponents**: Exploits consistent cooperators; avoids contributing when surrounded by defectors
4. **End-game exploitation**: Defects in final round when retaliation is impossible
'''

description_EXPLOITATIVE_107 = '''
# Exploitative Strategy for Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding** when others cooperate enough to meet the threshold. My strategy aims to:
1. **Extract maximum value** by defecting whenever I predict the threshold will be met without me
2. **Cooperate minimally** - only when my contribution is likely pivotal to reaching threshold m
3. **Exploit predictable cooperators** while avoiding being exploited myself

## Strategy: "Threshold Parasite"

### Decision Framework

**Primary Rule:** Defect by default. Only cooperate when I estimate my contribution is necessary to reach exactly m cooperators.

### Round-by-Round Logic

#### First Round
- **If m ≤ n/2:** DEFECT (optimistic that enough others will cooperate)
- **If m > n/2:** COOPERATE (threshold is high, need to seed cooperation)

#### Middle Rounds (rounds 2 through r-1)

**Step 1: Classify each opponent based on history**
- **Reliable Cooperator:** Cooperated ≥ 70% of past rounds
- **Reliable Defector:** Defected ≥ 70% of past rounds  
- **Unpredictable:** Everyone else

**Step 2: Estimate expected cooperators (excluding myself)**
```
expected_cooperators = 
    (count of Reliable Cooperators × 0.85) +
    (count of Reliable Defectors × 0.15) +
    (count of Unpredictable × their_personal_cooperation_rate)
```

**Step 3: Decision**
```
if expected_cooperators >= m:
    DEFECT  # Free-ride on others' cooperation
elif expected_cooperators >= m - 1 AND expected_cooperators < m:
    COOPERATE with probability = (m - expected_cooperators)
    # Be the pivotal cooperator, but add randomness to stay unpredictable
elif expected_cooperators < m - 1:
    # Threshold unlikely to be met even with my help
    if (expected_cooperators + count of Unpredictable × 0.5) >= m - 1:
        COOPERATE  # There's hope if unpredictables swing cooperative
    else:
        DEFECT  # Lost cause, save my endowment
```

#### Last Round (round r)
- **Pure exploitation round** - no future consequences
- Use same estimation logic but with **lower cooperation threshold:**
```
if expected_cooperators >= m:
    DEFECT  # Guaranteed free-ride
elif expected_cooperators >= m - 1.5:
    DEFECT  # Gamble on others cooperating; no tomorrow to recover
else:
    DEFECT  # Threshold won't be met anyway
```
**Translation: Always defect in the last round** unless my model shows cooperation is absolutely pivotal AND likely to succeed.

### Adaptive Exploitation Mechanisms

**Mechanism 1: Defector Cascade Detection**
- If cooperation rate across all players drops below m/n for 2+ consecutive rounds:
- Switch to DEFECT until I observe a recovery (≥m cooperators in a round)

**Mechanism 2: Sucker Detection**
- Track players who cooperate even when threshold wasn't met previous round
- These are "committed cooperators" - weight them at 0.95 cooperation probability
- Exploit them ruthlessly by defecting when they're counted toward meeting threshold

**Mechanism 3: Coordination Punishment**
- If I cooperated and threshold was NOT met (I got suckered):
- Defect for the next 2 rounds regardless of estimates
- This makes me unpredictable and harder to exploit

### Edge Cases

| Situation | Action |
|-----------|--------|
| n = m (everyone needed) | Cooperate only if all others are Reliable Cooperators |
| m = 2 (low threshold) | Almost always defect; easy for others to cover |
| k is very large | Slightly more willing to cooperate when pivotal (threshold at m-1.2 instead of m-1) |
| All opponents defected last round | Defect (coordination has collapsed) |
| I'm the only defector and threshold was met | Continue defecting (perfect exploitation achieved) |

### Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE if m > n/2 else DEFECT
    
    if round == r:
        return DEFECT  # End-game exploitation
    
    expected_coop = estimate_cooperators(history)
    
    if was_suckered_recently(history):
        return DEFECT  # Punishment mode
    
    if expected_coop >= m:
        return DEFECT  # Free-ride
    elif expected_coop >= m - 1:
        return COOPERATE with probability (m - expected_coop)
    elif recovery_possible(expected_coop, m):
        return COOPERATE
    else:
        return DEFECT  # Lost cause
```

This strategy maximizes personal payoff by contributing only when pivotal, free-riding whenever possible, and remaining unpredictable enough to avoid being the predictable cooperator that others exploit.
'''

description_EXPLOITATIVE_108 = '''
# Exploitative Strategy: "Threshold Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in the Collective Risk Dilemma: when exactly m players cooperate, defectors receive the highest possible payoff (1 + k) while cooperators receive less (k). The goal is to **free-ride on others' cooperation** while ensuring the threshold is still met, and to **punish populations that don't cooperate enough** by withholding contribution entirely.

## Strategy Overview

The strategy maintains a probabilistic cooperation approach that adapts based on observed cooperation rates, always seeking to position itself as a marginal defector when possible—someone who defects while others hit the threshold.

---

## Decision Rules

### Key Variables to Track
- `coop_rate`: Rolling cooperation rate from previous rounds (proportion of all players who cooperated)
- `round_number`: Current round t
- `total_rounds`: r
- `threshold_ratio`: m/n (what fraction needs to cooperate)

### Round-by-Round Logic

```
FUNCTION decide_action(history, parameters):
    
    n, r, m, k = parameters
    t = current_round
    threshold_ratio = m / n
    
    # FIRST ROUND: Probe the population
    IF t == 1:
        # Defect to gather information risk-free
        # If others cooperate enough, we profit maximally
        RETURN DEFECT
    
    # CALCULATE observed cooperation rate (excluding self)
    coop_rate = count_cooperations(history) / ((t-1) * (n-1))
    
    # LAST ROUND: Pure exploitation
    IF t == r:
        # No future consequences - always defect
        RETURN DEFECT
    
    # NEAR-END ROUNDS (final 20% of game)
    IF t > 0.8 * r:
        # Increase defection as game ends
        # Others can't punish effectively
        RETURN DEFECT
    
    # MAIN ADAPTIVE LOGIC
    
    # Case 1: Cooperation is abundant (rate > threshold + buffer)
    IF coop_rate > threshold_ratio + 0.15:
        # Free-ride: others will likely hit threshold without us
        RETURN DEFECT
    
    # Case 2: Cooperation is near threshold
    IF coop_rate >= threshold_ratio - 0.1 AND coop_rate <= threshold_ratio + 0.15:
        # Critical zone - be probabilistic to avoid being predictable
        # Cooperate with probability that keeps us just at threshold
        
        expected_cooperators = coop_rate * (n - 1)
        shortfall = m - expected_cooperators
        
        IF shortfall <= 0:
            # Threshold likely met without us
            RETURN DEFECT
        ELSE:
            # Cooperate with probability based on how much we're needed
            p_cooperate = min(shortfall / m, 0.5)
            RETURN COOPERATE with probability p_cooperate, else DEFECT
    
    # Case 3: Cooperation is scarce (rate < threshold - buffer)
    IF coop_rate < threshold_ratio - 0.1:
        # Check if cooperation is collapsing
        IF coop_rate < 0.1:
            # Population isn't cooperating - don't waste resources
            RETURN DEFECT
        ELSE:
            # Occasionally cooperate to test if others respond
            # But mostly defect since threshold won't be met anyway
            RETURN COOPERATE with probability 0.2, else DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **Round 1** | DEFECT | Gather information; no reputation cost yet |
| **Round r (last)** | DEFECT | No future rounds; pure exploitation |
| **Rounds > 80% of r** | DEFECT | Diminishing punishment window |
| **Very high coop (>80%)** | DEFECT | Guaranteed free-ride opportunity |
| **Very low coop (<10%)** | DEFECT | Threshold won't be met anyway |
| **m = n-1** | Increase cooperation | We're likely pivotal |
| **m << n** | Decrease cooperation | Easy to free-ride |

---

## Exploitation Mechanisms

1. **Information Asymmetry Exploitation**: First round defection extracts maximum value from cooperative opponents before they can adjust.

2. **Threshold Surfing**: When cooperation hovers near m, we strategically defect to claim the +1 bonus while others bear the cooperation cost.

3. **End-Game Exploitation**: Systematic defection in final rounds when punishment is impossible.

4. **Collapse Acceleration**: When cooperation falls below viable levels, we defect to conserve resources rather than futilely trying to reach threshold alone.

5. **Probabilistic Camouflage**: Mixed strategies prevent opponents from specifically targeting us for punishment while still achieving net exploitation.
'''

description_EXPLOITATIVE_109 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight in this game is that **defectors get strictly higher payoffs than cooperators when the threshold is met**. My goal is to maximize the probability that exactly `m` others cooperate while I defect—extracting the collective benefit without paying the cost.

## Strategy Overview

I will dynamically estimate the cooperation probability of the population and position myself to free-ride whenever the threshold is likely to be met without me, while cooperating only when my contribution is likely to be pivotal (preventing collective failure that hurts me too).

---

## Decision Rules

### Information Tracked Each Round
- `coop_rate`: Rolling estimate of population cooperation rate (excluding myself)
- `round_number`: Current round t
- `rounds_remaining`: r - t

### Core Decision Logic

**Step 1: Estimate Population Cooperation Rate**
```
After round t, calculate:
  coop_rate = (total cooperations by others in all past rounds) / ((n-1) * t)
  
For round 1: use prior estimate coop_rate = m / n (assume others aim for threshold)
```

**Step 2: Calculate Probability Threshold Will Be Met Without Me**

Using binomial approximation:
```
P(≥m others cooperate) = Σ(j=m to n-1) C(n-1,j) * coop_rate^j * (1-coop_rate)^(n-1-j)
```

**Step 3: Decision Rule**
```
IF P(≥m others cooperate) > 0.5:
    DEFECT  # Free-ride: threshold likely met without me
    
ELIF P(exactly m-1 others cooperate) > 0.3 AND k > 1.5:
    COOPERATE  # I'm likely pivotal, and reward is worth it
    
ELSE:
    DEFECT  # Threshold unlikely to be met anyway, save my endowment
```

---

## Edge Case Handling

### First Round (No History)
- **Default to DEFECT** with probability `(n-m)/n`, COOPERATE otherwise
- Rationale: If everyone reasons similarly, approximately `m` will cooperate. I want to be among the defectors while threshold is met.
- Implementation: `DEFECT if my_index > m else COOPERATE` (deterministic based on player index if available) OR use randomization

### Last Round
- **Pure exploitation**: Same logic but with slight bias toward DEFECT
- No future punishment possible, so maximize immediate gain
- Only cooperate if `P(exactly m-1 cooperate) > 0.5` (truly pivotal)

### When Cooperation Rate is Very High (>0.8)
- **Aggressively DEFECT**: Others are covering the threshold
- This is the prime exploitation scenario

### When Cooperation Rate is Very Low (<0.3)
- **DEFECT**: Threshold won't be met regardless
- Don't throw good money after bad

### When Cooperation Rate is Near Threshold (m/(n-1) ± 0.15)
- **Probabilistic cooperation**: Cooperate with probability that makes me pivotal
- `P(cooperate) = max(0, (m - expected_cooperators) / uncertainty)`

---

## Adaptive Mechanisms

### Regime Detection
```
IF last 3 rounds had ≥m cooperators AND I defected in all:
    Continue defecting (exploitation working)
    
IF last 3 rounds had <m cooperators:
    Increase cooperation probability temporarily (need to seed cooperation)
    But only for 1-2 rounds, then test defection again
```

### Anti-Punishment Camouflage
If I detect my defection rate is highest (others might target me):
```
Cooperate for 1 round every 4-5 rounds to appear "moderate"
Resume exploitation after brief cooperation signal
```

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT if random() > m/n else COOPERATE
    
    coop_rate = count_others_cooperations(history) / ((n-1) * (round-1))
    p_threshold_met = binomial_cdf_complement(m, n-1, coop_rate)
    p_pivotal = binomial_pmf(m-1, n-1, coop_rate)
    
    # Last round: pure exploitation
    if round == r:
        return COOPERATE if p_pivotal > 0.5 else DEFECT
    
    # Main logic
    if p_threshold_met > 0.5:
        return DEFECT  # Free-ride
    elif p_pivotal > 0.3 and k > 1.5:
        return COOPERATE  # Pivotal and worth it
    else:
        return DEFECT  # Not worth contributing
```

---

## Why This Strategy Exploits

1. **Targets the free-rider premium**: Defectors earn `1 + k` vs cooperators' `k` when threshold met
2. **Lets others bear the cost**: Only cooperates when mathematically necessary
3. **Adapts to cooperative opponents**: More cooperation by others = more defection by me
4. **Minimizes wasted contributions**: Never cooperates into a lost cause
5. **Robust to various opponent mixes**: Works whether opponents are cooperative, random, or strategic
'''

description_EXPLOITATIVE_110 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach in this game is to **free-ride on others' cooperation** whenever possible, while contributing just enough to prevent collective failure when necessary. The key insight is that if exactly m players are needed and I can predict that m or more others will cooperate, I should defect and claim the full payoff (1 + k) instead of the cooperator's payoff (k).

## Strategy Overview

I will maintain a probabilistic model of each player's cooperation likelihood based on observed history, then make decisions that maximize my expected payoff given those predictions.

---

## Decision Rules

### Round 1 (No History)

**Defect.**

Rationale: With no information about opponents, I cannot predict whether threshold will be met. By defecting, I guarantee payoff of 1 (if threshold fails) or 1+k (if threshold met). Cooperating risks getting 0 (threshold fails) or k (threshold met). Defection dominates in expectation under uncertainty, and I gather information about who the "natural cooperators" are.

### Middle Rounds (2 to r-1)

**Step 1: Estimate cooperation probabilities**

For each player j ≠ me, calculate:
```
p_j = (number of times j cooperated) / (rounds played so far)
```

**Step 2: Calculate expected cooperators without me**

```
E[cooperators_others] = Σ p_j for all j ≠ me
```

**Step 3: Calculate probability threshold is met without me**

Use the estimated probabilities to compute P(at least m others cooperate). For computational simplicity, approximate using:
```
P(threshold_met_without_me) = P(Σ X_j ≥ m) where X_j ~ Bernoulli(p_j)
```

**Step 4: Decision rule**

```
If P(threshold_met_without_me) > threshold_confidence:
    DEFECT  (free-ride on others)
    
Else if P(threshold_met_with_me) > threshold_confidence:
    # Check if my cooperation would tip us over
    If E[cooperators_others] is in range [m-1.5, m+0.5]:
        COOPERATE  (I'm pivotal)
    Else:
        DEFECT
        
Else:
    DEFECT  (lost cause, save my endowment)
```

Where `threshold_confidence = 0.6` (tunable parameter)

**Step 5: Exploitation adjustment**

If I've been cooperating and observe that threshold is consistently met with room to spare (average cooperators > m + 1), **switch to defection** for the next round to test if others will maintain the threshold without me.

### Last Round (Round r)

**Pure exploitation mode: Almost always DEFECT.**

Rationale: No future rounds mean no reputation consequences. The only exception:

```
If E[cooperators_others] ∈ [m-1, m) AND k > 1:
    COOPERATE  (only if I'm clearly pivotal and reward is worth it)
Else:
    DEFECT
```

---

## Pseudocode

```
function decide(round, history, n, m, k, r):
    
    if round == 1:
        return DEFECT
    
    # Calculate cooperation rates for each opponent
    coop_rates = []
    for each player j ≠ me:
        coop_rates[j] = count(history[j] == C) / (round - 1)
    
    expected_others = sum(coop_rates)
    
    # Estimate probability of threshold met without me
    p_threshold_without_me = calculate_threshold_probability(coop_rates, m)
    
    # Last round: pure exploitation
    if round == r:
        if (m - 1) <= expected_others < m and k > 1:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if p_threshold_without_me > 0.6:
        return DEFECT  # Free-ride
    
    elif expected_others >= m - 1.5 and expected_others <= m + 0.5:
        return COOPERATE  # I'm pivotal
    
    else:
        return DEFECT  # Lost cause or over-subscribed
```

---

## Edge Cases

| Situation | Action | Reason |
|-----------|--------|--------|
| n = m (everyone needed) | Cooperate after round 1 if others showed willingness | Can't free-ride if all are needed |
| m = n-1 | Defect unless cooperation rate is very high | One free-rider slot exists—claim it |
| All others always defect | Defect | Threshold will never be met |
| All others always cooperate | Defect | Maximum exploitation opportunity |
| k is very large | Slightly lower pivotal threshold | Worth cooperating to ensure big reward |
| Very few rounds (r ≤ 3) | Bias toward defection | Less time for reputation to matter |

---

## Why This Strategy Is Exploitative

1. **Defaults to defection** — Only cooperates when strategically necessary
2. **Identifies and exploits cooperators** — Uses their predictability against them
3. **Maximizes free-riding** — Claims 1+k whenever others provide the threshold
4. **Abandons lost causes** — Doesn't waste resources on failing groups
5. **End-game defection** — No sentimentality in final round
'''

description_EXPLOITATIVE_111 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that **defection is always more profitable than cooperation when the threshold is met**. My goal is to free-ride on others' cooperation while ensuring the threshold is reached just often enough to collect the bonus. I want to be a defector in a world where exactly m others cooperate.

## Strategy Overview: "Calculated Free-Rider"

This strategy exploits cooperative players by defecting whenever it's safe to do so, while maintaining just enough uncertainty about my behavior to prevent complete cooperation collapse.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: No history exists. Defection reveals information about others while preserving my endowment. If enough cooperators exist naturally, I get the free bonus.

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Count cooperation from previous round**
Let `prev_coop` = number of players who cooperated last round (excluding me)

**Step 2: Apply decision logic**

```
IF prev_coop >= m:
    # Threshold was met without me - DEFECT (free-ride)
    ACTION = D

ELSE IF prev_coop == m - 1:
    # I'm the pivotal player - cooperation depends on exploitation potential
    IF (times_I_defected / rounds_played) > 0.7:
        # I've been exploiting heavily; cooperate occasionally to keep hope alive
        ACTION = C with probability 0.3, else D
    ELSE:
        # Others are barely meeting threshold; defect and test their resolve
        ACTION = D

ELSE IF prev_coop < m - 1:
    # Not enough cooperators even with me
    # Check if cooperation is trending upward
    IF cooperation_is_increasing(last_3_rounds):
        # Defect - let others build up cooperation first
        ACTION = D
    ELSE:
        # Cooperation is collapsing; occasionally cooperate to probe
        ACTION = C with probability 0.15, else D
```

**Step 3: Reputation management**
```
IF I have defected for 4+ consecutive rounds AND prev_coop >= m - 2:
    # Risk of being identified as pure defector; throw in occasional C
    Override: ACTION = C with probability 0.2
```

### Final Round (Round r): Always Defect
- **Rationale**: No future consequences. Pure dominance of defection. Even if threshold fails, I keep my endowment.

---

## Auxiliary Functions

```
cooperation_is_increasing(last_k_rounds):
    Return TRUE if average cooperation in most recent k/2 rounds 
    exceeds average in earlier k/2 rounds
    
threshold_met_rate():
    Return (rounds where >= m cooperated) / (total rounds played)
```

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | D | Gather information risk-free |
| Round r (final) | D | No future; dominant strategy |
| n = m (all must cooperate) | D always | Threshold nearly impossible; save endowment |
| m = 2 (low threshold) | D aggressively | Easy for others to meet threshold without me |
| k is very large | Slightly more C | Worth occasional investment to ensure threshold |
| Threshold never met so far | D | Cooperation appears futile; preserve endowment |
| I'm always pivotal | Mix C/D | Don't become predictably exploitable |

---

## Exploitation Mechanisms

1. **Free-riding on cooperators**: When `prev_coop >= m`, I always defect, getting payoff k+1 while cooperators get only k.

2. **Testing resolve**: When cooperation is borderline, I defect to see if others will "pick up the slack."

3. **Maintaining false hope**: Occasional cooperation (especially after long defection streaks) prevents cooperators from giving up entirely, keeping the bonus flowing.

4. **Endgame extraction**: Final round pure defection maximizes terminal payoff.

5. **Threshold proximity awareness**: I cooperate most reluctantly, only when truly necessary and never predictably.

---

## Summary

**Default stance**: Defect unless strong evidence suggests I must cooperate to meet threshold AND the threshold bonus is at risk of disappearing permanently.

**Core principle**: Let others bear the cost of cooperation; harvest the collective benefit while contributing minimally.
'''

description_EXPLOITATIVE_112 = '''
# Exploitative Strategy: "Threshold Predator"

## Core Philosophy

This strategy aims to **free-ride whenever possible** while ensuring the collective threshold is met just often enough to extract maximum personal payoff. The key insight is that if I can predict that at least `m` others will cooperate, I should defect and collect the full payoff (1 + k). If cooperation is at risk of falling below threshold, I must decide whether saving the round is worth my contribution.

---

## Decision Framework

### Key Variables Tracked
- `coop_history[t]`: Number of cooperators in round t (excluding self)
- `player_profiles[i]`: Estimated cooperation probability for each player i
- `rounds_remaining`: r - current_round
- `threshold_met_rate`: Historical rate at which threshold was met

---

## Decision Rules

### Round 1: Defect
- **Rationale**: No information available. Defecting in round 1 provides crucial data about others' baseline cooperation rates at zero personal cost. If threshold fails, I only lose k (which I would have lost anyway if I cooperated alone). If threshold succeeds without me, I gain maximum payoff.

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Estimate expected cooperators this round**
```
expected_cooperators = sum(player_profiles[i]) for all other players
```

**Step 2: Apply decision logic**

```
IF expected_cooperators >= m:
    DEFECT  # Free-ride on others' cooperation
    
ELIF expected_cooperators >= m - 1 AND threshold_met_rate > 0.5:
    DEFECT  # Gamble that one more player cooperates than expected
    
ELIF expected_cooperators >= m - 1 AND my cooperation would likely tip threshold:
    COOPERATE with probability based on:
        - How much k exceeds 1 (higher k = more worth saving)
        - Rounds remaining (more rounds = more cooperative early)
        - Whether I've been "caught" defecting (others retaliating)
        
ELSE:
    DEFECT  # Threshold unreachable, save my endowment
```

### Last Round (Round r): Pure Exploitation
```
IF expected_cooperators >= m:
    DEFECT  # No future consequences, take maximum
ELIF expected_cooperators == m - 1 AND k > 1:
    COOPERATE  # My cooperation saves k, worth the cost of 1
ELSE:
    DEFECT  # Threshold unreachable
```

---

## Player Profiling Algorithm

After each round, update estimates:

```
For each player i:
    player_profiles[i] = (cooperations_by_i + 1) / (rounds_observed + 2)
    # Laplace smoothing to handle uncertainty
    
    # Adjust for detected patterns:
    IF player_i defected after I defected in previous round:
        player_profiles[i] *= 0.9  # They may be retaliating
    IF player_i has cooperated last 3 rounds:
        player_profiles[i] = min(0.95, player_profiles[i] * 1.1)  # Likely committed cooperator
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| m = n - 1 or m = n | Cooperate if k > 1 | Threshold requires near-unanimity; free-riding kills the game |
| k is very large (k > 2) | Slightly more cooperative | Threshold success is extremely valuable |
| Consistent threshold failure | Defect always | No point contributing to lost cause |
| One player always defects | Factor into estimates | Effectively m players must come from n-1 |
| I'm "caught" as defector (others reduce cooperation after my defections) | Temporarily cooperate | Reset others' behavior, then resume exploitation |

---

## Exploitation Tactics

1. **Identify "suckers"**: Players who cooperate regardless of outcomes are targets—their cooperation subsidizes my defection.

2. **Encourage threshold-adjacent outcomes**: If I can keep total cooperators at exactly m, all cooperators get k while defectors get 1+k. I want to be a defector in these scenarios.

3. **Late-game pivot**: In final rounds, become purely selfish. No future retaliation possible.

4. **Appear cooperative enough**: If total cooperation collapses, occasionally cooperate to "restart" cooperative norms in others, then resume exploitation.

---

## Summary Pseudocode

```python
def decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT
    
    expected_coop = estimate_cooperators(history)
    rounds_left = r - round
    
    if round == r:  # Last round
        return DEFECT if expected_coop >= m else (COOPERATE if expected_coop == m-1 and k > 1 else DEFECT)
    
    if expected_coop >= m:
        return DEFECT  # Free ride
    elif expected_coop >= m - 1:
        # I'm pivotal - cooperate only if k justifies it and reputation needs repair
        if k > 1.5 or (detected_retaliation(history) and rounds_left > 2):
            return COOPERATE
        return DEFECT
    else:
        return DEFECT  # Lost cause
```

This strategy maximizes personal payoff by cooperating only when absolutely necessary to meet the threshold, while exploiting predictable cooperators relentlessly.
'''

description_EXPLOITATIVE_113 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach recognizes a fundamental asymmetry: if exactly m players are needed to cooperate, and I can reliably predict that m or more *others* will cooperate, I should defect to maximize my payoff (getting 1 + k instead of 0 + k). The strategy aims to free-ride on cooperative players while ensuring the threshold is still met.

## Decision Framework

### Key Variables to Track
- `coop_rate[i]` = cooperation rate of player i across all observed rounds
- `total_cooperators_t` = number of cooperators in round t
- `rounds_remaining` = r - current_round
- `reliable_cooperators` = count of players with coop_rate > 0.7

### Decision Rules

#### Round 1: Probe with Conditional Cooperation
- **If m ≤ n/2:** DEFECT (threshold is low enough that others likely cover it)
- **If m > n/2:** COOPERATE (need to establish cooperation baseline; too risky to defect when threshold is high)

#### Middle Rounds (2 to r-1): Adaptive Free-Riding

```
Calculate: expected_cooperators = sum of coop_rate[i] for all other players

IF expected_cooperators >= m + 0.5:
    DEFECT  # Others will likely cover threshold; free-ride
    
ELIF expected_cooperators >= m - 0.5 AND expected_cooperators < m + 0.5:
    # Threshold is precarious - use probabilistic cooperation
    # Cooperate with probability based on how close we are to threshold
    p_coop = (m - expected_cooperators + 1) / 2
    COOPERATE with probability p_coop, else DEFECT
    
ELIF expected_cooperators < m - 0.5:
    # Not enough cooperators expected
    IF (expected_cooperators + 1 >= m) AND (k > 1.5):
        COOPERATE  # My cooperation could tip us over; worth it if k is high
    ELSE:
        DEFECT  # Lost cause this round; save my endowment
```

#### Last Round: Pure Exploitation
```
IF expected_cooperators >= m:
    DEFECT  # No future consequences; maximize immediate gain
ELIF expected_cooperators + 1 >= m AND k > 1:
    COOPERATE  # Still worth ensuring threshold if I'm pivotal
ELSE:
    DEFECT  # Threshold won't be met anyway
```

### Exploitation Amplifiers

**Identifying "Suckers":** Players with coop_rate > 0.8 are reliable cooperators. Count them.
- If `reliable_cooperators >= m`: Always DEFECT (they'll cover it)

**Detecting Other Exploiters:** Players with coop_rate < 0.3 are likely defectors.
- If `n - count(defector_types) < m`: Must occasionally cooperate or everyone loses

**Punishment Immunity:** Since I'm optimizing for total payoff, I don't retaliate against defectors—that's a sucker's game. I simply update my predictions.

### Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| r = 2 (minimal rounds) | Defect both rounds unless m > n-1 | Insufficient time for cooperation norms |
| m = n-1 (high threshold) | Cooperate unless I see a reliable defector | Can't afford threshold failure |
| m = 2 (low threshold) | Defect unless only 1 other player ever cooperates | Easy to free-ride |
| k > 3 (high reward) | Bias toward ensuring threshold met | Payoff from success outweighs free-riding gain |
| All previous rounds failed threshold | Defect | Cooperation regime has collapsed |

### Pseudocode Summary

```python
def decide(game_params, history):
    n, r, m, k = game_params
    current_round = len(history) + 1
    
    if current_round == 1:
        return DEFECT if m <= n/2 else COOPERATE
    
    # Calculate expected cooperators from others
    coop_rates = [player_coop_rate(i, history) for i in other_players]
    expected_others = sum(coop_rates)
    reliable_count = sum(1 for rate in coop_rates if rate > 0.7)
    
    # Last round: pure exploitation
    if current_round == r:
        return DEFECT if expected_others >= m else (COOPERATE if expected_others + 1 >= m and k > 1 else DEFECT)
    
    # Middle rounds: adaptive free-riding
    if reliable_count >= m or expected_others >= m + 0.5:
        return DEFECT
    elif expected_others >= m - 0.5:
        return COOPERATE if random() < (m - expected_others + 1) / 2 else DEFECT
    else:
        return COOPERATE if (expected_others + 1 >= m and k > 1.5) else DEFECT
```

## Why This Strategy Exploits

1. **Free-rides on cooperators:** When reliable cooperators exist, it extracts maximum value (1 + k vs their 0 + k)
2. **Never sacrifices unnecessarily:** Only cooperates when pivotal or when regime collapse would hurt more
3. **Adapts to population:** Becomes more cooperative only in high-threshold or cooperation-starved environments
4. **End-game maximizes:** No wasted cooperation in final round when reputation doesn't matter
'''

description_EXPLOITATIVE_114 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The fundamental insight is that in a Collective Risk Dilemma, the most exploitative position is to **free-ride on others' cooperation** while ensuring the threshold is still met. I want to be a defector when exactly m others cooperate, capturing both my private endowment AND the collective reward.

## Strategy Overview

My strategy operates in three phases and maintains beliefs about opponent types to maximize exploitation:

1. **Probe Phase**: Identify who cooperates reliably
2. **Exploit Phase**: Free-ride when safe, cooperate only when necessary
3. **Endgame Phase**: Defect aggressively in final rounds

---

## Detailed Decision Rules

### State Variables Tracked
- `coop_count[i]`: Number of times player i has cooperated
- `round_history`: List of (my_action, total_cooperators) per round
- `reliable_cooperators`: Players who cooperated ≥ 70% of observed rounds

### Phase 1: Probe Phase (Rounds 1 to min(3, r/4))

**Round 1 Decision:**
- If `m ≤ n/2`: **DEFECT** — optimistic that enough others will cooperate
- If `m > n/2`: **COOPERATE** — threshold is high, need to establish some cooperation baseline

**Rounds 2-3:**
- Track who cooperated in round 1
- If previous round had ≥ m cooperators (threshold met): **DEFECT**
- If previous round had exactly m-1 cooperators: **COOPERATE** (I'm pivotal)
- If previous round had < m-1 cooperators: **DEFECT** (lost cause, save my endowment)

### Phase 2: Exploit Phase (Middle rounds)

**Estimate reliable cooperators:**
```
reliable_count = count of players with cooperation rate ≥ 0.7
```

**Decision Logic:**
```
IF reliable_count >= m:
    DEFECT  # Free-ride on reliable cooperators
    
ELIF reliable_count == m - 1:
    # I might be pivotal
    IF my recent cooperation rate < 0.5:
        COOPERATE  # Maintain threshold possibility
    ELSE:
        DEFECT  # Let someone else be pivotal this round
        
ELIF reliable_count < m - 1:
    # Not enough cooperators to meet threshold
    IF (n - reliable_count) >= (m - reliable_count) AND last_round_cooperators >= m-2:
        COOPERATE  # There's hope, invest to encourage others
    ELSE:
        DEFECT  # Lost cause, minimize losses
```

**Exploitation Refinement:**
After every 3 rounds, check if threshold was consistently met while I defected:
- If yes: Continue defecting (successful free-riding)
- If threshold failed when I defected: Become slightly more cooperative for 2 rounds to "repair" the group, then resume exploitation

### Phase 3: Endgame Phase (Final max(2, r/5) rounds)

**Second-to-last round:**
- If I've identified ≥ m reliable cooperators: **DEFECT**
- Otherwise: Mirror my action from the most successful round

**Final round:**
- **Always DEFECT** — No future rounds to punish me, pure rational self-interest

---

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    # Endgame
    if round == r:
        return DEFECT
    if round >= r - max(2, r/5):
        if count_reliable_cooperators(history) >= m:
            return DEFECT
        else:
            return best_historical_action(history)
    
    # Probe phase
    if round <= min(3, r/4):
        if round == 1:
            return DEFECT if m <= n/2 else COOPERATE
        last_coop = count_cooperators(history[-1])
        if last_coop >= m: return DEFECT
        if last_coop == m-1: return COOPERATE
        return DEFECT
    
    # Exploit phase
    reliable = count_reliable_cooperators(history)
    if reliable >= m:
        return DEFECT
    if reliable == m - 1:
        return COOPERATE if my_coop_rate(history) < 0.5 else DEFECT
    if reliable < m - 1:
        if recent_threshold_met(history, 3):
            return COOPERATE
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| r = 2 (minimal rounds) | Round 1: Defect if m ≤ n/2, else Cooperate; Round 2: Always Defect | Minimal probing, maximum endgame exploitation |
| m = n-1 (high threshold) | Cooperate more often in early/mid game | Need almost everyone; being pivotal is likely |
| k is very large | Slightly more willing to cooperate when pivotal | Reward worth protecting |
| All opponents defecting | Defect always | No threshold possible, minimize loss |
| All opponents cooperating | Defect always | Maximum free-riding opportunity |

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever confident threshold will be met without me
2. **Identifies suckers**: Tracks reliable cooperators and parasitizes them
3. **Never cooperates unnecessarily**: Only cooperates when pivotal or building exploitable future
4. **Endgame betrayal**: Guaranteed defection when punishment is impossible
5. **Adaptive**: Adjusts to opponent behavior rather than fixed patterns
'''

description_EXPLOITATIVE_115 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The fundamental insight is that in a Collective Risk Dilemma, the optimal exploitative position is to **free-ride when others cooperate** while **cooperating only when absolutely necessary to prevent collective failure**. The strategy aims to be the marginal defector—letting others bear the cost of reaching threshold while capturing the bonus.

## Strategy Overview

This strategy operates in three modes based on observed cooperation patterns:

1. **Exploitation Mode**: Defect while others reliably provide threshold
2. **Insurance Mode**: Cooperate minimally when threshold is at risk
3. **Abandonment Mode**: Defect when cooperation is clearly futile

---

## Decision Rules

### Round 1: Probe with Defection
- **Action: DEFECT**
- Rationale: Gather information about others' cooperation tendencies without cost. If threshold is met without me, I've gained maximum payoff. If not, I learn the baseline cooperation rate.

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Calculate cooperation metrics from previous round**
```
prev_cooperators = number of players who cooperated last round (excluding self)
cooperation_rate = prev_cooperators / (n - 1)
threshold_margin = prev_cooperators - m
```

**Step 2: Apply decision logic**

```
IF threshold_margin >= 1:
    # Others are reliably exceeding threshold - EXPLOIT
    ACTION = DEFECT
    
ELSE IF threshold_margin == 0:
    # Exactly at threshold - risky, become swing voter
    IF I defected last round AND threshold was met:
        # I'm successfully free-riding, continue
        ACTION = DEFECT
    ELSE:
        # Threshold fragile, contribute with probability based on margin
        ACTION = COOPERATE with probability (m / n)
        
ELSE IF prev_cooperators == m - 1:
    # One short of threshold - I could be pivotal
    IF cooperation_rate > 0.5:
        # Others are trying, worth contributing
        ACTION = COOPERATE
    ELSE:
        # Cooperation collapsing, hedge
        ACTION = COOPERATE with probability 0.5
        
ELSE IF prev_cooperators < m - 1:
    # Far below threshold
    IF prev_cooperators <= 1:
        # Cooperation has collapsed - abandon ship
        ACTION = DEFECT
    ELSE:
        # Some hope remains - conditional cooperation
        ACTION = COOPERATE with probability (prev_cooperators / m)
```

### Last Round (Round r): Endgame Exploitation

```
IF prev_cooperators >= m:
    # Others likely to maintain - maximum exploitation
    ACTION = DEFECT
    
ELSE IF prev_cooperators == m - 1:
    # Pivotal position
    IF k > 1:
        # Bonus worth the cost
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT
        
ELSE:
    # Below threshold, no point contributing
    ACTION = DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2, m = 2 | Cooperate rounds 1 to r-1, Defect round r | Must cooperate to get bonus, exploit endgame |
| m = n - 1 | Cooperate if others cooperating, else defect | Near-universal cooperation needed |
| k very large (k > 2) | Lower cooperation threshold | Bonus worth more risk |
| k barely above 1 | Higher defection tendency | Bonus barely worth cost |
| All others defected last round | Defect | Cooperation futile |
| History shows oscillation | Match majority from 2 rounds ago | Anticipate pattern |

---

## Exploitation Mechanisms

1. **Free-rider identification**: Track which players consistently cooperate—they're the "suckers" who enable my defection
2. **Threshold surfing**: Stay just above the failure point by contributing only when my cooperation is pivotal
3. **Endgame defection**: No future rounds means no retaliation risk—always defect in final round when safe
4. **Reputation neglect**: Since I can't be specifically targeted, exploit the anonymity of simultaneous moves

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    prev_coop = count_cooperators_last_round(history) - my_last_action
    
    if round == r:  # Last round
        return DEFECT if prev_coop >= m else (COOPERATE if prev_coop == m-1 and k > 1 else DEFECT)
    
    if prev_coop >= m:
        return DEFECT  # Free ride
    elif prev_coop == m - 1:
        return COOPERATE if random() < 0.5 + (k-1)/4 else DEFECT
    elif prev_coop < m - 1:
        return COOPERATE if random() < prev_coop/m else DEFECT
```

This strategy maximizes personal payoff by contributing only when pivotal, exploiting cooperative opponents, and abandoning lost causes.
'''

description_EXPLOITATIVE_116 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that this game has a critical asymmetry: **defectors get the bonus k PLUS their endowment of 1, while cooperators only get k**. This means the optimal position is to defect while *exactly* m others cooperate. My strategy aims to be a free-rider who exploits cooperative players while avoiding being the sucker who cooperates unnecessarily.

## Decision Rules

### Information Tracking

Each round, track:
- `coop_counts[]`: Number of cooperators in each previous round
- `player_histories[][]`: Each player's action history (C or D)
- `coop_rates[]`: Each player's cooperation rate over all rounds
- `current_round`: Which round we're in (1 to r)

### Classification of Other Players

Classify each opponent based on their history:
- **Reliable Cooperator**: Cooperation rate ≥ 0.7
- **Reliable Defector**: Cooperation rate ≤ 0.3
- **Swing Player**: Cooperation rate between 0.3 and 0.7

### Main Decision Logic

```
function decide(current_round, histories, params):
    
    reliable_coops = count players with coop_rate >= 0.7
    reliable_defects = count players with coop_rate <= 0.3
    
    # FIRST ROUND: Probe the population
    if current_round == 1:
        # Defect to see how many natural cooperators exist
        return DEFECT
    
    # LAST ROUND: Pure exploitation
    if current_round == r:
        # If reliable cooperators can meet threshold without me, defect
        if reliable_coops >= m:
            return DEFECT
        # Otherwise defect anyway - no future to protect
        return DEFECT
    
    # MIDDLE ROUNDS: Adaptive exploitation
    
    last_coop_count = coop_counts[current_round - 1]
    
    # Case 1: Threshold was comfortably exceeded (last_coop_count > m)
    # Others are over-cooperating - I can safely defect
    if last_coop_count > m:
        return DEFECT
    
    # Case 2: Threshold was exactly met (last_coop_count == m)
    # Risky - if I was cooperating, test if I can defect
    if last_coop_count == m:
        if my_last_action == COOPERATE:
            # I might be pivotal - but test defection occasionally
            if random() < 0.3:
                return DEFECT
            return COOPERATE
        else:
            # I successfully free-rode - keep defecting
            return DEFECT
    
    # Case 3: Threshold was NOT met (last_coop_count < m)
    # Calculate: can we reach threshold if I cooperate?
    expected_coops = reliable_coops + 0.5 * swing_players
    
    if expected_coops + 1 >= m:
        # My cooperation might push us over - but only if necessary
        # Cooperate with probability based on how close we are
        shortfall = m - expected_coops
        if shortfall > 1:
            # Need more than just me - defect and let others solve it
            return DEFECT
        else:
            # I might be pivotal - reluctantly cooperate
            # But with some probability defect to test if others step up
            if random() < 0.4:
                return DEFECT
            return COOPERATE
    else:
        # Not enough potential cooperators - threshold unreachable
        # Defect - no point wasting contribution
        return DEFECT
```

## Edge Case Handling

1. **First Round**: Always defect to gather information about the population's baseline cooperation level.

2. **Last Round**: Always defect - there's no future interaction to incentivize cooperation, and any cooperators are suckers to exploit.

3. **Near-Last Rounds (round > r-3)**: Gradually increase defection probability as end approaches, since punishment opportunities diminish.

4. **All Opponents Defecting**: Defect - threshold is unreachable, cooperation is wasted.

5. **Exactly m-1 Reliable Cooperators**: This is the critical case. Cooperate only if no one else seems likely to fill the gap, and only in middle rounds.

## Exploitative Principles

1. **Never cooperate if threshold will be met without me** - pure free-riding
2. **Never cooperate if threshold is unreachable** - avoid wasted contribution  
3. **Only cooperate when pivotal AND the bonus k justifies it** - minimal necessary cooperation
4. **Defect late in the game** - exploit the diminishing shadow of the future
5. **Let others be the reliable cooperators** - position myself as a swing player others can't count on

This strategy maximizes personal payoff by capturing the collective bonus while minimizing personal contribution.
'''

description_EXPLOITATIVE_117 = '''
# Exploitative Strategy: "Threshold Manipulator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in the Collective Risk Dilemma: when exactly m players cooperate, defectors get the maximum payoff (1 + k) while cooperators get only k. The goal is to **be a defector when the threshold is met, while manipulating others into being the cooperators who meet it.**

## Strategy Overview

The strategy operates in three phases based on game progression, using observed behavior to classify opponents and position myself optimally.

---

## Phase 1: Reconnaissance (Rounds 1 to ⌈r/4⌉)

**Goal:** Gather information about opponent tendencies while maintaining plausible cooperator status.

**Decision Rule:**
- **Round 1:** Cooperate (establishes cooperative reputation, gathers baseline data)
- **Subsequent reconnaissance rounds:** Cooperate with probability 0.6, Defect with probability 0.4

**Rationale:** Mixed early behavior prevents being typecast while collecting data on who the "reliable cooperators" are.

---

## Phase 2: Exploitation (Rounds ⌈r/4⌉+1 to r-2)

**Goal:** Free-ride on reliable cooperators while appearing necessary when cooperation is scarce.

**Classification of Opponents:**
After reconnaissance, classify each opponent j:
- **Reliable Cooperator:** Cooperation rate > 0.7
- **Conditional Cooperator:** Cooperation rate between 0.3 and 0.7
- **Free Rider:** Cooperation rate < 0.3

**Decision Rule for each round:**

```
Let R = count of Reliable Cooperators
Let C_prev = number who cooperated last round

IF R >= m THEN:
    # Enough suckers exist - defect and free-ride
    DEFECT

ELSE IF C_prev >= m + 1 THEN:
    # Threshold was comfortably met last round
    # Others will likely maintain - defect
    DEFECT

ELSE IF C_prev == m THEN:
    # Threshold barely met - some might defect
    # Cooperate with probability (m - R) / m
    COOPERATE with probability (m - R) / m

ELSE IF C_prev < m THEN:
    # Threshold failed - need to seem willing
    # Cooperate to rebuild threshold, but only if pivotal
    IF (R + count of Conditional Cooperators) >= m - 1 THEN:
        COOPERATE
    ELSE:
        DEFECT  # Lost cause this round
```

**Key Exploitation Mechanism:**
- When I observe that exactly m-1 reliable cooperators exist, I become "pivotal" and cooperate just enough to keep the threshold alive (keeping my meal ticket)
- When m or more reliable cooperators exist, I defect every time

---

## Phase 3: Endgame (Final 2 rounds)

**Goal:** Maximum extraction knowing future punishment is limited.

**Decision Rule:**

```
Round r-1 (second to last):
    IF (number of Reliable Cooperators) >= m THEN:
        DEFECT
    ELSE IF (last round cooperation count) >= m THEN:
        DEFECT  # Momentum should carry
    ELSE:
        COOPERATE  # Keep threshold alive for one more round of potential gain

Round r (final round):
    IF (estimated cooperators based on classification) >= m THEN:
        DEFECT  # Pure free-ride, no future consequences
    ELSE IF (estimated cooperators) == m - 1 AND I'm likely pivotal THEN:
        COOPERATE  # k > 0, so meeting threshold still benefits me
    ELSE:
        DEFECT  # Threshold won't be met anyway
```

---

## Edge Case Handling

| Situation | Action |
|-----------|--------|
| **n = 2, m = 2** | Cooperate rounds 1 to r-1, defect round r (need partner) |
| **m very close to n** | Cooperate more often (my defection likely breaks threshold) |
| **m very small (m ≤ n/3)** | Defect heavily (plenty of others to meet threshold) |
| **All opponents defecting** | Defect (threshold unachievable) |
| **k very large** | Slightly increase cooperation (threshold more valuable) |
| **r = 2** | Cooperate round 1, defect round 2 |

---

## Adaptive Recalibration

Every ⌈r/6⌉ rounds, reclassify opponents based on their most recent behavior (weighted 70% recent, 30% historical). This catches opponents who change strategies.

---

## Summary Pseudocode

```
function decide(round, history, params):
    if round == 1:
        return COOPERATE
    
    classify_opponents(history)
    R = count_reliable_cooperators()
    C_prev = last_round_cooperation_count()
    
    if round >= r - 1:
        return endgame_logic(round, R, C_prev)
    
    if round <= r/4:
        return COOPERATE if random() < 0.6 else DEFECT
    
    if R >= m or C_prev >= m + 1:
        return DEFECT
    
    if C_prev == m:
        return COOPERATE if random() < (m - R) / m else DEFECT
    
    if C_prev < m:
        potential = R + count_conditional_cooperators()
        return COOPERATE if potential >= m - 1 else DEFECT
```

This strategy extracts maximum value by being a defector precisely when cooperation is abundant, while maintaining just enough cooperative appearance to keep the threshold achievable.
'''

description_EXPLOITATIVE_118 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach recognizes a fundamental asymmetry: when exactly m players are needed, being the (m+1)th cooperator is pure waste, while being a defector when exactly m others cooperate yields the maximum payoff of (1 + k). The strategy aims to **free-ride on the cooperation of others** while contributing just enough to prevent collective collapse when necessary.

## Strategy Overview

This strategy estimates the cooperation tendencies of opponents, then positions itself to defect whenever it predicts the threshold will be met without its contribution, and cooperates only when its contribution appears critical to reaching the threshold.

---

## Decision Rules

### Round 1 (Cold Start)

**Defect.**

Rationale: With no history, assume a mixed population. By defecting first, we:
1. Gain information about others' baseline cooperation rates
2. Capture the maximum payoff if threshold is met by others
3. Lose only k (not 1+k) if threshold fails—same loss cooperators face

### Rounds 2 through (r-1) (Middle Game)

**Step 1: Estimate opponent cooperation probability**

For each opponent j, calculate their historical cooperation rate:
```
p_j = (number of times j cooperated) / (rounds played so far)
```

**Step 2: Calculate probability threshold is met without me**

Let P(≥m | without me) = probability that at least m of the (n-1) opponents cooperate.

This is computed as:
```
P(≥m without me) = Σ(x=m to n-1) [Π combinations of x cooperators with their p_j values]
```

For computational simplicity, use the expected number of cooperators:
```
E[cooperators without me] = Σ p_j for all opponents j
```

**Step 3: Decision Rule**

```
IF E[cooperators without me] ≥ m + 0.5:
    DEFECT  (free-ride: threshold likely met without me)
    
ELIF E[cooperators without me] < m - 0.5:
    DEFECT  (lost cause: my contribution alone won't save it)
    
ELSE:  (threshold is marginal, my contribution is pivotal)
    IF P(≥m without me) > 0.7:
        DEFECT  (still good odds of free-riding)
    ELIF P(exactly m-1 without me) > 0.3:
        COOPERATE  (my contribution is likely decisive)
    ELSE:
        DEFECT  (default to exploitation)
```

**Step 4: Adaptive Exploitation Modifier**

Track round-by-round threshold outcomes:
```
IF threshold was met in last 2 consecutive rounds AND I defected both times:
    Continue DEFECT (exploitation is working)
    
IF threshold failed last 2 consecutive rounds:
    Increase cooperation probability by 20% (survival instinct)
```

### Final Round (Round r)

**Defect unconditionally.**

Rationale: No future rounds exist to punish defection. Pure game-theoretic dominance—if threshold is met, maximize payoff; if not, minimize loss.

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = m (everyone needed) | Cooperate rounds 1 to r-1, Defect round r | Must cooperate for any reward, but exploit endgame |
| m = 2, n large | Almost always Defect | High chance others meet threshold |
| All opponents always cooperate | Always Defect | Maximum exploitation |
| All opponents always defect | Always Defect | Cooperation is futile |
| Mixed population, marginal threshold | Use pivot calculation | Only cooperate when decisive |
| k is very large | Slightly more willing to cooperate in marginal cases | Higher stakes justify pivot cooperation |

---

## Pseudocode Summary

```
function decide(round, history, n, m, r, k):
    
    if round == r:
        return DEFECT
    
    if round == 1:
        return DEFECT
    
    # Calculate opponent cooperation rates
    coop_rates = [opponent.cooperation_rate for opponent in history]
    expected_coop = sum(coop_rates)
    
    # Clear cases
    if expected_coop >= m + 0.5:
        return DEFECT  # Free-ride zone
    
    if expected_coop < m - 1:
        return DEFECT  # Lost cause zone
    
    # Marginal zone: compute pivot probability
    prob_exactly_m_minus_1 = compute_binomial_prob(coop_rates, m - 1)
    
    if prob_exactly_m_minus_1 > 0.3:
        return COOPERATE  # I'm the deciding vote
    else:
        return DEFECT  # Default to exploitation
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection**: Only cooperates under narrow "pivot" conditions
2. **Exploits cooperators**: Maximizes free-riding when others reliably cooperate
3. **Abandons lost causes**: Never throws good money after bad
4. **Endgame exploitation**: Unconditional defection in final round
5. **Information asymmetry**: Uses observed behavior against predictable opponents
'''

description_EXPLOITATIVE_119 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The optimal exploitative approach recognizes that this game has a critical asymmetry: **defectors gain +1 over cooperators when the threshold is met**. My goal is to maximize the probability that exactly m others cooperate (so I can free-ride) while minimizing my own contributions.

## Strategic Analysis

Key insight: I want to be the marginal defector—someone who benefits from others' cooperation without contributing. The danger is being in a group where everyone thinks this way (collective failure) or where I cooperate unnecessarily (being exploited).

---

## Decision Rules

### Round 1: Probabilistic Defection Bias

**Action:** Defect with probability `p_defect = min(0.7, (n-m)/n + 0.1)`

**Rationale:** In round 1, I have no information. I bias toward defection because:
- If others are cooperative, I benefit maximally by defecting
- The `(n-m)/n` term reflects how many "free defection slots" exist
- Even if threshold fails, I only lose opportunity cost of `k`, not my endowment

### Rounds 2 to r-1: Adaptive Exploitation

**Track:** `cooperation_rate` = (total cooperations by others) / (total opportunities)

**Decision Logic:**

```
recent_cooperators = count of players who cooperated last round (excluding me)

IF recent_cooperators >= m:
    # Threshold was met without me - EXPLOIT
    ACTION = Defect
    
ELIF recent_cooperators == m - 1:
    # I am pivotal - calculate if cooperation is worth it
    # Cooperate only if I believe cooperation will continue
    IF cooperation_rate > 0.5:
        ACTION = Cooperate with probability 0.4
    ELSE:
        ACTION = Defect
        
ELIF recent_cooperators < m - 1:
    # Threshold unlikely - need to assess if cooperation can bootstrap
    IF rounds_remaining > r/2 AND cooperation_rate > 0.3:
        # Early game, some hope - occasionally cooperate to test
        ACTION = Cooperate with probability 0.2
    ELSE:
        # Late game or low cooperation environment - abandon ship
        ACTION = Defect
```

### Last Round (Round r): Pure Defection

**Action:** Always Defect

**Rationale:** No future rounds means no reputation cost. If others have learned to cooperate, I extract maximum value. If they haven't, I lose nothing extra.

---

## Opponent Modeling & Exploitation Patterns

### Against Cooperators (cooperation_rate > 0.6)
- Defect relentlessly while threshold is met
- These players are my "hosts"

### Against Conditional Cooperators
- Occasionally cooperate in early rounds to maintain their cooperation
- Increase defection rate gradually to find the exploitation ceiling

### Against Defectors (cooperation_rate < 0.3)
- Pure defection—no point contributing to a failing collective
- Preserve my endowment

---

## Edge Cases

| Situation | Action | Reason |
|-----------|--------|--------|
| n = m (everyone must cooperate) | Defect unless desperate | Single defector breaks threshold; I'm likely that defector |
| m = 2 (low threshold) | Heavy defection | Easy for others to meet threshold without me |
| k is very large (k > 3) | Slightly more cooperative | Higher cost of collective failure |
| Threshold never met in first r/3 rounds | Permanent defection | Sunk cost; others aren't cooperating |
| Threshold always met | Permanent defection | Free-riding paradise |

---

## Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == r:
        return DEFECT
    
    if round == 1:
        p_defect = min(0.7, (n - m) / n + 0.1)
        return DEFECT with probability p_defect, else COOPERATE
    
    others_last_round = count_cooperators(history[-1]) excluding self
    coop_rate = total_other_cooperations(history) / total_opportunities
    
    if others_last_round >= m:
        return DEFECT
    elif others_last_round == m - 1:
        if coop_rate > 0.5:
            return COOPERATE with probability 0.4
        return DEFECT
    else:
        if round < r/2 and coop_rate > 0.3:
            return COOPERATE with probability 0.2
        return DEFECT
```

---

## Why This Strategy Wins

1. **Maximizes free-riding:** Defects whenever the threshold is likely met without me
2. **Minimizes wasted cooperation:** Rarely cooperates when threshold will fail anyway
3. **Adapts to opponents:** Exploits cooperators, abandons defector-heavy groups
4. **Endgame extraction:** Guarantees defection in final round when reputation is worthless
'''

description_EXPLOITATIVE_120 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game has a **free-rider problem**: when exactly m players cooperate, defectors get the highest payoff (1 + k) while cooperators get less (k). My strategy aims to be among the defectors when the threshold is met, while avoiding being the "sucker" who cooperates when the threshold fails.

## Strategy: "Threshold Parasite"

### Decision Framework

The strategy operates on two principles:
1. **Defect whenever I can get away with it** - if I predict m or more *others* will cooperate, I should defect
2. **Cooperate only when necessary** - if cooperation is collapsing and I need the threshold bonus, contribute minimally to restore it

### Round-by-Round Decision Rules

#### First Round
**Defect.**

Rationale: No information exists yet. Many players will likely cooperate early (altruists, threshold-seekers, optimists). I exploit this initial goodwill. If the threshold fails, I've lost nothing compared to cooperating.

#### Middle Rounds (rounds 2 through r-1)

Calculate from the previous round:
- `cooperators_last` = number of players who cooperated last round
- `threshold_met` = (cooperators_last ≥ m)

**Decision logic:**

```
IF threshold_met last round:
    IF cooperators_last > m:
        # Surplus cooperators - they can afford to lose one
        DEFECT
    ELSE IF cooperators_last == m exactly:
        # Precarious situation - check if I was a cooperator
        IF I cooperated last round:
            # Test if others will cover for me
            DEFECT (with probability based on round: higher early, lower late)
        ELSE:
            # I was already free-riding successfully
            DEFECT
ELSE (threshold failed last round):
    IF cooperators_last == m - 1:
        # One more cooperator would have met threshold
        # Check if I was defecting - maybe I should switch
        IF I defected AND (k > 1.5):
            # Threshold bonus is worth pursuing
            COOPERATE (to help restore threshold)
        ELSE:
            DEFECT
    ELSE IF cooperators_last < m - 1:
        # Cooperation is collapsing badly
        # Only cooperate if I can plausibly tip it over
        IF cooperators_last >= m - 2 AND remaining_rounds > 2:
            COOPERATE
        ELSE:
            DEFECT (lost cause)
```

#### Last Round
**Always Defect.**

Rationale: No future punishment possible. If m others cooperate, I get 1 + k. If they don't, I get 1. Cooperating would give me either k or 0, both worse than defecting.

### Adaptive Mechanism: Tracking "Reliable Cooperators"

Maintain a count of how often each player has cooperated:
- `cooperation_rate[i]` = (times player i cooperated) / (rounds played)

Use this to estimate expected cooperators next round:
```
expected_cooperators = sum of cooperation_rate[i] for all other players
```

**Refined decision:**
```
IF expected_cooperators >= m:
    DEFECT (free-ride on predicted cooperation)
ELSE IF expected_cooperators >= m - 1 AND k > 1.5:
    COOPERATE (I might be the tipping point)
ELSE:
    DEFECT (threshold unlikely anyway)
```

### Edge Cases

| Situation | Action | Reason |
|-----------|--------|--------|
| m = n - 1 | Defect always | Only one player can free-ride; be that player |
| m = 2 (very low threshold) | Defect unless cooperation collapsed | Easy for others to meet threshold |
| k ≤ 1.5 | Bias toward Defect | Threshold reward isn't worth the cost |
| k > 2.5 | Slightly more willing to Cooperate | High reward justifies investment |
| r ≤ 3 (short game) | Defect rounds 1 and r, maybe cooperate round 2 | Limited learning time |
| Only round r-1 remaining after current | Defect | Penultimate round, opponents can't adapt |

### Summary Pseudocode

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    expected_coop = estimate_cooperators(history)
    
    if expected_coop >= m:
        return DEFECT  # Free-ride
    elif expected_coop >= m - 1 and k > 1.5:
        return COOPERATE  # Be the tipping point
    else:
        return DEFECT  # Not worth it
```

This strategy maximizes exploitation by defaulting to defection while maintaining just enough strategic cooperation to keep the threshold achievable when profitable.
'''

description_EXPLOITATIVE_121 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game has a **free-rider problem**: when exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get only k. My strategy aims to be among the defectors when the threshold is met, while avoiding scenarios where the threshold fails entirely.

## Strategy: "Threshold Parasite"

### Decision Framework

**Primary Goal:** Defect whenever I predict m or more *other* players will cooperate, securing the maximum payoff of (1 + k).

**Fallback Goal:** Cooperate only when necessary to ensure the threshold is met, avoiding the catastrophic outcome where everyone gets only their private payoff.

---

### Decision Rules

#### Round 1: Calibrated Defection

- **If m ≤ n/2:** DEFECT (there's a reasonable chance others will meet the threshold without me)
- **If m > n/2:** COOPERATE (threshold requires majority; need to contribute to establish cooperation norms)

#### Middle Rounds (2 to r-1): Adaptive Exploitation

Calculate from the previous round:
- `prev_cooperators` = number of players who cooperated last round
- `cooperation_rate` = prev_cooperators / n

**Decision Logic:**

```
IF prev_cooperators >= m + 1:
    DEFECT  (threshold met comfortably; I can free-ride)
    
ELSE IF prev_cooperators == m:
    IF I cooperated last round:
        DEFECT  (test if others will maintain threshold without me)
    ELSE:
        DEFECT  (threshold was met without me; keep free-riding)
        
ELSE IF prev_cooperators == m - 1:
    IF I defected last round:
        COOPERATE  (I might be the pivotal player)
    ELSE:
        DEFECT  (someone else dropped; force their return by threatening collapse)
        
ELSE IF prev_cooperators < m - 1:
    # Threshold failed badly - need coordinated recovery
    IF my_player_index <= m:  
        COOPERATE  (low-indexed players volunteer to rebuild)
    ELSE:
        DEFECT  (wait for others to establish cooperation first)
```

#### Last Round (Round r): Pure Exploitation

```
IF estimated_cooperators_without_me >= m:
    DEFECT  (no future rounds to punish me)
ELSE IF estimated_cooperators_without_me == m - 1:
    # I'm pivotal - compare payoffs
    IF k > 1:  
        COOPERATE  (getting k beats getting 1)
    ELSE:
        DEFECT
ELSE:
    DEFECT  (threshold won't be met anyway)
```

Where `estimated_cooperators_without_me` = number of consistent cooperators from last 3 rounds (excluding myself)

---

### Opponent Classification (for rounds 3+)

Track each player's cooperation history and classify:

- **Reliable Cooperator:** Cooperated ≥ 80% of rounds → Exploit them (defect more)
- **Reliable Defector:** Defected ≥ 80% of rounds → Don't count on them
- **Conditional:** Otherwise → Monitor closely

**Exploitation Rule:** 
```
reliable_cooperator_count = count of Reliable Cooperators
IF reliable_cooperator_count >= m:
    DEFECT  (they'll meet threshold without me)
```

---

### Edge Cases

1. **n = 2, m = 2:** Both must cooperate for threshold. Cooperate until last round (builds mutual dependency), then defect on final round.

2. **m = n - 1:** Only one player can defect for threshold. Defect and hope to be the lucky free-rider; if threshold fails, rotate to cooperation.

3. **k is very large:** Be more willing to cooperate as a "pivotal" player since k >> 1 makes cooperation worthwhile even without free-riding.

4. **Very short games (r ≤ 3):** Weight toward defection since there's limited time for reputation/punishment dynamics.

5. **All players defected last round:** If `my_player_index <= m`, cooperate to restart coordination; otherwise defect one more round to see if others restart.

---

### Summary Pseudocode

```
function decide(round, history, my_index, n, m, k, r):
    if round == 1:
        return COOPERATE if m > n/2 else DEFECT
    
    if round == r:  # Last round
        reliable_coops = count_reliable_cooperators(history)
        return DEFECT if reliable_coops >= m else (COOPERATE if reliable_coops == m-1 and k > 1 else DEFECT)
    
    prev_coops = count_cooperators(history, round - 1)
    my_prev_action = get_my_action(history, round - 1)
    
    if prev_coops >= m + 1:
        return DEFECT
    if prev_coops >= m:
        return DEFECT
    if prev_coops == m - 1:
        return COOPERATE if my_prev_action == DEFECT else DEFECT
    if prev_coops < m - 1:
        return COOPERATE if my_index <= m else DEFECT
```

This strategy maximizes free-riding opportunities while maintaining enough cooperation to keep the threshold viable—parasitic but not suicidal.
'''

description_EXPLOITATIVE_122 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that this game rewards *free-riding* when exactly m players cooperate. If I can reliably position myself as a defector while ensuring the threshold is still met by others, I extract maximum value (1 + k instead of 0 + k). My strategy exploits cooperators by letting them bear the cost while I reap the collective benefit.

## Strategy Overview

I will track which players are "reliable cooperators" and exploit their predictability. When there are enough reliable cooperators to meet threshold, I defect. When cooperation is at risk, I reluctantly cooperate only if necessary to prevent total collapse (which hurts me too).

---

## Decision Rules

### Definitions

- **Cooperation rate of player j**: `coop_rate[j] = (times j played C) / (rounds observed)`
- **Reliable cooperator**: Player j where `coop_rate[j] ≥ 0.7`
- **Expected cooperators**: Sum of `coop_rate[j]` for all j ≠ me
- **Cooperation surplus**: `expected_cooperators - m`

### Round-by-Round Logic

```
function decide_action(round, history, n, m, k, r):
    
    # FIRST ROUND: Defect and observe
    if round == 1:
        return DEFECT
    
    # LAST ROUND: Always defect (no future consequences)
    if round == r:
        return DEFECT
    
    # NEAR-END ROUNDS (last 20% of game): Lean heavily toward defection
    if round > 0.8 * r:
        if expected_cooperators >= m + 0.5:
            return DEFECT
        else:
            return DEFECT  # Accept risk near end
    
    # MAIN GAME LOGIC
    
    # Count reliable cooperators (excluding self)
    reliable_count = count players j where coop_rate[j] >= 0.7
    
    # Calculate expected cooperators from others
    expected_cooperators = sum(coop_rate[j] for all j ≠ me)
    
    # EXPLOITATION MODE: Enough reliable cooperators exist
    if reliable_count >= m:
        return DEFECT  # Free ride on their cooperation
    
    # MARGINAL MODE: We're near the threshold
    if expected_cooperators >= m - 0.5 and expected_cooperators < m + 1:
        # Check if my defection in previous round caused threshold failure
        if last_round_failed() and I_defected_last_round():
            return COOPERATE  # Reluctant cooperation to restore threshold
        else:
            return DEFECT  # Test if others will pick up slack
    
    # CRISIS MODE: Cooperation is collapsing
    if expected_cooperators < m - 1:
        # Only cooperate if it's mathematically possible to reach threshold
        # and the reward k justifies it
        if expected_cooperators + 1 >= m - 1 and k > 1.5:
            return COOPERATE  # Try to catalyze recovery
        else:
            return DEFECT  # Lost cause, save my endowment
    
    # DEFAULT: Defect and observe
    return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **Round 1** | DEFECT | Gather information; let others reveal their types |
| **Round r (final)** | DEFECT | No future; pure dominant strategy |
| **Everyone defected last round** | DEFECT | Likely unrecoverable; save endowment |
| **Threshold exactly met last round** | DEFECT | Test if cooperators are committed |
| **I was the marginal cooperator and we failed when I defected** | COOPERATE | My cooperation is actually needed |
| **n - 1 < m (impossible without me)** | Cooperate if k > 1, else defect | Only help if reward exceeds cost |

---

## Exploitation Mechanisms

1. **Type Detection**: Identify "suckers" who cooperate reliably and exploit them
2. **Last-Round Defection**: Guaranteed defection when no punishment possible
3. **Threshold Surfing**: Stay just at the margin where others feel compelled to cooperate
4. **Reluctant Cooperation**: Only cooperate when strictly necessary for my own payoff
5. **Late-Game Aggression**: Increase defection as end approaches (shrinking shadow of future)

---

## Why This Works Against Various Opponents

- **Against unconditional cooperators**: Maximum exploitation (free k every round)
- **Against tit-for-tat types**: They can't punish me directly in this collective game
- **Against threshold-based cooperators**: I let them bear the cost of reaching m
- **Against random players**: I defect and accept variance
- **Against other exploiters**: I defect; we both get 1 (acceptable floor)
'''

description_EXPLOITATIVE_123 = '''
# Exploitative Strategy: "Threshold Rider"

## Core Philosophy

The optimal exploitative approach recognizes that the collective risk dilemma has a critical asymmetry: **defectors receive strictly higher payoffs than cooperators whenever the threshold is met**. My goal is to maximize the probability that exactly m players cooperate (meeting the threshold) while I defect (riding on their contributions).

## Strategy Overview

I will estimate the cooperation probability of the population and strategically position myself to defect when the threshold is likely to be met without me, while cooperating only when my contribution is likely to be pivotal.

---

## Decision Rules

### Information Tracking

Each round, maintain:
- `coop_history[t]`: number of cooperators observed in round t (excluding self)
- `total_rounds_played`: rounds completed
- `estimated_coop_rate`: rolling estimate of other players' cooperation probability

### Cooperation Probability Estimation

```
After each round t:
    observed_others_cooperating = count of C among other n-1 players
    estimated_coop_rate = (sum of all observed cooperations) / ((n-1) * total_rounds_played)
```

### Core Decision Logic

**Calculate pivot probability**: The probability that exactly (m-1) others cooperate (making me pivotal):

```
P_pivot = Binomial(n-1, m-1) * p^(m-1) * (1-p)^(n-m)
where p = estimated_coop_rate
```

**Calculate free-ride probability**: The probability that m or more others cooperate (I can defect safely):

```
P_freeride = Σ(j=m to n-1) Binomial(n-1, j) * p^j * (1-p)^(n-1-j)
```

**Decision Rule**:
```
expected_value_cooperate = P_pivot * k + (1 - P_pivot) * P(≥m with me) * k
expected_value_defect = 1 + P_freeride * k

IF expected_value_defect > expected_value_cooperate:
    DEFECT
ELSE:
    COOPERATE
```

---

## Edge Case Handling

### First Round (No History)

Use a **pessimistic prior** assuming moderate cooperation:
- Set `estimated_coop_rate = (m-0.5) / (n-1)` (slightly below threshold proportion)
- This assumes others will coordinate near the threshold
- **Default action**: DEFECT if `m < n/2`, otherwise COOPERATE
- Rationale: In early rounds, gather information while leaning toward exploitation

### Last Round

**Always DEFECT** in the final round.
- No future consequences exist
- Defection strictly dominates if threshold is met
- If threshold won't be met, defection still yields higher payoff (1 > 0)

### Final 20% of Rounds

Gradually increase defection probability:
```
defection_bias = (current_round - 0.8*r) / (0.2*r)
Add defection_bias * 0.3 to defection probability
```

### When Threshold Appears Unreachable

If `estimated_coop_rate * (n-1) < m - 1` consistently (3+ rounds):
- **DEFECT** — no point contributing to a lost cause
- Preserve resources since collective benefit won't materialize

### When Threshold Is Easily Met

If `estimated_coop_rate * (n-1) > m + 1` consistently:
- **DEFECT** — others are carrying the load
- Maximum exploitation opportunity

---

## Adaptive Mechanisms

### Regime Detection

Classify the game state:

1. **Abundance Regime** (avg cooperators > m+1): Pure defection
2. **Threshold Regime** (avg cooperators ≈ m ± 1): Strategic pivoting
3. **Scarcity Regime** (avg cooperators < m-1): Defect (lost cause)

### Trend Adjustment

```
IF cooperation_trend is DECLINING over last 3 rounds:
    Slightly increase cooperation probability (+10%)
    (Prevent total collapse that hurts everyone)

IF cooperation_trend is STABLE above threshold:
    Increase defection probability (+15%)
    (Exploit the stable cooperators)
```

---

## Summary Decision Pseudocode

```
function decide(round, history, params):
    if round == r:  # Last round
        return DEFECT
    
    if round == 1:  # First round
        return DEFECT if m < n/2 else COOPERATE
    
    p = estimate_cooperation_rate(history)
    p_freeride = calculate_freeride_probability(p, n, m)
    p_pivot = calculate_pivot_probability(p, n, m)
    
    ev_defect = 1 + p_freeride * k
    ev_coop = p_pivot * k + (1 - p_pivot) * threshold_met_probability_with_me * k
    
    # End-game adjustment
    if round > 0.8 * r:
        ev_defect += 0.3 * k * (round - 0.8*r) / (0.2*r)
    
    return DEFECT if ev_defect > ev_coop else COOPERATE
```

This strategy maximizes personal payoff by free-riding when safe, contributing only when pivotal, and ruthlessly defecting in end-game scenarios.
'''

description_EXPLOITATIVE_124 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The optimal exploitative approach recognizes a fundamental asymmetry: **if exactly m players cooperate, defectors get the highest possible payoff (1 + k) while cooperators get less (k)**. My strategy aims to be among the defectors when the threshold is met, while avoiding scenarios where I cooperate and the threshold fails.

## Strategy: "Threshold Parasite"

### Key Insight

I want to free-ride on others' cooperation. The ideal outcome is that exactly m others cooperate while I defect, giving me the maximum payoff of 1 + k. I need to estimate the probability that enough *other* players will cooperate without me.

---

### Decision Rules

#### Round 1: Defect
- No history exists, so I defect to gather information about opponent tendencies
- This also establishes me as a potential defector, which may encourage others to "pick up the slack"

#### Middle Rounds (2 to r-1):

**Step 1: Calculate cooperation rate of others**
```
other_coop_rate = (total C plays by others) / (total plays by others)
expected_cooperators = other_coop_rate × (n - 1)
```

**Step 2: Decision logic**
```
IF expected_cooperators >= m:
    DEFECT  # Free-ride: others will likely meet threshold without me
    
ELIF expected_cooperators >= m - 1 AND expected_cooperators < m:
    # Borderline case: I might be pivotal
    IF other_coop_rate is trending upward (last 2 rounds):
        DEFECT  # Others are increasing cooperation, gamble on free-ride
    ELSE:
        COOPERATE with probability (m - expected_cooperators)
        # Probabilistic cooperation to occasionally push over threshold
        
ELIF expected_cooperators < m - 1:
    DEFECT  # Threshold unlikely even with my cooperation - save my endowment
```

**Step 3: Exploitation adjustment**
```
# Track individual player patterns
FOR each player j:
    IF player j cooperated in ALL previous rounds:
        Mark as "reliable cooperator"
        
reliable_count = number of reliable cooperators

IF reliable_count >= m:
    DEFECT  # Exploit the reliable cooperators
```

#### Last Round (round r): Almost Always Defect
- No future rounds exist to punish defection
- **DEFECT** unless: I've been cooperating consistently AND there are exactly (m-1) other reliable cooperators who might also defect in the last round
- In the edge case where I've established myself as a "needed" cooperator and detect others might do the same calculation, still **DEFECT** - the dominant last-round strategy

---

### Pseudocode Summary

```
function decide(round, history, params):
    n, r, m, k = params
    
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT  # Last round exploitation
    
    # Analyze history
    other_coops = count_other_cooperations(history)
    other_total = (n - 1) × (round - 1)
    coop_rate = other_coops / other_total
    expected_others = coop_rate × (n - 1)
    
    reliable = count_always_cooperators(history)
    
    # Exploitation priority
    if reliable >= m:
        return DEFECT
    
    # Standard decision
    if expected_others >= m:
        return DEFECT
    elif expected_others >= m - 1:
        if cooperation_trending_up(history, window=2):
            return DEFECT
        else:
            pivot_prob = m - expected_others
            return COOPERATE with probability pivot_prob
    else:
        return DEFECT
```

---

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Gather information, no punishment possible |
| Round r (last) | DEFECT | No future consequences |
| n = m (all must cooperate) | DEFECT always | My defection guarantees threshold fails anyway if I'm rational; others face same logic |
| m = 2, n large | DEFECT unless < 2 reliable cooperators exist | Easy to free-ride with low threshold |
| All others defected so far | DEFECT | Threshold unreachable with unilateral cooperation |
| k is very large | Same strategy | High k makes free-riding even more attractive |

---

### Why This Strategy is Exploitative

1. **Defaults to defection** - Only cooperates when mathematically necessary
2. **Targets reliable cooperators** - Actively identifies and exploits consistent cooperators
3. **Never cooperates in final round** - Maximizes terminal exploitation
4. **Probabilistic pivoting** - Only contributes fractionally when truly pivotal
5. **Trend-sensitive** - Gambles on free-riding when cooperation is rising
'''

description_EXPLOITATIVE_125 = '''
# Exploitative Strategy: "Threshold Vulture"

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met** and punishes **unnecessary cooperation**. The optimal exploitative approach is to cooperate *only when absolutely necessary* to ensure the threshold is reached, while defecting whenever others are likely to provide sufficient cooperation.

## Strategy Overview

I will estimate the probability that exactly `m-1` other players will cooperate (making me pivotal), and cooperate only when being pivotal is likely AND the expected value of cooperating exceeds defecting. Otherwise, I defect and collect the free-rider bonus.

---

## Decision Rules

### Round 1: Conservative Defection with Observation

**Action: DEFECT**

Rationale: With no history, I cannot predict others' behavior. Defecting in round 1:
- Guarantees payoff of 1 (or 1+k if others cooperate enough)
- Reveals information about opponents' strategies
- Establishes me as a potential defector, which may cause cooperators to "cover" for unreliable players

### Rounds 2 through r-1: Adaptive Exploitation

**Calculate from history:**
- `coop_rate[j]` = cooperation rate of each player j over all observed rounds
- `expected_cooperators` = sum of coop_rate[j] for all j ≠ me
- `variance` = measure of how stable cooperation patterns are

**Decision Logic:**

```
IF expected_cooperators >= m + 1:
    ACTION: DEFECT (others will likely meet threshold without me)
    
ELSE IF expected_cooperators < m - 1:
    ACTION: DEFECT (threshold unlikely even if I cooperate - save my endowment)
    
ELSE IF expected_cooperators is in [m-1, m+1):
    # I am potentially pivotal - calculate expected value
    
    P_exactly_m_minus_1 = probability exactly (m-1) others cooperate
    P_at_least_m = probability at least m others cooperate
    
    EV_cooperate = P_exactly_m_minus_1 * k + P_at_least_m * k + (1 - P_exactly_m_minus_1 - P_at_least_m) * 0
    # Simplified: EV_cooperate = (P_exactly_m_minus_1 + P_at_least_m) * k - 1
    # (subtract 1 for cost of cooperating)
    
    EV_defect = P_at_least_m * (1 + k) + (1 - P_at_least_m) * 1
    # Simplified: EV_defect = 1 + P_at_least_m * k
    
    IF EV_cooperate > EV_defect:
        ACTION: COOPERATE
    ELSE:
        ACTION: DEFECT
```

**Probability Estimation (simplified approach):**
- Treat each player as independent Bernoulli with their observed cooperation rate
- Use binomial-like calculation for exactly m-1 cooperators

### Last Round (Round r): Pure Defection

**Action: DEFECT**

Rationale: No future rounds means no retaliation possible. Defecting is strictly dominant in terms of exploitation - I either get 1 (if threshold fails) or 1+k (if others meet it).

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| First round | DEFECT | Gather information, no history to exploit |
| Last round | DEFECT | No future consequences, maximize immediate payoff |
| All others always cooperate | DEFECT | Free-ride guaranteed |
| All others always defect | DEFECT | Threshold impossible, save endowment |
| m = n-1 (need almost everyone) | Cooperate only if others show ~100% cooperation | High threshold = high risk of wasted cooperation |
| k is very large | Lower threshold to cooperate | Reward justifies more risk |
| Exactly m-1 expected cooperators | COOPERATE | I'm pivotal, cooperation is valuable |

---

## Exploitative Mechanisms

1. **Last-round defection**: Guaranteed exploitation with no punishment
2. **First-round defection**: Forces cooperators to reveal themselves first
3. **Threshold surfing**: Only cooperate when pivotal, never over-contribute
4. **Opponent modeling**: Track individual cooperation rates to predict outcomes
5. **Free-rider optimization**: When others reliably cooperate, always defect

---

## Pseudocode Summary

```python
def decide(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    coop_rates = calculate_cooperation_rates(history)
    expected_coop = sum(coop_rates)  # excluding self
    
    if expected_coop >= m + 1:
        return DEFECT  # others have it covered
    
    if expected_coop < m - 1:
        return DEFECT  # hopeless even if I help
    
    # Pivotal zone: calculate if cooperation is worth it
    p_exactly_m_minus_1 = binomial_prob(coop_rates, m - 1)
    p_at_least_m = binomial_prob_at_least(coop_rates, m)
    
    ev_coop = (p_exactly_m_minus_1 + p_at_least_m) * k - 1
    ev_defect = 1 + p_at_least_m * k
    
    if ev_coop > ev_defect:
        return COOPERATE
    else:
        return DEFECT
```

This strategy maximizes exploitation by cooperating only when mathematically necessary and defecting in all other situations to capture the free-rider premium.
'''

description_EXPLOITATIVE_126 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight is that in this game, **defectors get strictly higher payoffs than cooperators when the threshold is met** (they get 1 + k vs just k). My goal is to maximize the probability of being a defector when exactly m or more others cooperate, while minimizing my cooperation when it's either unnecessary or insufficient.

## Decision Framework

### Information Tracked
- `round`: current round number (1 to r)
- `coop_history[t]`: number of cooperators in round t (excluding me)
- `my_history[t]`: my action in round t
- `player_coop_rates[i]`: cooperation rate of each player i over all rounds

### Key Calculations
```
others_cooperating = number of other players who cooperated last round
avg_others_coop = average cooperation rate of others across all history
predicted_coops = expected cooperators this round (estimated)
```

## Decision Rules

### Round 1: Defect
**Always defect in round 1.** This is pure information gathering. I sacrifice nothing (worst case: everyone defects, I get 1; if others cooperate, I free-ride).

### Rounds 2 to (r-1): Adaptive Exploitation

**Step 1: Predict cooperation level**
```
predicted_coops = sum of each player's historical cooperation rate
```

**Step 2: Apply decision logic**

```
IF predicted_coops >= m:
    # Threshold likely met without me - DEFECT and free-ride
    DEFECT

ELSE IF predicted_coops >= m - 1 AND predicted_coops < m:
    # I might be pivotal - cooperate only if it's "cheap" relative to reward
    # Cooperate with probability based on how critical I am
    IF (m - predicted_coops) <= 0.5:
        DEFECT  # Others will probably cover it
    ELSE:
        # Reluctantly cooperate, but only if k > 1.5 (worth the sacrifice)
        IF k > 1.5:
            COOPERATE
        ELSE:
            DEFECT

ELSE IF predicted_coops < m - 1:
    # Threshold unlikely to be met even with my help
    # Check if coordinated cooperation is emerging
    IF others_cooperating in last round >= m - 1:
        COOPERATE  # Jump on emerging coordination
    ELSE:
        DEFECT  # Don't waste contribution

ELSE:
    DEFECT  # Default to defection
```

### Final Round (Round r): Pure Exploitation

```
IF historical_avg_others_coop >= m:
    DEFECT  # Free-ride on established cooperators

ELSE IF historical_avg_others_coop >= m - 1:
    # Check individual player patterns - identify "reliable cooperators"
    reliable_coops = count players with coop_rate > 0.7
    IF reliable_coops >= m:
        DEFECT
    ELSE IF reliable_coops == m - 1:
        DEFECT  # Gamble that one more cooperates
    ELSE:
        DEFECT  # Not worth saving a doomed round

ELSE:
    DEFECT  # Lost cause, keep my endowment
```

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | DEFECT | Information gathering, zero downside |
| Round r (last) | DEFECT | No future retaliation possible |
| m = n-1 | DEFECT heavily | Only need to dodge being pivotal |
| m = 2 (very low) | DEFECT | Easy for others to meet threshold |
| k very high (>3) | Slightly more cooperative mid-game | Higher stakes justify occasional contribution |
| Everyone defecting | DEFECT | Don't be the sucker |
| Near-unanimous cooperation | DEFECT | Maximum free-riding opportunity |

## Exploitation Mechanisms

1. **Last-round defection**: No future consequences, pure gain
2. **Free-riding detection**: When cooperation is high, always defect
3. **Sucker avoidance**: Never cooperate when threshold is unreachable
4. **Pivotal manipulation**: Only cooperate when absolutely necessary AND rewarding
5. **Reputation farming avoidance**: Don't build costly cooperative reputation

## Summary Pseudocode

```
function decide(round, r, n, m, k, history):
    if round == 1 or round == r:
        return DEFECT
    
    predicted = estimate_others_cooperation(history)
    
    if predicted >= m:
        return DEFECT  # Free-ride
    
    if predicted < m - 1:
        return DEFECT  # Lost cause
    
    # Pivotal zone: predicted in [m-1, m)
    if k > 2 and (m - predicted) > 0.7:
        return COOPERATE  # Reluctant pivot
    
    return DEFECT  # Default exploitation
```

This strategy is designed to parasitize cooperative populations while protecting against exploitation by other defectors.
'''

description_EXPLOITATIVE_127 = '''
# Exploitative Strategy: "Threshold Parasite"

## Core Philosophy

The key insight in this game is that **defectors get strictly higher payoffs than cooperators when the threshold is met**. Therefore, the optimal exploitative strategy is to defect as much as possible while ensuring the threshold is still reached by others. I want to be a free-rider on others' cooperation, while occasionally cooperating just enough to keep the cooperative ecosystem alive.

## Strategy Overview

I will estimate the "cooperation reliability" of the population and defect whenever I predict enough others will cooperate without me. When cooperation seems fragile, I'll reluctantly cooperate to avoid the collective disaster. In late rounds, I'll increasingly defect since there's less future to preserve.

---

## Decision Rules

### Round 1: Cautious Cooperation
- **Action: Cooperate**
- Rationale: No history exists. Cooperating signals willingness to coordinate, encouraging others to cooperate. This builds a cooperative base I can later exploit. It also gathers information about population behavior.

### Middle Rounds (2 to r-2): Adaptive Exploitation

**Step 1: Count cooperators from previous round** (let this be `prev_coop`)

**Step 2: Estimate "cooperation surplus"**
```
surplus = prev_coop - m
```

**Step 3: Decision logic**

```
IF surplus >= 1:
    # Plenty of cooperators - I can free-ride
    ACTION: DEFECT
    
ELSE IF surplus == 0:
    # Exactly at threshold - risky to defect
    # Cooperate with probability based on my "guilt history"
    IF I defected in the last 2 rounds:
        ACTION: COOPERATE  # Take my turn contributing
    ELSE:
        ACTION: DEFECT  # Let others carry the burden
        
ELSE IF surplus < 0 (threshold was NOT met):
    # Disaster occurred - need to rebuild cooperation
    IF prev_coop >= m - 2:
        # Close to threshold, worth trying to save
        ACTION: COOPERATE
    ELSE:
        # Cooperation collapsed badly - defect and conserve
        ACTION: DEFECT
```

**Step 4: Cooperation decay adjustment**
- Track the trend: Is cooperation increasing or decreasing over the last 3 rounds?
- If **decreasing trend** AND I was planning to defect: Cooperate instead (prevent collapse)
- If **increasing trend** AND I was planning to cooperate: Defect instead (exploit the growth)

### Late Rounds (r-1 and r): Endgame Exploitation

**Round r-1:**
```
IF prev_coop >= m + 1:
    ACTION: DEFECT  # Others likely to maintain cooperation
ELSE:
    ACTION: COOPERATE  # Need to keep threshold alive one more round
```

**Final Round r:**
```
IF prev_coop >= m:
    ACTION: DEFECT  # No future to preserve, maximize final payoff
ELSE:
    # Threshold wasn't met - cooperate only if I think it might help
    IF prev_coop == m - 1:
        ACTION: COOPERATE  # My vote might matter
    ELSE:
        ACTION: DEFECT  # Lost cause
```

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = m (everyone needed) | Always cooperate | No room for free-riding |
| m = 2 (low threshold) | Defect more aggressively | Easy for others to meet threshold |
| k is very large | Cooperate more readily | Disaster cost too high to risk |
| k is barely > 1 | Defect more | Reward barely worth the contribution |
| First round after disaster | Cooperate | Signal recovery attempt |
| Multiple consecutive disasters | Defect | Cooperation ecosystem dead |

---

## Pseudocode Summary

```
function decide(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE
    
    prev_coop = count_cooperators(history[round-1])
    my_recent_defects = count_my_defects(history, last=2)
    trend = cooperation_trend(history, last=3)
    
    # Endgame logic
    if round == r:
        return DEFECT if prev_coop >= m else (COOPERATE if prev_coop == m-1 else DEFECT)
    if round == r - 1:
        return DEFECT if prev_coop >= m + 1 else COOPERATE
    
    # Main exploitation logic
    surplus = prev_coop - m
    
    if surplus >= 1:
        action = DEFECT
    elif surplus == 0:
        action = COOPERATE if my_recent_defects >= 2 else DEFECT
    else:  # threshold missed
        action = COOPERATE if prev_coop >= m - 2 else DEFECT
    
    # Trend adjustment
    if trend == DECREASING and action == DEFECT:
        action = COOPERATE
    elif trend == INCREASING and action == COOPERATE and surplus >= 0:
        action = DEFECT
    
    return action
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: Defects whenever it's "safe" to let others carry the threshold
2. **Minimal contribution**: Only cooperates when absolutely necessary to prevent disaster
3. **Endgame defection**: Extracts maximum value when future cooperation doesn't matter
4. **Exploits cooperative players**: Takes advantage of unconditional cooperators and slower adaptive strategies
5. **Self-preserving**: Switches to cooperation when the ecosystem is about to collapse (protecting future exploitation opportunities)
'''

description_EXPLOITATIVE_128 = '''
# Exploitative Strategy for the Collective Risk Dilemma

## Core Philosophy

The key insight is that this game rewards **free-riding when the threshold is met** (payoff of 1+k) more than contributing (payoff of k). My strategy aims to:
1. Defect whenever I predict the threshold will be met without me
2. Cooperate only when my contribution is pivotal to reaching the threshold
3. Manipulate others into becoming reliable cooperators while I extract maximum value

---

## Strategy: "Reluctant Pivotal Defector" (RPD)

### Key Variables to Track

```
history[t] = list of (my_action, num_cooperators, threshold_met) for each round t
cooperation_rates[i] = rolling estimate of each player's cooperation probability
baseline_cooperation = overall cooperation rate across all players
```

### Decision Rules

#### **Round 1: Defect**
- Rationale: Gather information about opponent tendencies without sacrificing payoff
- Exception: If m/n > 0.7 (threshold is very high), cooperate to help establish cooperation norms that I can later exploit

#### **Rounds 2 through r-1: Adaptive Exploitation**

**Step 1: Estimate expected cooperators (excluding myself)**

```
expected_cooperators = sum of cooperation_rates for all other players
variance = estimate based on observed consistency
```

**Step 2: Apply decision logic**

```
IF expected_cooperators >= m + 1 (with high confidence):
    → DEFECT (free-ride; threshold met without me)
    
ELSE IF expected_cooperators is in range [m-1, m):
    → COOPERATE (I'm likely pivotal)
    
ELSE IF expected_cooperators < m - 1:
    → DEFECT (threshold unlikely even with my help; save my endowment)
    
ELSE (expected_cooperators approximately equals m, uncertain):
    → Use probabilistic cooperation based on:
       - Cooperate with probability = (k - 1) / k if k > 1
       - This is the mixed strategy equilibrium probability
```

**Step 3: Reputation Manipulation**

After 3+ consecutive rounds where threshold was NOT met:
- Cooperate for 1-2 rounds to "signal" willingness
- This encourages others to cooperate, restoring a pool I can exploit

#### **Final Round (Round r): Defect**
- No future rounds mean no retaliation possible
- Defect unconditionally unless my cooperation is certainly pivotal AND k > 2

---

### Exploitation Mechanisms

**1. Identifying "Suckers" (Reliable Cooperators)**
- Track players who cooperate >80% of the time
- When enough suckers exist (count ≥ m), always defect

**2. Punishing Cooperation Collapse**
- If threshold fails 2+ consecutive rounds, briefly cooperate to restart the cycle
- Then return to exploitation once cooperation is restored

**3. Threshold Manipulation**
- If I observe exactly m cooperators consistently, defect to test if one is tracking me
- If threshold still met, I've found a stable free-riding position

---

### Pseudocode

```
function decide_action(round, history, params):
    n, r, m, k = params
    
    # Final round: defect
    if round == r:
        return DEFECT
    
    # First round
    if round == 1:
        if m / n > 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Calculate cooperation estimates
    coop_rates = estimate_cooperation_rates(history)
    expected_coop = sum(coop_rates) - my_rate  # excluding self
    
    # Recent threshold failures - need to restore cooperation
    recent_failures = count_recent_failures(history, window=3)
    if recent_failures >= 2 and not_recently_cooperated(history, window=2):
        return COOPERATE  # Temporary cooperation to restore pool
    
    # Main decision logic
    confidence_margin = sqrt(expected_coop * (1 - avg_rate) / (n-1))
    
    if expected_coop - confidence_margin >= m:
        return DEFECT  # Safe to free-ride
    elif expected_coop + confidence_margin < m - 1:
        return DEFECT  # Hopeless, save endowment
    elif expected_coop >= m - 1 and expected_coop < m:
        return COOPERATE  # Likely pivotal
    else:
        # Uncertain region: mixed strategy
        p_cooperate = max(0, min(1, (k - 1) / k))
        return COOPERATE with probability p_cooperate, else DEFECT
```

---

### Edge Cases

| Situation | Action | Reason |
|-----------|--------|--------|
| n = m (everyone needed) | Cooperate rounds 1 to r-1, Defect round r | Must cooperate for threshold; defect when safe |
| m = 2, n large | Almost always defect | Easy threshold; others will cover |
| k very large (>5) | More willing to cooperate when pivotal | High reward justifies contribution |
| All others defecting | Defect | Cannot reach threshold alone |
| Observed coordination among others | Defect more aggressively | Others are solving the problem |

---

### Summary

This strategy exploits cooperative opponents by free-riding when safe, contributes only when pivotal, and occasionally cooperates strategically to maintain a cooperative environment worth exploiting. It maximizes personal payoff by treating others as resources to be leveraged rather than partners to coordinate with.
'''
